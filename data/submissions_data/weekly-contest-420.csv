username,userslug,contest_rank,question_id,language,code,submission_id
res,Res1StAnce7,1,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        res = 0
        for i in range(n):
            cnt = [0] * 26
            m = 0
            for j in range(i, n):
                idx = ord(s[j]) - 97
                cnt[idx] += 1
                m = max(m, cnt[idx])
                if m >= k:
                    res += 1
        return res",1427828224
res,Res1StAnce7,1,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        current = ''
        result = []
        
        for char in target:
            if not current:
                current += 'a'
                result.append(current)
            
            while current[-1] != char:
                current = current[:-1] + chr((ord(current[-1]) - ord('a') + 1) % 26 + ord('a'))
                result.append(current)
            
            if len(current) < len(target):
                current += 'a'
                result.append(current)
        
        return result",1427825634
res,Res1StAnce7,1,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], S: str) -> List[bool]:
        n = len(S)
        mod1, mod2 = 10**9 + 7, 10**9 + 9
        B1, B2 = 911, 3571
        max_len = n + 1

        pow_B1 = [1] * max_len
        pow_B2 = [1] * max_len
        for i in range(1, max_len):
            pow_B1[i] = (pow_B1[i - 1] * B1) % mod1
            pow_B2[i] = (pow_B2[i - 1] * B2) % mod2

        children = [[] for _ in range(n)]
        root = -1
        for i in range(n):
            if parent[i] == -1:
                root = i
            else:
                children[parent[i]].append(i)

        len_subtree = [0] * n
        H1 = [0] * n
        H2 = [0] * n
        HR1 = [0] * n
        HR2 = [0] * n
        answer = [False] * n

        def dfs(u):
            len_subtree[u] = 1
            H1_u, H2_u = 0, 0
            HR1_u = HR2_u = ord(S[u])
            for c in children[u]:
                dfs(c)
            for c in children[u]:
                H1_u = (H1_u * pow_B1[len_subtree[c]] + H1[c]) % mod1
                H2_u = (H2_u * pow_B2[len_subtree[c]] + H2[c]) % mod2
                len_subtree[u] += len_subtree[c]
            H1_u = (H1_u * B1 + ord(S[u])) % mod1
            H2_u = (H2_u * B2 + ord(S[u])) % mod2
            H1[u], H2[u] = H1_u, H2_u
            for c in reversed(children[u]):
                HR1_u = (HR1_u * pow_B1[len_subtree[c]] + HR1[c]) % mod1
                HR2_u = (HR2_u * pow_B2[len_subtree[c]] + HR2[c]) % mod2
            HR1[u], HR2[u] = HR1_u, HR2_u
            answer[u] = (H1[u] == HR1[u] and H2[u] == HR2[u])

        dfs(root)
        return answer",1427843054
res,Res1StAnce7,1,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:    
        def spf(x):
            if x <= 1:
                return x
            if x % 2 == 0:
                return 2
            max_div = int(math.isqrt(x)) + 1
            for i in range(3, max_div, 2):
                if x % i == 0:
                    return i
            return x  

        n = len(nums)
        ops = 0
        for i in range(n - 1, 0, -1):
            while nums[i - 1] > nums[i]:
                if nums[i - 1] == 1:
                    return -1
                factor = spf(nums[i - 1])
                if factor == nums[i - 1]:
                    return -1
                nums[i - 1] = factor
                ops += 1
                if nums[i - 1] > nums[i]:
                    if nums[i - 1] == 1:
                        return -1
                    return -1
        return ops",1427832330
arignote,arignote,3,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int sum = 0;
        for (int i = 0; i < s.length(); i++) {
            int[] count = new int[26];
            for (int j = i; j < s.length(); j++) {
                if ((++count[s.charAt(j) - 'a'] == k)) {
                    sum += s.length() - j;
                    break;
                }
            }
        }
        return sum;
    }
}",1427846352
arignote,arignote,3,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < target.length(); i++) {
            for (char c = 'a'; c <= target.charAt(i); c++) {
                list.add(target.substring(0, i) + c);
            }
        }
        return list;
    }
}",1427845946
arignote,arignote,3,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();
        for (int i = 1; i < parent.length; i++) {
            map.computeIfAbsent(parent[i], t -> new ArrayList<>()).add(i);
        }
        StringBuilder sb = new StringBuilder();
        int[][] range = new int[parent.length][2];
        findAnswer(0, sb, range, s, map);
        Manacher manacher = new Manacher("""" + sb);
        boolean[] result = new boolean[parent.length];
        for (int i = 0; i < parent.length; i++) {
            result[i] = manacher.p[range[i][0] + range[i][1] + 1] >= range[i][1] - range[i][0];
        }
        return result;
    }
    private void findAnswer(int k, StringBuilder sb, int[][] range, String s, HashMap<Integer, ArrayList<Integer>> map) {
        range[k][0] = sb.length();
        for (int i : map.getOrDefault(k, new ArrayList<>())) {
            findAnswer(i, sb, range, s, map);
        }
        sb.append(s.charAt(k));
        range[k][1] = sb.length();
    }
}

class Manacher {
    public int[] p;
    private String s;
    private char[] t;
    public Manacher(String s) {
        this.s = s;
        preprocess();
        p = new int[t.length];
        int center = 0, right = 0;
        for (int i = 1; i < t.length-1; i++) {
            int mirror = 2*center - i;
            if (right > i)
                p[i] = Math.min(right - i, p[mirror]);
            while (t[i + (1 + p[i])] == t[i - (1 + p[i])])
                p[i]++;
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }
        }
    }
    private void preprocess() {
        t = new char[s.length()*2 + 3];
        t[0] = '$';
        t[s.length()*2 + 2] = '@';
        for (int i = 0; i < s.length(); i++) {
            t[2*i + 1] = '#';
            t[2*i + 2] = s.charAt(i);
        }
        t[s.length()*2 + 1] = '#';
    }
}
",1427846821
arignote,arignote,3,3607,java,"class Solution {
    private static ArrayList<Integer> list = new ArrayList<>() {
        {
            boolean[] flag = new boolean[1000000];
            for (int i = 2; i < 1000000; i++) {
                if (!flag[i]) {
                    add(i);
                    for (int j = 2 * i; j < 1000000; j += i) {
                        flag[j] = true;
                    }
                }
            }
        }
    };
    public int minOperations(int[] nums) {
        int count = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                for (int j : list) {
                    if (nums[i] % j == 0) {
                        if ((nums[i] = j) > nums[i + 1]) {
                            return -1;
                        }
                        break;
                    }
                }
                count++;
            }
        }
        return count;
    }
}",1427846492
Abhishek Choudhary,theabbie,5,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        p = [[0] * 26 for _ in range(n + 1)]
        for i in range(n):
            for c in range(26):
                p[i + 1][c] = p[i][c] + int(c == ord(s[i]) - ord('a'))
        res = 0
        for i in range(n):
            beg = i
            end = n - 1
            while beg <= end:
                mid = (beg + end) // 2
                good = False
                for c in range(26):
                    if p[mid + 1][c] - p[i][c] >= k:
                        good = True
                        break
                if good:
                    end = mid - 1
                else:
                    beg = mid + 1
            res += n - end - 1
        return res",1427844492
Abhishek Choudhary,theabbie,5,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        s = """"
        for c in target:
            for x in range(ord(c) - ord('a') + 1):
                res.append(s + chr(ord('a') + x))
            s += c
        return res",1427838201
Abhishek Choudhary,theabbie,5,3603,python3,"class Solution:
    # s[i : j + 1] is palindrome if P[i + j + 2] >= j - i + 1
    def manachers(self, s):
        T = '#'.join('^{}$'.format(s))
        n = len(T)
        P = [0] * n
        C = R = 0
        for i in range(1, n - 1):
            if R > i:
                P[i] = min(R - i, P[2 * C - i])
            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1
            if i + P[i] > R:
                C, R = i, i + P[i]
        return P
    
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        graph = [[] for _ in range(n)]
        for i in range(1, n):
            graph[parent[i]].append(i)
        ctr = [0] * n
        pos = [0] * n
        v = []
        def dfs(i):
            ctr[i] += 1
            for j in sorted(graph[i]):
                dfs(j)
                ctr[i] += ctr[j]
            v.append(s[i])
            pos[i] = len(v) - 1
        dfs(0)
        pal = self.manachers("""".join(v))
        return [pal[2*pos[i]-ctr[i]+3]>=ctr[i] for i in range(n)]",1427834648
Abhishek Choudhary,theabbie,5,3607,python3,"MAX = 1 + 10 ** 6

v = [False] * MAX
sp = [0] * MAX

for i in range(2, MAX, 2):
    sp[i] = 2

for i in range(3, MAX, 2):
    if not v[i]:
        sp[i] = i
        j = i
        while j * i < MAX:
            if not v[j * i]:
                v[j * i] = True
                sp[j * i] = i
            j += 2

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        nums.reverse()
        res = 0
        for i in range(1, len(nums)):
            while nums[i] > nums[i - 1]:
                if nums[i] == sp[nums[i]]:
                    return -1
                nums[i] = sp[nums[i]]
                res += 1
        return res",1427851646
therealpratyushraman,therealpratyushraman,6,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
    int n = s.length(), totalCount = 0;
    for (int i = 0; i < n; i++) {
    int[] freq = new int[26];
    for (int j = i; j < n; j++) {
    freq[s.charAt(j) - 'a']++;
    for (int c = 0; c < 26; c++) {
    if (freq[c] >= k) {
    totalCount++;
    break;
    }
    }
    }
    }
    return totalCount;
    }
}",1427838247
therealpratyushraman,therealpratyushraman,6,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
public List<String> stringSequence(String target) {
List<String> result = new ArrayList<>();
StringBuilder screen = new StringBuilder();
int n = target.length();
for (int i = 0; i < n; i++) {
while (screen.length() < i + 1) {
screen.append('a');
result.add(screen.toString());
}
char ch = screen.charAt(i);
char targetChar = target.charAt(i);
int presses = (targetChar - ch + 26) % 26;
for (int p = 0; p < presses; p++) {
ch = (char)((ch - 'a' + 1) % 26 + 'a');
screen.setCharAt(i, ch);
result.add(screen.toString());
}
}
return result;
}
}
",1427828291
therealpratyushraman,therealpratyushraman,6,3603,java,"class Solution {
    static final int P = 911;
    static final int M = 1_000_000_007;
    public boolean[] findAnswer(int[] parent, String s) {
    int n = s.length();
    List<Integer>[] tree = new List[n];
    for(int i = 0; i < n; i++) tree[i] = new ArrayList<>();
    for(int i = 1; i < n; i++) tree[parent[i]].add(i);
    for(int i = 0; i < n; i++) Collections.sort(tree[i]);
    int[] start = new int[n], end = new int[n];
    int[] traversal = new int[n + 1];
    int[] powP = new int[n + 2];
    powP[0] = 1;
    for(int i = 1; i <= n + 1; i++) powP[i] = (int)((long)powP[i - 1] * P % M);
    int[] pos = new int[1];
    dfs(0, tree, s, start, end, traversal, pos);
    long[] prefixHash = new long[n + 1], reversePrefixHash = new long[n + 2];
    for(int i = 1; i <= n; i++)
    prefixHash[i] = (prefixHash[i - 1] * P + traversal[i]) % M;
    for(int i = n; i >= 1; i--)
    reversePrefixHash[i] = (reversePrefixHash[i + 1] * P + traversal[i]) % M;
    boolean[] answer = new boolean[n];
    for(int i = 0; i < n; i++) {
    int l = start[i], r = end[i];
    long h1 = (prefixHash[r] - prefixHash[l - 1] * powP[r - l + 1] % M + M) % M;
    long h2 = (reversePrefixHash[l] - reversePrefixHash[r + 1] * powP[r - l + 1] % M + M) % M;
    answer[i] = h1 == h2;
    }
    return answer;
    }
    void dfs(int u, List<Integer>[] tree, String s, int[] start, int[] end, int[] traversal, int[] pos) {
    start[u] = pos[0] + 1;
    for(int v : tree[u]) dfs(v, tree, s, start, end, traversal, pos);
    traversal[++pos[0]] = s.charAt(u) - 'a' + 1;
    end[u] = pos[0];
    }
}",1427852474
therealpratyushraman,therealpratyushraman,6,3607,java,"class Solution {
    public int minOperations(int[] nums) {
    int maxNum = 1000000;
    int[] spf = new int[maxNum + 1];
    for (int i = 0; i <= maxNum; i++) spf[i] = i;
    for (int i = 2; i * i <= maxNum; i++) {
    if (spf[i] == i) {
    for (int j = i * i; j <= maxNum; j += i) {
    if (spf[j] == j) spf[j] = i;
    }
    }
    }
    int n = nums.length;
    int INF = Integer.MAX_VALUE / 2;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = INF;
    int spfNum = spf[nums[0]];
    if (spfNum != nums[0]) dp[0][1] = 1;
    for (int i = 1; i < n; i++) {
    dp[i][0] = dp[i][1] = INF;
    int spf_i = spf[nums[i]];
    boolean canReduce = spf_i != nums[i];
    int[] prevValues = new int[2];
    prevValues[0] = nums[i - 1];
    prevValues[1] = spf[nums[i - 1]] != nums[i - 1] ? spf[nums[i - 1]] : -1;
    for (int prevState = 0; prevState <= 1; prevState++) {
    if (dp[i - 1][prevState] >= INF) continue;
    int prevValue = prevState == 0 ? nums[i - 1] : prevValues[1];
    if (prevValue == -1) continue;
    if (nums[i] >= prevValue) dp[i][0] = Math.min(dp[i][0], dp[i - 1][prevState]);
    if (canReduce && spf_i >= prevValue) dp[i][1] = Math.min(dp[i][1], dp[i - 1][prevState] + 1);
    }
    if (dp[i][0] >= INF && dp[i][1] >= INF) return -1;
    }
    int ans = Math.min(dp[n - 1][0], dp[n - 1][1]);
    return ans >= INF ? -1 : ans;
    }
}",1427840501
BarryBondsOfLC,BarryBondsOfLC,7,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        for (int i = 0; i < n; ++i) {
            array<int, 26> fm = {0};
            int mx = 0;
            for (int j = i; j < n; ++j) {
                mx = max(mx, ++fm[s[j] - 'a']);
                if (mx >= k) ++res;
            }
        }
        
        return res;
    }
};",1427825463
BarryBondsOfLC,BarryBondsOfLC,7,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr;
        
        for (auto c : target) {
            curr.push_back('a');
            res.push_back(curr);
            while (curr.back() != c) {
                ++curr.back();
                res.push_back(curr);
            }
        }
        
        return res;
    }
};",1427823833
BarryBondsOfLC,BarryBondsOfLC,7,3603,python3,"P = 911382629
MOD = 18446744073709551557
MX = int(1e5)
P_pows = [1] * (MX + 1)
for i in range(1, MX + 1):
    P_pows[i] = (P_pows[i - 1] * P) % MOD

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        G = [[] for _ in range(n)]
        
        for u in range(1, n):
            G[parent[u]].append(u)
            
        hashes = [0] * n
        rev_hashes = [0] * n
        length = [0] * n
        
        def dfs(x):
            hs = 0
            sz = 0
            for y in G[x]:
                dfs(y)
                hs = (hs * P_pows[length[y]] + hashes[y]) % MOD
                sz += length[y]
            hs = (hs * P + ord(s[x])) % MOD
            hashes[x] = hs
            sz += 1
            length[x] = sz
            
            rev_hs = ord(s[x])
            for y in reversed(G[x]):
                rev_hs = (
                    rev_hs * P_pows[length[y]] + rev_hashes[y]
                ) % MOD
            rev_hashes[x] = rev_hs

        dfs(0)

        res = [False] * n
        for x in range(n):
            if hashes[x] == rev_hashes[x]:
                res[x] = True

        return res",1427852502
BarryBondsOfLC,BarryBondsOfLC,7,3607,cpp,"int MX = 1e6;

struct Divisors {
    vector<int> fs;
    Divisors() : fs(MX + 1) {
        for (int p = 2; p <= MX; ++p) {
            for (int q = 2 * p; q <= MX; q += p) {
                fs[q] = p;
            }
        }
    }  
} divisors;

class Solution {
public:
    int minOperations(vector<int>& A) {
        int n = A.size(), res = 0;
        for (int i = n - 2; i >= 0; --i) {
            if (A[i] > A[i + 1]) {
                auto f = divisors.fs[A[i]];
                if (f == 0) return -1;
                if ((A[i] /= f) > A[i + 1]) return -1;
                ++res;
            }
        }
        
        return res;
    }
};",1427837406
Ethan,ethanrao,8,3502,cpp,"class Solution {
public:
    int t[26][3005], cnt[26];
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();
        for(int i = 0; i < n; ++i){
            int r = s[i] - 'a';
            t[r][++cnt[r]] = i;
            int u = -1;
            for(int j = 0; j < 26; ++j)
                if(cnt[j] >= k)
                    u = std::max(u, t[j][cnt[j] - k + 1]);
            ans += u + 1;
        }
        return ans;
    }
};",1427852731
Ethan,ethanrao,8,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string prefix = """";
        for (int i = 0; i < target.size(); ++i) {
            
            for (int k = 0; k < 26; ++k) {
                char ch = char(('a' + k) ); 
                string tt= prefix+ch;
                res.push_back(tt);
                if(ch==target[i]){
                    break;
                }
            }
            prefix+=target[i];
        }
        return res;
    }
};
",1427845687
Ethan,ethanrao,8,3603,cpp,"class Solution {
public:
    int siz[100005], f[100005], g[100005], n, val[100005], pw[100005];
    bool ans[100005];
    std::vector <int> son[100005];
    const int mod = 998244853, base = 41;
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int minus(int x, int y){
        return x < y ? x - y + mod : x - y;
    }
    void dfs(int x){
        siz[x] = 1;
        for(auto v: son[x]){
            dfs(v);
            siz[x] += siz[v];
        }
        for(int i = 0; i < son[x].size(); ++i){
            int v = son[x][i];
            f[x] = mul(f[x], pw[siz[v]]);
            f[x] = add(f[x], f[v]);
        }
        f[x] = mul(f[x], pw[1]);
        f[x] = add(f[x], val[x]);
        
        g[x] = val[x];
        for(int i = son[x].size() - 1; i >= 0; --i){
            int v = son[x][i];
            g[x] = mul(g[x], pw[siz[v]]);
            g[x] = add(g[x], g[v]);
        }
        if(f[x] == g[x]) ans[x] = true;
        else ans[x] = false;
        return ;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        n = parent.size();
        pw[0] = 1;
        for(int i = 1; i <= n; ++i) pw[i] = mul(pw[i - 1], base);
        for(int i = 0; i < n; ++i){
            val[i] = s[i] - 'a' + 10;
            if(i != 0) son[parent[i]].push_back(i);
        }
        dfs(0);
        std::vector <bool> res; res.resize(n);
        for(int i = 0; i < n; ++i) res[i] = ans[i];
        return res;
    }
};",1427843430
Ethan,ethanrao,8,3607,cpp,"class Solution {
public:
    int p[1005], cnt = 0, vis[1005];
    int minOperations(vector<int>& nums) {
        for(int i = 1; i <= 1000; ++i) vis[i] = 1;
        vis[1] = 0;
        for(int i = 2; i <= 1000; ++i){
            if(vis[i]) p[++cnt] = i;
            for(int j = 1; j <= cnt && i * p[j] <= 1000; ++j){
                vis[i * p[j]] = 0;
            }
        }
        int n = nums.size(), ans = 0, lst = 1000000;
        for(int i = n - 1; i >= 0; --i){
            if(nums[i] <= lst){
                lst = nums[i];
                continue;
            }
            int f = -1;
            for(int j = 1; j <= cnt; ++j)
                if(nums[i] % p[j] == 0){
                    f = p[j];
                    break;
                }
            if(f == -1 || f > lst) return -1;
            ans += 1;
            lst = f;
        }
        return ans;
    }
};",1427830038
SR3mix,SR3mix,9,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<vector<int>>v(26); int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            int c = s[i] - 'a';
            v[c].push_back(i);
            int ma = -1;
            for (int j = 0; j < 26; j++) {
                if (v[j].size() >= k) ma = max(ma, v[j][v[j].size() - k]);
            }
            
            ans += (ma + 1);
        }
        return ans;
    }
};",1427849960
SR3mix,SR3mix,9,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string curr = """";
        int n = target.size();
        for (int i = 0; i < n; i++) {
            int c = target[i] - 'a';
            curr.push_back('_');
            for (int j = 0; j <= c; j++) {
                curr.pop_back();
                char add = 'a'; add += j;
                curr.push_back(add);
                ans.push_back(curr);
            }
        }
        return ans;
    }
};",1427853028
SR3mix,SR3mix,9,3603,cpp,"class StringHash {
public:
    vector<long long>ps1,ps2;
    vector<long long>powq1,powq2;
    long long Q1 = 271, Q2 = 277, M1 = 1000000007, M2 = 998244353;
    StringHash(string s) {
        ps1 = vector<long long>(s.size()+1); ps2 = vector<long long>(s.size()+1);
        powq1 = {1}; powq2 = {1};
        for (int i = 1; i <= s.size(); i++) {
            long long c = s[i-1] + 1;
            ps1[i] = ((Q1 * ps1[i-1]) + c)%M1;
            ps2[i] = ((Q2 * ps2[i-1]) + c)%M2;
            powq1.push_back((powq1.back() * Q1)%M1);
            powq2.push_back((powq2.back() * Q2)%M2);
        }
    }
    long long substrHash1(int firstIndex, int lastIndex) {
        long long rem = (powq1[lastIndex - firstIndex + 1] * ps1[firstIndex])%M1;
        return (ps1[lastIndex+1] - rem + M1)%M1;
    }
    long long substrHash2(int firstIndex, int lastIndex) {
        long long rem = (powq2[lastIndex - firstIndex + 1] * ps2[firstIndex])%M2;
        return (ps2[lastIndex+1] - rem + M2)%M2;
    }
    pair<long long, long long> substrHash(int firstIndex, int lastIndex) {
        return {substrHash1(firstIndex, lastIndex), substrHash2(firstIndex, lastIndex)};
    }
}; 

class EulerTourTree {
public:
    vector<int>tin,tout,depth;
    vector<vector<int>>e;
    int n,timer;
    void dfs(int curr, int p) {
        if (p != -1) depth[curr] = depth[p] + 1;
        tin[curr] = timer;
        for (auto node : e[curr]) if (node != p) dfs(node,curr);
        tout[curr] = timer++;
    }
    EulerTourTree(int n, vector<vector<int>> edges, int root) {
        tin = vector<int>(n); tout = tin; depth = tin;
        e = edges;
        timer = 0;
        dfs(root,-1);
    }
};
// CREDIT TO CP-Algorithms FOR THIS TEMPLATE -> https://cp-algorithms.com/graph/lca_binary_lifting.html#implementation

class Solution {
public:
    int n;
    vector<vector<int>>e;
    vector<int>order;
    string s;
    
    vector<bool> findAnswer(vector<int>& parent, string ss) {
        n = parent.size(); s = ss;
        e = vector<vector<int>>(n);
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) e[parent[i]].push_back(i);
        }
        for (auto &i : e) sort(i.begin(), i.end());
        EulerTourTree ET(n, e, 0);
        // for (auto i : ET.tin) cout << i << "","";
        // cout << endl;
        // for (auto i : ET.tout) cout << i << "","";
        // cout << endl;
        vector<char>v(n);
        for (int i = 0; i < n; i++) {
            v[ET.tout[i]] = s[i];
        }
        string res = """";
        for (auto i : v) res += i;
        string rev = res; reverse(rev.begin(), rev.end());
        // cout << res << endl;
        // cout << rev << endl;
        StringHash SHF(res);
        StringHash SHR(rev);
        vector<bool>ans;
        for (int i = 0; i < n; i++) {
            int l = ET.tin[i];
            int r = ET.tout[i];
            //cout << i << "": "" << l << "","" << r << endl; 
            auto F = SHF.substrHash(l, r);
            auto R = SHR.substrHash(n - r - 1, n - l - 1);
            if (F == R) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
    }
};",1427839109
SR3mix,SR3mix,9,3607,cpp,"class Math {
    public:
    vector<long long> fact_vec,invfact_vec;
    vector<long long> fact_vec_pure;
    vector<long long> e10_vec;
    vector<int>primes,minp,isprime,phi;
    long long comb_M = -1;
    long long int powxy(long long int x, long long int y, long long M) {
        if (y == 0) return 1;
        if (y%2 == 1) return (x*powxy(x, y-1,M))%M;
        long long int t = powxy(x, y/2,M);
        return (t*t)%M;
    }
    void create_comb(long long maxChooseNumerator, long long M) {
        comb_M = M;
        if (fact_vec.size() > maxChooseNumerator) return;
        if (fact_vec.size() == 0) {
            fact_vec = {1,1};
            invfact_vec = {1,1};
        }
        long long startI = fact_vec.size();
        for (long long i = startI; i <= maxChooseNumerator+1; i++) {
            long long lastFact = fact_vec.back();
            long long currFact = (lastFact * i)%M;
            fact_vec.push_back(currFact);
        }
        invfact_vec.resize(fact_vec.size());
        invfact_vec[fact_vec.size()-1] = powxy(fact_vec.back(), M-2, M);
        for (long long i = maxChooseNumerator; i >= startI; i--) {
            long long lastInv = invfact_vec[i+1];
            long long currInv = (lastInv * (i+1))%M;
            invfact_vec[i] = currInv;
        }
    }
    long long factorial(long long n, long long M) {
        assert(comb_M == M);
        return fact_vec[n];
    }
    long long inv_factorial(long long n, long long M) {
        assert(comb_M == M);
        return invfact_vec[n];
    }
    long long comb(long long a, long long b, long long M) {
        assert(comb_M == M);
        return (((fact_vec[a] * invfact_vec[b])%comb_M) * invfact_vec[a-b])%comb_M;
    }
    long long mgcd(long long a, long long b, long long& x, long long& y) {
        if (b == 0) {x = 1; y = 0; return a;}
        long long x1, y1;
        long long d = mgcd(b, a % b, x1, y1);
        x = y1;
        y = x1 - y1 * (a / b);
        return d;
    }
    long long moddiv(long long a, long long  b, long long M) {
        a = a%M;
        long long x,y;
        long long g = mgcd(b,M,x,y);
        long long inv = (x%M + M)%M;
        return (inv * a)%M;
    }
    long long comb_pure(long long a, long long b) {
        long long numer = factorial_pure(a);
        long long denom1 = factorial_pure(b);
        long long denom2 = factorial_pure(a - b);
        return numer/(denom1 * denom2);
    }
    long long factorial_pure(long long n) {
        assert(n <= 20);
        if (fact_vec_pure.size() == 0) fact_vec_pure.push_back(1);
        while (fact_vec_pure.size() <= n) {
            long long val = fact_vec_pure.size();
            fact_vec_pure.push_back(fact_vec_pure.back() * val);
        }
        return fact_vec_pure[n];
    }
    long long exp10(int p) {
        assert(p <= 18);
        if (e10_vec.size() == 0) e10_vec.push_back(1);
        while (e10_vec.size() <= p) {
            e10_vec.push_back(e10_vec.back() * 10LL);
        }
        return e10_vec[p];
    }
    unsigned long long comb_2(unsigned long long num) {
        if (num%2 == 0) {return (num/2) * (num-1);}
        else {return ((num-1)/2) * num;}
    }
    long long safe_sqrt(long long x) {
        long long l = 0, r = x;
        while (l < r) {
            long long m = l + (r-l)/2 + (r-l)%2;
            long long allow = LLONG_MAX/m;
            if (m <= allow && m * m <= x) l = m;
            else r = m-1;
        }
        return l;
    }
    long long arith_seq_sum(long long first, long long last, long long diff) {
        long long endSum = first + last;
        long long nums = ((last - first)/diff) + 1;
        
        if (endSum%2 == 0) {return (endSum/2) * nums;}
        else {return (nums/2) * endSum;}
    }
    void SievePrimes(int n) {
        if (minp.size() == n+1) return;
        minp = vector<int>(n+1), isprime = minp;
        primes = {};
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {if (i * p > n) break; minp[i*p]=p;}
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    void SieveFull(int n) {
        if (phi.size() == n+1) return;
        phi = vector<int>(n+1);
        minp = vector<int>(n+1);
        isprime = phi;
        primes = {};
        phi[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                phi[i] = i - 1;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {
                if (i * p > n) {
                    break;
                }
                minp[i * p] = p;
                if (p == minp[i]) {
                    phi[i * p] = phi[i] * p;
                    break;
                }
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    vector<array<long long, 2>> prime_factorize(long long num) {
        vector<array<long long, 2>>res;
        for (auto p : primes) {
            if (p > num) break;
            int cnt = 0;
            while (num%p == 0) {
                num /= p;
                cnt++;
            }
            if (cnt) res.push_back({p,cnt});
        }
        if (num > 1) res.push_back({num,1});
        return res;
    }
    vector<int> get_factors(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        vector<int>res;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) res.push_back(i);
        }
        int start = res.size() - 1;
        for (int i = start; i >= 0; i--) {
            if ((num/res[i]) != res[i]) res.push_back(num/res[i]);
        }
        return res;
    }
    vector<int> get_factors_robust(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        set<int>s;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) {s.insert(i); s.insert(num/i);}
        }
        vector<int>res; for (auto i : s) res.push_back(i);
        return res;
    }
    vector<vector<long long>> matmul(vector<vector<long long>>&mat1, vector<vector<long long>>&mat2, long long M) {
        assert(mat1[0].size() == mat2.size());
        int m = mat1.size(), n = mat2[0].size();
        vector<vector<long long>>mat(m, vector<long long>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < mat1[0].size(); k++) {
                    long long add = mat1[i][k] * mat2[k][j];
                    if (M > 0) add %= M;
                    mat[i][j] += add;
                    if (M > 0) mat[i][j] %= M;
                }
            }
        }
        return mat;
    }
    vector<vector<long long>> mateye(int n) {
        vector<vector<long long>>res(n, vector<long long>(n));
        for (int i = 0; i < n; i++) res[i][i] = 1;
        return res;
    }
    vector<vector<long long>> matexp(vector<vector<long long>>&mat, long long p, long long M) {
        if (p == 0) return mateye(mat.size());
        if (p == 1) return mat;
        vector<vector<long long>>mat1 = matexp(mat, p/2, M);
        vector<vector<long long>>res = matmul(mat1, mat1, M);
        if (p%2) return matmul(res, mat, M);
        return res;
    }
    long long first_bit(long long num) {
        if (num == 0) return -1;
        if (num > INT_MAX) return 64 - __builtin_clzll(num) - 1;
        else return 32 - __builtin_clz(num) - 1;
    }
    long long log2(long long num) {
        return first_bit(num);
    }
    long long last_bit(long long num) {
        return __builtin_ctzll(num);
    }
    long long frombin(string &s) {
        long long res = 0;
        for (int shift = 0; shift < s.size(); shift++) {
            if (s[s.size() - shift - 1] == '1') {
                res += (1LL << shift);
            }
        }
        return res;
    }
    string tobin(long long num, int len) {
        string res = """"; for (int i = 0; i < len; i++) res += '0';
        for (int shift = 0; shift < 63; shift++) {
            if ((num & (1LL << shift)) != 0) res[len - shift - 1] = '1';
        }
        return res;
    }
    string toBase(long long n, long long b) {
        bool neg = false;
        if (n < 0) {neg = true;}
        n = abs(n);
        string ans = """";
        while (n > 0) {
            ans += to_string(n%b);
            n /= b;
        }
        if (ans.size() == 0) ans = ""0"";
        if (neg) ans += ""-"";
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
Math math;


class Solution {
public:
    int minOperations(vector<int>& nums) {
        math.SieveFull(1e6 + 5);
        int ans = 0; int n = nums.size();
        if (nums.size() == 1) return ans;
        for (int i = n-2; i >= 0; i--) {
            while (nums[i] > nums[i+1]) {
                if (nums[i] > nums[i+1] && math.minp[nums[i]] == nums[i]) return -1;
                nums[i] = math.minp[nums[i]];
                ans++;
            }
        } 
        return ans;
    }
};",1427845542
4dalols,4dalols,11,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),ans=0; 
        for (int i = 0,j; i < n; i++) {
            vector<int> c(26); 
            for (j = i; ~j; j--) {
                c[s[j]-'a']++;
                if (c[s[j]-'a']>=k) break; 
            }
            ans+=j+1; 
        }
        return ans;
    }
};",1427850623
4dalols,4dalols,11,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> v;
        int n = t.size();
        string s=""""; 
        for (int i = 0; i < n; i++) {
            s+=""a""; v.push_back(s); 
            while (s[i]!=t[i]) {
                s[i]++; v.push_back(s); 
            }
        }
        return v;
    }
};",1427854271
4dalols,4dalols,11,3603,cpp,"class Solution {
public:
    #define ll long long
    string a;
    vector<vector<int>> c;
    vector<int> tin, tout;
    static const ll M = (1LL << 61) - 1;
    static const ll B1 = 1e17+69, B2 = 1e17-69;
    
    vector<vector<ll>> pw = {{1},{1}};
    
    vector<vector<ll>> p_hash;
    
    __int128 mul(ll a, ll b) { return (__int128)a * b; }
    ll mod_mul(ll a, ll b) { return mul(a, b) % M; }
    
    ll HashedString(string &s, int a, ll B, bool h) {
        if (h) p_hash[a].resize(s.size()+1);
        while (pw[a].size() <= s.size()) { pw[a].push_back(mod_mul(pw[a].back(), B)); }
        ll cur=0;
        for (int i = 0; i < s.size(); i++) {
            cur = (mul(cur, B) + s[i]) % M;
            if (h) p_hash[a][i+1]=cur;
        }
        return cur;
    }
    
    ll getHash(int start, int end, int x) {
        ll raw_val =
            p_hash[x][end + 1] - mod_mul(p_hash[x][start], pw[x][end - start + 1]);
        return (raw_val>=0?raw_val:raw_val+M);
    }
    void dfs(int n, string &t) {
        tin[n]=a.size();
        for (int r:c[n]) dfs(r,t);
        tout[n]=a.size(); 
        a+=t[n]; 
    }
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n=s.size(); 
        p_hash.resize(2);
        a=""""; c.clear(); c.resize(n);
        tin.resize(n); tout=tin; 
        for (int i = 1; i < n; i++) c[p[i]].push_back(i); 
        dfs(0,s); 
        vector<bool> b(n); 
        HashedString(a,0,B1,1); 
        reverse(a.begin(),a.end());
        HashedString(a,1,B1,1); 
        for (int i = 0; i < n; i++) {
            b[i]=(getHash(tin[i],tout[i],0)==getHash(n-tout[i]-1,n-tin[i]-1,1));
        }
        return b;
    }
};",1427838224
4dalols,4dalols,11,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& v) {
        int n=v.size(),ans=0;
        for (int i=n-2; ~i; i--) {
            if (v[i]<=v[i+1]) continue; 
            for (int j = 2; j*j<=v[i]&&j<=v[i+1]; j+=(j%2+1)) {
                if (v[i]%j<1) {
                    v[i]=j; break; 
                }
            }
            if (v[i]>v[i+1]) return -1; 
            ans++; 
        }
        return ans;
    }
};",1427844104
SK_MysticCoder,sk8126,12,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int result = 0;

        for (int start = 0; start < n; ++start) {
            unordered_map<char, int> freq;
            for (int end = start; end < n; ++end) {
                freq[s[end]]++;
                // Check if any character appears at least k times
                for (auto &[ch, count] : freq) {
                    if (count >= k) {
                        result++;
                        break;
                    }
                }
            }
        }

        return result;
    }
};
",1427824121
SK_MysticCoder,sk8126,12,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        
        for (char c : target) {
            current += 'a';  // Step 1: Press key 1 to append 'a'
            result.push_back(current);
            
            // Step 2: Increment the last character to match target character
            while (current.back() != c) {
                current.back() = current.back() + 1;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427823664
SK_MysticCoder,sk8126,12,3603,cpp,"class Solution {
public:
    const int base = 911;
    const long long mod = 1000000007;

    
    void computePowers(vector<long long> &pow_p, int max_len) {
        pow_p.resize(max_len + 1, 1);
        for(int i = 1; i <= max_len; ++i){
            pow_p[i] = (pow_p[i-1] * base) % mod;
        }
    }

    
    struct NodeInfo {
        int len;             
        long long hash_fwd;  
        long long hash_rev;  
    };

   
    NodeInfo dfs(int node, const vector<vector<int>> &tree, const string &s, const vector<long long> &pow_p, vector<bool> &answer) {
        NodeInfo info;
        info.len = 1;
        info.hash_fwd = (s[node] - 'a' + 1) % mod;
        info.hash_rev = (s[node] - 'a' + 1) % mod;

        
        vector<NodeInfo> children_info;

        
        for(auto child : tree[node]){
            NodeInfo child_info = dfs(child, tree, s, pow_p, answer);
            children_info.push_back(child_info);
        }

       
        info.hash_fwd = 0;
        int total_len = 0;
        for(auto &child_info : children_info){
            info.hash_fwd = (info.hash_fwd * pow_p[child_info.len] + child_info.hash_fwd) % mod;
            total_len += child_info.len;
        }
        info.len = total_len + 1; 
        info.hash_fwd = (info.hash_fwd * pow_p[1] + (s[node] - 'a' + 1)) % mod;

        
        info.hash_rev = (s[node] - 'a' + 1) % mod;
        for(int i = children_info.size() -1; i >=0; --i){
            info.hash_rev = (info.hash_rev * pow_p[children_info[i].len] + children_info[i].hash_rev) % mod;
        }

        
        answer[node] = (info.hash_fwd == info.hash_rev);

        return info;
    }

    
    vector<bool> checkPalindromeDFS(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n, vector<int>());
        int root = -1;

        
        for(int i =0; i<n; ++i){
            if(parent[i] == -1){
                root = i;
            }
            else{
                tree[parent[i]].push_back(i);
            }
        }

        
        vector<long long> pow_p;
        computePowers(pow_p, n);

       
        vector<bool> answer(n, false);

       
        dfs(root, tree, s, pow_p, answer);

        return answer;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        return checkPalindromeDFS(parent, s);
    }
};
",1427846905
SK_MysticCoder,sk8126,12,3607,cpp,"#include <vector>
#include <cmath>

class Solution {
public:
   
    int smallestPrimeFactor(int x) {
        if (x % 2 == 0) return 2;
        for (int i = 3; i <= sqrt(x); i += 2) {
            if (x % i == 0) return i;
        }
        return x; 
    }

    int minOperations(std::vector<int>& nums) {
        int operations = 0;
        int n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            
            if (nums[i] <= nums[i + 1]) {
                continue;
            }

           
            if (nums[i] == 1) {
                return -1;
            }

            
            int spf = smallestPrimeFactor(nums[i]);
            nums[i] = spf;
            operations += 1;

           
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
        }
        return operations;
    }
};
",1427829701
Chinedu,profchi,16,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        
        int [] count = new int [26];
        
        int total = 0;
        
        for (int i = 0; i < s.length(); ++i) {
            Arrays.fill(count, 0);
            int val;
            boolean seen = false;
            
            for (int j = i; j < s.length(); ++j) {
                val = s.charAt(j) - 'a';
                
                count[val]++;
                
                if (count[val] == k)
                    seen = true;
                
                total += seen ? 1 : 0;
            }
        }
        
        return total;
    }
}",1427826638
Chinedu,profchi,16,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        
        String current = """";
        
        List<String> result = new ArrayList<>();
        
        for (char c : target.toCharArray()) {
            
            for (char x = 'a'; x <= c; ++x) {
                result.add(current + x);
            }
            
            current += c;
        }
        
        return result;
    }
}",1427824352
Chinedu,profchi,16,3603,java,"class Solution {
    
    List<Integer> [] graph;
    
    int [][] pos;
    
    int idx;
    
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        
        graph = new List[n];
        
        for (int i = 0; i < n; ++i) {
            graph[i] = new ArrayList<>();
        }
        
        for (int i = 1; i < n; ++i) {
            graph[parent[i]].add(i);
        }
        
        StringBuilder sb = new StringBuilder();
        pos = new int [n][2];
        
        dfs(0, sb, s);
        
        String val = sb.toString();
        
        boolean [] res = new boolean [n];
        
        RollingHashLong roll = RollingHashLong.getHashFromString(val, 30, 1_000_000_007);
        
        int a, b;
        
        for (int i = 0; i < n; ++i) {
            a = pos[i][0];
            b = pos[i][1];
            
            res[i] = roll.getHashLong(a, b) == roll.getHashLong(b, a);
        }
        
        return res;
    }
    
    private void dfs(int node, StringBuilder sb, String s) {
        
        pos[node][0] = sb.length();
        
        
        for (int child : graph[node]) {
            dfs(child, sb, s);
        }
        
        
        pos[node][1] = sb.length();
        sb.append(s.charAt(node));
    }
    
    
}
class RollingHashLong {
	
	long [] mArr;
	long [] forwardArr;
	long [] backArr;
	
	
	long [] mArr2;
	long [] forwardArr2;
	long [] backArr2;
	
	
	int [] requestArr;
	int reqMul, reqMul2;
	
	long mod, mod2;
	
	static Random rand = new Random();
	
	static int addMul =  1_005 + rand.nextInt(100);
	static int addMod = 1_000_016 + 2 * rand.nextInt(100_000);
	
	// lower case alpha
	public static RollingHashLong getHashFromString(String s, int mul, int mod) {
		int [] arr = new int[s.length()];
		
		for (int i = 0; i < s.length(); ++i) {
			arr[i] = s.charAt(i) - 'a';
		}
		
		return new RollingHashLong(arr, mul, mod);
	}
	
	// zero indexex
	public RollingHashLong(int [] arr, int mul, int mod) {
		
		long cHash = 0;
		long mHash = 1;
		
		mArr = new long [arr.length + 1];
		forwardArr = new long [arr.length];
		backArr = new long [arr.length];
		
		this.mod = mod;
		this.requestArr = arr;
		this.reqMul = mul;
		
		mArr[0] = 1;
		
		for (int i = 0; i < arr.length; ++i) {
			cHash *= mul;
			cHash += arr[i];
			cHash %= mod;
			
			forwardArr[i] = cHash;
			
			mHash *= mul;
			mHash %= mod;
			
			mArr[i + 1] = mHash;
		}
		
		cHash = 0;
		
		for (int i = arr.length - 1; i >= 0; --i) {
			cHash *= mul;
			cHash += arr[i];
			cHash %= mod;
			
			backArr[i] = cHash;
		}
		
		
		
		
		
		
		cHash = 0;
		mHash = 1;
		
		mArr2 = new long [arr.length + 1];
		forwardArr2 = new long [arr.length];
		backArr2 = new long [arr.length];
		
		this.mod2 = mod + addMod;
		this.reqMul2 = mul + addMul;
		int mul2 = reqMul2;
		
		mArr2[0] = 1;
		
		for (int i = 0; i < arr.length; ++i) {
			cHash *= mul2;
			cHash += arr[i];
			cHash %= mod2;
			
			forwardArr2[i] = cHash;
			
			mHash *= mul2;
			mHash %= mod2;
			
			mArr2[i + 1] = mHash;
		}
		
		cHash = 0;
		
		for (int i = arr.length - 1; i >= 0; --i) {
			cHash *= mul2;
			cHash += arr[i];
			cHash %= mod2;
			
			backArr2[i] = cHash;
		}
	}
	
	public long getHashLong(int from, int to) {
        // System.out.println(from + "" "" + to);
		long hash = getHash(from, to, forwardArr, backArr, mArr, mod);
		hash *= mod2;
		hash += getHash(from, to, forwardArr2, backArr2, mArr2, mod2);
		return hash;
	}
	
	// abcdefg
	// def - abcdef - abc * 3
	
	private long getHash(int from, int to, 
			long [] forwardArr, long [] backArr, long [] mArr, long mod) {
		
		long result;
		int prev;
		
		if (to >= from) {
			result = forwardArr[to];
			prev = from - 1;
			
			long sub = prev == -1 ? 0 : forwardArr[prev];
			sub *= mArr[to - prev];
			sub %= mod;
			
			result += mod;
			result -= sub;
			result %= mod;
		}else {
			result = backArr[to];
			prev = from + 1;
			
			long sub = prev == backArr.length ? 0 : backArr[prev];
			sub *= mArr[prev - to];
			sub %= mod;
			
			result += mod;
			result -= sub;
			result %= mod;
		}
		
		return result;
	}
}


",1427855862
Chinedu,profchi,16,3607,java,"class Solution {
    
    static int [] maxDiv;
    
    static {
        int length = 1_000_001;
        maxDiv = new int [length];
        
        for (int i = 1; i < length; ++i) {
            for (int j = 2 * i; j < length; j += i) {
                maxDiv[j] = i;
            }
        }
    }
    
    public int minOperations(int[] nums) {
        
        int max;
        
        int total = 0;
        
        for (int i = nums.length - 2; i >= 0; --i) {
            
            while (nums[i] > nums[i + 1]) {
                max = maxDiv[nums[i]];
                
                if (max < 2)
                    return -1;
                
                ++total;
                
                nums[i] /= max;
            }
        }
        
        return total;
    }
}",1427834481
penguinhacker,penguinhacker,17,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int cnt[26]={};
        int ans=0;
        for (int j=0, i=0; i<s.size(); ++i) {
            ++cnt[s[i]-'a'];
            while(*max_element(cnt, cnt+26)>=k) {
                --cnt[s[j]-'a'];
                ++j;
            }
            if (j) {
                --j;
                ++cnt[s[j]-'a'];
            }
            if (*max_element(cnt, cnt+26)>=k) {
                ans+=j+1;
            }
        }
        return ans;
    }
};",1427828986
penguinhacker,penguinhacker,17,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans(1, ""a"");
        while(ans.back()!=target) {
            //cout << ans.size() << endl;
            if (ans.back().back()==target[ans.back().size()-1]) {
                ans.push_back(ans.back()+""a"");
            } else {
                string x=ans.back();
                x.back()++;
                ans.push_back(x);
            }
        }
        return ans;
    }
};",1427827818
penguinhacker,penguinhacker,17,3603,cpp,"#define ll long long
#define ar array

const int MOD = 1e9 + 7;

namespace Hashing {

mt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<int> BDIST(0.1 * MOD, 0.9 * MOD);
const ar<int, 2> base = {BDIST(rng), BDIST(rng)};

ar<int, 2> operator+ (ar<int, 2> a, ar<int, 2> b) {
	for (int i = 0; i < 2; ++i)
		if ((a[i] += b[i]) >= MOD)
			a[i] -= MOD;
	return a;
}
ar<int, 2> operator- (ar<int, 2> a, ar<int, 2> b) {
	for (int i = 0; i < 2; ++i)
		if ((a[i] -= b[i]) < 0)
			a[i] += MOD;
	return a;
}
ar<int, 2> operator* (ar<int, 2> a, ar<int, 2> b) {
	for (int i = 0; i < 2; ++i)
		a[i] = (ll)a[i] * b[i] % MOD;
	return a;
}
ar<int, 2> make_hash(char c) {
	return {c, c};
}

vector<ar<int, 2>> pows = {{1, 1}};
void extend(int len) {
	while(pows.size() <= len)
		pows.push_back(base * pows.back());
}

// struct hstring {
// 	string s;
// 	vector<ar<int, 2>> pre = {{0, 0}};
// 	void add(string t) {
// 		s += t;
// 		for (char c : t)
// 			pre.push_back(base * pre.back() + make_hash(c));
// 	}
// 	ar<int, 2> hash(int l, int r) {
// 		assert(0 <= l && l <= r && r < s.size());
// 		int len = r - l + 1;
// 		extend(len);
// 		return pre[r + 1] - pows[len] * pre[l];
// 	}
// };

}
using namespace Hashing;


class Solution {
public:
    int n;
    vector<vector<int>> adj;
    vector<bool> ans;
    vector<int> sz;
    string s;

    ar<ar<int, 2>, 2> dfs(int u=0) {
        ar<int, 2> h1={}, h2={};
        int cur=0;
        for (int v : adj[u]) {
            ar<ar<int, 2>, 2> x = dfs(v);
            h1=h1*pows[sz[v]]+x[0];
            h2=x[1]*pows[sz[u]-1]+h2;
            sz[u]+=sz[v];
        }
        //cout << pows.size() << "" "" << s[u] << endl;
        h1=h1*pows[1]+make_hash(s[u]);
        h2=make_hash(s[u])*pows[sz[u]-1]+h2;
        // if (u==1) {
        //     cout << (make_hash('a')+make_hash('b')*pows[1]+make_hash('a')*pows[2])[0] << endl;
        //     cout << h1[0] << "" "" << h2[0] << endl;
        // }
        ans[u]=h1==h2;
        return {h1, h2};
    }

    vector<bool> findAnswer(vector<int>& parent, string _s) {
        s=_s;
        n=parent.size();
        adj.resize(n);
        ans.resize(n);
        sz.assign(n, 1);
        for (int i=1; i<n; ++i)
            adj[parent[i]].push_back(i);
        extend(n+5);
        dfs();
        return ans;
    }
};",1427856962
penguinhacker,penguinhacker,17,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> a(*max_element(nums.begin(), nums.end())+1);
        for (int i=2; i<a.size(); ++i) {
            if (a[i])
                continue;
            for (int j=i; j<a.size(); j+=i)
                if (!a[j])
                    a[j]=i;
        }
        reverse(nums.begin(), nums.end());
        int ans=0;
        for (int i=1; i<nums.size(); ++i) {
            if (nums[i]>nums[i-1]) {
                nums[i]=a[nums[i]];
                ++ans;
                if (nums[i]>nums[i-1])
                    return -1;
            }
        }
        return ans;
    }
};",1427832996
Lin Yang Yun,LinYangyun,18,3502,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution
{
public:
    int numberOfSubstrings(string s, int k)
    {
        int n = sz(s);
        if (k == 1)
            return n * (n + 1) / 2;
        if (k > n)
            return 0;

        int ans = 0;
        loop(i, 0, n)
        {
            int freq[26] = {0};
            int cnt = 0;
            for (int j = i; j < n; j++)
            {
                int idx = s[j] - 'a';
                freq[idx]++;
                cnt+= (freq[idx] == k);        
                if (cnt > 0)
                    ans++;
                
            }
        }
        return ans;
    }
};
",1427834410
Lin Yang Yun,LinYangyun,18,3566,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution {
public:
    vector<string> stringSequence(string target) {
        fastio;
        vector<string> ans;
        string t = """";
        
        for(char c : target){
            t += 'a';
            ans.pb(t);
            int charr = c - 'a';
            for(int i = 0; i < charr; ++i){
                if(t.empty()) break;
                if(t.back() != 'z')
                    t.back() += 1;
                else
                    t.back() = 'a';
                
                ans.pb(t);
            }
        }
        
        return ans;
    }
};
",1427840770
Lin Yang Yun,LinYangyun,18,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution
{
public:
    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        int n = sz(parent);
        vvi tree(n);
        for (int i = 1; i < n; ++i)
            tree[parent[i]].pb(i);

        vi L(n), R(n);
        string ss;
        int idx = 0;

        function<void(int)> dfs = [&](int x)
        {
            L[x] = idx;
            for (int y : tree[x])
            {
                dfs(y);
            }
            ss += s[x];
            R[x] = idx++;
        };

        dfs(0);
        string Rev_ss = ss;
        reverse(Rev_ss.begin(), Rev_ss.end());

        int N = ss.size();
        const lli P1 = 911, MOD1 = 999999937;
        const lli P2 = 3571, MOD2 = 999999929;

        vll powP1(N + 1), powP2(N + 1);
        powP1[0] = powP2[0] = 1;
        for (int i = 1; i <= N; ++i)
        {
            powP1[i] = (powP1[i - 1] * P1) % MOD1;
            powP2[i] = (powP2[i - 1] * P2) % MOD2;
        }

        vll H1(N), H2(N), RevH1(N), RevH2(N);
        vi val(256);
        for (char c = 'a'; c <= 'z'; ++c)
        {
            val[c] = c - 'a' + 1;
        }

        H1[0] = val[ss[0]];
        H2[0] = val[ss[0]];
        for (int i = 1; i < N; ++i)
        {
            H1[i] = (H1[i - 1] * P1 + val[ss[i]]) % MOD1;
            H2[i] = (H2[i - 1] * P2 + val[ss[i]]) % MOD2;
        }

        RevH1[0] = val[Rev_ss[0]];
        RevH2[0] = val[Rev_ss[0]];
        for (int i = 1; i < N; ++i)
        {
            RevH1[i] = (RevH1[i - 1] * P1 + val[Rev_ss[i]]) % MOD1;
            RevH2[i] = (RevH2[i - 1] * P2 + val[Rev_ss[i]]) % MOD2;
        }

        vector<bool> answer(n);

        for (int x = 0; x < n; ++x)
        {
            int Lx = L[x], Rx = R[x];
            lli frwrd, backwrd;
            if (Lx > 0)
            {
                frwrd = (H1[Rx] - H1[Lx - 1] * powP1[Rx - Lx + 1] % MOD1 + MOD1) % MOD1;
                backwrd = (H2[Rx] - H2[Lx - 1] * powP2[Rx - Lx + 1] % MOD2 + MOD2) % MOD2;
            }
            else
            {
                frwrd = H1[Rx];
                backwrd = H2[Rx];
            }
            int A = N - 1 - Rx, B = N - 1 - Lx;
            lli hash1_rev, hash2_rev;
            if (A > 0)
            {
                hash1_rev = (RevH1[B] - RevH1[A - 1] * powP1[B - A + 1] % MOD1 + MOD1) % MOD1;
                hash2_rev = (RevH2[B] - RevH2[A - 1] * powP2[B - A + 1] % MOD2 + MOD2) % MOD2;
            }
            else
            {
                hash1_rev = RevH1[B];
                hash2_rev = RevH2[B];
            }

            if (frwrd == hash1_rev && backwrd == hash2_rev)
            {
                answer[x] = true;
                continue;
            }

            answer[x] = false;
        }

        return answer;
    }
};
",1427829096
Lin Yang Yun,LinYangyun,18,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution
{
public:
    int minOperations(vector<int> &nums)
    {
        int n = sz(nums),ans = 0;
        const int MAXN = 1e6 + 1;
        vi spf(MAXN);
        for (int i = 0; i < MAXN; ++i)
        {
            spf[i] = i;
        }
        for (int i = 2; i * i < MAXN; ++i)
        {
            if (spf[i] == i)
            {
                for (int j = i * i; j < MAXN; j += i)
                {
                    if (spf[j] == j)
                    {
                        spf[j] = i;
                    }
                }
            }
        }

        loopD(i, n - 1, 1)
        {
            if (nums[i - 1] > nums[i])
            {
                if (nums[i - 1] == spf[nums[i - 1]])
                    return -1;
                if (spf[nums[i - 1]] > nums[i]) return -1;
                
                    nums[i - 1] = spf[nums[i - 1]];
                    ans += 1;
            }
        }
        return ans;
    }
};
",1427857762
dirigibility,dirigibility,19,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        q = defaultdict(deque)
        j = -1
        count = 0
        for i,c in enumerate(s):
            q[c].append(i)
            if len(q[c]) > k:
                q[c].popleft()
            if len(q[c]) == k:
                j = max(j,q[c][0])
            count += j+1
        return count",1427828201
dirigibility,dirigibility,19,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        l = []
        result = []
        for c in target:
            l.append('a')
            result.append(''.join(l))
            while l[-1] != c:
                l[-1] = chr(ord(l[-1])+1)
                result.append(''.join(l))
        return result
                ",1427824436
dirigibility,dirigibility,19,3603,python3,"def manacher(s):
    s = ''.join(chain('.',*zip(s,repeat('.'))))
    n = len(s)
    max_rad = [0]*n
    ctr = rad = 0
    while ctr < n:
        while ctr-rad-1 >= 0 and ctr+rad+1 < n and s[ctr-rad-1] == s[ctr+rad+1]:
            rad += 1
        max_rad[ctr] = rad
        ctr0 = ctr
        rad0 = rad
        ctr += 1
        rad = 0
        while ctr <= ctr0+rad0:
            ctr_refl = 2*ctr0-ctr
            rad_edge = ctr0+rad0-ctr
            if max_rad[ctr_refl] == rad_edge:
                rad = rad_edge
                break
            max_rad[ctr] = min(max_rad[ctr_refl],rad_edge)
            ctr += 1
    return max_rad

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        children = [[] for _ in range(n)]
        for x in range(1,n):
            children[parent[x]].append(x)
        a = {}
        b = {}
        dfsStr = []
        def dfs(x):
            a[x] = len(dfsStr)
            for y in children[x]:
                dfs(y)
            b[x] = len(dfsStr)
            dfsStr.append(s[x])
        dfs(0)
        max_rad = manacher(''.join(dfsStr))
        return [max_rad[a[x]+b[x]+1] >= b[x]-a[x]+1 for x in range(n)]",1427859014
dirigibility,dirigibility,19,3607,python3,"@cache
def p(n):
    for k in range(2,isqrt(n)+1):
        if not n%k:
            return k
    return n

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        @cache
        def f(i,prev):
            if i == len(nums):
                return 0
            if nums[i] < prev:
                return inf
            if (x := p(nums[i])) >= prev:
                return min(1+f(i+1,x),f(i+1,nums[i]))
            return f(i+1,nums[i])
        result = f(0,0)
        f.cache_clear()
        return result if result != inf else -1",1427837551
07dishwasherbob8,07dishwasherbob8,23,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int lo = 0, hi = 0;

        int cnt = 0;

        vector<int> cnts(26);

        for(int i = 0; i < s.size(); i++) {
            if(i) {
                cnts[s[i-1] - 'a']--;
            }
            while(*max_element(cnts.begin(), cnts.end()) < k && hi != s.size()) {
                cnts[s[hi++] - 'a']++;
            }
            if((*max_element(cnts.begin(), cnts.end())) >= k) {
                cnt += s.size() - hi + 1;
            }
        }

        return cnt;

    }
};",1427858627
07dishwasherbob8,07dishwasherbob8,23,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";
        for(int i = 0; i < target.size(); i++) {
            curr.push_back('a');
            res.push_back(curr);
            while(curr[i] != target[i]) {
                curr.back()++;
                res.push_back(curr);
            }
        }
        return res;
    }
};",1427860968
07dishwasherbob8,07dishwasherbob8,23,3603,cpp,"class Solution {

vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

//checks if is palindrome [l, r)
bool ispal(int l, int r, vector<int> &man) {

    int center = l + r - 1;
    return man[center] - 1 >= r - l ;
}

public:
    vector<bool> findAnswer(vector<int>& parent, string s) {


        int n = parent.size();
        vector<vector<int>> children(n);

        for(int i = 1; i < n; i++) {
            children[parent[i]].push_back(i);
        }

        vector<int> tin(n);
        vector<int> tout(n);

        string news = """";

        int time = 0;

        auto dfs = [&](auto self, int i) -> void {
            tin[i] = time;
            sort(children[i].begin(), children[i].end());
            for(int c : children[i]) {
                self(self, c);
            }
            news.push_back(s[i]);
            tout[i] = ++time;
        };

        dfs(dfs, 0);

        vector<int> man = manacher(news);


        // cout << ""news : "" << news << '\n';
        
        // for(int x : man) {
        //     cout << x << ' ';
        // }
        // cout << '\n';

        // for(int x : tin) {
        //     cout << x << ' ';
        // }
        // cout << '\n';
        // for(int x : tout) {
        //     cout << x << ' ';
        // }

        cout << '\n';

        vector<bool> res(n);

        for(int i = 0; i < n; i++) {
            res[i] = ispal(tin[i], tout[i], man);
        }

        return res;

    }
};",1427843977
07dishwasherbob8,07dishwasherbob8,23,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        
        int ops = 0;

        auto divide = [&](int idx) -> int {
            // cout << ""idx : "" << idx << "" nums[idx] : "" << nums[idx] << '\n';
            for(int i = 2; i * i <= nums[idx]; ++i) {
                if(nums[idx] % i == 0) {
                    nums[idx] /= nums[idx] / i;
                    return 1;
                }
            }
            return 0;
        };

        int lo = INT_MAX;
        for(int i = nums.size() - 1; i >= 0; i--) {
            while(nums[i] > lo) {
                if(!divide(i)) {
                    return -1;
                }
                ops++;
            }
            lo = min(lo, nums[i]);
        }
        return ops;
    }
};",1427852834
unicorn_15,unicorn_15,24,3502,cpp,"#include <iostream>
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int r = 0;
        for(int i = 0; i < n; ++i){
            vector<int> f(26, 0);
            int c = 0;
            for(int j = i; j < n; ++j){
                int idx = s[j] - 'a';
                if(idx < 0 || idx >= 26){
                    // If the character is not a lowercase letter, skip or handle as needed
                    continue;
                }
                f[idx] += 1;
                if(f[idx] == k){
                    c += 1;
                }
                if(c > 0){
                    r += 1;
                }
            }
        }
        return r;
    }
};
 ",1427861372
unicorn_15,unicorn_15,24,3566,cpp,"#include <cctype> 
class Solution {
public:
    vector<string> stringSequence(const string& target) {
        vector<string> result;
        string current = """";
        
        for(char c : target) {
            char lower_c = tolower(c);
            current += 'a';
            result.push_back(current);
            
            if(lower_c != 'a') {
                int increments = (static_cast<int>(lower_c) - static_cast<int>('a')) % 26;
                for(int i = 0; i < increments; ++i) {
                    current.back() = static_cast<char>(((current.back() - 'a' + 1) % 26) + 'a');
                    result.push_back(current);
                }
            }
        }
        
        return result;
    }
};",1427860232
unicorn_15,unicorn_15,24,3603,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <functional>

using namespace std;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size(); 
        vector<vector<int>> children(n, vector<int>());
        for(int i = 1; i < n; ++i){
            children[parent[i]].push_back(i);
        } 
        for(auto &ch : children){
            sort(ch.begin(), ch.end());
        } 
        const long long mod = 1000000007;
        const long long base = 911;
        vector<long long> pow_base(n + 2, 1);
        for(int i = 1; i <= n + 1; ++i){
            pow_base[i] = (pow_base[i - 1] * base) % mod;
        }
        
        // Initialize the result vector
        vector<bool> res(n, false);
        
        // Define a structure to hold hash values and length
        struct HashData {
            long long h; // Forward hash
            long long rh; // Reverse hash
            int l; // Length of the subtree
        };
        
        // Define the DFS function using lambda
        function<HashData(int)> dfs = [&](int x) -> HashData {
            long long h = 0;
            long long rh = 0;
            int l = 0;
            vector<pair<long long, int>> child_data;
            
            // Process all children
            for(auto &y : children[x]){
                HashData child = dfs(y);
                // Update forward hash
                h = (h * pow_base[child.l] + child.h) % mod;
                // Store reverse hash and length for later
                child_data.emplace_back(child.rh, child.l);
                // Update total length
                l += child.l;
            }
            
            // Process current node's character
            int c_val = (s[x] - 'a') + 1;
            h = (h * base + c_val) % mod;
            l += 1;
            rh = c_val;
            
            // Update reverse hash by processing children in reverse order
            for(auto it = child_data.rbegin(); it != child_data.rend(); ++it){
                rh = (rh * pow_base[it->second] + it->first) % mod;
            }
            
            // Check if forward hash equals reverse hash
            res[x] = (h == rh);
            
            return HashData{h, rh, l};
        };
        
        // Start DFS from the root node (assumed to be 0)
        dfs(0);
        
        return res;
    }
};",1427864143
unicorn_15,unicorn_15,24,3607,cpp,"#include <vector>
#include <climits>

using namespace std;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        const int mx = 32000; 
        vector<bool> sv(mx, true);
        vector<int> pr;
        sv[0] = sv[1] = false;
        for(int i = 2; i < mx; ++i){
            if(sv[i]){
                pr.push_back(i);
                for(int j = i * i; j < mx; j += i){
                    sv[j] = false;
                }
            }
        }
        
        // Lambda function to find the smallest prime factor of x
        auto spf = [&](int x) -> int {
            for(auto &p : pr){
                if((long long)p * p > x){
                    break;
                }
                if(x % p == 0){
                    return p;
                }
            }
            return x;
        };
        
        int res = 0;
        int mn = INT32_MAX;
         
        for(int i = n - 1; i >= 0; --i){
            while(nums[i] > mn){
                if(nums[i] == 1){
                    return -1;
                }
                int f = spf(nums[i]);
                if(f == nums[i]){
                    return -1;
                }
                nums[i] = f;
                res += 1;
            }
            mn = nums[i];
        }
        
        return res;
    }
};",1427862710
green_pig,green_pig,25,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        j = 0
        c = [0] * 26
        t = 0
        n = len(s)
        r = 0
        for i in range(len(s)):
            while j < n and not t:
                ch = ord(s[j]) - 97
                c[ch] += 1
                t += c[ch] == k
                j += 1
            r += t and n - j + 1
            ch = ord(s[i]) - 97
            c[ch] -= 1
            t -= c[ch] == k-1
        return r",1427827525
green_pig,green_pig,25,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        a = []
        r = []
        for c in target:
            a.append('a')
            r.append(''.join(a))
            for i in range(ord(c) - 97):
                a[-1] = chr(ord(a[-1]) + 1)
                r.append(''.join(a))
        return r",1427824445
green_pig,green_pig,25,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], S: str) -> List[bool]:
        n = len(parent)
        t = [[] for _ in range(n)]
        for i in range(1, n):
            t[parent[i]].append(i)
        p = [1] * n
        def dfs(i):
            s = r = k = 0
            s = ord(S[i])
            a = []
            for j in t[i]:
                a.append(dfs(j))
                k += a[-1][2]
            for x, y, z in a:
                r = (r * pow(Q, z, P) + y) % P
            for x, y, z in a[::-1]:
                s = (s * pow(Q, z, P) + x) % P
            r = (r * Q + ord(S[i])) % P
            p[i] &= s == r
            return s, r, k + 1
        P = 10**9+7
        Q = 257
        dfs(0)
        Q = 29
        dfs(0)
        Q = 31
        dfs(0)
        return [bool(x) for x in p]",1427857214
green_pig,green_pig,25,3607,python3,"def primes(n):
    prime = bytearray(b'\0\0' + b'\1' * (n-1))
    r = []
    for i in range(n+1):
        if prime[i]:
            r.append(i)
            prime[i*i::i] = b'\0' * (n//i-i+1)
    return r
n = 10**6+1
a = primes(n)
lp = [0] * n
for p in a[::-1]:
    for i in range(p, n, p):
        lp[i] = p
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        r = 0
        f = 0
        p = inf
        for x in nums[::-1]:
            if x > p:
                x = lp[x]
                r += 1
            if x > p:
                return -1
            p = x
        return r
",1427835377
uwi,uwi,26,3502,java,"class Solution {
    public int numberOfSubstrings(String S, int k) {
        char[] s = S.toCharArray();
        int ans = 0;
        for(int i = 0;i < s.length;i++){
            int[] f = new int[26];
            for(int j = i;j < s.length;j++){
                if(++f[s[j]-'a'] == k){
                    ans += s.length - j;
                    break;
                }
            }
        }
        return ans;
    }
}",1427825086
uwi,uwi,26,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        String cur = """";
        List<String> ret = new ArrayList<>();
        for(int i = 0;i < target.length();i++){
            for(char c = 'a';c <= target.charAt(i);c++){
                ret.add(cur + c);
            }
            cur += target.charAt(i);
        }
        return ret;
    }
}",1427824075
uwi,uwi,26,3603,java,"	class Solution {
		char[] s;
		int[][] ch;

		long[] hf;
		long[] hb;
		RollingHash61 rh;

		public boolean[] findAnswer(int[] parent, String S) {
			ch = parentToChildren(parent);
			for(int i = 0;i < parent.length;i++){
				Arrays.sort(ch[i]);
			}
			s = S.toCharArray();

			hf = new long[s.length];
			hb = new long[s.length];
			rh = new RollingHash61(31, s.length);
			dfsf(0);
			rh = new RollingHash61(31, s.length);
			dfsb(0);

			boolean[] ans = new boolean[parent.length];
			for(int i = 0;i < parent.length;i++){
				ans[i] = hf[i] == hb[i];
			}
			return ans;
		}

		void dfsf(int cur)
		{
			int pos = rh.hp;
			for(int c : ch[cur]){
				dfsf(c);
			}
			rh.add(s[cur]);
			hf[cur] = rh.h(pos, rh.hp);
		}

		void dfsb(int cur)
		{
			int pos = rh.hp;
			rh.add(s[cur]);
			for(int i = ch[cur].length-1;i >= 0;i--){
				int c = ch[cur][i];
				dfsb(c);
			}
			hb[cur] = rh.h(pos, rh.hp);
		}

		public static class RollingHash61
		{
			static final long mod = (1L<<61)-1;
			public long M;
			public long[] pows;
			public long[] hs;
			public int hp;

			public RollingHash61(long M, int n) {
				assert M > 0;
				assert n > 0;
				this.M = M;
				this.pows = makePows(M, n);
				this.hs = new long[n+1];
				this.hp = 0;
			}

			public static long mul(long a, long b)
			{
				long al = a&(1L<<31)-1, ah = a>>>31;
				long bl = b&(1L<<31)-1, bh = b>>>31;
				long low = al * bl; // <2^62
				long mid = al * bh + bl * ah; // < 2^62
				long high = ah * bh + (mid>>>31); // < 2^60 + 2^31 < 2^61
				// high*2^62 = high*2 (mod 2^61-1)
				long ret = mod(mod(2*high + low) + ((mid&(1L<<31)-1)<<31));
				return ret;
			}

			public static long mod(long a)
			{
				while(a >= mod)a -= mod;
				while(a < 0)a += mod;
				return a;
			}

			private static long[] makePows(long M, int n)
			{
				long[] ret = new long[n+1];
				ret[0] = 1;
				for(int i = 1;i <= n;i++)ret[i] = mul(ret[i-1], M);
				return ret;
			}

			public void add(long x)
			{
				hs[hp+1] = mul(hs[hp], M) + x;
				if(hs[hp+1] >= mod)hs[hp+1] -= mod;
				hp++;
			}

			public long h(int l, int r)
			{
				assert l <= r;
				return mod(hs[r] - mul(hs[l], pows[r-l]));
			}
		}

		public static int[][] parentToChildren(int[] par)
		{
			int n = par.length;
			int[] ct = new int[n];
			for(int v : par){
				if(v >= 0)ct[v]++;
			}
			int[][] g = new int[n][];
			for(int i = 0;i < n;i++){
				g[i] = new int[ct[i]];
			}
			for(int i = 0;i < n;i++){
				if(par[i] >= 0){
					g[par[i]][--ct[par[i]]] = i;
				}
			}

			return g;
		}


	}
",1427857284
uwi,uwi,26,3607,java,"	class Solution {
		static int[] lpf = enumLowestPrimeFactors(1000000);

		public int minOperations(int[] nums) {
			int dp0 = 0, dp1 = 1;
			for(int i = 1;i < nums.length;i++){
				int v0 = nums[i], v1 = lpf[nums[i]];
				int pv0 = nums[i-1], pv1 = lpf[nums[i-1]];
				int ndp0 = Integer.MAX_VALUE / 2;
				int ndp1 = Integer.MAX_VALUE / 2;
				if(pv0 <= v0){
					ndp0 = Math.min(ndp0, dp0);
				}
				if(v0 != v1 && pv0 <= v1){
					ndp1 = Math.min(ndp1, dp0 + 1);
				}
				if(pv0 != pv1 && pv1 <= v0){
					ndp0 = Math.min(ndp0, dp1);
				}
				if(pv0 != pv1 && v0 != v1 && pv1 <= v1){
					ndp1 = Math.min(ndp1, dp1 + 1);
				}
				dp0 = ndp0;
				dp1 = ndp1;
			}
			if(dp0 >= 999999)return -1;
			return Math.min(dp0, dp1);
		}

		public static int[] enumLowestPrimeFactors(int n)
		{
			int tot = 0;
			int[] lpf = new int[n+1];
			int u = n+32;
			double lu = Math.log(u);
			int[] primes = new int[(int)(u/lu+u/lu/lu*1.5)];
			for(int i = 2;i <= n;i++)lpf[i] = i;
			for(int p = 2;p <= n;p++){
				if(lpf[p] == p)primes[tot++] = p;
				int tmp;
				for(int i = 0;i < tot && primes[i] <= lpf[p] && (tmp = primes[i]*p) <= n;i++){
					lpf[tmp] = primes[i];
				}
			}
			return lpf;
		}

	}
",1427836534
physics0523,physics0523,28,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res=0;
        int l=s.size();
        for(int i=0;i<l;i++){
            int h=0;
            vector<int> bk(26,0);
            for(int j=i;j<l;j++){
                bk[s[j]-'a']++;
                if(bk[s[j]-'a']==k){h++;}
                // cout << i << "" "" << j << "" "" << h << ""\n"";
                if(h){res++;}
            }
        }
        return res;
    }
};",1427827245
physics0523,physics0523,28,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> sq;
        string cur="""";
        for(int i=0;i<target.size();i++){
            cur.push_back('a');
            sq.push_back(cur);
            while(target[i]!=cur[i]){
                if(cur[i]=='z'){cur[i]='a';}
                else{cur[i]++;}
                sq.push_back(cur);
            }
        }
        return sq;
    }
};",1427824331
physics0523,physics0523,28,3603,cpp,"//manacher algorithm
//http://snuke.hatenablog.com/entry/2014/12/02/235837

//longest palindrome(length:odd)
//if you want to find the answer for even palindrome,
//you can use dummy letter.
//ex. $a$b$c$c$b$a$
vector<int> manacher(string &s){
  int i,j,k,l;
  l=s.size();
  vector<int> arr(l);
  i=0;j=0;
  while(i<l){
    while((i-j)>=0 && (i+j)<l){
      if(s[i-j]!=s[i+j]){break;}
      j++;
    }
    arr[i]=j;
    k=1;
    while((i-k)>=0 && (i+k)<l){
      if(k+arr[i-k]>=arr[i]){break;}
      arr[i+k]=arr[i-k];
      k++;
    }
    j=arr[i]-k;
    i+=k;
  }
  return arr;
}

vector<int> pal_build(string s){
  string ms=""$"";
  for(auto &nx : s){
    ms.push_back(nx);
    ms.push_back('$');
  }
  return manacher(ms);
}

// 0-indexed ask [l,r]
bool pal_ask(int l,int r,vector<int> &pal_dat){
  int len=r-l+1;
  int cent=l+r+1;
  return (pal_dat[cent]>=len);
}

using Graph=vector<vector<int>>;

int cc;
void dfs(int v,vector<int> &l,vector<int> &r,Graph &g){
    l[v]=cc;
    for(auto &nx : g[v]){
        dfs(nx,l,r,g);
    }
    r[v]=cc;
    cc++;
}

class Solution{
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        Graph g(n);
        for(int i=1;i<n;i++){
            g[parent[i]].push_back(i);
        }
        cc=0;
        vector<int> l(n),r(n);
        dfs(0,l,r,g);
        string t;
        for(int i=0;i<n;i++){
            t.push_back('.');
        }
        for(int i=0;i<n;i++){
            t[r[i]]=s[i];
        }
        auto pd=pal_build(t);
        vector<bool> res;
        for(int i=0;i<n;i++){
            res.push_back(pal_ask(l[i],r[i],pd));
        }
        return res;
    }
};",1427858042
physics0523,physics0523,28,3607,cpp,"int MXM=1000005;
vector<int> mv;

class Solution {
public:
    int minOperations(vector<int>& nums){
        if(mv.empty()){
            mv.resize(MXM);
            for(auto &nx : mv){nx=1e9;}
            for(int i=2;i<MXM;i++){
                if(mv[i]>5e8){
                    for(int j=2*i;j<MXM;j+=i){
                        mv[j]=min(i,mv[j]);
                    }
                }
            }
        }
        // for(int i=0;i<10;i++){cout << mv[i] << ""\n"";}
        int n=nums.size();
        int d0=0,d1;
        if(mv[nums[0]]>5e8){d1=1e9;}
        else{d1=1;}
        for(int i=1;i<n;i++){
            int nd0=1e9;
            int nd1=1e9;
            if(nums[i-1]<=nums[i]){nd0=min(nd0,d0);}
            if(nums[i-1]<=mv[nums[i]] && mv[nums[i]]<5e8){nd1=min(nd1,d0+1);}
            if(mv[nums[i-1]]<=nums[i]){nd0=min(nd0,d1);}
            if(mv[nums[i-1]]<=mv[nums[i]] && mv[nums[i]]<5e8){nd1=min(nd1,d1+1);}
            d0=nd0;
            d1=nd1;
        }
        int oup=min(d0,d1);
        if(oup>5e8){oup=-1;}
        return oup;
    }
};",1427845204
Ma Lin,Ma_Lin,29,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int K) {
        int i, j, c, n = s.size(), l, r, q, res = 0;
        vector<int> f[26];
        for (i = 0; i < n; ++i){
            c = s[i] - 'a';
            f[c].push_back(i);
        }
        
        for (i = 0; i < n; ++i){
            q = n;
            for (j = 0; j < 26; ++j){
                l = lower_bound(f[j].begin(), f[j].end(), i) - f[j].begin();
                if (l + K - 1 < f[j].size()) q = min(q, f[j][l + K - 1]);
            }
            
            if (q < n) res += n - q;
        }
        
        return res;
    }
};",1427827148
Ma Lin,Ma_Lin,29,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        int i, j, n = s.size();
        string t;
        vector<string> res;
        for (i = 0; i < n; ++i){
            t.push_back('a');
            res.push_back(t);
            while (t[i] != s[i]){
                t[i]++;
                res.push_back(t);
            }
        }
        
        return res;
    }
};",1427824119
Ma Lin,Ma_Lin,29,3603,cpp,"class Solution {
public:
    int seed = 500002961, mo = 1000000007;
    vector<int> g[100005];
    int f[100005], f2[100005], ge[100005], yh[100005], n;
    string s;
    
    void dfs(int p, bool zheng){
        int i, j;
        if (g[p].size() == 0){
            f[p] = s[p] - 'a' + 1;
            ge[p] = 1;
            return;
        }
        
        ge[p] = 0;
        f[p] = 0;
        if (!zheng){
            for (i = 0; i < g[p].size(); ++i){
                j = g[p][i];
                dfs(j, zheng);
                f[p] = (f[p] + 1LL * f[j] * yh[ge[p]]) % mo;
                ge[p] += ge[j];
            }
            
            f[p] = (f[p] + 1LL * (s[p] - 'a' + 1) * yh[ge[p]]) % mo;
            ++ge[p];
        }
        else{
            f[p] = s[p] - 'a' + 1;
            ge[p] = 1;
            for (i = g[p].size() -1; i >= 0; --i){
                j = g[p][i];
                dfs(j, zheng);
                f[p] = (f[p] + 1LL * f[j] * yh[ge[p]]) % mo;
                ge[p] += ge[j];
            }
        }
        
    }
    
    vector<bool> findAnswer(vector<int>& par, string ss) {
        int i, j;
        n = par.size();
        s = ss;
        for (i = 0; i < n; ++i) g[i].clear();
        for (i = 0; i < n; ++i) 
            if (par[i] != -1)
                g[par[i]].push_back(i);
        
        yh[0] = 1;
        for (i = 1; i <= n; ++i) yh[i] = (1LL * seed * yh[i - 1]) % mo;
        dfs(0, true);
        for (i = 0; i < n; ++i) f2[i] = f[i];
        dfs(0, false);
        vector<bool> res;
        for (i = 0; i < n; ++i)
            res.push_back(f[i] == f2[i]);
        return res;
    }
};",1427858496
Ma Lin,Ma_Lin,29,3607,cpp,"int f[1000006];
bool yes = false;
class Solution {
public:
    void calc_f(){
        int i, j;
        for (i = 1; i <= 1000000; ++i) f[i] = 1;
        for (i = 2; i <= 1000000; ++i)
            for (j = i + i; j <= 1000000; j += i)
                f[j] = i;
    }    
    
    int minOperations(vector<int>& a) {
        int res = 0, i, j;
        if (!yes){
            calc_f();
            yes = true;
        }
        
        for (i = a.size() - 2; i >= 0; --i){
            while (a[i] > a[i + 1]){
                if (f[a[i]] == 1) break;
                a[i] /= f[a[i]];
                ++res;
            }
            
            if (a[i] > a[i + 1]) return -1;
        }
        
        return res;
    }
};",1427834882
Anas Maged,Anas_Maged,31,3502,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = sz(s);
        vector<vector<int>> pre(n, vector<int>(26));
        for(int i = 0; i < sz(s); i++){
            if(i) pre[i] = pre[i - 1];
            pre[i][s[i] - 'a']++;
        }

        auto val = [&](int l, int r) -> bool{
            for(int i = 0; i < 26; i++){
                int cnt = pre[r][i] - (l == 0 ? 0 : pre[l - 1][i]);
                if(cnt >= k) return 1;
            }
            return 0;
        };

        for(int i = 0; i < sz(s); i++){
            int start = 0, end = sz(s) - 1, mid, res = -1;
            while(start <= end){
                mid = (start + end) / 2;
                if(val(i, mid)){
                    res = mid;
                    end = mid - 1;
                }
                else{
                    start = mid + 1;
                }
            }
            if(res == -1) break;
            ans += n - res;
        }
        return ans;
    }
};",1427828670
Anas Maged,Anas_Maged,31,3566,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur;
        for(char c : target){
            cur += 'a';
            ans.push_back(cur);
            while(cur.back() != c){
                cur.back()++;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824959
Anas Maged,Anas_Maged,31,3603,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


const int N = 1e5 + 5, MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;
int pw1[N], inv1[N], pw2[N], inv2[N], BASE;

bool isPrime(int x) {
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) return 0;
    }
    return x > 1;
}

int fix(ll x, int M) {
    return (x % M + M) % M;
}

int fpow(int a, int b, int mod) {
    if (!b) return 1;
    int ret = fpow(a, b >> 1, mod);
    ret = fix(1ll * ret * ret, mod);
    if (b & 1) ret = fix(1ll * ret * a, mod);
    return ret;
}

void init() {
    static bool done = false;
    if (done) return;
    done = true;
    
    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<int> dist(257, 10007);
    do{
        BASE = dist(rng);
    }while (!isPrime(BASE));

    pw1[0] = inv1[0] = pw2[0] = inv2[0] = 1;
    int iv1 = fpow(BASE, MOD1 - 2, MOD1);
    int iv2 = fpow(BASE, MOD2 - 2, MOD2);
    for (int i = 1; i < N; ++i) {
        pw1[i] = fix(1ll * pw1[i - 1] * BASE, MOD1);
        pw2[i] = fix(1ll * pw2[i - 1] * BASE, MOD2);
        inv1[i] = fix(1ll * inv1[i - 1] * iv1, MOD1);
        inv2[i] = fix(1ll * inv2[i - 1] * iv2, MOD2);
    }
}

struct Hash {
    pair<int, int> H = {0, 0};
    int curSize = 0;
    void addChar(char c){
        H.first = fix(1ll * pw1[curSize] * c + H.first, MOD1);
        H.second = fix(1ll * pw2[curSize] * c + H.second, MOD2);
        curSize++;
    }
    void merge(pair<int, int> H2, int temp){
        H.first = fix(1ll * pw1[curSize] * H2.first + H.first, MOD1);
        H.second = fix(1ll * pw2[curSize] * H2.second + H.second, MOD2);
        curSize += temp;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        init();
        int n = sz(p);
        vector<vector<int>> adj(n);
        vector<bool> ans(n, 0);
        for(int i = 0; i < sz(p); i++){
            if(p[i] == -1) continue;
            adj[p[i]].push_back(i);
            adj[i].push_back(p[i]);
        }
        vector<int> cnt(n);
        auto dfs = [&](auto& self, int u, int p) -> pair<pair<int, int>, pair<int, int>>{
            cnt[u] = 1;
            sort(all(adj[u]), greater<int>());
            Hash H1, H2;
            H1.addChar(s[u]);
            vector<tuple<int, int, int>> a;
            for(int v : adj[u]){
                if(v == p) continue;
                auto temp = self(self, v, u);
                cnt[u] += cnt[v];
                H1.merge(temp.first, cnt[v]);
                a.push_back({temp.second.first, temp.second.second, cnt[v]});
            }
            reverse(all(a));
            for(auto& [i, j, k] : a){
                H2.merge({i, j}, k);
            }
            H2.addChar(s[u]);
            ans[u] = (H1.H == H2.H);
            return {H1.H, H2.H};
        };
        dfs(dfs, 0, -1);
        return ans;
    }
};",1427867017
Anas Maged,Anas_Maged,31,3607,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

const int N = 1e6 + 5;
int g[N];
void pre(){
    static bool done = false;
    if(done) return;
    done = true;
    for(int i = 1; i < N; i++){
        for(int j = i + i; j < N; j += i){
            g[j] = i;
        }
    }
    g[1] = 1;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        reverse(all(nums));
        pre();
        int last = 1e9;
        int ans = 0, cnt = 0;
        for(int x : nums){
            while(x > last){
                int y = x / g[x];
                if(x == y) return -1;
                ans++;
                x = y;
            }
            last = x;
        }
        return ans;
    }
};",1427838425
rithwikgupta,rithwikgupta,32,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> freq(26);
        multiset<int> fr;
        for (int i = 0; i < 26; i++ ) fr.insert(0);
        int l = 0;
        int r = 0;
        int res = 0;
        int n = s.size();
        while (l != n) {
            while (-(*fr.begin()) < k && r != n) {
                fr.erase(-freq[s[r]-'a']);
                freq[s[r]-'a']++;
                fr.insert(-freq[s[r]-'a']);
                r++;
            }
            if (-(*fr.begin()) >= k) res += n-r+1;
            fr.erase(-freq[s[l]-'a']);
            freq[s[l]-'a']--;
            fr.insert(-freq[s[l]-'a']);
            l++;
        }
        return res;
    }
};",1427856443
rithwikgupta,rithwikgupta,32,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string t;
        vector<string> res;
        for (int i = 0; i < target.size(); i++) {
            char cur = 'a';
            res.push_back(t + cur);
            while (cur != target[i]) {
                cur ++;
                res.push_back(t + cur);
            }
            t += cur;

        }
        return res;
    }
};",1427859188
rithwikgupta,rithwikgupta,32,3603,cpp,"#define ll long long

class Solution {
public:
vector<vector<ll> > adj;
    string s;
    vector<ll> tin;
    vector<ll> tout;
    
    string ass;
    ll B = 9911;
    ll MOD = 1e9 + 7;
    ll timer=0;
    void dfs(ll cur) {
        // cout << cur << endl;
        tin[cur]=timer;
        string here;
        // cout << cur << endl;
        for (auto val: adj[cur]) {
            // cout << val << endl;
            dfs(val);
        }
        tout[cur]=timer++;
        s += ass[cur];
    }
    vector<bool> findAnswer(vector<int>& parent, string as) {
        ll n = parent.size();
        adj.clear();
        tin.clear();
        tout.clear();
        adj.resize(n);
        tout.resize(n);
        tin.resize(n);
        vector<ll> pref(n), suff(n);
        vector<ll> power(n);
        timer=0;
        ass = as;
        power[0] = 1;
        for (ll i = 1; i < n; i++) {
            power[i] = power[i-1] * B % MOD;
            adj[parent[i]].push_back(i);
        }
        dfs(0);

        for (ll i = 0; i < n; i++) {
            // cout << i << endl;
            if (i) pref[i] = pref[i-1];
            pref[i] = (pref[i]*B + (s[i] - 'a')) % MOD;
        }

        for (ll i = n-1; i >= 0; i--) {
            if (i != n-1) suff[i] = suff[i+1];
            suff[i] = (suff[i]*B + (s[i] - 'a')) % MOD;
        }

        vector<bool> res(n);
        for (ll i = 0; i < n; i++) {
            // cout << i << endl;
            ll s1 = (suff[tin[i]] - suff[tout[i]] * power[tout[i] - tin[i]] % MOD + MOD) % MOD;
            ll p1 = (pref[tout[i]] - pref[tin[i]] * power[tout[i] - tin[i]] % MOD + MOD) % MOD;
            res[i] = (p1 == s1);
        }
        return res;


    }
};",1427846929
rithwikgupta,rithwikgupta,32,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int res= 0;
        for (int i = nums.size()-2; i >= 0; i--) {
            while (nums[i] > nums[i+1]) {
                int g = 1;
                for (int j = 2; j * j <= nums[i]; j++) {
                    if (nums[i] % j == 0) {
                        g = nums[i]/j;
                        break;
                    }
                }
                if (g == 1) return -1;
                else {
                    nums[i] /= g;
                    res++;
                }
            }
        }
        return res;
    }
};",1427851087
haohao,cchao,33,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = s.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int cnt[128] = {}, mx = 0;
            for (int j = i; j < n; ++j) {
                mx = max(mx, ++cnt[s[j]]);
                ans += mx >= k;
            }
        }
        return ans;
    }
};",1427828383
haohao,cchao,33,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string tmp = """";
        vector<string> ans;
        for (char c : target) {
            for (char i = 'a'; i <= c; ++i) {
                ans.push_back(tmp + i);
            }
            tmp += c;
        }
        return ans;
    }
};",1427824685
haohao,cchao,33,3603,cpp,"
void manacher(int n, const char *s, int *p) {
  for (int i = 0, j = 0, k = 0; i <= 2 * (n - 1); ++i) {
    int l = i < k && j + j - i >= 0 ? min(p[j + j - i], (k - i) / 2) : 0;
    int a = i / 2 - l, b = (i + 1) / 2 + l;
    while (0 <= a && b < n && s[a] == s[b]) {
      --a;
      ++b;
      ++l;
    }
    p[i] = l;
    if (k < 2 * b) {
      j = i;
      k = 2 * b;
    }
  }
}
bool isPalindrome(int *p, int l, int r) {
  int len = r - l + 1;
  l = l * 2;
  r = r * 2;
  return p[(l + r) / 2] >= (len + 1) / 2;
}

class Solution {
  vector<vector<int>> g;
  int n;
  string s;
  string t;
  vector<int> in, out;
  int timer = 0;
  void dfs(int x) {
    in[x] = timer;
    for (int y : g[x]) {
        dfs(y);
    }
    t += s[x];
    out[x] = timer++;
  }

 public:
  vector<bool> findAnswer(vector<int> &parent, string s) {
    n = parent.size();
    g.clear();
    g.resize(n);
    this->s = s;
    for (int i = 1; i < n; ++i) g[parent[i]].push_back(i);
    in = out = vector<int>(n + 1, 0);
    timer = 0;
    t = """";
    dfs(0);
    vector<int> p(2 * (n +1 ) + 10);
    manacher(t.size(), t.data(), p.data());
    vector<bool> ans(n);
    for (int i = 0; i < n; ++i) {
      ans[i] = isPalindrome(p.data(), in[i], out[i]);
    }
    return ans;
  }
};",1427867373
haohao,cchao,33,3607,cpp,"bool init = false;
const int maxn = 1e6 + 10;
int d[maxn] = {};
void f() {
    for (int i = 1; i < maxn; ++i) {
        for (int j = i * 2; j < maxn; j += i) {
            d[j] = i;
        }
    }
    init = true;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
          if (!init) f();
          const int n = nums.size();
          int ans = 0;
          for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1] && d[nums[i]] > 1) {
                nums[i] /= d[nums[i]];
                ++ans;
            }
            if (nums[i] > nums[i+1]) return -1;
          }
          return ans;
    }
};",1427836680
hank55663,hank55663,34,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i = 0;i<s.size();i++){
            int cnt[26];
            fill(cnt,cnt+26,0);
            int ok=0;
            for(int j = i;j<s.size();j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a']==k)ok=1;
                ans+=ok;
            }
        }
        return ans;
    }
};",1427824727
hank55663,hank55663,34,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string now;
        for(auto it:target){
            for(char i = 'a';i<=it;i++){
                ans.push_back(now+i);
            }
            now+=it;//+"""";
        }
        return ans;
    }
};",1427823974
hank55663,hank55663,34,3603,cpp,"
vector<int> v[100005];
const int mod[2]={698693077,230484029};
long long base[2][100005];
int Size[100005];
#define pll pair<long long,long long>
#define mp make_pair
#define x first
#define y second
#define LL long long
class Solution {
public:
    vector<bool> aans;
    string ss;
    pair<pll,pll> dfs(int x){
        Size[x]=1;
        vector<pair<pll,pll> > ans;
        for(auto it:v[x]){
            ans.push_back(dfs(it));
            Size[x]+=Size[it];
        }
        long long a[2]={0,0},b[2]={ss[x]-'a'+1,ss[x]-'a'+1};
        int idx=0;
        for(auto it:ans){
            a[0]=(a[0]*base[0][Size[v[x][idx]]]+it.x.x)%mod[0];
            a[1]=(a[1]*base[1][Size[v[x][idx]]]+it.x.y)%mod[1];
            idx++;
        }
        a[0]=(a[0]*27+ss[x]-'a'+1)%mod[0];
        a[1]=(a[1]*27+ss[x]-'a'+1)%mod[1];
        reverse(ans.begin(),ans.end());
        reverse(v[x].begin(),v[x].end());
        idx=0;
        for(auto it:ans){
            b[0]=(b[0]*base[0][Size[v[x][idx]]]+it.y.x)%mod[0];
            b[1]=(b[1]*base[1][Size[v[x][idx]]]+it.y.y)%mod[1];
            idx++;
        }
        aans[x]=(a[0]==b[0]&&a[1]==b[1]);
    //    printf(""%d %d %d %d %d\n"",x,a[0],a[1],b[0],b[1]);
        return mp(mp(a[0],a[1]),mp(b[0],b[1]));
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ss=s;
        for(int t=0;t<2;t++){
            base[t][0]=1;
            for(int j = 1;j<100005;j++)base[t][j]=base[t][j-1]*27%mod[t];
        }
        for(int i = 0;i<parent.size();i++)v[i].clear();
        for(int i = 1;i<parent.size();i++){
            v[parent[i]].push_back(i);            
        }
        //dfs(0);
        aans.resize(parent.size());
        dfs(0);
        return aans;
    }
};",1427859727
hank55663,hank55663,34,3607,cpp,"
    int ans[1000005];
class Solution {
public:

    int minOperations(vector<int>& nums) {
        if(ans[1]==0){
        for(int i = 1;i<1000005;i++)ans[i]=i;
        for(int i = 2;i<1000005;i++){
            if(ans[i]==i){
                for(int j = i;j<1000005;j+=i){
                    if(ans[j]==j)ans[j]=i;
                }
            }
        }
        }
        int last[2]={1,1};
        int dp[2]={0,0};
        int Max=1000000000;
        for(auto it:nums){
            int dp2[2]={Max,Max};
            if(it>=last[0])dp2[0]=min(dp2[0],dp[0]);
            if(it>=last[1])dp2[0]=min(dp2[0],dp[1]);
            if(ans[it]>=last[0])dp2[1]=min(dp2[1],dp[0]+1);
            if(ans[it]>=last[1])dp2[1]=min(dp2[1],dp[1]+1);
            if(dp2[0]==Max&&dp2[1]==Max)return -1;
            last[0]=it;
            last[1]=ans[it];
          //  printf(""%d %d\n"",last[0],last[1]);
            dp[0]=dp2[0];
            dp[1]=dp2[1];
        }
        return min(dp[0],dp[1]);
    }
};",1427834611
LayCurse,LayCurse,35,3502,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int numberOfSubstrings(string s, int K){
    int i;
    int N = s.size();
    int cnt[26];
    int res = 0;
    int mx;
    for(i=(0);i<(N);i++){
      int j, k;
      for(k=(0);k<(26);k++){
        cnt[k] = 0;
      }
      mx = 0;
      for(j=(i);j<(N);j++){
        cnt[s[j]-'a']++;
        chmax(mx, cnt[s[j]-'a']);
        if(mx >= K){
          res++;
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int numberOfSubstrings(string s, int K) {
//     int N = s.size();
//     int cnt[26], res = 0, mx;
// 
//     rep(i,N){
//       rep(k,26) cnt[k] = 0;
//       mx = 0;
//       rep(j,i,N){
//         cnt[s[j]-'a']++;
//         mx >?= cnt[s[j]-'a'];
//         if(mx >= K) res++;
//       }
//     }
//     return res;
//   }
// };
",1427826891
LayCurse,LayCurse,35,3566,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  vector<string> stringSequence(string target){
    int i;
    string now;
    vector<string> res;
    now += 'a';
    res.push_back(now);
    while(now != target){
      i = now.size();
      if(now[i-1] == target[i-1]){
        now += 'a';
      }
      else{
        now[i-1]++;
      }
      res.push_back(now);
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   vector<string> stringSequence(string target) {
//     int i;
//     string now;
//     VS res;
//     now += 'a';
//     res.push_back(now);
//     while(now != target){
//       i = now.size();
//       if(now[i-1] == target[i-1]) now += 'a'; else now[i-1]++;
//       res.push_back(now);
//     }
//     return res;
//   }
// };
",1427824371
LayCurse,LayCurse,35,3603,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
struct Rand{
  unsigned x;
  unsigned y;
  unsigned z;
  unsigned w;
  Rand(void){
    x=123456789;
    y=362436069;
    z=521288629;
    w=(unsigned)time(NULL);
  }
  Rand(unsigned seed){
    x=123456789;
    y=362436069;
    z=521288629;
    w=seed;
  }
  inline unsigned get(void){
    unsigned t;
    t = (x^(x<<11));
    x=y;
    y=z;
    z=w;
    w = (w^(w>>19))^(t^(t>>8));
    return w;
  }
  inline double getUni(void){
    return get()/4294967296.0;
  }
  inline int get(int a){
    return (int)(a*getUni());
  }
  inline int get(int a, int b){
    return a+(int)((b-a+1)*getUni());
  }
  inline long long get(long long a){
    return(long long)(a*getUni());
  }
  inline long long get(long long a, long long b){
    return a+(long long)((b-a+1)*getUni());
  }
  inline double get(double a, double b){
    return a+(b-a)*getUni();
  }
  inline int getExp(int a){
    return(int)(exp(getUni()*log(a+1.0))-1.0);
  }
  inline int getExp(int a, int b){
    return a+(int)(exp(getUni()*log((b-a+1)+1.0))-1.0);
  }
}
;
template<class T, class U> inline T GCD_L(T a, U b){
  T r;
  while(b){
    r=a;
    a=b;
    b=r%a;
  }
  return a;
}
struct graph{
  int N;
  int*es;
  int**edge;
  void setEdge(int N__, int M, int A[], int B[], void **mem = &wmem){
    int i;
    N = N__;
    walloc1d(&es, N, mem);
    walloc1d(&edge, N, mem);
    for(i=(0);i<(N);i++){
      es[i] = 0;
    }
    for(i=(0);i<(M);i++){
      es[A[i]]++;
      es[B[i]]++;
    }
    for(i=(0);i<(N);i++){
      walloc1d(&edge[i], es[i], mem);
    }
    for(i=(0);i<(N);i++){
      es[i] = 0;
    }
    for(i=(0);i<(M);i++){
      edge[A[i]][es[A[i]]++] = B[i];
      edge[B[i]][es[B[i]]++] = A[i];
    }
  }
  int preorder(int res[], int root = 0, void *mem=wmem){
    int i;
    int j;
    int k;
    int sts;
    int sz = 0;
    long long*st;
    char*vis;
    walloc1d(&vis, N, &mem);
    walloc1d(&st, N, &mem);
    sts = 0;
    st[sts++] = ((long long)root) << 32;
    for(i=(0);i<(N);i++){
      vis[i] = 0;
    }
    vis[root] = 1;
    while(sts){
      i = st[--sts] >> 32;
      j = st[sts] & 2147483647;
      if(j==0){
        res[sz++] = i;
      }
      while(j < es[i]){
        k = edge[i][j++];
        if(vis[k]){
          continue;
        }
        if(j < es[i]){
          st[sts++] = (((long long)i) << 32) + j;
        }
        vis[k] = 1;
        st[sts++] = ((long long)k) << 32;
        break;
      }
    }
    return sz;
  }
}
;
#define ROLLING_HASH_MOD (2305843009213693951ULL)
#define ROLLING_HASH_PRIMITIVE_ROOT (3)
#define ROLLING_HASH_MAX_MEMORY (2000000)
int ROLLING_HASH_MEM;
unsigned long long ROLLING_HASH_BASE;
unsigned long long ROLLING_HASH_IBASE;
unsigned long long*ROLLING_HASH_PW = NULL;
unsigned long long*ROLLING_HASH_IPW = NULL;
inline unsigned long long rollingHash61_mul(unsigned long long a, unsigned long long b){
  __uint128_t r = (__uint128_t) a * b;
  a = (r >> 61) + (r & ROLLING_HASH_MOD);
  if(a >= ROLLING_HASH_MOD){
    a -= ROLLING_HASH_MOD;
  }
  return a;
}
inline unsigned long long rollingHash61_pow(unsigned long long a, unsigned long long b){
  unsigned long long r = 1;
  for(;;){
    if(b&1){
      r = rollingHash61_mul(r, a);
    }
    if(b==0){
      break;
    }
    b >>= 1;
    a = rollingHash61_mul(a, a);
  }
  return r;
}
void rollingHashInit(){
  int i;
  Rand rnd;
  unsigned long long x;
  for(i=(0);i<(20);i++){
    rnd.get(2);
  }
  do{
    x = rnd.get(1.0, (double)(ROLLING_HASH_MOD-2));
  }
  while(GCD_L(x, ROLLING_HASH_MOD-1)!= 1);
  ROLLING_HASH_BASE = rollingHash61_pow(ROLLING_HASH_PRIMITIVE_ROOT, x);
  ROLLING_HASH_IBASE = rollingHash61_pow(ROLLING_HASH_BASE, ROLLING_HASH_MOD - 2);
}
void rollingHash_expand(int k){
  int i;
  if(ROLLING_HASH_MEM >= k){
    return;
  }
  ROLLING_HASH_MEM =max_L(2 * ROLLING_HASH_MEM, k);
  assert(ROLLING_HASH_MEM <= 2 * ROLLING_HASH_MAX_MEMORY);
  ROLLING_HASH_PW = (unsigned long long*) realloc(ROLLING_HASH_PW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_IPW = (unsigned long long*) realloc(ROLLING_HASH_IPW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_PW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_PW[i] = rollingHash61_mul(ROLLING_HASH_PW[i-1], ROLLING_HASH_BASE);
  }
  ROLLING_HASH_IPW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_IPW[i] = rollingHash61_mul(ROLLING_HASH_IPW[i-1], ROLLING_HASH_IBASE);
  }
}
struct rollingHash{
  long long len;
  unsigned long long hs;
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    hs = 0;
    len = N;
    rollingHash_expand(N);
    for(i=(0);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs += rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs >= ROLLING_HASH_MOD){
        hs -= ROLLING_HASH_MOD;
      }
    }
  }
  template<class S, class T> void change(long long ind, S bef, T aft){
    long long tmp1;
    long long tmp2;
    tmp1 = bef % ((long long)ROLLING_HASH_MOD);
    tmp2 = aft % ((long long)ROLLING_HASH_MOD);
    tmp1 = tmp2 - tmp1;
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 >= ROLLING_HASH_MOD){
      tmp1 -= ROLLING_HASH_MOD;
    }
    if(ind+1 <= ROLLING_HASH_MAX_MEMORY || ind+1 >= ROLLING_HASH_MEM){
      rollingHash_expand(ind+1);
      hs += rollingHash61_mul(tmp1, ROLLING_HASH_PW[ind]);
    }
    else{
      hs += rollingHash61_mul(tmp1, rollingHash61_pow(ROLLING_HASH_BASE, ind));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
  }
  void push_front(rollingHash a){
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_PW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_BASE, a.len));
    }
    hs += a.hs;
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void push_back(rollingHash a){
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      hs += rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      hs += rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void pop_front(rollingHash a){
    if(hs >= a.hs){
      hs -= a.hs;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - a.hs;
    }
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_IPW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_IBASE, a.len));
    }
    len -= a.len;
  }
  void pop_back(rollingHash a){
    unsigned long long tmp;
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      tmp = rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      tmp = rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= tmp){
      hs -= tmp;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - tmp;
    }
    len -= a.len;
  }
  bool operator==(const rollingHash a){
    return len == a.len && hs == a.hs;
  }
  bool operator!=(const rollingHash a){
    return len != a.len || hs != a.hs;
  }
}
;
template<class T> rollingHash calcRollingHash(int N, T A[]){
  rollingHash res;
  res.set(N, A);
  return res;
}
struct rollingHashSubarrays{
  unsigned long long*hs;
  int mem;
  int len;
  void set(){
    hs = NULL;
    mem = len = 0;
  }
  void free(){
    if(mem){
      delete[] hs;
    }
  }
  void expand(int k){
    if(mem >= k){
      return;
    }
    free();
    mem =max_L(2*mem, k);
    hs = new unsigned long long[mem];
  }
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    if(N <= 0){
      return;
    }
    rollingHash_expand(N);
    expand(N);
    len = N;
    tmp = A[0] % ((long long)ROLLING_HASH_MOD);
    if(tmp < 0){
      tmp += ROLLING_HASH_MOD;
    }
    hs[0] = tmp;
    for(i=(1);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs[i] = hs[i-1] + rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs[i] >= ROLLING_HASH_MOD){
        hs[i] -= ROLLING_HASH_MOD;
      }
    }
  }
  rollingHash get_len(int s, int len){
    unsigned long long x;
    rollingHash res;
    res.len = len;
    rollingHash_expand(s+1);
    if(s == 0){
      res.hs = hs[len-1];
    }
    else{
      if(hs[s+len-1] >= hs[s-1]){
        res.hs = hs[s+len-1] - hs[s-1];
      }
      else{
        res.hs = hs[s+len-1] + ROLLING_HASH_MOD - hs[s-1];
      }
      res.hs = rollingHash61_mul(res.hs, ROLLING_HASH_IPW[s]);
    }
    return res;
  }
  rollingHash get(int a, int b){
    return get_len(a, b - a + 1);
  }
  rollingHashSubarrays(){
    set();
  }
  ~rollingHashSubarrays(){
    free();
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  {
    rollingHashInit();
  }
  return 0;
}
#undef main
int a[1000000];
rollingHash arr1[1000000];
rollingHash arr2[1000000];
rollingHash one[1000000];
graph g;
int M;
int A[1000000];
int B[1000000];
int pre[1000000];
class Solution{
  public:
  vector<bool> findAnswer(vector<int>& p, string s){
    int OA9NF42T;
    dummy_main();
    int i;
    int k;
    int N = p.size();
    vector<bool> res(N);
    M = N-1;
    for(i=(1);i<(N);i++){
      A[i-1] = p[i];
      B[i-1] = i;
    }
    g.setEdge(N,M,A,B);
    g.preorder(pre);
    for(i=(0);i<(N);i++){
      a[i] = s[i];
    }
    for(i=(0);i<(N);i++){
      arr1[i] = arr2[i] = calcRollingHash(0, a);
    }
    for(i=(0);i<(N);i++){
      one[i] = calcRollingHash(1, a+i);
    }
    for(OA9NF42T=(N)-1;OA9NF42T>=(0);OA9NF42T--){
      auto&i = pre[OA9NF42T];
      arr1[i].push_back(one[i]);
      arr2[i].push_front(one[i]);
      k = p[i];
      if(k >= 0){
        arr1[k].push_front(arr1[i]);
        arr2[k].push_back(arr2[i]);
      }
      res[i] = (arr1[i] == arr2[i]);
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// int a[1d6];
// rollingHash arr1[1d6], arr2[1d6], one[1d6];
// 
// graph g;
// int M, A[1d6], B[1d6], pre[1d6];
// 
// class Solution {
// public:
//   vector<bool> findAnswer(vector<int>& p, string s) {
//     dummy_main();
//     int i, k;
//     int N = p.size();
//     vector<bool> res(N);
// 
//     M = N-1;
//     rep(i,1,N) A[i-1] = p[i], B[i-1] = i;
//     g.setEdge(N,M,A,B);
//     g.preorder(pre);
// 
//     rep(i,N) a[i] = s[i];
//     rep(i,N) arr1[i] = arr2[i] = calcRollingHash(0, a);
//     rep(i,N) one[i] = calcRollingHash(1, a+i);
// 
//     rrep[pre](i,N){
//       arr1[i].push_back(one[i]);
//       arr2[i].push_front(one[i]);
//       k = p[i];
//       if(k >= 0){
//         arr1[k].push_front(arr1[i]);
//         arr2[k].push_back(arr2[i]);
//       }
//       res[i] = (arr1[i] == arr2[i]);
//     }
// 
//     return res;
//   }
// };
",1427852708
LayCurse,LayCurse,35,3607,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
int fg = 0;
int go[1000000+1];
class Solution{
  public:
  int minOperations(vector<int>& A){
    int i;
    int N = A.size();
    int res = 0;
    if(!fg){
      int i;
      fg = 1;
      for(i=(0);i<(1000000+1);i++){
        go[i] = -1;
      }
      for(i=(2);i<(1000000+1);i++){
        int j;
        for(j=(2*i);j<(1000000+1);j+=(i)){
          if(go[j]==-1){
            go[j] = i;
          }
        }
      }
    }
    for(i=(N-1)-1;i>=(0);i--){
      if(A[i] > A[i+1]){
        res++;
        A[i] = go[A[i]];
        if(A[i]==-1 || A[i] > A[i+1]){
          return -1;
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// int fg = 0;
// int go[1d6+1];
// 
// class Solution {
// public:
//   int minOperations(vector<int>& A) {
//     int N = A.size();
//     int res = 0;
// 
//     if(!fg){
//       fg = 1;
//       rep(i,1d6+1) go[i] = -1;
//       rep(i,2,1d6+1) rep(j,2*i,1d6+1,i) if(go[j]==-1) go[j] = i;
//     }
// 
//     rrep(i,N-1){
//       if(A[i] > A[i+1]){
//         res++;
//         A[i] = go[A[i]];
//         if(A[i]==-1 || A[i] > A[i+1]) return -1;
//       }
//     }
// 
// 
//     return res;
//   }
// };
",1427833692
Agnibha Chakraborty,zanj0,38,3502,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	int numberOfSubstrings(string s, int k) {
		lli ret = 0;
		lli n = s.size();
		for (int i = 0; i < n; i++) {
			map<char, lli> cnt;
			lli max_freq = 0;
			for (lli j = i; j < n; j++) {
				cnt[s[j]]++;
				max_freq = max(max_freq, cnt[s[j]]);
				if (max_freq >= k) ret++;
			}
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1427826764
Agnibha Chakraborty,zanj0,38,3566,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	vector<string> stringSequence(string target) {
		int n = target.size();
		vector<string> ret;
		for (int i = 0; i < n; i++) {
			ret.pb(ret.empty() ? ""a"" : ret.back() + ""a"");
			while (ret.back().back() != target[i]) {
				string now = ret.back();
				if (now.back() == 'z') {
					now.back() = 'a';
				} else {
					now.back()++;
				}
				ret.pb(now);
			}
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1427825307
Agnibha Chakraborty,zanj0,38,3603,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;
vector<int> manacher_odd(string s) {
	int n = s.size();

	s = ""$"" + s + ""^"";
	vector<int> p(n + 2);
	int l = 1, r = 1;
	for (int i = 1; i <= n; i++) {
		p[i] = max(0, min(r - i, p[l + (r - i)]));
		while (s[i - p[i]] == s[i + p[i]]) {
			p[i]++;
		}
		if (i + p[i] > r) {
			l = i - p[i], r = i + p[i];
		}
	}
	return vector<int>(begin(p) + 1, end(p) - 1);
}
vector<int> manacher(string s) {
	string t;
	for (auto c : s) {
		t += string(""#"") + c;
	}
	auto res = manacher_odd(t + ""#"");
	return vector<int>(begin(res) + 1, end(res) - 1);
}

bool IsPalindrome(int l, int r, vector<int>& v) {
	return v[l + r] >= r - l + 1;
}
int now = -1;
void Dfs(int node, int par, vector<vector<int>>& graph, string& s, vector<int>& low, vector<int>& high, string& s2) {
	now++;
	low[node] = s.size();

	for (auto& it : graph[node]) {
		if (it == par) continue;
		Dfs(it, node, graph, s, low, high,  s2);
	}
	s += s2[node];
	high[node] = s.size() - 1;
}

class Solution {
public:
	void Out(vector<int>& v) {
		for (auto& it : v) {
			cout << it << "" "";
		}
		cout << endl;
	}
	vector<bool> findAnswer(vector<int>& parent, string s) {
		now = -1;
		vector<bool> ret;
		// string ss = ""abaaba"";
		// vector<int> m = manacher(ss);
		// cout << IsPalindrome(0, ss.size() - 1, m) << endl;
		// Out(m);
		int n = parent.size();
		vector<int> low(n), high(n);
		vector<vector<int>> graph(n);;

		for (int i = 0; i < n; i++) {
			if (parent[i ] != -1) {
				graph[i].pb(parent[i]);
				graph[parent[i]].pb(i);
			}
		}
		string curr = """";
		Dfs(0, -1, graph, curr, low, high, s);
		// cout << curr << endl;
		vector<int> m = manacher(curr);
		// Out(m);
		// for (int i = 0; i < n; i++) {
		// 	cout << low[i] << "" "" << high[i] << endl;
		// }
		for (int i = 0; i < n; i++) {
			ret.pb(IsPalindrome(low[i], high[i], m));
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
	vector<int> x = { -1, 0, 0, 1, 1, 2};
	Solution s;
	s.findAnswer(x, ""aababa"");
}
#endif",1427869494
Agnibha Chakraborty,zanj0,38,3607,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

const lli N = 1e6 + 5;
lli fact[N];
bool done = false;
void Pre() {
	if (done) return;
	done = true;
	for (int i = 0; i < N; i++) fact[i] = i;
	for (int i = 2; i < N; i++) {
		for (int j = i + i; j < N; j += i)fact[j] = i;
	}

}
class Solution {
public:
	int minOperations(vector<int>& nums) {
		Pre();
		lli ret = 0;
		lli n = nums.size();
		for (int i = n - 2; i >= 0; i--) {
			while (nums[i] > nums[ i + 1]) {
				if (fact[nums[i]] == nums[i]) return -1;
				ret++;
				nums[i] /= fact[nums[i]];
			}
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1427832039
garyjhu,garyjhu,39,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int[] freq = new int[26];
        int count = 0;
        int res = 0;
        for (int i = 0, j = 0; i < n; i++) {
            while (j < n && count == 0) {
                char c = s.charAt(j);
                freq[c - 'a']++;
                if (freq[c - 'a'] == k) count++;
                j++;
            }
            if (count > 0) res += n - j + 1;
            freq[s.charAt(i) - 'a']--;
            if (freq[s.charAt(i) - 'a'] == k - 1) count--;
        }
        return res;
    }
}
",1427830016
garyjhu,garyjhu,39,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        int n = target.length();
        for (int i = 0; i < n; i++) {
            for (char c = 'a'; c <= target.charAt(i); c++) {
                res.add(sb.toString() + c);
            }
            sb.append(target.charAt(i));
        }
        return res;
    }
}
",1427824869
garyjhu,garyjhu,39,3603,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    int n, t;
    int[] in, out;
    char[] ch;
    public boolean[] findAnswer(int[] parent, String s) {
        n = parent.length;
        ch = s.toCharArray();
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i].add(parent[i]);
            adj[parent[i]].add(i);
        }
        char[] list = new char[n];
        in = new int[n];
        out = new int[n];
        dfs(adj, 0, -1, list);
        int[] man = ManachersAlgorithm.manachers(list);
        boolean[] res = new boolean[n];
        for (int i = 0; i < n; i++) {
            int start = in[i], end = out[i];
            int mid = (2 * start + 2 * end) / 2 + 2;
            res[i] = man[mid] >= end - start;
        }
        return res;
    }

    private void dfs(List<Integer>[] adj, int v, int parent, char[] list) {
        in[v] = t;
        for (int w : adj[v]) {
            if (w == parent) continue;
            dfs(adj, w, v, list);
        }
        out[v] = t;
        list[t++] = ch[v];
    }

    public static class ManachersAlgorithm {

        public static int[] manachers(char[] str) {
            char[] arr = preProcess(str);
            int n = arr.length, c = 0, r = 0;
            int[] p = new int[n];
            for (int i = 1; i < n - 1; i++) {
                int invI = 2 * c - i;
                p[i] = r > i ? Math.min(r - i, p[invI]) : 0;
                while (arr[i + 1 + p[i]] == arr[i - 1 - p[i]]) p[i]++;
                if (i + p[i] > r) {
                    c = i;
                    r = i + p[i];
                }
            }
            return p;
        }

        private static char[] preProcess(char[] str) {
            char[] arr = new char[str.length * 2 + 3];
            arr[0] = '^';
            for (int i = 0; i < str.length; i++) {
                arr[i * 2 + 1] = '#';
                arr[i * 2 + 2] = str[i];
            }
            arr[arr.length - 2] = '#';
            arr[arr.length - 1] = '$';
            return arr;
        }
    }
}
",1427869773
garyjhu,garyjhu,39,3607,java,"class Solution {
    static int N = 1_000_000;
    static int[] spf;
    public int minOperations(int[] nums) {
        if (spf == null) init();
        int n = nums.length;
        int res = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                nums[i] = spf[nums[i]];
                res++;
            }
            if (nums[i] > nums[i + 1]) return -1;
        }
        return res;
    }

    private static void init() {
        spf = new int[N + 1];
        for (int i = 2; i <= N; i++) {
            if (spf[i] == 0) {
                for (int j = i; j <= N; j += i) {
                    if (spf[j] == 0) spf[j] = i;
                }
            }
        }
        spf[1] = 1;
    }
}
",1427843476
delphih,delphih,40,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        cntc, cntf = Counter(), 0
        q = 0
        res = 0
        for p in range(n):
            while q < n and cntf < 1:
                cntc[s[q]] += 1
                if cntc[s[q]] == k: cntf += 1
                q += 1
            if cntf > 0: res += n - q + 1
            cntc[s[p]] -= 1
            if cntc[s[p]] == k - 1: cntf -= 1
        return res",1427833027
delphih,delphih,40,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = ''
        for c in target:
            for i in ascii_lowercase:
                res.append(cur + i)
                if i == c: break
            cur += c
        return res",1427825611
delphih,delphih,40,3603,python3,"def m(s: str) -> str:
    s2 = '#' + '#'.join(s) + '#'
    ln2 = len(s2)
    d = [1] * ln2
    pre = 0
    for i in range(1, ln2 - 1):
        if pre + d[pre] > i:
            d[i] = min(pre + d[pre] - i, d[pre-(i-pre)])
        while 0 <= i-d[i] and i+d[i] < ln2 and s2[i-d[i]] == s2[i+d[i]]:
            d[i] += 1
        if i + d[i] > pre + d[pre]: pre = i
    d = [x-1 for x in d]
    return d
    mxi = max(range(ln2), key=d.__getitem__)
    return s[(mxi-d[mxi])//2:(mxi+d[mxi])//2]

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i, pa in enumerate(parent):
            if pa != -1: g[pa].append(i)
        lrs = [None] * n
        sb = []
        def dfs(p):
            pos0 = len(sb)
            for ch in g[p]:
                dfs(ch)
            sb.append(s[p])
            lrs[p] = [pos0, len(sb)]
        dfs(0)
        # print(''.join(sb))
        # print(lrs)
        # print(list('#' + '#'.join(sb) + '#'))
        d = m(sb)
        # print(d)
        res = []
        for l, r in lrs:
            res.append(d[l+r] >= r - l)
        return res",1427869802
delphih,delphih,40,3607,python3,"P = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def f(x):
            for p in P:
                if p * p > x: break
                if x % p == 0: return p
            return x
        res = 0
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] > nums[i+1]:
                nums[i] = f(nums[i])
                if nums[i] > nums[i+1]: return -1
                res += 1
        return res",1427840426
IphoneX,hahahiehie,43,3502,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static class StringCountPreSum {
        int[][] preCount;

        public StringCountPreSum(String s) {
            int n = s.length();
            preCount = new int[n + 1][26];
            for (int i = 0; i < n; i++) {
                for (int c = 0; c < 26; c++) preCount[i + 1][c] = preCount[i][c];
                preCount[i + 1][s.charAt(i) - 'a']++;
            }
        }

        // [l, r] inclusive, 0 <= l, r <= n - 1
        public boolean querySubstring(int l, int r, int k) {
            // if (l > r) TODO: Add error handling if needed
            for (int c = 0; c < 26; c++) {
                int count = preCount[r + 1][c] - preCount[l][c];
                if (count >= k) return true; // TODO: Add check condition
            }
            return false;
        }
    }
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        
        StringCountPreSum sum = new StringCountPreSum(s);
        
        int ans =0 ;
        for (int i = 0; i < n; i++) {
            for (int j = i + k - 1; j < n; j++) {
                if (sum.querySubstring(i, j, k)) {
                    ans++;
                }
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427829313
IphoneX,hahahiehie,43,3566,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    public List<String> stringSequence(String target) {
        int n = target.length();
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append('a');
            int c = target.charAt(i) - 'a';
            for (int j = 0; j <= c; j++) {
                sb.setCharAt(i, (char) (j + 'a'));
                ans.add(sb.toString());
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427825826
IphoneX,hahahiehie,43,3603,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    int n;
    GraphIntegerFaster g;
    String s;
    int[] startIndex;
    int[] endIndex;
    StringBuilder sb = new StringBuilder();

    String s1, s2;
    StringHash h1, h2;
    boolean check(int l, int r) {
        int len = r - l + 1;
        if (len == 1) return true;
        if (len % 2 == 0) {
            int mid = (l + r) / 2;
            long left = h1.hash(l, mid);
            long right = h2.hash(n - r - 1, n - (mid + 1) - 1);
            return left == right;
        } else {
            int mid = (l + r) / 2;
            long left = h1.hash(l, mid);
            long right = h2.hash(n - r - 1, n - (mid) - 1);
            return left == right;
        }
    }
    public boolean[] findAnswer(int[] parent, String s) {
        n = parent.length;
        g = new GraphIntegerFaster(n);
        this.s = s;
        startIndex = new int[n];
        endIndex = new int[n];
        for (int i = 1; i < n; i++) {
            g.link(parent[i], i);
        }

        dfs(0);
        s1 = sb.toString();
        s2 = new StringBuilder(s1).reverse().toString();
        h1 = new StringHash(s1);
        h2 = new StringHash(s2);

        boolean[] ans = new boolean[n];

        for (int i = 0; i < n; i++) {
            ans[i] = check(startIndex[i], endIndex[i]);
        }
        return ans;
    }

    void dfs(int x) {
        startIndex[x] = sb.length();
        for (int y : g.getChildren(x)) {
            dfs(y);
        }
        endIndex[x] = sb.length();
        sb.append(s.charAt(x));
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427871787
IphoneX,hahahiehie,43,3607,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int MAX_N = 1000_000 + 1;
    static int[] genFactors(int n) {
        int[] factors = new int[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = i + i; j <= n; j += i) {
                factors[j] = i;
            }
        }
        return factors;
    }
    
    static int[] factors = genFactors(MAX_N);
    public int minOperations(int[] nums) {
           int n = nums.length;
           int ans = 0;
           for (int i = n - 2; i >= 0; i--) {
               if (nums[i] > nums[i + 1]) {
                   nums[i] /= factors[nums[i]];
                    ans++;
               }
               if (nums[i] > nums[i + 1]) return -1;
           }
           return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427841603
Javier,JavOliva,45,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<vector<int> > c(n, vector<int>(26));
        for (int i = 0; i < n; i ++){
            c[i][s[i] - 'a'] ++;
            for (int j = 0; j < 26; j ++){
                if (i > 0)
                    c[i][j] += c[i - 1][j];
            }
        }
        int answer = 0;
        for (int i = 0; i < n; i ++){
            int left = i, right = n;
            while(left < right){
                int mid = (left + right) / 2;
                bool oka = false;
                for (int j = 0; j < 26; j ++){
                    int hay = c[mid][j] - (i > 0 ? c[i - 1][j] : 0);
                    if (hay >= k)
                        oka = true;
                }
                if (oka){
                    right = mid;
                }
                else{
                    left = mid + 1;
                }
            }
            answer += (n - right);
        }
        return answer;
    }
};",1427829905
Javier,JavOliva,45,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> A;
        string w = """";
        for (char x : target){
            w.push_back('a');
            A.push_back(w);
            while(w.back() < x){
                w[w.size() - 1] ++;
                A.push_back(w);
            }
        }
        return A;
    }
};",1427825015
Javier,JavOliva,45,3603,cpp,"typedef long long ll;
ll mod = 1e9 + 7;
ll mod2 = 1e9 + 123;
template<class T> struct IterativeSegmentTree{
  int n; vector<T> ST; T (*m_)(T, T);
  IterativeSegmentTree(vector<T> &a,T(*m_)(T,T)):m_(m_){
    n = a.size(); ST.resize(n << 1);
    for (int i=n;i<(n<<1);i++)ST[i]=a[i-n];
    for (int i=n-1;i>0;i--)ST[i]=m_(ST[i<<1],ST[i<<1|1]);
  }
  void update(int pos, T val){ // replace with val
    ST[pos += n] = val;
    for (pos >>= 1; pos > 0; pos >>= 1)
      ST[pos] = m_(ST[pos<<1], ST[pos<<1|1]);
  }
  T query(int l, int r){ // [l, r]
    T ansL, ansR; bool hasL = 0, hasR = 0;
    for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
      if (l & 1) 
        ansL=(hasL?m_(ansL,ST[l++]):ST[l++]),hasL=1;
      if (r & 1) 
        ansR=(hasR?m_(ST[--r],ansR):ST[--r]),hasR=1;
    }
    if (!hasL) return ansR; if (!hasR) return ansL;
    return m_(ansL, ansR);
  }
}; // Give vector of leaves and merge function
 
vector<ll> pot;
vector<ll> pot2;
 
pair<ll, ll> merge(pair<ll, ll> a, pair<ll, ll> b){
  return {(a.first + b.first * pot[a.second]) % mod, a.second + b.second};
}

pair<ll, ll> merge2(pair<ll, ll> a, pair<ll, ll> b){
    return {(a.first + b.first * pot2[a.second]) % mod2, a.second + b.second};
}
const int maxn = 1e5 + 5;
bool computed = false;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        if (!computed){
            pot.resize(maxn, 1);
            pot2.resize(maxn, 1);
            for (int i = 1; i < pot.size(); i ++){
                pot[i] = (pot[i - 1] * 139) % mod;
                pot2[i] = (pot2[i - 1] * 31) % mod2;
            }
            computed = true;
        }
        vector<vector<int> > adj(n);
        for (int i = 1; i < n; i ++){
            adj[parent[i]].push_back(i);
        }
        for (int i = 0; i < n; i ++)
            sort(adj[i].begin(), adj[i].end());
        vector<pair<ll, ll> > wea;
        vector<int> l(n), r(n);
        function<void (int)> dfs = [&](int u){
            l[u] = wea.size();
            for (int v : adj[u]){
                dfs(v);
            }
            r[u] = wea.size();
            wea.emplace_back((ll)s[u], 1LL);
        };
        dfs(0);
        vector<bool> ans(n);
        vector<pair<ll, ll> > s2 = wea;
        reverse(s2.begin(), s2.end());
        cout << wea.size() << endl;
        IterativeSegmentTree<pair<ll, ll> > T1(wea, merge), T2(s2, merge);
        IterativeSegmentTree<pair<ll, ll> > P1(wea, merge2), P2(s2, merge2);
        for (int i = 0; i < n; i ++){
            int a = l[i], b = r[i];
            ll v1 = T1.query(a, b).first;
            ll v2 = T2.query(n - 1 - b, n - 1 - a).first;
            ll v3 = P1.query(a, b).first;
            ll v4 = P2.query(n - 1 - b, n - 1 - a).first;
            if (v1 == v2 and v3 == v4){
                ans[i] = 1;
            }
            else{
                ans[i] = 0;
            }
        }
        return ans;
    }
};",1427864930
Javier,JavOliva,45,3607,cpp,"typedef long long ll;
const int maxx = 1e6 + 1;
int criba[maxx];
bool computed = false;
class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (!computed){
            iota(criba, criba + maxx, 0);
            for (int i = 4; i < maxx; i += 2){
                criba[i] = 2;
            }
            for (int i = 3; i < maxx; i += 2){
                if (criba[i] == i){
                    for (ll j = (ll)i * i; j < maxx; j += i){
                        criba[j] = min(criba[j], i);
                    }
                }
            }
            computed = true;
        }
        int n = nums.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i --){
            if (nums[i] > nums[i + 1]){
                ans ++;
                nums[i] = criba[nums[i]];
            }
            if (nums[i] > nums[i + 1]){
                return -1;
            }
        }
        return ans;
    }
};",1427838092
OTTFF,OTTFF,46,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();

        int ans = 0;
        map<char, int> cnt;

        auto check = [&]() {
            for (auto&& [v, c] : cnt) {
                if (c >= k) return true;
            }
            return false;
        };

        int r = 0;
        for (int l = 0; l < n; l++) {
            while (r <= l || r < n && !check()) {
                cnt[s[r]]++;
                r++;
            }

            if (!check()) break;

            // cout << l << ' ' << r << endl;

            ans += n - r + 1;

            cnt[s[l]]--;
        }
        return ans;
    }
};",1427833845
OTTFF,OTTFF,46,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        string s;
        int len = 0;
        vector<string> ans;

        while (s != t) {
            if (len == 0 || s[len - 1] == t[len - 1]) {
                s += 'a';
                len++;
            } else {
                s[len - 1] = s[len - 1] + 1;
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1427826647
OTTFF,OTTFF,46,3603,cpp,"template<typename Func> struct YCombinatorResult {
  Func func;
  template<typename T>
  explicit YCombinatorResult(T &&func) : func(std::forward<T>(func)) {}
  template<class ...Args> decltype(auto) operator()(Args &&...args) {
    return func(std::ref(*this), std::forward<Args>(args)...);
  }
};
template<typename Func> decltype(auto) y_comb(Func &&fun) {
  return YCombinatorResult<std::decay_t<Func>>(std::forward<Func>(fun));
}

template<typename T = char, T ST_CHAR = '$', T MD_CHAR = '*', T ED_CHAR = '#'>
struct Manacher {
  vector<T> t;
  vector<int> max_extend;

  Manacher(const vector<T>& s) {
    t.push_back(ST_CHAR);
    t.push_back(MD_CHAR);
    for (auto i : s) {
      t.push_back(i);
      t.push_back(MD_CHAR);
    }
    t.push_back(ED_CHAR);

    int m = t.size();
    max_extend.assign(m, 0);
    max_extend[1] = 1;
    int j = 1;
    for (int i = 2; i < m - 1; i++) {
      int cur_max_extend =
          (j + max_extend[j] > i)
          ? min(max_extend[j * 2 - i], j + max_extend[j] - i)
          : 1;

      while (t[i - cur_max_extend] == t[i + cur_max_extend]) {
          cur_max_extend++;
      }
      if (i + cur_max_extend > j + max_extend[j]) {
          j = i;
      }
      max_extend[i] = cur_max_extend;
    }
  }

  int tid(int i) const { return i * 2 + 2; }
  int oddlen(int o) const { // center at o
    return max_extend[tid(o)] - 1;
  }
  int evenlen(int o) const { // center at the middle of o, o+1
    return max_extend[tid(o) + 1] - 1;
  }

  pair<int, int> center_2_lr(int o) const {
    return {(o - max_extend[o]) / 2, (o + max_extend[o]) / 2 + 2};
  }


  int get_length(int i) { return max_extend[i] - 1; }
  int get_start(int i) { return (i - max_extend[i]) / 2; }
  int get_end(int i) { return (i + max_extend[i]) / 2 - 2; }

  vector<int> getl() { // [i - l[i] + 1, i]
    int n = t.size() / 2 - 1;
    vector<int> l(n);
    for (int i = 2; i <= n * 2; i++)
        l[get_end(i)] = max(l[get_end(i)], get_length(i));
    for(int i = n - 2; i >= 0; i--) l[i] = max(l[i] , l[i + 1] - 2);
    return l;
  }
  vector<int> getr() { // [i, i + r[i] - 1]
    int n = t.size() / 2 - 1;
    vector<int> r(n);
    for (int i = 2; i <= n * 2; i++)
        r[get_start(i)] = max(r[get_start(i)], get_length(i));
    for (int i = 1; i < n; i++) r[i] = max(r[i], r[i - 1] - 2);
    return r;
  }
};

vector<char> to_vec(const string& s) {
  vector<char> ans;
  for (char c : s) ans.push_back(c);
  return ans;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string val) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }

        vector<int> indfs(n), outdfs(n);
        int ndfn = 0;

        string s;
        y_comb([&](auto dfs, int u) -> void {
            indfs[u] = ndfn;
            for (int v : g[u]) {
                dfs(v);
            }
            s += val[u];
            outdfs[u] = ndfn++;
        })(0);

        // cout << s << endl;
        // for (int i : indfs) cout << i << ' ';
        // cout << endl;
        // for (int i : outdfs) cout << i << ' ';
        // cout << endl;

        Manacher mana(to_vec(s));

        vector<bool> ans(n);

        for (int i = 0; i < n; i++) {
            int l = indfs[i], r = outdfs[i];
            int len = r - l + 1;
            if (len & 1) {
                ans[i] = mana.oddlen((l + r) / 2) >= len;
            } else {
                ans[i] = mana.evenlen((l + r) / 2) >= len;
            }
        }
        return ans;
    }
};",1427865054
OTTFF,OTTFF,46,3607,cpp,"vector<int> isp, pri, minfac, maxfac;
void init_prime(int n) {
  isp.assign(n + 1, 1); isp[0] = isp[1] = 0;
  minfac.assign(n + 1, 0);
  maxfac.assign(n + 1, 0);
  for(int i = 2; i <= n; i++) {
    if(isp[i]) { pri.push_back(i); isp[i] = pri.size(); minfac[i] = i; }
    for(int p : pri) {
      if (i > n / p) break;
      isp[i * p] = 0;
      minfac[i * p] = p;
      if(i % p == 0) break;
    }
  }
  for (int i = 2; i <= n; i++) {
    maxfac[i] = max(maxfac[i / minfac[i]], minfac[i]);
  }
}

int f = 0;
void init() {
    if (f) return;
    f = 1;
    init_prime(1000001);
}

class Solution {
public:
    int minOperations(vector<int>& a) {
        init();
        int n = a.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (a[i] > a[i + 1]) {
                // cout << a[i] << ' ' << maxfac[a[i]] << endl;
                if (minfac[a[i]] == a[i]) return -1;

                a[i] = minfac[a[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427847202
Liwei Cai,cai_lw,47,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        array<int,26> cnt{};
        vector<int> cntcnt(k+1);
        int n=s.size(),j=0,ans=0;
        for(int i=0;i<n;i++){
            while(j<n&&cntcnt.back()==0){
                int& c=cnt[s[j]-'a'];
                if(c<k){
                    cntcnt[c]--;
                    cntcnt[c+1]++;
                }
                c++;
                j++;
            }
            if(cntcnt.back()>0)
                ans+=n-j+1;
            int& c=cnt[s[i]-'a'];
            if(c<=k){
                    cntcnt[c]--;
                    cntcnt[c-1]++;
            }
            c--;
        }
        return ans;
    }
};",1427829521
Liwei Cai,cai_lw,47,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans{""a""};
        while(ans.back()!=target){
            string last=ans.back();
            if(target[last.size()-1]==last.back())
                last.push_back('a');
            else
                last.back()++;
            ans.push_back(last);
        }
        return ans;
    }
};",1427824185
Liwei Cai,cai_lw,47,3603,cpp,"class Solution {
    // https://cp-algorithms.com/string/manacher.html
    vector<int> manacher_odd(string s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    vector<int> manacher(string s) {
        string t;
        for(auto c: s) {
            t += string(""#"") + c;
        }
        auto res = manacher_odd(t + ""#"");
        return vector<int>(begin(res) + 1, end(res) - 1);
    }
    void dfs(int u,const vector<vector<int>>& children,const string& s,string& o,vector<pair<int,int>>& lr){
        lr[u].first=o.size();
        for(int v:children[u])
            dfs(v,children,s,o,lr);
        o+=s[u];
        lr[u].second=o.size();
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=s.size();
        vector<vector<int>> children(n);
        for(int i=1;i<n;i++)
            children[parent[i]].push_back(i);
        string o;
        vector<pair<int,int>> lr(n);
        dfs(0,children,s,o,lr);
        auto d=manacher(o);
        vector<bool> ans(n);
        for(int i=0;i<n;i++){
            auto [l,r]=lr[i];
            ans[i]=d[l+r-1]-1>=r-l;
        }
        return ans;
    }
};",1427865079
Liwei Cai,cai_lw,47,3607,cpp,"class Solution {
    // https://cp-algorithms.com/algebra/prime-sieve-linear.html
    vector<int> linear_sieve(int N){
        vector<int> lp(N+1);
        vector<int> pr;

        for (int i=2; i <= N; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for (int j = 0; i * pr[j] <= N; ++j) {
                lp[i * pr[j]] = pr[j];
                if (pr[j] == lp[i]) {
                    break;
                }
            }
        }
        return lp;
    }
public:
    int minOperations(vector<int>& nums) {
        constexpr int INF=1e9;
        auto lp=linear_sieve(*max_element(nums.begin(),nums.end()));
        array<int,2> dp{0,1};
        for(int i=1;i<nums.size();i++){
            array<int,2> dp2{INF,INF};
            if(nums[i]>=nums[i-1])
                dp2[0]=min(dp2[0],dp[0]);
            if(nums[i]>=lp[nums[i-1]])
                dp2[0]=min(dp2[0],dp[1]);
            if(lp[nums[i]]>1){
                if(lp[nums[i]]>=nums[i-1])
                    dp2[1]=min(dp2[1],dp[0]+1);
                if(lp[nums[i]]>=lp[nums[i-1]])
                    dp2[1]=min(dp2[1],dp[1]+1);
            }
            dp=dp2;
        }
        int ans=min(dp[0],dp[1]);
        return ans==INF?-1:ans;
    }
};",1427842512
mastoori1234,mastoori1234,50,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int n = s.length();
        int ans = 0;
        
        vector< vector<int> > idx(26, vector<int>());
        
        for( int i=n-1; i>=0; i--) {
            int c = s[i]-'a';
            idx[c].push_back(i);
        }
        
        for( int i=0; i<n; i++) {
            int t = n;
            for( int j=0; j<26; j++) {
                int m = idx[j].size();
                if(m>=k) {
                    t = min( t, idx[j][m-k]);
                }
            }
            ans += (n-t);
            int c = s[i]-'a';
            idx[c].pop_back();
        }        
        
        return ans;
    }
};",1427867360
mastoori1234,mastoori1234,50,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        
        vector<string> res;
        
        string t = ""a"";
        
        while(true) {
            res.push_back(t);
            int n = t.length();
            if(t[n-1]==s[n-1]) {
                if(t.length()==s.length()) {
                    break;
                } else {
                    t.push_back('a');
                }
            } else {
                t.back() += 1;
            }
        }
        
        
        return res;
    }
};",1427873939
mastoori1234,mastoori1234,50,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& par, string s) {
        
        
        int n = s.length();
        vector<bool> res(n);
        
        vector< vector<int> > adj( n, vector<int>());
        vector< pair<int,int> > cover(n);        
        string t = """";
        
        for( int i=1; i<n; i++) {
            adj[par[i]].push_back(i);
        }
        
        function<void(int)> dfs;
        
        dfs = [&]( int idx)->void {
            int sIdx = t.length();
            sort( adj[idx].begin(), adj[idx].end());
            for( int child: adj[idx]) {
                dfs(child);
            }
            int eIdx = t.length();
            t.push_back(s[idx]);
            cover[idx] = { sIdx, eIdx};
        };
        
        dfs(0);
        
        vector<int> d1( n, 1);
        vector<int> d2( n, 0);
        
        for( int i=0, l=-1, r=-1; i<n; i++) {
            int k = (i>r)?1:min( d1[l+r-i], r-i+1);
            while((i-k>=0) && (i+k<n) && (t[i-k]==t[i+k])) {
                k += 1;
            }
            d1[i] = k--;
            if(i+k>r) {
                l = i-k;
                r = i+k;
            }
        }
        
        for( int i=1, l=0, r=0; i<n; i++) {
            int k = (i>r)?0:min( d2[l+r-i+1], r-i+1);
            while((i-k-1>=0) && (i+k<n) && (t[i-k-1]==t[i+k])) {
                k += 1;
            }
            d2[i] = k--;
            if(i+k>r) {
                l = i-k-1;
                r = i+k;
            }
        }
        
        for( int i=0; i<n; i++) {
            int l = cover[i].second - cover[i].first + 1;
            int mid = (cover[i].second + cover[i].first + 1)/2;
            if(l%2==0) {
                res[i] = (d2[mid]>=(cover[i].second-mid+1));
            } else {
                res[i] = (d1[mid]>=(cover[i].second-mid+1));
            }
        }
        
        return res;
    }
};",1427844251
mastoori1234,mastoori1234,50,3607,cpp,"const int N = 1e6;
int spd[N+1];

class Solution {
public:
    
    Solution() {
        if(spd[0]==-1) {
            return;
        }
        fill( begin(spd), end(spd), -1);
        for( int i=2; i<=N; i++) {
            if(spd[i]==-1) {
                for( int j=i+i; j<=N; j+=i) {
                    if(spd[j]==-1) {
                        spd[j] = i;
                    }
                }
            }
        }
    }
    
    int minOperations(vector<int>& arr) {
        int n = arr.size();
        int c0 = 0;
        int c1 = (spd[arr[0]]==-1)?(2*n):1;
        for( int i=1; i<n; i++) {
            int nc0 = 2*n;
            int nc1 = 2*n;
            if(arr[i]>=arr[i-1]) {
                nc0 = min( nc0, c0);
            }
            if((spd[arr[i-1]]!=-1) && (arr[i]>=spd[arr[i-1]])) {
                nc0 = min( nc0, c1);
            }
            if((spd[arr[i]]!=-1) && (spd[arr[i]]>=arr[i-1])) {
                nc1 = min( nc1, 1+c0);
            }
            if((spd[arr[i]]!=-1) && (spd[arr[i-1]]!=-1) && (spd[arr[i]]>=spd[arr[i-1]])) {
                nc1 = min( nc1, 1+c1);
            }
            c0 = nc0;
            c1 = nc1;
        }
        int ans = min( c0, c1);
        return (ans>n)?(-1):ans;
    }
};",1427861938
otto,_otto,51,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            freq = [0] * 26
            ok = False
            for j in range(i, n):
                freq[ord(s[j]) - 97] += 1
                if freq[ord(s[j]) - 97] == k:
                    ok = True
                if ok: ans += 1
        return ans",1427826106
otto,_otto,51,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        
        ans = [target]
        while ans[-1] != 'a':
            lst = ans[-1]
            if lst[-1] == 'a':
                ans.append(lst[:-1])
            else:
                fuck = lst[:-1]
                ans.append(fuck + chr(ord(lst[-1]) - 1))
        return ans[::-1]",1427824278
otto,_otto,51,3603,python3,"power = random.randint(150, 200)
mod = random.getrandbits(32)
powers = [1]
for _ in range(int(1e5) + 1): powers.append(powers[-1] * power % mod)
    
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        ans = [False] * n
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        def dfs(u):
            h = 0
            hr = 0
            tot = 0
            for v in sorted(tree[u]):
                h_v, hr_v, len_v = dfs(v)
                h = (h * powers[len_v] + h_v) % mod
                hr = (hr_v * powers[tot] + hr) % mod
                tot += len_v
            c = ord(s[u])
            h = (h * power + c) % mod
            hr = (c * powers[tot] + hr) % mod
            tot += 1
            if h == hr:
                ans[u] = True
            else:
                ans[u] = False
            return h, hr, tot
        dfs(0)
        return ans",1427866191
otto,_otto,51,3607,python3,"def sieve(MAXN):
    spf = [0] * (MAXN + 1)
    spf[0], spf[1] = 0, 1
    for i in range(2, MAXN + 1):
        if spf[i] == 0:
            spf[i] = i
            for j in range(i * 2, MAXN + 1, i):
                if spf[j] == 0:
                    spf[j] = i
    return spf
spf = sieve(int(1e6) + 1)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        
        ans = 0
        target = nums[-1]

        for i in range(len(nums) - 2, -1, -1):
            curr = nums[i]
            while curr > target:
                if curr == 1:
                    return -1
                gpd = curr // spf[curr]
                if gpd == 0: return -1
                if gpd == 1 and curr > target: return -1
                curr = curr // gpd
                ans += 1
            target = curr

        return ans",1427840965
kevinbu,kevinbu,52,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = {}
        total = 0
        left = 0
        for right in range(len(s)):
            cur = s[right]
            count[cur] = count.get(cur, 0) + 1
            while left <= right and count[cur] >= k:
                temp = s[left]
                count[temp] -= 1
                left += 1
            total += right - left + 1
        
        res = (len(s) + 1) * len(s) // 2
        res -= total
        return res
        ",1427839830
kevinbu,kevinbu,52,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = """"
        for i in range(len(target)):
            index = ord(target[i]) - ord('a')
            
            for j in range(index + 1):
                temp = chr(ord('a') + j)
                res.append(cur + temp)
            cur = target[:i + 1]
        return res",1427828969
kevinbu,kevinbu,52,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        res = [True] * len(parent)
        edges = collections.defaultdict(list)

        for i in range(len(parent)):
            par = parent[i]
            edges[par].append(i)
        print(edges)
        def checkPali(value):
            if len(value) == 1:
                return True
            if len(value) % 2 == 0:
                half = len(value) // 2
                return value[:half] == value[half:][::-1]
            else:
                half = len(value) // 2
                return value[:half] == value[half + 1:][::-1]
        
        def dfs(node):
            cur = """"
            for child in edges[node]:
                value = dfs(child)
                cur += value
            cur += s[node]
            result = checkPali(cur)
            nonlocal res
            res[node] = result
            return cur
        dfs(edges[-1][0])
        return res
        ",1427874456
kevinbu,kevinbu,52,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:

        def findDivisor(k):
            ceiling = math.floor(k ** 0.5)

            for i in range(2, ceiling + 1):
                if k % i == 0:
                    return i
            return k
        res = 0
        for i in range(len(nums)-2, -1, -1):
            if nums[i] > nums[i+1]:
                temp = findDivisor(nums[i])
                if temp > nums[i+1]:
                    return -1
                nums[i] = temp
                res += 1
        return res
        ",1427850425
user5860c,user5860c,54,3502,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ret = 0;
        
        FOR(i, sz(s)) {
            map<int,int> h;
            int ok = 0;
            for (int j=i;j<sz(s);++j) {
                h[s[j]]++;
                if (h[s[j]] >= k) {
                    ok = 1;
                }
                ret += ok;
            }
        }
        return ret;
    }
};",1427864149
user5860c,user5860c,54,3566,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> ret;
        string cur = """";
        for (int i=0;i<sz(t);++i) {
            cur += 'a';
            ret.pb(cur);
            while(cur.back() != t[i]) {
                cur.back() = cur.back() + 1;
                ret.pb(cur);
            }
        }
        return ret;
    }
};",1427866882
user5860c,user5860c,54,3603,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

vi g[2020200];

string ret,s;
vpi vx;
void dfs(int x) {
   vx[x].fs = sz(ret);
   for (auto n : g[x])  {
       dfs(n);
   }
   vx[x].sc = sz(ret);
   ret += s[x];
}
vi pscpld (string s) {
  string s1;
  int maxind=0,maxVal=0;
  for (int i=0;i<sz(s);++i) {
    s1 += s[i];
    if (i != sz(s)-1) {
      s1 += ""*"";
    }
  }

  vi val(sz(s1));
  //cout << s1 << endl;
  for(int i=0;i<sz(s1);++i) {
    if(maxVal >= i) {
      int loc = maxind - (i-maxind);
      val[i] = min(val[loc],maxVal-i);
    }
    while((i - val[i] >= 0) && (i + val[i] < sz(s1)) && 
          (s1[i-val[i]] == s1[i+val[i]])) {
      ++val[i];
      if(i + val[i] > maxVal){
        maxVal = i + val[i] - 1; maxind = i;
      }
    }
  }
  
  return val;
}
int isp(int l, int r, vi &v) {
    if ( (r - l + 1) % 2 == 1) {
        int mid = (l + r);
        //cout << l << "" "" << r << "" "" << mid << endl;
        if (v[mid] >= r - l + 1) return 1;
    } else {
        int mid = (l+r);
        if (v[mid] >= r - l + 1) return 1;
    }
    return 0;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& pr, string sx) {
        s = sx;
        FOR(i, sz(pr)) {
            g[i].clear();
        }
        FOR(i, sz(pr)) {
            if (pr[i] == -1) {
                continue;
            }
            g[pr[i]].pb(i);
        }
        ret = """";
        vx.resize(sz(pr));
        dfs(0);
        vi val = pscpld(ret);
        /*cout << ret << endl;
        for (auto x : val) {
            cout << x << "" "";
        }
        cout << endl;
        */
        vector<bool> rf;
        FOR(i, sz(pr)) {
            if (isp(vx[i].fs, vx[i].sc, val)) {
                rf.pb(1);
            } else {
                rf.pb(0);
            }
        }
        return rf;
        
    }
};
",1427845925
user5860c,user5860c,54,3607,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

int pr[2020200];

int getp(int x) {
    return pr[x];
}

int best[1010100][2];
class Solution {
public:
    int minOperations(vector<int>& v) {
        if (pr[2] == 0) {
            for (int i=2;i<=1000000;++i) {
                for (int j=i;j<=1000000;j+=i) {
                    if (pr[j] == 0) {
                        pr[j] = i;
                    }
                }
            }
            pr[1] = 1;
        }
        best[0][0] = 0;
        best[0][1] = 1;
        for (int i=1;i<sz(v);++i) {
            best[i][0] = best[i][1] = sz(v) * 100;
            if (v[i] >= v[i-1]) {
                //cout << ""WTF4 "" << i << endl;
                best[i][0] = min(best[i][0], best[i-1][1]);
                best[i][0] = min(best[i][0], best[i-1][0]);
            }
            if (v[i] >= getp(v[i-1])) {
                //cout << ""WTF3 "" << i << endl;
                best[i][0] = min(best[i][0], best[i-1][1]);
            }
            if (getp(v[i]) >= getp(v[i-1])) {
                //cout << ""WTF2 "" << i << endl;
                best[i][1] = min(best[i][1], best[i-1][1] + 1);
            }
            if (getp(v[i]) >= v[i-1]) {
                //cout << ""WTF1 "" << i << endl;
                best[i][1] = min(best[i][1], best[i-1][0] + 1);
            }
        }
        int ret = min(best[sz(v)-1][0], best[sz(v)-1][1]);
        if (ret > sz(v)) return -1;
        return ret;
    }
};",1427861923
Chuan-Chih Chou,chuan-chih,55,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c = Counter()
        ans = i = 0
        for char in s:
            c[char] += 1
            while max(c.values()) >= k:
                c[s[i]] -= 1
                i += 1
            ans += i
        return ans",1427830378
Chuan-Chih Chou,chuan-chih,55,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        l = []
        ans = []
        for c in target:
            l.append('a')
            ans.append(''.join(l))
            while l[-1] < c:
                prev = l.pop()
                curr = chr(ord(prev) + 1)
                l.append(curr)
                ans.append(''.join(l))
        return ans",1427826397
Chuan-Chih Chou,chuan-chih,55,3603,python3,"def manacher(s):
    # print(s)
    t = '#'.join('^' + s + '$')
    p = [0] * len(t)
    c = r = 0
    for i in range(2, len(t) - 2):
        p[i] = int(r > i) and min(r - i, p[2 * c - i])
        while t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] += 1
        if i + p[i] > r:
            c, r = i, i + p[i]
    return p

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        child = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                child[p].append(i)
        r = [None] * n
        l = []
        def dfs(i):
            for c in child[i]:
                dfs(c)
            index = len(l)
            l.append(s[i])
            if child[i]:
                r[i] = (r[child[i][0]][0], index)
            else:
                r[i] = (index, index)            
        dfs(0)
        p = manacher(''.join(l))[2:]
        # print(p)
        # print(r)
        
        def check(i, j):
            length = j - i + 1
            middle = i + j
            return p[middle] >= length
            
        
        return [check(*r[i]) for i in range(n)]
        
        ",1427876496
Chuan-Chih Chou,chuan-chih,55,3607,python3,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def op(x):
            for p in primes:
                if not x % p:
                    return p
            return x
            
        curr = nums[-1]
        ans = 0
        for i in reversed(range(len(nums) - 1)):
            x = nums[i]
            if x <= curr:
                curr = x
            else:
                x = op(x)
                ans += 1
                if x <= curr:
                    curr = x
                else:
                    return -1
        return ans",1427844801
kzyKT,kzyKT,57,3502,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    int ans=0;
    rep(i,s.size()) {
      int c[26],f=0;
      mem(c);
      REP(j,i,s.size()) {
        c[s[j]-'a']++;
        if(c[s[j]-'a']>=k) f=1;
        ans+=f;
      }
    }
    return ans;
  }
};",1427825537
kzyKT,kzyKT,57,3566,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  vector<string> stringSequence(string s) {
    vector<string> ans;
    string t="""";
    rep(i,s.size()) {
      t+='a';
      ans.pb(t);
      while(t.back()!=s[i]) {
        t.back()++;
        ans.pb(t);
      }
    }
    return ans;
  }
};
",1427824255
kzyKT,kzyKT,57,3603,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

struct RollingHash {
  static constexpr uint64_t MASK30=(1ULL<<30)-1;
  static constexpr uint64_t MASK31=(1ULL<<31)-1;
  static const uint64_t MOD=(1ULL<<61ULL)-1;
  const uint64_t base;
  vector<uint64_t> power;
  explicit RollingHash(uint64_t base=generate_base()):base(base),power{1} {}
  vector<uint64_t> build(const string& s) const {
    int sz=s.size();vector<uint64_t> hashed(sz+1);
    for(int i=0;i<sz;i++)hashed[i+1]=add(mul(hashed[i],base),s[i]);
    return hashed;
  }
  template<typename T>
  vector<uint64_t> build(const vector<T>& s) const {
    int sz=s.size();vector<uint64_t> hashed(sz+1);
    for(int i=0;i<sz;i++)hashed[i+1]=add(mul(hashed[i],base),s[i]);
    return hashed;
  }
  uint64_t query(const vector<uint64_t>& s,int l,int r) {
    expand(r-l);return add(s[r],MOD-mul(s[l],power[r-l]));
  }
  uint64_t combine(uint64_t h1,uint64_t h2,size_t h2len) {
    expand(h2len);return add(mul(h1,power[h2len]),h2);
  }
private:
  static inline uint64_t add(uint64_t a,uint64_t b) {
    if((a+=b)>=MOD)a-=MOD;return a;
  }
  static inline uint64_t mul(uint64_t l,uint64_t r) {
    auto lu=l>>31,ld=l&MASK31,ru=r>>31,rd=r&MASK31,mb=ld*ru+lu*rd;
    return calc_mod(((lu*ru)<<1)+ld*rd+((mb&MASK30)<<31)+(mb>>30));
  }
  static inline uint64_t calc_mod(uint64_t val) {
    val=(val&MOD)+(val>>61);if(val>MOD)val-=MOD;return val;
  }
  static inline uint64_t generate_base() {
    mt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<uint64_t> rand(1,RollingHash::MOD-1);
    return rand(mt);
  }
  inline void expand(size_t sz) {
    if(power.size()<sz+1) {
      int pre_sz=power.size();power.resize(sz+1);
      for(int i=pre_sz-1;i<sz;i++)power[i+1]=mul(power[i],base);
    }
  }
};


string s,t;
vector<ll> v[111111];
vector<bool> ans;

P a[200000];
void calc() {
  int k=0;
  stack<P> s;
  s.push(P(0,-1));
  while(!s.empty()) {
    P q=s.top();s.pop();
    int x=q.F,p=q.S;
    if(x<0||!x&&p>0) {
      a[-x].S=k;
      continue;
    }
    s.push(P(-x,-p));
    a[x].F=k++;
    for(int i=0; i<v[x].size(); i++) {
      int y=v[x][i];
      if(y==p) continue;
      s.push(P(y,x));
    }
  }
}

void dfs(ll x) {
  rep(i,v[x].size()) dfs(v[x][i]);
  t+=s[x];
}

class Solution {
public:
  vector<bool> findAnswer(vector<int>& p, string ss) {
    s=ss;
    ll n=s.size();
    ans.clear();
    rep(i,n) v[i].clear(),ans.pb(0);
    REP(i,1,p.size()) v[p[i]].pb(i);
    t="""";
    dfs(0);
    calc();
    RollingHash rh;
    reverse(all(t));
    auto r1=rh.build(t);
    reverse(all(t));
    auto r2=rh.build(t);
    rep(i,n) {
      ll l=a[i].F,r=a[i].S;
      ll x=t.size()-a[i].S,y=t.size()-a[i].F;
      uint64_t h1=rh.query(r1,l,r);
      uint64_t h2=rh.query(r2,x,y);
      ans[i]=h1==h2;
    }
    return ans;
  }
};
",1427869430
kzyKT,kzyKT,57,3607,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int minOperations(vector<int>& a) {
    map<ll,ll> ma;
    int ans=0;
    rrep(i,a.size()-1) {
      while(a[i]>a[i+1]) {
        if(!ma.count(a[i])) {
          ll M=1;
          for(ll j=2; j*j<=a[i]; j++) {
            if(a[i]%j==0) {
              M=max(M,j);
              M=max(M,a[i]/j);
            }
          }
          ma[a[i]]=M;
        }
        ll d=ma[a[i]];
        if(d==1) return -1;
        a[i]/=d;
        ans++;
      }
    }
    return ans;
  }
};",1427835054
aqxa2k,aqxa2k,58,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(); 
        vector<vector<int>> dp(n, vector<int>(n, 0)); 
        vector<vector<int>> pos(26); 
        for (int i = 0; i < n; ++i) {
            pos[s[i] - 'a'].push_back(i); 
        }
        for (auto v: pos) {
            if (v.size() < k) continue; 
            for (int i = 0; i + k - 1 < v.size(); ++i) {
                dp[v[i]][v[i + k - 1]] = 1; 
            }
        }
        int ans = 0; 
        for (int l = n - 1; l >= 0; --l) {
            for (int r = l; r < n; ++r) {
                if (dp[l][r]) ans++; 
                if (l) dp[l-1][r] |= dp[l][r]; 
                if (r + 1 < n) dp[l][r+1] |= dp[l][r]; 
            }
        }
        return ans; 
    }
};",1427828352
aqxa2k,aqxa2k,58,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res; 
        string cur = """"; 
        for (int i = 0; i < target.size(); ++i) {
            cur += 'a'; 
            res.push_back(cur); 
            while (cur[i] != target[i]) {
                cur[i]++; 
                // cout << ""! "" << cur << '\n';
                res.push_back(cur); 
            }
        }
        return res; 
    }
};",1427824428
aqxa2k,aqxa2k,58,3603,cpp,"using ll = long long; 
class HashedString {
  private:
	// change M and B if you want
	static const ll M = (1LL << 61) - 1;
	static const ll B;
 
	// pow[i] contains B^i % M
	static vector<ll> pow;
 
	// p_hash[i] is the hash of the first i characters of the given string
	vector<ll> p_hash;
 
	__int128 mul(ll a, ll b) { return (__int128)a * b; }
	ll mod_mul(ll a, ll b) { return mul(a, b) % M; }
 
  public:
	HashedString(const string &s) : p_hash(s.size() + 1) {
		while (pow.size() < s.size() + 5) { pow.push_back(mod_mul(pow.back(), B)); }
		p_hash[0] = 0;
		for (int i = 0; i < s.size(); i++) {
			p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;
		}
	}
 
	ll get(int start, int end) {
		ll raw_val =
		    p_hash[end + 1] - mod_mul(p_hash[start], pow[end - start + 1]);
		return (raw_val + M) % M;
	}
};
mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
vector<ll> HashedString::pow = {1};
const ll HashedString::B = uniform_int_distribution<ll>(0, M - 1)(rng);

class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = s.size(); 
        vector<vector<int>> g(n); 
        for (int i = 1; i < n; ++i) {
            g[p[i]].push_back(i); 
        }
        vector<int> tin(n), tout(n); 
        int tt = 0; 
        dfs(0, g, tin, tout, tt); 
        string t = s; 
        for (int i = 0; i < n; ++i) {
            // cout << tin[i] << ' ' << tout[i] << '\n';
            t[tout[i]] = s[i]; 
        }
        // cout << t << '\n';
        s = t; 
        reverse(s.begin(), s.end()); 
        HashedString ha(t); 
        HashedString hb(s); 

        vector<bool> res(n); 
        for (int i = 0; i < n; ++i) {
            int l = tin[i], r = tout[i]; 
            // cout << tin[i] << ' ' << tout[i] << '\n';
            // cout << ha.get(l, r) << ' ' << hb.get(n - 1 - r, n - 1 - l) << '\n';
            res[i] = ha.get(l, r) == hb.get(n - 1 - r, n - 1 - l); 
        }
        return res; 

    }
    void dfs(int x, vector<vector<int>> & g, vector<int> & tin, vector<int> & tout, int & t) {
        tin[x] = t; 
        for (auto y: g[x]) {
            dfs(y, g, tin, tout, t); 
        }
        tout[x] = t; 
        t++; 
    }
};",1427869449
aqxa2k,aqxa2k,58,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        int n = a.size(); 
        int ans = 0; 
        for (int i = n - 2; i >= 0; --i) {
            if (a[i] > a[i + 1]) {
                if (a[i] % 2 == 0) {
                    a[i] = 2; 
                    ans++; 
                    continue; 
                }
                for (int j = 3; j * j <= a[i]; j += 2) {
                    if (a[i] % j == 0) {
                        a[i] = j; 
                        ans++; 
                        break; 
                    }
                }
                if (a[i] > a[i + 1]) return -1; 
            }
        }
        return ans; 
    }
};",1427834597
nikatamliani1,nikatamliani1,59,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int)s.size();
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> freq(26);
            bool pos = false;
            for (int j = i; j < n; ++j) {
                if (++freq[s[j] - 'a'] >= k) {
                    pos = true;
                }
                if (pos) {
                    ++cnt;
                }
            }
        }
        return cnt;
    }
};",1427824699
nikatamliani1,nikatamliani1,59,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s;
        for (int i = 0; i < (int)target.size(); ++i) {
            s += 'a';
            res.push_back(s);
            for (int c = 'b'; c <= target[i]; ++c) {
                s.back() = c;
                res.push_back(s);
            }
        }
        return res;
    }
};",1427823976
nikatamliani1,nikatamliani1,59,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = (int)parent.size();
        vector<vector<int>> children(n);
        for (int i = 1; i < n; ++i) {
            children[parent[i]].push_back(i);
        }
        

        string t;
        int timer = -1;
        vector<int> out(n), mini(n, (int)1e9);
        auto dfs = [&](auto self, int x) -> void {
            for (int child : children[x]) {
                self(self, child);
            }
            out[x] = ++timer;
            mini[x] = min(mini[x], out[x]);
            if (x > 0) {
                mini[parent[x]] = min(mini[parent[x]], mini[x]);
            }
            t += s[x];
        };
        
        dfs(dfs, 0);

        const int MOD = 1e9 + 7, p = 31;

        auto bpow = [&](int x, int y, int MOD) -> int {
            int ans = 1;
            while (y > 0) {
                if (y & 1) {
                    ans = 1LL * ans * x % MOD;
                }
                x = 1LL * x * x % MOD;
                y >>= 1;
            }  
            return ans;
        };

        vector<int> po(n + 5), ipo(n + 5);
        po[0] = 1;
        for (int i = 1; i < (int)po.size(); ++i) {
            po[i] = 1LL * po[i - 1] * p % MOD; 
        }

        int ip = bpow(p, MOD - 2, MOD);
        ipo[0] = 1;
        for (int i = 1; i < (int)po.size(); ++i) {
            ipo[i] = 1LL * ipo[i - 1] * ip % MOD;
        }

        auto get_hash = [&](string s) -> vector<int> {
            vector<int> h(n);
            for (int i = 0; i < (int)s.size(); ++i) {
                h[i] = ((i > 0 ? 1LL * h[i - 1] * p : 0LL) + (s[i] - 'a' + 1)) % MOD;
            }
            return h;
        };

        auto get_val = [&](vector<int> &h, int l, int r) -> int {
            int pdiff = r - l + 1;
            return (1LL * (h[r] - 1LL * (l > 0 ? h[l - 1] : 0) * po[pdiff]) % MOD + MOD) % MOD;
        };

        vector<int> h1 = get_hash(t);
        reverse(t.begin(), t.end());
        vector<int> h2 = get_hash(t);
        reverse(t.begin(), t.end());



        auto is_palindrome = [&](int l, int r) -> bool {
            return get_val(h1, l, r) == get_val(h2, n - r - 1, n - l - 1);
        };

        vector<bool> ans(n);
        for (int i = 0; i < n; ++i) {
            ans[i] = is_palindrome(mini[i], out[i]);
        }
        return ans;
    }
};",1427861382
nikatamliani1,nikatamliani1,59,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        
        auto f = [&](int x) -> int {
            for (int i = 2; i * i <= x; ++i) {
                if (x % i == 0) {
                    return i;
                }
            }
            return x;
        };

        int n = (int)a.size(), cnt = 0;
        for (int i = n - 2; i >= 0; --i) {
            if (a[i] > a[i + 1]) {
                a[i] = f(a[i]);
                if (a[i] > a[i + 1]) {
                    return -1;
                }
                ++cnt;
            }
        }
        return cnt;
    }
};",1427831855
hxu10,hxu10,60,3502,python,"class Solution(object):
    def numberOfSubstrings(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        n = len(s)
        ans = 0
        
        for i in range(n):
            fre = [0]*26
            for j in range(i,n):
                fre[ord(s[j])-97] += 1
                if fre[ord(s[j])-97] >= k:
                    ans += n - j 
                    break
            
        return ans
        ",1427826833
hxu10,hxu10,60,3566,python,"class Solution(object):
    def stringSequence(self, target):
        """"""
        :type target: str
        :rtype: List[str]
        """"""
        ans = []
        curr = """"
        for c in target:
            index = ord(c) - 97
            for i in range(index+1):
                ans.append(curr+chr(97+i))
            curr += chr(97+i)
            
        return ans",1427824192
hxu10,hxu10,60,3603,python,"M = 10**18 + random.randint(1,10**9)

pows = [1]

for _ in range(100001):
    pows.append(pows[-1] * 27 % M)
    

class Solution(object):
    def findAnswer(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[bool]
        """"""
        
        n = len(s)
        children = [[] for _ in range(n)]
        
        for i in range(1,n):
            children[parent[i]].append(i)
            
            
        for i in range(n):
            children[i].sort()
            
            
        
            
            
            
            
        childnum = [0]*n
        
        seq = []
        
        ss = []
        
        
            
        def dfs(index):
            res = 1
            for nextindex in children[index]:
                res += dfs(nextindex)
            seq.append(index)
            ss.append(s[index])
            childnum[index] = res
            return res
        
        
        
        dfs(0)
        
        

        
        

        
        
            
        hleft = [0]*(n+1)
        hright = [0]*(n+1)
        
        
        

        for i in range(n):
            hleft[i] = hleft[i-1] * 27 + ord(ss[i]) - 26
            hleft[i] %= M
        for i in range(n-1,-1,-1):
            hright[i] = hright[i+1] * 27 + ord(ss[i]) - 26
            hright[i] %= M
            
        
        
        
 
        
        
        loc = [0]*n
        
        
        for i in range(n):
            loc[seq[i]] = i
            
            
  
            
            
        ans = []
        for i in range(n):
            end = loc[i]
            begin = end - childnum[i] + 1
            
         #   print(i,begin,end)
            
            h1 = hleft[end] - hleft[begin-1] * pows[childnum[i]]
            
            h2 = hright[begin] - hright[end+1] * pows[childnum[i]]
            
            
            
            
            if h1 % M == h2 % M:
                ans.append(True)
            else:
                ans.append(False)
                
                
        return ans
        
        

        
        
    
            
            
            
            
            
            
            
        ",1427869776
hxu10,hxu10,60,3607,python,"MAX = 1000001
smallest = [0]*(MAX+1)
smallest[1] = 1
for i in range(2,MAX+1):
    for j in range(i,MAX+1,i):
        if smallest[j] > 0:  continue  
        smallest[j] = i
        
        
        





class Solution(object):
    def minOperations(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums)
        ans = 0
        for i in range(n-2,-1,-1):
            while nums[i] > nums[i+1]:
                if smallest[nums[i]] == nums[i]:
                    return -1
                nums[i] = smallest[nums[i]]
                ans += 1
        return ans
        
        ",1427837415
colicon,colicon,61,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        s = [ord(x)-ord('a') for x in s]
        tot = [0] * 26

        ans = 0

        n = len(s)
        j = 0
        for i in range(n):
            while j < n and max(tot) < k:
                tot[s[j]] += 1
                j += 1
            
            if max(tot) >= k:
                ans += n - j + 1

            tot[s[i]] -= 1
    
        return ans
            
                
",1427835373
colicon,colicon,61,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        target = list(target)
        a = []

        c = []
        while c != target:
            if not c or c[-1] == target[len(c)-1]:
                c.append('a')
            else:
                c[-1] = chr(ord(c[-1]) + 1)
            a.append(''.join(c))

        return a",1427827188
colicon,colicon,61,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)

        adj = [[] for _ in range(n)]
        for i in range(1, n):
            adj[parent[i]].append(i)
        
        MOD = 10**9 + 7
        b = 31
        pw = [1] * (n+1)
        for i in range(1, n+1):
            pw[i] = pw[i-1] * b % MOD

        dp = [[0]*3 for _ in range(n)]
        
        ans = [0] * n

        def dfs(c):
            adj[c].sort()

            for ne in adj[c]:
                dfs(ne)

                dp[c][0] += pw[dp[c][2]] * dp[ne][0]
                dp[c][0] %= MOD
                dp[c][1] = dp[c][1] * pw[dp[ne][2]] + dp[ne][1]
                dp[c][1] %= MOD
                
                dp[c][2] += dp[ne][2]

            dp[c][0] += pw[dp[c][2]] * ord(s[c])
            dp[c][0] %= MOD
            dp[c][1] = dp[c][1] * b + ord(s[c])
            dp[c][1] %= MOD

            dp[c][2] += 1

            ans[c] = dp[c][0] == dp[c][1]


        dfs(0)

        return ans",1427870939
colicon,colicon,61,3607,python3,"mx = 10**6 + 1
div = [1] * mx

for i in range(2, mx):
    for j in range(2*i, mx, i):
        div[j] = i

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0

        n = len(nums)
        for i in range(n-2, -1, -1):
            while nums[i] > nums[i+1] and div[nums[i]] != 1:
                nums[i] //= div[nums[i]]
                ans += 1
            
            if nums[i] > nums[i+1]:
                return -1

        return ans

        ",1427846291
Xiaomeng Yang,yangxm,63,3502,cpp,"constexpr int MAX = 32;

int cnt[MAX];

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
      int n = s.length(), ret = 0;
      for (int i = 0; i < n; ++i) {
        memset(cnt, 0, sizeof(cnt));
        int cur = 0;
        for (int j = i; j < n; ++j) {
          ++cnt[s[j] - 'a'];
          cur = max(cur, cnt[s[j] - 'a']);
          if (cur >= k) {
            ++ret;
          }
        }
      }
      return ret;
    }
};",1427827499
Xiaomeng Yang,yangxm,63,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
      vector<string> ret;
      string cur = """";
      for (char ch : target) {
        cur.push_back('a');
        ret.push_back(cur);
        for (int i = 0; i < ch - 'a'; ++i) {
          cur.back() = 'a' + i + 1;
          ret.push_back(cur);
        }
      }
      return ret;
    }
};",1427825449
Xiaomeng Yang,yangxm,63,3603,cpp,"using i64 = long long;

constexpr int MAX = 100010;
constexpr i64 P = 131;
constexpr i64 Q = 997;
constexpr i64 MP = 999999937;
constexpr i64 MQ = 1000000007;

i64 Pow(i64 a, i64 b, i64 p) {
  i64 ret = 1;
  for (a %= p; b; b >>= 1) {
    if (b & 1) {
      ret = ret * a % p;
    }
    a = a * a % p;
  }
  return ret;
}

i64 Inv(i64 x, i64 p) { return Pow(x, p - 2, p); }

template<i64 P, i64 MOD>
struct Hash {
  i64 sum[MAX], inv[MAX];

  void Assign(const string& s) {
    int n = s.length();
    sum[0] = 0;
    inv[0] = 1;
    i64 w = 1;
    for (int i = 0; i < n; ++i) {
      sum[i + 1] = (sum[i] + (i64)(s[i]) * w) % MOD;
      w = w * P % MOD;
      inv[i + 1] = Inv(w, MOD);
    }
  }

  i64 Query(int l, int r) const {
    i64 ret = (sum[r] - sum[l] + MOD) % MOD;
    return ret * inv[l] % MOD;
  }
};

vector<int> adj[MAX];
int l[MAX], r[MAX];

string str, rev;
Hash<P, MP> h1, r1;
Hash<Q, MQ> h2, r2;

void DFS(const string& s, int x, int p, string& ret) {
  l[x] = ret.length();
  for (int y : adj[x]) {
    if (y != p) {
      DFS(s, y, x, ret);
    }
  }
  ret.push_back(s[x]);
  r[x] = ret.length();
}

bool Query(int n, int x) {
  i64 x1 = h1.Query(l[x], r[x]);
  i64 y1 = r1.Query(n - r[x], n - l[x]);
  i64 x2 = h2.Query(l[x], r[x]);
  i64 y2 = r2.Query(n - r[x], n - l[x]);
  return x1 == y1 && x2 == y2;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
      int n = parent.size();
      for (int i = 0; i < n; ++i) {
        vector<int>().swap(adj[i]);
      }
      for (int i = 0; i < n; ++i) {
        int p = parent[i];
        if (p != -1) {
          adj[p].push_back(i);
        }
      }
      str.clear();
      rev.clear();
      DFS(s, 0, -1, str);
      rev = str;
      reverse(rev.begin(), rev.end());
      h1.Assign(str);
      h2.Assign(str);
      r1.Assign(rev);
      r2.Assign(rev);
      vector<bool> ret(n, false);
      for (int i = 0; i < n; ++i) {
        ret[i] = Query(n, i);
      }
      return ret;
    }
};",1427881141
Xiaomeng Yang,yangxm,63,3607,cpp,"constexpr int MAX = 1000100;

int a[MAX], p[MAX];

void Prime() {
  int n = 0;
  for (int i = 2; i < MAX; ++i) {
    if (!a[i]) {
      a[i] = i;
      p[n++] = i;
    }
    for (int j = 0; i * p[j] < MAX; ++j) {
      a[i * p[j]] = p[j];
      if (!(i % p[j])) {
        break;
      }
    }
  }
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
      static bool init = []() {
        Prime();
        return true;
      }();

      int n = nums.size(), ret = 0;
      for (int i = n - 1; i > 0; --i) {
        if (nums[i - 1] > nums[i]) {
          int v = a[nums[i - 1]];
          if (v > nums[i]) {
            return -1;
          }
          nums[i - 1] = v;
          ++ret;
        }
      }
      return ret;
    }
};",1427836768
Ryan Guo,ryanguorocket,64,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ret = 0;
        int n = s.length();
        for(int i = 0; i < n; i++) {
            vector<int> freq(26);
            bool good = false;
            for(int j = i; j < n; j++) {
                int c = s[j] - 'a';
                freq[c]++;
                if(freq[c] >= k) good = true;
                if(good) ret++;
            }
        }
        return ret;
    }
};",1427830890
res,Res1StAnce7,1,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        res = 0
        for i in range(n):
            cnt = [0] * 26
            m = 0
            for j in range(i, n):
                idx = ord(s[j]) - 97
                cnt[idx] += 1
                m = max(m, cnt[idx])
                if m >= k:
                    res += 1
        return res",1427828224
res,Res1StAnce7,1,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        current = ''
        result = []
        
        for char in target:
            if not current:
                current += 'a'
                result.append(current)
            
            while current[-1] != char:
                current = current[:-1] + chr((ord(current[-1]) - ord('a') + 1) % 26 + ord('a'))
                result.append(current)
            
            if len(current) < len(target):
                current += 'a'
                result.append(current)
        
        return result",1427825634
res,Res1StAnce7,1,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], S: str) -> List[bool]:
        n = len(S)
        mod1, mod2 = 10**9 + 7, 10**9 + 9
        B1, B2 = 911, 3571
        max_len = n + 1

        pow_B1 = [1] * max_len
        pow_B2 = [1] * max_len
        for i in range(1, max_len):
            pow_B1[i] = (pow_B1[i - 1] * B1) % mod1
            pow_B2[i] = (pow_B2[i - 1] * B2) % mod2

        children = [[] for _ in range(n)]
        root = -1
        for i in range(n):
            if parent[i] == -1:
                root = i
            else:
                children[parent[i]].append(i)

        len_subtree = [0] * n
        H1 = [0] * n
        H2 = [0] * n
        HR1 = [0] * n
        HR2 = [0] * n
        answer = [False] * n

        def dfs(u):
            len_subtree[u] = 1
            H1_u, H2_u = 0, 0
            HR1_u = HR2_u = ord(S[u])
            for c in children[u]:
                dfs(c)
            for c in children[u]:
                H1_u = (H1_u * pow_B1[len_subtree[c]] + H1[c]) % mod1
                H2_u = (H2_u * pow_B2[len_subtree[c]] + H2[c]) % mod2
                len_subtree[u] += len_subtree[c]
            H1_u = (H1_u * B1 + ord(S[u])) % mod1
            H2_u = (H2_u * B2 + ord(S[u])) % mod2
            H1[u], H2[u] = H1_u, H2_u
            for c in reversed(children[u]):
                HR1_u = (HR1_u * pow_B1[len_subtree[c]] + HR1[c]) % mod1
                HR2_u = (HR2_u * pow_B2[len_subtree[c]] + HR2[c]) % mod2
            HR1[u], HR2[u] = HR1_u, HR2_u
            answer[u] = (H1[u] == HR1[u] and H2[u] == HR2[u])

        dfs(root)
        return answer",1427843054
res,Res1StAnce7,1,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:    
        def spf(x):
            if x <= 1:
                return x
            if x % 2 == 0:
                return 2
            max_div = int(math.isqrt(x)) + 1
            for i in range(3, max_div, 2):
                if x % i == 0:
                    return i
            return x  

        n = len(nums)
        ops = 0
        for i in range(n - 1, 0, -1):
            while nums[i - 1] > nums[i]:
                if nums[i - 1] == 1:
                    return -1
                factor = spf(nums[i - 1])
                if factor == nums[i - 1]:
                    return -1
                nums[i - 1] = factor
                ops += 1
                if nums[i - 1] > nums[i]:
                    if nums[i - 1] == 1:
                        return -1
                    return -1
        return ops",1427832330
arignote,arignote,3,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int sum = 0;
        for (int i = 0; i < s.length(); i++) {
            int[] count = new int[26];
            for (int j = i; j < s.length(); j++) {
                if ((++count[s.charAt(j) - 'a'] == k)) {
                    sum += s.length() - j;
                    break;
                }
            }
        }
        return sum;
    }
}",1427846352
arignote,arignote,3,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        ArrayList<String> list = new ArrayList<>();
        for (int i = 0; i < target.length(); i++) {
            for (char c = 'a'; c <= target.charAt(i); c++) {
                list.add(target.substring(0, i) + c);
            }
        }
        return list;
    }
}",1427845946
arignote,arignote,3,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();
        for (int i = 1; i < parent.length; i++) {
            map.computeIfAbsent(parent[i], t -> new ArrayList<>()).add(i);
        }
        StringBuilder sb = new StringBuilder();
        int[][] range = new int[parent.length][2];
        findAnswer(0, sb, range, s, map);
        Manacher manacher = new Manacher("""" + sb);
        boolean[] result = new boolean[parent.length];
        for (int i = 0; i < parent.length; i++) {
            result[i] = manacher.p[range[i][0] + range[i][1] + 1] >= range[i][1] - range[i][0];
        }
        return result;
    }
    private void findAnswer(int k, StringBuilder sb, int[][] range, String s, HashMap<Integer, ArrayList<Integer>> map) {
        range[k][0] = sb.length();
        for (int i : map.getOrDefault(k, new ArrayList<>())) {
            findAnswer(i, sb, range, s, map);
        }
        sb.append(s.charAt(k));
        range[k][1] = sb.length();
    }
}

class Manacher {
    public int[] p;
    private String s;
    private char[] t;
    public Manacher(String s) {
        this.s = s;
        preprocess();
        p = new int[t.length];
        int center = 0, right = 0;
        for (int i = 1; i < t.length-1; i++) {
            int mirror = 2*center - i;
            if (right > i)
                p[i] = Math.min(right - i, p[mirror]);
            while (t[i + (1 + p[i])] == t[i - (1 + p[i])])
                p[i]++;
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }
        }
    }
    private void preprocess() {
        t = new char[s.length()*2 + 3];
        t[0] = '$';
        t[s.length()*2 + 2] = '@';
        for (int i = 0; i < s.length(); i++) {
            t[2*i + 1] = '#';
            t[2*i + 2] = s.charAt(i);
        }
        t[s.length()*2 + 1] = '#';
    }
}
",1427846821
arignote,arignote,3,3607,java,"class Solution {
    private static ArrayList<Integer> list = new ArrayList<>() {
        {
            boolean[] flag = new boolean[1000000];
            for (int i = 2; i < 1000000; i++) {
                if (!flag[i]) {
                    add(i);
                    for (int j = 2 * i; j < 1000000; j += i) {
                        flag[j] = true;
                    }
                }
            }
        }
    };
    public int minOperations(int[] nums) {
        int count = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                for (int j : list) {
                    if (nums[i] % j == 0) {
                        if ((nums[i] = j) > nums[i + 1]) {
                            return -1;
                        }
                        break;
                    }
                }
                count++;
            }
        }
        return count;
    }
}",1427846492
Abhishek Choudhary,theabbie,5,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        p = [[0] * 26 for _ in range(n + 1)]
        for i in range(n):
            for c in range(26):
                p[i + 1][c] = p[i][c] + int(c == ord(s[i]) - ord('a'))
        res = 0
        for i in range(n):
            beg = i
            end = n - 1
            while beg <= end:
                mid = (beg + end) // 2
                good = False
                for c in range(26):
                    if p[mid + 1][c] - p[i][c] >= k:
                        good = True
                        break
                if good:
                    end = mid - 1
                else:
                    beg = mid + 1
            res += n - end - 1
        return res",1427844492
Abhishek Choudhary,theabbie,5,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        s = """"
        for c in target:
            for x in range(ord(c) - ord('a') + 1):
                res.append(s + chr(ord('a') + x))
            s += c
        return res",1427838201
Abhishek Choudhary,theabbie,5,3603,python3,"class Solution:
    # s[i : j + 1] is palindrome if P[i + j + 2] >= j - i + 1
    def manachers(self, s):
        T = '#'.join('^{}$'.format(s))
        n = len(T)
        P = [0] * n
        C = R = 0
        for i in range(1, n - 1):
            if R > i:
                P[i] = min(R - i, P[2 * C - i])
            while T[i + 1 + P[i]] == T[i - 1 - P[i]]:
                P[i] += 1
            if i + P[i] > R:
                C, R = i, i + P[i]
        return P
    
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        graph = [[] for _ in range(n)]
        for i in range(1, n):
            graph[parent[i]].append(i)
        ctr = [0] * n
        pos = [0] * n
        v = []
        def dfs(i):
            ctr[i] += 1
            for j in sorted(graph[i]):
                dfs(j)
                ctr[i] += ctr[j]
            v.append(s[i])
            pos[i] = len(v) - 1
        dfs(0)
        pal = self.manachers("""".join(v))
        return [pal[2*pos[i]-ctr[i]+3]>=ctr[i] for i in range(n)]",1427834648
Abhishek Choudhary,theabbie,5,3607,python3,"MAX = 1 + 10 ** 6

v = [False] * MAX
sp = [0] * MAX

for i in range(2, MAX, 2):
    sp[i] = 2

for i in range(3, MAX, 2):
    if not v[i]:
        sp[i] = i
        j = i
        while j * i < MAX:
            if not v[j * i]:
                v[j * i] = True
                sp[j * i] = i
            j += 2

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        nums.reverse()
        res = 0
        for i in range(1, len(nums)):
            while nums[i] > nums[i - 1]:
                if nums[i] == sp[nums[i]]:
                    return -1
                nums[i] = sp[nums[i]]
                res += 1
        return res",1427851646
therealpratyushraman,therealpratyushraman,6,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
    int n = s.length(), totalCount = 0;
    for (int i = 0; i < n; i++) {
    int[] freq = new int[26];
    for (int j = i; j < n; j++) {
    freq[s.charAt(j) - 'a']++;
    for (int c = 0; c < 26; c++) {
    if (freq[c] >= k) {
    totalCount++;
    break;
    }
    }
    }
    }
    return totalCount;
    }
}",1427838247
therealpratyushraman,therealpratyushraman,6,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
public List<String> stringSequence(String target) {
List<String> result = new ArrayList<>();
StringBuilder screen = new StringBuilder();
int n = target.length();
for (int i = 0; i < n; i++) {
while (screen.length() < i + 1) {
screen.append('a');
result.add(screen.toString());
}
char ch = screen.charAt(i);
char targetChar = target.charAt(i);
int presses = (targetChar - ch + 26) % 26;
for (int p = 0; p < presses; p++) {
ch = (char)((ch - 'a' + 1) % 26 + 'a');
screen.setCharAt(i, ch);
result.add(screen.toString());
}
}
return result;
}
}
",1427828291
therealpratyushraman,therealpratyushraman,6,3603,java,"class Solution {
    static final int P = 911;
    static final int M = 1_000_000_007;
    public boolean[] findAnswer(int[] parent, String s) {
    int n = s.length();
    List<Integer>[] tree = new List[n];
    for(int i = 0; i < n; i++) tree[i] = new ArrayList<>();
    for(int i = 1; i < n; i++) tree[parent[i]].add(i);
    for(int i = 0; i < n; i++) Collections.sort(tree[i]);
    int[] start = new int[n], end = new int[n];
    int[] traversal = new int[n + 1];
    int[] powP = new int[n + 2];
    powP[0] = 1;
    for(int i = 1; i <= n + 1; i++) powP[i] = (int)((long)powP[i - 1] * P % M);
    int[] pos = new int[1];
    dfs(0, tree, s, start, end, traversal, pos);
    long[] prefixHash = new long[n + 1], reversePrefixHash = new long[n + 2];
    for(int i = 1; i <= n; i++)
    prefixHash[i] = (prefixHash[i - 1] * P + traversal[i]) % M;
    for(int i = n; i >= 1; i--)
    reversePrefixHash[i] = (reversePrefixHash[i + 1] * P + traversal[i]) % M;
    boolean[] answer = new boolean[n];
    for(int i = 0; i < n; i++) {
    int l = start[i], r = end[i];
    long h1 = (prefixHash[r] - prefixHash[l - 1] * powP[r - l + 1] % M + M) % M;
    long h2 = (reversePrefixHash[l] - reversePrefixHash[r + 1] * powP[r - l + 1] % M + M) % M;
    answer[i] = h1 == h2;
    }
    return answer;
    }
    void dfs(int u, List<Integer>[] tree, String s, int[] start, int[] end, int[] traversal, int[] pos) {
    start[u] = pos[0] + 1;
    for(int v : tree[u]) dfs(v, tree, s, start, end, traversal, pos);
    traversal[++pos[0]] = s.charAt(u) - 'a' + 1;
    end[u] = pos[0];
    }
}",1427852474
therealpratyushraman,therealpratyushraman,6,3607,java,"class Solution {
    public int minOperations(int[] nums) {
    int maxNum = 1000000;
    int[] spf = new int[maxNum + 1];
    for (int i = 0; i <= maxNum; i++) spf[i] = i;
    for (int i = 2; i * i <= maxNum; i++) {
    if (spf[i] == i) {
    for (int j = i * i; j <= maxNum; j += i) {
    if (spf[j] == j) spf[j] = i;
    }
    }
    }
    int n = nums.length;
    int INF = Integer.MAX_VALUE / 2;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = INF;
    int spfNum = spf[nums[0]];
    if (spfNum != nums[0]) dp[0][1] = 1;
    for (int i = 1; i < n; i++) {
    dp[i][0] = dp[i][1] = INF;
    int spf_i = spf[nums[i]];
    boolean canReduce = spf_i != nums[i];
    int[] prevValues = new int[2];
    prevValues[0] = nums[i - 1];
    prevValues[1] = spf[nums[i - 1]] != nums[i - 1] ? spf[nums[i - 1]] : -1;
    for (int prevState = 0; prevState <= 1; prevState++) {
    if (dp[i - 1][prevState] >= INF) continue;
    int prevValue = prevState == 0 ? nums[i - 1] : prevValues[1];
    if (prevValue == -1) continue;
    if (nums[i] >= prevValue) dp[i][0] = Math.min(dp[i][0], dp[i - 1][prevState]);
    if (canReduce && spf_i >= prevValue) dp[i][1] = Math.min(dp[i][1], dp[i - 1][prevState] + 1);
    }
    if (dp[i][0] >= INF && dp[i][1] >= INF) return -1;
    }
    int ans = Math.min(dp[n - 1][0], dp[n - 1][1]);
    return ans >= INF ? -1 : ans;
    }
}",1427840501
BarryBondsOfLC,BarryBondsOfLC,7,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        for (int i = 0; i < n; ++i) {
            array<int, 26> fm = {0};
            int mx = 0;
            for (int j = i; j < n; ++j) {
                mx = max(mx, ++fm[s[j] - 'a']);
                if (mx >= k) ++res;
            }
        }
        
        return res;
    }
};",1427825463
BarryBondsOfLC,BarryBondsOfLC,7,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr;
        
        for (auto c : target) {
            curr.push_back('a');
            res.push_back(curr);
            while (curr.back() != c) {
                ++curr.back();
                res.push_back(curr);
            }
        }
        
        return res;
    }
};",1427823833
BarryBondsOfLC,BarryBondsOfLC,7,3603,python3,"P = 911382629
MOD = 18446744073709551557
MX = int(1e5)
P_pows = [1] * (MX + 1)
for i in range(1, MX + 1):
    P_pows[i] = (P_pows[i - 1] * P) % MOD

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        G = [[] for _ in range(n)]
        
        for u in range(1, n):
            G[parent[u]].append(u)
            
        hashes = [0] * n
        rev_hashes = [0] * n
        length = [0] * n
        
        def dfs(x):
            hs = 0
            sz = 0
            for y in G[x]:
                dfs(y)
                hs = (hs * P_pows[length[y]] + hashes[y]) % MOD
                sz += length[y]
            hs = (hs * P + ord(s[x])) % MOD
            hashes[x] = hs
            sz += 1
            length[x] = sz
            
            rev_hs = ord(s[x])
            for y in reversed(G[x]):
                rev_hs = (
                    rev_hs * P_pows[length[y]] + rev_hashes[y]
                ) % MOD
            rev_hashes[x] = rev_hs

        dfs(0)

        res = [False] * n
        for x in range(n):
            if hashes[x] == rev_hashes[x]:
                res[x] = True

        return res",1427852502
BarryBondsOfLC,BarryBondsOfLC,7,3607,cpp,"int MX = 1e6;

struct Divisors {
    vector<int> fs;
    Divisors() : fs(MX + 1) {
        for (int p = 2; p <= MX; ++p) {
            for (int q = 2 * p; q <= MX; q += p) {
                fs[q] = p;
            }
        }
    }  
} divisors;

class Solution {
public:
    int minOperations(vector<int>& A) {
        int n = A.size(), res = 0;
        for (int i = n - 2; i >= 0; --i) {
            if (A[i] > A[i + 1]) {
                auto f = divisors.fs[A[i]];
                if (f == 0) return -1;
                if ((A[i] /= f) > A[i + 1]) return -1;
                ++res;
            }
        }
        
        return res;
    }
};",1427837406
Ethan,ethanrao,8,3502,cpp,"class Solution {
public:
    int t[26][3005], cnt[26];
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();
        for(int i = 0; i < n; ++i){
            int r = s[i] - 'a';
            t[r][++cnt[r]] = i;
            int u = -1;
            for(int j = 0; j < 26; ++j)
                if(cnt[j] >= k)
                    u = std::max(u, t[j][cnt[j] - k + 1]);
            ans += u + 1;
        }
        return ans;
    }
};",1427852731
Ethan,ethanrao,8,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string prefix = """";
        for (int i = 0; i < target.size(); ++i) {
            
            for (int k = 0; k < 26; ++k) {
                char ch = char(('a' + k) ); 
                string tt= prefix+ch;
                res.push_back(tt);
                if(ch==target[i]){
                    break;
                }
            }
            prefix+=target[i];
        }
        return res;
    }
};
",1427845687
Ethan,ethanrao,8,3603,cpp,"class Solution {
public:
    int siz[100005], f[100005], g[100005], n, val[100005], pw[100005];
    bool ans[100005];
    std::vector <int> son[100005];
    const int mod = 998244853, base = 41;
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int minus(int x, int y){
        return x < y ? x - y + mod : x - y;
    }
    void dfs(int x){
        siz[x] = 1;
        for(auto v: son[x]){
            dfs(v);
            siz[x] += siz[v];
        }
        for(int i = 0; i < son[x].size(); ++i){
            int v = son[x][i];
            f[x] = mul(f[x], pw[siz[v]]);
            f[x] = add(f[x], f[v]);
        }
        f[x] = mul(f[x], pw[1]);
        f[x] = add(f[x], val[x]);
        
        g[x] = val[x];
        for(int i = son[x].size() - 1; i >= 0; --i){
            int v = son[x][i];
            g[x] = mul(g[x], pw[siz[v]]);
            g[x] = add(g[x], g[v]);
        }
        if(f[x] == g[x]) ans[x] = true;
        else ans[x] = false;
        return ;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        n = parent.size();
        pw[0] = 1;
        for(int i = 1; i <= n; ++i) pw[i] = mul(pw[i - 1], base);
        for(int i = 0; i < n; ++i){
            val[i] = s[i] - 'a' + 10;
            if(i != 0) son[parent[i]].push_back(i);
        }
        dfs(0);
        std::vector <bool> res; res.resize(n);
        for(int i = 0; i < n; ++i) res[i] = ans[i];
        return res;
    }
};",1427843430
Ethan,ethanrao,8,3607,cpp,"class Solution {
public:
    int p[1005], cnt = 0, vis[1005];
    int minOperations(vector<int>& nums) {
        for(int i = 1; i <= 1000; ++i) vis[i] = 1;
        vis[1] = 0;
        for(int i = 2; i <= 1000; ++i){
            if(vis[i]) p[++cnt] = i;
            for(int j = 1; j <= cnt && i * p[j] <= 1000; ++j){
                vis[i * p[j]] = 0;
            }
        }
        int n = nums.size(), ans = 0, lst = 1000000;
        for(int i = n - 1; i >= 0; --i){
            if(nums[i] <= lst){
                lst = nums[i];
                continue;
            }
            int f = -1;
            for(int j = 1; j <= cnt; ++j)
                if(nums[i] % p[j] == 0){
                    f = p[j];
                    break;
                }
            if(f == -1 || f > lst) return -1;
            ans += 1;
            lst = f;
        }
        return ans;
    }
};",1427830038
SR3mix,SR3mix,9,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<vector<int>>v(26); int ans = 0;
        for (int i = 0; i < s.size(); i++) {
            int c = s[i] - 'a';
            v[c].push_back(i);
            int ma = -1;
            for (int j = 0; j < 26; j++) {
                if (v[j].size() >= k) ma = max(ma, v[j][v[j].size() - k]);
            }
            
            ans += (ma + 1);
        }
        return ans;
    }
};",1427849960
SR3mix,SR3mix,9,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string curr = """";
        int n = target.size();
        for (int i = 0; i < n; i++) {
            int c = target[i] - 'a';
            curr.push_back('_');
            for (int j = 0; j <= c; j++) {
                curr.pop_back();
                char add = 'a'; add += j;
                curr.push_back(add);
                ans.push_back(curr);
            }
        }
        return ans;
    }
};",1427853028
SR3mix,SR3mix,9,3603,cpp,"class StringHash {
public:
    vector<long long>ps1,ps2;
    vector<long long>powq1,powq2;
    long long Q1 = 271, Q2 = 277, M1 = 1000000007, M2 = 998244353;
    StringHash(string s) {
        ps1 = vector<long long>(s.size()+1); ps2 = vector<long long>(s.size()+1);
        powq1 = {1}; powq2 = {1};
        for (int i = 1; i <= s.size(); i++) {
            long long c = s[i-1] + 1;
            ps1[i] = ((Q1 * ps1[i-1]) + c)%M1;
            ps2[i] = ((Q2 * ps2[i-1]) + c)%M2;
            powq1.push_back((powq1.back() * Q1)%M1);
            powq2.push_back((powq2.back() * Q2)%M2);
        }
    }
    long long substrHash1(int firstIndex, int lastIndex) {
        long long rem = (powq1[lastIndex - firstIndex + 1] * ps1[firstIndex])%M1;
        return (ps1[lastIndex+1] - rem + M1)%M1;
    }
    long long substrHash2(int firstIndex, int lastIndex) {
        long long rem = (powq2[lastIndex - firstIndex + 1] * ps2[firstIndex])%M2;
        return (ps2[lastIndex+1] - rem + M2)%M2;
    }
    pair<long long, long long> substrHash(int firstIndex, int lastIndex) {
        return {substrHash1(firstIndex, lastIndex), substrHash2(firstIndex, lastIndex)};
    }
}; 

class EulerTourTree {
public:
    vector<int>tin,tout,depth;
    vector<vector<int>>e;
    int n,timer;
    void dfs(int curr, int p) {
        if (p != -1) depth[curr] = depth[p] + 1;
        tin[curr] = timer;
        for (auto node : e[curr]) if (node != p) dfs(node,curr);
        tout[curr] = timer++;
    }
    EulerTourTree(int n, vector<vector<int>> edges, int root) {
        tin = vector<int>(n); tout = tin; depth = tin;
        e = edges;
        timer = 0;
        dfs(root,-1);
    }
};
// CREDIT TO CP-Algorithms FOR THIS TEMPLATE -> https://cp-algorithms.com/graph/lca_binary_lifting.html#implementation

class Solution {
public:
    int n;
    vector<vector<int>>e;
    vector<int>order;
    string s;
    
    vector<bool> findAnswer(vector<int>& parent, string ss) {
        n = parent.size(); s = ss;
        e = vector<vector<int>>(n);
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) e[parent[i]].push_back(i);
        }
        for (auto &i : e) sort(i.begin(), i.end());
        EulerTourTree ET(n, e, 0);
        // for (auto i : ET.tin) cout << i << "","";
        // cout << endl;
        // for (auto i : ET.tout) cout << i << "","";
        // cout << endl;
        vector<char>v(n);
        for (int i = 0; i < n; i++) {
            v[ET.tout[i]] = s[i];
        }
        string res = """";
        for (auto i : v) res += i;
        string rev = res; reverse(rev.begin(), rev.end());
        // cout << res << endl;
        // cout << rev << endl;
        StringHash SHF(res);
        StringHash SHR(rev);
        vector<bool>ans;
        for (int i = 0; i < n; i++) {
            int l = ET.tin[i];
            int r = ET.tout[i];
            //cout << i << "": "" << l << "","" << r << endl; 
            auto F = SHF.substrHash(l, r);
            auto R = SHR.substrHash(n - r - 1, n - l - 1);
            if (F == R) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;
    }
};",1427839109
SR3mix,SR3mix,9,3607,cpp,"class Math {
    public:
    vector<long long> fact_vec,invfact_vec;
    vector<long long> fact_vec_pure;
    vector<long long> e10_vec;
    vector<int>primes,minp,isprime,phi;
    long long comb_M = -1;
    long long int powxy(long long int x, long long int y, long long M) {
        if (y == 0) return 1;
        if (y%2 == 1) return (x*powxy(x, y-1,M))%M;
        long long int t = powxy(x, y/2,M);
        return (t*t)%M;
    }
    void create_comb(long long maxChooseNumerator, long long M) {
        comb_M = M;
        if (fact_vec.size() > maxChooseNumerator) return;
        if (fact_vec.size() == 0) {
            fact_vec = {1,1};
            invfact_vec = {1,1};
        }
        long long startI = fact_vec.size();
        for (long long i = startI; i <= maxChooseNumerator+1; i++) {
            long long lastFact = fact_vec.back();
            long long currFact = (lastFact * i)%M;
            fact_vec.push_back(currFact);
        }
        invfact_vec.resize(fact_vec.size());
        invfact_vec[fact_vec.size()-1] = powxy(fact_vec.back(), M-2, M);
        for (long long i = maxChooseNumerator; i >= startI; i--) {
            long long lastInv = invfact_vec[i+1];
            long long currInv = (lastInv * (i+1))%M;
            invfact_vec[i] = currInv;
        }
    }
    long long factorial(long long n, long long M) {
        assert(comb_M == M);
        return fact_vec[n];
    }
    long long inv_factorial(long long n, long long M) {
        assert(comb_M == M);
        return invfact_vec[n];
    }
    long long comb(long long a, long long b, long long M) {
        assert(comb_M == M);
        return (((fact_vec[a] * invfact_vec[b])%comb_M) * invfact_vec[a-b])%comb_M;
    }
    long long mgcd(long long a, long long b, long long& x, long long& y) {
        if (b == 0) {x = 1; y = 0; return a;}
        long long x1, y1;
        long long d = mgcd(b, a % b, x1, y1);
        x = y1;
        y = x1 - y1 * (a / b);
        return d;
    }
    long long moddiv(long long a, long long  b, long long M) {
        a = a%M;
        long long x,y;
        long long g = mgcd(b,M,x,y);
        long long inv = (x%M + M)%M;
        return (inv * a)%M;
    }
    long long comb_pure(long long a, long long b) {
        long long numer = factorial_pure(a);
        long long denom1 = factorial_pure(b);
        long long denom2 = factorial_pure(a - b);
        return numer/(denom1 * denom2);
    }
    long long factorial_pure(long long n) {
        assert(n <= 20);
        if (fact_vec_pure.size() == 0) fact_vec_pure.push_back(1);
        while (fact_vec_pure.size() <= n) {
            long long val = fact_vec_pure.size();
            fact_vec_pure.push_back(fact_vec_pure.back() * val);
        }
        return fact_vec_pure[n];
    }
    long long exp10(int p) {
        assert(p <= 18);
        if (e10_vec.size() == 0) e10_vec.push_back(1);
        while (e10_vec.size() <= p) {
            e10_vec.push_back(e10_vec.back() * 10LL);
        }
        return e10_vec[p];
    }
    unsigned long long comb_2(unsigned long long num) {
        if (num%2 == 0) {return (num/2) * (num-1);}
        else {return ((num-1)/2) * num;}
    }
    long long safe_sqrt(long long x) {
        long long l = 0, r = x;
        while (l < r) {
            long long m = l + (r-l)/2 + (r-l)%2;
            long long allow = LLONG_MAX/m;
            if (m <= allow && m * m <= x) l = m;
            else r = m-1;
        }
        return l;
    }
    long long arith_seq_sum(long long first, long long last, long long diff) {
        long long endSum = first + last;
        long long nums = ((last - first)/diff) + 1;
        
        if (endSum%2 == 0) {return (endSum/2) * nums;}
        else {return (nums/2) * endSum;}
    }
    void SievePrimes(int n) {
        if (minp.size() == n+1) return;
        minp = vector<int>(n+1), isprime = minp;
        primes = {};
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {if (i * p > n) break; minp[i*p]=p;}
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    void SieveFull(int n) {
        if (phi.size() == n+1) return;
        phi = vector<int>(n+1);
        minp = vector<int>(n+1);
        isprime = phi;
        primes = {};
        phi[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                phi[i] = i - 1;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {
                if (i * p > n) {
                    break;
                }
                minp[i * p] = p;
                if (p == minp[i]) {
                    phi[i * p] = phi[i] * p;
                    break;
                }
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    vector<array<long long, 2>> prime_factorize(long long num) {
        vector<array<long long, 2>>res;
        for (auto p : primes) {
            if (p > num) break;
            int cnt = 0;
            while (num%p == 0) {
                num /= p;
                cnt++;
            }
            if (cnt) res.push_back({p,cnt});
        }
        if (num > 1) res.push_back({num,1});
        return res;
    }
    vector<int> get_factors(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        vector<int>res;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) res.push_back(i);
        }
        int start = res.size() - 1;
        for (int i = start; i >= 0; i--) {
            if ((num/res[i]) != res[i]) res.push_back(num/res[i]);
        }
        return res;
    }
    vector<int> get_factors_robust(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        set<int>s;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) {s.insert(i); s.insert(num/i);}
        }
        vector<int>res; for (auto i : s) res.push_back(i);
        return res;
    }
    vector<vector<long long>> matmul(vector<vector<long long>>&mat1, vector<vector<long long>>&mat2, long long M) {
        assert(mat1[0].size() == mat2.size());
        int m = mat1.size(), n = mat2[0].size();
        vector<vector<long long>>mat(m, vector<long long>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < mat1[0].size(); k++) {
                    long long add = mat1[i][k] * mat2[k][j];
                    if (M > 0) add %= M;
                    mat[i][j] += add;
                    if (M > 0) mat[i][j] %= M;
                }
            }
        }
        return mat;
    }
    vector<vector<long long>> mateye(int n) {
        vector<vector<long long>>res(n, vector<long long>(n));
        for (int i = 0; i < n; i++) res[i][i] = 1;
        return res;
    }
    vector<vector<long long>> matexp(vector<vector<long long>>&mat, long long p, long long M) {
        if (p == 0) return mateye(mat.size());
        if (p == 1) return mat;
        vector<vector<long long>>mat1 = matexp(mat, p/2, M);
        vector<vector<long long>>res = matmul(mat1, mat1, M);
        if (p%2) return matmul(res, mat, M);
        return res;
    }
    long long first_bit(long long num) {
        if (num == 0) return -1;
        if (num > INT_MAX) return 64 - __builtin_clzll(num) - 1;
        else return 32 - __builtin_clz(num) - 1;
    }
    long long log2(long long num) {
        return first_bit(num);
    }
    long long last_bit(long long num) {
        return __builtin_ctzll(num);
    }
    long long frombin(string &s) {
        long long res = 0;
        for (int shift = 0; shift < s.size(); shift++) {
            if (s[s.size() - shift - 1] == '1') {
                res += (1LL << shift);
            }
        }
        return res;
    }
    string tobin(long long num, int len) {
        string res = """"; for (int i = 0; i < len; i++) res += '0';
        for (int shift = 0; shift < 63; shift++) {
            if ((num & (1LL << shift)) != 0) res[len - shift - 1] = '1';
        }
        return res;
    }
    string toBase(long long n, long long b) {
        bool neg = false;
        if (n < 0) {neg = true;}
        n = abs(n);
        string ans = """";
        while (n > 0) {
            ans += to_string(n%b);
            n /= b;
        }
        if (ans.size() == 0) ans = ""0"";
        if (neg) ans += ""-"";
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
Math math;


class Solution {
public:
    int minOperations(vector<int>& nums) {
        math.SieveFull(1e6 + 5);
        int ans = 0; int n = nums.size();
        if (nums.size() == 1) return ans;
        for (int i = n-2; i >= 0; i--) {
            while (nums[i] > nums[i+1]) {
                if (nums[i] > nums[i+1] && math.minp[nums[i]] == nums[i]) return -1;
                nums[i] = math.minp[nums[i]];
                ans++;
            }
        } 
        return ans;
    }
};",1427845542
4dalols,4dalols,11,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),ans=0; 
        for (int i = 0,j; i < n; i++) {
            vector<int> c(26); 
            for (j = i; ~j; j--) {
                c[s[j]-'a']++;
                if (c[s[j]-'a']>=k) break; 
            }
            ans+=j+1; 
        }
        return ans;
    }
};",1427850623
4dalols,4dalols,11,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> v;
        int n = t.size();
        string s=""""; 
        for (int i = 0; i < n; i++) {
            s+=""a""; v.push_back(s); 
            while (s[i]!=t[i]) {
                s[i]++; v.push_back(s); 
            }
        }
        return v;
    }
};",1427854271
4dalols,4dalols,11,3603,cpp,"class Solution {
public:
    #define ll long long
    string a;
    vector<vector<int>> c;
    vector<int> tin, tout;
    static const ll M = (1LL << 61) - 1;
    static const ll B1 = 1e17+69, B2 = 1e17-69;
    
    vector<vector<ll>> pw = {{1},{1}};
    
    vector<vector<ll>> p_hash;
    
    __int128 mul(ll a, ll b) { return (__int128)a * b; }
    ll mod_mul(ll a, ll b) { return mul(a, b) % M; }
    
    ll HashedString(string &s, int a, ll B, bool h) {
        if (h) p_hash[a].resize(s.size()+1);
        while (pw[a].size() <= s.size()) { pw[a].push_back(mod_mul(pw[a].back(), B)); }
        ll cur=0;
        for (int i = 0; i < s.size(); i++) {
            cur = (mul(cur, B) + s[i]) % M;
            if (h) p_hash[a][i+1]=cur;
        }
        return cur;
    }
    
    ll getHash(int start, int end, int x) {
        ll raw_val =
            p_hash[x][end + 1] - mod_mul(p_hash[x][start], pw[x][end - start + 1]);
        return (raw_val>=0?raw_val:raw_val+M);
    }
    void dfs(int n, string &t) {
        tin[n]=a.size();
        for (int r:c[n]) dfs(r,t);
        tout[n]=a.size(); 
        a+=t[n]; 
    }
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n=s.size(); 
        p_hash.resize(2);
        a=""""; c.clear(); c.resize(n);
        tin.resize(n); tout=tin; 
        for (int i = 1; i < n; i++) c[p[i]].push_back(i); 
        dfs(0,s); 
        vector<bool> b(n); 
        HashedString(a,0,B1,1); 
        reverse(a.begin(),a.end());
        HashedString(a,1,B1,1); 
        for (int i = 0; i < n; i++) {
            b[i]=(getHash(tin[i],tout[i],0)==getHash(n-tout[i]-1,n-tin[i]-1,1));
        }
        return b;
    }
};",1427838224
4dalols,4dalols,11,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& v) {
        int n=v.size(),ans=0;
        for (int i=n-2; ~i; i--) {
            if (v[i]<=v[i+1]) continue; 
            for (int j = 2; j*j<=v[i]&&j<=v[i+1]; j+=(j%2+1)) {
                if (v[i]%j<1) {
                    v[i]=j; break; 
                }
            }
            if (v[i]>v[i+1]) return -1; 
            ans++; 
        }
        return ans;
    }
};",1427844104
SK_MysticCoder,sk8126,12,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int result = 0;

        for (int start = 0; start < n; ++start) {
            unordered_map<char, int> freq;
            for (int end = start; end < n; ++end) {
                freq[s[end]]++;
                // Check if any character appears at least k times
                for (auto &[ch, count] : freq) {
                    if (count >= k) {
                        result++;
                        break;
                    }
                }
            }
        }

        return result;
    }
};
",1427824121
SK_MysticCoder,sk8126,12,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        
        for (char c : target) {
            current += 'a';  // Step 1: Press key 1 to append 'a'
            result.push_back(current);
            
            // Step 2: Increment the last character to match target character
            while (current.back() != c) {
                current.back() = current.back() + 1;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427823664
SK_MysticCoder,sk8126,12,3603,cpp,"class Solution {
public:
    const int base = 911;
    const long long mod = 1000000007;

    
    void computePowers(vector<long long> &pow_p, int max_len) {
        pow_p.resize(max_len + 1, 1);
        for(int i = 1; i <= max_len; ++i){
            pow_p[i] = (pow_p[i-1] * base) % mod;
        }
    }

    
    struct NodeInfo {
        int len;             
        long long hash_fwd;  
        long long hash_rev;  
    };

   
    NodeInfo dfs(int node, const vector<vector<int>> &tree, const string &s, const vector<long long> &pow_p, vector<bool> &answer) {
        NodeInfo info;
        info.len = 1;
        info.hash_fwd = (s[node] - 'a' + 1) % mod;
        info.hash_rev = (s[node] - 'a' + 1) % mod;

        
        vector<NodeInfo> children_info;

        
        for(auto child : tree[node]){
            NodeInfo child_info = dfs(child, tree, s, pow_p, answer);
            children_info.push_back(child_info);
        }

       
        info.hash_fwd = 0;
        int total_len = 0;
        for(auto &child_info : children_info){
            info.hash_fwd = (info.hash_fwd * pow_p[child_info.len] + child_info.hash_fwd) % mod;
            total_len += child_info.len;
        }
        info.len = total_len + 1; 
        info.hash_fwd = (info.hash_fwd * pow_p[1] + (s[node] - 'a' + 1)) % mod;

        
        info.hash_rev = (s[node] - 'a' + 1) % mod;
        for(int i = children_info.size() -1; i >=0; --i){
            info.hash_rev = (info.hash_rev * pow_p[children_info[i].len] + children_info[i].hash_rev) % mod;
        }

        
        answer[node] = (info.hash_fwd == info.hash_rev);

        return info;
    }

    
    vector<bool> checkPalindromeDFS(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n, vector<int>());
        int root = -1;

        
        for(int i =0; i<n; ++i){
            if(parent[i] == -1){
                root = i;
            }
            else{
                tree[parent[i]].push_back(i);
            }
        }

        
        vector<long long> pow_p;
        computePowers(pow_p, n);

       
        vector<bool> answer(n, false);

       
        dfs(root, tree, s, pow_p, answer);

        return answer;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        return checkPalindromeDFS(parent, s);
    }
};
",1427846905
SK_MysticCoder,sk8126,12,3607,cpp,"#include <vector>
#include <cmath>

class Solution {
public:
   
    int smallestPrimeFactor(int x) {
        if (x % 2 == 0) return 2;
        for (int i = 3; i <= sqrt(x); i += 2) {
            if (x % i == 0) return i;
        }
        return x; 
    }

    int minOperations(std::vector<int>& nums) {
        int operations = 0;
        int n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            
            if (nums[i] <= nums[i + 1]) {
                continue;
            }

           
            if (nums[i] == 1) {
                return -1;
            }

            
            int spf = smallestPrimeFactor(nums[i]);
            nums[i] = spf;
            operations += 1;

           
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
        }
        return operations;
    }
};
",1427829701
Chinedu,profchi,16,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        
        int [] count = new int [26];
        
        int total = 0;
        
        for (int i = 0; i < s.length(); ++i) {
            Arrays.fill(count, 0);
            int val;
            boolean seen = false;
            
            for (int j = i; j < s.length(); ++j) {
                val = s.charAt(j) - 'a';
                
                count[val]++;
                
                if (count[val] == k)
                    seen = true;
                
                total += seen ? 1 : 0;
            }
        }
        
        return total;
    }
}",1427826638
Chinedu,profchi,16,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        
        String current = """";
        
        List<String> result = new ArrayList<>();
        
        for (char c : target.toCharArray()) {
            
            for (char x = 'a'; x <= c; ++x) {
                result.add(current + x);
            }
            
            current += c;
        }
        
        return result;
    }
}",1427824352
Chinedu,profchi,16,3603,java,"class Solution {
    
    List<Integer> [] graph;
    
    int [][] pos;
    
    int idx;
    
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        
        graph = new List[n];
        
        for (int i = 0; i < n; ++i) {
            graph[i] = new ArrayList<>();
        }
        
        for (int i = 1; i < n; ++i) {
            graph[parent[i]].add(i);
        }
        
        StringBuilder sb = new StringBuilder();
        pos = new int [n][2];
        
        dfs(0, sb, s);
        
        String val = sb.toString();
        
        boolean [] res = new boolean [n];
        
        RollingHashLong roll = RollingHashLong.getHashFromString(val, 30, 1_000_000_007);
        
        int a, b;
        
        for (int i = 0; i < n; ++i) {
            a = pos[i][0];
            b = pos[i][1];
            
            res[i] = roll.getHashLong(a, b) == roll.getHashLong(b, a);
        }
        
        return res;
    }
    
    private void dfs(int node, StringBuilder sb, String s) {
        
        pos[node][0] = sb.length();
        
        
        for (int child : graph[node]) {
            dfs(child, sb, s);
        }
        
        
        pos[node][1] = sb.length();
        sb.append(s.charAt(node));
    }
    
    
}
class RollingHashLong {
	
	long [] mArr;
	long [] forwardArr;
	long [] backArr;
	
	
	long [] mArr2;
	long [] forwardArr2;
	long [] backArr2;
	
	
	int [] requestArr;
	int reqMul, reqMul2;
	
	long mod, mod2;
	
	static Random rand = new Random();
	
	static int addMul =  1_005 + rand.nextInt(100);
	static int addMod = 1_000_016 + 2 * rand.nextInt(100_000);
	
	// lower case alpha
	public static RollingHashLong getHashFromString(String s, int mul, int mod) {
		int [] arr = new int[s.length()];
		
		for (int i = 0; i < s.length(); ++i) {
			arr[i] = s.charAt(i) - 'a';
		}
		
		return new RollingHashLong(arr, mul, mod);
	}
	
	// zero indexex
	public RollingHashLong(int [] arr, int mul, int mod) {
		
		long cHash = 0;
		long mHash = 1;
		
		mArr = new long [arr.length + 1];
		forwardArr = new long [arr.length];
		backArr = new long [arr.length];
		
		this.mod = mod;
		this.requestArr = arr;
		this.reqMul = mul;
		
		mArr[0] = 1;
		
		for (int i = 0; i < arr.length; ++i) {
			cHash *= mul;
			cHash += arr[i];
			cHash %= mod;
			
			forwardArr[i] = cHash;
			
			mHash *= mul;
			mHash %= mod;
			
			mArr[i + 1] = mHash;
		}
		
		cHash = 0;
		
		for (int i = arr.length - 1; i >= 0; --i) {
			cHash *= mul;
			cHash += arr[i];
			cHash %= mod;
			
			backArr[i] = cHash;
		}
		
		
		
		
		
		
		cHash = 0;
		mHash = 1;
		
		mArr2 = new long [arr.length + 1];
		forwardArr2 = new long [arr.length];
		backArr2 = new long [arr.length];
		
		this.mod2 = mod + addMod;
		this.reqMul2 = mul + addMul;
		int mul2 = reqMul2;
		
		mArr2[0] = 1;
		
		for (int i = 0; i < arr.length; ++i) {
			cHash *= mul2;
			cHash += arr[i];
			cHash %= mod2;
			
			forwardArr2[i] = cHash;
			
			mHash *= mul2;
			mHash %= mod2;
			
			mArr2[i + 1] = mHash;
		}
		
		cHash = 0;
		
		for (int i = arr.length - 1; i >= 0; --i) {
			cHash *= mul2;
			cHash += arr[i];
			cHash %= mod2;
			
			backArr2[i] = cHash;
		}
	}
	
	public long getHashLong(int from, int to) {
        // System.out.println(from + "" "" + to);
		long hash = getHash(from, to, forwardArr, backArr, mArr, mod);
		hash *= mod2;
		hash += getHash(from, to, forwardArr2, backArr2, mArr2, mod2);
		return hash;
	}
	
	// abcdefg
	// def - abcdef - abc * 3
	
	private long getHash(int from, int to, 
			long [] forwardArr, long [] backArr, long [] mArr, long mod) {
		
		long result;
		int prev;
		
		if (to >= from) {
			result = forwardArr[to];
			prev = from - 1;
			
			long sub = prev == -1 ? 0 : forwardArr[prev];
			sub *= mArr[to - prev];
			sub %= mod;
			
			result += mod;
			result -= sub;
			result %= mod;
		}else {
			result = backArr[to];
			prev = from + 1;
			
			long sub = prev == backArr.length ? 0 : backArr[prev];
			sub *= mArr[prev - to];
			sub %= mod;
			
			result += mod;
			result -= sub;
			result %= mod;
		}
		
		return result;
	}
}


",1427855862
Chinedu,profchi,16,3607,java,"class Solution {
    
    static int [] maxDiv;
    
    static {
        int length = 1_000_001;
        maxDiv = new int [length];
        
        for (int i = 1; i < length; ++i) {
            for (int j = 2 * i; j < length; j += i) {
                maxDiv[j] = i;
            }
        }
    }
    
    public int minOperations(int[] nums) {
        
        int max;
        
        int total = 0;
        
        for (int i = nums.length - 2; i >= 0; --i) {
            
            while (nums[i] > nums[i + 1]) {
                max = maxDiv[nums[i]];
                
                if (max < 2)
                    return -1;
                
                ++total;
                
                nums[i] /= max;
            }
        }
        
        return total;
    }
}",1427834481
penguinhacker,penguinhacker,17,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int cnt[26]={};
        int ans=0;
        for (int j=0, i=0; i<s.size(); ++i) {
            ++cnt[s[i]-'a'];
            while(*max_element(cnt, cnt+26)>=k) {
                --cnt[s[j]-'a'];
                ++j;
            }
            if (j) {
                --j;
                ++cnt[s[j]-'a'];
            }
            if (*max_element(cnt, cnt+26)>=k) {
                ans+=j+1;
            }
        }
        return ans;
    }
};",1427828986
penguinhacker,penguinhacker,17,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans(1, ""a"");
        while(ans.back()!=target) {
            //cout << ans.size() << endl;
            if (ans.back().back()==target[ans.back().size()-1]) {
                ans.push_back(ans.back()+""a"");
            } else {
                string x=ans.back();
                x.back()++;
                ans.push_back(x);
            }
        }
        return ans;
    }
};",1427827818
penguinhacker,penguinhacker,17,3603,cpp,"#define ll long long
#define ar array

const int MOD = 1e9 + 7;

namespace Hashing {

mt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<int> BDIST(0.1 * MOD, 0.9 * MOD);
const ar<int, 2> base = {BDIST(rng), BDIST(rng)};

ar<int, 2> operator+ (ar<int, 2> a, ar<int, 2> b) {
	for (int i = 0; i < 2; ++i)
		if ((a[i] += b[i]) >= MOD)
			a[i] -= MOD;
	return a;
}
ar<int, 2> operator- (ar<int, 2> a, ar<int, 2> b) {
	for (int i = 0; i < 2; ++i)
		if ((a[i] -= b[i]) < 0)
			a[i] += MOD;
	return a;
}
ar<int, 2> operator* (ar<int, 2> a, ar<int, 2> b) {
	for (int i = 0; i < 2; ++i)
		a[i] = (ll)a[i] * b[i] % MOD;
	return a;
}
ar<int, 2> make_hash(char c) {
	return {c, c};
}

vector<ar<int, 2>> pows = {{1, 1}};
void extend(int len) {
	while(pows.size() <= len)
		pows.push_back(base * pows.back());
}

// struct hstring {
// 	string s;
// 	vector<ar<int, 2>> pre = {{0, 0}};
// 	void add(string t) {
// 		s += t;
// 		for (char c : t)
// 			pre.push_back(base * pre.back() + make_hash(c));
// 	}
// 	ar<int, 2> hash(int l, int r) {
// 		assert(0 <= l && l <= r && r < s.size());
// 		int len = r - l + 1;
// 		extend(len);
// 		return pre[r + 1] - pows[len] * pre[l];
// 	}
// };

}
using namespace Hashing;


class Solution {
public:
    int n;
    vector<vector<int>> adj;
    vector<bool> ans;
    vector<int> sz;
    string s;

    ar<ar<int, 2>, 2> dfs(int u=0) {
        ar<int, 2> h1={}, h2={};
        int cur=0;
        for (int v : adj[u]) {
            ar<ar<int, 2>, 2> x = dfs(v);
            h1=h1*pows[sz[v]]+x[0];
            h2=x[1]*pows[sz[u]-1]+h2;
            sz[u]+=sz[v];
        }
        //cout << pows.size() << "" "" << s[u] << endl;
        h1=h1*pows[1]+make_hash(s[u]);
        h2=make_hash(s[u])*pows[sz[u]-1]+h2;
        // if (u==1) {
        //     cout << (make_hash('a')+make_hash('b')*pows[1]+make_hash('a')*pows[2])[0] << endl;
        //     cout << h1[0] << "" "" << h2[0] << endl;
        // }
        ans[u]=h1==h2;
        return {h1, h2};
    }

    vector<bool> findAnswer(vector<int>& parent, string _s) {
        s=_s;
        n=parent.size();
        adj.resize(n);
        ans.resize(n);
        sz.assign(n, 1);
        for (int i=1; i<n; ++i)
            adj[parent[i]].push_back(i);
        extend(n+5);
        dfs();
        return ans;
    }
};",1427856962
penguinhacker,penguinhacker,17,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> a(*max_element(nums.begin(), nums.end())+1);
        for (int i=2; i<a.size(); ++i) {
            if (a[i])
                continue;
            for (int j=i; j<a.size(); j+=i)
                if (!a[j])
                    a[j]=i;
        }
        reverse(nums.begin(), nums.end());
        int ans=0;
        for (int i=1; i<nums.size(); ++i) {
            if (nums[i]>nums[i-1]) {
                nums[i]=a[nums[i]];
                ++ans;
                if (nums[i]>nums[i-1])
                    return -1;
            }
        }
        return ans;
    }
};",1427832996
Lin Yang Yun,LinYangyun,18,3502,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution
{
public:
    int numberOfSubstrings(string s, int k)
    {
        int n = sz(s);
        if (k == 1)
            return n * (n + 1) / 2;
        if (k > n)
            return 0;

        int ans = 0;
        loop(i, 0, n)
        {
            int freq[26] = {0};
            int cnt = 0;
            for (int j = i; j < n; j++)
            {
                int idx = s[j] - 'a';
                freq[idx]++;
                cnt+= (freq[idx] == k);        
                if (cnt > 0)
                    ans++;
                
            }
        }
        return ans;
    }
};
",1427834410
Lin Yang Yun,LinYangyun,18,3566,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution {
public:
    vector<string> stringSequence(string target) {
        fastio;
        vector<string> ans;
        string t = """";
        
        for(char c : target){
            t += 'a';
            ans.pb(t);
            int charr = c - 'a';
            for(int i = 0; i < charr; ++i){
                if(t.empty()) break;
                if(t.back() != 'z')
                    t.back() += 1;
                else
                    t.back() = 'a';
                
                ans.pb(t);
            }
        }
        
        return ans;
    }
};
",1427840770
Lin Yang Yun,LinYangyun,18,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution
{
public:
    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        int n = sz(parent);
        vvi tree(n);
        for (int i = 1; i < n; ++i)
            tree[parent[i]].pb(i);

        vi L(n), R(n);
        string ss;
        int idx = 0;

        function<void(int)> dfs = [&](int x)
        {
            L[x] = idx;
            for (int y : tree[x])
            {
                dfs(y);
            }
            ss += s[x];
            R[x] = idx++;
        };

        dfs(0);
        string Rev_ss = ss;
        reverse(Rev_ss.begin(), Rev_ss.end());

        int N = ss.size();
        const lli P1 = 911, MOD1 = 999999937;
        const lli P2 = 3571, MOD2 = 999999929;

        vll powP1(N + 1), powP2(N + 1);
        powP1[0] = powP2[0] = 1;
        for (int i = 1; i <= N; ++i)
        {
            powP1[i] = (powP1[i - 1] * P1) % MOD1;
            powP2[i] = (powP2[i - 1] * P2) % MOD2;
        }

        vll H1(N), H2(N), RevH1(N), RevH2(N);
        vi val(256);
        for (char c = 'a'; c <= 'z'; ++c)
        {
            val[c] = c - 'a' + 1;
        }

        H1[0] = val[ss[0]];
        H2[0] = val[ss[0]];
        for (int i = 1; i < N; ++i)
        {
            H1[i] = (H1[i - 1] * P1 + val[ss[i]]) % MOD1;
            H2[i] = (H2[i - 1] * P2 + val[ss[i]]) % MOD2;
        }

        RevH1[0] = val[Rev_ss[0]];
        RevH2[0] = val[Rev_ss[0]];
        for (int i = 1; i < N; ++i)
        {
            RevH1[i] = (RevH1[i - 1] * P1 + val[Rev_ss[i]]) % MOD1;
            RevH2[i] = (RevH2[i - 1] * P2 + val[Rev_ss[i]]) % MOD2;
        }

        vector<bool> answer(n);

        for (int x = 0; x < n; ++x)
        {
            int Lx = L[x], Rx = R[x];
            lli frwrd, backwrd;
            if (Lx > 0)
            {
                frwrd = (H1[Rx] - H1[Lx - 1] * powP1[Rx - Lx + 1] % MOD1 + MOD1) % MOD1;
                backwrd = (H2[Rx] - H2[Lx - 1] * powP2[Rx - Lx + 1] % MOD2 + MOD2) % MOD2;
            }
            else
            {
                frwrd = H1[Rx];
                backwrd = H2[Rx];
            }
            int A = N - 1 - Rx, B = N - 1 - Lx;
            lli hash1_rev, hash2_rev;
            if (A > 0)
            {
                hash1_rev = (RevH1[B] - RevH1[A - 1] * powP1[B - A + 1] % MOD1 + MOD1) % MOD1;
                hash2_rev = (RevH2[B] - RevH2[A - 1] * powP2[B - A + 1] % MOD2 + MOD2) % MOD2;
            }
            else
            {
                hash1_rev = RevH1[B];
                hash2_rev = RevH2[B];
            }

            if (frwrd == hash1_rev && backwrd == hash2_rev)
            {
                answer[x] = true;
                continue;
            }

            answer[x] = false;
        }

        return answer;
    }
};
",1427829096
Lin Yang Yun,LinYangyun,18,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
#define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;

class Solution
{
public:
    int minOperations(vector<int> &nums)
    {
        int n = sz(nums),ans = 0;
        const int MAXN = 1e6 + 1;
        vi spf(MAXN);
        for (int i = 0; i < MAXN; ++i)
        {
            spf[i] = i;
        }
        for (int i = 2; i * i < MAXN; ++i)
        {
            if (spf[i] == i)
            {
                for (int j = i * i; j < MAXN; j += i)
                {
                    if (spf[j] == j)
                    {
                        spf[j] = i;
                    }
                }
            }
        }

        loopD(i, n - 1, 1)
        {
            if (nums[i - 1] > nums[i])
            {
                if (nums[i - 1] == spf[nums[i - 1]])
                    return -1;
                if (spf[nums[i - 1]] > nums[i]) return -1;
                
                    nums[i - 1] = spf[nums[i - 1]];
                    ans += 1;
            }
        }
        return ans;
    }
};
",1427857762
dirigibility,dirigibility,19,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        q = defaultdict(deque)
        j = -1
        count = 0
        for i,c in enumerate(s):
            q[c].append(i)
            if len(q[c]) > k:
                q[c].popleft()
            if len(q[c]) == k:
                j = max(j,q[c][0])
            count += j+1
        return count",1427828201
dirigibility,dirigibility,19,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        l = []
        result = []
        for c in target:
            l.append('a')
            result.append(''.join(l))
            while l[-1] != c:
                l[-1] = chr(ord(l[-1])+1)
                result.append(''.join(l))
        return result
                ",1427824436
dirigibility,dirigibility,19,3603,python3,"def manacher(s):
    s = ''.join(chain('.',*zip(s,repeat('.'))))
    n = len(s)
    max_rad = [0]*n
    ctr = rad = 0
    while ctr < n:
        while ctr-rad-1 >= 0 and ctr+rad+1 < n and s[ctr-rad-1] == s[ctr+rad+1]:
            rad += 1
        max_rad[ctr] = rad
        ctr0 = ctr
        rad0 = rad
        ctr += 1
        rad = 0
        while ctr <= ctr0+rad0:
            ctr_refl = 2*ctr0-ctr
            rad_edge = ctr0+rad0-ctr
            if max_rad[ctr_refl] == rad_edge:
                rad = rad_edge
                break
            max_rad[ctr] = min(max_rad[ctr_refl],rad_edge)
            ctr += 1
    return max_rad

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        children = [[] for _ in range(n)]
        for x in range(1,n):
            children[parent[x]].append(x)
        a = {}
        b = {}
        dfsStr = []
        def dfs(x):
            a[x] = len(dfsStr)
            for y in children[x]:
                dfs(y)
            b[x] = len(dfsStr)
            dfsStr.append(s[x])
        dfs(0)
        max_rad = manacher(''.join(dfsStr))
        return [max_rad[a[x]+b[x]+1] >= b[x]-a[x]+1 for x in range(n)]",1427859014
dirigibility,dirigibility,19,3607,python3,"@cache
def p(n):
    for k in range(2,isqrt(n)+1):
        if not n%k:
            return k
    return n

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        @cache
        def f(i,prev):
            if i == len(nums):
                return 0
            if nums[i] < prev:
                return inf
            if (x := p(nums[i])) >= prev:
                return min(1+f(i+1,x),f(i+1,nums[i]))
            return f(i+1,nums[i])
        result = f(0,0)
        f.cache_clear()
        return result if result != inf else -1",1427837551
07dishwasherbob8,07dishwasherbob8,23,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int lo = 0, hi = 0;

        int cnt = 0;

        vector<int> cnts(26);

        for(int i = 0; i < s.size(); i++) {
            if(i) {
                cnts[s[i-1] - 'a']--;
            }
            while(*max_element(cnts.begin(), cnts.end()) < k && hi != s.size()) {
                cnts[s[hi++] - 'a']++;
            }
            if((*max_element(cnts.begin(), cnts.end())) >= k) {
                cnt += s.size() - hi + 1;
            }
        }

        return cnt;

    }
};",1427858627
07dishwasherbob8,07dishwasherbob8,23,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";
        for(int i = 0; i < target.size(); i++) {
            curr.push_back('a');
            res.push_back(curr);
            while(curr[i] != target[i]) {
                curr.back()++;
                res.push_back(curr);
            }
        }
        return res;
    }
};",1427860968
07dishwasherbob8,07dishwasherbob8,23,3603,cpp,"class Solution {

vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

//checks if is palindrome [l, r)
bool ispal(int l, int r, vector<int> &man) {

    int center = l + r - 1;
    return man[center] - 1 >= r - l ;
}

public:
    vector<bool> findAnswer(vector<int>& parent, string s) {


        int n = parent.size();
        vector<vector<int>> children(n);

        for(int i = 1; i < n; i++) {
            children[parent[i]].push_back(i);
        }

        vector<int> tin(n);
        vector<int> tout(n);

        string news = """";

        int time = 0;

        auto dfs = [&](auto self, int i) -> void {
            tin[i] = time;
            sort(children[i].begin(), children[i].end());
            for(int c : children[i]) {
                self(self, c);
            }
            news.push_back(s[i]);
            tout[i] = ++time;
        };

        dfs(dfs, 0);

        vector<int> man = manacher(news);


        // cout << ""news : "" << news << '\n';
        
        // for(int x : man) {
        //     cout << x << ' ';
        // }
        // cout << '\n';

        // for(int x : tin) {
        //     cout << x << ' ';
        // }
        // cout << '\n';
        // for(int x : tout) {
        //     cout << x << ' ';
        // }

        cout << '\n';

        vector<bool> res(n);

        for(int i = 0; i < n; i++) {
            res[i] = ispal(tin[i], tout[i], man);
        }

        return res;

    }
};",1427843977
07dishwasherbob8,07dishwasherbob8,23,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        
        int ops = 0;

        auto divide = [&](int idx) -> int {
            // cout << ""idx : "" << idx << "" nums[idx] : "" << nums[idx] << '\n';
            for(int i = 2; i * i <= nums[idx]; ++i) {
                if(nums[idx] % i == 0) {
                    nums[idx] /= nums[idx] / i;
                    return 1;
                }
            }
            return 0;
        };

        int lo = INT_MAX;
        for(int i = nums.size() - 1; i >= 0; i--) {
            while(nums[i] > lo) {
                if(!divide(i)) {
                    return -1;
                }
                ops++;
            }
            lo = min(lo, nums[i]);
        }
        return ops;
    }
};",1427852834
unicorn_15,unicorn_15,24,3502,cpp,"#include <iostream>
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int r = 0;
        for(int i = 0; i < n; ++i){
            vector<int> f(26, 0);
            int c = 0;
            for(int j = i; j < n; ++j){
                int idx = s[j] - 'a';
                if(idx < 0 || idx >= 26){
                    // If the character is not a lowercase letter, skip or handle as needed
                    continue;
                }
                f[idx] += 1;
                if(f[idx] == k){
                    c += 1;
                }
                if(c > 0){
                    r += 1;
                }
            }
        }
        return r;
    }
};
 ",1427861372
unicorn_15,unicorn_15,24,3566,cpp,"#include <cctype> 
class Solution {
public:
    vector<string> stringSequence(const string& target) {
        vector<string> result;
        string current = """";
        
        for(char c : target) {
            char lower_c = tolower(c);
            current += 'a';
            result.push_back(current);
            
            if(lower_c != 'a') {
                int increments = (static_cast<int>(lower_c) - static_cast<int>('a')) % 26;
                for(int i = 0; i < increments; ++i) {
                    current.back() = static_cast<char>(((current.back() - 'a' + 1) % 26) + 'a');
                    result.push_back(current);
                }
            }
        }
        
        return result;
    }
};",1427860232
unicorn_15,unicorn_15,24,3603,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <functional>

using namespace std;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size(); 
        vector<vector<int>> children(n, vector<int>());
        for(int i = 1; i < n; ++i){
            children[parent[i]].push_back(i);
        } 
        for(auto &ch : children){
            sort(ch.begin(), ch.end());
        } 
        const long long mod = 1000000007;
        const long long base = 911;
        vector<long long> pow_base(n + 2, 1);
        for(int i = 1; i <= n + 1; ++i){
            pow_base[i] = (pow_base[i - 1] * base) % mod;
        }
        
        // Initialize the result vector
        vector<bool> res(n, false);
        
        // Define a structure to hold hash values and length
        struct HashData {
            long long h; // Forward hash
            long long rh; // Reverse hash
            int l; // Length of the subtree
        };
        
        // Define the DFS function using lambda
        function<HashData(int)> dfs = [&](int x) -> HashData {
            long long h = 0;
            long long rh = 0;
            int l = 0;
            vector<pair<long long, int>> child_data;
            
            // Process all children
            for(auto &y : children[x]){
                HashData child = dfs(y);
                // Update forward hash
                h = (h * pow_base[child.l] + child.h) % mod;
                // Store reverse hash and length for later
                child_data.emplace_back(child.rh, child.l);
                // Update total length
                l += child.l;
            }
            
            // Process current node's character
            int c_val = (s[x] - 'a') + 1;
            h = (h * base + c_val) % mod;
            l += 1;
            rh = c_val;
            
            // Update reverse hash by processing children in reverse order
            for(auto it = child_data.rbegin(); it != child_data.rend(); ++it){
                rh = (rh * pow_base[it->second] + it->first) % mod;
            }
            
            // Check if forward hash equals reverse hash
            res[x] = (h == rh);
            
            return HashData{h, rh, l};
        };
        
        // Start DFS from the root node (assumed to be 0)
        dfs(0);
        
        return res;
    }
};",1427864143
unicorn_15,unicorn_15,24,3607,cpp,"#include <vector>
#include <climits>

using namespace std;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        const int mx = 32000; 
        vector<bool> sv(mx, true);
        vector<int> pr;
        sv[0] = sv[1] = false;
        for(int i = 2; i < mx; ++i){
            if(sv[i]){
                pr.push_back(i);
                for(int j = i * i; j < mx; j += i){
                    sv[j] = false;
                }
            }
        }
        
        // Lambda function to find the smallest prime factor of x
        auto spf = [&](int x) -> int {
            for(auto &p : pr){
                if((long long)p * p > x){
                    break;
                }
                if(x % p == 0){
                    return p;
                }
            }
            return x;
        };
        
        int res = 0;
        int mn = INT32_MAX;
         
        for(int i = n - 1; i >= 0; --i){
            while(nums[i] > mn){
                if(nums[i] == 1){
                    return -1;
                }
                int f = spf(nums[i]);
                if(f == nums[i]){
                    return -1;
                }
                nums[i] = f;
                res += 1;
            }
            mn = nums[i];
        }
        
        return res;
    }
};",1427862710
green_pig,green_pig,25,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        j = 0
        c = [0] * 26
        t = 0
        n = len(s)
        r = 0
        for i in range(len(s)):
            while j < n and not t:
                ch = ord(s[j]) - 97
                c[ch] += 1
                t += c[ch] == k
                j += 1
            r += t and n - j + 1
            ch = ord(s[i]) - 97
            c[ch] -= 1
            t -= c[ch] == k-1
        return r",1427827525
green_pig,green_pig,25,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        a = []
        r = []
        for c in target:
            a.append('a')
            r.append(''.join(a))
            for i in range(ord(c) - 97):
                a[-1] = chr(ord(a[-1]) + 1)
                r.append(''.join(a))
        return r",1427824445
green_pig,green_pig,25,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], S: str) -> List[bool]:
        n = len(parent)
        t = [[] for _ in range(n)]
        for i in range(1, n):
            t[parent[i]].append(i)
        p = [1] * n
        def dfs(i):
            s = r = k = 0
            s = ord(S[i])
            a = []
            for j in t[i]:
                a.append(dfs(j))
                k += a[-1][2]
            for x, y, z in a:
                r = (r * pow(Q, z, P) + y) % P
            for x, y, z in a[::-1]:
                s = (s * pow(Q, z, P) + x) % P
            r = (r * Q + ord(S[i])) % P
            p[i] &= s == r
            return s, r, k + 1
        P = 10**9+7
        Q = 257
        dfs(0)
        Q = 29
        dfs(0)
        Q = 31
        dfs(0)
        return [bool(x) for x in p]",1427857214
green_pig,green_pig,25,3607,python3,"def primes(n):
    prime = bytearray(b'\0\0' + b'\1' * (n-1))
    r = []
    for i in range(n+1):
        if prime[i]:
            r.append(i)
            prime[i*i::i] = b'\0' * (n//i-i+1)
    return r
n = 10**6+1
a = primes(n)
lp = [0] * n
for p in a[::-1]:
    for i in range(p, n, p):
        lp[i] = p
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        r = 0
        f = 0
        p = inf
        for x in nums[::-1]:
            if x > p:
                x = lp[x]
                r += 1
            if x > p:
                return -1
            p = x
        return r
",1427835377
uwi,uwi,26,3502,java,"class Solution {
    public int numberOfSubstrings(String S, int k) {
        char[] s = S.toCharArray();
        int ans = 0;
        for(int i = 0;i < s.length;i++){
            int[] f = new int[26];
            for(int j = i;j < s.length;j++){
                if(++f[s[j]-'a'] == k){
                    ans += s.length - j;
                    break;
                }
            }
        }
        return ans;
    }
}",1427825086
uwi,uwi,26,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        String cur = """";
        List<String> ret = new ArrayList<>();
        for(int i = 0;i < target.length();i++){
            for(char c = 'a';c <= target.charAt(i);c++){
                ret.add(cur + c);
            }
            cur += target.charAt(i);
        }
        return ret;
    }
}",1427824075
uwi,uwi,26,3603,java,"	class Solution {
		char[] s;
		int[][] ch;

		long[] hf;
		long[] hb;
		RollingHash61 rh;

		public boolean[] findAnswer(int[] parent, String S) {
			ch = parentToChildren(parent);
			for(int i = 0;i < parent.length;i++){
				Arrays.sort(ch[i]);
			}
			s = S.toCharArray();

			hf = new long[s.length];
			hb = new long[s.length];
			rh = new RollingHash61(31, s.length);
			dfsf(0);
			rh = new RollingHash61(31, s.length);
			dfsb(0);

			boolean[] ans = new boolean[parent.length];
			for(int i = 0;i < parent.length;i++){
				ans[i] = hf[i] == hb[i];
			}
			return ans;
		}

		void dfsf(int cur)
		{
			int pos = rh.hp;
			for(int c : ch[cur]){
				dfsf(c);
			}
			rh.add(s[cur]);
			hf[cur] = rh.h(pos, rh.hp);
		}

		void dfsb(int cur)
		{
			int pos = rh.hp;
			rh.add(s[cur]);
			for(int i = ch[cur].length-1;i >= 0;i--){
				int c = ch[cur][i];
				dfsb(c);
			}
			hb[cur] = rh.h(pos, rh.hp);
		}

		public static class RollingHash61
		{
			static final long mod = (1L<<61)-1;
			public long M;
			public long[] pows;
			public long[] hs;
			public int hp;

			public RollingHash61(long M, int n) {
				assert M > 0;
				assert n > 0;
				this.M = M;
				this.pows = makePows(M, n);
				this.hs = new long[n+1];
				this.hp = 0;
			}

			public static long mul(long a, long b)
			{
				long al = a&(1L<<31)-1, ah = a>>>31;
				long bl = b&(1L<<31)-1, bh = b>>>31;
				long low = al * bl; // <2^62
				long mid = al * bh + bl * ah; // < 2^62
				long high = ah * bh + (mid>>>31); // < 2^60 + 2^31 < 2^61
				// high*2^62 = high*2 (mod 2^61-1)
				long ret = mod(mod(2*high + low) + ((mid&(1L<<31)-1)<<31));
				return ret;
			}

			public static long mod(long a)
			{
				while(a >= mod)a -= mod;
				while(a < 0)a += mod;
				return a;
			}

			private static long[] makePows(long M, int n)
			{
				long[] ret = new long[n+1];
				ret[0] = 1;
				for(int i = 1;i <= n;i++)ret[i] = mul(ret[i-1], M);
				return ret;
			}

			public void add(long x)
			{
				hs[hp+1] = mul(hs[hp], M) + x;
				if(hs[hp+1] >= mod)hs[hp+1] -= mod;
				hp++;
			}

			public long h(int l, int r)
			{
				assert l <= r;
				return mod(hs[r] - mul(hs[l], pows[r-l]));
			}
		}

		public static int[][] parentToChildren(int[] par)
		{
			int n = par.length;
			int[] ct = new int[n];
			for(int v : par){
				if(v >= 0)ct[v]++;
			}
			int[][] g = new int[n][];
			for(int i = 0;i < n;i++){
				g[i] = new int[ct[i]];
			}
			for(int i = 0;i < n;i++){
				if(par[i] >= 0){
					g[par[i]][--ct[par[i]]] = i;
				}
			}

			return g;
		}


	}
",1427857284
uwi,uwi,26,3607,java,"	class Solution {
		static int[] lpf = enumLowestPrimeFactors(1000000);

		public int minOperations(int[] nums) {
			int dp0 = 0, dp1 = 1;
			for(int i = 1;i < nums.length;i++){
				int v0 = nums[i], v1 = lpf[nums[i]];
				int pv0 = nums[i-1], pv1 = lpf[nums[i-1]];
				int ndp0 = Integer.MAX_VALUE / 2;
				int ndp1 = Integer.MAX_VALUE / 2;
				if(pv0 <= v0){
					ndp0 = Math.min(ndp0, dp0);
				}
				if(v0 != v1 && pv0 <= v1){
					ndp1 = Math.min(ndp1, dp0 + 1);
				}
				if(pv0 != pv1 && pv1 <= v0){
					ndp0 = Math.min(ndp0, dp1);
				}
				if(pv0 != pv1 && v0 != v1 && pv1 <= v1){
					ndp1 = Math.min(ndp1, dp1 + 1);
				}
				dp0 = ndp0;
				dp1 = ndp1;
			}
			if(dp0 >= 999999)return -1;
			return Math.min(dp0, dp1);
		}

		public static int[] enumLowestPrimeFactors(int n)
		{
			int tot = 0;
			int[] lpf = new int[n+1];
			int u = n+32;
			double lu = Math.log(u);
			int[] primes = new int[(int)(u/lu+u/lu/lu*1.5)];
			for(int i = 2;i <= n;i++)lpf[i] = i;
			for(int p = 2;p <= n;p++){
				if(lpf[p] == p)primes[tot++] = p;
				int tmp;
				for(int i = 0;i < tot && primes[i] <= lpf[p] && (tmp = primes[i]*p) <= n;i++){
					lpf[tmp] = primes[i];
				}
			}
			return lpf;
		}

	}
",1427836534
physics0523,physics0523,28,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res=0;
        int l=s.size();
        for(int i=0;i<l;i++){
            int h=0;
            vector<int> bk(26,0);
            for(int j=i;j<l;j++){
                bk[s[j]-'a']++;
                if(bk[s[j]-'a']==k){h++;}
                // cout << i << "" "" << j << "" "" << h << ""\n"";
                if(h){res++;}
            }
        }
        return res;
    }
};",1427827245
physics0523,physics0523,28,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> sq;
        string cur="""";
        for(int i=0;i<target.size();i++){
            cur.push_back('a');
            sq.push_back(cur);
            while(target[i]!=cur[i]){
                if(cur[i]=='z'){cur[i]='a';}
                else{cur[i]++;}
                sq.push_back(cur);
            }
        }
        return sq;
    }
};",1427824331
physics0523,physics0523,28,3603,cpp,"//manacher algorithm
//http://snuke.hatenablog.com/entry/2014/12/02/235837

//longest palindrome(length:odd)
//if you want to find the answer for even palindrome,
//you can use dummy letter.
//ex. $a$b$c$c$b$a$
vector<int> manacher(string &s){
  int i,j,k,l;
  l=s.size();
  vector<int> arr(l);
  i=0;j=0;
  while(i<l){
    while((i-j)>=0 && (i+j)<l){
      if(s[i-j]!=s[i+j]){break;}
      j++;
    }
    arr[i]=j;
    k=1;
    while((i-k)>=0 && (i+k)<l){
      if(k+arr[i-k]>=arr[i]){break;}
      arr[i+k]=arr[i-k];
      k++;
    }
    j=arr[i]-k;
    i+=k;
  }
  return arr;
}

vector<int> pal_build(string s){
  string ms=""$"";
  for(auto &nx : s){
    ms.push_back(nx);
    ms.push_back('$');
  }
  return manacher(ms);
}

// 0-indexed ask [l,r]
bool pal_ask(int l,int r,vector<int> &pal_dat){
  int len=r-l+1;
  int cent=l+r+1;
  return (pal_dat[cent]>=len);
}

using Graph=vector<vector<int>>;

int cc;
void dfs(int v,vector<int> &l,vector<int> &r,Graph &g){
    l[v]=cc;
    for(auto &nx : g[v]){
        dfs(nx,l,r,g);
    }
    r[v]=cc;
    cc++;
}

class Solution{
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        Graph g(n);
        for(int i=1;i<n;i++){
            g[parent[i]].push_back(i);
        }
        cc=0;
        vector<int> l(n),r(n);
        dfs(0,l,r,g);
        string t;
        for(int i=0;i<n;i++){
            t.push_back('.');
        }
        for(int i=0;i<n;i++){
            t[r[i]]=s[i];
        }
        auto pd=pal_build(t);
        vector<bool> res;
        for(int i=0;i<n;i++){
            res.push_back(pal_ask(l[i],r[i],pd));
        }
        return res;
    }
};",1427858042
physics0523,physics0523,28,3607,cpp,"int MXM=1000005;
vector<int> mv;

class Solution {
public:
    int minOperations(vector<int>& nums){
        if(mv.empty()){
            mv.resize(MXM);
            for(auto &nx : mv){nx=1e9;}
            for(int i=2;i<MXM;i++){
                if(mv[i]>5e8){
                    for(int j=2*i;j<MXM;j+=i){
                        mv[j]=min(i,mv[j]);
                    }
                }
            }
        }
        // for(int i=0;i<10;i++){cout << mv[i] << ""\n"";}
        int n=nums.size();
        int d0=0,d1;
        if(mv[nums[0]]>5e8){d1=1e9;}
        else{d1=1;}
        for(int i=1;i<n;i++){
            int nd0=1e9;
            int nd1=1e9;
            if(nums[i-1]<=nums[i]){nd0=min(nd0,d0);}
            if(nums[i-1]<=mv[nums[i]] && mv[nums[i]]<5e8){nd1=min(nd1,d0+1);}
            if(mv[nums[i-1]]<=nums[i]){nd0=min(nd0,d1);}
            if(mv[nums[i-1]]<=mv[nums[i]] && mv[nums[i]]<5e8){nd1=min(nd1,d1+1);}
            d0=nd0;
            d1=nd1;
        }
        int oup=min(d0,d1);
        if(oup>5e8){oup=-1;}
        return oup;
    }
};",1427845204
Ma Lin,Ma_Lin,29,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int K) {
        int i, j, c, n = s.size(), l, r, q, res = 0;
        vector<int> f[26];
        for (i = 0; i < n; ++i){
            c = s[i] - 'a';
            f[c].push_back(i);
        }
        
        for (i = 0; i < n; ++i){
            q = n;
            for (j = 0; j < 26; ++j){
                l = lower_bound(f[j].begin(), f[j].end(), i) - f[j].begin();
                if (l + K - 1 < f[j].size()) q = min(q, f[j][l + K - 1]);
            }
            
            if (q < n) res += n - q;
        }
        
        return res;
    }
};",1427827148
Ma Lin,Ma_Lin,29,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        int i, j, n = s.size();
        string t;
        vector<string> res;
        for (i = 0; i < n; ++i){
            t.push_back('a');
            res.push_back(t);
            while (t[i] != s[i]){
                t[i]++;
                res.push_back(t);
            }
        }
        
        return res;
    }
};",1427824119
Ma Lin,Ma_Lin,29,3603,cpp,"class Solution {
public:
    int seed = 500002961, mo = 1000000007;
    vector<int> g[100005];
    int f[100005], f2[100005], ge[100005], yh[100005], n;
    string s;
    
    void dfs(int p, bool zheng){
        int i, j;
        if (g[p].size() == 0){
            f[p] = s[p] - 'a' + 1;
            ge[p] = 1;
            return;
        }
        
        ge[p] = 0;
        f[p] = 0;
        if (!zheng){
            for (i = 0; i < g[p].size(); ++i){
                j = g[p][i];
                dfs(j, zheng);
                f[p] = (f[p] + 1LL * f[j] * yh[ge[p]]) % mo;
                ge[p] += ge[j];
            }
            
            f[p] = (f[p] + 1LL * (s[p] - 'a' + 1) * yh[ge[p]]) % mo;
            ++ge[p];
        }
        else{
            f[p] = s[p] - 'a' + 1;
            ge[p] = 1;
            for (i = g[p].size() -1; i >= 0; --i){
                j = g[p][i];
                dfs(j, zheng);
                f[p] = (f[p] + 1LL * f[j] * yh[ge[p]]) % mo;
                ge[p] += ge[j];
            }
        }
        
    }
    
    vector<bool> findAnswer(vector<int>& par, string ss) {
        int i, j;
        n = par.size();
        s = ss;
        for (i = 0; i < n; ++i) g[i].clear();
        for (i = 0; i < n; ++i) 
            if (par[i] != -1)
                g[par[i]].push_back(i);
        
        yh[0] = 1;
        for (i = 1; i <= n; ++i) yh[i] = (1LL * seed * yh[i - 1]) % mo;
        dfs(0, true);
        for (i = 0; i < n; ++i) f2[i] = f[i];
        dfs(0, false);
        vector<bool> res;
        for (i = 0; i < n; ++i)
            res.push_back(f[i] == f2[i]);
        return res;
    }
};",1427858496
Ma Lin,Ma_Lin,29,3607,cpp,"int f[1000006];
bool yes = false;
class Solution {
public:
    void calc_f(){
        int i, j;
        for (i = 1; i <= 1000000; ++i) f[i] = 1;
        for (i = 2; i <= 1000000; ++i)
            for (j = i + i; j <= 1000000; j += i)
                f[j] = i;
    }    
    
    int minOperations(vector<int>& a) {
        int res = 0, i, j;
        if (!yes){
            calc_f();
            yes = true;
        }
        
        for (i = a.size() - 2; i >= 0; --i){
            while (a[i] > a[i + 1]){
                if (f[a[i]] == 1) break;
                a[i] /= f[a[i]];
                ++res;
            }
            
            if (a[i] > a[i + 1]) return -1;
        }
        
        return res;
    }
};",1427834882
Anas Maged,Anas_Maged,31,3502,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = sz(s);
        vector<vector<int>> pre(n, vector<int>(26));
        for(int i = 0; i < sz(s); i++){
            if(i) pre[i] = pre[i - 1];
            pre[i][s[i] - 'a']++;
        }

        auto val = [&](int l, int r) -> bool{
            for(int i = 0; i < 26; i++){
                int cnt = pre[r][i] - (l == 0 ? 0 : pre[l - 1][i]);
                if(cnt >= k) return 1;
            }
            return 0;
        };

        for(int i = 0; i < sz(s); i++){
            int start = 0, end = sz(s) - 1, mid, res = -1;
            while(start <= end){
                mid = (start + end) / 2;
                if(val(i, mid)){
                    res = mid;
                    end = mid - 1;
                }
                else{
                    start = mid + 1;
                }
            }
            if(res == -1) break;
            ans += n - res;
        }
        return ans;
    }
};",1427828670
Anas Maged,Anas_Maged,31,3566,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur;
        for(char c : target){
            cur += 'a';
            ans.push_back(cur);
            while(cur.back() != c){
                cur.back()++;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824959
Anas Maged,Anas_Maged,31,3603,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()


const int N = 1e5 + 5, MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;
int pw1[N], inv1[N], pw2[N], inv2[N], BASE;

bool isPrime(int x) {
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) return 0;
    }
    return x > 1;
}

int fix(ll x, int M) {
    return (x % M + M) % M;
}

int fpow(int a, int b, int mod) {
    if (!b) return 1;
    int ret = fpow(a, b >> 1, mod);
    ret = fix(1ll * ret * ret, mod);
    if (b & 1) ret = fix(1ll * ret * a, mod);
    return ret;
}

void init() {
    static bool done = false;
    if (done) return;
    done = true;
    
    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<int> dist(257, 10007);
    do{
        BASE = dist(rng);
    }while (!isPrime(BASE));

    pw1[0] = inv1[0] = pw2[0] = inv2[0] = 1;
    int iv1 = fpow(BASE, MOD1 - 2, MOD1);
    int iv2 = fpow(BASE, MOD2 - 2, MOD2);
    for (int i = 1; i < N; ++i) {
        pw1[i] = fix(1ll * pw1[i - 1] * BASE, MOD1);
        pw2[i] = fix(1ll * pw2[i - 1] * BASE, MOD2);
        inv1[i] = fix(1ll * inv1[i - 1] * iv1, MOD1);
        inv2[i] = fix(1ll * inv2[i - 1] * iv2, MOD2);
    }
}

struct Hash {
    pair<int, int> H = {0, 0};
    int curSize = 0;
    void addChar(char c){
        H.first = fix(1ll * pw1[curSize] * c + H.first, MOD1);
        H.second = fix(1ll * pw2[curSize] * c + H.second, MOD2);
        curSize++;
    }
    void merge(pair<int, int> H2, int temp){
        H.first = fix(1ll * pw1[curSize] * H2.first + H.first, MOD1);
        H.second = fix(1ll * pw2[curSize] * H2.second + H.second, MOD2);
        curSize += temp;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        init();
        int n = sz(p);
        vector<vector<int>> adj(n);
        vector<bool> ans(n, 0);
        for(int i = 0; i < sz(p); i++){
            if(p[i] == -1) continue;
            adj[p[i]].push_back(i);
            adj[i].push_back(p[i]);
        }
        vector<int> cnt(n);
        auto dfs = [&](auto& self, int u, int p) -> pair<pair<int, int>, pair<int, int>>{
            cnt[u] = 1;
            sort(all(adj[u]), greater<int>());
            Hash H1, H2;
            H1.addChar(s[u]);
            vector<tuple<int, int, int>> a;
            for(int v : adj[u]){
                if(v == p) continue;
                auto temp = self(self, v, u);
                cnt[u] += cnt[v];
                H1.merge(temp.first, cnt[v]);
                a.push_back({temp.second.first, temp.second.second, cnt[v]});
            }
            reverse(all(a));
            for(auto& [i, j, k] : a){
                H2.merge({i, j}, k);
            }
            H2.addChar(s[u]);
            ans[u] = (H1.H == H2.H);
            return {H1.H, H2.H};
        };
        dfs(dfs, 0, -1);
        return ans;
    }
};",1427867017
Anas Maged,Anas_Maged,31,3607,cpp,"#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
#define sz(s) (int)(s).size()
#define all(s) s.begin(),s.end()

const int N = 1e6 + 5;
int g[N];
void pre(){
    static bool done = false;
    if(done) return;
    done = true;
    for(int i = 1; i < N; i++){
        for(int j = i + i; j < N; j += i){
            g[j] = i;
        }
    }
    g[1] = 1;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        reverse(all(nums));
        pre();
        int last = 1e9;
        int ans = 0, cnt = 0;
        for(int x : nums){
            while(x > last){
                int y = x / g[x];
                if(x == y) return -1;
                ans++;
                x = y;
            }
            last = x;
        }
        return ans;
    }
};",1427838425
rithwikgupta,rithwikgupta,32,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> freq(26);
        multiset<int> fr;
        for (int i = 0; i < 26; i++ ) fr.insert(0);
        int l = 0;
        int r = 0;
        int res = 0;
        int n = s.size();
        while (l != n) {
            while (-(*fr.begin()) < k && r != n) {
                fr.erase(-freq[s[r]-'a']);
                freq[s[r]-'a']++;
                fr.insert(-freq[s[r]-'a']);
                r++;
            }
            if (-(*fr.begin()) >= k) res += n-r+1;
            fr.erase(-freq[s[l]-'a']);
            freq[s[l]-'a']--;
            fr.insert(-freq[s[l]-'a']);
            l++;
        }
        return res;
    }
};",1427856443
rithwikgupta,rithwikgupta,32,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string t;
        vector<string> res;
        for (int i = 0; i < target.size(); i++) {
            char cur = 'a';
            res.push_back(t + cur);
            while (cur != target[i]) {
                cur ++;
                res.push_back(t + cur);
            }
            t += cur;

        }
        return res;
    }
};",1427859188
rithwikgupta,rithwikgupta,32,3603,cpp,"#define ll long long

class Solution {
public:
vector<vector<ll> > adj;
    string s;
    vector<ll> tin;
    vector<ll> tout;
    
    string ass;
    ll B = 9911;
    ll MOD = 1e9 + 7;
    ll timer=0;
    void dfs(ll cur) {
        // cout << cur << endl;
        tin[cur]=timer;
        string here;
        // cout << cur << endl;
        for (auto val: adj[cur]) {
            // cout << val << endl;
            dfs(val);
        }
        tout[cur]=timer++;
        s += ass[cur];
    }
    vector<bool> findAnswer(vector<int>& parent, string as) {
        ll n = parent.size();
        adj.clear();
        tin.clear();
        tout.clear();
        adj.resize(n);
        tout.resize(n);
        tin.resize(n);
        vector<ll> pref(n), suff(n);
        vector<ll> power(n);
        timer=0;
        ass = as;
        power[0] = 1;
        for (ll i = 1; i < n; i++) {
            power[i] = power[i-1] * B % MOD;
            adj[parent[i]].push_back(i);
        }
        dfs(0);

        for (ll i = 0; i < n; i++) {
            // cout << i << endl;
            if (i) pref[i] = pref[i-1];
            pref[i] = (pref[i]*B + (s[i] - 'a')) % MOD;
        }

        for (ll i = n-1; i >= 0; i--) {
            if (i != n-1) suff[i] = suff[i+1];
            suff[i] = (suff[i]*B + (s[i] - 'a')) % MOD;
        }

        vector<bool> res(n);
        for (ll i = 0; i < n; i++) {
            // cout << i << endl;
            ll s1 = (suff[tin[i]] - suff[tout[i]] * power[tout[i] - tin[i]] % MOD + MOD) % MOD;
            ll p1 = (pref[tout[i]] - pref[tin[i]] * power[tout[i] - tin[i]] % MOD + MOD) % MOD;
            res[i] = (p1 == s1);
        }
        return res;


    }
};",1427846929
rithwikgupta,rithwikgupta,32,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int res= 0;
        for (int i = nums.size()-2; i >= 0; i--) {
            while (nums[i] > nums[i+1]) {
                int g = 1;
                for (int j = 2; j * j <= nums[i]; j++) {
                    if (nums[i] % j == 0) {
                        g = nums[i]/j;
                        break;
                    }
                }
                if (g == 1) return -1;
                else {
                    nums[i] /= g;
                    res++;
                }
            }
        }
        return res;
    }
};",1427851087
haohao,cchao,33,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = s.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int cnt[128] = {}, mx = 0;
            for (int j = i; j < n; ++j) {
                mx = max(mx, ++cnt[s[j]]);
                ans += mx >= k;
            }
        }
        return ans;
    }
};",1427828383
haohao,cchao,33,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string tmp = """";
        vector<string> ans;
        for (char c : target) {
            for (char i = 'a'; i <= c; ++i) {
                ans.push_back(tmp + i);
            }
            tmp += c;
        }
        return ans;
    }
};",1427824685
haohao,cchao,33,3603,cpp,"
void manacher(int n, const char *s, int *p) {
  for (int i = 0, j = 0, k = 0; i <= 2 * (n - 1); ++i) {
    int l = i < k && j + j - i >= 0 ? min(p[j + j - i], (k - i) / 2) : 0;
    int a = i / 2 - l, b = (i + 1) / 2 + l;
    while (0 <= a && b < n && s[a] == s[b]) {
      --a;
      ++b;
      ++l;
    }
    p[i] = l;
    if (k < 2 * b) {
      j = i;
      k = 2 * b;
    }
  }
}
bool isPalindrome(int *p, int l, int r) {
  int len = r - l + 1;
  l = l * 2;
  r = r * 2;
  return p[(l + r) / 2] >= (len + 1) / 2;
}

class Solution {
  vector<vector<int>> g;
  int n;
  string s;
  string t;
  vector<int> in, out;
  int timer = 0;
  void dfs(int x) {
    in[x] = timer;
    for (int y : g[x]) {
        dfs(y);
    }
    t += s[x];
    out[x] = timer++;
  }

 public:
  vector<bool> findAnswer(vector<int> &parent, string s) {
    n = parent.size();
    g.clear();
    g.resize(n);
    this->s = s;
    for (int i = 1; i < n; ++i) g[parent[i]].push_back(i);
    in = out = vector<int>(n + 1, 0);
    timer = 0;
    t = """";
    dfs(0);
    vector<int> p(2 * (n +1 ) + 10);
    manacher(t.size(), t.data(), p.data());
    vector<bool> ans(n);
    for (int i = 0; i < n; ++i) {
      ans[i] = isPalindrome(p.data(), in[i], out[i]);
    }
    return ans;
  }
};",1427867373
haohao,cchao,33,3607,cpp,"bool init = false;
const int maxn = 1e6 + 10;
int d[maxn] = {};
void f() {
    for (int i = 1; i < maxn; ++i) {
        for (int j = i * 2; j < maxn; j += i) {
            d[j] = i;
        }
    }
    init = true;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
          if (!init) f();
          const int n = nums.size();
          int ans = 0;
          for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1] && d[nums[i]] > 1) {
                nums[i] /= d[nums[i]];
                ++ans;
            }
            if (nums[i] > nums[i+1]) return -1;
          }
          return ans;
    }
};",1427836680
hank55663,hank55663,34,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i = 0;i<s.size();i++){
            int cnt[26];
            fill(cnt,cnt+26,0);
            int ok=0;
            for(int j = i;j<s.size();j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a']==k)ok=1;
                ans+=ok;
            }
        }
        return ans;
    }
};",1427824727
hank55663,hank55663,34,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string now;
        for(auto it:target){
            for(char i = 'a';i<=it;i++){
                ans.push_back(now+i);
            }
            now+=it;//+"""";
        }
        return ans;
    }
};",1427823974
hank55663,hank55663,34,3603,cpp,"
vector<int> v[100005];
const int mod[2]={698693077,230484029};
long long base[2][100005];
int Size[100005];
#define pll pair<long long,long long>
#define mp make_pair
#define x first
#define y second
#define LL long long
class Solution {
public:
    vector<bool> aans;
    string ss;
    pair<pll,pll> dfs(int x){
        Size[x]=1;
        vector<pair<pll,pll> > ans;
        for(auto it:v[x]){
            ans.push_back(dfs(it));
            Size[x]+=Size[it];
        }
        long long a[2]={0,0},b[2]={ss[x]-'a'+1,ss[x]-'a'+1};
        int idx=0;
        for(auto it:ans){
            a[0]=(a[0]*base[0][Size[v[x][idx]]]+it.x.x)%mod[0];
            a[1]=(a[1]*base[1][Size[v[x][idx]]]+it.x.y)%mod[1];
            idx++;
        }
        a[0]=(a[0]*27+ss[x]-'a'+1)%mod[0];
        a[1]=(a[1]*27+ss[x]-'a'+1)%mod[1];
        reverse(ans.begin(),ans.end());
        reverse(v[x].begin(),v[x].end());
        idx=0;
        for(auto it:ans){
            b[0]=(b[0]*base[0][Size[v[x][idx]]]+it.y.x)%mod[0];
            b[1]=(b[1]*base[1][Size[v[x][idx]]]+it.y.y)%mod[1];
            idx++;
        }
        aans[x]=(a[0]==b[0]&&a[1]==b[1]);
    //    printf(""%d %d %d %d %d\n"",x,a[0],a[1],b[0],b[1]);
        return mp(mp(a[0],a[1]),mp(b[0],b[1]));
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ss=s;
        for(int t=0;t<2;t++){
            base[t][0]=1;
            for(int j = 1;j<100005;j++)base[t][j]=base[t][j-1]*27%mod[t];
        }
        for(int i = 0;i<parent.size();i++)v[i].clear();
        for(int i = 1;i<parent.size();i++){
            v[parent[i]].push_back(i);            
        }
        //dfs(0);
        aans.resize(parent.size());
        dfs(0);
        return aans;
    }
};",1427859727
hank55663,hank55663,34,3607,cpp,"
    int ans[1000005];
class Solution {
public:

    int minOperations(vector<int>& nums) {
        if(ans[1]==0){
        for(int i = 1;i<1000005;i++)ans[i]=i;
        for(int i = 2;i<1000005;i++){
            if(ans[i]==i){
                for(int j = i;j<1000005;j+=i){
                    if(ans[j]==j)ans[j]=i;
                }
            }
        }
        }
        int last[2]={1,1};
        int dp[2]={0,0};
        int Max=1000000000;
        for(auto it:nums){
            int dp2[2]={Max,Max};
            if(it>=last[0])dp2[0]=min(dp2[0],dp[0]);
            if(it>=last[1])dp2[0]=min(dp2[0],dp[1]);
            if(ans[it]>=last[0])dp2[1]=min(dp2[1],dp[0]+1);
            if(ans[it]>=last[1])dp2[1]=min(dp2[1],dp[1]+1);
            if(dp2[0]==Max&&dp2[1]==Max)return -1;
            last[0]=it;
            last[1]=ans[it];
          //  printf(""%d %d\n"",last[0],last[1]);
            dp[0]=dp2[0];
            dp[1]=dp2[1];
        }
        return min(dp[0],dp[1]);
    }
};",1427834611
LayCurse,LayCurse,35,3502,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  int numberOfSubstrings(string s, int K){
    int i;
    int N = s.size();
    int cnt[26];
    int res = 0;
    int mx;
    for(i=(0);i<(N);i++){
      int j, k;
      for(k=(0);k<(26);k++){
        cnt[k] = 0;
      }
      mx = 0;
      for(j=(i);j<(N);j++){
        cnt[s[j]-'a']++;
        chmax(mx, cnt[s[j]-'a']);
        if(mx >= K){
          res++;
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   int numberOfSubstrings(string s, int K) {
//     int N = s.size();
//     int cnt[26], res = 0, mx;
// 
//     rep(i,N){
//       rep(k,26) cnt[k] = 0;
//       mx = 0;
//       rep(j,i,N){
//         cnt[s[j]-'a']++;
//         mx >?= cnt[s[j]-'a'];
//         if(mx >= K) res++;
//       }
//     }
//     return res;
//   }
// };
",1427826891
LayCurse,LayCurse,35,3566,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  vector<string> stringSequence(string target){
    int i;
    string now;
    vector<string> res;
    now += 'a';
    res.push_back(now);
    while(now != target){
      i = now.size();
      if(now[i-1] == target[i-1]){
        now += 'a';
      }
      else{
        now[i-1]++;
      }
      res.push_back(now);
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   vector<string> stringSequence(string target) {
//     int i;
//     string now;
//     VS res;
//     now += 'a';
//     res.push_back(now);
//     while(now != target){
//       i = now.size();
//       if(now[i-1] == target[i-1]) now += 'a'; else now[i-1]++;
//       res.push_back(now);
//     }
//     return res;
//   }
// };
",1427824371
LayCurse,LayCurse,35,3603,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
struct Rand{
  unsigned x;
  unsigned y;
  unsigned z;
  unsigned w;
  Rand(void){
    x=123456789;
    y=362436069;
    z=521288629;
    w=(unsigned)time(NULL);
  }
  Rand(unsigned seed){
    x=123456789;
    y=362436069;
    z=521288629;
    w=seed;
  }
  inline unsigned get(void){
    unsigned t;
    t = (x^(x<<11));
    x=y;
    y=z;
    z=w;
    w = (w^(w>>19))^(t^(t>>8));
    return w;
  }
  inline double getUni(void){
    return get()/4294967296.0;
  }
  inline int get(int a){
    return (int)(a*getUni());
  }
  inline int get(int a, int b){
    return a+(int)((b-a+1)*getUni());
  }
  inline long long get(long long a){
    return(long long)(a*getUni());
  }
  inline long long get(long long a, long long b){
    return a+(long long)((b-a+1)*getUni());
  }
  inline double get(double a, double b){
    return a+(b-a)*getUni();
  }
  inline int getExp(int a){
    return(int)(exp(getUni()*log(a+1.0))-1.0);
  }
  inline int getExp(int a, int b){
    return a+(int)(exp(getUni()*log((b-a+1)+1.0))-1.0);
  }
}
;
template<class T, class U> inline T GCD_L(T a, U b){
  T r;
  while(b){
    r=a;
    a=b;
    b=r%a;
  }
  return a;
}
struct graph{
  int N;
  int*es;
  int**edge;
  void setEdge(int N__, int M, int A[], int B[], void **mem = &wmem){
    int i;
    N = N__;
    walloc1d(&es, N, mem);
    walloc1d(&edge, N, mem);
    for(i=(0);i<(N);i++){
      es[i] = 0;
    }
    for(i=(0);i<(M);i++){
      es[A[i]]++;
      es[B[i]]++;
    }
    for(i=(0);i<(N);i++){
      walloc1d(&edge[i], es[i], mem);
    }
    for(i=(0);i<(N);i++){
      es[i] = 0;
    }
    for(i=(0);i<(M);i++){
      edge[A[i]][es[A[i]]++] = B[i];
      edge[B[i]][es[B[i]]++] = A[i];
    }
  }
  int preorder(int res[], int root = 0, void *mem=wmem){
    int i;
    int j;
    int k;
    int sts;
    int sz = 0;
    long long*st;
    char*vis;
    walloc1d(&vis, N, &mem);
    walloc1d(&st, N, &mem);
    sts = 0;
    st[sts++] = ((long long)root) << 32;
    for(i=(0);i<(N);i++){
      vis[i] = 0;
    }
    vis[root] = 1;
    while(sts){
      i = st[--sts] >> 32;
      j = st[sts] & 2147483647;
      if(j==0){
        res[sz++] = i;
      }
      while(j < es[i]){
        k = edge[i][j++];
        if(vis[k]){
          continue;
        }
        if(j < es[i]){
          st[sts++] = (((long long)i) << 32) + j;
        }
        vis[k] = 1;
        st[sts++] = ((long long)k) << 32;
        break;
      }
    }
    return sz;
  }
}
;
#define ROLLING_HASH_MOD (2305843009213693951ULL)
#define ROLLING_HASH_PRIMITIVE_ROOT (3)
#define ROLLING_HASH_MAX_MEMORY (2000000)
int ROLLING_HASH_MEM;
unsigned long long ROLLING_HASH_BASE;
unsigned long long ROLLING_HASH_IBASE;
unsigned long long*ROLLING_HASH_PW = NULL;
unsigned long long*ROLLING_HASH_IPW = NULL;
inline unsigned long long rollingHash61_mul(unsigned long long a, unsigned long long b){
  __uint128_t r = (__uint128_t) a * b;
  a = (r >> 61) + (r & ROLLING_HASH_MOD);
  if(a >= ROLLING_HASH_MOD){
    a -= ROLLING_HASH_MOD;
  }
  return a;
}
inline unsigned long long rollingHash61_pow(unsigned long long a, unsigned long long b){
  unsigned long long r = 1;
  for(;;){
    if(b&1){
      r = rollingHash61_mul(r, a);
    }
    if(b==0){
      break;
    }
    b >>= 1;
    a = rollingHash61_mul(a, a);
  }
  return r;
}
void rollingHashInit(){
  int i;
  Rand rnd;
  unsigned long long x;
  for(i=(0);i<(20);i++){
    rnd.get(2);
  }
  do{
    x = rnd.get(1.0, (double)(ROLLING_HASH_MOD-2));
  }
  while(GCD_L(x, ROLLING_HASH_MOD-1)!= 1);
  ROLLING_HASH_BASE = rollingHash61_pow(ROLLING_HASH_PRIMITIVE_ROOT, x);
  ROLLING_HASH_IBASE = rollingHash61_pow(ROLLING_HASH_BASE, ROLLING_HASH_MOD - 2);
}
void rollingHash_expand(int k){
  int i;
  if(ROLLING_HASH_MEM >= k){
    return;
  }
  ROLLING_HASH_MEM =max_L(2 * ROLLING_HASH_MEM, k);
  assert(ROLLING_HASH_MEM <= 2 * ROLLING_HASH_MAX_MEMORY);
  ROLLING_HASH_PW = (unsigned long long*) realloc(ROLLING_HASH_PW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_IPW = (unsigned long long*) realloc(ROLLING_HASH_IPW, ROLLING_HASH_MEM * sizeof(unsigned long long));
  ROLLING_HASH_PW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_PW[i] = rollingHash61_mul(ROLLING_HASH_PW[i-1], ROLLING_HASH_BASE);
  }
  ROLLING_HASH_IPW[0] = 1;
  for(i=(1);i<(ROLLING_HASH_MEM);i++){
    ROLLING_HASH_IPW[i] = rollingHash61_mul(ROLLING_HASH_IPW[i-1], ROLLING_HASH_IBASE);
  }
}
struct rollingHash{
  long long len;
  unsigned long long hs;
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    hs = 0;
    len = N;
    rollingHash_expand(N);
    for(i=(0);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs += rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs >= ROLLING_HASH_MOD){
        hs -= ROLLING_HASH_MOD;
      }
    }
  }
  template<class S, class T> void change(long long ind, S bef, T aft){
    long long tmp1;
    long long tmp2;
    tmp1 = bef % ((long long)ROLLING_HASH_MOD);
    tmp2 = aft % ((long long)ROLLING_HASH_MOD);
    tmp1 = tmp2 - tmp1;
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 < 0){
      tmp1 += ROLLING_HASH_MOD;
    }
    if(tmp1 >= ROLLING_HASH_MOD){
      tmp1 -= ROLLING_HASH_MOD;
    }
    if(ind+1 <= ROLLING_HASH_MAX_MEMORY || ind+1 >= ROLLING_HASH_MEM){
      rollingHash_expand(ind+1);
      hs += rollingHash61_mul(tmp1, ROLLING_HASH_PW[ind]);
    }
    else{
      hs += rollingHash61_mul(tmp1, rollingHash61_pow(ROLLING_HASH_BASE, ind));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
  }
  void push_front(rollingHash a){
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_PW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_BASE, a.len));
    }
    hs += a.hs;
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void push_back(rollingHash a){
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      hs += rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      hs += rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= ROLLING_HASH_MOD){
      hs -= ROLLING_HASH_MOD;
    }
    len += a.len;
  }
  void pop_front(rollingHash a){
    if(hs >= a.hs){
      hs -= a.hs;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - a.hs;
    }
    if(a.len + 1 <= ROLLING_HASH_MAX_MEMORY || a.len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(a.len + 1);
      hs = rollingHash61_mul(hs, ROLLING_HASH_IPW[a.len]);
    }
    else{
      hs = rollingHash61_mul(hs, rollingHash61_pow(ROLLING_HASH_IBASE, a.len));
    }
    len -= a.len;
  }
  void pop_back(rollingHash a){
    unsigned long long tmp;
    if(len + 1 <= ROLLING_HASH_MAX_MEMORY || len + 1 >= ROLLING_HASH_MEM){
      rollingHash_expand(len + 1);
      tmp = rollingHash61_mul(a.hs, ROLLING_HASH_PW[len]);
    }
    else{
      tmp = rollingHash61_mul(a.hs, rollingHash61_pow(ROLLING_HASH_BASE, len));
    }
    if(hs >= tmp){
      hs -= tmp;
    }
    else{
      hs = hs + ROLLING_HASH_MOD - tmp;
    }
    len -= a.len;
  }
  bool operator==(const rollingHash a){
    return len == a.len && hs == a.hs;
  }
  bool operator!=(const rollingHash a){
    return len != a.len || hs != a.hs;
  }
}
;
template<class T> rollingHash calcRollingHash(int N, T A[]){
  rollingHash res;
  res.set(N, A);
  return res;
}
struct rollingHashSubarrays{
  unsigned long long*hs;
  int mem;
  int len;
  void set(){
    hs = NULL;
    mem = len = 0;
  }
  void free(){
    if(mem){
      delete[] hs;
    }
  }
  void expand(int k){
    if(mem >= k){
      return;
    }
    free();
    mem =max_L(2*mem, k);
    hs = new unsigned long long[mem];
  }
  template<class T> void set(int N, T A[]){
    int i;
    long long tmp;
    if(N <= 0){
      return;
    }
    rollingHash_expand(N);
    expand(N);
    len = N;
    tmp = A[0] % ((long long)ROLLING_HASH_MOD);
    if(tmp < 0){
      tmp += ROLLING_HASH_MOD;
    }
    hs[0] = tmp;
    for(i=(1);i<(N);i++){
      tmp = A[i] % ((long long)ROLLING_HASH_MOD);
      if(tmp < 0){
        tmp += ROLLING_HASH_MOD;
      }
      hs[i] = hs[i-1] + rollingHash61_mul(tmp, ROLLING_HASH_PW[i]);
      if(hs[i] >= ROLLING_HASH_MOD){
        hs[i] -= ROLLING_HASH_MOD;
      }
    }
  }
  rollingHash get_len(int s, int len){
    unsigned long long x;
    rollingHash res;
    res.len = len;
    rollingHash_expand(s+1);
    if(s == 0){
      res.hs = hs[len-1];
    }
    else{
      if(hs[s+len-1] >= hs[s-1]){
        res.hs = hs[s+len-1] - hs[s-1];
      }
      else{
        res.hs = hs[s+len-1] + ROLLING_HASH_MOD - hs[s-1];
      }
      res.hs = rollingHash61_mul(res.hs, ROLLING_HASH_IPW[s]);
    }
    return res;
  }
  rollingHash get(int a, int b){
    return get_len(a, b - a + 1);
  }
  rollingHashSubarrays(){
    set();
  }
  ~rollingHashSubarrays(){
    free();
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  {
    rollingHashInit();
  }
  return 0;
}
#undef main
int a[1000000];
rollingHash arr1[1000000];
rollingHash arr2[1000000];
rollingHash one[1000000];
graph g;
int M;
int A[1000000];
int B[1000000];
int pre[1000000];
class Solution{
  public:
  vector<bool> findAnswer(vector<int>& p, string s){
    int OA9NF42T;
    dummy_main();
    int i;
    int k;
    int N = p.size();
    vector<bool> res(N);
    M = N-1;
    for(i=(1);i<(N);i++){
      A[i-1] = p[i];
      B[i-1] = i;
    }
    g.setEdge(N,M,A,B);
    g.preorder(pre);
    for(i=(0);i<(N);i++){
      a[i] = s[i];
    }
    for(i=(0);i<(N);i++){
      arr1[i] = arr2[i] = calcRollingHash(0, a);
    }
    for(i=(0);i<(N);i++){
      one[i] = calcRollingHash(1, a+i);
    }
    for(OA9NF42T=(N)-1;OA9NF42T>=(0);OA9NF42T--){
      auto&i = pre[OA9NF42T];
      arr1[i].push_back(one[i]);
      arr2[i].push_front(one[i]);
      k = p[i];
      if(k >= 0){
        arr1[k].push_front(arr1[i]);
        arr2[k].push_back(arr2[i]);
      }
      res[i] = (arr1[i] == arr2[i]);
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// int a[1d6];
// rollingHash arr1[1d6], arr2[1d6], one[1d6];
// 
// graph g;
// int M, A[1d6], B[1d6], pre[1d6];
// 
// class Solution {
// public:
//   vector<bool> findAnswer(vector<int>& p, string s) {
//     dummy_main();
//     int i, k;
//     int N = p.size();
//     vector<bool> res(N);
// 
//     M = N-1;
//     rep(i,1,N) A[i-1] = p[i], B[i-1] = i;
//     g.setEdge(N,M,A,B);
//     g.preorder(pre);
// 
//     rep(i,N) a[i] = s[i];
//     rep(i,N) arr1[i] = arr2[i] = calcRollingHash(0, a);
//     rep(i,N) one[i] = calcRollingHash(1, a+i);
// 
//     rrep[pre](i,N){
//       arr1[i].push_back(one[i]);
//       arr2[i].push_front(one[i]);
//       k = p[i];
//       if(k >= 0){
//         arr1[k].push_front(arr1[i]);
//         arr2[k].push_back(arr2[i]);
//       }
//       res[i] = (arr1[i] == arr2[i]);
//     }
// 
//     return res;
//   }
// };
",1427852708
LayCurse,LayCurse,35,3607,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
int fg = 0;
int go[1000000+1];
class Solution{
  public:
  int minOperations(vector<int>& A){
    int i;
    int N = A.size();
    int res = 0;
    if(!fg){
      int i;
      fg = 1;
      for(i=(0);i<(1000000+1);i++){
        go[i] = -1;
      }
      for(i=(2);i<(1000000+1);i++){
        int j;
        for(j=(2*i);j<(1000000+1);j+=(i)){
          if(go[j]==-1){
            go[j] = i;
          }
        }
      }
    }
    for(i=(N-1)-1;i>=(0);i--){
      if(A[i] > A[i+1]){
        res++;
        A[i] = go[A[i]];
        if(A[i]==-1 || A[i] > A[i+1]){
          return -1;
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// int fg = 0;
// int go[1d6+1];
// 
// class Solution {
// public:
//   int minOperations(vector<int>& A) {
//     int N = A.size();
//     int res = 0;
// 
//     if(!fg){
//       fg = 1;
//       rep(i,1d6+1) go[i] = -1;
//       rep(i,2,1d6+1) rep(j,2*i,1d6+1,i) if(go[j]==-1) go[j] = i;
//     }
// 
//     rrep(i,N-1){
//       if(A[i] > A[i+1]){
//         res++;
//         A[i] = go[A[i]];
//         if(A[i]==-1 || A[i] > A[i+1]) return -1;
//       }
//     }
// 
// 
//     return res;
//   }
// };
",1427833692
Agnibha Chakraborty,zanj0,38,3502,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	int numberOfSubstrings(string s, int k) {
		lli ret = 0;
		lli n = s.size();
		for (int i = 0; i < n; i++) {
			map<char, lli> cnt;
			lli max_freq = 0;
			for (lli j = i; j < n; j++) {
				cnt[s[j]]++;
				max_freq = max(max_freq, cnt[s[j]]);
				if (max_freq >= k) ret++;
			}
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1427826764
Agnibha Chakraborty,zanj0,38,3566,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	vector<string> stringSequence(string target) {
		int n = target.size();
		vector<string> ret;
		for (int i = 0; i < n; i++) {
			ret.pb(ret.empty() ? ""a"" : ret.back() + ""a"");
			while (ret.back().back() != target[i]) {
				string now = ret.back();
				if (now.back() == 'z') {
					now.back() = 'a';
				} else {
					now.back()++;
				}
				ret.pb(now);
			}
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1427825307
Agnibha Chakraborty,zanj0,38,3603,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;
vector<int> manacher_odd(string s) {
	int n = s.size();

	s = ""$"" + s + ""^"";
	vector<int> p(n + 2);
	int l = 1, r = 1;
	for (int i = 1; i <= n; i++) {
		p[i] = max(0, min(r - i, p[l + (r - i)]));
		while (s[i - p[i]] == s[i + p[i]]) {
			p[i]++;
		}
		if (i + p[i] > r) {
			l = i - p[i], r = i + p[i];
		}
	}
	return vector<int>(begin(p) + 1, end(p) - 1);
}
vector<int> manacher(string s) {
	string t;
	for (auto c : s) {
		t += string(""#"") + c;
	}
	auto res = manacher_odd(t + ""#"");
	return vector<int>(begin(res) + 1, end(res) - 1);
}

bool IsPalindrome(int l, int r, vector<int>& v) {
	return v[l + r] >= r - l + 1;
}
int now = -1;
void Dfs(int node, int par, vector<vector<int>>& graph, string& s, vector<int>& low, vector<int>& high, string& s2) {
	now++;
	low[node] = s.size();

	for (auto& it : graph[node]) {
		if (it == par) continue;
		Dfs(it, node, graph, s, low, high,  s2);
	}
	s += s2[node];
	high[node] = s.size() - 1;
}

class Solution {
public:
	void Out(vector<int>& v) {
		for (auto& it : v) {
			cout << it << "" "";
		}
		cout << endl;
	}
	vector<bool> findAnswer(vector<int>& parent, string s) {
		now = -1;
		vector<bool> ret;
		// string ss = ""abaaba"";
		// vector<int> m = manacher(ss);
		// cout << IsPalindrome(0, ss.size() - 1, m) << endl;
		// Out(m);
		int n = parent.size();
		vector<int> low(n), high(n);
		vector<vector<int>> graph(n);;

		for (int i = 0; i < n; i++) {
			if (parent[i ] != -1) {
				graph[i].pb(parent[i]);
				graph[parent[i]].pb(i);
			}
		}
		string curr = """";
		Dfs(0, -1, graph, curr, low, high, s);
		// cout << curr << endl;
		vector<int> m = manacher(curr);
		// Out(m);
		// for (int i = 0; i < n; i++) {
		// 	cout << low[i] << "" "" << high[i] << endl;
		// }
		for (int i = 0; i < n; i++) {
			ret.pb(IsPalindrome(low[i], high[i], m));
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
	vector<int> x = { -1, 0, 0, 1, 1, 2};
	Solution s;
	s.findAnswer(x, ""aababa"");
}
#endif",1427869494
Agnibha Chakraborty,zanj0,38,3607,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;

const lli N = 1e6 + 5;
lli fact[N];
bool done = false;
void Pre() {
	if (done) return;
	done = true;
	for (int i = 0; i < N; i++) fact[i] = i;
	for (int i = 2; i < N; i++) {
		for (int j = i + i; j < N; j += i)fact[j] = i;
	}

}
class Solution {
public:
	int minOperations(vector<int>& nums) {
		Pre();
		lli ret = 0;
		lli n = nums.size();
		for (int i = n - 2; i >= 0; i--) {
			while (nums[i] > nums[ i + 1]) {
				if (fact[nums[i]] == nums[i]) return -1;
				ret++;
				nums[i] /= fact[nums[i]];
			}
		}
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1427832039
garyjhu,garyjhu,39,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int[] freq = new int[26];
        int count = 0;
        int res = 0;
        for (int i = 0, j = 0; i < n; i++) {
            while (j < n && count == 0) {
                char c = s.charAt(j);
                freq[c - 'a']++;
                if (freq[c - 'a'] == k) count++;
                j++;
            }
            if (count > 0) res += n - j + 1;
            freq[s.charAt(i) - 'a']--;
            if (freq[s.charAt(i) - 'a'] == k - 1) count--;
        }
        return res;
    }
}
",1427830016
garyjhu,garyjhu,39,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        int n = target.length();
        for (int i = 0; i < n; i++) {
            for (char c = 'a'; c <= target.charAt(i); c++) {
                res.add(sb.toString() + c);
            }
            sb.append(target.charAt(i));
        }
        return res;
    }
}
",1427824869
garyjhu,garyjhu,39,3603,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    int n, t;
    int[] in, out;
    char[] ch;
    public boolean[] findAnswer(int[] parent, String s) {
        n = parent.length;
        ch = s.toCharArray();
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i].add(parent[i]);
            adj[parent[i]].add(i);
        }
        char[] list = new char[n];
        in = new int[n];
        out = new int[n];
        dfs(adj, 0, -1, list);
        int[] man = ManachersAlgorithm.manachers(list);
        boolean[] res = new boolean[n];
        for (int i = 0; i < n; i++) {
            int start = in[i], end = out[i];
            int mid = (2 * start + 2 * end) / 2 + 2;
            res[i] = man[mid] >= end - start;
        }
        return res;
    }

    private void dfs(List<Integer>[] adj, int v, int parent, char[] list) {
        in[v] = t;
        for (int w : adj[v]) {
            if (w == parent) continue;
            dfs(adj, w, v, list);
        }
        out[v] = t;
        list[t++] = ch[v];
    }

    public static class ManachersAlgorithm {

        public static int[] manachers(char[] str) {
            char[] arr = preProcess(str);
            int n = arr.length, c = 0, r = 0;
            int[] p = new int[n];
            for (int i = 1; i < n - 1; i++) {
                int invI = 2 * c - i;
                p[i] = r > i ? Math.min(r - i, p[invI]) : 0;
                while (arr[i + 1 + p[i]] == arr[i - 1 - p[i]]) p[i]++;
                if (i + p[i] > r) {
                    c = i;
                    r = i + p[i];
                }
            }
            return p;
        }

        private static char[] preProcess(char[] str) {
            char[] arr = new char[str.length * 2 + 3];
            arr[0] = '^';
            for (int i = 0; i < str.length; i++) {
                arr[i * 2 + 1] = '#';
                arr[i * 2 + 2] = str[i];
            }
            arr[arr.length - 2] = '#';
            arr[arr.length - 1] = '$';
            return arr;
        }
    }
}
",1427869773
garyjhu,garyjhu,39,3607,java,"class Solution {
    static int N = 1_000_000;
    static int[] spf;
    public int minOperations(int[] nums) {
        if (spf == null) init();
        int n = nums.length;
        int res = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                nums[i] = spf[nums[i]];
                res++;
            }
            if (nums[i] > nums[i + 1]) return -1;
        }
        return res;
    }

    private static void init() {
        spf = new int[N + 1];
        for (int i = 2; i <= N; i++) {
            if (spf[i] == 0) {
                for (int j = i; j <= N; j += i) {
                    if (spf[j] == 0) spf[j] = i;
                }
            }
        }
        spf[1] = 1;
    }
}
",1427843476
delphih,delphih,40,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        cntc, cntf = Counter(), 0
        q = 0
        res = 0
        for p in range(n):
            while q < n and cntf < 1:
                cntc[s[q]] += 1
                if cntc[s[q]] == k: cntf += 1
                q += 1
            if cntf > 0: res += n - q + 1
            cntc[s[p]] -= 1
            if cntc[s[p]] == k - 1: cntf -= 1
        return res",1427833027
delphih,delphih,40,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = ''
        for c in target:
            for i in ascii_lowercase:
                res.append(cur + i)
                if i == c: break
            cur += c
        return res",1427825611
delphih,delphih,40,3603,python3,"def m(s: str) -> str:
    s2 = '#' + '#'.join(s) + '#'
    ln2 = len(s2)
    d = [1] * ln2
    pre = 0
    for i in range(1, ln2 - 1):
        if pre + d[pre] > i:
            d[i] = min(pre + d[pre] - i, d[pre-(i-pre)])
        while 0 <= i-d[i] and i+d[i] < ln2 and s2[i-d[i]] == s2[i+d[i]]:
            d[i] += 1
        if i + d[i] > pre + d[pre]: pre = i
    d = [x-1 for x in d]
    return d
    mxi = max(range(ln2), key=d.__getitem__)
    return s[(mxi-d[mxi])//2:(mxi+d[mxi])//2]

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i, pa in enumerate(parent):
            if pa != -1: g[pa].append(i)
        lrs = [None] * n
        sb = []
        def dfs(p):
            pos0 = len(sb)
            for ch in g[p]:
                dfs(ch)
            sb.append(s[p])
            lrs[p] = [pos0, len(sb)]
        dfs(0)
        # print(''.join(sb))
        # print(lrs)
        # print(list('#' + '#'.join(sb) + '#'))
        d = m(sb)
        # print(d)
        res = []
        for l, r in lrs:
            res.append(d[l+r] >= r - l)
        return res",1427869802
delphih,delphih,40,3607,python3,"P = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def f(x):
            for p in P:
                if p * p > x: break
                if x % p == 0: return p
            return x
        res = 0
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] > nums[i+1]:
                nums[i] = f(nums[i])
                if nums[i] > nums[i+1]: return -1
                res += 1
        return res",1427840426
IphoneX,hahahiehie,43,3502,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static class StringCountPreSum {
        int[][] preCount;

        public StringCountPreSum(String s) {
            int n = s.length();
            preCount = new int[n + 1][26];
            for (int i = 0; i < n; i++) {
                for (int c = 0; c < 26; c++) preCount[i + 1][c] = preCount[i][c];
                preCount[i + 1][s.charAt(i) - 'a']++;
            }
        }

        // [l, r] inclusive, 0 <= l, r <= n - 1
        public boolean querySubstring(int l, int r, int k) {
            // if (l > r) TODO: Add error handling if needed
            for (int c = 0; c < 26; c++) {
                int count = preCount[r + 1][c] - preCount[l][c];
                if (count >= k) return true; // TODO: Add check condition
            }
            return false;
        }
    }
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        
        StringCountPreSum sum = new StringCountPreSum(s);
        
        int ans =0 ;
        for (int i = 0; i < n; i++) {
            for (int j = i + k - 1; j < n; j++) {
                if (sum.querySubstring(i, j, k)) {
                    ans++;
                }
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427829313
IphoneX,hahahiehie,43,3566,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    public List<String> stringSequence(String target) {
        int n = target.length();
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append('a');
            int c = target.charAt(i) - 'a';
            for (int j = 0; j <= c; j++) {
                sb.setCharAt(i, (char) (j + 'a'));
                ans.add(sb.toString());
            }
        }
        return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427825826
IphoneX,hahahiehie,43,3603,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    int n;
    GraphIntegerFaster g;
    String s;
    int[] startIndex;
    int[] endIndex;
    StringBuilder sb = new StringBuilder();

    String s1, s2;
    StringHash h1, h2;
    boolean check(int l, int r) {
        int len = r - l + 1;
        if (len == 1) return true;
        if (len % 2 == 0) {
            int mid = (l + r) / 2;
            long left = h1.hash(l, mid);
            long right = h2.hash(n - r - 1, n - (mid + 1) - 1);
            return left == right;
        } else {
            int mid = (l + r) / 2;
            long left = h1.hash(l, mid);
            long right = h2.hash(n - r - 1, n - (mid) - 1);
            return left == right;
        }
    }
    public boolean[] findAnswer(int[] parent, String s) {
        n = parent.length;
        g = new GraphIntegerFaster(n);
        this.s = s;
        startIndex = new int[n];
        endIndex = new int[n];
        for (int i = 1; i < n; i++) {
            g.link(parent[i], i);
        }

        dfs(0);
        s1 = sb.toString();
        s2 = new StringBuilder(s1).reverse().toString();
        h1 = new StringHash(s1);
        h2 = new StringHash(s2);

        boolean[] ans = new boolean[n];

        for (int i = 0; i < n; i++) {
            ans[i] = check(startIndex[i], endIndex[i]);
        }
        return ans;
    }

    void dfs(int x) {
        startIndex[x] = sb.length();
        for (int y : g.getChildren(x)) {
            dfs(y);
        }
        endIndex[x] = sb.length();
        sb.append(s.charAt(x));
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427871787
IphoneX,hahahiehie,43,3607,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Testd by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    private static final double EPS = 1e-8;
    private static final long SEED = 31L;

    static final int MAX_N = 1000_000 + 1;
    static int[] genFactors(int n) {
        int[] factors = new int[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = i + i; j <= n; j += i) {
                factors[j] = i;
            }
        }
        return factors;
    }
    
    static int[] factors = genFactors(MAX_N);
    public int minOperations(int[] nums) {
           int n = nums.length;
           int ans = 0;
           for (int i = n - 2; i >= 0; i--) {
               if (nums[i] > nums[i + 1]) {
                   nums[i] /= factors[nums[i]];
                    ans++;
               }
               if (nums[i] > nums[i + 1]) return -1;
           }
           return ans;
    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1427841603
Javier,JavOliva,45,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<vector<int> > c(n, vector<int>(26));
        for (int i = 0; i < n; i ++){
            c[i][s[i] - 'a'] ++;
            for (int j = 0; j < 26; j ++){
                if (i > 0)
                    c[i][j] += c[i - 1][j];
            }
        }
        int answer = 0;
        for (int i = 0; i < n; i ++){
            int left = i, right = n;
            while(left < right){
                int mid = (left + right) / 2;
                bool oka = false;
                for (int j = 0; j < 26; j ++){
                    int hay = c[mid][j] - (i > 0 ? c[i - 1][j] : 0);
                    if (hay >= k)
                        oka = true;
                }
                if (oka){
                    right = mid;
                }
                else{
                    left = mid + 1;
                }
            }
            answer += (n - right);
        }
        return answer;
    }
};",1427829905
Javier,JavOliva,45,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> A;
        string w = """";
        for (char x : target){
            w.push_back('a');
            A.push_back(w);
            while(w.back() < x){
                w[w.size() - 1] ++;
                A.push_back(w);
            }
        }
        return A;
    }
};",1427825015
Javier,JavOliva,45,3603,cpp,"typedef long long ll;
ll mod = 1e9 + 7;
ll mod2 = 1e9 + 123;
template<class T> struct IterativeSegmentTree{
  int n; vector<T> ST; T (*m_)(T, T);
  IterativeSegmentTree(vector<T> &a,T(*m_)(T,T)):m_(m_){
    n = a.size(); ST.resize(n << 1);
    for (int i=n;i<(n<<1);i++)ST[i]=a[i-n];
    for (int i=n-1;i>0;i--)ST[i]=m_(ST[i<<1],ST[i<<1|1]);
  }
  void update(int pos, T val){ // replace with val
    ST[pos += n] = val;
    for (pos >>= 1; pos > 0; pos >>= 1)
      ST[pos] = m_(ST[pos<<1], ST[pos<<1|1]);
  }
  T query(int l, int r){ // [l, r]
    T ansL, ansR; bool hasL = 0, hasR = 0;
    for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
      if (l & 1) 
        ansL=(hasL?m_(ansL,ST[l++]):ST[l++]),hasL=1;
      if (r & 1) 
        ansR=(hasR?m_(ST[--r],ansR):ST[--r]),hasR=1;
    }
    if (!hasL) return ansR; if (!hasR) return ansL;
    return m_(ansL, ansR);
  }
}; // Give vector of leaves and merge function
 
vector<ll> pot;
vector<ll> pot2;
 
pair<ll, ll> merge(pair<ll, ll> a, pair<ll, ll> b){
  return {(a.first + b.first * pot[a.second]) % mod, a.second + b.second};
}

pair<ll, ll> merge2(pair<ll, ll> a, pair<ll, ll> b){
    return {(a.first + b.first * pot2[a.second]) % mod2, a.second + b.second};
}
const int maxn = 1e5 + 5;
bool computed = false;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        if (!computed){
            pot.resize(maxn, 1);
            pot2.resize(maxn, 1);
            for (int i = 1; i < pot.size(); i ++){
                pot[i] = (pot[i - 1] * 139) % mod;
                pot2[i] = (pot2[i - 1] * 31) % mod2;
            }
            computed = true;
        }
        vector<vector<int> > adj(n);
        for (int i = 1; i < n; i ++){
            adj[parent[i]].push_back(i);
        }
        for (int i = 0; i < n; i ++)
            sort(adj[i].begin(), adj[i].end());
        vector<pair<ll, ll> > wea;
        vector<int> l(n), r(n);
        function<void (int)> dfs = [&](int u){
            l[u] = wea.size();
            for (int v : adj[u]){
                dfs(v);
            }
            r[u] = wea.size();
            wea.emplace_back((ll)s[u], 1LL);
        };
        dfs(0);
        vector<bool> ans(n);
        vector<pair<ll, ll> > s2 = wea;
        reverse(s2.begin(), s2.end());
        cout << wea.size() << endl;
        IterativeSegmentTree<pair<ll, ll> > T1(wea, merge), T2(s2, merge);
        IterativeSegmentTree<pair<ll, ll> > P1(wea, merge2), P2(s2, merge2);
        for (int i = 0; i < n; i ++){
            int a = l[i], b = r[i];
            ll v1 = T1.query(a, b).first;
            ll v2 = T2.query(n - 1 - b, n - 1 - a).first;
            ll v3 = P1.query(a, b).first;
            ll v4 = P2.query(n - 1 - b, n - 1 - a).first;
            if (v1 == v2 and v3 == v4){
                ans[i] = 1;
            }
            else{
                ans[i] = 0;
            }
        }
        return ans;
    }
};",1427864930
Javier,JavOliva,45,3607,cpp,"typedef long long ll;
const int maxx = 1e6 + 1;
int criba[maxx];
bool computed = false;
class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (!computed){
            iota(criba, criba + maxx, 0);
            for (int i = 4; i < maxx; i += 2){
                criba[i] = 2;
            }
            for (int i = 3; i < maxx; i += 2){
                if (criba[i] == i){
                    for (ll j = (ll)i * i; j < maxx; j += i){
                        criba[j] = min(criba[j], i);
                    }
                }
            }
            computed = true;
        }
        int n = nums.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i --){
            if (nums[i] > nums[i + 1]){
                ans ++;
                nums[i] = criba[nums[i]];
            }
            if (nums[i] > nums[i + 1]){
                return -1;
            }
        }
        return ans;
    }
};",1427838092
OTTFF,OTTFF,46,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();

        int ans = 0;
        map<char, int> cnt;

        auto check = [&]() {
            for (auto&& [v, c] : cnt) {
                if (c >= k) return true;
            }
            return false;
        };

        int r = 0;
        for (int l = 0; l < n; l++) {
            while (r <= l || r < n && !check()) {
                cnt[s[r]]++;
                r++;
            }

            if (!check()) break;

            // cout << l << ' ' << r << endl;

            ans += n - r + 1;

            cnt[s[l]]--;
        }
        return ans;
    }
};",1427833845
OTTFF,OTTFF,46,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        string s;
        int len = 0;
        vector<string> ans;

        while (s != t) {
            if (len == 0 || s[len - 1] == t[len - 1]) {
                s += 'a';
                len++;
            } else {
                s[len - 1] = s[len - 1] + 1;
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1427826647
OTTFF,OTTFF,46,3603,cpp,"template<typename Func> struct YCombinatorResult {
  Func func;
  template<typename T>
  explicit YCombinatorResult(T &&func) : func(std::forward<T>(func)) {}
  template<class ...Args> decltype(auto) operator()(Args &&...args) {
    return func(std::ref(*this), std::forward<Args>(args)...);
  }
};
template<typename Func> decltype(auto) y_comb(Func &&fun) {
  return YCombinatorResult<std::decay_t<Func>>(std::forward<Func>(fun));
}

template<typename T = char, T ST_CHAR = '$', T MD_CHAR = '*', T ED_CHAR = '#'>
struct Manacher {
  vector<T> t;
  vector<int> max_extend;

  Manacher(const vector<T>& s) {
    t.push_back(ST_CHAR);
    t.push_back(MD_CHAR);
    for (auto i : s) {
      t.push_back(i);
      t.push_back(MD_CHAR);
    }
    t.push_back(ED_CHAR);

    int m = t.size();
    max_extend.assign(m, 0);
    max_extend[1] = 1;
    int j = 1;
    for (int i = 2; i < m - 1; i++) {
      int cur_max_extend =
          (j + max_extend[j] > i)
          ? min(max_extend[j * 2 - i], j + max_extend[j] - i)
          : 1;

      while (t[i - cur_max_extend] == t[i + cur_max_extend]) {
          cur_max_extend++;
      }
      if (i + cur_max_extend > j + max_extend[j]) {
          j = i;
      }
      max_extend[i] = cur_max_extend;
    }
  }

  int tid(int i) const { return i * 2 + 2; }
  int oddlen(int o) const { // center at o
    return max_extend[tid(o)] - 1;
  }
  int evenlen(int o) const { // center at the middle of o, o+1
    return max_extend[tid(o) + 1] - 1;
  }

  pair<int, int> center_2_lr(int o) const {
    return {(o - max_extend[o]) / 2, (o + max_extend[o]) / 2 + 2};
  }


  int get_length(int i) { return max_extend[i] - 1; }
  int get_start(int i) { return (i - max_extend[i]) / 2; }
  int get_end(int i) { return (i + max_extend[i]) / 2 - 2; }

  vector<int> getl() { // [i - l[i] + 1, i]
    int n = t.size() / 2 - 1;
    vector<int> l(n);
    for (int i = 2; i <= n * 2; i++)
        l[get_end(i)] = max(l[get_end(i)], get_length(i));
    for(int i = n - 2; i >= 0; i--) l[i] = max(l[i] , l[i + 1] - 2);
    return l;
  }
  vector<int> getr() { // [i, i + r[i] - 1]
    int n = t.size() / 2 - 1;
    vector<int> r(n);
    for (int i = 2; i <= n * 2; i++)
        r[get_start(i)] = max(r[get_start(i)], get_length(i));
    for (int i = 1; i < n; i++) r[i] = max(r[i], r[i - 1] - 2);
    return r;
  }
};

vector<char> to_vec(const string& s) {
  vector<char> ans;
  for (char c : s) ans.push_back(c);
  return ans;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string val) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }

        vector<int> indfs(n), outdfs(n);
        int ndfn = 0;

        string s;
        y_comb([&](auto dfs, int u) -> void {
            indfs[u] = ndfn;
            for (int v : g[u]) {
                dfs(v);
            }
            s += val[u];
            outdfs[u] = ndfn++;
        })(0);

        // cout << s << endl;
        // for (int i : indfs) cout << i << ' ';
        // cout << endl;
        // for (int i : outdfs) cout << i << ' ';
        // cout << endl;

        Manacher mana(to_vec(s));

        vector<bool> ans(n);

        for (int i = 0; i < n; i++) {
            int l = indfs[i], r = outdfs[i];
            int len = r - l + 1;
            if (len & 1) {
                ans[i] = mana.oddlen((l + r) / 2) >= len;
            } else {
                ans[i] = mana.evenlen((l + r) / 2) >= len;
            }
        }
        return ans;
    }
};",1427865054
OTTFF,OTTFF,46,3607,cpp,"vector<int> isp, pri, minfac, maxfac;
void init_prime(int n) {
  isp.assign(n + 1, 1); isp[0] = isp[1] = 0;
  minfac.assign(n + 1, 0);
  maxfac.assign(n + 1, 0);
  for(int i = 2; i <= n; i++) {
    if(isp[i]) { pri.push_back(i); isp[i] = pri.size(); minfac[i] = i; }
    for(int p : pri) {
      if (i > n / p) break;
      isp[i * p] = 0;
      minfac[i * p] = p;
      if(i % p == 0) break;
    }
  }
  for (int i = 2; i <= n; i++) {
    maxfac[i] = max(maxfac[i / minfac[i]], minfac[i]);
  }
}

int f = 0;
void init() {
    if (f) return;
    f = 1;
    init_prime(1000001);
}

class Solution {
public:
    int minOperations(vector<int>& a) {
        init();
        int n = a.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (a[i] > a[i + 1]) {
                // cout << a[i] << ' ' << maxfac[a[i]] << endl;
                if (minfac[a[i]] == a[i]) return -1;

                a[i] = minfac[a[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427847202
Liwei Cai,cai_lw,47,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        array<int,26> cnt{};
        vector<int> cntcnt(k+1);
        int n=s.size(),j=0,ans=0;
        for(int i=0;i<n;i++){
            while(j<n&&cntcnt.back()==0){
                int& c=cnt[s[j]-'a'];
                if(c<k){
                    cntcnt[c]--;
                    cntcnt[c+1]++;
                }
                c++;
                j++;
            }
            if(cntcnt.back()>0)
                ans+=n-j+1;
            int& c=cnt[s[i]-'a'];
            if(c<=k){
                    cntcnt[c]--;
                    cntcnt[c-1]++;
            }
            c--;
        }
        return ans;
    }
};",1427829521
Liwei Cai,cai_lw,47,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans{""a""};
        while(ans.back()!=target){
            string last=ans.back();
            if(target[last.size()-1]==last.back())
                last.push_back('a');
            else
                last.back()++;
            ans.push_back(last);
        }
        return ans;
    }
};",1427824185
Liwei Cai,cai_lw,47,3603,cpp,"class Solution {
    // https://cp-algorithms.com/string/manacher.html
    vector<int> manacher_odd(string s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    vector<int> manacher(string s) {
        string t;
        for(auto c: s) {
            t += string(""#"") + c;
        }
        auto res = manacher_odd(t + ""#"");
        return vector<int>(begin(res) + 1, end(res) - 1);
    }
    void dfs(int u,const vector<vector<int>>& children,const string& s,string& o,vector<pair<int,int>>& lr){
        lr[u].first=o.size();
        for(int v:children[u])
            dfs(v,children,s,o,lr);
        o+=s[u];
        lr[u].second=o.size();
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=s.size();
        vector<vector<int>> children(n);
        for(int i=1;i<n;i++)
            children[parent[i]].push_back(i);
        string o;
        vector<pair<int,int>> lr(n);
        dfs(0,children,s,o,lr);
        auto d=manacher(o);
        vector<bool> ans(n);
        for(int i=0;i<n;i++){
            auto [l,r]=lr[i];
            ans[i]=d[l+r-1]-1>=r-l;
        }
        return ans;
    }
};",1427865079
Liwei Cai,cai_lw,47,3607,cpp,"class Solution {
    // https://cp-algorithms.com/algebra/prime-sieve-linear.html
    vector<int> linear_sieve(int N){
        vector<int> lp(N+1);
        vector<int> pr;

        for (int i=2; i <= N; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for (int j = 0; i * pr[j] <= N; ++j) {
                lp[i * pr[j]] = pr[j];
                if (pr[j] == lp[i]) {
                    break;
                }
            }
        }
        return lp;
    }
public:
    int minOperations(vector<int>& nums) {
        constexpr int INF=1e9;
        auto lp=linear_sieve(*max_element(nums.begin(),nums.end()));
        array<int,2> dp{0,1};
        for(int i=1;i<nums.size();i++){
            array<int,2> dp2{INF,INF};
            if(nums[i]>=nums[i-1])
                dp2[0]=min(dp2[0],dp[0]);
            if(nums[i]>=lp[nums[i-1]])
                dp2[0]=min(dp2[0],dp[1]);
            if(lp[nums[i]]>1){
                if(lp[nums[i]]>=nums[i-1])
                    dp2[1]=min(dp2[1],dp[0]+1);
                if(lp[nums[i]]>=lp[nums[i-1]])
                    dp2[1]=min(dp2[1],dp[1]+1);
            }
            dp=dp2;
        }
        int ans=min(dp[0],dp[1]);
        return ans==INF?-1:ans;
    }
};",1427842512
mastoori1234,mastoori1234,50,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int n = s.length();
        int ans = 0;
        
        vector< vector<int> > idx(26, vector<int>());
        
        for( int i=n-1; i>=0; i--) {
            int c = s[i]-'a';
            idx[c].push_back(i);
        }
        
        for( int i=0; i<n; i++) {
            int t = n;
            for( int j=0; j<26; j++) {
                int m = idx[j].size();
                if(m>=k) {
                    t = min( t, idx[j][m-k]);
                }
            }
            ans += (n-t);
            int c = s[i]-'a';
            idx[c].pop_back();
        }        
        
        return ans;
    }
};",1427867360
mastoori1234,mastoori1234,50,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        
        vector<string> res;
        
        string t = ""a"";
        
        while(true) {
            res.push_back(t);
            int n = t.length();
            if(t[n-1]==s[n-1]) {
                if(t.length()==s.length()) {
                    break;
                } else {
                    t.push_back('a');
                }
            } else {
                t.back() += 1;
            }
        }
        
        
        return res;
    }
};",1427873939
mastoori1234,mastoori1234,50,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& par, string s) {
        
        
        int n = s.length();
        vector<bool> res(n);
        
        vector< vector<int> > adj( n, vector<int>());
        vector< pair<int,int> > cover(n);        
        string t = """";
        
        for( int i=1; i<n; i++) {
            adj[par[i]].push_back(i);
        }
        
        function<void(int)> dfs;
        
        dfs = [&]( int idx)->void {
            int sIdx = t.length();
            sort( adj[idx].begin(), adj[idx].end());
            for( int child: adj[idx]) {
                dfs(child);
            }
            int eIdx = t.length();
            t.push_back(s[idx]);
            cover[idx] = { sIdx, eIdx};
        };
        
        dfs(0);
        
        vector<int> d1( n, 1);
        vector<int> d2( n, 0);
        
        for( int i=0, l=-1, r=-1; i<n; i++) {
            int k = (i>r)?1:min( d1[l+r-i], r-i+1);
            while((i-k>=0) && (i+k<n) && (t[i-k]==t[i+k])) {
                k += 1;
            }
            d1[i] = k--;
            if(i+k>r) {
                l = i-k;
                r = i+k;
            }
        }
        
        for( int i=1, l=0, r=0; i<n; i++) {
            int k = (i>r)?0:min( d2[l+r-i+1], r-i+1);
            while((i-k-1>=0) && (i+k<n) && (t[i-k-1]==t[i+k])) {
                k += 1;
            }
            d2[i] = k--;
            if(i+k>r) {
                l = i-k-1;
                r = i+k;
            }
        }
        
        for( int i=0; i<n; i++) {
            int l = cover[i].second - cover[i].first + 1;
            int mid = (cover[i].second + cover[i].first + 1)/2;
            if(l%2==0) {
                res[i] = (d2[mid]>=(cover[i].second-mid+1));
            } else {
                res[i] = (d1[mid]>=(cover[i].second-mid+1));
            }
        }
        
        return res;
    }
};",1427844251
mastoori1234,mastoori1234,50,3607,cpp,"const int N = 1e6;
int spd[N+1];

class Solution {
public:
    
    Solution() {
        if(spd[0]==-1) {
            return;
        }
        fill( begin(spd), end(spd), -1);
        for( int i=2; i<=N; i++) {
            if(spd[i]==-1) {
                for( int j=i+i; j<=N; j+=i) {
                    if(spd[j]==-1) {
                        spd[j] = i;
                    }
                }
            }
        }
    }
    
    int minOperations(vector<int>& arr) {
        int n = arr.size();
        int c0 = 0;
        int c1 = (spd[arr[0]]==-1)?(2*n):1;
        for( int i=1; i<n; i++) {
            int nc0 = 2*n;
            int nc1 = 2*n;
            if(arr[i]>=arr[i-1]) {
                nc0 = min( nc0, c0);
            }
            if((spd[arr[i-1]]!=-1) && (arr[i]>=spd[arr[i-1]])) {
                nc0 = min( nc0, c1);
            }
            if((spd[arr[i]]!=-1) && (spd[arr[i]]>=arr[i-1])) {
                nc1 = min( nc1, 1+c0);
            }
            if((spd[arr[i]]!=-1) && (spd[arr[i-1]]!=-1) && (spd[arr[i]]>=spd[arr[i-1]])) {
                nc1 = min( nc1, 1+c1);
            }
            c0 = nc0;
            c1 = nc1;
        }
        int ans = min( c0, c1);
        return (ans>n)?(-1):ans;
    }
};",1427861938
otto,_otto,51,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            freq = [0] * 26
            ok = False
            for j in range(i, n):
                freq[ord(s[j]) - 97] += 1
                if freq[ord(s[j]) - 97] == k:
                    ok = True
                if ok: ans += 1
        return ans",1427826106
otto,_otto,51,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        
        ans = [target]
        while ans[-1] != 'a':
            lst = ans[-1]
            if lst[-1] == 'a':
                ans.append(lst[:-1])
            else:
                fuck = lst[:-1]
                ans.append(fuck + chr(ord(lst[-1]) - 1))
        return ans[::-1]",1427824278
otto,_otto,51,3603,python3,"power = random.randint(150, 200)
mod = random.getrandbits(32)
powers = [1]
for _ in range(int(1e5) + 1): powers.append(powers[-1] * power % mod)
    
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        ans = [False] * n
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        def dfs(u):
            h = 0
            hr = 0
            tot = 0
            for v in sorted(tree[u]):
                h_v, hr_v, len_v = dfs(v)
                h = (h * powers[len_v] + h_v) % mod
                hr = (hr_v * powers[tot] + hr) % mod
                tot += len_v
            c = ord(s[u])
            h = (h * power + c) % mod
            hr = (c * powers[tot] + hr) % mod
            tot += 1
            if h == hr:
                ans[u] = True
            else:
                ans[u] = False
            return h, hr, tot
        dfs(0)
        return ans",1427866191
otto,_otto,51,3607,python3,"def sieve(MAXN):
    spf = [0] * (MAXN + 1)
    spf[0], spf[1] = 0, 1
    for i in range(2, MAXN + 1):
        if spf[i] == 0:
            spf[i] = i
            for j in range(i * 2, MAXN + 1, i):
                if spf[j] == 0:
                    spf[j] = i
    return spf
spf = sieve(int(1e6) + 1)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        
        ans = 0
        target = nums[-1]

        for i in range(len(nums) - 2, -1, -1):
            curr = nums[i]
            while curr > target:
                if curr == 1:
                    return -1
                gpd = curr // spf[curr]
                if gpd == 0: return -1
                if gpd == 1 and curr > target: return -1
                curr = curr // gpd
                ans += 1
            target = curr

        return ans",1427840965
kevinbu,kevinbu,52,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = {}
        total = 0
        left = 0
        for right in range(len(s)):
            cur = s[right]
            count[cur] = count.get(cur, 0) + 1
            while left <= right and count[cur] >= k:
                temp = s[left]
                count[temp] -= 1
                left += 1
            total += right - left + 1
        
        res = (len(s) + 1) * len(s) // 2
        res -= total
        return res
        ",1427839830
kevinbu,kevinbu,52,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = """"
        for i in range(len(target)):
            index = ord(target[i]) - ord('a')
            
            for j in range(index + 1):
                temp = chr(ord('a') + j)
                res.append(cur + temp)
            cur = target[:i + 1]
        return res",1427828969
kevinbu,kevinbu,52,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        res = [True] * len(parent)
        edges = collections.defaultdict(list)

        for i in range(len(parent)):
            par = parent[i]
            edges[par].append(i)
        print(edges)
        def checkPali(value):
            if len(value) == 1:
                return True
            if len(value) % 2 == 0:
                half = len(value) // 2
                return value[:half] == value[half:][::-1]
            else:
                half = len(value) // 2
                return value[:half] == value[half + 1:][::-1]
        
        def dfs(node):
            cur = """"
            for child in edges[node]:
                value = dfs(child)
                cur += value
            cur += s[node]
            result = checkPali(cur)
            nonlocal res
            res[node] = result
            return cur
        dfs(edges[-1][0])
        return res
        ",1427874456
kevinbu,kevinbu,52,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:

        def findDivisor(k):
            ceiling = math.floor(k ** 0.5)

            for i in range(2, ceiling + 1):
                if k % i == 0:
                    return i
            return k
        res = 0
        for i in range(len(nums)-2, -1, -1):
            if nums[i] > nums[i+1]:
                temp = findDivisor(nums[i])
                if temp > nums[i+1]:
                    return -1
                nums[i] = temp
                res += 1
        return res
        ",1427850425
user5860c,user5860c,54,3502,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ret = 0;
        
        FOR(i, sz(s)) {
            map<int,int> h;
            int ok = 0;
            for (int j=i;j<sz(s);++j) {
                h[s[j]]++;
                if (h[s[j]] >= k) {
                    ok = 1;
                }
                ret += ok;
            }
        }
        return ret;
    }
};",1427864149
user5860c,user5860c,54,3566,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> ret;
        string cur = """";
        for (int i=0;i<sz(t);++i) {
            cur += 'a';
            ret.pb(cur);
            while(cur.back() != t[i]) {
                cur.back() = cur.back() + 1;
                ret.pb(cur);
            }
        }
        return ret;
    }
};",1427866882
user5860c,user5860c,54,3603,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

vi g[2020200];

string ret,s;
vpi vx;
void dfs(int x) {
   vx[x].fs = sz(ret);
   for (auto n : g[x])  {
       dfs(n);
   }
   vx[x].sc = sz(ret);
   ret += s[x];
}
vi pscpld (string s) {
  string s1;
  int maxind=0,maxVal=0;
  for (int i=0;i<sz(s);++i) {
    s1 += s[i];
    if (i != sz(s)-1) {
      s1 += ""*"";
    }
  }

  vi val(sz(s1));
  //cout << s1 << endl;
  for(int i=0;i<sz(s1);++i) {
    if(maxVal >= i) {
      int loc = maxind - (i-maxind);
      val[i] = min(val[loc],maxVal-i);
    }
    while((i - val[i] >= 0) && (i + val[i] < sz(s1)) && 
          (s1[i-val[i]] == s1[i+val[i]])) {
      ++val[i];
      if(i + val[i] > maxVal){
        maxVal = i + val[i] - 1; maxind = i;
      }
    }
  }
  
  return val;
}
int isp(int l, int r, vi &v) {
    if ( (r - l + 1) % 2 == 1) {
        int mid = (l + r);
        //cout << l << "" "" << r << "" "" << mid << endl;
        if (v[mid] >= r - l + 1) return 1;
    } else {
        int mid = (l+r);
        if (v[mid] >= r - l + 1) return 1;
    }
    return 0;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& pr, string sx) {
        s = sx;
        FOR(i, sz(pr)) {
            g[i].clear();
        }
        FOR(i, sz(pr)) {
            if (pr[i] == -1) {
                continue;
            }
            g[pr[i]].pb(i);
        }
        ret = """";
        vx.resize(sz(pr));
        dfs(0);
        vi val = pscpld(ret);
        /*cout << ret << endl;
        for (auto x : val) {
            cout << x << "" "";
        }
        cout << endl;
        */
        vector<bool> rf;
        FOR(i, sz(pr)) {
            if (isp(vx[i].fs, vx[i].sc, val)) {
                rf.pb(1);
            } else {
                rf.pb(0);
            }
        }
        return rf;
        
    }
};
",1427845925
user5860c,user5860c,54,3607,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

int pr[2020200];

int getp(int x) {
    return pr[x];
}

int best[1010100][2];
class Solution {
public:
    int minOperations(vector<int>& v) {
        if (pr[2] == 0) {
            for (int i=2;i<=1000000;++i) {
                for (int j=i;j<=1000000;j+=i) {
                    if (pr[j] == 0) {
                        pr[j] = i;
                    }
                }
            }
            pr[1] = 1;
        }
        best[0][0] = 0;
        best[0][1] = 1;
        for (int i=1;i<sz(v);++i) {
            best[i][0] = best[i][1] = sz(v) * 100;
            if (v[i] >= v[i-1]) {
                //cout << ""WTF4 "" << i << endl;
                best[i][0] = min(best[i][0], best[i-1][1]);
                best[i][0] = min(best[i][0], best[i-1][0]);
            }
            if (v[i] >= getp(v[i-1])) {
                //cout << ""WTF3 "" << i << endl;
                best[i][0] = min(best[i][0], best[i-1][1]);
            }
            if (getp(v[i]) >= getp(v[i-1])) {
                //cout << ""WTF2 "" << i << endl;
                best[i][1] = min(best[i][1], best[i-1][1] + 1);
            }
            if (getp(v[i]) >= v[i-1]) {
                //cout << ""WTF1 "" << i << endl;
                best[i][1] = min(best[i][1], best[i-1][0] + 1);
            }
        }
        int ret = min(best[sz(v)-1][0], best[sz(v)-1][1]);
        if (ret > sz(v)) return -1;
        return ret;
    }
};",1427861923
Chuan-Chih Chou,chuan-chih,55,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c = Counter()
        ans = i = 0
        for char in s:
            c[char] += 1
            while max(c.values()) >= k:
                c[s[i]] -= 1
                i += 1
            ans += i
        return ans",1427830378
Chuan-Chih Chou,chuan-chih,55,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        l = []
        ans = []
        for c in target:
            l.append('a')
            ans.append(''.join(l))
            while l[-1] < c:
                prev = l.pop()
                curr = chr(ord(prev) + 1)
                l.append(curr)
                ans.append(''.join(l))
        return ans",1427826397
Chuan-Chih Chou,chuan-chih,55,3603,python3,"def manacher(s):
    # print(s)
    t = '#'.join('^' + s + '$')
    p = [0] * len(t)
    c = r = 0
    for i in range(2, len(t) - 2):
        p[i] = int(r > i) and min(r - i, p[2 * c - i])
        while t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] += 1
        if i + p[i] > r:
            c, r = i, i + p[i]
    return p

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        child = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                child[p].append(i)
        r = [None] * n
        l = []
        def dfs(i):
            for c in child[i]:
                dfs(c)
            index = len(l)
            l.append(s[i])
            if child[i]:
                r[i] = (r[child[i][0]][0], index)
            else:
                r[i] = (index, index)            
        dfs(0)
        p = manacher(''.join(l))[2:]
        # print(p)
        # print(r)
        
        def check(i, j):
            length = j - i + 1
            middle = i + j
            return p[middle] >= length
            
        
        return [check(*r[i]) for i in range(n)]
        
        ",1427876496
Chuan-Chih Chou,chuan-chih,55,3607,python3,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def op(x):
            for p in primes:
                if not x % p:
                    return p
            return x
            
        curr = nums[-1]
        ans = 0
        for i in reversed(range(len(nums) - 1)):
            x = nums[i]
            if x <= curr:
                curr = x
            else:
                x = op(x)
                ans += 1
                if x <= curr:
                    curr = x
                else:
                    return -1
        return ans",1427844801
kzyKT,kzyKT,57,3502,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    int ans=0;
    rep(i,s.size()) {
      int c[26],f=0;
      mem(c);
      REP(j,i,s.size()) {
        c[s[j]-'a']++;
        if(c[s[j]-'a']>=k) f=1;
        ans+=f;
      }
    }
    return ans;
  }
};",1427825537
kzyKT,kzyKT,57,3566,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  vector<string> stringSequence(string s) {
    vector<string> ans;
    string t="""";
    rep(i,s.size()) {
      t+='a';
      ans.pb(t);
      while(t.back()!=s[i]) {
        t.back()++;
        ans.pb(t);
      }
    }
    return ans;
  }
};
",1427824255
kzyKT,kzyKT,57,3603,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

struct RollingHash {
  static constexpr uint64_t MASK30=(1ULL<<30)-1;
  static constexpr uint64_t MASK31=(1ULL<<31)-1;
  static const uint64_t MOD=(1ULL<<61ULL)-1;
  const uint64_t base;
  vector<uint64_t> power;
  explicit RollingHash(uint64_t base=generate_base()):base(base),power{1} {}
  vector<uint64_t> build(const string& s) const {
    int sz=s.size();vector<uint64_t> hashed(sz+1);
    for(int i=0;i<sz;i++)hashed[i+1]=add(mul(hashed[i],base),s[i]);
    return hashed;
  }
  template<typename T>
  vector<uint64_t> build(const vector<T>& s) const {
    int sz=s.size();vector<uint64_t> hashed(sz+1);
    for(int i=0;i<sz;i++)hashed[i+1]=add(mul(hashed[i],base),s[i]);
    return hashed;
  }
  uint64_t query(const vector<uint64_t>& s,int l,int r) {
    expand(r-l);return add(s[r],MOD-mul(s[l],power[r-l]));
  }
  uint64_t combine(uint64_t h1,uint64_t h2,size_t h2len) {
    expand(h2len);return add(mul(h1,power[h2len]),h2);
  }
private:
  static inline uint64_t add(uint64_t a,uint64_t b) {
    if((a+=b)>=MOD)a-=MOD;return a;
  }
  static inline uint64_t mul(uint64_t l,uint64_t r) {
    auto lu=l>>31,ld=l&MASK31,ru=r>>31,rd=r&MASK31,mb=ld*ru+lu*rd;
    return calc_mod(((lu*ru)<<1)+ld*rd+((mb&MASK30)<<31)+(mb>>30));
  }
  static inline uint64_t calc_mod(uint64_t val) {
    val=(val&MOD)+(val>>61);if(val>MOD)val-=MOD;return val;
  }
  static inline uint64_t generate_base() {
    mt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<uint64_t> rand(1,RollingHash::MOD-1);
    return rand(mt);
  }
  inline void expand(size_t sz) {
    if(power.size()<sz+1) {
      int pre_sz=power.size();power.resize(sz+1);
      for(int i=pre_sz-1;i<sz;i++)power[i+1]=mul(power[i],base);
    }
  }
};


string s,t;
vector<ll> v[111111];
vector<bool> ans;

P a[200000];
void calc() {
  int k=0;
  stack<P> s;
  s.push(P(0,-1));
  while(!s.empty()) {
    P q=s.top();s.pop();
    int x=q.F,p=q.S;
    if(x<0||!x&&p>0) {
      a[-x].S=k;
      continue;
    }
    s.push(P(-x,-p));
    a[x].F=k++;
    for(int i=0; i<v[x].size(); i++) {
      int y=v[x][i];
      if(y==p) continue;
      s.push(P(y,x));
    }
  }
}

void dfs(ll x) {
  rep(i,v[x].size()) dfs(v[x][i]);
  t+=s[x];
}

class Solution {
public:
  vector<bool> findAnswer(vector<int>& p, string ss) {
    s=ss;
    ll n=s.size();
    ans.clear();
    rep(i,n) v[i].clear(),ans.pb(0);
    REP(i,1,p.size()) v[p[i]].pb(i);
    t="""";
    dfs(0);
    calc();
    RollingHash rh;
    reverse(all(t));
    auto r1=rh.build(t);
    reverse(all(t));
    auto r2=rh.build(t);
    rep(i,n) {
      ll l=a[i].F,r=a[i].S;
      ll x=t.size()-a[i].S,y=t.size()-a[i].F;
      uint64_t h1=rh.query(r1,l,r);
      uint64_t h2=rh.query(r2,x,y);
      ans[i]=h1==h2;
    }
    return ans;
  }
};
",1427869430
kzyKT,kzyKT,57,3607,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int minOperations(vector<int>& a) {
    map<ll,ll> ma;
    int ans=0;
    rrep(i,a.size()-1) {
      while(a[i]>a[i+1]) {
        if(!ma.count(a[i])) {
          ll M=1;
          for(ll j=2; j*j<=a[i]; j++) {
            if(a[i]%j==0) {
              M=max(M,j);
              M=max(M,a[i]/j);
            }
          }
          ma[a[i]]=M;
        }
        ll d=ma[a[i]];
        if(d==1) return -1;
        a[i]/=d;
        ans++;
      }
    }
    return ans;
  }
};",1427835054
aqxa2k,aqxa2k,58,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(); 
        vector<vector<int>> dp(n, vector<int>(n, 0)); 
        vector<vector<int>> pos(26); 
        for (int i = 0; i < n; ++i) {
            pos[s[i] - 'a'].push_back(i); 
        }
        for (auto v: pos) {
            if (v.size() < k) continue; 
            for (int i = 0; i + k - 1 < v.size(); ++i) {
                dp[v[i]][v[i + k - 1]] = 1; 
            }
        }
        int ans = 0; 
        for (int l = n - 1; l >= 0; --l) {
            for (int r = l; r < n; ++r) {
                if (dp[l][r]) ans++; 
                if (l) dp[l-1][r] |= dp[l][r]; 
                if (r + 1 < n) dp[l][r+1] |= dp[l][r]; 
            }
        }
        return ans; 
    }
};",1427828352
aqxa2k,aqxa2k,58,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res; 
        string cur = """"; 
        for (int i = 0; i < target.size(); ++i) {
            cur += 'a'; 
            res.push_back(cur); 
            while (cur[i] != target[i]) {
                cur[i]++; 
                // cout << ""! "" << cur << '\n';
                res.push_back(cur); 
            }
        }
        return res; 
    }
};",1427824428
aqxa2k,aqxa2k,58,3603,cpp,"using ll = long long; 
class HashedString {
  private:
	// change M and B if you want
	static const ll M = (1LL << 61) - 1;
	static const ll B;
 
	// pow[i] contains B^i % M
	static vector<ll> pow;
 
	// p_hash[i] is the hash of the first i characters of the given string
	vector<ll> p_hash;
 
	__int128 mul(ll a, ll b) { return (__int128)a * b; }
	ll mod_mul(ll a, ll b) { return mul(a, b) % M; }
 
  public:
	HashedString(const string &s) : p_hash(s.size() + 1) {
		while (pow.size() < s.size() + 5) { pow.push_back(mod_mul(pow.back(), B)); }
		p_hash[0] = 0;
		for (int i = 0; i < s.size(); i++) {
			p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;
		}
	}
 
	ll get(int start, int end) {
		ll raw_val =
		    p_hash[end + 1] - mod_mul(p_hash[start], pow[end - start + 1]);
		return (raw_val + M) % M;
	}
};
mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
vector<ll> HashedString::pow = {1};
const ll HashedString::B = uniform_int_distribution<ll>(0, M - 1)(rng);

class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = s.size(); 
        vector<vector<int>> g(n); 
        for (int i = 1; i < n; ++i) {
            g[p[i]].push_back(i); 
        }
        vector<int> tin(n), tout(n); 
        int tt = 0; 
        dfs(0, g, tin, tout, tt); 
        string t = s; 
        for (int i = 0; i < n; ++i) {
            // cout << tin[i] << ' ' << tout[i] << '\n';
            t[tout[i]] = s[i]; 
        }
        // cout << t << '\n';
        s = t; 
        reverse(s.begin(), s.end()); 
        HashedString ha(t); 
        HashedString hb(s); 

        vector<bool> res(n); 
        for (int i = 0; i < n; ++i) {
            int l = tin[i], r = tout[i]; 
            // cout << tin[i] << ' ' << tout[i] << '\n';
            // cout << ha.get(l, r) << ' ' << hb.get(n - 1 - r, n - 1 - l) << '\n';
            res[i] = ha.get(l, r) == hb.get(n - 1 - r, n - 1 - l); 
        }
        return res; 

    }
    void dfs(int x, vector<vector<int>> & g, vector<int> & tin, vector<int> & tout, int & t) {
        tin[x] = t; 
        for (auto y: g[x]) {
            dfs(y, g, tin, tout, t); 
        }
        tout[x] = t; 
        t++; 
    }
};",1427869449
aqxa2k,aqxa2k,58,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        int n = a.size(); 
        int ans = 0; 
        for (int i = n - 2; i >= 0; --i) {
            if (a[i] > a[i + 1]) {
                if (a[i] % 2 == 0) {
                    a[i] = 2; 
                    ans++; 
                    continue; 
                }
                for (int j = 3; j * j <= a[i]; j += 2) {
                    if (a[i] % j == 0) {
                        a[i] = j; 
                        ans++; 
                        break; 
                    }
                }
                if (a[i] > a[i + 1]) return -1; 
            }
        }
        return ans; 
    }
};",1427834597
nikatamliani1,nikatamliani1,59,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int)s.size();
        int cnt = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> freq(26);
            bool pos = false;
            for (int j = i; j < n; ++j) {
                if (++freq[s[j] - 'a'] >= k) {
                    pos = true;
                }
                if (pos) {
                    ++cnt;
                }
            }
        }
        return cnt;
    }
};",1427824699
nikatamliani1,nikatamliani1,59,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s;
        for (int i = 0; i < (int)target.size(); ++i) {
            s += 'a';
            res.push_back(s);
            for (int c = 'b'; c <= target[i]; ++c) {
                s.back() = c;
                res.push_back(s);
            }
        }
        return res;
    }
};",1427823976
nikatamliani1,nikatamliani1,59,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = (int)parent.size();
        vector<vector<int>> children(n);
        for (int i = 1; i < n; ++i) {
            children[parent[i]].push_back(i);
        }
        

        string t;
        int timer = -1;
        vector<int> out(n), mini(n, (int)1e9);
        auto dfs = [&](auto self, int x) -> void {
            for (int child : children[x]) {
                self(self, child);
            }
            out[x] = ++timer;
            mini[x] = min(mini[x], out[x]);
            if (x > 0) {
                mini[parent[x]] = min(mini[parent[x]], mini[x]);
            }
            t += s[x];
        };
        
        dfs(dfs, 0);

        const int MOD = 1e9 + 7, p = 31;

        auto bpow = [&](int x, int y, int MOD) -> int {
            int ans = 1;
            while (y > 0) {
                if (y & 1) {
                    ans = 1LL * ans * x % MOD;
                }
                x = 1LL * x * x % MOD;
                y >>= 1;
            }  
            return ans;
        };

        vector<int> po(n + 5), ipo(n + 5);
        po[0] = 1;
        for (int i = 1; i < (int)po.size(); ++i) {
            po[i] = 1LL * po[i - 1] * p % MOD; 
        }

        int ip = bpow(p, MOD - 2, MOD);
        ipo[0] = 1;
        for (int i = 1; i < (int)po.size(); ++i) {
            ipo[i] = 1LL * ipo[i - 1] * ip % MOD;
        }

        auto get_hash = [&](string s) -> vector<int> {
            vector<int> h(n);
            for (int i = 0; i < (int)s.size(); ++i) {
                h[i] = ((i > 0 ? 1LL * h[i - 1] * p : 0LL) + (s[i] - 'a' + 1)) % MOD;
            }
            return h;
        };

        auto get_val = [&](vector<int> &h, int l, int r) -> int {
            int pdiff = r - l + 1;
            return (1LL * (h[r] - 1LL * (l > 0 ? h[l - 1] : 0) * po[pdiff]) % MOD + MOD) % MOD;
        };

        vector<int> h1 = get_hash(t);
        reverse(t.begin(), t.end());
        vector<int> h2 = get_hash(t);
        reverse(t.begin(), t.end());



        auto is_palindrome = [&](int l, int r) -> bool {
            return get_val(h1, l, r) == get_val(h2, n - r - 1, n - l - 1);
        };

        vector<bool> ans(n);
        for (int i = 0; i < n; ++i) {
            ans[i] = is_palindrome(mini[i], out[i]);
        }
        return ans;
    }
};",1427861382
nikatamliani1,nikatamliani1,59,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        
        auto f = [&](int x) -> int {
            for (int i = 2; i * i <= x; ++i) {
                if (x % i == 0) {
                    return i;
                }
            }
            return x;
        };

        int n = (int)a.size(), cnt = 0;
        for (int i = n - 2; i >= 0; --i) {
            if (a[i] > a[i + 1]) {
                a[i] = f(a[i]);
                if (a[i] > a[i + 1]) {
                    return -1;
                }
                ++cnt;
            }
        }
        return cnt;
    }
};",1427831855
hxu10,hxu10,60,3502,python,"class Solution(object):
    def numberOfSubstrings(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        n = len(s)
        ans = 0
        
        for i in range(n):
            fre = [0]*26
            for j in range(i,n):
                fre[ord(s[j])-97] += 1
                if fre[ord(s[j])-97] >= k:
                    ans += n - j 
                    break
            
        return ans
        ",1427826833
hxu10,hxu10,60,3566,python,"class Solution(object):
    def stringSequence(self, target):
        """"""
        :type target: str
        :rtype: List[str]
        """"""
        ans = []
        curr = """"
        for c in target:
            index = ord(c) - 97
            for i in range(index+1):
                ans.append(curr+chr(97+i))
            curr += chr(97+i)
            
        return ans",1427824192
hxu10,hxu10,60,3603,python,"M = 10**18 + random.randint(1,10**9)

pows = [1]

for _ in range(100001):
    pows.append(pows[-1] * 27 % M)
    

class Solution(object):
    def findAnswer(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[bool]
        """"""
        
        n = len(s)
        children = [[] for _ in range(n)]
        
        for i in range(1,n):
            children[parent[i]].append(i)
            
            
        for i in range(n):
            children[i].sort()
            
            
        
            
            
            
            
        childnum = [0]*n
        
        seq = []
        
        ss = []
        
        
            
        def dfs(index):
            res = 1
            for nextindex in children[index]:
                res += dfs(nextindex)
            seq.append(index)
            ss.append(s[index])
            childnum[index] = res
            return res
        
        
        
        dfs(0)
        
        

        
        

        
        
            
        hleft = [0]*(n+1)
        hright = [0]*(n+1)
        
        
        

        for i in range(n):
            hleft[i] = hleft[i-1] * 27 + ord(ss[i]) - 26
            hleft[i] %= M
        for i in range(n-1,-1,-1):
            hright[i] = hright[i+1] * 27 + ord(ss[i]) - 26
            hright[i] %= M
            
        
        
        
 
        
        
        loc = [0]*n
        
        
        for i in range(n):
            loc[seq[i]] = i
            
            
  
            
            
        ans = []
        for i in range(n):
            end = loc[i]
            begin = end - childnum[i] + 1
            
         #   print(i,begin,end)
            
            h1 = hleft[end] - hleft[begin-1] * pows[childnum[i]]
            
            h2 = hright[begin] - hright[end+1] * pows[childnum[i]]
            
            
            
            
            if h1 % M == h2 % M:
                ans.append(True)
            else:
                ans.append(False)
                
                
        return ans
        
        

        
        
    
            
            
            
            
            
            
            
        ",1427869776
hxu10,hxu10,60,3607,python,"MAX = 1000001
smallest = [0]*(MAX+1)
smallest[1] = 1
for i in range(2,MAX+1):
    for j in range(i,MAX+1,i):
        if smallest[j] > 0:  continue  
        smallest[j] = i
        
        
        





class Solution(object):
    def minOperations(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums)
        ans = 0
        for i in range(n-2,-1,-1):
            while nums[i] > nums[i+1]:
                if smallest[nums[i]] == nums[i]:
                    return -1
                nums[i] = smallest[nums[i]]
                ans += 1
        return ans
        
        ",1427837415
colicon,colicon,61,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        s = [ord(x)-ord('a') for x in s]
        tot = [0] * 26

        ans = 0

        n = len(s)
        j = 0
        for i in range(n):
            while j < n and max(tot) < k:
                tot[s[j]] += 1
                j += 1
            
            if max(tot) >= k:
                ans += n - j + 1

            tot[s[i]] -= 1
    
        return ans
            
                
",1427835373
colicon,colicon,61,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        target = list(target)
        a = []

        c = []
        while c != target:
            if not c or c[-1] == target[len(c)-1]:
                c.append('a')
            else:
                c[-1] = chr(ord(c[-1]) + 1)
            a.append(''.join(c))

        return a",1427827188
colicon,colicon,61,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)

        adj = [[] for _ in range(n)]
        for i in range(1, n):
            adj[parent[i]].append(i)
        
        MOD = 10**9 + 7
        b = 31
        pw = [1] * (n+1)
        for i in range(1, n+1):
            pw[i] = pw[i-1] * b % MOD

        dp = [[0]*3 for _ in range(n)]
        
        ans = [0] * n

        def dfs(c):
            adj[c].sort()

            for ne in adj[c]:
                dfs(ne)

                dp[c][0] += pw[dp[c][2]] * dp[ne][0]
                dp[c][0] %= MOD
                dp[c][1] = dp[c][1] * pw[dp[ne][2]] + dp[ne][1]
                dp[c][1] %= MOD
                
                dp[c][2] += dp[ne][2]

            dp[c][0] += pw[dp[c][2]] * ord(s[c])
            dp[c][0] %= MOD
            dp[c][1] = dp[c][1] * b + ord(s[c])
            dp[c][1] %= MOD

            dp[c][2] += 1

            ans[c] = dp[c][0] == dp[c][1]


        dfs(0)

        return ans",1427870939
colicon,colicon,61,3607,python3,"mx = 10**6 + 1
div = [1] * mx

for i in range(2, mx):
    for j in range(2*i, mx, i):
        div[j] = i

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0

        n = len(nums)
        for i in range(n-2, -1, -1):
            while nums[i] > nums[i+1] and div[nums[i]] != 1:
                nums[i] //= div[nums[i]]
                ans += 1
            
            if nums[i] > nums[i+1]:
                return -1

        return ans

        ",1427846291
Xiaomeng Yang,yangxm,63,3502,cpp,"constexpr int MAX = 32;

int cnt[MAX];

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
      int n = s.length(), ret = 0;
      for (int i = 0; i < n; ++i) {
        memset(cnt, 0, sizeof(cnt));
        int cur = 0;
        for (int j = i; j < n; ++j) {
          ++cnt[s[j] - 'a'];
          cur = max(cur, cnt[s[j] - 'a']);
          if (cur >= k) {
            ++ret;
          }
        }
      }
      return ret;
    }
};",1427827499
Xiaomeng Yang,yangxm,63,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
      vector<string> ret;
      string cur = """";
      for (char ch : target) {
        cur.push_back('a');
        ret.push_back(cur);
        for (int i = 0; i < ch - 'a'; ++i) {
          cur.back() = 'a' + i + 1;
          ret.push_back(cur);
        }
      }
      return ret;
    }
};",1427825449
Xiaomeng Yang,yangxm,63,3603,cpp,"using i64 = long long;

constexpr int MAX = 100010;
constexpr i64 P = 131;
constexpr i64 Q = 997;
constexpr i64 MP = 999999937;
constexpr i64 MQ = 1000000007;

i64 Pow(i64 a, i64 b, i64 p) {
  i64 ret = 1;
  for (a %= p; b; b >>= 1) {
    if (b & 1) {
      ret = ret * a % p;
    }
    a = a * a % p;
  }
  return ret;
}

i64 Inv(i64 x, i64 p) { return Pow(x, p - 2, p); }

template<i64 P, i64 MOD>
struct Hash {
  i64 sum[MAX], inv[MAX];

  void Assign(const string& s) {
    int n = s.length();
    sum[0] = 0;
    inv[0] = 1;
    i64 w = 1;
    for (int i = 0; i < n; ++i) {
      sum[i + 1] = (sum[i] + (i64)(s[i]) * w) % MOD;
      w = w * P % MOD;
      inv[i + 1] = Inv(w, MOD);
    }
  }

  i64 Query(int l, int r) const {
    i64 ret = (sum[r] - sum[l] + MOD) % MOD;
    return ret * inv[l] % MOD;
  }
};

vector<int> adj[MAX];
int l[MAX], r[MAX];

string str, rev;
Hash<P, MP> h1, r1;
Hash<Q, MQ> h2, r2;

void DFS(const string& s, int x, int p, string& ret) {
  l[x] = ret.length();
  for (int y : adj[x]) {
    if (y != p) {
      DFS(s, y, x, ret);
    }
  }
  ret.push_back(s[x]);
  r[x] = ret.length();
}

bool Query(int n, int x) {
  i64 x1 = h1.Query(l[x], r[x]);
  i64 y1 = r1.Query(n - r[x], n - l[x]);
  i64 x2 = h2.Query(l[x], r[x]);
  i64 y2 = r2.Query(n - r[x], n - l[x]);
  return x1 == y1 && x2 == y2;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
      int n = parent.size();
      for (int i = 0; i < n; ++i) {
        vector<int>().swap(adj[i]);
      }
      for (int i = 0; i < n; ++i) {
        int p = parent[i];
        if (p != -1) {
          adj[p].push_back(i);
        }
      }
      str.clear();
      rev.clear();
      DFS(s, 0, -1, str);
      rev = str;
      reverse(rev.begin(), rev.end());
      h1.Assign(str);
      h2.Assign(str);
      r1.Assign(rev);
      r2.Assign(rev);
      vector<bool> ret(n, false);
      for (int i = 0; i < n; ++i) {
        ret[i] = Query(n, i);
      }
      return ret;
    }
};",1427881141
Xiaomeng Yang,yangxm,63,3607,cpp,"constexpr int MAX = 1000100;

int a[MAX], p[MAX];

void Prime() {
  int n = 0;
  for (int i = 2; i < MAX; ++i) {
    if (!a[i]) {
      a[i] = i;
      p[n++] = i;
    }
    for (int j = 0; i * p[j] < MAX; ++j) {
      a[i * p[j]] = p[j];
      if (!(i % p[j])) {
        break;
      }
    }
  }
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
      static bool init = []() {
        Prime();
        return true;
      }();

      int n = nums.size(), ret = 0;
      for (int i = n - 1; i > 0; --i) {
        if (nums[i - 1] > nums[i]) {
          int v = a[nums[i - 1]];
          if (v > nums[i]) {
            return -1;
          }
          nums[i - 1] = v;
          ++ret;
        }
      }
      return ret;
    }
};",1427836768
Ryan Guo,ryanguorocket,64,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ret = 0;
        int n = s.length();
        for(int i = 0; i < n; i++) {
            vector<int> freq(26);
            bool good = false;
            for(int j = i; j < n; j++) {
                int c = s[j] - 'a';
                freq[c]++;
                if(freq[c] >= k) good = true;
                if(good) ret++;
            }
        }
        return ret;
    }
};",1427830890
Ryan Guo,ryanguorocket,64,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ret;
        string cur = """";
        for(int i = 0; i < target.length(); i++) {
            for(int j = 0; j <= int(target[i] - 'a'); j++) {
                ret.push_back(cur + char('a' + j));
            }
            cur += target[i];
        }
        return ret;
    }
};",1427827840
Ryan Guo,ryanguorocket,64,3603,cpp,"
const int mod1 = 10889991;
const int mod2 = 12356487;

struct Hash {
    int h1, h2;
    Hash() {h1 = h2 = 0;}
    Hash(int nv) {h1 = h2 = nv;}
    Hash(int nh1, int nh2) {
        h1 = nh1;
        h2 = nh2;
    }
    Hash operator + (int a) const {return Hash((h1 + a) % mod1, (h2 + a) % mod2);}
    Hash operator + (const Hash &a) const {return Hash((h1 + a.h1) % mod1, (h2 + a.h2) % mod2);}
    Hash& operator += (int a) {
        h1 = (h1 + a) % mod1;
        h2 = (h2 + a) % mod2;
        return *this;
    }
    Hash& operator += (const Hash &a) {
        h1 = (h1 + a.h1) % mod1;
        h2 = (h2 + a.h2) % mod2;
        return *this;
    }
    Hash operator - (int a) const {return Hash((h1 - a + mod1) % mod1, (h2 - a + mod2) % mod2);}
    Hash operator - (const Hash &a) const {return Hash((h1 - a.h1 + mod1) % mod1, (h2 - a.h2 + mod2) % mod2);}
    Hash& operator -= (int a) {
        h1 = (h1 - a + mod1) % mod1;
        h2 = (h2 - a + mod2) % mod2;
        return *this;
    }
    Hash& operator -= (const Hash &a) {
        h1 = (h1 - a.h1 + mod1) % mod1;
        h2 = (h2 - a.h2 + mod2) % mod2;
        return *this;
    }
    Hash operator * (int a) const {return Hash(((long long)h1 * a) % mod1, ((long long)h2 * a) % mod2);}
    Hash operator * (const Hash &a) const {return Hash(((long long)h1 * a.h1) % mod1, ((long long)h2 * a.h2) % mod2);}
    Hash& operator *= (int a) {
        h1 = ((long long)h1 * a) % mod1;
        h2 = ((long long)h2 * a) % mod2;
        return *this;
    }
    Hash& operator *= (const Hash &a) {
        h1 = ((long long)h1 * a.h1) % mod1;
        h2 = ((long long)h2 * a.h2) % mod2;
        return *this;
    }
    Hash& operator = (int a) {
        h1 = a % mod1, h2 = a % mod2;
        return *this;
    }
    Hash& operator = (const Hash &a) {
        h1 = a.h1, h2 = a.h2;
        return *this;
    }
    bool operator == (int a) const {return (h1 == a && h2 == a);}
    bool operator == (const Hash &a) const {return (h1 == a.h1 && h2 == a.h2);}
    bool operator != (int a) const {return !(h1 == a && h2 == a);}
    bool operator != (const Hash &a) const {return !(h1 == a.h1 && h2 == a.h2);}
    bool operator < (const Hash &a) const {return make_pair(h1, h2) < make_pair(a.h1, a.h2);}
    friend ostream& operator << (ostream &os, const Hash &a) {
        os << ""{"" << a.h1 << "", "" << a.h2 << ""}"";
        return os;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> si(n);
        vector<Hash> f(n, Hash(0)), b(n, Hash(0));
        vector<vector<int>> adj(n);
        vector<Hash> base(n + 1);
        base[0] = Hash(1);
        for(int i = 1; i <= n; i++) base[i] = base[i - 1] * 26;
        for(int i = 0; i < n; i++) {
            if(parent[i] != -1) {
                adj[parent[i]].push_back(i);
            }
        }
        auto dfs = [&](int p, auto &&self)->void {
            for(int i: adj[p]) {
                self(i, self);
            }
            si[p] = 1;
            for(int i: adj[p]) si[p] += si[i];
        };
        dfs(0, dfs);

        auto fdfs = [&](int p, auto&& self)->void {
            if(adj[p].empty()) {
                f[p] = s[p] - 'a';
                return;
            }
            for(int i: adj[p]) {
                self(i, self);
            }
            Hash cur = 0;
            int cnt = 0;
            for(int j = adj[p].size() - 1; j >= 0; j--) {
                int i = adj[p][j];
                cur += f[i] * base[cnt];
                cnt += si[i];
            }
            cur *= 26;
            cur += s[p] - 'a';
            f[p] = cur;
        };
        fdfs(0, fdfs);

        auto bdfs = [&](int p, auto&& self)->void {
            if(adj[p].empty()) {
                b[p] = Hash(s[p] - 'a');
                return;
            }
            for(int i: adj[p]) {
                self(i, self);
            }
            Hash cur = s[p] - 'a';
            //int cnt = 1;
            for(int j = adj[p].size() - 1; j >= 0; j--) {
                int i = adj[p][j];
                //cur += b[i] * base[cnt];
                //cnt += si[i];
                cur *= base[si[i]];
                cur += b[i];
            }
            b[p] = cur;
        };
        bdfs(0, bdfs);

        // for(int i = 0; i < n; i++) {
        //     cout << f[i] << "" "" << b[i] << ""\n"";
        // }

        vector<bool> ret(n);
        for(int i = 0; i < n; i++) {
            ret[i] = (f[i] == b[i]);
        }
        return ret;
    }
};",1427881289
Ryan Guo,ryanguorocket,64,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        auto get = [&](int v) {
            for(int i = 2; i <= sqrt(v); i++) {
                if(v % i == 0) return i;
            }
            return -1;
        };
        int ret = 0;
        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] > nums[i + 1]) {
                int gv = get(nums[i]);
                if(gv == -1) return -1;
                if(gv > nums[i + 1]) return -1;
                nums[i] = gv;
                ret++;
            }
        }
        return ret;
    }
};",1427837680
zokumyoin,zokumyoin,65,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int hi = 0;
        int ans = 0;
        int[] cnt = new int[26];
        int maxF = 0;
        for (int lo = 0; lo < s.length(); lo++) {
            while (hi < s.length() && maxF < k) {
                cnt[s.charAt(hi) - 'a']++;
                maxF = Math.max(maxF, cnt[s.charAt(hi) - 'a']);
                hi++;
            }
            if (maxF == k) {
                ans += s.length() - hi + 1;
            }
            int prev = s.charAt(lo) - 'a';
            if (cnt[prev] == maxF) {
                cnt[prev]--;
                maxF = 0;
                for (int v : cnt) {
                    maxF = Math.max(maxF, v);
                }
            } else {
                cnt[prev]--;
            }
        }
        return ans;

    }
}",1427828807
zokumyoin,zokumyoin,65,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        String pref = """";
        for (int i = 0; i < target.length(); i++) {
            for (char c = 'a'; c <= target.charAt(i); c++) {
                ans.add(pref + c);
            }
            pref += target.charAt(i);
        }
        return ans;
        
    }
}",1427824374
zokumyoin,zokumyoin,65,3603,java,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    int N;
    long P = 1001;
    long Q = 1926_0817;
    long MOD = 1_000_000_007;
    long[] p;
    long[] q;

    public boolean[] findAnswer(int[] parent, String s) {

        N = parent.length;
        p = new long[N + 1];
        q = new long[N + 1];
        p[0] = 1;
        q[0] = 1;
        for (int i = 1; i < N; i++) {
            p[i] = p[i - 1] * P % MOD;
            q[i] = q[i - 1] * Q % MOD;
        }

        List<List<Integer>> children = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            children.add(new ArrayList<>());
        }
        for (int i = 1; i < N; i++) {
            int p = parent[i];
            children.get(p).add(i);
        }
        boolean[] ans = new boolean[N];
        Arrays.fill(ans, true);
        dfs(0, s, children, ans, P, p);
        dfs(0, s, children, ans, Q, q);
        return ans;
    }

    private long[] dfs(int v, String s, List<List<Integer>> children, boolean[] ans, long prime, long[] pow) {

        int c = s.charAt(v) - 'a';
        if (children.get(v).isEmpty()) {
            ans[v] = true;
            return new long[]{c, c, 1};
        }


        List<Long> inOrder = new ArrayList<>();
        List<Long> reverse = new ArrayList<>();
        List<Long> size = new ArrayList<>();
        long totalSize = 0;
        for (int w : children.get(v)) {
            long[] sub = dfs(w, s, children, ans, prime, pow);
            inOrder.add(sub[0]);
            reverse.add(sub[1]);
            size.add(sub[2]);
            totalSize += sub[2];
        }
        long l = 0;
        for (int i = 0; i < children.get(v).size(); i++) {
            long hash = inOrder.get(i);
            int sz = (int) ((long) size.get(i));
            l *= pow[sz];
            l %= MOD;
            l += hash;
            l %= MOD;
        }
        l *= prime;
        l %= MOD;
        l += c;
        l %= MOD;


        long r = c;
        for (int i = children.get(v).size() - 1; i >= 0; i--) {
            long hash = reverse.get(i);
            int sz = (int) ((long) size.get(i));
            r *= pow[sz];
            r %= MOD;
            r += hash;
            r %= MOD;
        }
        ans[v] &= (l == r);
        return new long[]{l, r, totalSize + 1};
    }
}",1427873213
zokumyoin,zokumyoin,65,3607,java,"class Solution {
    public int minOperations(int[] arr) {
        int ans = 0;
        for (int i = arr.length - 2; i >= 0; i--) {
            int next = arr[i + 1];
            int cur = arr[i];
            while (cur > next) {
                int maxDiv = maxDiv(cur);
                if (maxDiv == -1) {
                    return -1;
                }
                ans++;
                cur /= maxDiv;
            }
            arr[i] = cur;
        }
        return ans;

    }

    private int maxDiv(int v) {
        for (int d = 2; d * d <= v; d++) {
            if (v % d == 0) {
                return v / d;
            }
        }
        return -1;
    }
}",1427836187
Evan Tian,etian6795,66,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int ans = 0;
        
        for(int i = 0; i < n; i++) {
            int[] f = new int[26];
            int qwe = 0;
            
            for(int j = i; j < n; j++) {
                f[s.charAt(j) - 'a']++;
                
                if(f[s.charAt(j) - 'a'] == k) {
                    qwe++;
                }
                
                if(qwe > 0) {
                    ans++;
                }
            }
        }
        
        return ans;
    }
}
",1427854801
Evan Tian,etian6795,66,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < target.length(); i++) {
            sb.append('a');
            ans.add(sb.toString());
            for(int j = 0; j < target.charAt(i)-'a'; j++) {
                sb.deleteCharAt(sb.length()-1);
                sb.append((char)('a'+j+1));
                ans.add(sb.toString());
            }
        }
        return ans;
    }
}",1427855009
Evan Tian,etian6795,66,3603,java,"import java.util.*;

class Solution {
    public long base = 911;
    public long mod = 1000000007L;
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        
        ArrayList<ArrayList<Integer>> children = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            children.add(new ArrayList<>());
        }
        for(int i = 0; i < n; i++) {
            if(parent[i] != -1){
                children.get(parent[i]).add(i);
            }
        }
        
        for(int i = 0; i < n; i++) {
            Collections.sort(children.get(i));
        }
        
        int maxLen = n + 1;
        long[] pow = new long[maxLen + 1];
        pow[0] = 1;
        for(int i = 1; i <= maxLen; i++) {
            pow[i] = (pow[i - 1] * base) % mod;
        }
        
        long[] forwardHash = new long[n];
        long[] reverseHash = new long[n];
        int[] len = new int[n];
        
        qwe(0, children, s, pow, forwardHash, reverseHash, len);
        
        boolean[] answer = new boolean[n];
        for(int i = 0; i < n; i++) {
            answer[i] = (forwardHash[i] == reverseHash[i]);
        }
        
        return answer;
    }
    
    private void qwe(int x, ArrayList<ArrayList<Integer>> children, String s, long[] pow, long[] forwardHash, long[] reverseHash, int[] len) {
        len[x] = 1;
        forwardHash[x] = 0;
        
        for(int y : children.get(x)) {
            qwe(y, children, s, pow, forwardHash, reverseHash, len);
            forwardHash[x] = (forwardHash[x] * pow[len[y]] + forwardHash[y]) % mod;
            len[x] += len[y];
        }
        
        forwardHash[x] = (forwardHash[x] * base + (s.charAt(x) - 'a' + 1)) % mod;
        
        reverseHash[x] = (s.charAt(x) - 'a' + 1);
        ArrayList<Integer> childs = children.get(x);
        for(int i = childs.size() - 1; i >= 0; i--){
            int y = childs.get(i);
            reverseHash[x] = (reverseHash[x] * pow[len[y]] + reverseHash[y]) % mod;
        }
    }
}
",1427854205
Evan Tian,etian6795,66,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        int n = nums.size();
        int max_val = 0;
        
        // Find the maximum value in the array
        for(int x : nums) {
            max_val = max(max_val, x);
        }
        
        // Run the linear sieve to fill 'lp' and 'pr'
        linSieve(max_val);
        
        // Process the array from right to left
        for(int i = n - 2; i >= 0; i--) {
            while(nums[i] > nums[i + 1]) {
                if(nums[i] == lp[nums[i]]) return -1;
                nums[i] = lp[nums[i]];
                ans++;
            }
        }
        
        return ans;
    }

    vector<int> lp;
    vector<int> pr;

    void linSieve(int N) {
        lp.resize(N + 1);
        for(int i = 2; i <= N; i++) {
            if(lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for(int j = 0; j < pr.size() && i * pr[j] <= N; j++) {
                lp[i * pr[j]] = pr[j];
                if(pr[j] == lp[i]) break;
            }
        }
    }
};",1427865745
Dylan Smith,DylanSmith,67,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res = 0;
        for (int i = 0; i < (int)s.size(); i++) {
            vector<int> freq(26, 0);
            for (int j = i; j < (int)s.size(); j++) {
                freq[s[j] - 'a']++;
                if (freq[s[j] - 'a'] >= k) {
                    res += (int)s.size() - j;
                    break;
                }
            }
        }
        return res;
    }
};",1427826457
Dylan Smith,DylanSmith,67,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        vector<string> res;
        for (char c : target) {
            char c2 = 'a';
            res.push_back(s + c2);
            while (c2 != c) {
                c2++;
                res.push_back(s + c2);
            }
            s += c2;
        }
        return res;
    }
};",1427824280
Dylan Smith,DylanSmith,67,3603,cpp,"typedef long long ll;
 
#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

mt19937 rng;

ll radix = 26, mod = 1;

// kactl
typedef unsigned long long ull;
ull modmul(ull a, ull b, ull M) {
    ll ret = a * b - M * ull(1.L / M * a * b);
    return ret + M * (ret < 0) - M * (ret >= (ll)M);
}
ull modpow(ull b, ull e, ull mod) {
    ull ans = 1;
    for (; e; b = modmul(b, b, mod), e /= 2)
        if (e & 1) ans = modmul(ans, b, mod);
    return ans;
}
bool isPrime(ull n) {
    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;
    ull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},
        s = __builtin_ctzll(n-1), d = n >> s;
    for (ull a : A) {   // ^ count trailing zeroes
        ull p = modpow(a%n, d, n), i = s;
        while (p != 1 && p != n - 1 && a % n && i--)
            p = modmul(p, p, n);
        if (p != n-1 && i != s) return 0;
    }
    return 1;
}
void setRandModLL() { mod = abs((long long)((ll)rng() << 32 ^ rng()) % 1000000000000000000LL + 100000000000000000LL); if (!isPrime(mod)) setRandModLL(); }

vector<ll> radixPows;
void prec() {
    rng = mt19937(chrono::steady_clock::now().time_since_epoch().count());
    setRandModLL();
    radixPows = vector<ll>(1000001, 0);
    ll cur = 1;
    for (int i = 0; i <= 1000000; i++) {
        radixPows[i] = cur;
        cur = (__int128)cur * radix % mod;
    }
}

vector<ll> preHash(string s) {
    vector<ll> res(sz(s), 0);
    for (int i = 0; i < sz(s); i++) {
        res[i] = ((__int128)(i == 0 ? 0 : res[i - 1]) * radix + s[i] - 'a') % mod;
    }
    return res;
}

ll subHash(vector<ll> &pre, int l, int r) {
    return (pre[r] - (__int128)(l == 0 ? 0 : pre[l - 1]) * radixPows[r - l + 1] % mod + mod) % mod;
}

bool first = 1;

class Solution {
public:
    vector<vector<int>> adj;
    string srt;
    vector<int> cnt, pos;
    void dfs(string &s, int u) {
        sort(adj[u].begin(), adj[u].end());
        for (int v : adj[u]) {
            dfs(s, v);
            cnt[u] += cnt[v];
        }
        pos[u] = (int)srt.size();
        srt += s[u];
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        if (first) {
            first = 0;
            prec();
        }
        int N = (int)parent.size();
        adj = vector<vector<int>>(N);
        for (int i = 1; i < N; i++) adj[parent[i]].pb(i);
        cnt = vector<int>(N, 1);
        pos = vector<int>(N);
        dfs(s, 0);
        vector<ll> pre = preHash(srt);
        reverse(all(srt));
        vector<ll> rev = preHash(srt);
        vector<bool> res;
        for (int i = 0; i < N; i++) {
            int r = pos[i], l = pos[i] - cnt[i] + 1;
            res.push_back(subHash(pre, l, r) == subHash(rev, N - 1 - r, N - 1 - l));
        }
        return res;
    }
};",1427865867
Dylan Smith,DylanSmith,67,3607,cpp,"vector<int> last;
bool first = 1;
void prec() {
    last = vector<int>(1000001, -1);
    for (int i = 2; i <= 1000000; i++) {
        for (int j = i * 2; j <= 1000000; j += i) {
            last[j] = i;
        }
    }
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (first) {
            first = 0;
            prec();
        }
        int cur = INT_MAX;
        int res = 0;
        for (int i = (int)nums.size() - 1; i >= 0; i--) {
            if (nums[i] > cur) {
                if (last[nums[i]] >= 2) {
                    nums[i] /= last[nums[i]];
                    res++;
                }
                if (nums[i] > cur) return -1;
            }
            cur = nums[i];
        }
        return res;
    }
};",1427836723
pika_code,pika_code,68,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n=len(s)
        r=0
        for i in range(n):
            f=[0]*26
            c=0
            for j in range(i,n):
                idx=ord(s[j])-97
                f[idx]+=1
                if f[idx]==k:
                    c+=1
                if c>0:
                    r+=1
        return r",1427824004
pika_code,pika_code,68,3566,python3,"from typing import List
class Solution:
    def stringSequence(self, target: str) -> List[str]:
        r=[]
        s=''
        for c in target:
            s+='a'
            r.append(s)
            if c!='a':
                n=(ord(c)-97)%26
                for _ in range(n):
                    s=s[:-1]+chr((ord(s[-1])-97+1)%26+97)
                    r.append(s)
        return r",1427823832
pika_code,pika_code,68,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        for ch in children:
            ch.sort()
        mod = 10**9 + 7
        base = 911
        pow_base = [1] * (n + 2)
        for i in range(1, n + 2):
            pow_base[i] = (pow_base[i - 1] * base) % mod
        res = [False] * n
        def dfs(x):
            h = 0
            rh = 0
            l = 0
            child_data = []
            for y in children[x]:
                hy, rhy, ly = dfs(y)
                h = (h * pow_base[ly] + hy) % mod
                child_data.append((rhy, ly))
                l += ly
            c_val = ord(s[x]) - ord('a') + 1
            h = (h * base + c_val) % mod
            l += 1
            rh = c_val
            for rhy, ly in reversed(child_data):
                rh = (rh * pow_base[ly] + rhy) % mod
            res[x] = (h == rh)
            return h, rh, l
        dfs(0)
        return res",1427835321
pika_code,pika_code,68,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        mx = 32000
        sv = [True] * mx
        pr = []
        for i in range(2, mx):
            if sv[i]:
                pr.append(i)
                for j in range(i*i, mx, i):
                    sv[j] = False
        def spf(x):
            for p in pr:
                if p*p > x:
                    break
                if x % p == 0:
                    return p
            return x
        res = 0
        mn = float('inf')
        for i in range(n - 1, -1, -1):
            while nums[i] > mn:
                if nums[i] == 1:
                    return -1
                f = spf(nums[i])
                if f == nums[i]:
                    return -1
                nums[i] = f
                res +=1
            mn = nums[i]
        return res",1427849744
JeffreyLC,JeffreyLC,69,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = s.length();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> cnt(26);
            for (int j = i; j < n; ++j) {
                if (++cnt[s[j] - 'a'] == k) {
                    ans += n - j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427826351
JeffreyLC,JeffreyLC,69,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string str = """";
        vector<string> ans;
        while (str != target) {
            if (str.empty()) {
                str += ""a"";
            } else {
                const int n = str.length();
                if (str[n - 1] == target[n - 1]) {
                    str += ""a"";
                } else {
                    ++str.back();
                }
            }
            ans.push_back(str);
        }
        return ans;
    }
};",1427824455
JeffreyLC,JeffreyLC,69,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        const int n = parent.size();
        c.resize(n);
        t.resize(n);
        for (int i = 1; i < n; ++i) {
            c[parent[i]].push_back(i);
        }
        explore(0, s);
        
        vector<int> m = Manacher(str);
        
        vector<bool> ans(n);
        for (int i = 0; i < n; ++i) {
            int idx = t[i].first + t[i].second;
            int len = t[i].second - t[i].first + 1;
            ans[i] = (m[idx] >= (len + 1) / 2);
        }
        return ans;
    }
private:
    vector<vector<int>> c;
    vector<pair<int, int>> t;
    string str;
    int idx = -1;
    
    void explore(int x, const string& s) {
        int tin = INT_MAX;
        for (int y : c[x]) {
            explore(y, s);
            tin = min(tin, t[y].first);
        }
        ++idx;
        if (tin == INT_MAX) {
            tin = idx;
        }
        str += s[x];
        t[x] = {tin, idx};
    }
    
    vector<int> Manacher(const string& str) {
        function<vector<int>(string)> manacher_odd = [](const string& str) {
            const int n = str.length();
            vector<int> p(n);
            for (int i = 0, l = 0, r = 0; i < n; ++i) {
                p[i] = max(0, min(r - i, l + (r - i) == -1 ? 0 : p[l + (r - i)]));
                while (i - p[i] >= 0 && i + p[i] < n && str[i - p[i]] == str[i + p[i]]) {
                    ++p[i];
                }
                if (i + p[i] > r) {
                    l = i - p[i];
                    r = i + p[i];
                }
            }
            return p;
        };

        string t = ""#"";
        for (char c : str) {
            t += c + string(""#"");
        }
        vector<int> res = manacher_odd(t);
        for_each(res.begin(), res.end(), [](int &num) {
            num /= 2;
        });
        return vector<int>(res.begin() + 1, res.end() - 1);
    }
};",1427882499
JeffreyLC,JeffreyLC,69,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int n = nums.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                change(nums[i]);
                ++ans;
            }
            if (nums[i] > nums[i + 1]) return -1;
        }
        return ans;
    }
private:
    void change(int& num) {
        for (int i = 2; i * i <= num; ++i) {
            if (num % i == 0) {
                num = i;
            }
        }
    }
};",1427833801
AntonRaichuk,AntonRaichuk,70,3502,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

int a[26];
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int r=0;
        REP(i,s.size()){
            CL(a,0);
            int mx=0;
            FOR(j,i,s.size()){
                a[s[j]-'a']++;
                if(a[s[j]-'a']>a[mx])mx=s[j]-'a';
                if(a[mx]>=k)r++;
            }
        }
        return r;
    }
};",1427826874
AntonRaichuk,AntonRaichuk,70,3566,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    vector<string> stringSequence(string target) {
        string s;
        vector<string> r;
        while(s!=target){
            if(s.empty() || s.back() == target[s.size()-1]){
                s.pb('a');
            }else{
                s.back()++;
            }
            r.pb(s);
        }
        return r;
    }
};",1427824902
AntonRaichuk,AntonRaichuk,70,3603,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

vi v[111111];
string s;
string t;
pii a[111111];

void dfs(int ver){
    a[ver].first=t.size();
    REP(i,v[ver].size())dfs(v[ver][i]);
    t.pb(s[ver]);
    a[ver].second=t.size();
}

ll h1[111111];
ll h2[111111];
const ll mod = 10007;
const ll mod1 = 1ll<<31;
const ll mod2 = 1000000007;
string tr;
ll hr1[111111];
ll hr2[111111];
ll st1[111111];
ll st2[111111];

ll geth(ll* h, ll* st,int pos,int len, ll m){
    //cout<<h<<' '<<st<<' '<<len<<' '<<pos<<' '<<pos+len-1<<' '<<s.size()<<endl;
    ll z = h[pos+len-1]-(pos-1>=0?h[pos-1]:0)*st[len];
    z%=m;
    if(z<0)z+=m;
    return z;
}
pl gethh(ll* h1, ll* h2, int pos, int len){
    return {geth(h1,st1,pos,len,mod1),geth(h2,st2,pos,len,mod2)};
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string S) {
        s=S;
        REP(i,p.size())v[i].clear();
        REP(i,p.size())if(p[i]!=-1)v[p[i]].pb(i);
        REP(i,p.size())SORT(v[i]);
        t="""";
        dfs(0);
        tr=t;
        reverse(tr.begin(),tr.end());
        REP(i,p.size()){
            h1[i]=((i-1>=0?h1[i-1]:0)*mod+t[i]-'a'+1)%mod1;
            h2[i]=((i-1>=0?h2[i-1]:0)*mod+t[i]-'a'+1)%mod2;
            hr1[i]=((i-1>=0?hr1[i-1]:0)*mod+tr[i]-'a'+1)%mod1;
            hr2[i]=((i-1>=0?hr2[i-1]:0)*mod+tr[i]-'a'+1)%mod2;
        }
        st1[0]=1;
        st2[0]=1;
        FOR(i,1,p.size()+1){
            st1[i]=(st1[i-1]*mod)%mod1;
            st2[i]=(st2[i-1]*mod)%mod2;
        }
        vector<bool> r;
        REP(i,p.size()){
            int from = a[i].first;
            int to = a[i].second-1;
            int len = (to-from+1);
            if(len==1)r.pb(1);
            else{
                len/=2;
                //cout<<from<<' '<<to<<' '<<p.size()<<endl;
                pl hh1=gethh(h1,h2,from,len);
                pl hh2=gethh(hr1,hr2,p.size()-1-to,len);
                r.pb(hh1==hh2);
            }
        }
        return r;
    }
};",1427866011
AntonRaichuk,AntonRaichuk,70,3607,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

int p[1111111];

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(p[4]==0){
            for(int i=2;i<1111111;i++)if(p[i]==0){
                for(ll j=ll(i)*i;j<1111111;j+=i){
                    if(p[j]==0)p[j]=i;
                }
            }
        }
        int r = 0;
        for(int i=int(nums.size())-2;i>=0;i--){
            if(nums[i]<=nums[i+1])continue;
            if(p[nums[i]]==0)return -1;
            r++;
            nums[i]=p[nums[i]];
            if(nums[i]>nums[i+1])return -1;
        }
        return r;
    }
};",1427834154
Sanmai Reddy,sanmai_reddy377,71,3502,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
// #define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=2e3+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        ll n=s.size(),ans=0;
        for(int i=0;i<n;i++){
           vll ct(26);
           ll f=0;
           for(int j=i;j<n;j++){
              ct[s[j]-'a']++;
              if(ct[s[j]-'a']>=k || f){
                f=1;
                ans++;
              }
           }
        }
        return ans;
    }
};",1427830743
Sanmai Reddy,sanmai_reddy377,71,3566,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
// #define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=2e3+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string> ans;
        ll n=s.size(),ind=0;
        string c="""";
        while(ind<n){
            if(c.size()==ind){
                c+='a';
            }
            else if(s[ind]>c[ind]){
              c[ind]=c[ind]+1;
            }
            else{
                ind++;
                continue;
            }
            ans.pb(c);
        }
        return ans;
    }
};",1427826140
Sanmai Reddy,sanmai_reddy377,71,3603,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
// #define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=2e3+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

//string and array hashing
#define MAXLEN 1000010
constexpr uint64_t mod = (1ULL << 61) - 1;
const uint64_t seed = chrono::system_clock::now().time_since_epoch().count();
const uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);
uint64_t base_pow[MAXLEN];

int64_t modmul(uint64_t a, uint64_t b){
    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;
    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;
    uint64_t ret = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;
    ret = (ret & mod) + (ret >> 61);
    ret = (ret & mod) + (ret >> 61);
    return ret - 1;
}

void init(){
    base_pow[0] = 1;
    for (int i = 1; i < MAXLEN; i++){
        base_pow[i] = modmul(base_pow[i - 1], base);
    }
}

struct PolyHash{
    /// Remove suff vector and usage if reverse hash is not required for more speed
    vector<int64_t> pref, suff;

    PolyHash() {}

    template <typename T>
    PolyHash(const vector<T>& ar){
        if (!base_pow[0]) init();

        int n = ar.size();
        assert(n < MAXLEN);
        pref.resize(n + 3, 0), suff.resize(n + 3, 0);

        for (int i = 1; i <= n; i++){
            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;
            if (pref[i] >= mod) pref[i] -= mod;
        }

        for (int i = n; i >= 1; i--){
            suff[i] = modmul(suff[i + 1], base) + ar[i - 1] + 997;
            if (suff[i] >= mod) suff[i] -= mod;
        }
    }

    PolyHash(const string &str)
        : PolyHash(vector<char> (str.begin(), str .end())) {}

    uint64_t get_hash(int l, int r){
        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);
        return h < 0 ? h + mod : h;
    }

    uint64_t rev_hash(int l, int r){
        int64_t h = suff[l + 1] - modmul(base_pow[r - l + 1], suff[r + 2]);
        return h < 0 ? h + mod : h;
    }
};

ll f=0;

class Solution {
public:
    ll n;
    vvll g;
    vll a,b;
    string t;

    void dfs(ll ind,string &s,ll &ct){
      t+=s[ind];
      a[ind]=ct;
      for(auto &k: g[ind]){
        ct++;
        dfs(k,s,ct);
      }
      b[ind]=ct;
    }

    vector<bool> findAnswer(vector<int>& p, string s) {
        if(f==0) init();
        f++;
        g.clear(); a.clear(); b.clear(); t.clear();
        n=s.size();
        g.resize(n); a.resize(n); b.resize(n);
        for(int i=1;i<n;i++){
           g[p[i]].pb(i);
        }
        for(auto &k: g) sort(rall(k));
        ll ct=0;
        dfs(0,s,ct);
        PolyHash hsh(t);
        vector<bool> ans(n);
        // disp(a)
        // disp(b)
        // de(t)
        for(int i=0;i<n;i++){
           ll val=(hsh.get_hash(a[i],b[i])==hsh.rev_hash(a[i],b[i]));
           ans[i]=val;
        }
        return ans;
    }
};",1427874469
Sanmai Reddy,sanmai_reddy377,71,3607,cpp,"#pragma GCC optimize(""unroll-loops,O3,Ofast"") //even 10^8+ also works with this
#pragma GCC target(""avx2,avx,fma,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;

#define pb push_back
#define ppb pop_back
#define ff first
#define ss second
#define rt return;
#define set_bits(a) __builtin_popcountll(a)
#define mine(a)    (*min_element((a).begin(), (a).end()))
#define maxe(a)    (*max_element((a).begin(), (a).end()))
#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())
#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())
#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())
#define disp(a) {for(int i=0;i<a.size();i++) cout<<a[i]<<"" ""; cout<<endl;}
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
#define inp(a) {for(int i=0;i<(a).size();i++) cin>>(a)[i];}
// #define fill(a,b) memset(a, b, sizeof(a))
#define prt(a) cout<<(a)<<endl;
#define endl ""\n""
#define NO cout<<""NO""<<endl;
#define YES cout<<""YES""<<endl;
#define vll vector<ll>
#define vvll vector<vector<ll>>
#define double double
#define de(a) cout<<""(""<<a<<"")""<<endl;
#define de2(a) cout<<""*""<<a<<""*""<<endl;
#define ft front()
#define bk back()
#define nl cout<<endl;
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define cont continue;
#define vpll vector<pair<ll,ll>>
#define vvii vector<vi>
#define vi vector<int>
#define vvpll vector<vector<pair<ll,ll>>>
#define pll pair<ll,ll>
#define ld long double

template<class T> using minpq = priority_queue<T,vector<T>,greater<T>>;
template<class T> using maxpq = priority_queue<T>;

//const ll M=998244353;
const ll M=1e9+7;
const ll N=2e3+2;  
const ll inf=1e18; //keeping inf may not give soln every time,try 1e9, 1e15

bool isOverflow(ll x, ll y){return (x > LLONG_MAX / y or y > LLONG_MAX / x);}
ll bit(ll n,ll i){return (n&(1LL<<i)) ? 1 : 0;}
void unset(ll &n,ll i){ if((n&(1LL<<i))!=0) n-=(1LL<<i);}
void makeset(ll &n,ll i){ if((n&(1LL<<i))==0) n+=(1LL<<i);}
ll add(ll a,ll b){return ((a%M) + (b%M))%M;}
ll mul(ll a,ll b){return ((a%M) * (b%M))%M;}
ll sub(ll a,ll b){return ((a%M) - (b%M) + M)%M;}
ll isPail(string &s){string t=s; reverse(all(t)); return s==t; }

vll dx{-1,0,1,0},dy{0,-1,0,1};

class Solution {
public:
    ll f(ll a){
       for(int i=2;i*i<=a;i++){
         if(a%i==0) return i;
       }
       return -1;
    }
    int minOperations(vector<int>& v) {
        ll n=v.size(),ans=0;
        for(int i=n-1;i>0;i--){
          if(v[i-1]>v[i]){
            ll val=f(v[i-1]);
            if(val==-1 || val>v[i]) return -1;
            ans++;
            v[i-1]=val;
          }
        }
        return ans;
    }
};",1427844228
Muhammad Hasan,mhasan01,72,3502,cpp,"const int A = 26;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int) s.size();
        multiset<int> ms = {-1};
        vector<int> cnt(A);
        int ans = 0;
        for (int l = 0, r = -1; l < n; l++) {
            while (r + 1 < n && *ms.rbegin() < k) {
                int x = s[r + 1] - 'a';
                if (ms.find(cnt[x]) != ms.end()) {
                    ms.erase(ms.find(cnt[x]));
                }
                cnt[x]++;
                ms.emplace(cnt[x]);
                r++;
            }
            if (*ms.rbegin() >= k) {
                ans += n - r;
            }
            int x = s[l] - 'a';
            if (ms.find(cnt[x]) != ms.end()) {
                ms.erase(ms.find(cnt[x]));
            }
            cnt[x]--;
            ms.emplace(cnt[x]);
        }
        return ans;
    }
};",1427882362
Muhammad Hasan,mhasan01,72,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        int n = (int) s.size();
        vector<string> res;
        string cur = """";
        for (int i = 0; i < n; i++) {
            if ((int) cur.size() < i + 1) {
                cur += ""a"";
            }
            while (cur[i] != s[i]) {
                res.emplace_back(cur);
                cur[i]++;
            }
            res.emplace_back(cur);
        }
        return res;
    }
};",1427882862
Muhammad Hasan,mhasan01,72,3603,cpp,"class Solution {
public:
    vector<int> manacher_odd(string s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    
    vector<bool> findAnswer(vector<int>& par, string s) {
        int n = (int) par.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++) {
            adj[par[i]].emplace_back(i);
        }
        for (int u = 0; u < n; u++) {
            sort(adj[u].begin(), adj[u].end());
        }
        vector<int> tin(n);
        vector<int> tout(n);
        int tim = 0;
        string str = ""#"";
        
        function<void(int)> dfs = [&](int u) {
            tin[u] = (int) str.size();
            for (int v : adj[u]) {
                dfs(v);
            }
            tout[u] = (int) str.size();
            str += s[u];
            str += ""#"";
        };
        
        dfs(0);
        vector<int> d = manacher_odd(str);
        vector<bool> ans(n);
        for (int u = 0; u < n; u++) {
            int l = tin[u];
            int r = tout[u];
            int len = r - l + 1;
            int mid = (l + r) / 2;
            ans[u] = (mid + d[mid] - 1 >= r);
        }
        return ans;
    }
};",1427878747
Muhammad Hasan,mhasan01,72,3607,cpp,"const int N = 1e6 + 5;

int p[N];
bool done = false;

class Solution {
public:
    int minOperations(vector<int>& a) {
        if (!done) {
            p[1] = 1;
            for (int i = 1; i < N; i++) {
                for (int j = i + i; j < N; j += i) {
                    p[j] = i;
                }
            }
            done = true;
        }
        int n = (int) a.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (a[i] <= a[i + 1]) {
                continue;
            }
            a[i] = a[i] / p[a[i]];
            if (a[i] > a[i + 1]) {
                return -1;
            }
            ++ans;
        }
        return ans;
    }
};",1427881529
Michael Yu,yumichael,73,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        answer = 0
        i = 0
        window = Counter()
        for j in range(n):
            window[s[j]] += 1
            while i <= j:
                window[s[i]] -= 1
                if window.most_common(1)[0][1] >= k:
                    i += 1
                else:
                    window[s[i]] += 1
                    break
            if window.most_common(1)[0][1] >= k:
                answer += i + 1
        return answer",1427835560
Michael Yu,yumichael,73,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        answer = []
        build = []
        for char in target:
            build.append(None)
            for i in range(ord(char) - ord('a') + 1):
                build[-1] = chr(ord('a') + i) # NOTE 1: Confused it as `append`.
                answer.append(''.join(build))
        return answer",1427825781
Michael Yu,yumichael,73,3603,python3,"class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []
    # NOTE 3: Didn't have dunder methods here.
    def __eq__(self, other):
        return self.value == other.value
    def __lt__(self, other):
        return self.value < other.value

def is_palindrome(s):
    n = len(s)
    first_half_end = (n - 2) // 2 # NOTE 4: Oops had that as `(n - 1)`.
    last_half_start = (n + 1) // 2
    return s[: first_half_end + 1] == s[: last_half_start - 1 : -1]

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        nodes = [TreeNode(i) for i in range(n)]
        for child, parent in enumerate(parent):
            if parent == -1:
                continue
            nodes[parent].children.append(nodes[child]) # NOTE 2: Forgot the `nodes[...]`.
        for i in range(n):
            nodes[i].children.sort()
        
        answer = [None] * n
        def recur(subroot):
            if not subroot:
                return ''
            else:
                children_results = []
                for child in subroot.children: # NOTE 1: Forgot I changed `left` and `right` to `chidren`.
                    children_results.append(recur(child))
                combined = ''.join(children_results + [s[subroot.value]])
                answer[subroot.value] = is_palindrome(combined)
                #print(subroot.value, combined)
                return combined
        recur(nodes[0])
        
        return answer",1427883251
Michael Yu,yumichael,73,3607,python3,"m = 1_000_000
a = [True] * (m + 1)
a[0] = a[1] = False
for i in range(2, int(m ** 0.5) + 1):
    a[i * i : m + 1 : i] = [False] * len(a[i * i : m + 1 : i])
primes = [i for i in range(m + 1) if a[i]]

def find_smallest_prime_factor(num):
    for prime in primes:
        if num % prime == 0:
            return prime

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        min_so_far = inf
        answer = 0
        for i in range(n - 1, -1, -1):
            if nums[i] > min_so_far:
                nums[i] = find_smallest_prime_factor(nums[i])
                answer += 1
            if nums[i] > min_so_far:
                return -1
            min_so_far = min(min_so_far, nums[i])
        return answer",1427847299
plevande,plevande,75,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        l = [[] for i in range(26)]
        curr = None 
        n = len(s)
        answer = 0 
        for i in range(n):
            c = s[i]
            c = ord(c)-ord('a')
            l[c].append(i)
            if len(l[c]) >= k:
                i1 = l[c][-1*k]
                if curr is None:
                    curr = i1 
                else:
                    curr = max(curr, i1)
            if curr is not None:
                answer+=(curr+1)
        return answer
        ",1427828327
plevande,plevande,75,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        answer = ['']
        for c in target:
            entry = []
            word = answer[-1]
            for i in range(ord(c)-ord('a')+1):
                c2 = chr(i+ord('a'))
                entry.append(word+c2)
            answer = answer+entry
        return answer[1:]
        ",1427824707
plevande,plevande,75,3603,python3,"p = 10**9+7
q = 998244353
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for i in range(n)]
        for i in range(n):
            pi = parent[i]
            if pi != -1:
                g[pi].append(i)
        start = [[0]]
        seen = [0 for i in range(n)]
        seen[0] = 1 
        while True:
            next_s = []
            for x in start[-1]:
                for y in g[x]:
                    next_s.append(y)
            if len(next_s)==0:
                break 
            start.append(next_s)
        subtree_size = [0 for i in range(n)]
        m = len(start)
        for i in range(m-1, -1, -1):
            for x in start[i]:
                subtree_size[x]+=1
                for y in g[x]:
                    subtree_size[x]+=subtree_size[y]
        dfs_word = [None for i in range(n)]
        my_index = [None for i in range(n)]
        for x in range(n):
            g[x] = sorted(g[x])
        start = [[0, 0]]
        while len(start) > 0:
            next_s = []
            for node, indent in start:
                curr = 0 
                for y in g[node]:
                    next_s.append([y, curr+indent])
                    curr+=subtree_size[y]
                dfs_word[curr+indent] = s[node]
                my_index[node] = curr+indent
            start = next_s
        forward = [0]
        for c in dfs_word:
            forward.append((p*forward[-1]+ord(c)-ord('a')+1) % q)
        backward = [0]
        for c in dfs_word[::-1]:
            backward.append((p*backward[-1]+ord(c)-ord('a')+1) % q)
        answer = []
        for i in range(n):
            a = subtree_size[i]
            b = my_index[i]
            """"""
            word is dfs_word[b-a+1:b], inclusive
            which is 
            forward[b+1]-forward[b-a]*pow(p, )
            backword word is 
            dfs_word[n-b-1:n-b+a-2 inclusive]
            """"""
            forward_word = forward[b+1]-forward[b-a+1]*pow(p, a, q)
            backward_word = backward[n-b+a-1]-backward[n-b-1]*pow(p, a, q)
            if (forward_word-backward_word) % q==0:
                answer.append(True)
            else:
                answer.append(False)
        return answer",1427876142
plevande,plevande,75,3607,python3,"primes = [2,3,5]
for x in range(7, 10**3+1):
    is_prime = True  
    for p in primes:
        if p*p > x:
            break 
        if x % p==0:
            is_prime = False 
            break 
    if is_prime:
        primes.append(x)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        d = {-1*float('inf'): 0}
        for x in nums:
            x2 = None 
            for y in primes:
                if x % y==0:
                    x2 = y 
                    break
            new_d = {}
            if x2 is not None:
                ops = [[x, 0], [x2, 1]]
            else:
                ops = [[x, 0]]
            for y in d:
                for a, b in ops:
                    if a >= y:
                        if a not in new_d:
                            new_d[a] = float('inf')
                        new_d[a] = min(new_d[a], b+d[y])
            d = new_d 
            if len(d)==0:
                return -1 
        return min(d.values())",1427839290
scotchtape,scotchtape,77,3502,cpp,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define sz(v) int(v.size())
template <class T>ostream&operator<<(ostream& os,const vector<T>&v){os<<""["";for(typename vector<T>::const_iterator i=v.begin();i!=v.end();++i){os<<*i<<"" "";}os<<""\b]\n"";return os;}


class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26, 0);
        int n = s.size();

        auto f = [&]() {
            for (int i : cnt) {
                if (i >= k) return true;
            }
            return false;
        };

        int r = -1;
        int ans = 0;
        for (int l = 0; l < n; ++l) {
            while (r+1 < n && !f()) {
                ++r;
                ++cnt[s[r]-'a'];
            }
            if (f()) {
                ans += n-r;
            }
            --cnt[s[l]-'a'];
        }
        return ans;
    }
};",1427826518
scotchtape,scotchtape,77,3566,cpp,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define sz(v) int(v.size())
template <class T>ostream&operator<<(ostream& os,const vector<T>&v){os<<""["";for(typename vector<T>::const_iterator i=v.begin();i!=v.end();++i){os<<*i<<"" "";}os<<""\b]\n"";return os;}


class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> ans;
        string s;
        for (char c : t) {
            s += ""a""; ans.push_back(s);
            while (s.back() != c) {
                ++s.back();
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427823928
scotchtape,scotchtape,77,3603,cpp,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define sz(v) int(v.size())
template <class T>ostream&operator<<(ostream& os,const vector<T>&v){os<<""["";for(typename vector<T>::const_iterator i=v.begin();i!=v.end();++i){os<<*i<<"" "";}os<<""\b]\n"";return os;}
class HashedString {
private:
    // change M and B if you want
    static const ll M = (1LL << 61) - 1;
    static const ll B = 174009870203695392;

    // pow[i] contains B^i % M
    inline static vector<ll> pow = {1};

    // p_hash[i] is the hash of the first i characters of the given string
    vector<ll> p_hash;

    __int128 mul(ll a, ll b) { return (__int128)a * b; }
    ll mod_mul(ll a, ll b) { return mul(a, b) % M; }

public:
    HashedString(const string &s) : p_hash(s.size() + 1) {
        while (pow.size() <= s.size()) { pow.push_back(mod_mul(pow.back(), B)); }
        p_hash[0] = 0;
        for (int i = 0; i < s.size(); i++) {
            p_hash[i + 1] = (mul(p_hash[i], B) + s[i]) % M;
        }
    }

    ll get_hash(int start, int end) {
        ll raw_val =
                p_hash[end + 1] - mod_mul(p_hash[start], pow[end - start + 1]);
        return (raw_val + M) % M;
    }
};
class Solution {
public:
    vector<bool> findAnswer(vector<int>& par, string s) {
        int n = par.size();
        vector<vector<int>> g(n);
        for (int i = 1; i < n; ++i) {
            g[par[i]].push_back(i);
        }
        for (int i = 0; i < n; ++i) sort(g[i].begin(), g[i].end());

        

        string S;
        vector<pair<int, int>> v(n);

        function<void(int)> dfs = [&](int i) {
            v[i].first = sz(S);

            for (int j : g[i]) dfs(j);

            S += s[i];
            v[i].second = sz(S)-1;
        };

        dfs(0);


        HashedString h(S);
        string R = S; reverse(R.begin(), R.end());
        HashedString rev(R);

        vector<bool> ans(n, false);

        for (int i = 0; i < n; ++i) {
            int l = v[i].first, r = v[i].second;
            //cout << l << ' ' << r << endl;
            ans[i] = h.get_hash(l, r) == rev.get_hash(n-r-1, n-l-1);
        }
        return ans;
    }
};",1427876371
scotchtape,scotchtape,77,3607,cpp,"#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define sz(v) int(v.size())
template <class T>ostream&operator<<(ostream& os,const vector<T>&v){os<<""["";for(typename vector<T>::const_iterator i=v.begin();i!=v.end();++i){os<<*i<<"" "";}os<<""\b]\n"";return os;}

class Solution {
public:
    int minOperations(vector<int>& a) {
        int n = a.size();
        int MAX_NUM = *max_element(a.begin(), a.end())+3;

        vector<int> spf(MAX_NUM);
        spf[1] = 1;
        for (int i = 2; i < MAX_NUM; ++i) spf[i] = i;
        for (int i = 4; i < MAX_NUM; ++i, ++i) spf[i] = 2;
        for (int i = 3; i*i < MAX_NUM; ++i) {
            if (spf[i] != i) continue;
            for (int j = i*i; j < MAX_NUM; j += i) {
                if (spf[j] == j) spf[j] = i;
            }
        }

        vector<int> b = a; for (int &i : b) i = spf[i];

        //cout << b << endl;

        int reduced_ans = 0, same_ans = 0;
        int prev_reduced = -1, prev = -1;

        for (int i = 0; i < n; ++i) {
            int nxt_red = 1e9, nxt_same = 1e9;
            if (prev_reduced > a[i]) {
                return -1;
            }
            if (prev <= a[i]) {
                nxt_same = min(nxt_same, same_ans);
            }
            if (prev_reduced <= a[i]) {
                nxt_same = min(nxt_same, reduced_ans);
            }

            if (prev <= b[i]) {
                nxt_red = min(nxt_red, same_ans+1);
            }
            if (prev_reduced <= b[i]) {
                nxt_red = min(nxt_red, reduced_ans+1);
            }
            
            reduced_ans = nxt_red;
            same_ans = nxt_same;

            if (reduced_ans == 1e9 && same_ans == 1e9) {
                return -1;
            }

            prev_reduced = b[i];
            prev = a[i];

            //cout << same_ans << ' ' << reduced_ans << ' ' << prev << ' ' << prev_reduced << endl;
        }

        return min(reduced_ans, same_ans);
    }
};",1427850031
Rajat,log1,79,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),ans=0;
        for(int i=0;i<n;++i)
        {
            vector<int> fz(26,0);
            for(int j=i;j<n;++j)
            {
                fz[s[j]-'a']++;
                bool ok=false;
                for(int f=0;f<26;++f)
                {
                    if(fz[f]>=k)
                    {
                        ok=true;
                        break;
                    }
                }
                if(ok)
                {
                    ans+=(n-j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427834815
Rajat,log1,79,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string str="""";

        for(auto c:target)
        {
            str+='a';
            ans.push_back(str);
            while(str.back()<c)
            {
                str.back()++;
                ans.push_back(str);
            }
        }
        return ans;
    }
};",1427829237
Rajat,log1,79,3603,cpp,"#include <vector>
#include <functional>
using namespace std;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>>tree(n);
        for(int i=1;i<n;++i)
        {
            tree[parent[i]].push_back(i);
        }
        vector<long long>pali(n+1,1);
        const long long polynomial_hash=911382629;
        for(int i=1;i<=n;++i)
        {
            pali[i]=(pali[i-1]*polynomial_hash)%1000000007;
        }
        vector<long long>InitHashing(n,0),FinalHashing(n,0);
        vector<int>nums(n,1);
        function<void(int)>dfs=[&](int u)->void
        {
            long long res=0;
            int total=0;
            for(int i=0;i<tree[u].size();++i)
            {
                dfs(tree[u][i]);
                res=(res*pali[nums[tree[u][i]]]+InitHashing[tree[u][i]])%1000000007;
                total+=nums[tree[u][i]];
                // cout<<""Print: ""<<res<<endl;
                // cout<<""Print: ""<<nums[tree[u][i]]<<endl;
                // for(int j=0;j<n;++j)
                // {
                //     cout<<InitHashing[j]<<"" "";
                // }
                // cout<<endl;
            }
            auto func=[&](long long res,int num)->long long
            {
                return (res*pali[num]+(s[u]-'a'+1))%1000000007;
            };
            InitHashing[u]=func(res,nums[u]);
            nums[u]=total+1;
            long long convert=(s[u]-'a'+1);
            for(vector<int>::reverse_iterator it=tree[u].rbegin();it!=tree[u].rend();++it)
            {
                convert=(convert*pali[nums[*it]]+FinalHashing[*it])%1000000007;
                // for(int i=0;i<n;++i)
                // {
                //     cout<<FinalHashing[i]<<"" "";
                // }
                // cout<<endl;
            }
            FinalHashing[u]=convert;
        };
        for(int i=0;i<n;++i)
        {
            if(parent[i]==-1)dfs(i);
        }
        vector<bool>order(n,false);
        for(int i=0;i<n;++i)
        {
            order[i]=(InitHashing[i]==FinalHashing[i]);
        }
        return order;
    }
};",1427869121
Rajat,log1,79,3607,cpp,"class Solution {
public:
    static const int N=1000005;
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        static vector<int>spf(N,0);
        static vector<int>gpd(N,1);
        static bool ok=false;
        if(!ok)
        {
            for(int i=2;i<N;++i)
            {
                if(spf[i]==0){
                    spf[i]=i;
                    for(int j=2*i;j<N;j+=i)
                    {
                        if(spf[j]==0)
                        {
                            spf[j]=i;
                        }
                    }
                }
            }
            for(int i=2;i<N;++i)
            {
                gpd[i]=i/spf[i];
            }
            ok=true;
        }
        long long ans=0;
        for(int i=n-2;~i;--i)
        {
            while(nums[i]>nums[i+1])
            {
                if(nums[i]==1)return -1;
                int dsc=gpd[nums[i]];
                if(dsc==1)return -1;
                nums[i]/=dsc;
                ans++;
            }
        }
        return ans;
    }
};",1427846939
BERNARD BRAHIMCHA,BERNARB01,81,3502,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int numberOfSubstrings(string s, int k) {
    int n = int(s.length());
    int ans = 0;
    for (int i = 0; i < n; i++) {
      array<int, 26> cnt = {};
      int mx = 0;
      for (int j = i; j < n; j++) {
        mx = max(mx, ++cnt[int(s[j] - 'a')]);
        if (mx >= k) {
          ++ans;
        }
      }
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;

}
#endif
",1427879474
BERNARD BRAHIMCHA,BERNARB01,81,3566,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<string> stringSequence(string s) {
    int n = int(s.length());
    string t = """";
    vector<string> res;
    for (int i = 0; i < n; i++) {
      t.push_back('a');
      while (t.back() != s[i]) {
        res.emplace_back(t);
        ++t.back();
      }
      res.emplace_back(t);
    }
    return res;
  }
};

#ifdef B01
int main() {
  Solution sl;

}
#endif
",1427876628
BERNARD BRAHIMCHA,BERNARB01,81,3603,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int o = 3;
const int md = int(1e9) + 33;
const int md2 = int(1e9) + 21;
const int b = 419;
const int b2 = 421;
vector<int64_t> pb;
vector<int64_t> pb2;

struct p_hash {
  inline pair<int, int> H(char c) const {
    return {int(c + o) % md, int(c + o) % md2};
  }

  int n;
  int64_t h, h2;

  p_hash() : n(0), h(0), h2(0) {}
  

  template <typename T>
  inline void push_back(const T& c) {
    h = (pb[n] * int(c + o) % md + h) % md;
    h2 = (pb2[n] * int(c + o) % md2 + h2) % md2;
    ++n;
  }

  inline pair<int, int> get() const {
    return {h, h2};
  }

  inline pair<int, int> shift(const pair<int, int>& p, int d) const {
    return {p.first * pb[d] % md, p.second * pb2[d] % md2};
  }

  inline pair<int, int> sum(const pair<int, int>& l, const pair<int, int>& r, int len1) const {
    auto tmp = shift(r, len1);
    return {(l.first + tmp.first) % md, (l.second + tmp.second) % md2};
  }

  inline p_hash sum(const p_hash& l, const p_hash& r) {
    auto p = sum(l.get(), r.get(), l.n);
    p_hash res;
    tie(res.h, res.h2) = p;
    res.n = l.n + r.n;
    return res;
  }
};

class Solution {
 public:
  vector<bool> findAnswer(vector<int>& pr, string s) {
    int n = int(s.length());
    pb.assign(2 * n + 1, 1);
    pb2.assign(2 * n + 1, 1);
    for (int i = 1; i <= 2 * n; i++) {
      pb[i] = pb[i - 1] * b % md;
      pb2[i] = pb2[i - 1] * b2 % md2;
    }
    vector<vector<int>> g(n);
    for (int i = n - 1; i >= 1; i--) {
      g[pr[i]].push_back(i);
    }
    vector<bool> res(n);
    vector<p_hash> sh(n);
    vector<p_hash> rsh(n);
    auto Dfs = [&](auto&& self, int v) -> void {
      sh[v].push_back(s[v]);
      for (int u : g[v]) {
        self(self, u);
        sh[v] = sh[v].sum(sh[v], sh[u]);
        rsh[v] = rsh[v].sum(rsh[u], rsh[v]);
      }
      rsh[v].push_back(s[v]);
      res[v] = (sh[v].get() == rsh[v].get());
    };
    Dfs(Dfs, 0);
    return res;
  }
};

#ifdef B01
int main() {
  Solution sl;
  vector<int> pr = {-1,0,0,1,1,2};
  deb(sl.findAnswer(pr, ""aababa""));
  pr = {-1,0,0,0,0};
  deb(sl.findAnswer(pr, ""aabcb""));
}
#endif
",1427871887
BERNARD BRAHIMCHA,BERNARB01,81,3607,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int N = int(1e6) + 1;

bool calculated = false;
int mxd[N];

class Solution {
 public:
  int minOperations(vector<int>& b) {
    if (!calculated) {
      calculated = true;
      for (int i = 1; i < N; i++) {
        for (int j = 2 * i; j < N; j += i) {
          mxd[j] = i;
        }
      }
    }
    vector<int> a = b;
    int n = int(a.size());
    int ans = 0;
    for (int i = n - 2; i >= 0; i--) {
      while (a[i] > a[i + 1]) {
        if (mxd[a[i]] == 1) {
          return -1;
        }
        ++ans;
        a[i] /= mxd[a[i]];
      }
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;

}
#endif
",1427886238
fxfxxxfxx,fxfxxxfxx,84,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), ok = 0;
        int left = 0, ans = 0;
        vector<int> M(128);
        for (int i = 0; i < n; i++) {
            M[s[i]] += 1;
            if (M[s[i]] == k) ok += 1;
            // [left, i]
            while (left <= i && ok > 0) {
                if (M[s[left]] == k) ok -= 1;
                M[s[left]] -= 1;
                left += 1;
            }
            // [left, i] not ok
            ans += left;
        }
        return ans;
    }
};",1427839341
fxfxxxfxx,fxfxxxfxx,84,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string now = ""a"";
        ans.push_back(""a"");
        while (now.size() < target.size() || now.back() < target.back()) {
            int k = int(now.size()) - 1;
            if (now[k] < target[k])
                now[k] += 1;
            else now += 'a';
            ans.push_back(now);
        }
        return ans;
    }
};",1427828595
fxfxxxfxx,fxfxxxfxx,84,3603,cpp,"class Machine {
public:
    vector<int> dp;
    bool is_palindrome(int left, int right) {
        int mid = ((left * 2 + 1) + (right * 2 + 1)) / 2;
        int need = right - left + 1;
        return dp[mid] >= need;
    }

    Machine(const string &s) {
        int n = s.size();
        
        int m = 2 * n + 1;
        dp = vector<int>(m);
        
        int mid = -1, right = -1;
        for (int i = 0; i < m; i++) {
            if (i <= right) {
                int shadow = mid - (i - mid);
                int upper = right - i;

                if (dp[shadow] < upper) {
                    dp[i] = dp[shadow];
                    continue;
                }
            }
            dp[i] = right - i;
            for (int j = right + 1; j < m; j++) {
                if (i - (j - i) < 0) break;
                char cr = s[j/2];
                char cl = s[(i-(j-i))/2];
                if (j & 1 && cr != cl)
                    break;
                right = j;
                mid = i;
                dp[i] = right - i;
            }
        }
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);

        string PO;
        vector<int> ID, SZ;
        auto dfs = [&](int v, auto&& dfs) -> int {
            int sz = 1;
            for (int u : adj[v])
                sz += dfs(u, dfs);
            ID.push_back(v);
            PO.push_back(s[v]);
            SZ.push_back(sz);
            return sz;
        };
        dfs(0, dfs);

        Machine M(PO);

        vector<bool> ans(n);
        for (int i = 0; i < n; i++) {
            int left = i - SZ[i] + 1;
            ans[ID[i]] = M.is_palindrome(left, i);
        }
        return ans;
    }
};",1427887300
fxfxxxfxx,fxfxxxfxx,84,3607,cpp,"static auto P = []{
    constexpr int N = 10000001;
    array<int, N> ret = {0, 1};
    for (int v = 2; v < N; v++) ret[v] = v;
    for (int v = 2; v < N; v++) {
        if (ret[v] < v) continue;
        for (int64_t k = int64_t{v}*v; k < N; k += v) {
            if (ret[k] < k) continue;
            ret[k] = v;
        }
    }
    return ret;
}();

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int prev = 1e7, ans = 0;
        for (int i = n-1; i >= 0; i--) {
            if (nums[i] > prev) {
                nums[i] = P[nums[i]];
                ans += 1;
            }
            if (nums[i] > prev) return -1;
            prev = nums[i];
        }
        return ans;
    }
};",1427852806
user4508OO,user4508OO,88,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n = s.length();
        for(int i=0;i<n;i++){
            map<int,int>mp;
            for(int j=i;j<n;j++){
                mp[s[j]]++;
                if(mp[s[j]]==k){
                    ans+=n-j;
                    break;
                }
            }
        }
        
        return ans;
    }
};",1427839492
user4508OO,user4508OO,88,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
     vector<string>ans;
     string sub="""";
     for(auto it:target){
        for(int i='a';i<='z';i++){
            sub+=i;
            ans.push_back(sub);
            if(i!=it)sub.pop_back();
            else break;
        }
     }   
     return ans;
    }
};",1427827817
user4508OO,user4508OO,88,3603,cpp,"class Solution {
public:
    #define ll long long
    vector<int>adj[100005];
    string ps;
    int st[100005],en[100005],sz;

    struct Hashing
    {
    ///bases:100001,313,3797,717,1337
    int len;
    ll base = 313;
    static const ll mod = 1e9+7;
    vector<ll> hashF, hashR, pw;

    Hashing(const string& str,ll base):base(base)
    {
        len = str.length();
        hashF.assign(len + 2, 0);
        hashR.assign(len + 2, 0);
        pw.assign(len + 2, 1);

        for (int i = 1; i <= len; i++)
        {
            pw[i] = (pw[i - 1]*base)%mod;
        }

        for (int i = 1; i <= len; i++)
        {
            hashF[i] = ((hashF[i - 1]*base)%mod + str[i - 1]) % mod;
            hashR[len - i + 1] = ((hashR[len - i + 2]*base)%mod + str[len - i]) % mod;
        }
    }

    ll getForwardHash(int l, int r)
    {
        if (l == 1) return hashF[r];
        return (hashF[r] - (hashF[l - 1]*pw[r - l + 1])%mod + mod) % mod;
    }

    ll getBackwardHash(int l, int r)
    {
        if (r == len) return hashR[l];
        return (hashR[l] - (hashR[r + 1]*pw[r - l + 1])%mod + mod) % mod;
    }

    ll getCombinedHash(int l1, int r1, int l2, int r2)
    {
        ll hash1 = getForwardHash(l1, r1);
        ll hash2 = getForwardHash(l2, r2);
        int len1 = r2 - l2 + 1;
        ll combinedHash = (hash1 * pw[len1]) % mod;
        combinedHash = (combinedHash + hash2) % mod;
        return combinedHash;
    }

    bool isPalin(int l, int r)
    {
        if (r < l) return false;
        return getForwardHash(l, r) == getBackwardHash(l, r);
    }
    };

    void dfs(int src,int par, string &s){
        st[src]=sz;
        for(auto it:adj[src]){
            if(it!=par)dfs(it,src,s);
        }
        ps+=s[src];
        sz++;
        st[src]++;
        en[src]=sz;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.length();

        for(int u=1;u<n;u++){
            int v = parent[u];
            adj[v].push_back(u);
            adj[u].push_back(v);
        }

        dfs(0,-1,s);

        Hashing hs(ps,313);

        vector<bool>ans;
        for(int i=0;i<n;i++)
            ans.push_back(hs.isPalin(st[i],en[i]));
        return ans;
    }
};",1427888409
user4508OO,user4508OO,88,3607,cpp,"class Solution {
public:
    int pre[1000005];
    int maxDiv(int n){
        if(pre[n]) return pre[n];
        int sq= sqrt(n);
        int mx=0;
        for(int i=2;i<=sq;i++){
            if(n%i==0){
                mx=max(mx,i);
                mx=max(mx,n/i);
            }
        }
        pre[n]=mx;
        return mx;
    }
    int minOperations(vector<int>& nums) {
        int ans=0;
        int n = nums.size();
        for(int i=n-2;i>=0;i--){
            int x=nums[i];
             while(x>nums[i+1]){
                int div = maxDiv(x);
                if(div==0) return -1;
                x/=div;
                ans++; 
            }
            nums[i]=x;
        }
        return ans;
    }
};",1427853332
furuyarei,furuyarei,90,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int cnt[26] = {0};
            bool check = false;
            for (int j = i; j < n; ++j) {
                int x = s[j] - 'a';
                ++cnt[x];
                if (cnt[x] == k) {
                    check = true;
                }
                if (check) {
                    // cout << i << "" "" << j << endl;
                    ++ans;
                }
            }
        }
        return ans;
    }
};",1427864302
furuyarei,furuyarei,90,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur;
        for (char ch: target) {
            for (char i = 'a'; i <= ch; ++i) {
                ans.push_back(cur + i);
            }
            cur.push_back(ch);
        }
        return ans;
    }
};",1427854394
furuyarei,furuyarei,90,3603,cpp,"// Source: https://cp-algorithms.com/string/manacher.html
vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        vector<vector<int>> g(n);
        for (int i = 1; i < n; ++i) {
            g[parent[i]].push_back(i);
        }
        
        vector<int> l(n), r(n);
        string eth;
        
        function<void(int)> dfs = [&](int u) {
            l[u] = eth.size();
            for (int v: g[u]) {
                dfs(v);
            }
            eth.push_back(s[u]);
            r[u] = eth.size() - 1;
        };
        dfs(0);
        
        // cout << eth << endl;
        vector<int> mc = manacher(eth);
        // for (int x: mc) cout << x << "" ""; cout << endl;
        vector<bool> ans(n);
        for (int i = 0; i < n; ++i) {
            // cout << ""l, r = "" << l[i] << "" "" << r[i] << endl;
            int ll = l[i] * 2, rr = r[i] * 2;
            int cent = (ll + rr) / 2;
            int length = cent - ll + 1;
            // cout << ""ll, rr = "" << ll << "" "" << rr << "" "" << cent << "" "" << length << endl;
            ans[i] = (mc[cent] >= length);
        }
        
        return ans;
    }
};",1427853843
furuyarei,furuyarei,90,3607,cpp,"static constexpr int BOUND = 1000000;
int rep[BOUND + 10];
bool inited = false;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (!inited) {
            inited = true;
            rep[1] = 1;
            for (int i = 2; i <= BOUND; ++i) {
                if (!rep[i]) {
                    rep[i] = i;
                }
                for (int j = i + i; j <= BOUND; j += i) {
                    if (!rep[j]) {
                        rep[j] = i;
                    }
                }
            }
        }
        
        int ans = 0;
        int n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                if (rep[nums[i]] > nums[i + 1]) {
                    return -1;
                }
                ++ans;
                nums[i] = rep[nums[i]];
            }
        }
        return ans;
    }
};",1427860167
w0w0,w0w0,92,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = defaultdict(int)
        n = len(s)

        ans = 0
        l = 0
        for r in range(n):
            count[s[r]] += 1
            while max(count.values()) >= k:
                count[s[l]] -= 1
                if max(count.values()) < k:
                    count[s[l]] += 1
                    break
                else:
                    l += 1

            if max(count.values()) >= k:
                ans += l + 1

        return ans",1427829028
w0w0,w0w0,92,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        cur = []

        for c in target:
            for i in range(ord(""a""), ord(c)):
                cur.append(chr(i))
                ans.append("""".join(cur))
                cur.pop()

            cur.append(c)
            ans.append("""".join(cur))

        return ans",1427825142
w0w0,w0w0,92,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        chd = [[] for _ in range(n)]

        root = 0
        for i in range(1, n):
            chd[parent[i]].append(i)

        res = []
        pos = []
        left = [0] * n
        right = [0] * n

        def dfs(x):
            left[x] = len(res)
            for y in chd[x]:
                dfs(y)

            res.append(s[x])
            pos.append(x)
            right[x] = len(res) - 1

        dfs(0)

        def manacher(s):
            def expand(s, left, right):
                while left >= 0 and right < len(s) and s[left] == s[right]:
                    left -= 1
                    right += 1
                return (right - left - 2) // 2
            end, start = -1, 0
            s = '#' + '#'.join(list(s)) + '#'
            arm_len = []
            right = -1
            j = -1
            for i in range(len(s)):
                if right >= i:
                    i_sym = 2 * j - i
                    min_arm_len = min(arm_len[i_sym], right - i)
                    cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len)
                else:
                    cur_arm_len = expand(s, i, i)
                arm_len.append(cur_arm_len)
                if i + cur_arm_len > right:
                    j = i
                    right = i + cur_arm_len
                if 2 * cur_arm_len + 1 > end - start:
                    start = i - cur_arm_len
                    end = i + cur_arm_len

            return arm_len

        arm_len = manacher(res)

        ans = [True] * n
        for i in range(n):
            l, r = left[i], right[i]
            m = (r + l) + 1
            ans[i] = arm_len[m] >= r - l

        return ans",1427890220
w0w0,w0w0,92,3607,python3,"@cache
def get_prime_factors(n):
    if n % 2 == 0:
        return 2

    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return i

    if n > 2:
        return n

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)

        ans = 0

        for i in range(n - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                nums[i] = get_prime_factors(nums[i])
                ans += 1

            if nums[i] > nums[i + 1]:
                return -1

        return ans",1427835694
Anupam Shandilya,anupamshandilya28,93,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
    int n = s.size(), ans = 0;
        
    for(int i = 0; i < n; ++i) 
    {
        vector<int> freq(26, 0);
        int cnt = 0;
        for(int j = i; j < n; ++j) 
        {
            freq[s[j] - 'a']++;
            if(freq[s[j] - 'a'] == k) 
            {                
                cnt++;
            }
            if(cnt > 0) 
            {
                ans++;
            }
        }
    }
        
    return ans;
}

};",1427831764
Anupam Shandilya,anupamshandilya28,93,3566,cpp,"class Solution {
public:
   vector<string> stringSequence(string target) {
    vector<string> res;
    string s = """";
       
    for(int i = 0; i < target.length(); ++i)
    {
        if(s.length() < i + 1) 
        {
            s += 'a';
            res.push_back(s);
        }
        while(s.back() != target[i]) 
        {
            s.back() = (s.back() - 'a' + 1) % 26 + 'a';
            res.push_back(s);
        }
    }
       
    return res;
}

};",1427825912
Anupam Shandilya,anupamshandilya28,93,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();

        vector<vector<int>> tree(n);
        for(int i = 1; i < n; ++i)
        {
            tree[parent[i]].push_back(i);
        }

        string dfsStr;
        dfsStr.reserve(n);
        vector<int> start(n), end(n);
        int pos = 0;

        function<void(int)> dfs = [&](int x) {
            start[x] = pos;
            for(int y : tree[x])
                dfs(y);
            
            dfsStr.push_back(s[x]);
            pos++;
            end[x] = pos - 1;
        };

        dfs(0);

        const int MOD1 = 1e9 + 7;
        const int MOD2 = 1e9 + 9;
        const int BASE1 = 911;
        const int BASE2 = 1597;

        int len = dfsStr.size();
        vector<long long> pow1(len + 1), pow2(len + 1);
        pow1[0] = pow2[0] = 1;
        for(int i = 1; i <= len; ++i)
        {
            pow1[i] = (pow1[i - 1] * BASE1) % MOD1;
            pow2[i] = (pow2[i - 1] * BASE2) % MOD2;
        }

        vector<long long> h1(len + 1), h2(len + 1);
        h1[0] = h2[0] = 0;
        for(int i = 0; i < len; ++i)
        {
            h1[i + 1] = (h1[i] * BASE1 + dfsStr[i]) % MOD1;
            h2[i + 1] = (h2[i] * BASE2 + dfsStr[i]) % MOD2;
        }

        vector<long long> hr1(len + 1), hr2(len + 1);
        hr1[len] = hr2[len] = 0;
        for(int i = len - 1; i >= 0; --i)
        {
            hr1[i] = (hr1[i + 1] * BASE1 + dfsStr[i]) % MOD1;
            hr2[i] = (hr2[i + 1] * BASE2 + dfsStr[i]) % MOD2;
        }

        vector<bool> answer(n);

        for(int i = 0; i < n; ++i) 
        {
            int l = start[i];
            int r = end[i];
            int substring_len = r - l + 1;

            long long hash1 = (h1[r + 1] - h1[l] * pow1[substring_len] % MOD1 + MOD1) % MOD1;
            long long hash2 = (h2[r + 1] - h2[l] * pow2[substring_len] % MOD2 + MOD2) % MOD2;

            long long rev_hash1 = (hr1[l] - hr1[r + 1] * pow1[substring_len] % MOD1 + MOD1) % MOD1;
            long long rev_hash2 = (hr2[l] - hr2[r + 1] * pow2[substring_len] % MOD2 + MOD2) % MOD2;

            if(hash1 == rev_hash1 && hash2 == rev_hash2)
            {
                answer[i] = true;
            }
            else
            {
                answer[i] = false;
            }
        }

        return answer;
    }

};",1427873561
Anupam Shandilya,anupamshandilya28,93,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        const int MAX_N = 1e6 + 1;
        vector<int> spf(MAX_N);

        for(int i = 0; i < MAX_N; ++i)
            spf[i] = i;

        for(int i = 2; i * i < MAX_N; ++i)
        {
            if(spf[i] == i)
            {
                for(int j = i * i; j < MAX_N; j += i) 
                {
                    if(spf[j] == j)
                        spf[j] = i;
                }
            }
        }

        int ops = 0;
        for(int i = n - 2; i >= 0; --i) 
        {
            if(nums[i] <= nums[i + 1]) continue;

            int p = spf[nums[i]];
            if(p <= nums[i + 1]) 
            {
                nums[i] = p;
                ops ++;
            }
            else
            {
                return -1;
            }
        }
        
        return ops;
    }

};",1427857721
Rakesh_Reddy7,Addula_Rakesh7,96,3502,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n, cnt = len(s), 0
        for i in range(n):
            mp = [0] * 26
            x = 0
            for j in range(i, n):
                p = ord(s[j]) - ord('a')
                mp[p] += 1
                
                if mp[p] == k: 
                    x += 1

                if x > 0:  
                    cnt += 1
        
        return cnt*1
",1427861369
Rakesh_Reddy7,Addula_Rakesh7,96,3566,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def stringSequence(self, tar: str) -> List[str]:
        st = """" 
        ans = []
        x = """" 
        for i in tar:
            st += 'a'
            x += 'z'
            ans.append(st)
            while st[-1] != i:
                l = chr(((ord(st[-1]) - ord('a') + 1) % 26) + ord('a'))
                st = st[:-1] + l
                ans.append(st)
        return ans
        pass",1427849357
Rakesh_Reddy7,Addula_Rakesh7,96,3603,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def findAnswer(self, par: List[int], s: str) -> List[bool]:
        n = len(par)
        base = 911382629
        mod = 10**18 + 7
        lst = [[] for i in range(n)]
        for i in range(1, n):
            lst[par[i]].append(i)
        pows = [1] * (n + 1)
        for i in range(1,n):
            pass
        for i in range(1, n + 1):
            pows[i] = pows[i - 1] * base % mod
        h1, h2, lenx = [0] * n, [0] * n, [0] * n
        res = (par, s)
        stk = [(0, False)]
        r = 0
        while stk:
            node, state = stk.pop()
            if state:
                x = 0
                for ch in lst[node]:
                    x = (x * pows[lenx[ch]] + h1[ch]) % mod
                x = (x * base + ord(s[node])) % mod
                p = ord(s[node])
                for ch in reversed(lst[node]):
                    p = (p * pows[lenx[ch]] + h2[ch]) % mod
                h1[node] = x
                h2[node] = p
                r += 1
                lenx[node] = sum(lenx[ch] for ch in lst[node]) + 1
            else:
                stk.append((node, True))
                for ch in reversed(lst[node]):
                    stk.append((ch, False))
        ans = [h1[i] == h2[i] for i in range(n)]
        return ans
",1427844425
Rakesh_Reddy7,Addula_Rakesh7,96,3607,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def minOperations(self, arr: List[int]) -> int:
        n, ans = len(arr), 0
        dup = arr.copy() 
        unq = set(arr)
        freq = {}
        r = 0
        def solve(x):
            if x == 1:
                return 1
            if x % 2 == 0:
                return 2
            srt = int(x ** 0.5) + 1
            for p in range(3, srt, 2):
                if x % p == 0:
                    return p
            return x 
        for x in unq:
            freq[x] = solve(x)
        
        for i in range(n - 2, -1, -1):
            tar = arr[i + 1]
            x = arr[i]
            cnt = 0
            while x > tar:
                if x == 1:
                    break 
                else: r -= 1
                curr = freq.get(x, x)
                if curr == x:
                    break 
                d = x // curr  
                if d == 1:
                    break  
                else: 
                    r += 1
                x = x // d  
                cnt += 1
                if x not in freq:
                    freq[x] = solve(x)
                else: pass
            
            if x <= tar:
                ans += cnt
                arr[i] = x
            else:
                return -1 
        return ans*1",1427891666
pingchungchang,pingchungchang,97,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for(int i = 0;i<s.size();i++){
            vector<int> cnt(26,0);
            bool fl = false;
            for(int j = i;j<s.size();j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a']>=k)fl = true;
                ans += fl;
            }
        }
        return ans;
    }
};",1427848980
pingchungchang,pingchungchang,97,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        char c = 'a';
        for (auto it:target){
            s+='a';
            while (it != c){
                ans.push_back(s);
                if (c == 'z') c = 'a';
                else c++;
                s[s.size()-1] = c;
            }
            ans.push_back(s);
            c = 'a';
        }
        return ans;
    }
};",1427866744
pingchungchang,pingchungchang,97,3603,cpp,"class Solution {
public:
#define pll pair<ll,ll>
#define ll long long
#define fs first
#define sc second
    const pll p = {29,31};
    const ll mod = 998244353;
    ll mad(ll a,ll b){
        a += b;
        return a>=mod?a-mod:a;
    }
    pll add(pll a,pll b){
        return pll(mad(a.fs,b.fs),mad(a.sc,b.sc));
    }
    pll mul(pll a,pll b){
        return pll(a.fs*b.fs%mod,a.sc*b.sc%mod);
    }
    vector<vector<int>> T;
    string val;
    vector<pll> pw;
    vector<pll> dp,rdp;
    vector<bool> ans;
    vector<int> sz;

    void dfs(int now){
        sz[now] = 1;
        sort(T[now].begin(),T[now].end());
        for(auto nxt:T[now]){
            dfs(nxt);
            sz[now] += sz[nxt];
        }
        int pref = 0;
        for(auto nxt:T[now]){
            dp[now] = add(dp[now],mul(pw[pref],dp[nxt]));
            pref += sz[nxt];
        }
        dp[now] = add(dp[now],mul(pw[pref],pll(val[now]-'a'+1,val[now]-'a'+1)));
        pref = 1;
        rdp[now] = add(rdp[now],pll(val[now]-'a'+1,val[now]-'a'+1));
        for(auto it = T[now].rbegin();it != T[now].rend();it++){
            int nxt = *it;
            rdp[now] = add(rdp[now],mul(pw[pref],rdp[nxt]));
            pref += sz[nxt];
        }
        if(dp[now].fs == rdp[now].fs&&dp[now].sc == rdp[now].sc)ans[now] = true;
        return;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        val = s;
        int N = parent.size();
        pw = vector<pll>(N+1,pll(1,1));
        pw[1] = pll(p.fs,p.sc);
        dp = rdp = vector<pll>(N,pll(0,0));
        for(int i = 2;i<pw.size();i++)pw[i] = mul(pw[i-1],pw[1]);
        T = vector<vector<int>>(N);
        for(int i = 1;i<N;i++){
            T[parent[i]].push_back(i);
        }
        sz = vector<int>(N,1);
        ans = vector<bool>(N,0);
        dfs(0);
        return ans;
    }
};",1427883401
pingchungchang,pingchungchang,97,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int N = nums.size();
        vector<int> to(N,-1);
        for(int i = 0;i<N;i++){
            to[i] = nums[i];
            for(int j = 2;j*j<=nums[i];j++){
                if(nums[i]%j == 0){
                    to[i] = j;
                    break;
                }
            }
        }
        int mx = nums.back();
        int ans = 0;
        for(int i = N-2;i>=0;i--){
            if(to[i]>mx)return -1;
            if(nums[i]>mx)ans++,mx = to[i];
            else mx = nums[i];
        }
        return ans;
    }
};",1427855969
Vijay Katari,vijaykatari23,98,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string S, int K) {
        int N = S.length();
        int ans = 0;
        for (int i = 0; i < N; ++i) {
            vector<int> cnt(26);
            int mx = 0;
            for (int j = i; j < N; ++j) {
                cnt[S[j] - 'a']++;
                mx = max(mx, cnt[S[j] - 'a']);
                if (mx >= K)
                    ++ans;
            }
        }
        return ans;
    }
};",1427827652
Vijay Katari,vijaykatari23,98,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string T) {
        int N = T.length();
        vector<string> ans;
        string s;
        for (int i = 0; i < N; ++i) {
            s += 'a';
            ans.push_back(s);
            while (T[i] ^ s.back()) {
                s.back() += 1;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427832758
Vijay Katari,vijaykatari23,98,3603,cpp,"using ll = long long;

template<int... mods>
struct StringHash {
    StringHash(const string &s) {}
    int hashval(int l1, int r2) {
        return 0;
    }
    int compare(int l1, int r1, int l2, int r2) {
        return true;
    }
};
 
template<int mod, int... mods>
struct StringHash<mod, mods...> {
    StringHash() {}
    int modpow(ll x, ll p) {
        x %= mod;
        ll ans = 1;
        while (p) {
            if (p & 1) ans = (ans * x) % mod;
            x = (x * x) % mod;
            p >>= 1;
        }
        return int(ans);
    }
 
    vector<int> hashvalues;
    vector<int> pows;
    vector<int> invpows;
    StringHash<mods...> ohash;
    const int AL = 26;
 
    StringHash(const string &s) : ohash(s) {
        int n = s.size();
        hashvalues.resize(n + 1);
        pows.resize(n + 1);
        invpows.resize(n + 1);
        
        pows[0] = 1;
        for (int i = 1; i <= n; i++) 
            pows[i] = ll(AL + 1) * pows[i - 1] % mod;
        
        invpows[n] = modpow(pows[n], mod - 2);
        for (int i = n - 1; i >= 0; --i) 
            invpows[i] = ll(AL + 1) * invpows[i + 1] % mod;
        
        for (int i = 1; i <= n; i++) 
            hashvalues[i] = (ll(AL + 1) * hashvalues[i - 1] + (s[i - 1] - 'a' + 1)) % mod;
    }
 
    int hashval(int l1, int r1) { // 0 indexed
        ll ans = hashvalues[r1 + 1] - ll(hashvalues[l1]) * pows[r1 - l1 + 1];
        ans %= mod;
        return ans >= 0 ? ans : ans + mod;
    }
 
    bool compare(int l1, int r1, int l2, int r2) {
        return hashval(l1, r1) == hashval(l2, r2) && ohash.compare(l1, r1, l2, r2);
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string S) {
        ll N = S.length();
        vector<vector<ll>> adj(N);
        for (ll i = 1; i < N; ++i) {
            ll u = i, v = parent[i];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        
        for (ll i = 0; i < N; ++i)
            sort(adj[i].begin(), adj[i].end());
        
        string dfsStr;
        vector<ll> start(N), end(N);
        function<void(ll, ll)> dfs = [&] (ll u, ll par) -> void {
            start[u] = dfsStr.length();
            for (auto v : adj[u]) {
                if (v == par) continue;
                dfs(v, u);
            }
            end[u] = dfsStr.length();
            dfsStr += S[u];
        };
        dfs(0, -1);
        
        StringHash<(int)1e9 + 9, (int)1e9 + 7> sh(dfsStr);
        auto ss = dfsStr;
        reverse(ss.begin(), ss.end());
        StringHash<(int)1e9 + 9, (int)1e9 + 7> sh1(ss);
        vector<bool> ans(N);
        for (ll i = 0; i < N; ++i) 
            ans[i] = sh.hashval(start[i], end[i]) == sh1.hashval(N - 1 - end[i], N - 1 - start[i]);
        return ans;
    }
};",1427883441
Vijay Katari,vijaykatari23,98,3607,cpp,"const int M = 1e6 + 5;
int prd[M];
bool init = false;
class Solution {
public:
    void initialise() {
        for (int i = 1; i < M; ++i)
            prd[i] = -1;
        for (int i = 2; i < M; ++i) 
            for (int j = i + i; j < M; j += i) {
                prd[j] = i;
            }
    }
    
    int minOperations(vector<int>& A) {
        if (!init) {
            init = true;
            initialise();
        }
        int N = A.size();
        reverse(A.begin(), A.end());
        int lst = M;
        int ans = 0;
        for (int x : A) {
            if (x <= lst) {
                lst = x;
                continue;
            }
            int xx = x;
            while (xx > lst) {
                if (prd[xx] == -1) return -1;
                ++ans;
                xx /= prd[xx];
            }
            lst = xx;
        }
        
        return ans;
    }
};",1427847621
wei zhang,l1l2,99,3502,cpp,"

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int result = 0;
        for (int start = 0; start < s.length(); ++start) {
            result += countSubstringsFromStart(s, start, k);
        }
        return result;
    }
    
private:
    int countSubstringsFromStart(const string& s, int start, int k) {
        unordered_map<char, int> charCount;
        int count = 0;
        for (int end = start; end < s.length(); ++end) {
            charCount[s[end]]++;
            if (hasCharAtLeastK(charCount, k)) {
                count++;
            }
        }
        return count;
    }
    
    bool hasCharAtLeastK(const unordered_map<char, int>& charCount, int k) {
        for (auto& entry : charCount) {
            if (entry.second >= k) return true;
        }
        return false;
    }
};
",1427827178
wei zhang,l1l2,99,3566,cpp,"

class Solution {
public:
    vector<string> stringSequence(string &target) {
        vector<string> result;
        string current = """";

        for (int i = 0; i < target.length(); ++i) {

            current += 'a';
            result.push_back(current);
            

            while (current[i] != target[i]) {
                current[i]++; 
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427825484
wei zhang,l1l2,99,3603,cpp,"#include <vector>
#include <string>
#include <functional>
#include <cmath>
#include <algorithm>

using namespace std;

class Solution {
public:
    const long long MOD = 1000000007;
    const long long P = 911;
    vector<long long> P_pow;

    void precompute_powers(int max_len){
        P_pow.resize(max_len + 1, 1);
        for(int i = 1; i <= max_len; ++i){
            P_pow[i] = (P_pow[i-1] * P) % MOD;
        }
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> children(n, vector<int>());
        int root = -1;
        for(int i = 0; i < n; ++i){
            if(parent[i] == -1) root = i;
            else children[parent[i]].push_back(i);
        }
        precompute_powers(n + 1);
        vector<bool> answer(n, false);
        struct NodeInfo{
            long long fh;
            long long rh;
            int len;
        };
        vector<NodeInfo> info(n);
        function<void(int)> dfs = [&](int x) {
            if(children[x].empty()){
                info[x].fh = (s[x]-'a'+1);
                info[x].rh = (s[x]-'a'+1);
                info[x].len = 1;
                answer[x] = true;
                return;
            }
            for(auto child : children[x]) dfs(child);
            long long fh = 0, rh = (s[x]-'a'+1);
            int total_len = 1;
            for(auto child : children[x]){
                fh = (fh * P_pow[info[child].len] + info[child].fh) % MOD;
                total_len += info[child].len;
            }
            fh = (fh * P + (s[x]-'a'+1)) % MOD;
            for(auto it = children[x].rbegin(); it != children[x].rend(); ++it){
                rh = (rh * P_pow[info[*it].len] + info[*it].rh) % MOD;
            }
            info[x].fh = fh;
            info[x].rh = rh;
            info[x].len = total_len;
            answer[x] = (fh == rh);
        };
        dfs(root);
        return answer;
    }
};
",1427875343
wei zhang,l1l2,99,3607,cpp,"
class Solution {
public:

    int getGPD(int x) {
        if (x == 1) return -1; 

        for (int i = 2; i <= std::sqrt(x); ++i) {
            if (x % i == 0) {
                return x / i;
            }
        }

        return 1;
    }

    int minOperations(std::vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) return 0; 

        int operations = 0;

        for (int i = n - 2; i >= 0; --i) {

            while (nums[i] > nums[i + 1]) {
                int gpd = getGPD(nums[i]);
                if (gpd == -1 || gpd == 1) {

                    return -1;
                }
                nums[i] = nums[i] / gpd;
                operations++;
            }
        }

        return operations;
    }
};
",1427855085
Zhao Yang,IAFB358kMw,101,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int r = 0;
        int i = 0;
        while (i < n) {
            r += processSubstring(s, n, i, k);
            i++;
        }
        return r;
    }

    private int processSubstring(String s, int n, int start, int k) {
        int[] f = new int[26];
        int m = 0;
        int j = start;
        int c = 0;
        while (j < n) {
            updateFrequency(s, j, f);
            m = Math.max(m, f[s.charAt(j) - 'a']);
            c += m >= k ? 1 : 0;
            j++;
        }
        return c;
    }

    private void updateFrequency(String s, int index, int[] f) {
        f[s.charAt(index) - 'a']++;
    }
}",1427859236
Zhao Yang,IAFB358kMw,101,3566,java,"class Solution {
    public List<String> stringSequence(String t) {
        List<String> r = new ArrayList<>();
        StringBuilder s = new StringBuilder();
        int i = 0;
        while (i < t.length()) {
            s.append('a');
            r.add(s.toString());
            updateString(r, s, t.charAt(i));
            i++;
        }
        return r;
    }

    private void updateString(List<String> r, StringBuilder s, char target) {
        while (s.charAt(s.length() - 1) != target) {
            char lastChar = s.charAt(s.length() - 1);
            s.setCharAt(s.length() - 1, (lastChar == 'z') ? 'a' : (char) (lastChar + 1));
            r.add(s.toString());
        }
    }
}",1427855715
Zhao Yang,IAFB358kMw,101,3603,java,"class Solution {

    private void initializeAnswerArray(boolean[] a, int[] st, int[] e, int n, long[][] ph, long[][] pr, long[][] pw) {
        int i = 0;
        while (i < n) {
            a[i] = cP(st[i], e[i] + 1, n, ph, pr, pw);
            i++;
        }
    }

    private void iP(long[][] pw, int n) {
        pw[0][0] = pw[1][0] = 1;
        initializePwArray(pw, 0, n);
        initializePwArray(pw, 1, n);
    }

    private void initializePwArray(long[][] pw, int index, int n) {
        int i = 1;
        long m = (index == 0) ? M1 : M2;
        while (i <= n) {
            pw[index][i] = (pw[index][i-1] * B) % m;
            i++;
        }
    }

    private List<List<Integer>> bAL(int[] p) {
        List<List<Integer>> aj = initializeAdjacencyList(p.length);
        populateAdjacencyList(aj, p);
        sortAdjacencyList(aj);
        return aj;
    }

    
    private static final long M1 = 1000000007;
    private static final long M2 = 1000000009;
    private static final long B = 911382629;

    public boolean[] findAnswer(int[] p, String s) {
        int n = p.length;
        boolean[] a = new boolean[n];
        long[][] ph = new long[2][n + 1];
        long[][] pr = new long[2][n + 1];
        long[][] pw = new long[2][n + 1];
        iP(pw, n);
        
        List<List<Integer>> aj = bAL(p);
        int[] st = new int[n];
        int[] e = new int[n];
        String t = pT(aj, s, st, e);
        String r = new StringBuilder(t).reverse().toString();
        
        cPH(t, ph, pw);
        cPH(r, pr, pw);
        
        initializeAnswerArray(a, st, e, n, ph, pr, pw);
        
        return a;
    }
    
    private List<List<Integer>> initializeAdjacencyList(int size) {
        List<List<Integer>> aj = new ArrayList<>();
        int i = 0;
        while (i < size) {
            aj.add(new ArrayList<>());
            i++;
        }
        return aj;
    }

    private void populateAdjacencyList(List<List<Integer>> aj, int[] p) {
        int i = 1;
        while (i < p.length) {
            aj.get(p[i]).add(i);
            i++;
        }
    }

    private void sortAdjacencyList(List<List<Integer>> aj) {
        for (List<Integer> l : aj) {
            Collections.sort(l);
        }
    }

    private String pT(List<List<Integer>> aj, String s, int[] st, int[] e) {
        StringBuilder t = new StringBuilder();
        Deque<int[]> stk = new ArrayDeque<>();
        stk.push(new int[]{0, 0});
        int tm = 0;
        
        return processTree(aj, s, st, e, t, stk, tm);
    }

    private String processTree(List<List<Integer>> aj, String s, int[] st, int[] e, StringBuilder t, Deque<int[]> stk, int tm) {
        while (!stk.isEmpty()) {
            int[] cr = stk.pop();
            int nd = cr[0], pr = cr[1];
            
            if (pr == 1) {
                t.append(s.charAt(nd));
                e[nd] = tm++;
            } else {
                st[nd] = tm;
                stk.push(new int[]{nd, 1});
                pushChildrenToStack(aj.get(nd), stk);
            }
        }
        return t.toString();
    }

    private void pushChildrenToStack(List<Integer> children, Deque<int[]> stk) {
        int i = children.size() - 1;
        while (i >= 0) {
            stk.push(new int[]{children.get(i), 0});
            i--;
        }
    }

    private void cPH(String s, long[][] ph, long[][] pw) {
        calculatePrefixHash(s, ph[0], pw[0], M1);
        calculatePrefixHash(s, ph[1], pw[1], M2);
    }

    private void calculatePrefixHash(String s, long[] ph, long[] pw, long m) {
        int i = 0;
        while (i < s.length()) {
            ph[i+1] = (ph[i] * B + s.charAt(i)) % m;
            i++;
        }
    }

    private boolean cP(int l, int r, int n, long[][] ph, long[][] pr, long[][] pw) {
        long h1 = gH(l, r, ph[0], pw[0], M1);
        long h2 = gH(l, r, ph[1], pw[1], M2);
        int rl = n - r, rr = n - l;
        long rh1 = gH(rl, rr, pr[0], pw[0], M1);
        long rh2 = gH(rl, rr, pr[1], pw[1], M2);
        return h1 == rh1 && h2 == rh2;
    }

    private long gH(int l, int r, long[] ph, long[] pw, long m) {
        return (ph[r] - (ph[l] * pw[r - l]) % m + m) % m;
    }
}",1427878472
Zhao Yang,IAFB358kMw,101,3607,java,"class Solution {
    private static final int MX = 1000001;
    private static final long INF = (long) 1e18;
    
    private int[] cSPF() {
        int[] s = new int[MX];
        iSPF(s);
        cPF(s);
        return s;
    }
    private void iSPF(int[] s) {
        int i = 2;
        while (i < MX) {
            s[i] = i;
            i++;
        }
    }
    private void cPF(int[] s) {
        int i = 2;
        while (i * i < MX) {
            if (s[i] == i) {
                uM(s, i);
            }
            i++;
        }
    }
    private void uM(int[] s, int p) {
        int j = p * p;
        while (j < MX) {
            if (s[j] == j) {
                s[j] = p;
            }
            j += p;
        }
    }
    
    
    public int minOperations(int[] n) {
        int[] s = cSPF();
        long[] ps = iDPS(n[0], s);
        
        long[] fs = pA(n, ps, s);
        if (fs == null) return -1;
        long r = Math.min(fs[0], fs[2]);
        return r >= INF ? -1 : (int) r;
    }
    
    private long[] iDPS(int fn, int[] s) {
        long ko = 0, kv = fn, ro = INF, rv = 0;
        if (fn > 1 && s[fn] != fn) {
            ro = 1;
            rv = s[fn];
        }
        return new long[]{ko, kv, ro, rv};
    }
    private long[] pE(int n, long[] p, int[] s) {
        int cv = n;
        boolean cR = n > 1 && s[n] != n;
        int rv = cR ? s[n] : 0;
        long nko = INF, nro = INF;
        nko = cv >= p[1] ? Math.min(nko, p[0]) : nko;
        nko = cv >= p[3] ? Math.min(nko, p[2]) : nko;
        if (cR) {
            nro = rv >= p[1] ? Math.min(nro, p[0] + 1) : nro;
            nro = rv >= p[3] ? Math.min(nro, p[2] + 1) : nro;
        }
        return (nko == INF && nro == INF) ? null : new long[]{nko, cv, nro, rv};
    }
    private long[] pA(int[] n, long[] ps, int[] s) {
        int i = 1;
        while (i < n.length) {
            long[] ns = pE(n[i], ps, s);
            if (ns == null) return null;
            ps = ns;
            i++;
        }
        return ps;
    }
}",1427884411
chengxia you,cy171,104,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            c = Counter()
            good = False
            for j in range(i, n):
                c[s[j]] += 1
                if c[s[j]] == k:
                    good = True
                if good:
                    ans += 1
        return ans",1427878726
chengxia you,cy171,104,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        curr = """"
        for ch in target:
            for j in range(ord(ch) - ord(""a"") + 1):
                ans.append(curr + chr(j+ord(""a"")))
            curr += ch
        return ans",1427884996
chengxia you,cy171,104,3603,python3,"from itertools import accumulate
from typing import Optional, List


class Manacher:
    '''马拉车算法 O(n)
    '''

    def __init__(self, s: str):
        self._s = s
        self._n = len(s)
        self._odds = self._getOddRadius()
        self._evens = self._getEvenRadius()
        self._maxOdd1: Optional[List[int]] = None
        self._maxOdd2: Optional[List[int]] = None
        self._maxEven1: Optional[List[int]] = None
        self._maxEven2: Optional[List[int]] = None

    def getLongestOddStartsAt(self, index: int) -> int:
        """"""以s[index]开头的最长奇回文子串的长度
        """"""
        if self._maxOdd1 is None:
            self._maxOdd1 = [1] * self._n
            self._maxOdd2 = [1] * self._n
            for i, radius in enumerate(self._odds):
                start, end = i - radius + 1, i + radius - 1
                length = 2 * radius - 1
                self._maxOdd1[start] = max(self._maxOdd1[start], length)
                self._maxOdd2[end] = max(self._maxOdd2[end], length)

            # 根据左右更新端点
            for i in range(self._n):
                if i - 1 >= 0:
                    self._maxOdd1[i] = max(self._maxOdd1[i], self._maxOdd1[i - 1] - 2)
                if i + 1 < self._n:
                    self._maxOdd2[i] = max(self._maxOdd2[i], self._maxOdd2[i + 1] - 2)
        return self._maxOdd1[index]

    def getLongestOddEndsAt(self, index: int) -> int:
        """"""以s[index]结尾的最长奇回文子串的长度
        """"""
        if self._maxOdd2 is None:
            self._maxOdd1 = [1] * self._n
            self._maxOdd2 = [1] * self._n
            for i, radius in enumerate(self._odds):
                start, end = i - radius + 1, i + radius - 1
                length = 2 * radius - 1
                self._maxOdd1[start] = max(self._maxOdd1[start], length)
                self._maxOdd2[end] = max(self._maxOdd2[end], length)

            # 根据左右更新端点
            for i in range(self._n):
                if i - 1 >= 0:
                    self._maxOdd1[i] = max(self._maxOdd1[i], self._maxOdd1[i - 1] - 2)
                if i + 1 < self._n:
                    self._maxOdd2[i] = max(self._maxOdd2[i], self._maxOdd2[i + 1] - 2)
        return self._maxOdd2[index]

    def getLongestEvenStartsAt(self, index: int) -> int:
        """"""以s[index]开头的最长偶回文子串的长度
        """"""
        if self._maxEven1 is None:
            self._maxEven1 = [0] * self._n
            self._maxEven2 = [0] * self._n
            for i, radius in enumerate(self._evens):
                if radius == 0:
                    continue
                start = i - radius
                end = start + 2 * radius - 1
                length = 2 * radius
                self._maxEven1[start] = max(self._maxEven1[start], length)
                self._maxEven2[end] = max(self._maxEven2[end], length)

            # 根据左右更新端点
            for i in range(self._n):
                if i - 1 >= 0:
                    self._maxEven1[i] = max(self._maxEven1[i], self._maxEven1[i - 1] - 2)
                if i + 1 < self._n:
                    self._maxEven2[i] = max(self._maxEven2[i], self._maxEven2[i + 1] - 2)
        return self._maxEven1[index]

    def getLongestEvenEndsAt(self, index: int) -> int:
        """"""以s[index]结尾的最长偶回文子串的长度
        """"""
        if self._maxEven2 is None:
            self._maxEven1 = [0] * self._n
            self._maxEven2 = [0] * self._n
            for i, radius in enumerate(self._evens):
                if radius == 0:
                    continue
                start = i - radius
                end = start + 2 * radius - 1
                length = 2 * radius
                self._maxEven1[start] = max(self._maxEven1[start], length)
                self._maxEven2[end] = max(self._maxEven2[end], length)

            # 根据左右更新端点
            for i in range(self._n):
                if i - 1 >= 0:
                    self._maxEven1[i] = max(self._maxEven1[i], self._maxEven1[i - 1] - 2)
                if i + 1 < self._n:
                    self._maxEven2[i] = max(self._maxEven2[i], self._maxEven2[i + 1] - 2)
        return self._maxEven2[index]

    def _getOddRadius(self) -> List[int]:
        '''获取每个中心点的奇回文半径`radius`

        回文为`[pos-radius+1:pos+radius]`
        '''
        res = [0] * self._n
        left, right = 0, -1
        for i in range(self._n):
            k = 1 if i > right else min(res[left + right - i], right - i + 1)
            while 0 <= i - k and i + k < self._n and self._s[i - k] == self._s[i + k]:
                k += 1
            res[i] = k
            k -= 1
            if i + k > right:
                left = i - k
                right = i + k
        return res

    def _getEvenRadius(self) -> List[int]:
        '''获取每个中心点的偶回文半径`radius`

        回文为`[pos-radius:pos+radius]`
        '''
        res = [0] * self._n
        left, right = 0, -1
        for i in range(self._n):
            k = 0 if i > right else min(res[left + right - i + 1], right - i + 1)
            while 0 <= i - k - 1 and i + k < self._n and self._s[i - k - 1] == self._s[i + k]:
                k += 1
            res[i] = k
            k -= 1
            if i + k > right:
                left = i - k - 1
                right = i + k
        return res

    def __len__(self) -> int:
        return self._n


class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        child = defaultdict(list)
        for i, nei in enumerate(parent[1:],1):
            child[nei].append(i)
        for i in range(1, len(parent)):
            child[i].sort()
        dfstr = []
        r = [[] for i in range(len(parent))]
        def dfs(node):
            r[node].append(len(dfstr))
            for nei in child[node]:
                dfs(nei)
            dfstr.append(s[node])
            r[node].append(len(dfstr)-1)
        dfs(0)
        # print(dfstr)
        # print(r)
        m = Manacher(dfstr)
        odd = m._odds
        even = m._evens
        # print(odd, even)
        ans = []
        for l, r in r:
            if (r - l + 1)%2:
                mid = (l + r)//2
                # print(l, r, mid, odd[mid])
                if r - mid + 1 <= odd[mid]:
                    ans.append(True)
                else:
                    ans.append(False)
            else:
                mid = (l+r)//2 + 1
                if mid - l <= even[mid]:
                    ans.append(True)
                else:
                    ans.append(False)
        return ans",1427858949
chengxia you,cy171,104,3607,python3,"class PrimeTable:
    def __init__(self, n:int) -> None:
        self.n = n
        self.primes = [] # 2到n 之间所有的质数
        self.max_div = list(range(n+1))
        self.max_div[1] = 1
        self.phi = list(range(n+1))

        for i in range(2, n + 1):
            if self.max_div[i] == i:
                self.primes.append(i)
                for j in range(i, n+1, i):
                    self.max_div[j] = i
                    self.phi[j] = self.phi[j] // i * (i-1)

    #检查知否为质数，最高能到n**2
    def is_prime(self, x:int):
        if x < 2: return False
        if x <= self.n: return self.max_div[x] == x
        for p in self.primes:
            if p * p > x: break
            if x % p == 0: return False
        return True

    # 输出x 的质因子以及 数量，最高能到n**2
    def prime_factorization(self, x:int):
        if x > self.n:
            for p in self.primes:
                if p * p > x: break
                if x <= self.n: break
                if x % p == 0:
                    cnt = 0
                    while x % p == 0:
                        cnt += 1
                        x //= p
                    yield p, cnt
        while (1 < x and x <= self.n):
            p, cnt = self.max_div[x], 0
            while x % p == 0:
                cnt += 1
                x //= p
            yield p, cnt
        if x >= self.n and x > 1:
            yield x, 1

    # 输出x 的质因子以及 数量，最高能到n**2, 返回Counter
    def prime_factor(self, x:int):
        c = Counter()
        if x > self.n:
            for p in self.primes:
                if p * p > x: break
                if x <= self.n: break
                if x % p == 0:
                    cnt = 0
                    while x % p == 0:
                        cnt += 1
                        x //= p
                    c[p] = cnt
        while (1 < x and x <= self.n):
            p, cnt = self.max_div[x], 0
            while x % p == 0:
                cnt += 1
                x //= p
            c[p] = cnt
        if x >= self.n and x > 1:
            c[x] = cnt
        return c

    # 输出所有因子
    def get_factors(self, x:int):
        factors = [1]
        for p, b in self.prime_factorization(x):
            n = len(factors)
            for j in range(1, b+1):
                for d in factors[:n]:
                    factors.append(d * (p ** j))
        return factors

pt = PrimeTable(10 ** 6)
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        curr = nums[-1]
        ans = 0
        for i in range(n-2, -1,-1):
            if nums[i] <= curr:
                curr = nums[i]
            else:
                t = pt.get_factors(nums[i])
                t.sort()
                # print(t)
                val = nums[i]
                if len(t) > 1:
                    val = nums[i] // t[-2]
                if val > curr:
                    return -1
                curr = val
                ans += 1
        return ans",1427873984
Suryaansh Rathinam,suryaansh28,105,3502,cpp,"#include <unordered_map>
#include <string>

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int result = 0;
         for (int i = 0; i < n; ++i) {
            unordered_map<char, int> freqMap; 
            for (int j = i; j < n; ++j) {
                freqMap[s[j]]++; 
                bool valid = false;
                for (auto &entry : freqMap) {
                    if (entry.second >= k) {
                        valid = true;
                        break;
                    }
                }
                if (valid) {
                    result += 1;
                }
            }
        }
        
        return result;
    }
};
",1427828956
Suryaansh Rathinam,suryaansh28,105,3566,cpp,"#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";

        for (char c : target) {
            current += 'a';
            result.push_back(current);
            
            while (current.back() != c) {
                current.back() = (current.back() - 'a' + 1) % 26 + 'a';
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427825151
Suryaansh Rathinam,suryaansh28,105,3603,cpp,"class Solution {
public:
    const int MOD1 = 1e9 + 7;
    const int MOD2 = 1e9 + 9;
    const int BASE1 = 911;
    const int BASE2 = 1597;

    vector<int> powBase1, powBase2;
    vector<int> start, end;
    string dfsStr;
    int pos = 0;
    string s;
    vector<vector<int>> tree;

    void precomputePowers(int n) {
        powBase1.resize(n + 1);
        powBase2.resize(n + 1);
        powBase1[0] = powBase2[0] = 1;
        for (int i = 1; i <= n; ++i) {
            powBase1[i] = (1LL * powBase1[i - 1] * BASE1) % MOD1;
            powBase2[i] = (1LL * powBase2[i - 1] * BASE2) % MOD2;
        }
    }

    void buildDfsStr(int x) {
        start[x] = pos;
        for (int y : tree[x]) {
            buildDfsStr(y);
        }
        dfsStr[pos++] = s[x];
        end[x] = pos - 1;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        this->s = s;
        tree.resize(n);
        start.resize(n);
        end.resize(n);
        dfsStr.resize(n);

        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        precomputePowers(n);
        buildDfsStr(0);

        // Compute prefix hashes
        vector<int> prefixHash1(n + 1, 0), prefixHash2(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            prefixHash1[i + 1] = (1LL * prefixHash1[i] * BASE1 + dfsStr[i]) % MOD1;
            prefixHash2[i + 1] = (1LL * prefixHash2[i] * BASE2 + dfsStr[i]) % MOD2;
        }

        // Compute reverse prefix hashes
        vector<int> reverseHash1(n + 1, 0), reverseHash2(n + 1, 0);
        for (int i = n - 1; i >= 0; --i) {
            reverseHash1[i] = (1LL * reverseHash1[i + 1] * BASE1 + dfsStr[i]) % MOD1;
            reverseHash2[i] = (1LL * reverseHash2[i + 1] * BASE2 + dfsStr[i]) % MOD2;
        }

        vector<bool> answer(n);
        for (int x = 0; x < n; ++x) {
            int l = start[x], r = end[x];
            int len = r - l + 1;

            // Forward hash
            int hashFwd1 = (prefixHash1[r + 1] - (1LL * prefixHash1[l] * powBase1[len]) % MOD1 + MOD1) % MOD1;
            int hashFwd2 = (prefixHash2[r + 1] - (1LL * prefixHash2[l] * powBase2[len]) % MOD2 + MOD2) % MOD2;

            // Reverse hash
            int hashRev1 = (reverseHash1[l] - (1LL * reverseHash1[r + 1] * powBase1[len]) % MOD1 + MOD1) % MOD1;
            int hashRev2 = (reverseHash2[l] - (1LL * reverseHash2[r + 1] * powBase2[len]) % MOD2 + MOD2) % MOD2;

            if (hashFwd1 == hashRev1 && hashFwd2 == hashRev2) {
                answer[x] = true;
            } else {
                answer[x] = false;
            }
        }

        return answer;
    }
};
",1427860375
Suryaansh Rathinam,suryaansh28,105,3607,cpp,"#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

class Solution {
public:
    const int INF = 1e9;
    std::vector<int> primes;

    // Sieve of Eratosthenes to generate primes up to limit
    void generate_primes(int limit) {
        std::vector<bool> is_prime(limit + 1, true);
        for (int i = 2; i <= limit; ++i) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (long long j = (long long)i * i; j <= limit; j += i) {
                    is_prime[j] = false;
                }
            }
        }
    }

    int get_smallest_prime_factor(int x) {
        if (x % 2 == 0) return 2;
        for (int p : primes) {
            if (p * p > x) break;
            if (x % p == 0) return p;
        }
        return x; // x is prime
    }

    int minOperations(std::vector<int>& nums) {
        int n = nums.size();
        generate_primes(31623); // Primes up to sqrt(1e9)
        std::vector<int> spf(n);
        for (int i = 0; i < n; ++i) {
            spf[i] = get_smallest_prime_factor(nums[i]);
        }

        // dp[i][0]: min operations up to i, nums[i] kept as is
        // dp[i][1]: min operations up to i, nums[i] reduced to spf[i]
        int dp_prev[2] = {INF, INF}, dp_curr[2];
        dp_prev[0] = 0; // Starting with nums[0] as is
        dp_prev[1] = 1; // Starting with nums[0] reduced to spf[0]
        int val_prev[2] = {nums[0], spf[0]};

        for (int i = 1; i < n; ++i) {
            dp_curr[0] = dp_curr[1] = INF;
            int val_curr[2] = {nums[i], spf[i]};
            // Option 1: Keep nums[i] as is
            for (int k = 0; k < 2; ++k) {
                if (val_curr[0] >= val_prev[k]) {
                    if (dp_prev[k] < dp_curr[0]) {
                        dp_curr[0] = dp_prev[k];
                        val_curr[0] = nums[i];
                    }
                }
            }
            // Option 2: Reduce nums[i] to spf[i]
            for (int k = 0; k < 2; ++k) {
                if (val_curr[1] >= val_prev[k]) {
                    if (dp_prev[k] + 1 < dp_curr[1]) {
                        dp_curr[1] = dp_prev[k] + 1;
                        val_curr[1] = spf[i];
                    }
                }
            }
            // If both options are impossible, return -1
            if (dp_curr[0] == INF && dp_curr[1] == INF) return -1;
            dp_prev[0] = dp_curr[0];
            dp_prev[1] = dp_curr[1];
            val_prev[0] = val_curr[0];
            val_prev[1] = val_curr[1];
        }

        int ans = std::min(dp_prev[0], dp_prev[1]);
        return ans >= INF ? -1 : ans;
    }
};
",1427840135
Huzaifa Khilawala,RedHeadphone,106,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        l,r = 0,0 
        c = [0]*26
        ans = 0

        def check(c,k):
            for i in range(26):
                if c[i]>=k:
                    return True

            return False

        while r < n:
            c[ord(s[r]) - ord('a')] += 1
            
            while l<r:
                c[ord(s[l]) - ord('a')]-=1
                if not check(c,k):
                    c[ord(s[l]) - ord('a')]+=1
                    break
                else:
                    l+=1


            if check(c,k):
                ans+=l+1
            
            r+=1
        
        return ans ",1427834974
Huzaifa Khilawala,RedHeadphone,106,3566,python3,"
class Solution:
    def stringSequence(self, target: str) -> List[str]:
        curr = []

        ans = []

        for i in range(len(target)):
            curr.append('a')

            ans.append(''.join(curr))

            while curr[-1] != target[i]:
                c = curr.pop()

                curr.append(chr(ord(c) + 1))

                ans.append(''.join(curr))

        return ans",1427833331
Huzaifa Khilawala,RedHeadphone,106,3603,python3,"
class RangeHash:
    def __init__(self, s, mod=2147483647, base1=None, base2=None):
        s = [ord(i) for i in s]
        base1 = base1 if base1 is not None else random.randrange(mod)
        base2 = base2 if base2 is not None else random.randrange(mod)
        self.mod, self.base1, self.base2 = mod, base1, base2
        _len = len(s)
        f_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)
        s_hash, s_pow = f_hash[:], f_pow[:]
        for i in range(_len):
            f_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod
            s_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod
            f_pow[i + 1] = base1 * f_pow[i] % mod
            s_pow[i + 1] = base2 * s_pow[i] % mod
        self.f_hash, self.f_pow = f_hash, f_pow
        self.s_hash, self.s_pow = s_hash, s_pow

    def get_hash(self, start, stop):
        return (
            (self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start])
            % self.mod,
            (self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start])
            % self.mod,
        )

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        ans = [False] * n

        tree = [[] for _ in range(n)]

        for i in range(1, n):
            tree[parent[i]].append(i)
        
        for i in range(n):
            tree[i].sort()

        first = {}
        last = {}
        ind = 0
        dfs_s = []

        def dfs(node):
            nonlocal ind

            first[node] = ind
            for child in tree[node]:
                dfs(child)
            dfs_s.append(s[node])
            ind += 1
            last[node] = ind 

        dfs(0)
        dfs_s = ''.join(dfs_s)
        rh = RangeHash(dfs_s)
        rh_rev = RangeHash(dfs_s[::-1],base1=rh.base1,base2=rh.base2,mod=rh.mod)
        nn = len(dfs_s)

        for i in range(n):
            st,end = first[i], last[i]

            straight = rh.get_hash(st, end)
            rev = rh_rev.get_hash(nn-end, nn-st)
            # print(dfs_s[st:end],nn-end,nn-st)
            ans[i] = (straight == rev)

        return ans ",1427885297
Huzaifa Khilawala,RedHeadphone,106,3607,python3,"
class Factors:
    def __init__(self, pre_compute_limit=0):
        self.last_prime_factor = [0] * pre_compute_limit
        for i in range(2, pre_compute_limit):
            if self.last_prime_factor[i] > 0:
                continue
            for j in range(i, pre_compute_limit, i):
                if self.last_prime_factor[j] > 0:
                    continue
                self.last_prime_factor[j] = i 
                
fs = Factors(10**6 + 50)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0

        for i in range(n-2,-1,-1):
            nex = nums[i+1]
            while nums[i]>nex:
                lpf = fs.last_prime_factor[nums[i]]
                if lpf==0 or lpf==nums[i]:
                    return -1
                ans+=1
                nums[i] = lpf

        return ans",1427856196
Dhruv Pasricha,pasricha_dhruv,107,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();
        for(int i = 0; i < n; ++i)
        {
            vector<int> freq(26);
            int mx = 0;
            for(int j = i; j < n; ++j)
            {
                freq[s[j] - 'a']++;
                mx = max(mx, freq[s[j] - 'a']);
                if(mx >= k) ++ans;
            }
        }
        return ans;
    }
};",1427826718
Dhruv Pasricha,pasricha_dhruv,107,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        vector<string> ans;
        string cur;
        for(int i = 0; i < n; ++i)
        {
            cur += 'a';
            ans.push_back(cur);
            while(target[i] != cur.back())
            {
                cur.back()++;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824909
Dhruv Pasricha,pasricha_dhruv,107,3603,cpp,"vector<int> tour, size_;

void dfs(vector<int> adj[], int cur)
{
    tour.push_back(cur);
    size_[cur]++;

    for(int nb : adj[cur])
    {
        dfs(adj, nb);
        size_[cur] += size_[nb];
    }
}

// https://github.com/ShahjalalShohag/code-library/blob/main/Strings/Manachers.cpp
struct Manacher {
  vector<int> p[2];
  // p[1][i] = (max odd length palindrome centered at i) / 2 [floor division]
  // p[0][i] = same for even, it considers the right center
  // e.g. for s = ""abbabba"", p[1][3] = 3, p[0][2] = 2
  Manacher(string s) {
    int n = s.size();
    p[0].resize(n + 1);
    p[1].resize(n);
    for (int z = 0; z < 2; z++) {
      for (int i = 0, l = 0, r = 0; i < n; i++) {
        int t = r - i + !z;
        if (i < r) p[z][i] = min(t, p[z][l + t]);
        int L = i - p[z][i], R = i + p[z][i] - !z;
        while (L >= 1 && R + 1 < n && s[L - 1] == s[R + 1]) 
          p[z][i]++, L--, R++;
        if (R > r) l = L, r = R;
      }
    }
  }
  bool is_palindrome(int l, int r) {
    int mid = (l + r + 1) / 2, len = r - l + 1;
    return 2 * p[len % 2][mid] + len % 2 >= len;
  }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string str) {
        int n = str.size();
        tour.clear();
        tour.reserve(n);
        size_.clear();
        size_.resize(n);
        vector<int> adj[n];
        for(int i = 0; i < n; ++i)
        {
            int u = i, v = parent[i];
            if(v != -1) adj[v].push_back(u);
        }

        for(int i = 0; i < n; ++i)
        {
            sort(adj[i].begin(), adj[i].end());
            reverse(adj[i].begin(), adj[i].end());
        }

        dfs(adj, 0);


        string s = str;
        
        for(int i = 0; i < n; ++i)
        {
            s[i] = str[tour[i]];
        }


        vector<bool>ans(n);
        Manacher manacher(s);
        auto p = manacher.p;
        for(int i = 0; i < n; ++i)
        {
            int start = i;
            int end = i + size_[tour[i]] - 1;

            int len = end - start + 1;

            if(len % 2 == 0)
            {
                int c = ((start + end) / 2) + 1;
                ans[tour[i]] = 2 * p[0][c] >= len;
            }
            else
            {
                int c = ((start + end) / 2);
                ans[tour[i]] = (2 * p[1][c] + 1) >= len;
            }
        }

        return ans;
    }
};",1427877802
Dhruv Pasricha,pasricha_dhruv,107,3607,cpp,"const int N = 1e6 + 10;
int spf[N + 1], done = 0, dp[N][2];

void pre()
{
    if(done) return;

    for(int i = 1; i <= N; ++i)
        spf[i] = i;
    
    for(int i = 2; i <= N; ++i)
        if(spf[i] == i)
            for(int j = i; j <= N; j += i)
                spf[j] = min(spf[j], i);
    
    done = 1;
}

int solve(vector<int> &nums, int idx, bool changed, int prev)
{
    if(idx == nums.size()) return 0;

    int &ans = dp[idx][changed]; if(ans != -1) return ans;

    int ans1 = (nums[idx] >= prev) ? solve(nums, idx + 1, false, nums[idx]) : N;
    int ans2 = (spf[nums[idx]] >= prev) ? 1 + solve(nums, idx + 1, true, spf[nums[idx]]) : N;

    return ans = min(ans1, ans2);
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        pre();
        int n = nums.size();
        for(int i = 0; i < n; ++i) dp[i][0] = dp[i][1] = -1;
        int ans = solve(nums, 0, false, -1);
        if(ans > n) ans = -1;
        return ans;
    }
};",1427847660
Jose Coves,jcoves,108,3502,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = sz(s), ans = 0, l = 0, good = 0;
        vi cnt(26);
        forn(r, n) {
            int rc = s[r] - 'a';
            if(++cnt[rc] == k) good++;
            while(l < n and good > 0){
                int lc = s[l] - 'a';
                if(cnt[lc]-- == k) good--;
                l++;
            }
            ans += l;
        }
        return ans;
    }
    int SlownumberOfSubstrings(string s, int k) {
        int n = sz(s), ans = 0, l = 0, good = 0;
        vi cnt(26);
        forn(r, n) {
            int rc = s[r] - 'a';
            if(++cnt[rc] == k) good++;
            while(l < n and good > 0){
                int lc = s[l] - 'a';
                if(cnt[lc]-- == k) good--;
                l++;
            }
            debug2(r, l);
            ans += l;
        }
        return ans;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    string s; int k;
    cin >> s >> k;
    out(sol.numberOfSubstrings(s, k));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1427841395
Jose Coves,jcoves,108,3566,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    vector<string> stringSequence(string target) {
        vc<string> ans;
        string s;
        for(char c: target){
            char a = 'a';
            while(a <= c){
                ans.pb(s + a);
                a++;
            }
            s += c;
        }
        return ans;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;

}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1427826155
Jose Coves,jcoves,108,3603,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
const ll MOD = (1ll<<61) - 1;
    const int sigma = 256; // max size of alphabet
    ll mulmod(ll a, ll b) { // a*b % MOD by splitting bits
        const static ll LOWER = (1ll<<30) - 1, GET31 = (1ll<<31) - 1;
        ll l1 = a&LOWER, h1 = a>>30, l2 = b&LOWER, h2 = b>>30;
        ll m = l1*h2 + l2*h1, h = h1*h2;
        ll ans = l1*l2 + (h>>1) + ((h&1)<<60) + (m>>31) + ((m&GET31)<<30) + 1;
        ans = (ans&MOD) + (ans>>61); ans = (ans&MOD) + (ans>>61);
        return ans - 1;
    }

    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

    ll uniform(ll l, ll r) {
        uniform_int_distribution<ll> uid(l, r);
        return uid(rng);
    }

    struct Hash {
        static ll P; // shared for x-string checks
        vector<ll> h, p;

        Hash(auto &s) : h(s.size()), p(s.size()) {
            for(auto x: s) assert(x < sigma);
            p[0] = 1, h[0] = s[0];
            for (int i = 1; i < sz(s); i++)
                p[i] = mulmod(p[i - 1], P), h[i] = (mulmod(h[i - 1], P) + s[i])%MOD;
        }
        ll operator()(int r) { // return Hash s[0, r]
            return h[r];
        }
        ll operator()(int l, int r) { // return Hash s[l, r]
            ll val = h[r] - (l ? mulmod(h[l - 1], p[r - l + 1]) : 0);
            return val < 0 ? val + MOD : val;
        }
    };
    ll Hash::P = uniform(sigma, MOD - 1); // l > |alphabet|

class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = sz(p);
        vvi g(n);
        fornn(x, 1, n){
            g[p[x]].pb(x);
        }
        forn(i, n) sort(all(g[i]));
        string t;
        vi ls(n), rs(n);
        auto dfs = yf([&](auto f, int x) -> void {
            // string add;
            ls[x] = sz(t);
            for(int y: g[x]){
                f(y);
            }
            t += s[x];
            rs[x] = sz(t);
        }); dfs(0);
        debug(t);
        forn(i, n){
            debug4(i, ls[i], rs[i], t.substr(ls[i], rs[i] - ls[i]));
        }
        auto rt = t; reverse(all(rt));
        Hash h(t), rh(rt);
        vc<bool> ans(n);
        forn(i, n){
            int l = ls[i], r = rs[i] - 1;
            if(h(l, r) == rh(n - r - 1, n - l - 1)) ans[i] = true;
        }
        return ans;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi p; string s;
    cin >> p >> s;
    out(sol.findAnswer(p, s));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1427878278
Jose Coves,jcoves,108,3607,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e6 + 3;
const int mod = 1e9+7;
struct Sieve {
    vi isp, primes, fdiv;
    vvi divisors;
    int n = -1;
    void init(int _n=maxn){
        n = _n;
        primes.clear();
        isp.assign(n, 1);
        fdiv.assign(n, 0);
        fdiv[0]=fdiv[1]=1;
        isp[0]=isp[1]=0;
        for(int i=2; i<n; ++i){
            if(!isp[i]) continue;
            fdiv[i] = i;
            primes.push_back(i);
            for(int j=i+i; j<n; j+=i) {
                isp[j] = 0;
                if(fdiv[j]==0)
                    fdiv[j] = i;
            }
        }
        fornn(x, 1, 10) debug2(x, fdiv[x]);
    }
    void computeDivs(){
        divisors.resize(n);
        fornn(i, 2, n) for(int j=i; j<n; j+=i) divisors[j].pb(i);
    }

    vi getFactorList(ll val){ // 12 = [2,2,3]
        vi ans;
        if(val < n){ // use cache
            auto x = val;
            while(x > 1){
                auto p = fdiv[x];
                ans.pb(p);
                x /= p;
            }
        } else {
            assert(val <= sqr(n - 1LL));
            auto x = val;
            for(int p: primes){
                if(p > x or p*1LL*p > val) break;
                while(x % p == 0){
                    ans.pb(p);
                    x /= p;
                }
            }
            assert(x <= numeric_limits<int>::max());
            if(x > 1) ans.pb(int(x));
        }
        return ans;
    }
    map<int,int> getFactorMap(ll val){ // 12 = [2:2, 3:1]
        map<int,int> ans;
        if(val < n){ // use cache
            auto x = val;
            while(x > 1){
                auto p = fdiv[x];
                ans[p]++;
                x /= p;
            }
        } else {
            if(!(val <= sqr(n - 1LL))) debug2(val, n);
            // else assert(val <= sqr(n - 1LL));
            auto x = val;
            for(int p: primes){
                if(p > x or p*1LL*p > val) break;
                while(x % p == 0){
                    ans[p]++;
                    x /= p;
                }
            }
            assert(x <= numeric_limits<int>::max());
            if(x > 1) ans[(int)x]++;
        }
        return ans;
    }
    void f(vpii& divs, vll &ans, int i, ll val){
        // if(val > hi) return;
        if(i < 0) {
            ans.pb(val); return;
        }
        ll cur = 1;
        f(divs, ans, i-1, val);
        auto [x, c] = divs[i];
        forn(j, c){
            cur *= x;
            f(divs, ans, i-1, val*cur);
        }
    }

    vll getAllDivs(ll x, map<int, int> factorMap = {}){ // 12 = [1 2 3 4 6 12]
        if(factorMap.empty()) factorMap = getFactorMap(x);
        else {
            ll cur = 1; for(auto [k, v]: factorMap) forn(i, v) cur *= k;
            assert(cur == x);
        }
        vpii divs; for(auto [k,v]: factorMap) divs.eb(k, v);
        vll ans; f(divs, ans, sz(factorMap)-1, 1);
        return ans;
    }
    ll getNumDivs(map<int, int>& divs){ // 12 = [2:2, 3:1] = 3 * 2
        ll ans = 1;
        for(auto [k, v]: divs) ans *= (v+1);
        return ans;
    }
    int getSquareDiv(int x){ // largest d: d*d | x;
        int val = 1;
        for(auto p: primes){
            if(p*p*p > x) break;
            int t = 0;
            while(x%p == 0){
                x /= p;
                t++;
                if(t%2 == 0) val *= p;
            }
        }
        int root = sqrt(x); if(x>1 and root*root == x) val *= root;
        return val;
    }
} sieve;


class Solution {
public:
    int minOperations(vector<int>& a) {
        
        if(sieve.fdiv.empty()) sieve.init();
        int n = sz(a), ans = 0;
        debug2(n, a);
        forb(i, n-1){
            int &x = a[i], y = a[i+1];
            while(x > y) {
                int d = sieve.fdiv[x];
                if(d == x) return -1;
                x = d;
                ans++;
            }
        }
        return ans;
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vi a; cin >> a;
    out(sol.minOperations(a));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1427853541
Chinnu,chinnu11,109,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),r=0;
        for(int i=0;i<n;++i){
            int f[26]={0},m=0;
            for(int j=i;j<n;++j){
                m=max(m,++f[s[j]-'a']);
                if(m>=k)r++;
            }
        }
        return r;
    }
};
",1427828128
Chinnu,chinnu11,109,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> s;
        string c="""";
        for(char x:t){
            c+='a';
            s.push_back(c);
            int k=(x-'a')%26;
            for(int i=0;i<k;++i){
                c.back()=c.back()=='z'?'a':c.back()+1;
                s.push_back(c);
            }
        }
        return s;
    }
};",1427825471
Chinnu,chinnu11,109,3603,cpp,"typedef long long ll;

struct HPair{ll f,s;};

class Solution {
public:
    const ll M1=1000000007,M2=1000000009,B=911382629;

    void compPowers(int n,vector<ll>&p1,vector<ll>&p2){
        p1.resize(n+2,1);p2.resize(n+2,1);
        for(int i=1;i<=n+1;++i){
            p1[i]=(p1[i-1]*B)%M1;
            p2[i]=(p2[i-1]*B)%M2;
        }
    }

    vector<bool> findAnswer(vector<int>&p,string s){
        int n=p.size();
        vector<vector<int>>ch(n);
        int root=-1;
        for(int i=0;i<n;++i){
            if(p[i]==-1)root=i;
            else ch[p[i]].push_back(i);
        }
        for(int i=0;i<n;++i)sort(ch[i].begin(),ch[i].end());

        vector<ll>p1,p2;
        compPowers(n,p1,p2);

        vector<HPair>hf(n,HPair{0,0}),hr(n,HPair{0,0});
        vector<int>len(n,0);
        vector<bool>ans(n,false);

        stack<pair<int,int>>stk;
        stk.emplace(root,0);

        while(!stk.empty()){
            auto &[node,idx]=stk.top();
            if(idx<ch[node].size()){
                int c=ch[node][idx];
                stk.top().second++;
                stk.emplace(c,0);
            }else{
                stk.pop();
                ll f1=0,f2=0,r1=0,r2=0;
                int totLen=0;

                for(auto &c:ch[node]){
                    f1=(f1*p1[len[c]]+hf[c].f)%M1;
                    f2=(f2*p2[len[c]]+hf[c].s)%M2;
                    r1=(r1+hr[c].f*p1[totLen])%M1;
                    r2=(r2+hr[c].s*p2[totLen])%M2;
                    totLen+=len[c];
                }

                f1=(f1*p1[1]+(s[node]-'a'+1))%M1;
                f2=(f2*p2[1]+(s[node]-'a'+1))%M2;
                r1=(((s[node]-'a'+1)*p1[totLen])%M1+r1)%M1;
                r2=(((s[node]-'a'+1)*p2[totLen])%M2+r2)%M2;
                totLen++;

                hf[node]={f1,f2};
                hr[node]={r1,r2};
                len[node]=totLen;

                ans[node]=(hf[node].f==hr[node].f&&hf[node].s==hr[node].s);
            }
        }
        return ans;
    }
};
",1427852754
Chinnu,chinnu11,109,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        int n=a.size();
        if(n<=1)return 0;

        const int MAX=1000000;
        vector<int> spf(MAX+1);
        for(int i=0;i<=MAX;i++)spf[i]=i;
        for(int p=2;p*p<=MAX;p++)if(spf[p]==p)for(int m=p*p;m<=MAX;m+=p)if(spf[m]==m)spf[m]=p;

        long long ops=0;
        for(int i=n-2;i>=0;i--){
            while(a[i]>a[i+1]){
                if(a[i]==1||spf[a[i]]==a[i])return -1;
                a[i]=spf[a[i]];
                ops++;
            }
        }
        return ops;
    }
};
",1427861883
Sanskar Soni,Sunscar-Sony,110,3502,rust,"impl Solution {
    pub fn number_of_substrings(s: String, k: i32) -> i32 {
        let a = s.len();
        let mut b = 0;
        let c: Vec<char> = s.chars().collect();
        // let mut d = 0;
        // while d < a {
        let mut d = 0;
        while d < a {
            let mut e = vec![0; 26];
            let mut f = d;
            while f < a {
        //     let mut e = vec![0; 26];
        //     let mut f = d;
        //     while f < a {
                let g = (c[f] as u8 - b'a') as usize;
                e[g] += 1;
                let mut h = 0;
                let mut i = false;
                while h < 26 {
                    if e[h] >= k {
                        i = true;
                        break;
                //     }
                //     h += 1;
                // }
                    }
                    h += 1;
                }
                if i {
                    b += 1;
                }
                f += 1;
                // if i {
                //     b += 1;
                // }
                // f += 1;
            }
            d += 1;
        }
        b
    }
}
",1427845533
Sanskar Soni,Sunscar-Sony,110,3566,rust,"impl Solution {
    pub fn string_sequence(target: String) -> Vec<String> {
        let mut a = Vec::new(); 
        let mut b = String::new(); 
        
        let mut i = 0;
        while i < target.len() {
            // b.push('a');
            // a.push(b.clone());
            b.push('a');
            a.push(b.clone());
            
            let mut c = b.chars().last().unwrap();
            while c != target.chars().nth(i).unwrap() {
                let d = b.pop().unwrap();
            // let mut c = b.chars().last().unwrap();
            // while c != target.chars().nth(i).unwrap() {
            //     let d = b.pop().unwrap();
                b.push((d as u8 + 1) as char);
                a.push(b.clone());
        //         c = b.chars().last().unwrap();
        //     }
                c = b.chars().last().unwrap();
            }
            i += 1;
        }
        //     i += 1;
        // }
        a
    }
}
",1427840756
Sanskar Soni,Sunscar-Sony,110,3603,kotlin,"class Solution {
    fun findAnswer(p: IntArray, s: String): BooleanArray {
        val n = p.size
        val c = Array(n) { mutableListOf<Int>() }
        var i = 1

        // while (i < n) {
        //     c[p[i]].add(i)
        while (i < n) {
            c[p[i]].add(i)
            i++
        }
        val b = StringBuilder()
        // }

        // val b = StringBuilder()
        val d = IntArray(n)
        val e = IntArray(n)
        var t = 0

        fun f(x: Int) {
            d[x] = t
            var j = 0
        //     while (j < c[x].size) {
        //         f(c[x][j])
        //         j++
            while (j < c[x].size) {
                f(c[x][j])
                j++
            }
            b.append(s[x])
            e[x] = t
            t++
        }
        //     b.append(s[x])
        //     e[x] = t
        //     t++
        // }

        f(0)

        val m1 = 1000000007L
        val m2 = 1000000009L
        val b1 = 911L
        val b2 = 3571L

        val pow1 = LongArray(n + 1) { 1 }
        val pow2 = LongArray(n + 1) { 1 }
        var k = 1

        while (k <= n) {
            pow1[k] = (pow1[k - 1] * b1 % m1)
            pow2[k] = (pow2[k - 1] * b2 % m2)
            k++
        }

        val h1 = LongArray(n + 1)
        val h2 = LongArray(n + 1)
        var l = 0

        // while (l < n) {
        //     val v = b[l] - 'a' + 1
        while (l < n) {
            val v = b[l] - 'a' + 1
            h1[l + 1] = (h1[l] * b1 + v) % m1
            h2[l + 1] = (h2[l] * b2 + v) % m2
            l++
        }
        //     h1[l + 1] = (h1[l] * b1 + v) % m1
        // }

        val rB = b.reverse().toString()
        val rh1 = LongArray(n + 1)
        val rh2 = LongArray(n + 1)
        var o = 0

        while (o < n) {
            val v = rB[o] - 'a' + 1
            rh1[o + 1] = (rh1[o] * b1 + v) % m1
            rh2[o + 1] = (rh2[o] * b2 + v) % m2
            o++
        }

        val ans = BooleanArray(n)
        var x = 0

        while (x < n) {
            // val l = d[x]
            // val r = e[x]
            val l = d[x]
            val r = e[x]

            val h1Val = (h1[r + 1] - (h1[l] * pow1[r - l + 1] % m1 + m1) % m1 + m1) % m1
            val h2Val = (h2[r + 1] - (h2[l] * pow2[r - l + 1] % m2 + m2) % m2 + m2) % m2

            val revL = n - r - 1
            val revR = n - l - 1
            // val h1Val = (h1[r + 1] - (h1[l] * pow1[r - l + 1] % m1 + m1) % m1 + m1) % m1
            // val revR = n - l - 1
            val revH1 = (rh1[revR + 1] - (rh1[revL] * pow1[revR - revL + 1] % m1 + m1) % m1 + m1) % m1
            // val revH2 = (rh2[revR + 1] - (rh2[revL] * pow2[revR - revL + 1] % m2 + m2) % m2 + m2) % m2
            val revH2 = (rh2[revR + 1] - (rh2[revL] * pow2[revR - revL + 1] % m2 + m2) % m2 + m2) % m2

            ans[x] = (h1Val == revH1 && h2Val == revH2)
            x++
            // ans[x] = (h1Val == revH1 && h2Val == revH2)
            // x++
        }

        return ans
    }
}
",1427886738
Sanskar Soni,Sunscar-Sony,110,3607,rust,"impl Solution {
    pub fn min_operations(mut a: Vec<i32>) -> i32 {
        let b = a.len();
        let mut c = 0;

        // fn d(e: i32) -> i32 {
        //     if e == 1 {
        fn d(e: i32) -> i32 {
            if e == 1 {
                return 1;
            }
            let mut f = 2;
        //         return 1;
        //     }
        //     let mut f = 2;
            while f <= (e as f64).sqrt() as i32 {
                if e % f == 0 {
                    return e / f;
                }
                f += 1;
            }
            1
        }

        let mut g = b - 2;
        // while g != usize::MAX {
        while g != usize::MAX {
            while a[g] > a[g + 1] {
                let h = d(a[g]);
                if h == 1 {
                    return -1;
        //     while a[g] > a[g + 1] {
        //         let h = d(a[g]);
        //         if h == 1 {
        //             return -1;
                }
                a[g] /= h;
                c += 1;
            }
            g = g.wrapping_sub(1);
        }

        c
    }
}
",1427854263
Claude_Ballad,Claude_Ballad,111,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c=0
        for i in range(len(s)):
            f=[0]*26
            m=False
            for j in range(i,len(s)):
                f[ord(s[j])-97]+=1
                if not m and f[ord(s[j])-97]>=k:m=True
                if m:c+=1
        return c",1427823784
Claude_Ballad,Claude_Ballad,111,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        s,c=[],[]
        for ch in target:
            c.append('a')
            s.append(''.join(c))
            p=(ord(ch)-97)%26
            for _ in range(p):
                c[-1]='a' if c[-1]=='z' else chr(ord(c[-1])+1)
                s.append(''.join(c))
        return s",1427824165
Claude_Ballad,Claude_Ballad,111,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        M,B=10**9+7,911382629
        n=len(parent)
        c=defaultdict(list)
        for i in range(1,n):
            c[parent[i]].append(i)
        p=[1]*(n+1)
        for i in range(1,n+1):
            p[i]=(p[i-1]*B)%M
        fh=[0]*n
        rh=[0]*n
        l=[0]*n
        a=[False]*n
        stk=[(0,False)]
        while stk:
            x,v=stk.pop()
            if not v:
                stk.append((x,True))
                for y in sorted(c[x]):
                    stk.append((y,False))
            else:
                f=0;r=0;ln=0
                for y in sorted(c[x]):
                    f=(f*p[l[y]]+fh[y])%M
                    r=(rh[y]*p[ln]+r)%M
                    ln+=l[y]
                f=(f*B+ord(s[x]))%M
                r=(ord(s[x])*p[ln]+r)%M
                ln+=1
                fh[x]=f
                rh[x]=r
                l[x]=ln
                a[x]=(f==r)
        return a
",1427827728
Claude_Ballad,Claude_Ballad,111,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums){
        if(nums.empty()) return 0;
        int m = *max_element(nums.begin(), nums.end());
        vector<int>spf(m +1,0);
        for(int i=2;i<=m;i++) if(spf[i]==0){
            spf[i]=i;
            for(int j=i*2;j<=m;j+=i) if(spf[j]==0) spf[j]=i;
        }
        int t=0,n=nums.size();
        for(int i=n-2;i>=0;i--){
            while(nums[i]>nums[i+1]){
                if(nums[i]/spf[nums[i]]==1) return -1;
                nums[i] /= (nums[i]/spf[nums[i]]);
                t++;
            }
        }
        return t;
    }
};",1427845807
raararaara,raararaara,112,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = int(size(s));
        s = '.' + s;
        vector<vector<int>> p(26, vector<int>(n+1));
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j < 26; j++) p[j][i] = p[j][i-1];
            p[s[i]-'a'][i]++;
        }

        auto f = [](int l, int r, vector<int> &v) {
            return v[r] - v[l-1];
        };

        int ret = 0;
        for(int i = 1; i <= n; i++) {
            for(int j = i; j <= n; j++) {
                int add = 0;
                for(int c = 0; c < 26; c++) {
                    if(f(i,j,p[c])>=k) {
                        add = 1;
                        break;
                    }
                }
                ret += add;
            }
        }

        return ret;
    }
};",1427875219
raararaara,raararaara,112,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string tar) {
        vector<string> ret;
        string s;
        for(int i = 0; tar[i]; i++) {
            s += 'a';
            ret.emplace_back(s);
            while(s.back() != tar[i]) {
                s.back()++;
                ret.emplace_back(s);
            }
        }
        return ret;
    }
};",1427878587
raararaara,raararaara,112,3603,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
//#include <atcoder/all>
//using mint = atcoder::modint998244353;
using namespace std;
using namespace __gnu_pbds;
template<class key, class cmp = std::less<key>>
using ordered_set = tree<key, null_type, cmp, rb_tree_tag, tree_order_statistics_node_update>;
template<class key, class value, class cmp = std::less<key>>
using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;

using lint = long long;
using ii = pair<int, int>;
using il = pair<int, lint>;
using li = pair<lint, int>;
using ll = pair<lint, lint>;

const int mxn = 1000100, mxp = 1000001;
const int MOD = 1e9 + 7, inf = -1e9 - 7, INF = 1e9 + 1;
const lint lnf = -4e18, LNF = 5e18;
const double eps = 1e-10;
const int sqrtN = 200;

#define sz(x) int(size(x))
#define all(x) (x).begin(),(x).end()
#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define lb(x, v) (lower_bound(all(x), v) - (x).begin())
#define ub(x, v) (upper_bound(all(x), v) - (x).begin())
#define eb emplace_back
#define pb push_back
#define getName(var)  #var
vector<lint> xl, yl;

#define Yes ""Yes\n""
#define No ""No\n""

const int dr[] = {-1, 0, 1, 0};
const int dc[] = {0, -1, 0, 1};

inline int inRange(int r, int c, int R, int C) {
    return 0 <= r && r < R && 0 <= c && c < C;
}

lint N, M, Q, R, H, K, T;

void init() {

}
const int msz = 2, globalM = 1000001333;
array<long long, msz> mod= {1000000009, 1000000007};

template<int p>
struct Hashing {
    int n;
    string s;
    vector<vector<long long>> pw, h;
    Hashing(const string &str): n(int(size(str))), s(str) {
        h = pw = vector<vector<long long>>(n, vector<long long>(msz));

        for(int j = 0; j < msz; j++) pw[0][j] = 1LL, h[0][j] = str[0];
        for(int i = 1; i < n; i++) {
            for (int j = 0; j < msz; j++) {
                h[i][j] = (h[i-1][j] * p + str[i]) % mod[j];
                pw[i][j] = (pw[i-1][j] * p) % mod[j];
            }
        }
    }

    long long get(int l, int r) {
        long long ret = 1;
        for(int j = 0; j < msz; j++) {
            long long x = h[r][j];
            if(l) x = (x - h[l-1][j] * pw[r-l+1][j]) % mod[j];
            if(x < 0) x += mod[j];

            ret = (ret * globalM) + x;
        }
        return ret;
    }

    bool equals(Hashing<p> &other) {
        return n == other.n && (get(0, n-1) == other.get(0, n-1));
    }

    bool contains(Hashing<p> &other) {
        int m = other.n;
        if(n < m) return false;
        for(int i = 0; i + m - 1 < n; i++) {
            if(get(i, i+m-1) == other.get(0, m-1)) return true;
        }
        return false;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = sz(parent);
        vector<vector<int>> adj(n);
        vector<int> l(n), r(n);
        for(int i = 0; auto &p: parent) {
            if(!i) {
                i++;
                continue;
            }
            adj[p].eb(i++);
        }
        string pat;
        int dfn = 0;
        function<void(int)> dfs = [&](int cur) {
            l[cur] = dfn;
            for(auto &nxt: adj[cur]) {
                dfs(nxt);
            }
            pat += s[cur];
            r[cur] = dfn++;
        };
        dfs(0);

        Hashing<27> h(pat);
        reverse(all(pat));
        Hashing<27> rh(pat);

        vector<bool> ret(n);
        for(int i = 0; i < n; i++) {
            ret[i] = (h.get(l[i], r[i]) == rh.get(n-1-r[i], n-1-l[i]));
        }

        return ret;
    }
};
",1427848372
raararaara,raararaara,112,3607,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
//#include <atcoder/all>
//using mint = atcoder::modint998244353;
using namespace std;
using namespace __gnu_pbds;

using lint = long long;
using ii = pair<int, int>;
using il = pair<int, lint>;
using li = pair<lint, int>;
using ll = pair<lint, lint>;

const int mxn = 1000100, mxp = 1000001;
const int MOD = 998244353, inf = -1e9 - 7, INF = 1e9 + 1;
const lint lnf = -4e18, LNF = 5e18;
const double eps = 1e-10;
const int sqrtN = 200;

#define sz(x) int(size(x))
#define all(x) (x).begin(),(x).end()
#define compress(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define lb(x, v) (lower_bound(all(x), v) - (x).begin())
#define ub(x, v) (upper_bound(all(x), v) - (x).begin())
#define getName(var)  #var
vector<lint> xl, yl;

#define Yes ""Yes\n""
#define No ""No\n""

const int dr[] = {-1, 0, 1, 0};
const int dc[] = {0, -1, 0, 1};

inline int inRange(int r, int c, int R, int C) {
    return 0 <= r && r < R && 0 <= c && c < C;
}

lint N, M, Q, R, C, H, K, T;

template<typename K, typename V, int SZ>
struct PrimeUtils {
    const lint LNF = 1e16;
    vector<int> spf, pList;
    PrimeUtils() {
        spf = vector<int>(SZ);
        sieve();
    }

    void sieve() {
        for (int i = 2; i < SZ; i++) {
            if(!spf[i]) {
                pList.emplace_back(i);
                spf[i] = i;
            }
            for (int j = 0; i * pList[j] < SZ; j++) {
                spf[i * pList[j]] = pList[j];
                if (i % pList[j] == 0) break;
            }
        }
    }
    
    bool IsPrime(K n) {
        if(n < SZ) return spf[n] == n;
        else if(n < LNF) isPrimeSqrtN(n);
    }
    bool isPrimeSqrtN(K n) {
        if (n == 2 || n == 3) return true;
        if (n <= 1 || n % 2 == 0 || n % 3 == 0) return false;

        for (K i = 5; i * i <= n; i += 6) {
            if (n % i == 0 || n % (i + 2) == 0) return false;
        }
        return true;
    }
    
    vector<pair<K,V>> Factorize(K x) {
        if(x < SZ) return factorizeSmall(x);
        else if(x < LNF) factorizeSqrtN(x);
    }
    vector<pair<K,V>> factorizeSmall(K n) {
        vector<pair<K,V>> ret;
        while(n != 1) {
            if(ret.empty() || ret.back().first != spf[n]) ret.push_back({spf[n], 0});
            ret.back().second++;
            n /= spf[n];
        }
        return ret;
    }
    vector<pair<K,V>> factorizeSqrtN(K n) {
        vector<pair<K,V>> ret;

        V cnt2 = 0;
        while(n % 2 == 0) {
            cnt2++;
            n >>= 1;
        }
        if(cnt2) ret.push_back({2, cnt2});
        for(K i = 3; i * i <= n; i += 2) {
            V cnt = 0;
            while(n % i == 0) {
                cnt++;
                n /= i;
            }
            if(cnt) ret.push_back({i, cnt});
        }
        if(n > 1) ret.push_back({n, 1});
        return ret;
    }
};


class Solution {
public:
    int minOperations(vector<int>& a) {
        auto f = [](int x) {
            for(int i = 2; i*i <= x; i++) {
                if(x%i==0) return i;
            }
            return x;
        };

        N = sz(a);

        int ret = 0;
        for(int i = N-2; i >= 0; i--) {
            while(a[i] > a[i+1]) {
                int spf = f(a[i]);
                if(a[i] == spf) return -1;

                a[i] = spf;
                ret++;
                
                // if(a[i] == a[i+1] && i > 0 && a[i-1] > a[i]) return -1;
            }
        }
        return ret;
    }
};",1427869280
Ritik110,Ritik110,113,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int totalSubstrings = 0;
        
        // Iterate over every possible starting index
        for (int start = 0; start < n; ++start) {
            vector<int> freq(26, 0);  // Frequency array to track character counts
            // Expand the window with the end index
            for (int end = start; end < n; ++end) {
                freq[s[end] - 'a']++;  // Increase frequency of the current character
                
                // Check if any character appears at least k times
                bool isValid = false;
                for (int i = 0; i < 26; ++i) {
                    if (freq[i] >= k) {
                        isValid = true;
                        break;
                    }
                }
                
                // If the substring is valid, count it
                if (isValid) {
                    totalSubstrings++;
                }
            }
        }
        
        return totalSubstrings;
    }
};
",1427826949
Ritik110,Ritik110,113,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;  // To store the sequence of strings
        string current = """";    // Represents the current string on the screen
        
        // Loop through each character of the target string
        for (char ch : target) {
            // Step 1: Append 'a' using Key 1
            current += 'a';
            result.push_back(current);
            
            // Step 2: Use Key 2 to increment the last character until it matches target character
            while (current.back() != ch) {
                current.back() = current.back() + 1;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427825873
Ritik110,Ritik110,113,3603,php,"class Solution {

    /**
     * @param Integer[] $parent
     * @param String $s
     * @return Boolean[]
     */
    function findAnswer($parent, $s) {
        $n = count($parent);
        $c = array_fill(0, $n, []);
        for ($i = 1; $i < $n; $i++) {
            $c[$parent[$i]][] = $i;
        }
        $f = """";
        $start = array_fill(0, $n, 0);
        $end_pos = array_fill(0, $n, 0);
        $time = 0;

        $postOrder = function($x) use (&$postOrder, &$f, &$start, &$end_pos, &$time, $c, $s) {
            $start[$x] = $time;
            foreach ($c[$x] as $y) {
                $postOrder($y);
            }
            $f .= $s[$x];
            $end_pos[$x] = $time;
            $time++;
        };


        //     foreach ($c[$x] as $y) {
        //         $postOrder($y);
        //     }
        //     $f .= $s[$x];
        //     $end_pos[$x] = $time;
        //     $time++;
        // };



        $postOrder(0);
        $mod1 = 1000000007;
        $mod2 = 1000000009;
        $base1 = 911;
        $base2 = 3571;

        $power1 = array_fill(0, $n + 1, 1);
        $power2 = array_fill(0, $n + 1, 1);
        for ($i = 1; $i <= $n; $i++) {
            $power1[$i] = ($power1[$i - 1] * $base1) % $mod1;
            $power2[$i] = ($power2[$i - 1] * $base2) % $mod2;
        }

        // $prefixHash1 = array_fill(0, $n + 1, 0);
        // $prefixHash2 = array_fill(0, $n + 1, 0);
        // for ($i = 0; $i < $n; $i++) {


        $prefixHash1 = array_fill(0, $n + 1, 0);
        $prefixHash2 = array_fill(0, $n + 1, 0);
        for ($i = 0; $i < $n; $i++) {
            $char_val = ord($f[$i]) - ord('a') + 1;
            $prefixHash1[$i + 1] = ($prefixHash1[$i] * $base1 + $char_val) % $mod1;
            $prefixHash2[$i + 1] = ($prefixHash2[$i] * $base2 + $char_val) % $mod2;
        }


        // $reverseF = strrev($f);
        // $reversePrefixHash1 = array_fill(0, $n + 1, 0);
        // $reversePrefixHash2 = array_fill(0, $n + 1, 0);
        // for ($i = 0; $i < $n; $i++) {


        $reverseF = strrev($f);
        $reversePrefixHash1 = array_fill(0, $n + 1, 0);
        $reversePrefixHash2 = array_fill(0, $n + 1, 0);
        for ($i = 0; $i < $n; $i++) {
            $char_val = ord($reverseF[$i]) - ord('a') + 1;
            $reversePrefixHash1[$i + 1] = ($reversePrefixHash1[$i] * $base1 + $char_val) % $mod1;
            $reversePrefixHash2[$i + 1] = ($reversePrefixHash2[$i] * $base2 + $char_val) % $mod2;
        }

        $answer = array_fill(0, $n, false);
        for ($x = 0; $x < $n; $x++) {
            $l = $start[$x];
            $r = $end_pos[$x];
            $hash1 = ($prefixHash1[$r + 1] - ($prefixHash1[$l] * $power1[$r - $l + 1]) % $mod1 + $mod1) % $mod1;
            $hash2 = ($prefixHash2[$r + 1] - ($prefixHash2[$l] * $power2[$r - $l + 1]) % $mod2 + $mod2) % $mod2;
            $rev_l = $n - $r - 1;
            $rev_r = $n - $l - 1;
            $rev_hash1 = ($reversePrefixHash1[$rev_r + 1] - ($reversePrefixHash1[$rev_l] * $power1[$rev_r - $rev_l + 1]) % $mod1 + $mod1) % $mod1;
            $rev_hash2 = ($reversePrefixHash2[$rev_r + 1] - ($reversePrefixHash2[$rev_l] * $power2[$rev_r - $rev_l + 1]) % $mod2 + $mod2) % $mod2;

            // $rev_hash2 = ($reversePrefixHash2[$rev_r + 1] - ($reversePrefixHash2[$rev_l] * $power2[$rev_r - $rev_l + 1]) % $mod2 + $mod2) % $mod2;

            $answer[$x] = ($hash1 == $rev_hash1 && $hash2 == $rev_hash2);
        }

        return $answer;
    }
}
",1427878790
Ritik110,Ritik110,113,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> v = nums;
        int n = nums.size(), ops = 0;
        auto gpd = [](int x) -> int {
            if (x == 1) return 1;
            for (int i = 2; i <= sqrt(x); ++i) {
                if (x % i == 0) return x / i;
            }
            return 1;
        };
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int d = gpd(nums[i]);
                if (d == 1) return -1;
                nums[i] /= d;
                ops++;
            }
        }
        return ops;
    }
};
",1427830205
Akash,Akash_0P,114,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), total = 0;

        for(int i = 0; i < n; i++) {
            vector<int> freq(26);
            for(int j = i; j < n; j++) {
                freq[s[j] - 'a']++;
                for(auto &it: freq) if(it >= k) {
                    total++;
                    break;
                }
            }
        }

        return total;
    }
};",1427834020
Akash,Akash_0P,114,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();

        vector<string> ans;
        string str;

        for(auto &i: target) {
            string s = str;
            char c = 'a';
            s += c;

            ans.push_back(s);

            while(i > c) {
                c++;
                s[s.size() - 1] = c;
                ans.push_back(s);
            }

            str += i;
        }

        return ans;
    }
};",1427829399
Akash,Akash_0P,114,3603,cpp,"using ll = long long;

class hasher {
  ll n, prime, M = 998244353;
  string s;
 
  vector<ll> dp, base;
 
public:
  hasher(string s, int prime) {
    this->s = s, this->prime = prime, n = s.size();
    dp.resize(n + 1), base.resize(n + 1);
    init();
  }
 
  void init() {
 
    base[0] = 1;
 
    for(int i = 1; i <= n; i++) {
      dp[i] = (dp[i - 1] * prime % M + s[i - 1]) % M;
      base[i] = (base[i - 1] * prime) % M;
    }
 
  }
 
  ll query(int l, int r) {
    return (dp[r + 1] - (dp[l] * base[r - l + 1]) % M + M) % M;
  }
 
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string str) {
        int n = parent.size();
        vector<set<int>> adj(n);

        for(int i = 1; i < n; i++) {
            int p = parent[i];
            adj[p].insert(i);
        }

        string s;
        vector<pair<int,int>> pos(n); 

        auto dfs = [&](int u, auto && dfs) -> void {

            pos[u].first = (int)s.size();
            for(auto v: adj[u]) dfs(v, dfs);
            pos[u].second = (int)s.size();

            s += str[u];

        }; dfs(0, dfs);

        hasher h1(s, 1e9 + 7), t1(s, 1e9 + 9);
        reverse(s.begin(), s.end());
        hasher h2(s, 1e9 + 7), t2(s, 1e9 + 9);

        auto get1 = [&](int l, int r) {
            pair<ll,ll> ans = {h1.query(l, r), t1.query(l, r)};
            return ans;
        };

        auto get2 = [&](int l, int r) {
            pair<ll,ll> ans = {h2.query(l, r), t2.query(l, r)};
            return ans;
        };

        vector<bool> ans(n);

        for(int i = 0; i < n; i++) {
            int a = pos[i].first, b = pos[i].second;
            int c = n - b - 1, d = n - a -1 ;
            ans[i] = get1(a, b) == get2(c, d);
        }

        return ans;
    }
};",1427879104
Akash,Akash_0P,114,3607,cpp,"int flag = 0;
const int N = 1e6 + 10;

int sieve[N];

void pre() {
    for(int i = 0; i < N; i++) sieve[i] = i;

    for(long long i = 2; i < N; i++) {
        for(long long j = i + i; j < N; j += i) sieve[j] = i;
    }
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(!flag) pre(), flag = 1;

        int n = nums.size(), nxt = nums.back(), ans = 0;

        for(int i = n - 1; i >= 0; i--) {
            while(nums[i] > nxt) {
                int d = sieve[nums[i]];
                if(d == nums[i]) break;
                nums[i] /= d, ans++;
            }
            if(nums[i] > nxt) {
                ans = -1;
                break;
            }
            nxt = nums[i];
        }
        return ans;
    }
};",1427852760
Zejun Wu,watashi,115,3502,cpp,"class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    static constexpr int CHARSET = 26;
    vector<vector<int>> idx(CHARSET);
    vector<int> kth(CHARSET, -1);
    int ret = 0;
    for (int i = 0; i < (int)s.size(); ++i) {
      int ii = s[i] - 'a';
      idx[ii].push_back(i);
      kth[ii] = idx[ii].size();
      int first = -1;
      for (int j = 0; j < CHARSET; ++j) {
        if (kth[j] >= k) {
          first = max(first, idx[j][kth[j] - k]);
        }
      }
      ret += first + 1;
    }
    return ret;
  }
};",1427830384
Zejun Wu,watashi,115,3566,cpp,"class Solution {
public:
  vector<string> stringSequence(string target) {
    vector<string> ret;
    string s = """";
    for (char c : target) {
      s.push_back('a');
      for (char i = 'a'; i <= c; ++i) {
        s.back() = i;
        ret.push_back(s);
      }
    }
    return ret;
  }
};",1427824312
Zejun Wu,watashi,115,3603,cpp,"class Solution {
  struct Manacher {
    vector<int> p;

    template<typename T>
    void init(int n, const T s[]) {
      p.resize(max(0, 2 * n - 1));
      for (int i = 0, j = 0, k = 0; i <= 2 * (n - 1); ++i) {
        int d = i < k ? min(p[j + j - i], (k - i) / 2) : 0;
        int a = i / 2 - d, b = (i + 1) / 2 + d;
        while (0 <= a && b < n && s[a] == s[b]) {
          --a;
          ++b;
          ++d;
        }
        p[i] = d;
        if (k < 2 * b - 1) {
          j = i;
          k = 2 * b - 1;
        }
      }
    }

    // [l, r)
    bool isPalindrome(int l, int r) {
      int m = l + r - 1;
      return m / 2 - p[m] < l;
    }
  };

  vector<vector<int>> e;
  vector<pair<int, int>> ranges;
  string orig, str;

  void dfs(int v) {
    ranges[v].first = str.length();
    for (int w : e[v]) {
      dfs(w);
    }
    str += orig[v];
    ranges[v].second = str.length();
  }

public:
  vector<bool> findAnswer(vector<int>& parent, string s) {
    const int n = parent.size();
    e = vector<vector<int>>(n);
    for (int i = 1; i < n; ++i) {
      e[parent[i]].push_back(i);
    }
    ranges = vector<pair<int, int>>(n);
    orig = s;
    str = """";
    dfs(0);
    
    Manacher m;
    m.init(n, str.data());
    vector<bool> ret;
    ret.reserve(n);
    for (const auto& i : ranges) {
      ret.push_back(m.isPalindrome(i.first, i.second));
    }
    return ret;
  }
};",1427862642
Zejun Wu,watashi,115,3607,cpp,"class Solution {
  struct PrimeTable {
    vector<int> p;

    PrimeTable(int n) {
      init(n);
    }

    void init(int n) {
      p = vector<int>(n, 0);
      iota(p.begin(), p.end(), 0);
      for (int i = 2; i * i < n; ++i) {
        if (p[i] == i) {
          for (int j = i * i; j < n; j += i) {
            if (p[j] == j) {
              p[j] = i;
            }
          }
        }
      }
    }
  };

public:
  int minOperations(vector<int>& nums) {
    static const PrimeTable pt(1 << 20);
    vector<int> v = nums;
    int ret = 0;
    while (v.size() >= 2) {
      auto& lhs = v[v.size() - 2];
      auto rhs = v.back();
      if (lhs <= rhs) {
        v.pop_back();
      }
      else if (pt.p[lhs] <= rhs) {
        lhs = pt.p[lhs];
        ++ret;
      }
      else {
        return -1;
      }
    }
    return ret;
  }
};",1427849276
junbinliang,junbinliang,117,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for(int i = 0; i < s.size(); i++) {
            vector<int> t(26);
            bool ok = false;
            for(int j = i; j < s.size(); j++) {
                int d = s[j] - 'a';
                t[d]++;
                if(t[d] >= k) ok = true;
                if(ok) ans++;
            }
        }
        return ans;
    }
};",1427824491
junbinliang,junbinliang,117,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string> ans;
        int n = s.size();
        string cur = """";
        for(int i = 0; i < s.size(); i++) {
            for(char c = 'a'; c <= s[i]; c++) {
                ans.push_back(cur + c);
            }
            cur += s[i];
        }
        
        return ans;
    }
};",1427826190
junbinliang,junbinliang,117,3603,cpp,"template <typename T>
ostream& operator <<(ostream& out, const vector<T>& a) {
  out << ""[""; bool first = true;
  for (auto v : a) { out << (first ? """" : "", ""); out << v; first = 0;} 
  out << ""]"";
  return out;
}


const int N = 1e5 + 10;
vector<int> g[N];
bool isp[N];

const int MOD = 1e9 + 7;
long long p[N];
int sz[N];
pair<long long, long long> dp[N];
int base = 101;

/*long long get(int l, int r) {
    if(l == 0) return h[r];
    long long ans = ((h[r] - (h[l - 1] * p[r - l + 1]) % MOD) + MOD) % MOD;
    if(ans < 0) ans += MOD;
    return ans;
}*/

void dfs(string& s, int u) {
    sz[u] = 1;
    sort(g[u].begin(), g[u].end());
    reverse(g[u].begin(), g[u].end());
    //if(u == 1) cout << g[u] << endl;
    
    long long h1 = s[u] - 'a' + 1;
    long long h2 = 0;
    //if(u == 1) cout << ""gg1 "" << h1 << endl;
    for(int v : g[u]) {
        dfs(s, v);
        sz[u] += sz[v];
        h1 = h1 * p[sz[v]] + dp[v].first;
        h1 %= MOD;
        //if(u == 1) cout << ""gg1 "" << h1 << endl;
    }
    
    for(int i = g[u].size() - 1; i >= 0; i--) {
        int v = g[u][i];
        h2 = h2 * p[sz[v]] + dp[v].second;
        h2 %= MOD;
        
       // if(u == 1) cout << ""gg2 "" << h2 << endl;
    }
   // if(u == 1) cout << ""gg2 "" << h2 << endl;
    h2 = h2 * base + (s[u] - 'a' + 1);
    h2 %= MOD;
    
    //cout << u << ""  "" << h1 << "" "" << h2 << endl;
    
    if(h1 == h2) {
        isp[u] = true;
    }
    dp[u] = {h1, h2};
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        for(int i = 0; i <= n; i++) {
            g[i].clear();
            isp[i] = false;
        }
        for(int i = 1; i < parent.size(); i++) {
            g[parent[i]].push_back(i);
        }
        
        p[0] = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = p[i - 1] * base;
            p[i] %= MOD;
        }
        
        dfs(s, 0);
        
        
        vector<bool> ans(n);
        for(int i = 0; i < n; i++) {
            ans[i] = isp[i];
        }
        return ans;
    }
};",1427887995
junbinliang,junbinliang,117,3607,cpp,"const int N = 1e6 + 10;
int d[N];
bool yes = false;
void init() {
    if(yes) return;
    yes = true;
    memset(d, -1, sizeof d);
    for(int i = 2; i < N; i++) {
        for(int j = i + i; j < N; j += i) {
            if(d[j] == -1) d[j] = i;
            else d[j] = max(d[j], i);
        }
    }
}

const int INF = 1e8;
int dp[100000 + 10][2];
class Solution {
public:
    int minOperations(vector<int>& a) {
        init();
        int n = a.size();
        for(int i = 0; i <= n; i++) {
            dp[i][0] = dp[i][1] = -1;
        }
        
        dp[0][0] = 0; //not change
        if(d[a[0]] != -1) {
            dp[0][1] = 1;
        }
        
        for(int i = 1; i < n; i++) {
            if(dp[i - 1][0] != -1) { //previous not change
                if(a[i] >= a[i - 1]) {
                    dp[i][0] = dp[i - 1][0];
                }
                if(d[a[i]] != -1 && (a[i] / d[a[i]]) >= a[i - 1]) {
                    dp[i][1] = 1 + dp[i - 1][0];
                }
            }
            
            if(dp[i - 1][1] != -1) {
                int pval = a[i - 1] / d[a[i - 1]];
                if(a[i] >= pval) {
                    if(dp[i][0] == -1) dp[i][0] = dp[i - 1][1];
                    else dp[i][0] = min(dp[i][0], dp[i - 1][1]);
                }
                
                if(d[a[i]] != -1 && (a[i] / d[a[i]]) >= pval) {
                    if(dp[i][1] == -1) dp[i][1] = 1 + dp[i - 1][1];
                    else dp[i][1] = min(dp[i][1], 1 + dp[i - 1][1]);
                }
            }
        }
        /*cout << d[9] << "" "" << d[27] << "" "" << d[81] << "" "" << d[3] << endl;
        for(int i = 0; i < n; i++) {
            cout << dp[i][0] << "" "" << dp[i][1] << endl;
        }*/
        
        
        int ans = INF;
        if(dp[n - 1][0] != -1) {
            ans = min(ans, dp[n - 1][0]);
        }
        if(dp[n - 1][1] != -1) {
            ans = min(ans, dp[n - 1][1]);
        }
        return ans <= n ? ans : -1;
    }
};

/*
[9,27,81,27,3]
*/",1427853141
Ian Wong,ianwong1999,118,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        
        int res = 0;
        
        for (int i = 0; i < n; i++) {
            vector<int> cnt(26);
            int high = 0;
            
            for (int j = i; j < n; j++) {
                high = max(high, ++cnt[s[j] - 'a']);
                
                if (high >= k) res++;
            }
        }
        
        return res;
    }
};",1427825270
Ian Wong,ianwong1999,118,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s;
        
        while (s != target) {
            if (s.empty() || s[s.size() - 1] == target[s.size() - 1]) {
                s += ""a"";
            } else {
                s.back()++;
            }
            
            res.push_back(s);
        }
        
        return res;
    }
};",1427824015
Ian Wong,ianwong1999,118,3603,cpp,"#include <ranges>

class Solution {
public:
    using ULL = unsigned long long;
    inline static ULL p1[100055];
    inline static ULL p2[100055];
    static constexpr ULL B1 = 1e9 + 7;
    static constexpr ULL B2 = 1e9 + 9;
    
    struct HN {   
        ULL h1, h2;
        int len;
        
        HN() : h1(0), h2(0), len(0) {}
        HN(char ch) : h1(ch - 'a'), h2(ch - 'a'), len(1) {}
        friend HN operator+(const HN& lhs, const HN& rhs) {
            HN res;
            res.len = lhs.len + rhs.len;
            
            res.h1 = lhs.h1 * p1[rhs.len] + rhs.h1;
            res.h2 = lhs.h2 * p2[rhs.len] + rhs.h2;
            
            return res;
        }
        
        friend bool operator==(const HN& lhs, const HN& rhs) {
            return lhs.h1 == rhs.h1 && lhs.h2 == rhs.h2;
        }
    };
    
    string t;
    vector<bool> res;
    HN pre[100055], post[100055];
    vector<int> g[100055];
    
    void dfs(int v, int par = -1) {
        pre[v] = HN();
        post[v] = HN();
        post[v] = post[v] + HN(t[v]);
        
        for (auto u : g[v]) {
            dfs(u, v);
            pre[v] = pre[v] + pre[u];
        }
        
        pre[v] = pre[v] + HN(t[v]);
        
        for (auto u : g[v] | std::views::reverse) {
            post[v] = post[v] + post[u];
        }
        
        res[v] = pre[v] == post[v];
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        t = s;
        
        for (int i = 0; i < n; i++) {
            g[i].clear();
        }
        
        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }
        
        p1[0] = 1;
        p2[0] = 1;
        
        for (int i = 1; i <= n; i++) {
            p1[i] = p1[i - 1] * B1;
            p2[i] = p2[i - 1] * B2;
        }
        
        res.clear();
        for (int i = 0; i < n; i++) res.push_back(false);
        
        dfs(0);
        
        return res;
    }
};",1427863099
Ian Wong,ianwong1999,118,3607,cpp,"class Solution {
public:
    int d[1000055];
    Solution() {
        memset(d, -1, sizeof(d));
        
        for (int i = 2; i * i <= (int)1e6; i++) {
            if (d[i] != -1) continue;
            
            for (int j = i * i; j <= (int)1e6; j += i) {
                if (d[j] != -1) continue;
                d[j] = i;
            }
        }
    }
    int minOperations(vector<int>& nums) {
        
        
        int res = 0;
        int n = nums.size();
        vector<int> r(n);
        
        for (int i = n - 1; i >= 0; i--) {
            r[i] = nums[i];
            
            if (i + 1 < n) r[i] = min(r[i + 1], r[i]);
            if (r[i] < nums[i]) {
                if (d[nums[i]] == -1) return -1;
                
                res++;
                
                nums[i] = d[nums[i]];
                
                if (r[i] < nums[i]) return -1;
            }
            r[i] = min(r[i], nums[i]);
        }
        
        return res;
    }
};",1427841032
AADITYA BHARGAV,beunique_18,119,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        total = 0
        for i in range(n):
            freq = [0] * 26
            for j in range(i, n):
                c = ord(s[j]) - ord('a')
                freq[c] += 1
                if freq[c] == k:
                    total += n - j
                    break
        return total
",1427834307
AADITYA BHARGAV,beunique_18,119,3566,python3,"from typing import List

class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = []
        screen = """" 
        for i in range(len(target)):
            screen = self.expand_screen(screen, i + 1, result)
            screen = self.modify_characters(screen, target[i], result)
        return result
    def expand_screen(self, screen: str, required_length: int, result: List[str]) -> str:
        while len(screen) < required_length:
            screen += 'a'
            result.append(screen)
        return screen
    def modify_characters(self, screen: str, target_char: str, result: List[str]) -> str:
        current_char = screen[-1]
        diff = (ord(target_char) - ord(current_char)) % 26
        for _ in range(diff):
            current_char = 'a' if current_char == 'z' else chr(ord(current_char) + 1)
            screen = screen[:-1] + current_char
            result.append(screen)
        return screen
",1427826681
AADITYA BHARGAV,beunique_18,119,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)

        MOD1 = 10 ** 9 + 7
        MOD2 = 10 ** 9 + 9
        p = 911
        max_len = n

        pow_p_mod1 = [1] * (max_len + 2)
        pow_p_mod2 = [1] * (max_len + 2)
        for i in range(1, max_len + 2):
            pow_p_mod1[i] = (pow_p_mod1[i - 1] * p) % MOD1
            pow_p_mod2[i] = (pow_p_mod2[i - 1] * p) % MOD2

        answer = [False] * n
        dfs_info = [None] * n

        def dfs(x):
            len_subtree = 1  
            h1 = 0  
            h2 = 0 
            child_info = []
            for y in tree[x]:
                dfs(y)
                child_info.append(dfs_info[y])
            for child_len, child_h1, child_h2, child_rev_h1, child_rev_h2 in child_info:
                h1 = (h1 * pow_p_mod1[child_len] + child_h1) % MOD1
                h2 = (h2 * pow_p_mod2[child_len] + child_h2) % MOD2
                len_subtree += child_len
            h1 = (h1 * p + ord(s[x])) % MOD1
            h2 = (h2 * p + ord(s[x])) % MOD2
            rev_h1 = ord(s[x]) % MOD1
            rev_h2 = ord(s[x]) % MOD2
            for child_len, child_h1, child_h2, child_rev_h1, child_rev_h2 in reversed(child_info):
                rev_h1 = (rev_h1 * pow_p_mod1[child_len] + child_rev_h1) % MOD1
                rev_h2 = (rev_h2 * pow_p_mod2[child_len] + child_rev_h2) % MOD2
            dfs_info[x] = (len_subtree, h1, h2, rev_h1, rev_h2)
            if h1 == rev_h1 and h2 == rev_h2:
                answer[x] = True
            else:
                answer[x] = False

        dfs(0)
        return answer
",1427844250
AADITYA BHARGAV,beunique_18,119,3607,python3,"class Solution:
    def minOperations(self, nums):
        import math
        max_num = max(nums)
        max_sqrt = int(math.isqrt(max_num)) + 1
        is_prime = [True] * max_sqrt
        is_prime[0] = is_prime[1] = False
        primes = []
        for i in range(2, max_sqrt):
            if is_prime[i]:
                primes.append(i)
                for j in range(i * i, max_sqrt, i):
                    is_prime[j] = False

        total_operations = 0
        n = len(nums)
        for i in range(n - 2, -1, -1):
            if nums[i] <= nums[i + 1]:
                continue

            x = nums[i]
            spf = None
            for p in primes:
                if p * p > x:
                    break
                if x % p == 0:
                    spf = p
                    break
            if spf is None:
                spf = x  

            if spf == x:
                return -1
            nums[i] = spf
            total_operations += 1

            if nums[i] > nums[i + 1]:
                return -1

        return total_operations
",1427855393
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,120,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        s = [ord(c)-97 for c in s]
        j = 0
        f = [0] * 26
        ret = 0
        for i in range(len(s)):
            while j < len(s) and f[s[j]] < k - 1:
                f[s[j]] += 1
                j += 1
            if max(f) < k:
                ret += len(s) - j
            f[s[i]] -= 1
        return ret
                ",1427835023
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,120,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ret = []
        cur = ''
        for i in range(len(target)):
            cur += 'a'
            ret.append(cur)
            while cur[-1] != target[i]:
                cur = cur[:-1] + chr(ord(cur[-1]) + 1)
                ret.append(cur)
        return ret",1427824673
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,120,3603,python3,"import random

HMOD = 2147483647
HBASE1 = random.randrange(HMOD)
HBASE2 = random.randrange(HMOD)


class Hashing:
    def __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):
        self.mod, self.base1, self.base2 = mod, base1, base2
        self._len = _len = len(s)
        f_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)
        s_hash, s_pow = f_hash[:], f_pow[:]
        for i in range(_len):
            f_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod
            s_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod
            f_pow[i + 1] = base1 * f_pow[i] % mod
            s_pow[i + 1] = base2 * s_pow[i] % mod
        self.f_hash, self.f_pow = f_hash, f_pow
        self.s_hash, self.s_pow = s_hash, s_pow

    def hashed(self, start, stop):
        return (
            (self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,
            (self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,
        )

    def get_hashes(self, length):
        return (
            [(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in range(self._len - length + 1)],
            [(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in range(self._len - length + 1)],
        )

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for _ in range(n)]
        inout = [[None, None] for _ in range(n)]
        for i, x in enumerate(parent):
            if x != -1:
                g[x].append(i)
        
        ss = ''
        def dfs(idx, t):
            nonlocal ss
            inout[idx][0] = t
            for ch in g[idx]:
                t = dfs(ch, t)
            t += 1
            inout[idx][1] = t
            ss += s[idx]
            return t

        dfs(0, 0)

        q = [ord(x) for x in (ss + ss[::-1])]
        h = Hashing(q)
        ret = []
        for i in range(n):
            a, b = inout[i]
            ret.append(h.hashed(a, b) == h.hashed(2*len(ss)-b, 2*len(ss)-a))
        return ret",1427888258
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,120,3607,python3,"def get_primes(n):
    p = 3
    sieve = [1 for _ in range(n+1)]
    while p*p <= n:
        if sieve[p]:
            for x in range(p*p, n+1, 2*p):
                sieve[x] = 0
        p += 2
    ret = [2]
    for i in range(3, n+1, 2):
        if sieve[i]:
            ret.append(i)
    return ret

PRIMES = get_primes(1000)

class Solution:
    def minOperations(self, nums: List[int]) -> int:

        fnums = []
        for x in nums:
            t = 0
            for p in PRIMES:
                if p >= x:
                    break
                if x % p == 0:
                    t = 1
                    fnums.append(p)
                    break
            if not t:
                fnums.append(x)



        @cache
        def dp(idx, last):
            if idx == len(nums):
                return 0
            ret = inf
            if nums[idx] >= last:
                ret = min(ret, dp(idx+1, nums[idx]))
            if fnums[idx] >= last:
                ret = min(ret, 1 + dp(idx+1, fnums[idx]))
            return ret

        r = dp(0, -inf)
        dp.cache_clear()
        return r if r != inf else -1
            
            ",1427850062
HFDnpkp1cs,HFDnpkp1cs,121,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<int> cnt(26, 0);

        int hi = 0, ret = 0;
        for(int i = 0; i < n; i++) {
            while(hi < n && !check(cnt, k)) {
                cnt[s[hi] - 'a']++;
                hi++;
            }
            if(check(cnt, k))
                ret += n - hi + 1;
            
            cnt[s[i] - 'a']--;
        }
        return ret;
    }

    bool check(vector<int>& cnt, int k) {
        for(int i = 0; i < 26; i++) {
            if(cnt[i] >= k)
                return true;
        }
        return false;
    }
};",1427829693
HFDnpkp1cs,HFDnpkp1cs,121,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ret;
        int n = target.size();
        string s;
        for(int i = 0; i < n; i++) {
            s.push_back('a');
            ret.push_back(s);
            int sz = s.size();
            for(char c = 'b'; c <= target[i]; c++) {
                s[sz - 1] = c;
                ret.push_back(s);
            }
        }
        return ret;
    }
};",1427824563
HFDnpkp1cs,HFDnpkp1cs,121,3603,cpp,"using ull = unsigned long long;

class StringHash
{
public:
    ull p;
    ull n;
    vector<ull> hashv;
    vector<ull> pwr;
    StringHash(ull pp, string& str)
    {
        p = pp;
        n = str.size();
        hashv = vector<ull>(n, 0);
        pwr = vector<ull>(n + 10, 0);
        build(str);
    }

    void build(string& str)
    {
        hashv[0] = str[0];
        for(ull i = 1; i < n; i++)
        {
            hashv[i] = hashv[i - 1] * p + str[i];
        }

        pwr[0] = 1;
        for(ull i = 1; i < pwr.size(); i++)
        {
            pwr[i] = p * pwr[i - 1];
        }
    }

    ull getHash(ull lo, ull hi)
    {
        if(lo == 0)
            return hashv[hi];
        ull ret = hashv[hi] - hashv[lo - 1] * pwr[1 + hi - lo];
        return ret;
    }
};

class Solution {
public:
    int n;
    vector<vector<int>> adj;
    vector<int> in;
    vector<int> out;
    string str;
    string s;
    vector<bool> findAnswer(vector<int>& parent, string ss) {
        n = ss.size();
        adj = vector<vector<int>>(n);
        in = vector<int>(n);
        out = vector<int>(n);
        s = ss;
        for(int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }

        dfs(0);
        // cout << str << endl;

        auto rstr = str;
        reverse(rstr.begin(), rstr.end());
        StringHash sh(131, str);
        StringHash rsh(131, rstr);
        vector<bool> ret(n, false);
        for(int i = 0; i < n; i++) {
            int lo = in[i], hi = out[i];
            int rlo = n - hi - 1, rhi = n - lo - 1;
            // cerr << lo << "" "" << hi << "" "" << rlo << "" "" << rhi << endl;
            if(sh.getHash(lo, hi) == rsh.getHash(rlo, rhi))
                ret[i] = true;
        }
        return ret;

    }


    void dfs(int idx) {
        int sz = str.size();
        in[idx] = sz;
        for(auto nidx : adj[idx]) {
            dfs(nidx);
        }
        str.push_back(s[idx]);
        int nsz = str.size();
        out[idx] = nsz - 1;
    }
};",1427880245
HFDnpkp1cs,HFDnpkp1cs,121,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n, vector<int>(2, 1e9));

        vector<int> alt = nums;
        for(int i = 0; i < n; i++) {
            for(int j = 2; j * j <= nums[i]; j++) {
                if(nums[i] % j == 0) {
                    alt[i] = j;
                    break;
                }
            }
        }

        // for(int i : alt)
        //     cout << i << endl;

        dp[n - 1][0] = dp[n - 1][1] = 0;

        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] <= nums[i + 1]) {
                dp[i][0] = min(dp[i][0], dp[i + 1][0]);
            }
            if(nums[i] <= alt[i + 1]) {
                dp[i][0] = min(dp[i][0], dp[i + 1][1]);
            }

            if(alt[i] <= nums[i + 1]) {
                dp[i][1] = min(dp[i][0], dp[i + 1][0] + 1);
            }
            if(alt[i] <= alt[i + 1]) {
                dp[i][1] = min(dp[i][0], dp[i + 1][1] + 1);
            }
        }

        int ret = min(dp[0][0], dp[0][1]);
        if(ret == 1e9)
            return -1;
        return ret;
    }
};",1427852146
trchen,trchen,122,3502,cpp,"class Solution {
 public:
  int numberOfSubstrings(string s, int k) {
    int n = s.size();
    int ret = 0;
    for (int i = 0; i < n; ++i) {
      vector<int> cnt(26, 0);
      for (int j = i; j < n; ++j) {
        cnt[s[j] - 'a']++;
        if (cnt[s[j] - 'a'] >= k) {
          ret += n - j;
          break;
        }
      }
    }
    return ret;
  }
};",1427828314
trchen,trchen,122,3566,cpp,"class Solution {
 public:
  vector<string> stringSequence(string target) {
    vector<string> ret;
    int n = target.size();
    string curr = """";
    for (int i = 0; i < n; ++i) {
      char c = target[i];
      curr += 'a';
      ret.push_back(curr);
      while (curr.back() < c) {
        curr.back()++;
        ret.push_back(curr);
      }
    }
    return ret;
  }
};",1427824640
trchen,trchen,122,3603,cpp,"
namespace impl {

template <bool>
struct DynamicModulusComponent {};

template <>
struct DynamicModulusComponent<true> {
  inline DynamicModulusComponent() noexcept
      : modulus(dynamic_modulus) {
  }

  int64_t modulus;
  static inline int64_t dynamic_modulus = -1;
};

}  // namespace impl

template <int64_t Modulus>
struct ModularNumber : public impl::DynamicModulusComponent<Modulus == -1> {
 private:
  static inline constexpr int64_t Dynamic = -1;

 public:
  int64_t value{};

  inline constexpr ModularNumber() noexcept = default;
  inline constexpr ModularNumber(const ModularNumber& other) noexcept = default;
  inline constexpr ModularNumber(ModularNumber&& other) noexcept = default;

  template <typename IntType>
  inline explicit constexpr ModularNumber(IntType integer) noexcept
      : value(static_cast<int64_t>(integer) % GetModulus()) {
    if (this->value < 0) {
      this->value += this->GetModulus();
    }
  }

  inline constexpr ~ModularNumber() noexcept = default;

  inline constexpr ModularNumber& operator=(const ModularNumber& other) noexcept = default;
  inline constexpr ModularNumber& operator=(ModularNumber&& other) noexcept = default;

  [[nodiscard]] inline constexpr int64_t GetModulus() const noexcept {
    if constexpr (Modulus == Dynamic) {
      return this->modulus;
    } else {
      return Modulus;
    }
  }

  static inline void SetModulus(int64_t modulus) noexcept
    requires (Modulus == Dynamic) {
    impl::DynamicModulusComponent<true>::dynamic_modulus = modulus;
  }

  static inline constexpr bool HaveSameModulus(const ModularNumber& lhs,
                                               const ModularNumber& rhs) noexcept {
    if constexpr (Modulus == Dynamic) {
      return lhs.modulus == rhs.modulus;
    } else {
      return true;
    }
  }

  template <typename IntType>
  inline constexpr ModularNumber& operator=(IntType integer) noexcept {
    this->value = static_cast<int64_t>(integer) % this->GetModulus();
    if (this->value < 0) {
      this->value += this->GetModulus();
    }
    return *this;
  }

  [[nodiscard]] inline constexpr ModularNumber operator+() const noexcept {
    return *this;
  }

  [[nodiscard]] inline constexpr ModularNumber operator-() const noexcept {
    ModularNumber ret = *this;
    if (ret.value > 0) {
      ret.value = this->GetModulus() - ret.value;
    }
    return ret;
  }

  inline constexpr ModularNumber& operator+=(const ModularNumber& other) noexcept {
    assert(HaveSameModulus(*this, other));
    this->value += other.value;
    if (this->value >= this->GetModulus()) {
      this->value -= this->GetModulus();
    }
    return *this;
  }

  inline constexpr ModularNumber& operator-=(const ModularNumber& other) noexcept {
    assert(HaveSameModulus(*this, other));
    this->value -= other.value;
    if (this->value < 0) {
      this->value += this->GetModulus();
    }
    return *this;
  }

  inline constexpr ModularNumber& operator*=(const ModularNumber& other) noexcept {
    assert(HaveSameModulus(*this, other));
    this->value = (this->value * other.value) % this->GetModulus();
    return *this;
  }

  inline constexpr ModularNumber& operator/=(const ModularNumber& other) noexcept {
    assert(HaveSameModulus(*this, other));
    return *this *= Inverse(other);
  }

  inline constexpr ModularNumber& operator++() noexcept {
    this->value++;
    if (this->value == this->GetModulus()) {
      this->value = 0;
    }
    return *this;
  }

  inline constexpr ModularNumber& operator--() noexcept {
    if (this->value == 0) {
      this->value = this->GetModulus() - 1;
    } else {
      this->value--;
    }
    return *this;
  }

  template <typename IntType>
  inline explicit constexpr operator IntType() const noexcept {
    return static_cast<IntType>(this->value);
  }
};

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> operator+(const ModularNumber<Modulus>& lhs,
                                                  const ModularNumber<Modulus>& rhs) noexcept {
  ModularNumber<Modulus> ret = lhs;
  ret += rhs;
  return ret;
}

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> operator-(const ModularNumber<Modulus>& lhs,
                                                  const ModularNumber<Modulus>& rhs) noexcept {
  ModularNumber<Modulus> ret = lhs;
  ret -= rhs;
  return ret;
}

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> operator*(const ModularNumber<Modulus>& lhs,
                                                  const ModularNumber<Modulus>& rhs) noexcept {
  ModularNumber<Modulus> ret = lhs;
  ret *= rhs;
  return ret;
}

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> operator/(const ModularNumber<Modulus>& lhs,
                                                  const ModularNumber<Modulus>& rhs) noexcept {
  ModularNumber<Modulus> ret = lhs;
  ret /= rhs;
  return ret;
}

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> operator++(ModularNumber<Modulus>& modular_number,
                                                   int) noexcept {
  ModularNumber<Modulus> ret = modular_number;
  ++modular_number;
  return ret;
}

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> operator--(ModularNumber<Modulus>& modular_number,
                                                   int) noexcept {
  ModularNumber<Modulus> ret = modular_number;
  --modular_number;
  return ret;
}

template <int64_t Modulus, typename IntType>
inline constexpr ModularNumber<Modulus> Power(ModularNumber<Modulus> modular_number,
                                              IntType power) noexcept {
  ModularNumber<Modulus> ret;
  ret.value = 1;
  if constexpr (Modulus == -1) {
    ret.modulus = modular_number.modulus;
  }
  while (power > 0) {
    if (power % 2 == 1) {
      ret *= modular_number;
    }
    modular_number *= modular_number;
    power /= 2;
  }
  return ret;
}

template <int64_t Modulus>
inline constexpr ModularNumber<Modulus> Inverse(
    const ModularNumber<Modulus>& modular_number) noexcept {
  assert(modular_number.value != 0);
  return Power(modular_number, modular_number.GetModulus() - 2);
}

template <int64_t Modulus>
inline std::istream& operator>>(std::istream& stream,
                                ModularNumber<Modulus>& modular_number) noexcept {
  stream >> modular_number.value;
  modular_number.value %= modular_number.GetModulus();
  if (modular_number < 0) {
    modular_number += modular_number.GetModulus();
  }
  return stream;
}

template <int64_t Modulus>
inline std::ostream& operator<<(std::ostream& stream,
                                const ModularNumber<Modulus>& modular_number) noexcept {
  return stream << modular_number.value;
}

template <int64_t Modulus, int64_t Power, int MaxSize, char BaseCharacter>
class StringHash {
 public:
  inline explicit StringHash(const std::string& s) noexcept {
    const auto n = static_cast<int>(s.size());
    prefix_hash_.resize(n + 1);
    prefix_hash_[0] = 0;
    for (int i = 0; i < n; ++i) {
      prefix_hash_[i + 1] =
          prefix_hash_[i] + powers[i] * ModularNumber<Modulus>(s[i] - BaseCharacter + 1);
    }
  }

  inline ModularNumber<Modulus> GetHash() const noexcept {
    return prefix_hash_.back();
  }

  // Get hash of s[left : right]
  inline ModularNumber<Modulus> GetSubstringHash(int left, int right) const noexcept {
    return (prefix_hash_[right + 1] - prefix_hash_[left]) * inverse_powers[left];
  }

 private:
  static inline constexpr std::array<ModularNumber<Modulus>, MaxSize> ComputePowers() noexcept {
    std::array<ModularNumber<Modulus>, MaxSize> ret;
    ret[0] = 1;
    ret[1] = Power;
    for (int i = 2; i < MaxSize; ++i) {
      ret[i] = ret[i - 1] * ret[1];
    }
    return ret;
  }

  static inline constexpr std::array<ModularNumber<Modulus>, MaxSize>
      ComputeInversePowers() noexcept {
    std::array<ModularNumber<Modulus>, MaxSize> ret;
    ret[0] = 1;
    ret[1] = Inverse(ModularNumber<Modulus>(Power));
    for (int i = 2; i < MaxSize; ++i) {
      ret[i] = ret[i - 1] * ret[1];
    }
    return ret;
  }

  static inline const std::array<ModularNumber<Modulus>, MaxSize> powers = ComputePowers();
  static inline const std::array<ModularNumber<Modulus>, MaxSize> inverse_powers =
      ComputeInversePowers();

  std::vector<ModularNumber<Modulus>> prefix_hash_;
};

class Solution {
 public:
  using Hash = StringHash<1000000007, 31, 100005, 'a'>;

  vector<bool> findAnswer(vector<int>& parent, string st) {
    n = parent.size();
    str = st;
    childs.resize(n);
    for (int i = 0; i < n; ++i) {
      if (parent[i] != -1) {
        childs[parent[i]].push_back(i);
      }
    }
    // cout << n << endl;
    // for (int i = 0; i < n; ++i) {
    //   cout << i << "": "";
    //   for (auto c : childs[i]) {
    //     cout << c << ' ';
    //   }
    //   cout << endl;
    // }
    intervals.resize(n);
    int time = 0;
    DFSFindInterval(0, time);
    Hash hash1(s);
    reverse(s.begin(), s.end());
    Hash hash2(s);
    vector<bool> ret(n);
    for (int i = 0; i < n; ++i) {
      int l1 = intervals[i].first;
      int r1 = intervals[i].second;
      auto h1 = hash1.GetSubstringHash(l1, r1);
      int l2 = n - 1 - r1;
      int r2 = n - 1 - l1;
      auto h2 = hash2.GetSubstringHash(l2, r2);
      if ((int)h1 == (int)h2) {
        ret[i] = true;
      } else {
        ret[i] = false;
      }
    }
    return ret;
  }

  void DFSFindInterval(int v, int& time) {
    intervals[v].first = time;
    for (auto u : childs[v]) {
      DFSFindInterval(u, time);
    }
    s.push_back(str[v]);
    intervals[v].second = s.size() - 1;
    time++;
  }

  int n;
  string s;
  string str;
  vector<vector<int>> childs;
  vector<pair<int, int>> intervals;
};
",1427897282
trchen,trchen,122,3607,cpp,"class Solution {
 public:
  int Become(int a) {
    if (a == 1) {
      return 1;
    }
    for (auto c : primes) {
      if ((c * c) > a) {
        return a;
      }
      if (a % c == 0) {
        return c;
      }
    }
    return 1;
  }

  int minOperations(vector<int>& nums) {
    int n = nums.size();
    vector<int> target(n);
    for (int i = 0; i < n; ++i) {
      target[i] = Become(nums[i]);
    }
    int ret = 0;
    for (int i = n - 2; i >= 0; --i) {
      if (nums[i] > nums[i + 1]) {
        if (target[i] > nums[i + 1]) {
          return -1;
        }
        ++ret;
        nums[i] = target[i];
      }
    }
    return ret;
  }

  vector<int> primes{
    2,   3,   5,   7,   11,  13,  17,  19,  23,  29,  31,  37,  41,  43,  47,  53,  59,  61,  67,
    71,  73,  79,  83,  89,  97,  101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,
    167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269,
    271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383,
    389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
    503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619,
    631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,
    757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881,
    883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
  };
};",1427840473
HungYu,henry870603,123,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int result = 0;
        int n = s.length();

        for (int start = 0; start < n; ++start) {
            unordered_map<char, int> counts;
            for (int end = start; end < n; ++end) {
                counts[s[end]]++;
                for (const auto& entry : counts) {
                    if (entry.second >= k) {
                        result++;
                        break; 
                    }
                }
            }
        }

        return result;
    }
};",1427855604
HungYu,henry870603,123,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> sequence;
        string current = """";

        for (size_t i = 0; i < target.size(); ++i) {
            char target_char = target[i];

            // If the current string is shorter than needed, append 'a'
            if (current.size() < i + 1) {
                current += 'a';
                sequence.push_back(current);
            }

            // Increment the last character until it matches the target character
            while (current[i] != target_char) {
                if (current[i] == 'z') {
                    current[i] = 'a';  // Wrap around to 'a' if 'z' is reached
                } else {
                    current[i] = current[i] + 1;
                }
                sequence.push_back(current);
            }
        }

        return sequence;
    }
};
",1427839666
HungYu,henry870603,123,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        // Sort the children of each node in increasing order
        for (int i = 0; i < n; ++i) {
            sort(tree[i].begin(), tree[i].end());
        }

        vector<int> tinSubtree(n);
        vector<int> toutSubtree(n);
        string dfsStr;

        // The DFS function
        function<void(int)> dfs = [&](int x) {
            tinSubtree[x] = dfsStr.size();
            for (int y : tree[x]) {
                dfs(y);
            }
            dfsStr.push_back(s[x]);
            toutSubtree[x] = dfsStr.size() - 1;
        };

        // Start DFS from the root node
        dfs(0);

        int N = dfsStr.size();
        vector<long long> Hf(N + 1, 0), Hr(N + 1, 0), powBase(N + 1, 1);
        vector<long long> Hf2(N + 1, 0), Hr2(N + 1, 0), powBase2(N + 1, 1);
        long long mod1 = 1000000007, mod2 = 1000000009;
        long long base1 = 911, base2 = 1597;

        // Build reverse of dfsStr
        string reverse_dfsStr = dfsStr;
        reverse(reverse_dfsStr.begin(), reverse_dfsStr.end());

        // Precompute hashes and powers for both forward and reverse strings
        for (int i = 0; i < N; ++i) {
            Hf[i + 1] = (Hf[i] * base1 + dfsStr[i]) % mod1;
            Hf2[i + 1] = (Hf2[i] * base2 + dfsStr[i]) % mod2;
            powBase[i + 1] = (powBase[i] * base1) % mod1;
            powBase2[i + 1] = (powBase2[i] * base2) % mod2;

            Hr[i + 1] = (Hr[i] * base1 + reverse_dfsStr[i]) % mod1;
            Hr2[i + 1] = (Hr2[i] * base2 + reverse_dfsStr[i]) % mod2;
        }

        vector<bool> answer(n, false);
        for (int i = 0; i < n; ++i) {
            int l = tinSubtree[i];
            int r = toutSubtree[i];
            int len = r - l + 1;

            // Forward hash for dfsStr[l..r]
            long long hashF1 = (Hf[r + 1] - Hf[l] * powBase[len] % mod1 + mod1) % mod1;
            long long hashF2 = (Hf2[r + 1] - Hf2[l] * powBase2[len] % mod2 + mod2) % mod2;

            // Reverse hash for the substring
            int L = N - 1 - r;
            int R = N - 1 - l;
            long long hashR1 = (Hr[R + 1] - Hr[L] * powBase[len] % mod1 + mod1) % mod1;
            long long hashR2 = (Hr2[R + 1] - Hr2[L] * powBase2[len] % mod2 + mod2) % mod2;

            // Compare the hashes to check for palindrome
            if (hashF1 == hashR1 && hashF2 == hashR2) {
                answer[i] = true;
            } else {
                answer[i] = false;
            }
        }

        return answer;
    }
};
",1427889235
HungYu,henry870603,123,3607,cpp,"class Solution {
public:
    int minOperations(std::vector<int>& nums) {
        int n = nums.size();
        int total_operations = 0;
        nums.push_back(std::numeric_limits<int>::max());

        for (int i = n - 1; i >= 0; --i) {
            int min_ops = INT_MAX;
            int selected_value = nums[i];
            int operations = 0;

            std::vector<std::pair<int, int>> possible_values;
            possible_values.push_back({nums[i], 0});

            if (!isPrime(nums[i])) {
                int spf = smallestPrimeFactor(nums[i]);
                possible_values.push_back({spf, 1});
            }

            bool found = false;
            for (auto& p : possible_values) {
                int value = p.first;
                int ops = p.second;
                if (value <= nums[i + 1]) {
                    if (ops < min_ops) {
                        min_ops = ops;
                        selected_value = value;
                        found = true;
                    }
                }
            }

            if (!found) {
                return -1; // Impossible to make the array non-decreasing
            }

            nums[i] = selected_value;
            total_operations += min_ops;
        }

        return total_operations;
    }

private:
    bool isPrime(int x) {
        if (x <= 1) return false;
        if (x <= 3) return true;
        if (x % 2 == 0 || x % 3 == 0) return false;
        for (int i = 5; (long long)i * i <= x; i += 6) {
            if (x % i == 0 || x % (i + 2) == 0)
                return false;
        }
        return true;
    }

    int smallestPrimeFactor(int x) {
        if (x % 2 == 0) return 2;
        for (int i = 3; (long long)i * i <= x; i += 2) {
            if (x % i == 0) return i;
        }
        return x; 
    }
};",1427864119
Yuanrui Zhao,GoldenShadow5,125,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] arr = s.toCharArray();
        int ans = 0;
        for(int i = 0; i < arr.length; i++) {
            int[] occ = new int[26];
            int j;
            for(j = i; j >= 0; j--) {
                occ[arr[j]-'a']++;
                if(occ[arr[j]-'a'] >= k) {
                    break;
                }
            }
            ans += j+1;
        }
        return ans;
    }
}",1427829350
Yuanrui Zhao,GoldenShadow5,125,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> arr = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(char i: target.toCharArray()) {
            sb.append('a');
            arr.add(sb.toString());
            for(int j = 1; j <= i-'a'; j++) {
                sb.deleteCharAt(sb.length()-1);
                sb.append((char) ('a'+j));
                arr.add(sb.toString());
            }
        }
        return arr;
    }
}",1427825778
Yuanrui Zhao,GoldenShadow5,125,3603,java,"class Solution {
    private static final int MOD = 1000000007;
    //private static final int MOD = 998244353;
    private static int add(long a, long b) { return (int) (((a+MOD)%MOD+(b+MOD)%MOD)%MOD); }
    private static int subtract(long a, long b) { return add(a, -b); }
    private static int multiply(long a, long b) { return (int) (((a%MOD)*(b%MOD))%MOD); }
    private static int divide(long a, long b) { return multiply(a, modularInverse(b)); }
    private static int modularInverse(long a) { return power(a, MOD-2); }
    private static int power(long a, long b) {
        long c = 1;
        while(b > 0) {
            if((b&1) > 0) {
                c = multiply(c, a);
            }
            a = multiply(a, a);

            b >>= 1;
        }
        return (int) c;
    }

    private static final int p = 31;
    private static ArrayList<ArrayList<Integer>> adjacencyList;
    private static char[] arr;
    private static int[] pow;
    private static int[] size;
    private static int[] forward;
    private static int[] backward;
    private static void dfs1(int u, int x) {
        size[u] = 1;
        for(int v: adjacencyList.get(u)) {
            if(v != x) {
                dfs1(v, u);
                size[u] += size[v];
                forward[u] = add(multiply(forward[u], pow[size[v]]), forward[v]);
            }
        }
        forward[u] = add(multiply(forward[u], p), arr[u]-'a'+1);
    }
    private static void dfs2(int u, int x) {
        backward[u] = arr[u]-'a'+1;
        for(int v: adjacencyList.get(u)) {
            if(v != x) {
                dfs2(v, u);
                backward[u] = add(multiply(backward[u], pow[size[v]]), backward[v]);
            }
        }
    }
    public static boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        adjacencyList = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            adjacencyList.add(new ArrayList<>());
        }
        for(int i = 1; i < n; i++) {
            adjacencyList.get(parent[i]).add(i);
        }
        arr = s.toCharArray();
        pow = new int[n+1];
        pow[0] = 1;
        for(int i = 1; i <= n; i++) {
            pow[i] = multiply(pow[i-1], p);
        }
        size = new int[n];
        forward = new int[n];
        backward = new int[n];
        dfs1(0, -1);
        for(ArrayList<Integer> i: adjacencyList) {
            Collections.reverse(i);
        }
        dfs2(0, -1);
        boolean[] res = new boolean[n];
        for(int i = 0; i < n; i++) {
            res[i] = forward[i] == backward[i];
        }
        return res;
    }
}",1427889502
Yuanrui Zhao,GoldenShadow5,125,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int ans = 0;
        for(int i = nums.length-2; i >= 0; i--) {
            if(nums[i] > nums[i+1]) {
                for(int p = 2; p*p <= nums[i] && p <= nums[i+1]; p++) {
                    if(nums[i]%p == 0) {
                        nums[i] = p;
                        break;
                    }
                }
                ans++;
                if(nums[i] > nums[i+1]) {
                    return -1;
                }
            }
        }
        return ans;
    }
}",1427844003
xymabinogi,xymabinogi,127,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        vector<vector<int>> pos(26);
        for (int i = 0; i < n; i++){
            pos[s[i] - 'a'].push_back(i);
        }
        vector<int> left(n, -1);
        for (auto &vec : pos){
            int sz = vec.size();
            if (sz < k) continue;
            for (int i = k - 1; i < sz; i++){
                left[vec[i]] = vec[i - k + 1];
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++){
            if (i) left[i] = max(left[i - 1], left[i]);
            if (left[i] != -1){
                res += (left[i] + 1);
            }
        }
        return res;
        
    }
};",1427837127
xymabinogi,xymabinogi,127,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        int idx = 0;
        string cur;
        while(cur != target){
            if (cur.empty()){
                cur.push_back('a');
            }
            else {
                int len = cur.length();
                if (cur[len - 1] != target[len - 1]){
                    cur.back() = char(cur.back() + 1);
                }
                else {
                    cur.push_back('a');
                }
            }
            res.push_back(cur);
        }
        return res;
    }
};",1427824907
xymabinogi,xymabinogi,127,3603,cpp,"using i64 = long long;
using u64 = unsigned long long;

constexpr int M = 1E5 + 5;

u64 base = 131LL;
u64 multi[M];
void init() {
    multi[0] = 1;
    for (int i = 0; i < M - 1; i++){
        multi[i + 1] = multi[i] * base;
    }
}




class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        if (multi[0] == 0) init();
        int n = parent.size();
        vector<vector<int>> child(n);
        for (int i = 1; i < n; i++){
            child[parent[i]].push_back(i);
        }
        vector<int> siz(n, 0);
        vector<bool> res(n, 0);
        
        auto dfs = [&](auto self, int u) -> pair<u64,u64>{
            
            pair<u64,u64> val{0, 0};
            siz[u] = 0;
            for (auto &v : child[u]){
                auto son = self(self, v);
                
                val.first = combineLeft(val.first, siz[u], son.first, siz[v]);
                val.second = combineRight(val.second, siz[u], son.second, siz[v]);      
                siz[u] += siz[v];
            }
            //if (u == 1){
                
            //}
            val.first = val.first * base + (s[u] - 'a' + 1);
            val.second += (s[u] - 'a' + 1) * multi[siz[u]];
            //cout << u <<"" ""<< val.first <<"" ""<< val.second << ""\n"";
            if (val.first == val.second) res[u] = 1;
            siz[u]++;
            return val;
        };
        dfs(dfs, 0);
        return res;
        
        
    }
    
    u64 combineLeft(u64 l, int len_l, u64 r, int len_r){
        u64 a =  l * multi[len_r] + r;
        return a;
    }
    u64 combineRight(u64 l, int len_l, u64 r, int len_r){
        u64 a =  r * multi[len_l] + l;
        return a;
    }
};",1427898177
xymabinogi,xymabinogi,127,3607,cpp,"std::vector<int> minp, primes;

void sieve(int n) {
    minp.assign(n + 1, 0);
    primes.clear();
    
    for (int i = 2; i <= n; i++) {
        if (minp[i] == 0) {
            minp[i] = i;
            primes.push_back(i);
        }
        
        for (auto p : primes) {
            if (i * p > n) {
                break;
            }
            minp[i * p] = p;
            if (p == minp[i]) {
                break;
            }
        }
    }
    minp[1] = 1;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (primes.empty()) sieve(1E6 + 5);
        int n = nums.size();
        int mx = nums[n - 1];
        int res = 0;
        for (int i = n - 2; i >= 0; i--){
            while(nums[i] > mx){
                if (minp[nums[i]] == nums[i]) return -1;
                res++;
                nums[i] = minp[nums[i]];
            }
            mx = min(mx, nums[i]);
        }
        return res;
    }
};",1427845107
Wanjun Li,wjli,133,3502,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int numberOfSubstrings(string s, int k) {
		int n = s.length(), i, j, ans = 0, curr, maxx;
		VI ct(26, 0);
		curr = 0;
		FOR(i, n) {
			while ((curr < n) && (MAX(ct) < k)) {
				ct[s[curr] - 'a']++;
				curr++;
			}
			if (MAX(ct) >= k) ans += n - curr + 1;
			ct[s[i] - 'a']--;
		}
		return ans;
	}
};
",1427826341
Wanjun Li,wjli,133,3566,cpp,"
// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	vector<string> stringSequence(string target) {
		VS s;
		string ss = """";

		LL n = target.length(), i, j, k;
		FOR(i, n) {
			ss = ss + ""a"";
			s.PB(ss);
			FOR(j, target[i] - 'a') {
				ss[ss.length() - 1]++;
				s.PB(ss);
			}
		}

		return s;
	}
};

",1427823979
Wanjun Li,wjli,133,3603,cpp,"


// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)

#define MAXXX 100100
#define MODDD 1000000009 
#define OFFSET 12377

VL v(MAXXX);
bool used = false;

class tree {		// implementation of recurvie programming
    int ct;
public:
    int nn, root;				// # of nodes, id of root
    vector<int> parent;			// parent of each node; -1 if unassigned
    vector<int> depth;			// depth of each node
    vector<int> sz;				// subtree size of each node 
    vector<vector<int>> adj;	// adjacency list from each node
    vector<vector<int>> sons;	// sons list from each node

    // for cartesian_decomposition
    vector<int> in, out;		// starting and ending position of a subtree
    vector<int> pos;			// inorder of DFS

    // for LCA sparse table
    vector<vector<int>> pred;
    int MAXLEVEL;

    bool called_LCA = false;

    tree(int n) {
        nn = n;
        adj.clear();
        adj.resize(n);
    }

    void add_path(int a, int b) {
        adj[a].push_back(b);
        adj[b].push_back(a);
    }

    void add_directed_path(int a, int b) {
        adj[a].push_back(b);
    }

    void dfs_set_root(int id, bool cartesian_decomposition = false) {	// internal
        if (cartesian_decomposition) {
            in[id] = ct;
            pos[ct] = id;
            ct++;
        }

        sz[id]++;

        for (auto p : adj[id]) {
            if (parent[p] == -1) {
                parent[p] = id;
                depth[p] = depth[id] + 1;
                dfs_set_root(p, cartesian_decomposition);
                sz[id] += sz[p];

                sons[id].push_back(p);
            }
        }

        if (cartesian_decomposition) out[id] = ct - 1;
    }

    void set_root(int id, bool cartesian_decomposition = true) {		// set root of the tree and calculate necessary info
        if (cartesian_decomposition) {
            in.resize(nn);
            out.resize(nn);
            pos.resize(nn);
            ct = 0;
        }

        parent.assign(nn, -1);
        depth.assign(nn, -1);
        sz.assign(nn, 0);
        sons.clear();
        sons.resize(nn);

        // dfs_set_root(id, cartesian_decomposition);


        // set root using stack
        stack<pair<int, int>> st;		// id, # of sons processes
        st.push({ id, 0 });
        parent[id] = 0;
        depth[id] = 0;

        int ct = 0;

        while (!st.empty()) {
            int id = st.top().first, x = st.top().second;

            if (x == 0) {
                in[id] = ct;
                pos[ct] = id;
                sz[id] = 1;
                ct++;
            }

            if (x >= adj[id].size()) {
                out[id] = ct - 1;
                if (parent[id] != -1) {
                    sz[parent[id]] += sz[id];
                }
                st.pop();
            }
            else {

                st.top().second++;

                int p = adj[id][x];
                if (parent[p] == -1) {
                    parent[p] = id;
                    depth[p] = depth[id] + 1;
                    sons[id].push_back(p);
                    st.push({ p, 0 });
                }
            }
        }

        int i = 0;
    }

    void eulerian_tour_dfs(int root, vector<int>& ans) {
        ans.push_back(root);
        for (auto p : sons[root]) {
            eulerian_tour_dfs(p, ans);
            ans.push_back(root);
        }
    }

    vector<int> eulerian_tour(int root) {
        vector<int> ans;

        eulerian_tour_dfs(root, ans);

        return ans;
    }


    void prep_LCA() {		// prepare the sparse table for LCA calculation
        MAXLEVEL = 1;
        while ((1 << MAXLEVEL) < nn) MAXLEVEL++;
        MAXLEVEL++;

        pred.assign(MAXLEVEL, vector<int>(nn, 0));
        pred[0] = parent;

        int i, j, k;
        for (i = 1; i < MAXLEVEL; i++) {
            for (j = 0; j < nn; j++) {
                if (pred[i - 1][j] != -1) pred[i][j] = pred[i - 1][pred[i - 1][j]];
            }
        }

        called_LCA = true;
    }

    int get_p_ancestor(int a, int p) {		// get p-ancestor of node a;  need to call set_root() and prep_LCA() first
        if (!called_LCA) prep_LCA();

        int i;
        for (i = MAXLEVEL - 1; (i >= 0) && (p > 0) && (a != -1); i--) {
            if ((1 << i) & p) {
                p -= (1 << i);
                a = pred[i][a];
            }
        }
        return a;
    }

    int LCA(int a, int b) {		// get the LCA of a and b, need to call set_root() and prep_LCA() first
        if (!called_LCA) prep_LCA();
        int da = depth[a], db = depth[b];

        if (da > db) {
            swap(da, db);
            swap(a, b);
        }

        int i, j, k;
        for (i = MAXLEVEL - 1; i >= 0; i--) {
            if (db - (1 << i) >= da) {
                db -= (1 << i);
                b = pred[i][b];
            }
        }

        if (a == b) return a;

        for (i = MAXLEVEL - 1; i >= 0; i--) {
            if (pred[i][a] != pred[i][b]) {
                a = pred[i][a];
                b = pred[i][b];
            }
        }

        return parent[a];
    }

    int get_distance(int a, int b) {	// get distance between a and b, need to call set_root() and prep_LCA() first
        if (!called_LCA) prep_LCA();

        int c = LCA(a, b);
        int ans = depth[a] + depth[b] - 2 * depth[c];
        return ans;
    }

    int get_diameter(VI& path) {
        int a, b, c, i, j, k, id, INF = nn + 100, ans;
        vector<int> dist(nn), last(nn);
        queue<int> q;

        if (nn == 1) return 0;

        // first pass, start with 1 -- any node
        a = 1;
        dist.assign(nn, INF);
        dist[a] = 0;
        q.push(a);

        while (!q.empty()) {
            id = q.front();
            q.pop();

            for (auto p : adj[id]) {
                if (dist[p] == INF) {
                    dist[p] = dist[id] + 1;
                    q.push(p);
                }
            }
        }

        // second pass, start from the most remote node id, collect last to get ID
        a = id;
        dist.assign(nn, INF);
        last.assign(nn, -1);
        dist[a] = 0;
        q.push(a);

        while (!q.empty()) {
            id = q.front();
            q.pop();

            for (auto p : adj[id]) {
                if (dist[p] == INF) {
                    dist[p] = dist[id] + 1;
                    last[p] = id;
                    q.push(p);
                }
            }
        }

        // a and id forms the diameter
        ans = dist[id];

        //return ans;

        // construct the path of diamter in path
        path.clear();
        b = id;
        c = id;
        do {
            path.push_back(b);
            b = last[b];
        } while (b != -1);

        return ans;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        if (!used) {
            used = true;
            v[0] = 1;
            FOR1(i, MAXXX - 1) v[i] = (v[i - 1] * OFFSET) % MODDD;
        }

        int n = parent.size(), i, j;
        vector<bool> ans(n, false);
        tree tr(n);
        FOR1(i, n - 1) tr.add_path(parent[i], i);
        tr.set_root(0);

        tr.sz[0] = n;

        vector<LL> sl(n, 0), sr(n, 0);
        for (i = n - 1; i >= 0; i--) {
            int id = tr.pos[i];

            if (tr.sons[id].empty()) {
                sl[id] = s[id] - 'a';
                sr[id] = s[id] - 'a';
            }
            else {
                int m = tr.sons[id].size();
                FOR(j, m) {
                    int idd = tr.sons[id][j];
                    sl[id] = (sl[id] * v[tr.sz[idd]] + sl[idd]) % MODDD;
                }
                sl[id] = (sl[id] * OFFSET + s[id] - 'a') % MODDD;

                sr[id] = s[id] - 'a';
                for (j = m - 1; j >= 0; j--) {
                    int idd = tr.sons[id][j];
                    sr[id] = (sr[id] * v[tr.sz[idd]] + sr[idd]) % MODDD;
                }
            }

            if (sl[id] == sr[id]) ans[id] = true;
        }
        return ans;
    }
};
",1427867633
Wanjun Li,wjli,133,3607,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)



#define MAXN 225000			// total # of prime numbers
#define MAXP 1100000		// highest number to test prime

int prime[MAXN];		// prime numbers: 2, 3, 5 ...
int lp[MAXP];		// lp[n] = n if n is prime; otherwise smallest prime factor of the number
int phi[MAXP];			// phii function

class prime_class {
public:
    long top;

    prime_class() {			// generate all prime under MAXP
        int i, i2, j;

        top = 0;
        lp[0] = 0;
        lp[1] = 1;
        for (i = 2; i < MAXP; i++) lp[i] = 0;

        top = 0;
        for (i = 2; i < MAXP; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                prime[top++] = i;
            }
            for (j = 0; (j < top) && (prime[j] <= lp[i]) && (i * prime[j] < MAXP); ++j)
                lp[i * prime[j]] = prime[j];
        }
    }

    bool isprime(long long key)
    {
        if (key < MAXP)	return (lp[key] == key) && (key >= 2);
        else {
            int i;
            for (i = 0; (i < top) && (prime[i] * prime[i] <= key); i++)
                if (key % prime[i] == 0) return false;
            return true;
        }
    }

    unordered_map<int, int> factorize(int key) {
        unordered_map<int, int> ans;

        while (lp[key] != key) {
            ans[lp[key]]++;
            key /= lp[key];
        }
        if (key > 1) ans[key]++;

        return ans;
    }

    vector<int> mobius(int n) {     // generate mobius function of size n
        int i, j, k, ct, curr, cct, x, last;
        vector<int> mobius(n + 1);
        for (i = 1; i <= n; i++) {
            curr = i; ct = 0; last = -1;

            while (lp[curr] != curr) {
                x = lp[curr];
                if (x != last) {
                    cct = 1;
                    last = x;
                    ct++;
                }
                else {
                    if (++cct >= 2) {
                        mobius[i] = 0;
                        goto outer;
                    }

                }
                curr /= lp[curr];
            }
            if (curr > 1) {
                x = curr;
                if (x != last) {
                    cct = 1;
                    last = x;
                    ct++;
                }
                else {
                    if (++cct >= 2) {
                        mobius[i] = 0;
                        goto outer;
                    }

                }
            }

            if (ct % 2 == 0) mobius[i] = 1;
            else mobius[i] = -1;

        outer:;
        }

        return mobius;
    }

    int get_phi(int key) {	// calculate Euler's totient function, also known as phi-function
        int ans = key, last = 0;

        while (lp[key] != key) {
            if (lp[key] != last) {
                last = lp[key];
                ans -= ans / last;
            }
            key /= lp[key];
        }
        if ((key > 1) && (key != last)) ans -= ans / key;

        return ans;
    }

    void calc_all_phi(int n) {
        int i, j, k;
        for (int i = 1; i < n; i++) phi[i] = i;
        for (int i = 2; i < n; i++) {
            if (phi[i] == i) {
                for (int j = i; j < n; j += i) {
                    phi[j] /= i;
                    phi[j] *= i - 1;
                }
            }
        }
    }

    vector<pair<long long, long long>> factorize_full(long long key) {		// can be used to factorize numbers >= MAXP
        vector<pair<long long, long long>> ans;

        long i, ct, sq = sqrt(key) + 10;

        for (i = 0; (i < top) && (prime[i] <= sq); i++)
            if (key % prime[i] == 0) {
                ct = 0;
                while (key % prime[i] == 0) {
                    ct++;
                    key /= prime[i];
                }
                ans.push_back({ prime[i], ct });
            }
        if (key > 1) {
            ans.push_back({ key, 1 });
        }
        return ans;
    }

    void generate_divisors(int step, int v, vector<pair<int, int>>& fp, vector<int>& ans) {
        if (step < fp.size()) {
            generate_divisors(step + 1, v, fp, ans);
            for (int i = 1; i <= fp[step].second; i++) {
                v *= fp[step].first;
                generate_divisors(step + 1, v, fp, ans);
            }
        }
        else ans.push_back(v);
    }

    void generate_divisors_full(long long step, long long v, vector<pair<long long, long long>>& fp, vector<long long>& ans) {
        if (step < fp.size()) {
            generate_divisors_full(step + 1, v, fp, ans);
            for (int i = 1; i <= fp[step].second; i++) {
                v *= fp[step].first;
                generate_divisors_full(step + 1, v, fp, ans);
            }
        }
        else ans.push_back(v);
    }

    vector<int> get_divisors(int key) {
        unordered_map<int, int> f = factorize(key);
        int n = f.size();
        vector<pair<int, int>> fp;
        for (auto p : f) fp.push_back(p);
        vector<int> ans;
        generate_divisors(0, 1, fp, ans);
        return ans;
    }

    vector<long long> get_divisors_full(long long key) {
        vector<pair<long long, long long>> f = factorize_full(key);
        int n = f.size();
        vector<pair<long long, long long>> fp;
        for (auto p : f) fp.push_back(p);
        vector<long long> ans;
        generate_divisors_full(0, 1, fp, ans);
        return ans;
    }


    long long get_divisors_count(long long key) {
        vector<pair<long long, long long>> f = factorize_full(key);
        long long ans = 1;
        for (auto p : f) ans *= (p.second + 1);
        return ans;
    }

};

prime_class pr;

class Solution {
public:
	int minOperations(vector<int>& nums) {
        int n = nums.size(), i, j, k, ans = 0;

        for (i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (pr.isprime(nums[i])) 
                    return -1;
				nums[i] = lp[nums[i]]; ans++;
            }
        }

        return ans;
	}
};

",1427833541
M Kawa,mkawa222,134,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n=len(s)
        cc=[ord(c)-97 for c in s]
        cnt=[0]*26
        ans=0
        r=0
        for l in range(n):
            while max(cnt)<k and r<n:
                cnt[cc[r]]+=1
                r+=1
            if max(cnt)<k:break
            ans+=n-r+1
            cnt[cc[l]]-=1
        return ans
",1427845647
M Kawa,mkawa222,134,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        cc=[ord(c) for c in target]
        ans=[]
        now=[]
        for c in cc:
            now.append(97)
            ans.append("""".join(chr(c) for c in now))
            while now[-1]!=c:
                now[-1]+=1
                ans.append("""".join(chr(c) for c in now))
        return ans
",1427830712
M Kawa,mkawa222,134,3603,python3,"# 偶数長、奇数長含めて回文「直径」（つまり全長）を返す
# s[i]の前の隙間を中心とした回文長がres[i*2]（偶数長）
# s[i]を中心とした回文長がres[i*2+1]（奇数長）
#  a b a a b a
# 0103016103010
# 0123456789012
# dummyがsに入っていないか注意
def Manacher(s):
    dummy=""@""
    s = dummy + dummy.join(s) + dummy
    i=j=0
    res=[-1]*len(s)
    while i<len(s):
        while i-j>=0 and i+j<len(s) and s[i-j]==s[i+j]:j+=1
        res[i]=j-1
        k=1
        while i-k>=0 and k+res[i-k]+1<j:
            res[i+k]=res[i-k]
            k+=1
        i+=k
        j-=k
    return res

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def dfs(u):
            nonlocal t
            ll[u]=len(t)
            for v in to[u]:dfs(v)
            t+=s[u]
            rr[u]=len(t)

        n=len(parent)
        to=[[] for _ in range(n)]
        for u,p in enumerate(parent):
            if u==0:continue
            to[p].append(u)
        t=""""
        ll=[0]*n
        rr=[0]*n
        dfs(0)
        # print(ll,rr)
        dd=Manacher(t)
        ans=[dd[l+r]>=r-l for l,r in zip(ll,rr)]
        return ans
",1427893007
M Kawa,mkawa222,134,3607,python3,"class Sieve:
    def __init__(self, n):
        self.plist = [2]
        min_prime_factor = [2, 0]*(n//2+1)
        for x in range(3, n+1, 2):
            if min_prime_factor[x] == 0:
                min_prime_factor[x] = x
                self.plist.append(x)
                if x**2 > n: continue
                for y in range(x**2, n+1, 2*x):
                    if min_prime_factor[y] == 0:
                        min_prime_factor[y] = x
        self.min_prime_factor = min_prime_factor

sv=Sieve(10**6)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n=len(nums)
        ans=0
        for i in range(n-1)[::-1]:
            if nums[i]>nums[i+1]:
                nums[i]=sv.min_prime_factor[nums[i]]
                ans+=1
            if nums[i]>nums[i+1]:return -1
        return ans
",1427853417
Piyush Kumar,kumarfeldspar,136,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res = 0, n = s.size();

        
        for(int i = 0; i < n; i++){
            int cnt[26] = {0};
            bool flag = false;
            for(int j = i; j < n; j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a'] == k){
                    flag = true;
                }
                if(flag){
                    res += (n - j);
                    break;
                }
            }
        }
        return res;
    }
};",1427829167
Piyush Kumar,kumarfeldspar,136,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> res;
        string s = """";
        for (char c : t) {
            s += 'a';
            res.push_back(s);
            while (s.back() != c) {
                if (s.back() == 'z') {
                    s.back() = 'a';
                } else {
                    s.back() += 1;
                }
                res.push_back(s);
            }
        }
        return res;
    }
};",1427825532
Piyush Kumar,kumarfeldspar,136,3603,cpp,"typedef long long ll;

class Solution
{
public:
    vector<int> temp;
    vector<bool> ans;
    const int mod = 1000000007;
    int base;
    vector<ll> pw;

    void dfs(int x, vector<vector<int>> &adj, string &s, vector<ll> &h, vector<ll> &rev, vector<int> &sz)
    {
        h[x] = 0;
        rev[x] = 0;
        sz[x] = 0;
        for (auto y : adj[x])
        {
            dfs(y, adj, s, h, rev, sz);
            h[x] = (h[x] * pw[sz[y]] + h[y]) % mod; // same order
            rev[x] = (rev[y] * pw[sz[x]] + rev[x]) % mod;
            sz[x] += sz[y];
        }
        h[x] = (h[x] * base + s[x]) % mod;
        rev[x] = (rev[x] + s[x] * pw[sz[x]]) % mod;
        sz[x] += 1;
        ans[x] = (h[x] == rev[x]);
    }

    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        vector<int>vv={101,113,157,282,53,167};
        int x=rand()%6;
        base=vv[x];
        // cout<<base<<endl;
        int n = parent.size();
        vector<vector<int>> adj(n, vector<int>());
        for (int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);
        for (int i = 0; i < n; i++)
            sort(adj[i].begin(), adj[i].end());

        temp = parent;
        pw.resize(n + 1, 1);
        for (int i = 1; i <= n; i++)
            pw[i] = (pw[i - 1] * base) % mod;

        ans.assign(n, false);
        vector<ll> h(n, 0), rev(n, 0);
        vector<int> sz(n, 0);
        dfs(0, adj, s, h, rev, sz);
        return ans;
    }
};",1427884984
Piyush Kumar,kumarfeldspar,136,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> spf(1000001, 0);
        if(is_sorted(nums.begin(),nums.end()))return 0;
        for (int i = 2; i <= 1000000; i++) {

            if (spf[i] == 0) {
                spf[i] = i;
                for (int j = 2 * i; j <= 1000000; j += i) {
                    if (spf[j] == 0) {
                        spf[j] = i;
                    }
                }
            }
        }
        int ops = 0, n = nums.size();

        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (spf[nums[i]] == nums[i]) {
                    return -1;
                }
                nums[i] = spf[nums[i]];
                ops++;
            }
        }

        return ops;
    }
};",1427852030
Jing-You,mble6125,139,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        int count[128] = {0}, cur = 0;

        for (int i = 0, j = 0; i < n; ++i) {
            
            while (j < n && cur == 0) {
                if (++count[s[j]] == k) ++cur;
                ++j;
            }
            
            if (cur) {
                res += (n - j + 1);
            }
            // cout<<i<<"" ""<<j<<"" ""<<cur<<endl;
            
            if (count[s[i]]-- == k) --cur;
        }
        
        return res;
    }
};",1427835241
Jing-You,mble6125,139,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string cur;
        
        for (char c : target) {
            cur.push_back('a');
            res.push_back(cur);
            while (cur.back() < c) {
                cur.back() += 1;
                res.push_back(cur);
            }
        }
        
        return res;
    }
};",1427825540
Jing-You,mble6125,139,3603,cpp,"class Solution {
    vector<vector<int>> next;
    vector<bool> res;
    vector<int> count;
    std::vector<int> dp;
    string temp;
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        next.resize(n);
        res.resize(n);
        count.resize(n);
        
        for (int i = 1; i < parent.size(); ++i) {
            next[parent[i]].push_back(i);
        }
        
        for (auto& nex : next) {
            sort(nex.begin(), nex.end());
        }
        traverse1(0, s);
        manacher(temp);
        traverse2(0, 0, n -1);
        
        return res;
    }
    
    int traverse1(int cur, string& s) {
        int ans = 1;
        for (int x : next[cur]) {
            ans += traverse1(x, s);
        }
        count[cur] = ans;
        temp.push_back(s[cur]);
        return ans;
    }
    
    void traverse2(int cur, int l, int r) {
        res[cur] = isP(l, r);
        for (int x : next[cur]) {
            traverse2(x, l, l + count[x] - 1);
            l += count[x];
        }
    }
    
    void manacher(std::string& s) {
        int len = s.size();
        int N = 2 * len + 1;
        int C = 1;
        int R = 1;
        int maxLen = 1;
        int maxI = 0;
        dp.resize(N);
        for(int i = 1; i < N; i++) {
          int mirrorI = C - (i-C);
          int delta = R - i;
          if(delta>0) {
            dp[i] = std::min(dp[mirrorI], delta);
          }
          while(( i + dp[i] < N - 1) &&
                ( i - dp[i] > 0) &&
                ( ((i + dp[i] + 1) % 2 == 0) ||
                (s[(i+dp[i]+1)/2] == s[(i-dp[i]-1) / 2]))) {
            dp[i]++;
          }
          if(dp[i] > maxLen) {
             maxLen = dp[i];
             maxI = i;
          }
          if(i + dp[i] > R) {
            C = i;
            R = i + dp[i];
          }
        }
    }
    
    bool isP(int l, int r) {
        l = (l * 2) + 1;
        r = (r * 2) + 1;
        int mid = ((l + r) >> 1);
        int diff = mid - l + 1;
        return dp[mid] >= diff;
    }
};",1427902816
Jing-You,mble6125,139,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int res = 0;    
        
        for (int i = nums.size() - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                ++res;
                int temp = min((int)sqrt(nums[i]), nums[i + 1]);
                
                for (int j = 2; j <= temp; ++j) {
                    if ((nums[i] % j) == 0) {
                        nums[i] = j;
                        break;
                    }
                }
            }
            
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
        }
        
        return res;
    }
};",1427857991
LiuWeibo,LiuWeibo,141,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();
        for (int i = 0; i < n; ++i) {
            int j = i;
            bool mark = false;
            map<char, int> cnt;
            while(j >= 0 && !mark) {
                int& v = cnt[s[j]];
                v++;
                if (v >= k) {
                    mark = true;
                    break;
                }                    
                j--;
            }
            if (mark)
                ans += j + 1;
        }
        return ans;
    }
};",1427837517
LiuWeibo,LiuWeibo,141,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string tg) {
        vector<string> ret;
        string v;
        while(v != tg) {
            int len = v.size();
            if (v == """" || v.back() == tg[len - 1]) {
                v += 'a';
            } else {
                v.back()++;
            }
            ret.push_back(v);
        }
        return ret;
    }
};",1427826594
LiuWeibo,LiuWeibo,141,3603,cpp,"using i64 = long long;
constexpr int primes[] = {999727999, 1070777777, 1000004249, 1000000007, 1000003889, 1000000009};
constexpr int BASE = 131;
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());
int P = primes[rng() % 6];

struct StringRollingHash {
    std::vector<i64> hash, base, mod;

    StringRollingHash(const std::string& s) {
        int n = s.size();
        hash.resize(n + 1);
        base.resize(n + 1);
        mod.resize(n + 1);
        base[0] = 1;
        mod[0] = 1;
        for (int i = 1; i <= n; i++) {
            base[i] = (base[i - 1] * BASE) % P;
            mod[i] = (mod[i - 1] * P) % P;
        }
        for (int i = 0; i < n; i++) {
            hash[i + 1] = (hash[i] * BASE + s[i]) % P;
        }
    }

    i64 get(int l, int r) {
        return (hash[r] - (hash[l] * base[r - l]) % P + P) % P;
    }

    i64 get(const std::string& s) {
        i64 h = 0;
        for (char c : s) {
            h = (h * BASE + c) % P;
        }
        return h;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& pa, string s) {
        int n = pa.size();
        vector<vector<int>> g(n);
        for (int i = 0; i < n; ++i)
            if (pa[i] != -1)
                g[pa[i]].push_back(i);
        for (auto& v: g) sort(v.begin(), v.end());
        
        string ans;
        using a2i = array<int, 2>;
        vector<a2i> ord(n);
        int dfn = 0;
        function<void(int)> dfs = [&](int u) {
            ord[u][0] = dfn;
            for (auto v: g[u]) {
                dfs(v);
            }
            ans.push_back(s[u]);
            dfn++;
            ord[u][1] = dfn;
        };
        dfs(0);
        
        StringRollingHash hs1(ans);
        reverse(ans.begin(), ans.end());
        StringRollingHash hs2(ans);
        vector<bool> ret(n);
        for (int i = 0; i < n; ++i) {
            auto [l, r] = ord[i];
            ret[i] = hs1.get(l, r) == hs2.get(n - r, n - l);
        }
        return ret;
    }
};",1427888240
LiuWeibo,LiuWeibo,141,3607,cpp,"constexpr int ub = 1e6 + 3;
vector<int> prime, sf(ub, -1);
vector<bool> not_prime(ub, false);

void init() {
    for (int i = 2; i < ub; ++i) {
        if (!not_prime[i]) {
            prime.push_back(i);
            sf[i] = -1;
        }
        for (int j = 0; j < prime.size() && prime[j] * i < ub; ++j) {
            not_prime[prime[j] * i] = true;
            sf[prime[j] * i] = prime[j];
            if (i % prime[j] == 0) break;
        }
    }
}

class Solution {
public:
    int minOperations(vector<int>& ns) {
        if (prime.size() == 0) init();
        
        using a2i = array<int, 2>; // idx, val;
        map<a2i, int> cache;
        function<int(int, int)> search = [&](int idx, int prev_val) {
            if (idx == -1) return 0;
            if (cache.count({idx, prev_val})) return cache[{idx, prev_val}];
            int v = ns[idx], op = 1;
            int ans = v <= prev_val ? search(idx - 1, v) : INT_MAX / 2;
            while(sf[v] != -1) {
                if (sf[v] <= prev_val) ans = min(ans, search(idx - 1, sf[v]) + op);
                v = sf[v], op += 1;
            }
                
            return ans;
        };
        int ans = search(ns.size() - 1, INT_MAX);
        return ans != INT_MAX / 2 ? ans : -1;
    }
};",1427860172
Ahemad_14,Ahemad_14,142,3502,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long int
#define ld long double
#define F first
#define S second
const int MOD=1e9+7;
#define vl vector<ll>
#define vi vector<int>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define mem(v,z) memset(v,z,sizeof(v))
#define bpc(x) __builtin_popcountll(x)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define fast() ios_base::sync_with_stdio(false); cin.tie(NULL);
#define pb push_back
#define in insert
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool check(vi &v,int k){
        for(auto &it:v) if(it>=k) return 1;
        return 0;
    }
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i=0;i<s.size();i++){
            vi v(26,0);
            for(int j=i;j<s.size();j++){
                v[s[j]-'a']++;
                if(check(v,k)) ans++;
            }
        }
        
        return ans;
    }
};",1427828837
Ahemad_14,Ahemad_14,142,3566,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long int
#define ld long double
#define F first
#define S second
const int MOD=1e9+7;
#define vl vector<ll>
#define vi vector<int>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define mem(v,z) memset(v,z,sizeof(v))
#define bpc(x) __builtin_popcountll(x)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define fast() ios_base::sync_with_stdio(false); cin.tie(NULL);
#define pb push_back
#define in insert
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    vector<string> stringSequence(string target) {
        vs v;
        string ans="""";
        for(auto &it:target){
            ans+=""a"";
            v.pb(ans);
            while(ans.back() != it){
                ans.back()=char(ans.back()+1);
                v.pb(ans);
            }
        }
        
        return v;
    }
};",1427825340
Ahemad_14,Ahemad_14,142,3603,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long int
#define ld long double
#define F first
#define S second
const int MOD=1e9+7;
#define vl vector<ll>
#define vi vector<int>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define mem(v,z) memset(v,z,sizeof(v))
#define bpc(x) __builtin_popcountll(x)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define fast() ios_base::sync_with_stdio(false); cin.tie(NULL);
#define pb push_back
#define in insert
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class StringHash {
public:
    vector<long long>ps1,ps2;
    vector<long long>powxyq1,powxyq2;
    long long Q1 = 277, Q2 = 271, M1 = 1000000007, M2 = 998244353;
    StringHash(string s) {
        ps1 = vector<long long>(s.size()+3); ps2 = vector<long long>(s.size()+3);
        powxyq1 = vector<long long>(s.size()+3); powxyq2 = vector<long long>(s.size()+3);
		powxyq1[0]=powxyq2[0]=1;
        for (int i = 1; i <= s.size(); i++) {
            long long c = s[i-1] + 1;
            ps1[i] = ((Q1 * ps1[i-1]) + c)%M1;
            ps2[i] = ((Q2 * ps2[i-1]) + c)%M2;
			powxyq1[i]=(powxyq1[i-1]*Q1)%M1;
			powxyq2[i]=(powxyq2[i-1]*Q2)%M2;
        }
    }

    long long substrHash1(int firstIndex, int lastIndex) {
        long long rem = (powxyq1[lastIndex-firstIndex+1] * ps1[firstIndex])%M1;
        return (ps1[lastIndex+1] - rem + M1)%M1;
    }
    long long substrHash2(int firstIndex, int lastIndex) {
        long long rem = (powxyq2[lastIndex-firstIndex+1] * ps2[firstIndex])%M2;
        return (ps2[lastIndex+1] - rem + M2)%M2;
    }
    pair<long long, long long> substrHash(int firstIndex, int lastIndex) {
        return {substrHash1(firstIndex, lastIndex), substrHash2(firstIndex, lastIndex)};
    }


	pair<long long, long long> addTwoSubstring(pair<long long,long long> a, pair<long long,long long>b,long long sizeOfSecondString) {
        long long x=((a.first*powxyq1[sizeOfSecondString])%M1 + b.first)%M1;
        long long y=((a.second*powxyq2[sizeOfSecondString])%M2 + b.second)%M2;
        return {x,y};
    }

	pair<long long, long long> addTwoSubstring (int i1,int j1,int i2,int j2){
		pair<long long, long long> a=substrHash(i1,j1);
		pair<long long, long long> b=substrHash(i2,j2);
		long long sizeOfSecondString=j2-i2+1;
		long long x=((a.first*powxyq1[sizeOfSecondString])%M1 + b.first)%M1;
        long long y=((a.second*powxyq2[sizeOfSecondString])%M2 + b.second)%M2;
        return {x,y};
	}
};

vector<int> g[100500];

class Solution {
public:
    int n;
    void dfs1(int i,int p, string &s,string &s1,vi &index){
        
        s1+=s[i];
        index[i]=s1.size()-1;
        
        for(auto &it:g[i]){
            if(it==p) continue;
            dfs1(it,i,s,s1,index);
        }
    }
    
    void dfs2(int u,int p,StringHash &sh1,StringHash &sh2,vi &index,vector<bool>&ans,int i,int j){
        
        int i1=n-i-1;
        int j1=n-i-(j-i+1);
        
        
        if(sh1.substrHash(i,j)==sh2.substrHash(j1,i1)){
            ans[u]=1;
            
        }
        // else{
        //     cout<<u<<endl;
        //     // cout<<i<<"" ""<<j<<"" ""<<i1<<"" ""<<j1<<endl;
        // }
        
        for(int ind=0;ind<g[u].size();ind++){
            if(g[u][ind]==p) continue;
            int it=g[u][ind];
            int nx=-1;
            int ind1=ind+1;
            while(ind1<g[u].size()){
                if(g[u][ind1]!=p){
                    nx=g[u][ind1];
                    break;
                }
                ind1++;
            }
            
            if(nx==-1) dfs2(it,u,sh1,sh2,index,ans,index[it],j);
            else dfs2(it,u,sh1,sh2,index,ans,index[it],index[nx]-1);
        }
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        string s1="""";
        n=s.size();
        cl(n);
        for(int i=1;i<parent.size();i++){
            g[i].pb(parent[i]);
            g[parent[i]].pb(i);
        }
        
        vi index(n+5,-1);
        for(int i=0;i<=n;i++) sort(all(g[i]));
        for(int i=0;i<=n;i++) reverse(all(g[i]));
        dfs1(0,-1,s,s1,index);
        
        
        // cout<<s1<<endl;
        string s2=s1;
        reverse(all(s2));
        StringHash sh1(s1);
        StringHash sh2(s2);
        // cout<<s2<<endl;
        
        vector<bool>ans(n,0);
        
        dfs2(0,-1,sh1,sh2,index,ans,0,n-1);
        return ans;
    }
};",1427896707
Ahemad_14,Ahemad_14,142,3607,cpp,"
/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long int
#define ld long double
#define F first
#define S second
const int MOD=1e9+7;
#define vl vector<ll>
#define vi vector<int>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define mem(v,z) memset(v,z,sizeof(v))
#define bpc(x) __builtin_popcountll(x)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define fast() ios_base::sync_with_stdio(false); cin.tie(NULL);
#define pb push_back
#define in insert
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

const int MAXN =1e6+2;
 
int spf[MAXN+2];
 
void sieve()
{
    for (ll i = 2; i <= MAXN; i++)
        spf[i] = i;
 
    // separately marking spf for every even
    // number as 2
    for (ll i = 4; i <= MAXN; i += 2)
        spf[i] = 2;
 
    for (ll i = 3; i * i <= MAXN; i++) {
        // checking if i is prime
        if (spf[i] == i) {
            // marking SPF for all numbers divisible by i
            for (ll j = i * i; j <= MAXN; j += i)
 
                // marking spf[j] if it is not
                // previously marked
                if (spf[j] == j)
                    spf[j] = i;
        }
    }
}

int getMinFactorization(ll x)
{
    int mn=1e9;
    while (x != 1) {
        mn=min(mn,spf[x]);
        x = x / spf[x];
    }
    return mn;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        sieve();
        
        int c=0;
        for(int i=n-2;i>=0;i--){
            while(nums[i]>nums[i+1]){
                ll x=getMinFactorization(nums[i]);
                if(x==nums[i] || x==1) return -1;
                c++;
                nums[i]=x;
            }
        }
        
        return c;
    }
};",1427841492
Shacola,shacola,146,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            cnt = defaultdict(int)
            mx = 0
            for j in range(i, n):
                ch = s[j]
                cnt[ch] += 1
                mx = max(mx, cnt[ch])
                if mx >= k:
                    ans += 1
        return ans",1427829950
Shacola,shacola,146,3566,python3,"
class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        s = """"

        for ch in target:
            s += 'a'
            ans.append(s)
            for _ in range(ord(ch) - ord('a')):
                s = s[:-1] + chr(((ord(s[-1]) - ord('a') + 1) % 26) + ord('a'))
                ans.append(s)

        return ans",1427825454
Shacola,shacola,146,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        MOD1 = 10**9 + 7
        MOD2 = 10**9 + 9
        BASE = random.randint(27, 100)

        P1 = [1] * (n + 1) # power of BASE
        P2 = [1] * (n + 1)
        for i in range(1, n + 1):
            P1[i] = (P1[i-1] * BASE) % MOD1
            P2[i] = (P2[i-1] * BASE) % MOD2

        HF1 = [0] * n # forward hash
        HF2 = [0] * n
        HB1 = [0] * n # backward hash
        HB2 = [0] * n
        ln = [0] * n  # dfsStr length

        def dfs1(u):
            nonlocal tree, s, HF1, HF2, HB1, HB2, ln
            cur_ln = 0
            hf1, hf2, hb1, hb2 = 0, 0, 0, 0
            for child in sorted(tree[u]):
                dfs1(child)
                hf1 = (hf1 * P1[ln[child]] + HF1[child]) % MOD1
                hf2 = (hf2 * P2[ln[child]] + HF2[child]) % MOD2
                hb1 = (HB1[child] * P1[cur_ln] + hb1) % MOD1
                hb2 = (HB2[child] * P2[cur_ln] + hb2) % MOD2
                cur_ln += ln[child]
            ch = ord(s[u]) - ord('a') + 1
            hf1 = (hf1 * BASE + ch) % MOD1
            hf2 = (hf2 * BASE + ch) % MOD2
            hb1 = (ch * P1[cur_ln] + hb1) % MOD1
            hb2 = (ch * P2[cur_ln] + hb2) % MOD2
            cur_ln += 1
            HF1[u], HF2[u], HB1[u], HB2[u] = hf1, hf2, hb1, hb2
            ln[u] = cur_ln

        def dfs2(u):
            nonlocal tree, s, HF1, HF2, HB1, HB2, ln
            cur_ln = 0
            hf1, hf2, hb1, hb2 = 0, 0, 0, 0
            for child in tree[u]:
                dfs2(child)
                hf1 = (hf1 * P1[ln[child]] + HF1[child]) % MOD1
                hf2 = (hf2 * P2[ln[child]] + HF2[child]) % MOD2
                hb1 = (HB1[child] * P1[cur_ln] + hb1) % MOD1
                hb2 = (HB2[child] * P2[cur_ln] + hb2) % MOD2
                cur_ln += ln[child]
            ch = ord(s[u]) - ord('a') + 1
            hf1 = (hf1 * BASE + ch) % MOD1
            hf2 = (hf2 * BASE + ch) % MOD2
            hb1 = (ch * P1[cur_ln] + hb1) % MOD1
            hb2 = (ch * P2[cur_ln] + hb2) % MOD2
            cur_ln += 1
            HF1[u], HF2[u], HB1[u], HB2[u] = hf1, hf2, hb1, hb2
            ln[u] = cur_ln

        for u in range(n):
            if parent[u] == -1:
                dfs2(u)
        
        ans = [False] * n
        for u in range(n):
            if HF1[u] == HB1[u] and HF2[u] == HB2[u]:
                ans[u] = True
            else:
                ans[u] = False
        return ans",1427906172
Shacola,shacola,146,3607,python3,"MAX = int(1e6) + 5
lpd = [1] * (MAX + 1)  # largest proper divisor
for i in range(2, MAX // 2 + 1):
    for j in range(2 * i, MAX + 1, i):
        if i > lpd[j]:
            lpd[j] = i

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def helper(x):
            values = [x]
            while True:
                pd = lpd[x] # proper divisor
                if pd <= 1:
                    break
                x = x // pd
                values.append(x)
            return values[::-1]
        last = float('inf')
        ans = 0
        for x in reversed(nums):
            values = helper(x)
            idx = bisect_right(values, last) - 1
            if idx < 0:
                return -1
            x = values[idx]
            cur = values[::-1].index(x)
            last = x
            ans += cur
        return ans",1427884795
QzjkuhhQ17,QzjkuhhQ17,149,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),re=0;
        for(int i=0;i<n;i++){
            array<int,26> cnt{};
            int j=i;
            while(j<n){
                int id=s[j]-'a';
                cnt[id]++;
                if(cnt[id]==k){
                    re+=n-j;
                    break;
                }
                j++;
            }
        }
        return re;
    }
};",1427838620
QzjkuhhQ17,QzjkuhhQ17,149,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string temp;
        for(char ch:target){
            temp.push_back('a');
            res.push_back(temp);
            while(temp.back()!=ch) {
                char x=temp.back();
                temp.pop_back();
                temp.push_back(x+1);
                res.push_back(temp);
            }
        }
        return res;
    }
};",1427832794
QzjkuhhQ17,QzjkuhhQ17,149,3603,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};

template <typename T> T power(T a, long long b) {
    assert(b >= 0);
    T r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;
}

template <typename U, typename V> struct pairnum {
    U u;
    V v;

    pairnum() : u(0), v(0) {}
    pairnum(long long val) : u(val), v(val) {}
    pairnum(const U& u_, const V& v_) : u(u_), v(v_) {}

    friend std::ostream& operator << (std::ostream& out, const pairnum& n) { return out << '(' << n.u << ',' << ' ' << n.v << ')'; }
    friend std::istream& operator >> (std::istream& in, pairnum& n) { long long val; in >> val; n = pairnum(val); return in; }

    friend bool operator == (const pairnum& a, const pairnum& b) { return a.u == b.u && a.v == b.v; }
    friend bool operator != (const pairnum& a, const pairnum& b) { return a.u != b.u || a.v != b.v; }

    pairnum inv() const {
        return pairnum(u.inv(), v.inv());
    }
    pairnum neg() const {
        return pairnum(u.neg(), v.neg());
    }
    pairnum operator- () const {
        return pairnum(-u, -v);
    }
    pairnum operator+ () const {
        return pairnum(+u, +v);
    }

    pairnum& operator ++ () {
        ++u, ++v;
        return *this;
    }
    pairnum& operator -- () {
        --u, --v;
        return *this;
    }

    pairnum& operator += (const pairnum& o) {
        u += o.u;
        v += o.v;
        return *this;
    }
    pairnum& operator -= (const pairnum& o) {
        u -= o.u;
        v -= o.v;
        return *this;
    }
    pairnum& operator *= (const pairnum& o) {
        u *= o.u;
        v *= o.v;
        return *this;
    }
    pairnum& operator /= (const pairnum& o) {
        u /= o.u;
        v /= o.v;
        return *this;
    }

    friend pairnum operator ++ (pairnum& a, int) { pairnum r = a; ++a; return r; }
    friend pairnum operator -- (pairnum& a, int) { pairnum r = a; --a; return r; }
    friend pairnum operator + (const pairnum& a, const pairnum& b) { return pairnum(a) += b; }
    friend pairnum operator - (const pairnum& a, const pairnum& b) { return pairnum(a) -= b; }
    friend pairnum operator * (const pairnum& a, const pairnum& b) { return pairnum(a) *= b; }
    friend pairnum operator / (const pairnum& a, const pairnum& b) { return pairnum(a) /= b; }
};
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>> adj(n);
        for(int i=1;i<n;i++) adj[parent[i]].push_back(i);
        vector<pair<int,int>> se(n);
        string temp;
        auto dfs=[&](auto self,int u)->void{
            int st=temp.size();
            //sort(adj[u].begin(),adj[u].end());
            for(int v:adj[u])self(self,v);
            temp.push_back(s[u]);
            int e=temp.size();
            se[u]={st,e};
        };
        dfs(dfs,0);
        using m1=modnum<1'000'000'007>;
        using m2=modnum<1'000'000'009>;
        using pm=pairnum<m1,m2>;
        int sz=temp.size();
        vector<pm> pw(sz+1),fw(sz+1),bw(sz+1);
        pm x{11,13};
        pw[0]={1,1};
        for(int i=0;i<sz;i++)pw[i+1]=pw[i]*x;
        for(int i=0;i<sz;i++) fw[i+1]=fw[i]*x+pm{temp[i]-'a'+1,temp[i]-'a'+1};
        for(int i=0;i<sz;i++) bw[i+1]=bw[i]*x+pm{temp[sz-1-i]-'a'+1,temp[sz-1-i]-'a'+1};
        vector<bool> re(n);
        //cout << temp << '\n';
        for(int i=0;i<n;i++){
            auto [s,e]=se[i];
            //cout << s << ' ' << e << '\n';
            int k=(e-s)/2;
            int l1=s,r1=s+k,l2=sz-e,r2=l2+k;
            if(fw[r1]-fw[l1]*pw[k]==bw[r2]-bw[l2]*pw[k]) re[i]=true;
            else re[i]=false;
        }
        return re;
    }
};",1427891733
QzjkuhhQ17,QzjkuhhQ17,149,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int mx=1'001;
        vector<int> inp(mx),prime;
        for(int i=2;i<mx;i++){
            if(!inp[i]){
                prime.push_back(i);
                for(int j=i*i;j<mx;j+=i)inp[j]=true;
            }
        }
        reverse(nums.begin(),nums.end());
        int re=0;
        for(int i=1,n=nums.size();i<n;i++){
            int target=nums[i-1];
            int& x=nums[i];
            if(x<=target) continue;
            for(int p:prime) {
                if(x>p&&x%p==0){
                    x=p;
                    re++;
                    break;
                }
            }
            if(x>target)return -1;
        }
        return re;
    }
};",1427857703
xlx2,xlx2,150,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        c = [0] * 26
        i = 0
        for j,v in enumerate(s):
            x = ord(v) - ord('a')
            c[x] += 1
            if c[x] >= k:
                while (y := ord(s[i]) - ord('a')) != x or c[y] > k:
                    c[y] -= 1
                    i += 1
                ans += i+1
            elif max(c) >= k:
                ans += i+1
        return ans",1427868399
xlx2,xlx2,150,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        cur = ''
        res = []
        for c in target:
            x = 'a'
            while True:
                res.append(cur + x)
                if x == c: break
                x = chr(ord(x) + 1)
            cur += c
        return res",1427868641
xlx2,xlx2,150,3603,python3,"class StrHash:
    def __init__(self, n: int, base=13331, mod=634777849558332619) -> None:
        pw = [1] * (n+1)
        for i in range(1, n+1):
            pw[i] = pw[i-1] * base % mod
        self.n, self.b, self.M, self.pw = n, base, mod, pw
        self.table = []
    
    def hash(self, s: str) -> None:     
        m = len(s)                      
        f = [0] * (m+1)
        for i in range(m-1, -1, -1):
            f[i] = (f[i+1] * self.b + ord(s[i])) % self.M
        self.table.append(f)
    
    def get(self, i: int, l: int, r: int) -> int:  
        if l > r: return 0   
        f = self.table[i]
        return (f[l] - f[r+1] * self.pw[r+1-l]) % self.M


class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        G = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                G[p].append(i)
        for i in range(n):
            G[i].sort()

        l = [1] * n
        dfsstr = []
        def dfs(i):
            for j in G[i]:
                dfs(j)
                l[i] += l[j]
            dfsstr.append(s[i])
        dfs(0)

        t = ''.join(dfsstr)
        sh = StrHash(n)
        sh.hash(t)
        sh.hash(t[::-1])

        ans = [False] * n
        def dfs2(i, a, b):
            if l[i] == 1:
                ans[i] = True
                return
            if sh.get(0, a, b) == sh.get(1, n-1-b, n-1-a):
                ans[i] = True
            x = a
            for j in G[i]:
                dfs2(j, x, x+l[j]-1)
                x += l[j]

        dfs2(0, 0, n-1)
        return ans",1427900901
xlx2,xlx2,150,3607,python3,"N = 10**6+1
f = [1] * N
for i in range(2, N):
    if f[i] == 1:
        for j in range(i+i, N, i):
            if f[j] == 1:
                f[j] = i
            
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        @cache
        def g(i, prev):
            if i == n:
                return 0
            if prev > nums[i]:
                return math.inf
            ans = g(i+1, nums[i])
            if f[nums[i]] != 1 and prev <= f[nums[i]]:
                ans = min(ans, g(i+1, f[nums[i]]) + 1)
            return ans

        ans = g(0, 0)
        g.cache_clear()
        return ans if ans < math.inf else -1",1427868238
leetcode_speedrun,leetcode_speedrun,151,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        
        cnt = {""zz"": 0}
        n = len(s)
        j = 0
        for i in range(n):
            while j < n and max(cnt.values()) < k:
                cnt[s[j]] = cnt.get(s[j],0)+1
                j += 1
            
            if max(cnt.values()) >= k:
                ans += (n-j+1) 
                # print(i,j)
            cnt[s[i]] -= 1
        
        return ans
        ",1427833323
leetcode_speedrun,leetcode_speedrun,151,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        cur = []
        res = []
        target = list(target)
        while cur != target:
           
            if len(cur) == 0 or cur[-1] == target[len(cur)-1]:
                cur.append(""a"")
            else:
                cur.append( chr(ord((cur.pop(-1)))+1 ))
            res.append("""".join(cur[:]))
        
        return res",1427827745
leetcode_speedrun,leetcode_speedrun,151,3603,python3,"class Solution:
    def dfs(self, r = 0):
        self.st[r] = self.idx
        
        for i in self.C[r]:
            self.dfs(i)
        self.idx += 1
        self.fs += (self.s[r])
        self.ed[r] = self.idx
        
    def findAnswer(self, p: List[int], s: str) -> List[bool]:
        n = len(s)
        self.s = s
        self.st = [-1]*n
        self.ed = [-1]*n
        self.idx = 0
        self.C = [[] for i in range(n)]
        self.fs = """"
        for i in range(1,n):
            self.C[p[i]].append(i)
        # print(self.C)
        self.dfs()
        sf = self.fs[::-1]
        ans = [0]*n
        # print(sf,self.fs)
        for i in range(n):
            # print(i, self.fs[self.st[i]:self.ed[i]],sf[n - self.ed[i] :n - self.st[i] ] )
            ans[i] = (self.fs[self.st[i]:self.ed[i]] == sf[n - self.ed[i] :n - self.st[i] ])
        return ans
        
        
        
        ",1427875898
leetcode_speedrun,leetcode_speedrun,151,3607,python3,"mxn = 10**6+2
P = list(range(mxn))
for i in range(4,mxn,2):
    P[i] = 2
for i in range(3,mxn,2):
    if P[i] != i:
        continue
    for j in range(i*i,mxn,2*i):
        if P[j] == j:
            P[j] = i

class Solution:
    def __init__(self):
        self.P = P
        
    
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        # print(self.P[:10])
        ans = 0
        nums = nums[::-1]
        mx = 10**18
        for i in range(n):
            if nums[i] <= mx:
                mx = nums[i]
                continue
            # print(i,nums[i], P[nums[i]])
            
            if self.P[nums[i]] == nums[i]:
                return -1
            ans += 1
            nums[i] = self.P[nums[i]]
            if nums[i] > mx:
                return -1
            
            mx = nums[i]
        return ans
            
        ",1427851317
czjnbb,czjnbb,154,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        lens = len(s)
        res = 0
        l = 0
        d = defaultdict(int)
        f = False
        
        for r in range(lens):
            c = s[r]
            d[c] += 1
            if max(d.values()) >= k:
                f = True
            
            if not f:
                continue
            
            while max(d.values()) >= k:        
                p = s[l]
                d[p] -= 1
                l += 1
                
            res += l
            
        return res
            
            ",1427833164
czjnbb,czjnbb,154,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        
        res = []
        
        for i,c in enumerate(target):
            pre = target[:i]
            cur = 97
            while chr(cur) != c:
                res.append(pre + chr(cur))
                cur += 1
            res.append(pre + chr(cur))
            
        return res
                
                ",1427825844
czjnbb,czjnbb,154,3603,python3,"mod = 10**9 + 7
base = 31
power = [1]

for _ in range(10**5 + 1):
    pre = power[-1]
    pre = pre * base % mod
    power.append(pre)


class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        
        def helper(cur):
            
            char = s[cur]
            num = ord(char) - 97
            
            if cur not in d:
                res[cur] = True
                return [num, num, 1]
            
            
            d[cur].sort()
            ll = 0
            fh = bh = 0
            ret = []
            
            for nxt in d[cur]:
                ret.append(helper(nxt))
                
            for f, b, l in ret:
                fh = (fh * power[l] + f) % mod
                ll += l
                
            fh = (fh * power[1] + num) % mod
            
            
            ll = 0
            
            for f, b, l in ret[::-1]:
                bh = (bh * power[l] + b) % mod
                ll += l
                
            bh = (num * power[ll] + bh) % mod
            
            # print(fh, bh, cur)
                
            if fh == bh:
                res[cur] = True
                
                
            return [fh, bh, ll + 1]
                
            
        
        ### par to child
        d = defaultdict(list)
        
        for i,p in enumerate(parent):
            d[p].append(i)
        
        
        leng = len(parent)
        res = [False for _ in range(leng)]
        
        helper(0)
        
        return res
        
        ",1427901990
czjnbb,czjnbb,154,3607,python3,"p = set()
siev = [True for _ in range(10**6 + 1)]

for i in range(2, 10**6 + 1):
    if siev[i]:
        p.add(i)
        for j in range(2 * i, 10**6 + 1, i):
            siev[j] = False

            
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        
        leng = len(nums)
        res = 0
        
        for i in range(leng - 2, -1, -1):
            
            cur = nums[i]
            nxt = nums[i + 1]
            if cur <= nxt:
                continue
                
            if cur in p or nxt == 1:
                return -1
            
            while cur > nxt and cur not in p:
                upp = int(sqrt(cur))
                for div in range(2, upp + 1):
                    if cur % div == 0:
                        res += 1
                        cur = div
                        break
                        
            if cur <= nxt:
                nums[i] = cur
            else:
                return -1
            
        return res
                
        ",1427848881
Tianyi Chen,tianyichen,155,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),ans=0;
        for(auto&x:s)x-='a';
        for(int i=0;i<n;++i){
            int cnt[26]={};
            for(int j=i;j<n;++j){
                if(++cnt[s[j]]==k){
                    ans+=n-j;break;
                }
            }
        }
        return ans;
    }
};",1427828403
Tianyi Chen,tianyichen,155,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> r;string t;
        for(auto&x:target){
            t.push_back('a');
            for(;t.back()<=x;++t.back()){
                r.push_back(t);
            }
            --t.back();
        }
        return r;
    }
};",1427824725
Tianyi Chen,tianyichen,155,3603,cpp,"constexpr int N=1e5+10;
using ull=uint64_t;
constexpr ull p=37;
ull pw[N];
vector<int>e[N];
vector<bool>ans;
struct H{
    ull f,b;
    int len;
    H operator+(const H&o){
        H r;
        r.len=len+o.len;
        r.f=f+pw[len]*o.f;
        r.b=b*pw[o.len]+o.b;
        return r;
    }
};
vector<H>h[N];
string*s;
H dfs(int i){
    h[i].clear();
    H r((*s)[i],(ull)(*s)[i],1);
    for(auto&x:e[i]){
        h[i].push_back(dfs(x));
    }
    for(int x=h[i].size()-1;x>=0;--x){
        r=h[i][x]+r;
    }
    ans[i]=r.f==r.b;
    return r;
}
const auto init=[](){
    pw[0]=1;
    for(int i=1;i<=100000;++i)pw[i]=pw[i-1]*p;
    return 1;
}();
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s_) {
        //cout<<pw[1]<<' '<<pw[2]<<endl;
        s=&s_;
        for(auto&x:s_)x=x-'a';
        int n=parent.size();
        ans.resize(n);
        for(int i=0;i<n;++i)e[i].clear();
        for(int i=1;i<n;++i)e[parent[i]].push_back(i);
        dfs(0);
        return ans;
    }
};",1427893665
Tianyi Chen,tianyichen,155,3607,cpp,"constexpr int N=1e6;
class Solution {
public:
    int minOperations(vector<int>& nums) {
        static vector<int> gd(1e6+1);int ans=0;
        if(!gd[8])for(int i=2;i<=N;++i)if(!gd[i]){
            for(long j=long(i)*i;j<=N;j+=i)if(!gd[j]){
                gd[j]=i;
            }
        }
        for(int i=nums.size()-2;i>=0;--i){
            if(nums[i]>nums[i+1]&&gd[nums[i]])
                nums[i]=gd[nums[i]],++ans;
            //cout<<i<<' '<<nums[i]<<endl;
            if(nums[i]>nums[i+1])return -1;
        }
        return ans;
    }
};",1427855866
Nicolas Alba,nicolasalba,156,3502,cpp,"#define ACTIVE_DEBUG
// ############ Ignore macros and debugger ########################
#include ""bits/stdc++.h""
using namespace std;

#define pb push_back
#define F first
#define S second
#define all(x) (x).begin(), (x).end()
#define sortt(x) sort(all(x))

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pl = pair<ll, ll>;
using ti = tuple<long long, long long, long long>;
using vi = vector<int>;
using vb = vector<bool>;
using vl = vector<ll>;
using vs = vector<string>;
using vvl = vector<vl>;
using vpl = vector<pl>;

template<class T> using pql = priority_queue<T,vector<T>,greater<T>>;
template<class T> using pqg = priority_queue<T>;

void __print(int x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(string x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(bool x) {cout << (x ? ""T"" : ""F"");}

void __print(map<ll,ll> mp) {
    for (auto p : mp) {
        cout << p.F << "":"" << p.S << "","";
    }
}

template<typename T> // for data structures (vector, set, map, etc)

void __print(const T &xs)
{cout << ""[ ""; for (auto &x : xs) {__print(x);cout << ' ';}cout << ']';}

void _print()
{cout << ""]"" << endl;}

template <typename T, typename... V>
void _print(T t, V... v)
{__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}

#ifdef ACTIVE_DEBUG
    #define deb(x...) cout << ""["" << #x << ""] = ["", _print(x)
    #define LINE cout << ""-------------------"" << endl;
#else
    #define deb(x...) ""C""
    #define LINE ""C""
#endif
// ############ Ignore macros and debugger ########################

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
 
// #define oset tree<pair<ll,ll>, null_type,greater<pair<ll,ll>>, rb_tree_tag,tree_order_statistics_node_update>
// //find_by_order(k) order_of_key(k)

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        ll n =s.size();
        map<char,ll> cnt;

        auto mx =[&]() {
            ll ok= 0;
            for (auto c : cnt) {
                ok = max(ok,c.S);
            }
            return ok;
        };
        ll j = -1;
        ll ans =0;
        for (int i =0;i<n;i++) {
            while (mx()<k && j+1<n) {
                j++;
                cnt[s[j]]++;
            }

            if (mx()>=k) {
                // deb(i,j);
                ans += n-j;
            }
            cnt[s[i]]--;
        }
        return ans;
    }
};",1427833513
Nicolas Alba,nicolasalba,156,3566,cpp,"// #define ACTIVE_DEBUG
// ############ Ignore macros and debugger ########################
#include ""bits/stdc++.h""
using namespace std;

#define pb push_back
#define F first
#define S second
#define all(x) (x).begin(), (x).end()
#define sortt(x) sort(all(x))

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pl = pair<ll, ll>;
using ti = tuple<long long, long long, long long>;
using vi = vector<int>;
using vb = vector<bool>;
using vl = vector<ll>;
using vs = vector<string>;
using vvl = vector<vl>;
using vpl = vector<pl>;

template<class T> using pql = priority_queue<T,vector<T>,greater<T>>;
template<class T> using pqg = priority_queue<T>;

void __print(int x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(string x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(bool x) {cout << (x ? ""T"" : ""F"");}

void __print(map<ll,ll> mp) {
    for (auto p : mp) {
        cout << p.F << "":"" << p.S << "","";
    }
}

template<typename T> // for data structures (vector, set, map, etc)

void __print(const T &xs)
{cout << ""[ ""; for (auto &x : xs) {__print(x);cout << ' ';}cout << ']';}

void _print()
{cout << ""]"" << endl;}

template <typename T, typename... V>
void _print(T t, V... v)
{__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}

#ifdef ACTIVE_DEBUG
    #define deb(x...) cout << ""["" << #x << ""] = ["", _print(x)
    #define LINE cout << ""-------------------"" << endl;
#else
    #define deb(x...) ""C""
    #define LINE ""C""
#endif
// ############ Ignore macros and debugger ########################

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
 
// #define oset tree<pair<ll,ll>, null_type,greater<pair<ll,ll>>, rb_tree_tag,tree_order_statistics_node_update>
// //find_by_order(k) order_of_key(k)

class Solution {
public:
    vector<string> stringSequence(string target) {
        string actual;
        vector<string> path;
        while (actual.size() != target.size() || target.back() != actual.back()) {
            ll pos = (ll)actual.size()-1;
            if (actual.empty() || target[pos] == actual[pos]) {
                actual.pb('a');
            } else {
                actual.back()++;
            }
            path.pb(actual);
        }      
        return path;
    }
};",1427826490
Nicolas Alba,nicolasalba,156,3603,cpp,"#define ACTIVE_DEBUG
// ############ Ignore macros and debugger ########################
#include ""bits/stdc++.h""
using namespace std;

#define pb push_back
#define F first
#define S second
#define all(x) (x).begin(), (x).end()
#define sortt(x) sort(all(x))

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pl = pair<ll, ll>;
using ti = tuple<long long, long long, long long>;
using vi = vector<int>;
using vb = vector<bool>;
using vl = vector<ll>;
using vs = vector<string>;
using vvl = vector<vl>;
using vpl = vector<pl>;

template<class T> using pql = priority_queue<T,vector<T>,greater<T>>;
template<class T> using pqg = priority_queue<T>;

void __print(int x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(string x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(bool x) {cout << (x ? ""T"" : ""F"");}

void __print(map<ll,ll> mp) {
    for (auto p : mp) {
        cout << p.F << "":"" << p.S << "","";
    }
}

template<typename T> // for data structures (vector, set, map, etc)

void __print(const T &xs)
{cout << ""[ ""; for (auto &x : xs) {__print(x);cout << ' ';}cout << ']';}

void _print()
{cout << ""]"" << endl;}

template <typename T, typename... V>
void _print(T t, V... v)
{__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}

#ifdef ACTIVE_DEBUG
    #define deb(x...) cout << ""["" << #x << ""] = ["", _print(x)
    #define LINE cout << ""-------------------"" << endl;
#else
    #define deb(x...) ""C""
    #define LINE ""C""
#endif
// ############ Ignore macros and debugger ########################

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
 
// #define oset tree<pair<ll,ll>, null_type,greater<pair<ll,ll>>, rb_tree_tag,tree_order_statistics_node_update>
// //find_by_order(k) order_of_key(k)


class Solution {
public:

    static const ll MOD1 = 998244353;
    static const ll MOD2 = 1000000009;
    static const ll B = 997; 

    struct Hash {
        ll h1, h2, sz;

        Hash() {
            h1 = h2 = sz = 0;
        }

        Hash(ll num) {
            h1 = (num) % MOD1;
            h2 = (num) % MOD2;
            sz = 1;
        }

        void mul(ll a, ll b) {
            h1 = (h1 * (a%MOD1)) % MOD1;
            h2 = (h2 * (b%MOD2)) % MOD2;
        }

        void add(ll a, ll b) {
            h1 = (h1 + (a%MOD1)) % MOD1;
            h2 = (h2 + (b%MOD2)) % MOD2;
        }

        bool eq(Hash o) {
            return h1 == o.h1 && h2 == o.h2 && sz == o.sz;
        }
    };

    vl p1, p2;
    Hash append(Hash h1, Hash h2) {
        h1.mul(p1[h2.sz], p2[h2.sz]);
        h1.add(h2.h1, h2.h2);
        h1.sz += h2.sz;
        return h1;
    }


    vb proc1, proc2;
    vector<Hash> dp1, dp2;


    vector<vector<int>> children;
    string t;

    Hash dfs(ll x) {
        if (proc1[x]) {
            return dp1[x]; 
        }

        Hash ans;
        for (int i = 0;i<children[x].size();i++) {
            ll y = children[x][i];
            ans = append(ans, dfs(y));
        }
        ans = append(ans, Hash(t[x]));
        
        proc1[x]=true;
        return dp1[x] = ans;
    }

    Hash dfsRev(ll x) {
        if (proc2[x]) {
            return dp2[x];
        }
        Hash ans(t[x]);

        for (int i = ll(children[x].size())-1;i>=0;i--) {
            ll y = children[x][i];
            ans = append(ans, dfsRev(y));
        }

        proc2[x] = true;
        return dp2[x] = ans;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        t = s;
        p1 = p2 = {1};
        ll n = s.size();

        children = vector<vector<int>>(n+1);
        proc1 = proc2 = vb(n+1);
        dp1 = dp2 = vector<Hash>(n+1);

        for (int i = 1;i<n;i++) {
            children[parent[i]].pb(i);
        }

        for (int i = 0;i<n;i++) {
            sort(children[i].begin(), children[i].end());
        }

        for (int i = 0;i<n+2;i++) {
            p1.pb((p1.back() * B) % MOD1);
            p2.pb((p2.back() * B) % MOD2);
        }

        vector<bool> ans(n);
        for (int i =0;i<n;i++) {
            ans[i] = dfs(i).eq(dfsRev(i));
        }
        
        // deb(dfs(3).h1);
        return ans;
    }
};",1427911137
Nicolas Alba,nicolasalba,156,3607,cpp,"#define ACTIVE_DEBUG
// ############ Ignore macros and debugger ########################
#include ""bits/stdc++.h""
using namespace std;

#define pb push_back
#define F first
#define S second
#define all(x) (x).begin(), (x).end()
#define sortt(x) sort(all(x))

using ll = long long;
using ld = long double;
using pi = pair<int, int>;
using pl = pair<ll, ll>;
using ti = tuple<long long, long long, long long>;
using vi = vector<int>;
using vb = vector<bool>;
using vl = vector<ll>;
using vs = vector<string>;
using vvl = vector<vl>;
using vpl = vector<pl>;

template<class T> using pql = priority_queue<T,vector<T>,greater<T>>;
template<class T> using pqg = priority_queue<T>;

void __print(int x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(string x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(bool x) {cout << (x ? ""T"" : ""F"");}

void __print(map<ll,ll> mp) {
    for (auto p : mp) {
        cout << p.F << "":"" << p.S << "","";
    }
}

template<typename T> // for data structures (vector, set, map, etc)

void __print(const T &xs)
{cout << ""[ ""; for (auto &x : xs) {__print(x);cout << ' ';}cout << ']';}

void _print()
{cout << ""]"" << endl;}

template <typename T, typename... V>
void _print(T t, V... v)
{__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}

#ifdef ACTIVE_DEBUG
    #define deb(x...) cout << ""["" << #x << ""] = ["", _print(x)
    #define LINE cout << ""-------------------"" << endl;
#else
    #define deb(x...) ""C""
    #define LINE ""C""
#endif
// ############ Ignore macros and debugger ########################

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
 
// #define oset tree<pair<ll,ll>, null_type,greater<pair<ll,ll>>, rb_tree_tag,tree_order_statistics_node_update>
// //find_by_order(k) order_of_key(k)

class Solution {
public:
    int minOperations(vector<int>& nums) {
        ll inf = 1e9;
        ll n = nums.size();

        ll mx = *max_element(all(nums))+1;

        vector<ll> lp(mx+2);
        for (ll i = 2;i<=mx;i++) {
            if (lp[i] == 0) for (ll j = i*2;j<=mx;j+=i) {
                if (lp[j]==0)lp[j] = i;
                lp[j] = min(lp[j],i);
            }
        }


        vector<vector<ll>> dp(2, vl(n,inf));

        dp[0][0] = 0;
        dp[1][0] = 1;

        // 0 normal, 1 applied

        for (int i = 1;i<n;i++) {

            // normal
            if (nums[i-1]<=nums[i]) {
                dp[0][i] = min(dp[0][i], dp[0][i-1]);
            }
            if (lp[nums[i-1]] != 0 && lp[nums[i-1]] <= nums[i]) {
                dp[0][i] = min(dp[0][i], dp[1][i-1]);
            }

            // applied
            if (lp[nums[i]] == 0) continue;

            if (nums[i-1] <= lp[nums[i]]) {
                dp[1][i] = min(dp[1][i], dp[0][i-1]+1);
            }
            if (lp[nums[i-1]] != 0 && lp[nums[i-1]] <= lp[nums[i]]) {
                dp[1][i] = min(dp[1][i], dp[1][i-1]+1);
            }
        }

        ll ans = min(dp[0].back(), dp[1].back());
        if (ans == inf) ans = -1;
        return ans;
    }
};",1427853591
Alok Mishra,isnotavail,159,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for(int i = 0 ; i < n ; ++i){
            vector<int> cnt(26 , 0);
            int mx = 0;
            for(int j = i ; j < n ; ++j){
                cnt[s[j] - 'a']++;
                mx = max(cnt[s[j] - 'a'] , mx);
                if(mx >= k)ans++;
            }
        }
        return ans;
    }
};",1427907203
Alok Mishra,isnotavail,159,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v;
        string cur = """";
        for(auto i : target){
            cur += 'a';
            v.push_back(cur);
            while(cur.back() != i){
                cur.back()++;
                v.push_back(cur);
            }
        }
        return v;
    }
};",1427911490
Alok Mishra,isnotavail,159,3603,cpp,"#define ll long long
ll mod = 1e9 + 7;
class Solution {
public:
    ll power(ll a, ll b, ll p)
    {
    if(a==0)
    return 0;
    ll res=1;
    a%=p;
    while(b>0)
    {
        if(b&1)
        res=(res*a)%p;
        b>>=1;
        a=(a*a)%p;
    }
    return res;
    }
    ll getHash(vector<pair<ll,ll>> &v){
        ll base = 31 ;
        ll curLen = 0;
        ll hash = 0;
        for(auto i : v){
            hash = (hash + ((i.first * power(base , curLen , mod)) % mod)) % mod;
            curLen += i.second;
        }
        return hash;
    }
    pair<pair<ll,ll>,ll> dfs(int node , int par , vector<int> adj[] , vector<bool>& ans , string& s){
        vector<pair<ll,ll>> val;
        vector<pair<ll,ll>> valr;
        ll len = 0;
        for(auto child : adj[node]){
            if(child == par)continue;
            pair<pair<ll,ll> , ll> pr = dfs(child , node , adj , ans,s);
            val.push_back(pair<ll,ll>{pr.first.first , pr.second});
            valr.push_back(pair<ll,ll>{pr.first.second , pr.second});
            len += val.back().second;
        }
        val.push_back({s[node] - 'a' + 1 , 1});
        valr.push_back({s[node] - 'a' + 1 , 1});
        ll h1 = getHash(val);
        reverse(valr.begin() , valr.end());
        ll h2 = getHash(valr);
        // cout<<node<<"" ""<<h1<<"" ""<<h2<<""\n"";
        ans[node] = (h1 == h2);
        return {{h1 , h2} , len + 1};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> ans(n);
        vector<int> adj[n];
        for(int i = 1 ; i < n ; ++i){
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        for(int i = 0 ; i < n ; ++i){
            sort(adj[i].begin() , adj[i].end());
        }
        dfs(0 , -1 , adj , ans , s);
        return ans;
    }
};",1427883456
Alok Mishra,isnotavail,159,3607,cpp,"#define MAXN 1000006
bool done = false;
int spf[MAXN];
 
void sieve()
{
    spf[1] = 1;
    done = true;
    for (int i = 2; i < MAXN; i++)
        spf[i] = i;

    for (int i = 4; i < MAXN; i += 2)
        spf[i] = 2;
 
    for (int i = 3; i * i < MAXN; i++) {
        if (spf[i] == i) {
            for (int j = i * i; j < MAXN; j += i)
                if (spf[j] == j)
                    spf[j] = i;
        }
    }
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(!done)sieve();
        reverse(nums.begin() , nums.end());
        int smallest = MAXN;
        int tot = 0;
        for(auto &i : nums){
            // cout<<i<<"" ""<<spf[i]<<""\n"";
            if(i > smallest){
                i = spf[i];
                ++tot;
            }
            if(i > smallest)return -1;
            smallest = i;
        }
        return tot;
    }
};",1427901305
Vasanth Reddy,vassu118,160,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        vector<vector<int>> a(26);
        for(int i = 0; i < n; i++) {
            int mx = -1;
            a[s[i] - 'a'].push_back(i);
            for(int j = 0; j < 26; j++) if(a[j].size() >= k) {
                mx = max(mx, a[j][a[j].size() - k]);
            }
            ans += mx + 1;
        }
        return ans;
    }
};",1427900386
Vasanth Reddy,vassu118,160,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string now = """";
        for(char c : target) {
            now += ""a"";
            while(c != now.back()) {
                ans.push_back(now);
                now.back() += 1;
            }
            ans.push_back(now);
        }
        return ans;
    }
};",1427903622
Vasanth Reddy,vassu118,160,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        string now = """";
        int n = parent.size();
        vector<vector<int>> g(n);
        vector<int> size(n);
        for(int i = 1; i < n; i++) g[parent[i]].push_back(i);
        auto dfs = [&](auto self, int x) -> void {
            sort(g[x].begin(), g[x].end());
            size[x] = 1;
            for(auto it : g[x]) { 
                self(self, it);
                size[x] += size[it];
            }
            now += s[x];
        };
        dfs(dfs, 0);
        
        vector<int> power(n + 10);
        power[0] = 1;
        int mod = 1e9 + 7;
        
        auto rev = [&](int x) -> int {
            int ans = 1;
            int y = mod - 2;
            for(; y; y >>= 1, x = 1LL * x * x % mod) if(y & 1) ans = 1LL * ans * x % mod;
            return ans;
        };
        for(int i = 1; i < n + 10; i++) power[i] = 1LL * power[i - 1] * 31 % mod;
        vector<int> pre(n), suf(n);
        for(int i = 0; i < n; i++) {
            if(i) pre[i] = pre[i - 1];
            pre[i] = (pre[i] + 1LL * power[i] * now[i] % mod) % mod;
        }
        for(int i = n - 1; i >= 0; i--) {
            if(i < n - 1) suf[i] = suf[i + 1];
            suf[i] = (suf[i] + 1LL * power[n - i - 1] * now[i] % mod) % mod;
        }
        
        auto check = [&](int l, int r) -> bool {
            int pre_hash = 1LL * (pre[r] - (l == 0 ? 0 : pre[l - 1]) + mod) % mod * rev(power[l]) % mod;
            int suf_hash = 1LL * (suf[l] - (r == n - 1 ? 0 : suf[r + 1]) + mod) % mod * rev(power[(n - r - 1)]) % mod;
            return pre_hash == suf_hash;
        };
        
        
        int sz = 0;
        vector<bool> ans(n);
        auto dfs2 = [&](auto self, int x) -> void {
            int store = sz;
            for(auto it : g[x]) self(self, it);
            ans[x] = check(store, store + size[x] - 1);
            sz += 1;
        };
        dfs2(dfs2, 0);
        return ans;
    }
};",1427882732
Vasanth Reddy,vassu118,160,3607,cpp,"
const int N = 1e6 + 118;
vector<int> store(N);
bool done = false;
void init() {
    if(done) return;
    done = true;
    for(int i = 1; i < N; i++) {
        for(int j = 2 * i; j < N; j += i) store[j] = i;
    }
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        int curr = 2e9;
        init();
        for(int i = nums.size() - 1; i >= 0; i--) {
            if(nums[i] <= curr) {
                curr = nums[i];
                continue;
            }
            while(nums[i] > curr) {
                int div = store[nums[i]];
                if(div == 1) return -1;
                nums[i] /= div;
                ans += 1;
            }
            curr = nums[i];
        }
        return ans;
    }
};",1427895010
kishan-jaiswal,kishan-jaiswal,161,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string inputStr, int target) {
        int len = getLength(inputStr);
        if (target == 1)
            return modDivide(modMultiplication(len, modAddition(len, 1)), 2);
        if (target > len)
            return 0;

        int totalCount = 0;
        for (int start = 0; start < len; start++) {
            vector<int> charFrequency(26, 0);
            int matches = 0;
            for (int end = start; end < len; end++) {
                int position = inputStr[end] - 'a';
                charFrequency[position]++;
                matches = modAddition(matches, charFrequency[position] == target);
                if (matches > 0)
                    totalCount = modAddition(totalCount, 1);
            }
        }
        return totalCount;
    }
    private:
    int modAddition(int a, int b) {
        return a + b;
    }

    int modSubtraction(int a, int b) {
        return a - b;
    }

    int modMultiplication(int a, int b) {
        return a * b;
    }

    int modDivide(int a, int b) {
        return a / b;
    }

    int getLength(const string& str) {
        return str.size();
    }
};",1427842619
kishan-jaiswal,kishan-jaiswal,161,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";

        for (char ch : target) {
            curr += 'a';
            res.push_back(curr);
            while (curr.back() != ch) {
                curr.back() =(curr.back() == 'z') ? 'a' : curr.back() + 1;
                res.push_back(curr);
            }
        }

        return res;
    }
};",1427828221
kishan-jaiswal,kishan-jaiswal,161,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& relations, string str) {
        vector<int> tmp_relations = relations;
        int size = relations.size();
        vector<vector<int>> adjList(size);
        for (int i = 1; i < size; ++i) {
            adjList[relations[i]].push_back(i);
        }

        vector<int> startIdx(size), endIdx(size);
        string traversalStr;
        int traverseCount = 0;

        function<void(int)> dfsTraversal = [&](int node) {
            startIdx[node] = traverseCount;
            for (int neighbor : adjList[node]) {
                dfsTraversal(neighbor);
            }
            traversalStr += str[node];
            endIdx[node] = traverseCount++;
        };

        dfsTraversal(0);

        string revTraversalStr = traversalStr;
        reverse(revTraversalStr.begin(), revTraversalStr.end());

        int length = traversalStr.size();
        const int64_t prime1 = 911, mod1 = 999999937;
        const int64_t prime2 = 3571, mod2 = 999999929;

        vector<int64_t> powPrime1(length + 1), powPrime2(length + 1);
        powPrime1[0] = powPrime2[0] = 1;
        for (int i = 1; i <= length; ++i) {
            powPrime1[i] = modMultiplication(powPrime1[i - 1], prime1, mod1);
            powPrime2[i] = modMultiplication(powPrime2[i - 1], prime2, mod2);
        }

        vector<int64_t> hash1(length), hash2(length), revHash1(length), revHash2(length);
        vector<int> charValue(256);
        for (char c = 'a'; c <= 'z'; ++c) {
            charValue[c] = c - 'a' + 1;
        }

        hash1[0] = charValue[traversalStr[0]];
        hash2[0] = charValue[traversalStr[0]];
        for (int i = 1; i < length; ++i) {
            hash1[i] = modAddition(modMultiplication(hash1[i - 1], prime1, mod1), charValue[traversalStr[i]], mod1);
            hash2[i] = modAddition(modMultiplication(hash2[i - 1], prime2, mod2), charValue[traversalStr[i]], mod2);
        }

        revHash1[0] = charValue[revTraversalStr[0]];
        revHash2[0] = charValue[revTraversalStr[0]];
        for (int i = 1; i < length; ++i) {
            revHash1[i] = modAddition(modMultiplication(revHash1[i - 1], prime1, mod1), charValue[revTraversalStr[i]], mod1);
            revHash2[i] = modAddition(modMultiplication(revHash2[i - 1], prime2, mod2), charValue[revTraversalStr[i]], mod2);
        }

        vector<bool> result(size);
        for (int node = 0; node < size; ++node) {
            int left = startIdx[node], right = endIdx[node];

            int64_t forwardHash1 = computeSubstringHash(hash1, powPrime1, left, right, mod1);
            int64_t forwardHash2 = computeSubstringHash(hash2, powPrime2, left, right, mod2);

            int A = length - 1 - right, B = length - 1 - left;
            int64_t reverseHash1 = computeSubstringHash(revHash1, powPrime1, A, B, mod1);
            int64_t reverseHash2 = computeSubstringHash(revHash2, powPrime2, A, B, mod2);

            result[node] = (forwardHash1 == reverseHash1 && forwardHash2 == reverseHash2);
        }

        return result;
    }
    private:
    int64_t modAddition(int64_t a, int64_t b, int64_t mod) {
        return (a + b) % mod;
    }

    int64_t modSubtraction(int64_t a, int64_t b, int64_t mod) {
        return (a - b + mod) % mod;
    }

    int64_t modMultiplication(int64_t a, int64_t b, int64_t mod) {
        return (a * b) % mod;
    }

    int64_t computeSubstringHash(const vector<int64_t>& hash, const vector<int64_t>& power, int left, int right, int64_t mod) {
        if (left > 0) {
            return modSubtraction(hash[right], modMultiplication(hash[left - 1], power[right - left + 1], mod), mod);
        } else {
            return hash[right];
        }
    }
};",1427837179
kishan-jaiswal,kishan-jaiswal,161,3607,cpp,"#define faster std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

class Solution {
public:
    static vector<int> smallestPrimeFactor;
    static bool sieve_computed;
    static void compute_sieve(int limit = 1000001) {
        smallestPrimeFactor.assign(limit, 0);
        for(int i = 0; i < limit; ++i){
            smallestPrimeFactor[i] = i;
        }
        for(int i = 2; i * i < limit; ++i){
            if(smallestPrimeFactor[i] == i){
                for(int j = i * i; j < limit; j += i){
                    if(smallestPrimeFactor[j] == j){
                        smallestPrimeFactor[j] = i;
                    }
                }
            }
        }
        sieve_computed = true;
    }

    int minOperations(vector<int>& numbers) {
        if(!sieve_computed){
            compute_sieve();
        }
        faster;
        int totalOps = 0;
        int size = numbers.size();

        for(int index = size - 1; index > 0; --index){
            while(numbers[index - 1] > numbers[index]){
                int currentNum = numbers[index - 1];
                if(currentNum == 1){
                    return -1;
                }
                if(smallestPrimeFactor[currentNum] == currentNum){
                    return -1;
                }

                int reducedNum = smallestPrimeFactor[currentNum];
                if(reducedNum > numbers[index]){
                    return -1;
                }
                numbers[index - 1] = reducedNum;
                totalOps++;
            }
        }

        return totalOps;
    }
};
vector<int> Solution::smallestPrimeFactor;
bool Solution::sieve_computed = false;",1427886616
raincoat911,raincoat911,164,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res = 0;
        vector<vector<int>> bkt(26);
        for (int i = 0, j = -1; i < s.size(); i++) {
            int c = s[i] - 'a';
            bkt[c].push_back(i);
            if (bkt[c].size() >= k) {
                j = max(j, bkt[c][bkt[c].size() - k]);
            }
            // cout << j << endl;
            res += j + 1;
        }
        return res;
    }
};",1427832347
raincoat911,raincoat911,164,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur;
        vector<string> res;
        dfs(target, 0, cur, res);
        return res;
    }
    
private:
    void dfs(string& t, int i, string& cur, vector<string>& res) {
        if (i == t.size()) return;
        if (cur.size() == i) {
            cur += 'a';
            res.push_back(cur);
            dfs(t, i, cur, res);
        }
        else if (t[i] != cur[i]) {
            cur[i]++;
            res.push_back(cur);
            dfs(t, i, cur, res);
        }
        else dfs(t, i + 1, cur, res);
    }
};",1427825650
raincoat911,raincoat911,164,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector<vector<int>> adj(s.size());
        int r = -1;
        for (int i = 0; i < parent.size(); i++) {
            int p = parent[i];
            if (p == -1) {
                r = i;
                continue;
            }
            adj[p].push_back(i);
        }
        int i = 2;
        vector<array<int, 2>> arr(s.size());
        int l = s.size();
        string t(2 * l + 3, '#');
        t[0] = '!';
        t.back() = '@';
        dfs(s, r, adj, arr, t, i);
        vector<int> dp(t.size());
        int c = 0;
        r = 0;
        for (i = 2; i < t.size(); i++) {
            int d = r > i ? min(r - i, dp[c * 2 - i]) : 0;
            int lo = i - d, hi = i + d;
            while (t[lo] == t[hi]) {
                lo--;
                hi++;
            }
            if (hi > r) {
                c = i;
                r = hi;
            }
            dp[i] = hi - i;
        }
        vector<bool> res;
        for (int i = 0; i < l; i++) {
            int lo = arr[i][0], hi = arr[i][1];
            int mid = (lo + hi) / 2;
            // cout << dp[mid] << endl;
            res.push_back(dp[mid] > mid - lo);
        }
        return res;
    }
    
private:
    void dfs(string& s, int v, vector<vector<int>>& adj, vector<array<int, 2>>& arr, string& t, int& i) {
        int lo = i;
        for (int w : adj[v]) {
            dfs(s, w, adj, arr, t, i);
        }
        t[i++] = s[v];
        arr[v] = {lo, i++};
    }
};",1427895499
raincoat911,raincoat911,164,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        arr.resize(1e6 + 1);
        int res = 0;
        for (int i = nums.size() - 2; i > -1; i--) {
            int p = nums[i + 1], n = nums[i];
            while (n > p) {
                int d = f(n);
                // cout << i << "" "" << p << "" "" << n  << "" "" << d<< endl;
                if (d == -1) return -1;
                res++;
                n = d;
            }
            nums[i] = n;
        }
        return res;
    }
    
private:
    vector<int> arr;
    
    int f(int n) {
        if (arr[n] != 0) return arr[n];
        for (int j = 2; j * j <= n; j++) {
            if (n % j == 0) {
                return arr[n] = j;
            }
        }
        return arr[n] = -1;
    }
};",1427847902
Amarjargal Ayurzana,neko643,165,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26, 0);
        int n = s.size(), i = 0;
        for(; i < n; i++) {
            cnt[s[i] - 'a']++;
            if(cnt[s[i] - 'a'] >= k) break;
        }
        int l = 0;
        auto check = [&]() -> bool {
            for(int x : cnt) {
                if(x >= k) return true;
            }
            return false;
        };
        int ans = 0;
        for(; i + 1 < n; i++) {
            while(check()) {
                cnt[s[l] - 'a']--;
                l++;
            }
            ans += l;
            cnt[s[i + 1] - 'a']++;
        }
        while(check()) {
            cnt[s[l] - 'a']--;
            l++;
        }
        ans += l;
        return ans;
    }
};",1427832003
Amarjargal Ayurzana,neko643,165,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int i = 0, n = target.size();
        string cur = """";
        vector<string> ans;
        for(int i = 0; i < n; i++) {
            cur += 'a';
            ans.push_back(cur);
            while(cur[i] != target[i]) {
                cur[i]++;
                ans.push_back(cur);
            }
        }
        return ans;
        
    }
};",1427824759
Amarjargal Ayurzana,neko643,165,3603,cpp,"class Solution {
public:
    vector<int> sz, inds;
    vector<vector<int> > G;

    void dfs(int cur, int& curind) {
        for(int x : G[cur]) {
            dfs(x, curind);
            sz[cur] += sz[x];
        }
        inds[cur] = curind++;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        G.resize(n);
        sz.resize(n, 1);
        inds.resize(n, 0);
        for(int i = 1; i < n; i++) {
            G[parent[i]].push_back(i);
        }

        for(int i = 0; i < n; i++) {
            sort(G[i].begin(), G[i].end());
        }
        int ind = 0;
        dfs(0, ind);
        string res(n, 'a');
        for(int i = 0; i < n; i++) {
            res[inds[i]] = s[i];
        }

        const long long MOD = 1e9 + 7, p = 151583;
        vector<long long> preh(n), sufh(n), pw(n, 1);
        long long prehash = 0, sufhash = 0;
        for(int i = 0; i < n; i++) {
            if(i > 0)
                pw[i] = pw[i - 1] * p % MOD;

            prehash = (prehash + pw[i] * res[i]) % MOD;
            sufhash = (sufhash + pw[i] * res[n - 1 - i]) % MOD;

            preh[i] = prehash;
            sufh[n - 1 - i] = sufhash;
        }

        auto compare = [&] (int l, int r) -> bool {
            long long precalc = (preh[r] - (l > 0 ? preh[l - 1] : 0) + MOD) % MOD * pw[n - 1 - r] % MOD;
            long long sufcalc = (sufh[l] - (r < n - 1 ? sufh[r + 1] : 0) + MOD) % MOD * pw[l] % MOD;
            return precalc == sufcalc;
        };

        // cout << res << ""\n"";
        vector<bool> ans(n);
        for(int i = 0; i < n; i++) {
            int l = inds[i] - sz[i] + 1, r = inds[i];
            // cout << l << "" "" << r << ""\n"";
            ans[i] = compare(l, r);
        }

        
        
        return ans;
    }
};",1427904361
Amarjargal Ayurzana,neko643,165,3607,cpp,"class Solution {
public:
    // vector<bool> p;
    // vector<int> primes;
    const long long N = 1e6;
    // void sieve() {
    //     for(long long i = 2; i < N; i++) {
    //         if(!p[i]) {
    //             primes.push_back(i);
    //             for(long long j = i * i; j < N; j += i) {
    //                 p[j] = true;
    //             }
    //         }
    //     }
    // }
    Solution() {
        // p.resize(N, false);
        // sieve();
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size(), last = N, ans = 0;
        for(int i = n - 1; i >= 0; i--) {
            if(nums[i] > last) {
                for(int j = 2; j * j <= nums[i]; j++) {
                    if(nums[i] % j == 0) {
                        nums[i] = j;
                        ans++;
                        break;
                    }
                }
            }
            if(nums[i] > last) return -1;
            
            last = nums[i];
        }
        return ans;
    }
};",1427847994
Ivan_len,Ivan_len,166,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.size();
        for (int i = 0; i < n; i++) {
            vector<int> cnt(26);
            for (int j = i; j < n; j++) {
                cnt[(int)(s[j] - 'a')]++;
                if (cnt[(int)(s[j] - 'a')] >= k) {
                    ans += (n - j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427825931
Ivan_len,Ivan_len,166,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string pre = """";
        int n = target.size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= (int)(target[i] - 'a'); j++) ans.push_back(pre + (char)('a' + j));
            pre += target[i];
        }
        return ans;
    }
};",1427824454
Ivan_len,Ivan_len,166,3603,cpp,"typedef long long ll;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
class Solution {
    class MillerRabin{
    const vector<long long> plist = {2, 325, 9375, 28178, 450775};
    // Multiplication mod n avoiding overflow
    ll RussianMulti(ll x, ll y, ll n) {
        ll ans = 0;
        while (x) {
            if (x & 1) {
                ans = (ans + y) % n;
                x--;
            }
            x /= 2;
            y = (y * 2) % n;
        }
        return ans;
    }

    ll QuickPow(ll base, ll p, ll m) {
        if (p == 0) return 1;
        if (p == 1) return base % m;
        ll tmp = QuickPow(base, p / 2, m);
        tmp = (tmp * tmp) % m;
        if (p & 1) return (tmp * base) % m;
        return tmp;
    }
public:
    bool PrimeTest(ll n) {
        if (n < 3 || n % 2 == 0) return n == 2;
        ll u = n - 1, t = 0;
        while (u % 2 == 0) {
            u /= 2;
            t++;
        }

        for (int i = 0; i < plist.size(); i++) {
            ll a = plist[i], v = QuickPow(a, u, n);
            if (v == 1) continue;
            int s = 0;
            while (s < t) {
                if (v == n - 1) break;
                v = (v * n) % n;
                s++;
            }
            if (s == t) return false;
        }
        return true;
    }

    bool BruteTest(ll n) {
        if (n <= 10) {
            for (ll i = 2; i < n; i++) if (n % i == 0) return false;
            return true;
        }
        for (ll i = 2; i <= (ll)sqrt(n) + 1; i++) if (n % i == 0) return false;
        return true;
    }

    // generates a prime in range [l, r)
    ll Generate(ll l, ll r) {
        while (true) {
            ll t = ((ll)rnd() % (r - l)) + l;
            if (PrimeTest(t)) return t;
        }
    }
};

class RabinKarp{
    // Need M ~ 2kN^2/4 * log(kN^2/4) for error < 1/k worst case
    // N = 1e6, k > 50
    ll p; // About 1e15. Make sure 1e15 * base << ll_max
    int n, b;
    vector<ll> exp, a, reva;

public:
    RabinKarp(string s) {
        b = 256;
        vector<int> S;
        for (auto c : s) S.push_back((int)c);
        init(S);
    }

    RabinKarp(vector<int> S, int base) {
        b = base;
        init(S);
    }

    void init(vector<int> s) {
        MillerRabin T;
        p = T.Generate(1e9, 2e9);
        n = s.size();
        exp.resize(n + 1);
        a.resize(n + 1);
        reva.resize(n + 1);
        exp[0] = 1;
        for (int i = 1; i <= n; i++) exp[i] = (exp[i - 1] * b) % p;
        for (int i = 1; i <= n; i++) a[i] = (a[i - 1] * b + s[i - 1]) % p;
        for (int i = n - 1; i >= 0; i--) reva[i] = (reva[i + 1] * b + s[i]) % p;
    }

    // 0-indexed, exclusive right endpoint
    ll hash(int l, int r) {
        ll ret = (a[r] - a[l] * exp[r - l]) % p;
        return (ret + p) % p;
    }

    // 0-indexed, exclusive right endpoint
    ll revhash(int l, int r) {
        // return 0;
        // cout << l << ' ' << r << ' ' << exp.size() << endl;
        // cout << reva[r] << ' ' << reva[l] << ' ' << exp[r - l] << ' ' << p << endl;
        ll ret = (reva[l] - reva[r] * exp[r - l]) % p;
        return (ret + p) % p;
    }

    vector<int> find_occ(string s) {
        int N = s.size();
        ll wt = 0;
        for (int i = 0; i < N; i++) wt = (wt * b + (int)s[i]) % p;
        vector<int> ans;
        for (int i = 0; i <= n - N; i++) {
            if (hash(i, i + N) == wt) ans.push_back(i);
        }
        return ans;
    }
};
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> sz(n), start(n);
        vector<vector<int>> c(n);
        vector<bool> ans(n, false);
        vector<int> S;
        for (int i = 1; i < n; i++) c[parent[i]].push_back(i);
        auto dfs = [&](auto&& self, int u) -> void {
            sz[u] = 1;
            start[u] = S.size();
            for (auto v : c[u]) {
                self(self, v);
                sz[u] += sz[v];
            }
            S.push_back((int)(s[u] - 'a'));
        };
        dfs(dfs, 0);
        RabinKarp T(S, 26);
        for (int i = 0; i < n; i++) {
            int st = start[i];
            int len = sz[i];
            assert(st + len <= n);
            if (len & 1) {
                if (T.hash(st, st + len / 2) == T.revhash(st + len / 2 + 1, len + st)) ans[i] = true;
            }
            else {
                if (T.hash(st, st + len / 2) == T.revhash(st + len / 2, len + st)) ans[i] = true;
            }
        }
        return ans;
    }
};",1427887475
Ivan_len,Ivan_len,166,3607,cpp,"class Solution {
    vector<int> fact;
    void init(int n) {
        if (fact.size() >= 1000000) return;
        fact.resize(n + 1);
        iota(fact.begin(), fact.end(), 0);
        for (int i = 2; i <= n; i++) {
            if (fact[i] != i) continue;
            for (int j = i; j <= n; j+=i) {
                fact[j] = i;
            }
        }
    }
public:
    int minOperations(vector<int>& nums) {
        // init(1e6 + 5);
        int n = nums.size();
        vector<pair<int, int>> pos(n);
        // for (int i = 0; i < n; i++) {
        //     pos[i].second = nums[i];
        //     int tmp = nums[i];
        //     while (fact[tmp] != tmp) tmp /= fact[tmp];
        //     pos[i].first = tmp;
        // }
        for (int i = 0; i < n; i++) {
            pos[i].second = nums[i];
            pos[i].first = nums[i];
            for (int j = 2; j <= sqrt(nums[i]) + 1; j++) {
                if (j < nums[i] && nums[i] % j == 0) {
                    pos[i].first = j;
                    break;
                }
            }
        }
        vector<vector<int>> dp(n, vector<int>(2, 1 << 20));
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                dp[i][1] = 0;
                if (pos[i].first != nums[i]) dp[i][0] = 1;
                // cout << i << ' ' << pos[i].first << ' ' << pos[i].second << ' ' << dp[i][0] << ' ' << dp[i][1] << '\n';
                continue;
            }
            if (pos[i - 1].first != nums[i - 1] && pos[i].second >= pos[i - 1].first) dp[i][1] = min(dp[i][1], dp[i - 1][0]);
            if (pos[i].second >= pos[i - 1].second) dp[i][1] = min(dp[i][1], dp[i - 1][1]);
            if (pos[i].first != nums[i]) {
                if (pos[i - 1].first != nums[i - 1] && pos[i].first >= pos[i - 1].first) dp[i][0] = min(dp[i][0], dp[i - 1][0]) + 1;
                if (pos[i].first >= pos[i - 1].second) dp[i][0] = min(dp[i][0], dp[i - 1][1]) + 1;
            }
            // cout << i << ' ' << pos[i].first << ' ' << pos[i].second << ' ' << dp[i][0] << ' ' << dp[i][1] << '\n';
        }
        int ans = min(dp[n - 1][0], dp[n - 1][1]);
        if (ans == 1 << 20) return -1;
        return ans;
    }
};",1427859326
tanakat01,tanakat01,168,3502,python3,"from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c2is = defaultdict(list)
        ans = 0
        for i, c in enumerate(s):
            c2is[c].append(i)
            max_k = -1
            for c1, i_s in c2is.items():
                if len(i_s) >= k:
                    j = i_s[-k]
                    max_k = max(max_k, j)
            ans += max_k + 1
        return ans",1427834590
tanakat01,tanakat01,168,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        for i, c in enumerate(target):
            if i == 0:
                ans.append('a')
            else:
                ans.append(ans[-1] + 'a')
            while ans[-1][-1] != c:
                ans.append(ans[-1][:-1] + chr(ord(ans[-1][-1]) + 1))
        return ans                ",1427827373
tanakat01,tanakat01,168,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        mino = [-1] * n
        maxo = [-1] * n
        children = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                children[p].append(i)
        ps = [None] * n
        cnt = [0]
        def dfs(i, p):
            mino[i] = cnt[0]
            for j in children[i]:
                dfs(j, i)
            ps[cnt[0]] = s[i]
            cnt[0] += 1
            maxo[i] = cnt[0]
        dfs(0, -1)
        ans = [False] * n
        rps = ps[::-1]
        Z = 31
        MOD = 1000000007
        def makepre(s):
            pre = [0]
            for c in s:
                pre.append((pre[-1] * Z + ord(c)) % MOD)
            return pre                
        pre, rpre = makepre(ps), makepre(rps)
        #print(f'pre={pre}, rpre={rpre}')
        for i in range(n):
            l = maxo[i] - mino[i]
            #s1 = ps[mino[i]:maxo[i]]
            h1 = (pre[maxo[i]] + MOD - pre[mino[i]] * pow(Z, l, MOD) % MOD) % MOD
            h2 = (rpre[n - mino[i]] + MOD - rpre[n - maxo[i]] * pow(Z, l, MOD)) % MOD
            #s2 = rps[n - maxo[i]:n - mino[i]]
            if h1 == h2:
                ans[i] = True
        return ans                ",1427913230
tanakat01,tanakat01,168,3607,python3,"from functools import lru_cache
from math import sqrt
from collections import defaultdict
@lru_cache(None)
def factor(n):
    for i in range(2, int(sqrt(n)) + 1):
        if n % i == 0:
            s = factor(n // i)
            for q in s:
                s.add(q * i)
            return s
    return set([1, n])
@lru_cache(None)    
def sub(n):
    for i in range(2, int(sqrt(n)) + 1):
        if n % i == 0:
            return i
    return -1
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        dp = {1: 0}
        for x in nums:
            newdp = {}
            sx = sub(x)
            for x1, c in [(x, 0), (sx, 1)]:
                if x1 < 1:
                    continue
                for x2, val in dp.items():
                    if x2 >= 1:
                        if x1 >= x2:
                            oldv = newdp.get(x1, float('inf'))
                            newv = c + val
                            if newv < oldv:
                                newdp[x1] = newv
            dp = newdp                                
            #print(f'dp={dp}')
        if len(dp) == 0:
            return -1
        return min(dp.values())

",1427882207
Navneet Singh,snavneet561,171,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length(), res=0;
        for(int i=0; i<n; i++){
            vector<int> mp(26);
            for(int j=i; j<n; j++){
                mp[s[j]-'a']++;
                if(mp[s[j]-'a'] >= k){
                    res+=n-j;
                    break;
                }
            }   
        }
        return res;
    }
};",1427831219
Navneet Singh,snavneet561,171,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        res.push_back(""a"");
        while(res.back() != target){
            string cur=res.back();
            if(cur.back() == target[cur.length()-1]){
                cur+=""a"";
                res.push_back(cur);
            }else{
                char ch=cur.back();
                if(ch=='z')ch=='a';
                else ch++;
                cur.back()=ch;
                res.push_back(cur);
            }
        }
        return res;
    }
};",1427826194
Navneet Singh,snavneet561,171,3603,cpp,"struct Manacher{
      vector<int> p;
      string t;
      Manacher(const string& s) {
            for(char c : s) t += string(""#"") + c; 
            t += ""#"";
            int n = (int) t.length(), c = 0, r = 0;
            p.resize(n);
            for(int i = 0; i < n; i++){
                  int mirr = c + c - i;
                  if(i < r) p[i] = min(p[mirr], r - i + 1);
                  while(i + p[i] < n && i - p[i] >= 0 && t[i+p[i]] == t[i-p[i]]) p[i]++;
                  if(i + p[i] - 1 > r) c = i, r = i + p[i] - 1;
            }
            for(int i = 0; i < n; i++) p[i]--;
      }
      int maxEven(int i) { return p[2*i + 2]; }
      int maxOdd(int i) { return p[2*i+1]; }
      bool pal(int l, int r){
            int c = (l + r) / 2, len = r - l + 1;
            if(len % 2) return maxOdd(c) >= len;
            else return maxEven(c) >= len;
      }
};

class Solution {
public:
    int dfs(int node, int par, string &str, vector<int> edges[], string &s, vector<int> &sub, vector<int> &v, int idx){
        vector<int> adjs;
        sub[node]=1;
        for(auto adj: edges[node]){
            if(adj!=par)adjs.push_back(adj);
        }
        sort(adjs.begin(), adjs.end());
        for(int x: adjs){
            sub[node] += dfs(x, node, str, edges, s, sub, v, idx+1);
        }
        str+=s[node];
        v[node]=str.size()-1;
        return sub[node];
    }
    
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        string str="""";
        int n=parent.size();
        vector<int> edges[n];
        for(int i=1; i<n; i++){
            edges[i].push_back(parent[i]);
            edges[parent[i]].push_back(i);
        }
        vector<int> sub(n), v(n);
        dfs(0, -1, str, edges, s, sub, v, 0);
        Manacher mc(str);
        vector<bool> res(n);

        for(int i=0; i<n; i++){
            int l=v[i]-sub[i]+1, r=v[i];
            res[i]=mc.pal(l, r);
        }
        
        return res;
    }
};",1427905299
Navneet Singh,snavneet561,171,3607,cpp,"class Solution {
public:
    typedef long long ll;
  
    
    int minOperations(vector<int>& nums) {
        ll MAX=1e6+6;
        bool prime[MAX];
        ll spf[MAX];

        fill(prime, prime+MAX, true);
        for(int i=1; i<MAX; i++){
            spf[i] = i;
        }
        prime[0] = prime[1] = false;
        for(int i=2; i*i<MAX; i++){
            if(prime[i]){
                for(int j=i*i; j<MAX; j+=i){
                    if(prime[j]){
                        spf[j] = i;
                        prime[j] = false;
                    }
                }
            }
        }
        ll res=0;
        for(int i=nums.size()-2; i>=0; i--){
            if(nums[i]<=nums[i+1])continue;
            int cur=nums[i];
            if(cur==spf[cur])return -1;
            while(cur!=1 && cur!=spf[cur] && cur>nums[i+1]){
                int val=cur/spf[cur];
                cur/=val;
                res++;
            }
            nums[i]=cur;
        }
        for(int i=0; i<nums.size()-1; i++){
            if(nums[i]>nums[i+1])return -1;
        }
        return res;
    }
};",1427851737
abhishek vaish,abhishekvaish,172,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        w = [0]*26
        n = len(s)
        l = 0
        res = 0
        for r in range(n):
            w[ord(s[r]) - ord('a') ] += 1
            valid = False
            while max(w) >= k:
                valid = True
                w[ord(s[l]) - ord('a') ] -= 1
                l += 1
            
            if valid:
                l -= 1
                w[ord(s[l]) - ord('a') ] += 1
                res += l+1
        return res 
            
                ",1427840327
abhishek vaish,abhishekvaish,172,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        curr = ''
        res = []
        while curr != target:
            curr += 'a'
            res.append(curr)
            while curr[-1] != target[len(curr)-1]:
                curr = curr[:-1] +  chr(ord('a') + (ord(curr[-1]) - ord('a')  + 1) % 26)
                res.append(curr)
        
        return res ",1427826328
abhishek vaish,abhishekvaish,172,3603,python3,"p = 31
MOD = 10**9+9
power = [1] * 100001
for i in range(1,100001):
    power[i] = (power[i-1] * p) % MOD

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        adj = [ [] for i in range(n) ]
        for i in range(n):
            if parent[i] != -1:
                adj[parent[i]].append(i)
        
        
        def dfs(u):
            ch = ord(s[u])-ord('a')+1
            fh,rh = 0, ch
            rev = []
            l = 0
            for v in adj[u]:
                fv,rv,lv = dfs(v)
                fh = (fh + (power[l] * fv)%MOD)%MOD
                l += lv
                rev.append((rv,lv))
            fh = (fh + (power[l] * ch) % MOD) % MOD
            l += 1
            
            lr = 1
            for rv,lv in reversed(rev):
                rh = ( rh + (power[lr] * rv)%MOD ) % MOD
                lr += lv
            if fh == rh:
                res[u] = True
            return fh,rh,l
        
        res = [False] *  n
        dfs(0)
        return res 
        
                
            
                
                
                
                
                
            
        ",1427905732
abhishek vaish,abhishekvaish,172,3607,python3,"from math import ceil
def divisor(n):
    i = 2
    m = ceil(n**0.5)
    while i <= m:
        if n % i == 0:
            return i
        i += 1
    return n

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        valid = True
        res = 0
        for i in reversed(range(n-1)):
            if nums[i] <= nums[i+1]: continue            
            x = divisor(nums[i])
            if x > nums[i+1]: return -1 
            nums[i] = x
            res += 1
        return res 
        
        
            ",1427863805
ohnoooo,ohnoooo,173,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int cnt[26]{};
        int more = 0;
        int ans = 0;
        for(int l=0, r=0; r<n; r++) {
            more += ++cnt[s[r] - 'a'] == k;
            while(more) {
                more -= cnt[s[l++] - 'a']-- == k;
            }
            ans += l;
        }
        return ans;
    }
};",1427829998
ohnoooo,ohnoooo,173,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s = """";
        for(char b : target) {
            s += 'a';
            ans.push_back(s);
            while(s.back() < b) {
                s.back()++;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427824810
ohnoooo,ohnoooo,173,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for(int i=1; i<n; i++)
            g[parent[i]].push_back(i);
        
        vector<pair<int,int>> span(n);

        string t = """";
        auto dfs = [&](auto&& dfs, int x) -> void {
            int st = t.size();
            for(auto y : g[x]) {
                dfs(dfs, y);
            }
            t += s[x];
            span[x] = {st, t.size() - st};
        };
        dfs(dfs, 0);

        string tt = """";
        int m = t.size();
        tt.reserve(2 * m + 1);
        tt += '#';
        for(int i = 0; i < m; i++) {
            tt += t[i];
            tt += '#';
        }

        vector<int> p(tt.size(), 0);
        int c = 0, r = 0;
        for(int i = 0; i < tt.size(); i++) {
            int mirror = 2 * c - i;
            if(i < r)
                p[i] = min(r - i, p[mirror]);
            int a = i + (1 + p[i]);
            int b = i - (1 + p[i]);
            while(a < tt.size() && b >= 0 && tt[a] == tt[b]) {
                p[i]++;
                a++;
                b--;
            }
            if(i + p[i] > r) {
                c = i;
                r = i + p[i];
            }
        }

        vector<bool> ans(n);
        for(int x = 0; x < n; x++) {
            auto [l, len] = span[x];
            int r = l + len - 1;

            l = 2 * l + 1;
            r = 2 * r + 1;

            int c = (l + r) / 2;
            int rad = r - c;
            
            ans[x] = p[c] >= rad;
        }
        
        return ans;
    }
};",1427897264
ohnoooo,ohnoooo,173,3607,cpp,"const int MAXN = 1e6 + 10;
int factor[MAXN];

auto init = [](){
    memset(factor, -1, sizeof(factor));
    factor[1] = 1;
    for(int i=2; i<MAXN; i++) {
        if(factor[i] != -1) continue;
        for(int j=i; j<MAXN; j+=i)
            if(factor[j] == -1)
                factor[j] = i;
    }
    return 0;
}();

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int m = *max_element(nums.begin(), nums.end());
        int cnt = 0;
        for(int i=n-1, mx = INT_MAX; i>=0; i--) {
            int x = nums[i];
            if(x <= mx) {
                mx = x;
                continue;
            }
            x = factor[x];
            if(x > mx) return -1;
            mx = x;
            cnt++;
        }
        return cnt;
    }
};",1427854401
virinci,virinci,174,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        for i in range(n):
            f = [0] * 26
            for j in range(i, -1, -1):
                z = ord(s[j]) - ord('a')
                f[z] += 1
                if f[z] >= k:
                    ans += j + 1
                    break
        return ans",1427830239
virinci,virinci,174,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        n = len(target)
        ans = []
        for i in range(n):
            ans.extend(target[:i] + chr(j) for j in range(ord('a'), ord(target[i]) + 1))
        return ans",1427826661
virinci,virinci,174,3603,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...) 42
#endif

class Solution {
public:
	vector<bool> findAnswer(vector<int>& parent, string s) {
		int n = ssize(parent);
		vector<vector<int>> adj(n);
		for (int i = 0; i < n; ++i) {
			if (parent[i] >= 0)
				adj[parent[i]].emplace_back(i);
		}

		for (auto& a : adj)
			ranges::sort(a);

		dbg(adj);
		vector<int> index(n, -1), node(n, -1), size(n, -1);
		int tracker = 0;

		auto dfs = [&](auto&& self, int v) -> void {
			int count = 0;
			for (auto w : adj[v]) {
				self(self, w);
				count += size[index[w]];
			}
			index[v] = tracker;
			node[tracker] = v;
			size[tracker] = count + 1;
			tracker++;
		};

		dfs(dfs, 0);
		dbg(index), dbg(node), dbg(size);

		constexpr int N_MAX = 1e5 + 10, M = 1e9 + 9;
		vector<int> p1_pow(N_MAX, 1), p2_pow(N_MAX, 1), p1_inv(N_MAX, 1), p2_inv(N_MAX, 1);

		for (int i = 1; i < N_MAX; ++i) {
			constexpr int p1 = 29, p2 = 31, inv1 = 517241384, inv2 = 838709685;
			p1_pow[i] = int(1LL * p1_pow[i - 1] * p1 % M);
			p2_pow[i] = int(1LL * p2_pow[i - 1] * p2 % M);
			p1_inv[i] = int(1LL * p1_inv[i - 1] * inv1 % M);
			p2_inv[i] = int(1LL * p2_inv[i - 1] * inv2 % M);
		}

		using i64 = long long;

		auto substr_hash = [&p1_inv, &p2_inv](std::span<i64> prefix_hashes, int i, int j) {
			auto hi = prefix_hashes[i], hj = prefix_hashes[j + 1];
			auto h1 = ((hj / M) - (hi / M) + M) % M * p1_inv[i] % M;
			auto h2 = ((hj % M) - (hi % M) + M) % M * p2_inv[i] % M;
			return h1 * M + h2;
		};

		vector<i64> prefix_hashes(n + 1, 0), prefix_hashes_rev(n + 1, 0);
		auto s1 = s;
		for (int i = 0; i < n; ++i) {
			s[index[i]] = s1[i];
		}
		dbg(s);

		{
			i64 h1 = 0, h2 = 0;
			for (int i = 0; i < n; ++i) {
				h1 = (1LL * (s[i] - 'a' + 1) * p1_pow[i] + h1) % M;
				h2 = (1LL * (s[i] - 'a' + 1) * p2_pow[i] + h2) % M;
				auto h = h1 * M + h2;
				prefix_hashes[i + 1] = h;
			}
			h1 = 0, h2 = 0;
			for (int i = 0; i < n; ++i) {
				h1 = (1LL * (s[n - 1 - i] - 'a' + 1) * p1_pow[i] + h1) % M;
				h2 = (1LL * (s[n - 1 - i] - 'a' + 1) * p2_pow[i] + h2) % M;
				auto h = h1 * M + h2;
				prefix_hashes_rev[i + 1] = h;
			}
		}

		vector<bool> answer(n);
		for (int i = 0; i < n; ++i) {
			auto h = substr_hash(prefix_hashes, index[i] - size[index[i]] + 1, index[i]);
			auto hr = substr_hash(prefix_hashes_rev, n - 1 - index[i], n - 1 - (index[i] - size[index[i]] + 1));
			answer[i] = h == hr;
		}

		dbg(prefix_hashes);
		return answer;
	}
};",1427888807
virinci,virinci,174,3607,cpp,"std::vector<int> minp, primes;
void sieve(int n) {
	minp.assign(n + 1, 0);
	primes.clear();

	for (int i = 2; i <= n; i++) {
		if (minp[i] == 0) {
			minp[i] = i;
			primes.push_back(i);
		}

		for (auto p : primes) {
			if (i * p > n) break;
			minp[i * p] = p;
			if (p == minp[i]) break;
		}
	}
}

class Solution {
public:
    Solution() {
        if (minp.empty())
            sieve(int(1e6) + 10);
    }
    int minOperations(vector<int>& nums) {
        int n = ssize(nums);
        int limit = 1e8, ops = 0;
        for (int i = n - 1; i >= 0; --i) {
            if (nums[i] <= limit) {
                limit = nums[i];
                continue;
            }
            nums[i] = minp[nums[i]];
            if (nums[i] > limit) return -1;
            nums[i] = limit = minp[nums[i]];
            ops++;
        }
        return ops;
    }
};",1427846728
Di Kang,zephyrr,176,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        d = defaultdict(int)

        def isvalid(d):
            for ch in d:
                if d[ch] >= k:
                    return True
            return False
        
        l = 0
        r = -1
        while l < len(s):
            while not isvalid(d):
                r += 1
                if r >= len(s):
                    break
                d[s[r]] += 1
            if isvalid(d):
                ans += len(s) - r
                d[s[l]] -= 1
                l += 1
            else:
                l += 1
        return ans

",1427835306
Di Kang,zephyrr,176,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        while ans==[] or ans[-1] != target:
            if ans == []:
                ans.append('a')
                continue
            tmp = ans[-1]
            if tmp[-1] == target[len(tmp)-1]:
                tmp += 'a'
                ans.append(tmp)
            else:
                ntmp = tmp[:-1] + chr(ord(tmp[-1]) + 1)
                ans.append(ntmp)
        return ans
        ",1427825580
Di Kang,zephyrr,176,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        arr = [[0,0] for _ in range(n)]
        g = defaultdict(list)
        
        for i in range(n):
            g[parent[i]].append(i)


        def dfs(node, startind):
            ss = ''
            for nxt in g[node]:
                ss += dfs(nxt, startind + len(ss))
            ss += s[node]
            arr[node] = [startind, len(ss)]
            #print(node, arr[node], ss)
            return ss
        
        ss = dfs(0,0)

        def getp(ss):
            snew = '&'.join(ss)
            snew = '&'+ snew + '&'
            lenmax = 0
            maxloc = -1 
            R = -1
            C = -1
            arr = [0 for x in range(len(snew))]
            cur = 0
            for cur in range(len(snew)):
                if cur > R:
                    C = cur
                    R = cur
                    arr[cur]=1
                    while cur+arr[cur]<len(snew) and cur-arr[cur]>= 0 and snew[cur-arr[cur]]==snew[cur+arr[cur]]:
                        arr[cur] +=1
                        R +=1
                elif cur <= R:
                    sym = 2*C-cur
                    if arr[sym]< R - cur +1:
                        arr[cur]=arr[sym]
                    elif arr[sym] > R - cur +1:
                        arr[cur] = R - cur +1
                    elif arr[sym] == R - cur +1:                    
                        arr[cur] =  R - cur +1
                        C = cur
                        while cur+arr[cur]< len(snew) and cur-arr[cur]>= 0 and snew[cur-arr[cur]]==snew[cur+arr[cur]]:
                            arr[cur] +=1
                            R +=1           
                if arr[cur]>lenmax:
                    lenmax = arr[cur]
                    maxloc = cur
     
            return arr
        
        arr1 = getp(ss)
        ans = []
        for i in range(n):
            st, ll = arr[i]
            ed = st + ll - 1
            mid = st + ed + 1
            if arr1[mid] >= mid - 2*st:
                ans.append(True)
            else:
                ans.append(False) 

        return ans




        ",1427906186
Di Kang,zephyrr,176,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ct = 0
        arr = [1 for n in range(1002)]
        prime = []
        for i in range(1002):
            if i == 0 or i == 1 or arr[i] == 0:
                continue
            prime.append(i)
            for j in range(2*i,1002,i):
                arr[j] = 0
        #print(prime)
        cur = nums[-1]
        for n in nums[::-1]:
            if n <= cur:
                cur = n
            else:
                tmp = n
                while tmp > cur:
                    pp = tmp
                    for p in prime:
                        if tmp % p == 0:
                            pp = p
                            break
                    if tmp == pp:
                        return -1
                    tmp = pp
                    ct += 1
                cur = tmp
        return ct
                
            

        
        ",1427853708
D V Sushmanth Reddy,user2937Vz,177,3502,python3,"class Solution:
    def numberOfSubstrings(self, a: str, k: int) -> int:
        
        n = len(a)
        ans = 0
        for i in range(n):
            toadd , count = 0 , [0] * (26)
            for j in range(i , n):
                count[ord(a[j]) - 97] += 1
                if(count[ord(a[j]) - 97] >= k):
                    toadd = 1
                
                ans += toadd
        
        return ans
        ",1427837945
D V Sushmanth Reddy,user2937Vz,177,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        
        ans , cur = [] , """"
        for x in target:
            for ch in range(26):
                ans.append(cur + chr(97 + ch))
                if(chr(97 + ch) == x):break
            
            cur += x
        
        return ans",1427832650
D V Sushmanth Reddy,user2937Vz,177,3603,python3,"mod1 , mod2 = (10 ** 9) + 7 , (10 ** 9) + 9
p1 , p2 = 37 , 31
class Solution:
    def findAnswer(self, parent: List[int], a: str) -> List[bool]:
        n = len(parent)
        fhash , rhash = [None for i in range(n)] , [None for i in range(n)]
        def dfs(p , store_hash , rev):
            s , hashval1 , hashval2 = 0 , 0 , 0
            if(rev):
                hashval1 += (ord(a[p]) - 97 + 1) * pow(p1 , s , mod1)
                hashval2 += (ord(a[p]) - 97 + 1) * pow(p2 , s , mod2)
                hashval1 , hashval2 = hashval1 % mod1 , hashval2 % mod2
                s += 1
            
            if(rev):
                nxt = child[p][::-1]
            else:
                nxt = child[p]
            for i in nxt:
                h1 , h2 , c = dfs(i , store_hash , rev)
                hashval1 += (h1 * pow(p1 , s , mod1))
                hashval2 += (h2 * pow(p2 , s , mod2))
                hashval1 , hashval2 = hashval1 % mod1 , hashval2 % mod2
                s += c
            
            if(not rev):
                hashval1 += (ord(a[p]) - 97 + 1) * pow(p1 , s , mod1)
                hashval2 += (ord(a[p]) - 97 + 1) * pow(p2 , s , mod2)
                hashval1 , hashval2 = hashval1 % mod1 , hashval2 % mod2
                s += 1
                
            store_hash[p] = [hashval1 , hashval2]
            return [hashval1 , hashval2 , s]        
            
            
        child = [[] for i in range(n + 1)]
        for i in range(1 , n):
            child[parent[i]].append(i)
        
        dfs(0 , fhash , False)
        dfs(0 , rhash , True)
        
        ans = [False for i in range(n)]
        for i in range(n):
            if(fhash[i] == rhash[i]):
                ans[i] = True
        
        return ans",1427906591
D V Sushmanth Reddy,user2937Vz,177,3607,python3,"sz = (10 ** 6) + 1
div = [-1 for i in range(sz)]
div[1] = 1
for i in range(1 , sz + 1):
    for j in range(i + i , sz , i):
        div[j] = max(div[j] , i)
        
class Solution:
    def minOperations(self, a: List[int]) -> int:
        
        n = len(a)
        
        dp = [[0 , 0]]
        for i in range(n):
            points , x , score = [] , a[i] , 0
            while(True):
                points.append([x , score])
                if(div[x] == 1):break
                x //= div[x]
                score += 1
            
            points.sort()
            ndp , best = [] , float('inf')
            dp.sort()
            j = 0
            for [p , score] in points:
                while(j < len(dp) and dp[j][0] <= p):
                    best = min(best , dp[j][1])
                    j += 1
                
                ndp.append([p , best + score])
            
            dp = ndp
        
        ans = float('inf')
        for [p , best] in dp:
            ans = min(ans , best)
        
        if(ans == float('inf')):return -1
        return ans
            
            
                ",1427857108
cro_poder,cro_poder,178,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> hash(26, 0); 
            int flag = 0; 
            for (int j = i; j < n; ++j) {
                hash[s[j] - 'a']++; 
 
                if (hash[s[j] - 'a'] == k) {
                    flag = 1;
                }
                if (flag) {
                    ans++;
                }
            }
        }

        return ans;
    }
};
",1427828385
cro_poder,cro_poder,178,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> ans;
        string s = """";  

        for (char ch : t) {
            if (s.empty()) { 
                s = ""a"";
                ans.push_back(s);
            }
            
            while (s.back() != ch) {
                if (s.back() == 'z') { 
                    s.back() = 'a';
                } else { 
                    s.back()++;
                }
                ans.push_back(s);
            }
            s.push_back('a');
            ans.push_back(s);
        }
        if(ans.size())ans.pop_back();
        return ans;
    }
};
",1427825231
cro_poder,cro_poder,178,3603,cpp,"int a = []()->int{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    return 0;
}();

typedef long long ll;

class Solution2 {
public:
    const int MOD = 1e9 + 7; 
    const int P = 31;          
    
    vector<ll> prefixHash, suffixHash, power;
     
    void preprocess(const string& s) {
        int n = s.length();
        prefixHash.resize(n);
        suffixHash.resize(n);
        power.resize(n);
        
        power[0] = 1;
        for (int i = 1; i < n; ++i) {
            power[i] = (power[i - 1] * P) % MOD;   
        }
         
        prefixHash[0] = (s[0] - 'a') * power[0] % MOD;  
        for (int i = 1; i < n; ++i) {
            prefixHash[i] = (prefixHash[i - 1] + (s[i] - 'a') * power[i] % MOD) % MOD;
        }
         
        suffixHash[n - 1] = (s[n - 1] - 'a') * power[0] % MOD;  
        for (int i = n - 2; i >= 0; --i) {
            suffixHash[i] = (suffixHash[i + 1] + (s[i] - 'a') * power[n - 1 - i] % MOD) % MOD;
        }
    }
     
    ll getPrefixHash(int l, int r) { 
        ll hashValue = prefixHash[r];
        if (l > 0) {
            hashValue = (hashValue - prefixHash[l - 1] + MOD) % MOD;
        }
        return (hashValue * power[power.size() - 1 - r]) % MOD;
    }
     
    ll getSuffixHash(int l, int r, int n) {
        ll hashValue = suffixHash[l];
        if (r < n - 1) {
            hashValue = (hashValue - suffixHash[r + 1] + MOD) % MOD;
        }
        return (hashValue * power[power.size() - 1 - (n - 1 - l)]) % MOD;
    }
     
    bool isPalindrome(const string& s, int l, int r) {
        int n = s.length();
        int len = r - l + 1;
        if (len == 1) return true;  
        ll leftHash = getPrefixHash(l, r);
        ll rightHash = getSuffixHash(l, r, n);
        
        return leftHash == rightHash;
    }
};
class Solution {
public: 
    string dfsStr;
     
    vector<int> startPos;
     
    vector<int> subtreeSize;
     
    void dfs(int node, const vector<vector<int>>& adj, const string& s) {
        for (int child : adj[node]) {
            dfs(child, adj, s);
        }
        startPos[node] = dfsStr.size();
        dfsStr += s[node]; 
    }
    int dfs2(int node, const vector<vector<int>>& adj) {
        int v = 0;
        for (int child : adj[node]) {
            v+=dfs2(child, adj);
        }
       return subtreeSize[node] = v+1;
    }
    // bool isPalindrome(int end, int len) {
    //     int start = end - len + 1;
    //     if(start==end)return true;
    //     while (start < end) {
    //         if (dfsStr[start] != dfsStr[end]) {
    //             return false;
    //         }
    //         start++;
    //         end--;
    //     }
    //     return true;
    // }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        startPos.resize(n, 0);
        subtreeSize.resize(n, 0);

        dfsStr.clear();
        dfs(0, adj, s);
        dfs2(0,adj);
        // cout<<dfsStr<<endl;
        // for(auto&it:startPos)cout<<it<<endl;
        // for(auto&it:subtreeSize)cout<<it<<endl;
        Solution2 sol;
        sol.preprocess(dfsStr);
        vector<bool> answer(n, false);
        for (int i = 0; i < n; ++i) {
            int end = startPos[i];
            int len = subtreeSize[i];
            int start = end - len + 1;
            answer[i] = sol.isPalindrome(dfsStr,start, end);
        }
        
        return answer;
    }
};
",1427898541
cro_poder,cro_poder,178,3607,cpp,"class Solution {
public:
    int gpd(int n){
        for(int j=2;j<=sqrt(n);j++){
            if(n%j==0)return j;
        }
        return -1;
    }
    int minOperations(vector<int>& nums) {
        int ans=  0;
        for(int i=nums.size()-2;i>=0;i--){
            up:
            if(nums[i]<=nums[i+1])continue;
            if(nums[i]<4){
               return -1; 
            }
            int x = gpd(nums[i]);
            ans++;
            if(x==-1)return -1;
            nums[i] = x;
            goto up;
        }
        return ans;
    }
};",1427872051
Rishabh Kumrawat,rishabhk02,179,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length(), res = 0;
        for(int i=0; i<n; i++){
            int freq[] = new int[26];
            int idx = -1;
            for(int j=i; j<n; j++){
                freq[s.charAt(j)-'a']++;
                if(freq[s.charAt(j)-'a']>=k){
                    idx = j;
                    break;
                }
            }
            if(idx!=-1){
                res+=(n-idx);
            }
        }
        return res;
    }
}",1427847328
Rishabh Kumrawat,rishabhk02,179,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        int n = target.length();
        List<String> res = new ArrayList<>();
        StringBuilder cur = new StringBuilder();
        for(int i=0; i<n; i++){
            char c = target.charAt(i);
            cur.append(c);
            for(char j='a'; j<=c; j++){
                cur.setCharAt(i,j);
                res.add(cur.toString());
            }
            cur.setCharAt(i,c);
        }
        return res;
    }
}",1427836666
Rishabh Kumrawat,rishabhk02,179,3603,java,"class Solution {
    long[] arr1;
    long[] arr2;
    long base = 31;  // A prime base for the rolling hash
    long mod = (long)(1e9 + 7); // A large prime modulus for the hash
    long[] basePowers; // Precomputed powers of base to handle length factors

    public boolean[] findAnswer(int[] par, String s) {
        int n = par.length;
        ArrayList<ArrayList<Integer>> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            list.get(par[i]).add(i);
        }

        arr1 = new long[n]; // hash results for pre-order
        arr2 = new long[n]; // hash results for post-order
        basePowers = new long[n + 1]; // Precompute base powers up to n
        precomputeBasePowers(n);

        helper1(0, list, s, new int[1]); // Track the length in helper1
        helper2(0, list, s, new int[1]); // Track the length in helper2

        boolean[] result = new boolean[n];
        for (int i = 0; i < n; i++) {
            result[i] = (arr1[i] == arr2[i]); // Compare hash values
        }
        return result;
    }

    // Precompute powers of the base
    private void precomputeBasePowers(int n) {
        basePowers[0] = 1;
        for (int i = 1; i <= n; i++) {
            basePowers[i] = (basePowers[i - 1] * base) % mod;
        }
    }

    // Pre-order traversal hashing with length tracking
    long helper1(int node, ArrayList<ArrayList<Integer>> adj, String s, int[] length) {
        long hash = 0;
        int totalLength = 0;
        for (int child : adj.get(node)) {
            int[] childLength = new int[1];
            long childHash = helper1(child, adj, s, childLength);
            hash = (hash * basePowers[childLength[0]] + childHash) % mod; // Use child length for correct base factor
            totalLength += childLength[0];
        }
        totalLength += 1; // Include current node's character
        hash = (hash * base + s.charAt(node)) % mod; // Add current node char
        arr1[node] = hash;
        length[0] = totalLength; // Pass the total length upwards
        return hash;
    }

    // Post-order traversal hashing with length tracking
    long helper2(int node, ArrayList<ArrayList<Integer>> adj, String s, int[] length) {
        long hash = s.charAt(node); // Start with the current node char
        int totalLength = 1;
        for (int i = adj.get(node).size() - 1; i >= 0; i--) {
            int[] childLength = new int[1];
            long childHash = helper2(adj.get(node).get(i), adj, s, childLength);
            hash = (hash * basePowers[childLength[0]] + childHash) % mod; // Use child length for correct base factor
            totalLength += childLength[0];
        }
        arr2[node] = hash;
        length[0] = totalLength; // Pass the total length upwards
        return hash;
    }
}
",1427899100
Rishabh Kumrawat,rishabhk02,179,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int res = 0;
        for(int i=n-2; i>=0; i--){
            while(nums[i]>nums[i+1]){
                int val = nums[i];
                int maxDiv = 1;
                for(int j=2; j*j<=val; j++){
                    if(val%j==0){
                        maxDiv = (val/j);
                        break;
                    }
                }
                if(maxDiv==1) return -1;
                nums[i]/=maxDiv;
                res++;
            }
        }
        return res;
    }
}",1427860365
funsquared,funsquared,181,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res = 0
        for i in range(len(s)):
            cnt = Counter()
            for j in range(i, len(s)):
                cnt[s[j]] += 1
                if cnt[s[j]] >= k:
                    res += len(s) - j
                    break
        return res
                
            ",1427907903
funsquared,funsquared,181,3566,python3,"def idx(c): return ord(c) - ord('a')
def inv(i): return chr(ord('a') + i)

class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        for i, x in enumerate(target):
            for ch in range(idx(x) + 1):
                res.append(target[:i] + inv(ch))
        return res
                ",1427908209
funsquared,funsquared,181,3603,python3,"M = 10 ** 9 + 7
P = 101
def idx(c): return ord(c) - ord('a') + 1

class Solution:
    def findAnswer(self, parent: List[int], S: str) -> List[bool]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        for u in range(1, n):
            adj[parent[u]].append(u)
            adj[u].append(parent[u])
        for l in adj:
            l.sort()
        hash_post = [None] * n
        def post(u):
            h, s = 0, 1
            for v in adj[u]:
                if v != parent[u]:
                    cur_h, cur_s = post(v)
                    h = (h * pow(P, cur_s, M) + cur_h) % M
                    s += cur_s
            h = (h * P % M + idx(S[u]))
            hash_post[u] = h
            return h, s
        hash_pre = [None] * n
        def pre(u):
            h, s = 0, 1
            h = (h * P % M + idx(S[u]))
            for v in reversed(adj[u]):
                if v != parent[u]:
                    cur_h, cur_s = pre(v)
                    h = (h * pow(P, cur_s, M) + cur_h) % M
                    s += cur_s
            hash_pre[u] = h
            return h, s
        pre(0)
        post(0)
        return [hash_pre[u] == hash_post[u] for u in range(n)]
        
            ",1427902819
funsquared,funsquared,181,3607,python3,"MAXN = 10 ** 6
lp = list(range(MAXN + 1))
p = 2
while p * p <= MAXN:
    if lp[p] == p:
        for m in range(p * p, MAXN + 1, p):
            lp[m] = min(lp[m], p)
    p += 1

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                if lp[nums[i]] == nums[i] or lp[nums[i]] > nums[i + 1]:
                    return -1
                nums[i] = lp[nums[i]]
                res += 1
        return res
",1427907704
Jiabei Zhu,zzjjbb,182,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c = defaultdict(int)
        c['a']
        l = r = 0
        ans = 0
        n = len(s)
        while r < n and max(c.values()) < k:
            c[s[r]] += 1
            r += 1
            while max(c.values()) >= k:
                c[s[l]] -= 1
                l += 1
            ans += l
        return ans",1427831577
Jiabei Zhu,zzjjbb,182,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        curr = """"
        for l in target:
            for i in string.ascii_lowercase:
                ans.append(curr + i)
                if i == l:
                    curr += i
                    break
        return ans",1427825276
Jiabei Zhu,zzjjbb,182,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def getd(ss):
            n = len(ss)
            d1 = [0] * n
            l, r = 0, -1
            for i in range(0, n):
                k = 1 if i > r else min(d1[l + r - i], r - i + 1)
                while 0 <= i - k and i + k < n and ss[i - k] == ss[i + k]:
                    k += 1
                d1[i] = k
                k -= 1
                if i + k > r:
                    l = i - k
                    r = i + k
            d2 = [0] * n
            l, r = 0, -1
            for i in range(0, n):
                k = 0 if i > r else min(d2[l + r - i + 1], r - i + 1)
                while 0 <= i - k - 1 and i + k < n and ss[i - k - 1] == ss[i + k]:
                    k += 1
                d2[i] = k
                k -= 1
                if i + k > r:
                    l = i - k - 1
                    r = i + k
            return d1, d2
        
        child = defaultdict(list)
        for i, pi in enumerate(parent[1:], 1):
            child[pi].append(i)
        dfss = []
        small = [0] * len(s)
        big = [0] * len(s)
        def dfs(node):
            small[node] = len(dfss)
            for c in child[node]:
                dfs(c)
            dfss.append(s[node])
            big[node] = len(dfss)
        dfs(0)
        d1, d2 = getd(dfss)
        # print(d1, d2, dfss, small, big)
        def check(l, r):
            mid = (l + r) // 2
            ll = (r - l + 1) // 2
            # print(l, r, mid, ll)
            if (r - l) % 2:
                return ll <= d1[mid]
            else:
                return ll <= d2[mid]
        return [check(ss, bb) for bb, ss in zip(big, small)]
        

",1427908428
Jiabei Zhu,zzjjbb,182,3607,python3,"N = 10_000
prime = [True] * N
prime[0] = prime[1] = False
cp = 2
while cp < N:
    if prime[cp]:
        for j in range(2 * cp, N, cp):
            prime[j] = False
    cp += 1
prime_l = [i for i, q in enumerate(prime) if q]
primes = set(prime_l)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def op(x):
            assert x not in primes
            for i in prime_l:
                if i > int(sqrt(x)) + 1:
                    primes.add(x)
                    assert False
                if not x % i:
                    x = i
                    return x
        prev = 10 ** 7
        ans = 0
        try:
            for i in reversed(nums):
                while i > prev:
                    i = op(i)
                    ans += 1
                prev = i
        except AssertionError:
            return -1
        return ans
",1427848022
Maruzensky,Maruzensky,183,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        seen = [[] for _ in range(26)]
        
        for i, c in enumerate(s):
            idx = ord(c) - ord('a')
            seen[idx].append(i)
            
        n = len(s)
        for seq in seen:
            seq.extend([n] * k)
            
        answer = 0
        indices = [-1] * 26
        for i, c in enumerate(s):
            idx = ord(c) - ord('a')
            best = min(seen[i][indices[i] + k] for i in range(26))
            
            indices[idx] += 1
            
            answer += (n - best)
            
        return answer",1427832616
Maruzensky,Maruzensky,183,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        answer = []
        ready = ''
        
        for c in target:
            answer.extend([ready + chr(ord('a') + i) for i in range(ord(c) - ord('a') + 1)])
            ready = f'{ready}{c}'
            
        return answer",1427824709
Maruzensky,Maruzensky,183,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def power(p, x, e):
            base = x
            answer = 1
            while e:
                if e & 1:
                    answer = (answer * base) % p

                base = (base * base) % p
                e >>= 1

            return answer

        n = len(parent)
        mod = 863054227073095753
        exp = 31
        
        children = [[] for _ in range(n)]
        child_size = [None for _ in range(n)]
        left_sig = [None for _ in range(n)]
        right_sig = [None for _ in range(n)]
        
        for i in range(1, n):
            p = parent[i]
            children[p].append(i)
            
        def get_child_size(idx):
            if child_size[idx] is not None:
                return child_size[idx]
            
            answer = 1 + sum(get_child_size(c) for c in children[idx])
            child_size[idx] = answer
            return answer
        
        def get_left_sig(idx):
            if left_sig[idx] is not None:
                return left_sig[idx]
            
            answer = 0
            for c in children[idx]:
                size = child_size[c]
                answer = (answer * power(mod, exp, size)) % mod
                answer = (answer + get_left_sig(c)) % mod
                
            answer = (answer * exp + ord(s[idx]) - ord('a')) % mod
            left_sig[idx] = answer
            return answer
        
        def get_right_sig(idx):
            if right_sig[idx] is not None:
                return left_sig[idx]
            
            answer = ord(s[idx]) - ord('a')
            for c in reversed(children[idx]):
                size = child_size[c]
                answer = (answer * power(mod, exp, size)) % mod
                answer = (answer + get_right_sig(c)) % mod
                
            right_sig[idx] = answer
            return answer
        
        get_child_size(0)
        get_left_sig(0)
        get_right_sig(0)
        
        return [left == right for left, right in zip(left_sig, right_sig)]
        
",1427908736
Maruzensky,Maruzensky,183,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        answer = 0
        
        m = max(nums)
#         gpd = list(range(m + 2))
        
#         up = min(m, int(m**0.5) + 3)
#         for d in range(2, up + 1):
#             if gpd[d] == d:
#                 for y in range(2 * d, m + 1, d):
#                     if gpd[y] > d:
#                         gpd[y] = d

        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
                  67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,
                  139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,
                  223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
                  293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
                  383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,
                  463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,
                  569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
                  647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
                  743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,
                  839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,
                  941, 947, 953, 967, 971, 977, 983, 991, 997]
    
        def test(x, y):
            if x <= y:
                return x
            for p in primes:
                if p * p > x or p > y:
                    return x
                if x % p == 0:
                    return p
                
            return x
    
        for i in range(n - 2, -1, -1):
            x = nums[i]
            y = nums[i + 1]
            
            if x <= y:
                continue
                
            z = test(x, y)
            
            if z == x:
                return -1
            else:
                nums[i] = z
                answer += 1
            
        return answer
            ",1427860203
Anav Prasad,vrangr,185,3502,cpp,"#define all(x) (x).begin(),(x).end()
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int sol = 0, n = s.size();
        vector<int> ct(26,0);
        int stt = 0;
        for (int i = 0; i < n; ++i) {
            ct[s[i]-'a']++;
            if (*max_element(all(ct)) < k) continue;
            while (stt <= i && *max_element(all(ct)) >= k) {
                sol += n-i;
                ct[s[stt]-'a']--;
                stt++;
            }
        }
        return sol;
    }
};",1427828419
Anav Prasad,vrangr,185,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        int n = t.size();
        vector<string> sol;
        string s;
        for (char ch : t) {
            s.push_back('a');
            sol.push_back(s);
            while(s.back() != ch) {
                s.back()++;
                sol.push_back(s);
            }
        }
        return sol;
        
    }
};",1427824353
Anav Prasad,vrangr,185,3603,cpp,"#define IS_SMALL_INT_TYPE(T) ( \
    std::is_same<T, int>::value || \
    std::is_same<T, int32_t>::value || \
    std::is_same<T, unsigned int>::value || \
    std::is_same<T, int16_t>::value || \
    std::is_same<T, short int>::value || \
    std::is_same<T, int8_t>::value )
#define OVERFLOW_MULTIPLY(T, lhs, rhs) \
    (IS_SMALL_INT_TYPE(T) ? \
        normalize(static_cast<int64_t>(lhs) * static_cast<int64_t>(rhs)) : \
        normalize(static_cast<__uint128_t>(lhs) * static_cast<__uint128_t>(rhs)))

// Based on ACL's modint header and tourist's Modular class.
template <typename MOD>
class ModularInt {
private:
    using type = typename decay<decltype(MOD::value)>::type;
    const type mod = MOD::value;
    type value;

    template <typename T>
    type normalize(T val) const {
        val %= T(mod);
        if (val >= 0ll)
            return type(val);
        return type((val + mod) % mod);
    }

    // Not done value = (value%mod + mod)%mod because mod-1+mod maybe > inf
    void normalize() {
        this->value %= this->mod;
        if (this->value >= 0) 
            return;
        this->value = (this->value + this->mod) % this->mod;
    }
    
    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    void add(type lhs, type rhs, type &result) const {
        if (__builtin_add_overflow(lhs, rhs, &result))
            result = lhs + (this->mod - rhs);
        else 
            result = normalize(result);
    }
    
    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    type add(type lhs, type rhs) const {
        type result;
        add(lhs, rhs, result);
        return result;
    }

    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    void subtract(type lhs, type rhs, type &result) const {
        if (lhs >= rhs)
            result = lhs - rhs;
        else
            result = this->mod - (rhs - lhs);
    }

    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    type subtract(type lhs, type rhs) const {
        type result;
        subtract(lhs, rhs, result);
        return result;
    }

    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    void multiply(type lhs, type rhs, type &result) const {
        if (__builtin_mul_overflow(lhs, rhs, &result))
            result = OVERFLOW_MULTIPLY(type, lhs, rhs);
        else
            result = normalize(result);
    }

    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    type multiply(type lhs, type rhs) const {
        type result;
        multiply(lhs, rhs, result);
        return result;
    }

    pair<type,type> inverse(type a, type b) const {
        if (a == 1) return {1,0};
        auto [x, y] = inverse(b%a,a);
        return {subtract(y, multiply((b / a), x)), x};
    }

    // Assumes 1 <= x < mod
    type inverse(type x) const {
        if (x == 1) return 1;
        return inverse(x, this->mod).first;
    }

    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    void divide(type lhs, type rhs, type &result) const {
        multiply(lhs, inverse(rhs), result);
    }

    // Assumes 0 <= lhs < mod, 0 <= rhs < mod
    type divide(type lhs, type rhs) const {
        type result;
        divide(lhs, rhs, result);
        return result;
    }

public:
    ModularInt() : value(0) {}

    ModularInt(const ModularInt &var) {
        this->value = var.value;
    }
    
    template <typename U>
    ModularInt(const U val) {
        this->value = normalize(val);
    }

    type operator()() const {
        return this->value;
    }

    template <typename T>
    friend ostream& operator<< (ostream& out, const ModularInt<T> &var) {
        out << var.value;
        return out;
    }

    // Assumes the input fits into the type of mod
    template <typename T>
    friend istream& operator>> (istream &in, ModularInt<T> &var) {
        in >> var.value;
        var.normalize();
        return in;
    }

    ModularInt& operator=(const ModularInt &rhs) {
        this->value = rhs.value;
        return *this;
    }

    template <typename U>
    ModularInt& operator=(const U val) {
        this->value = this->normalize(val);
        return *this;
    }

    ModularInt operator+() const {
        return ModularInt(this->value);
    }

    ModularInt operator-() const {
        return ModularInt(-this->value);
    }

    ModularInt& operator+=(const ModularInt &rhs) {
        this->value = add(this->value, rhs.value);
        return *this;
    }

    ModularInt& operator-=(const ModularInt &rhs) {
        this->value = subtract(this->value, rhs.value);
        return *this;
    }

    ModularInt& operator*=(const ModularInt &rhs) {
        this->value = multiply(this->value, rhs.value);
        return *this;
    }

    ModularInt& operator/=(const ModularInt &rhs) {
        this->value = divide(this->value, rhs.value);
        return *this;
    }

    ModularInt& operator++() {
        this->value = add(this->value,type(1)%mod);
        return *this;
    }
    
    ModularInt& operator--() {
        this->value = subtract(this->value,type(1)%mod);
        return *this;
    }

    ModularInt operator++(int) {
        ModularInt result = *this;
        this->value = add(this->value,type(1)%mod);
        return result;
    }

    ModularInt operator--(int) {
        ModularInt result = *this;
        this->value = subtract(this->value,type(1)%mod);
        return result;
    }

    template <typename U>
    ModularInt power(const U n) const {
        if (typeid(U) == typeid(ModularInt))
            return this->power(__int128_t(n));
        if (n == 0) {
            return ModularInt(1);
        } else if (n < 0) {
            return 1 / this->power(-n);
        } else {
            ModularInt result = this->value;
            result *= result;
            if (n % 2 == 1)
                return this->value * result.power(n/2);
            return result.power(n/2);
        }
    }

    template <typename U>
    operator U() const {
        return U(this->value);
    }

    template <typename T>
    friend ModularInt<T> operator+(const ModularInt<T> &lhs, const ModularInt<T> &rhs) {
        ModularInt<T> result;
        result.add(lhs.value, rhs.value, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator+(const ModularInt<T> &lhs, const U rhs) {
        ModularInt<T> result;
        type rhs_normalized = result.normalize(rhs);
        result.add(lhs.value, rhs_normalized, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator+(const U lhs, const ModularInt<T> &rhs) {
        return rhs + lhs;
    }

    template <typename T>
    friend ModularInt<T> operator-(const ModularInt<T> &lhs, const ModularInt<T> &rhs) {
        ModularInt<T> result;
        result.subtract(lhs.value, rhs.value, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator-(const ModularInt<T> &lhs, const U rhs) {
        ModularInt<T> result;
        type rhs_normalized = result.normalize(rhs);
        result.subtract(lhs.value, rhs_normalized, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator-(const U lhs, const ModularInt<T> &rhs) {
        ModularInt<T> result;
        type lhs_normalized = result.normalize(lhs);
        result.subtract(lhs_normalized, rhs.value, result.value);
        return result;
    }

    template <typename T>
    friend ModularInt<T> operator*(const ModularInt<T> &lhs, const ModularInt<T> &rhs) {
        ModularInt<T> result;
        result.multiply(lhs.value, rhs.value, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator*(const ModularInt<T> &lhs, const U rhs) {
        ModularInt<T> result;
        type rhs_normalized = result.normalize(rhs);
        result.multiply(lhs.value, rhs_normalized, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator*(const U lhs, const ModularInt<T> &rhs) {
        return rhs * lhs;
    }

    template <typename T>
    friend ModularInt<T> operator/(const ModularInt<T> &lhs, const ModularInt<T> &rhs) {
        ModularInt<T> result;
        result.divide(lhs.value, rhs.value, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator/(const ModularInt<T> &lhs, const U rhs) {
        ModularInt<T> result;
        type rhs_normalized = result.normalize(rhs);
        result.divide(lhs.value, rhs_normalized, result.value);
        return result;
    }

    template <typename T, typename U>
    friend ModularInt<T> operator/(const U lhs, const ModularInt<T> &rhs) {
        ModularInt<T> result;
        type lhs_normalized = result.normalize(lhs);
        result.divide(lhs_normalized, rhs.value, result.value);
        return result;
    }

    template <typename T>
    friend ModularInt<T> operator%(const ModularInt<T> &lhs, const ModularInt<T> &rhs) {
        assert(rhs.value != 0);
        return ModularInt<T>(lhs.value % rhs.value);
    }

    template <typename T, typename U>
    friend U operator%(const ModularInt<T> &lhs, const U rhs) {
        return U(lhs.value) % rhs;
    }

    template <typename T, typename U>
    friend U operator%(const U lhs, const ModularInt<T> &rhs) {
        return lhs % U(rhs);
    }

    template <typename T>
    friend bool operator<(const ModularInt<T> lhs, const ModularInt<T>rhs) {
        return lhs.value < rhs.value;
    }

    template <typename T>
    friend bool operator>(const ModularInt<T> lhs, const ModularInt<T> rhs) {
        return lhs.value > rhs.value;
    }

    template <typename T>
    friend bool operator<=(const ModularInt<T> lhs, const ModularInt<T> rhs) {
        return lhs.value <= rhs.value;
    }

    template <typename T>
    friend bool operator>=(const ModularInt<T> lhs, const ModularInt<T> rhs) {
        return lhs.value >= rhs.value;
    }

    template <typename T, typename U>
    friend bool operator<(const ModularInt<T> lhs, const U rhs) {
        return lhs < ModularInt<T>(rhs);
    }

    template <typename T, typename U>
    friend bool operator<(const U lhs, const ModularInt<T> rhs) {
        return ModularInt<T>(lhs) < rhs;
    }

    template <typename T, typename U>
    friend bool operator>(const ModularInt<T> lhs, const U rhs) {
        return lhs > ModularInt<T>(rhs);
    }

    template <typename T, typename U>
    friend bool operator>(const U lhs, const ModularInt<T> rhs) {
        return ModularInt<T>(lhs) > rhs;
    }

    template <typename T, typename U>
    friend bool operator<=(const ModularInt<T> lhs, const U rhs) {
        return lhs <= ModularInt<T>(rhs);
    }

    template <typename T, typename U>
    friend bool operator<=(const U lhs, const ModularInt<T> rhs) {
        return ModularInt<T>(lhs) <= rhs;
    }

    template <typename T, typename U>
    friend bool operator>=(const ModularInt<T> lhs, const U rhs) {
        return lhs >= ModularInt<T>(rhs);
    }

    template <typename T, typename U>
    friend bool operator>=(const U lhs, const ModularInt<T> rhs) {
        return ModularInt<T>(lhs) >= rhs;
    }

    template <typename T>
    friend bool operator==(const ModularInt<T> lhs, const ModularInt<T> rhs) {
        return lhs.value == rhs.value;
    }

    template <typename T, typename U>
    friend bool operator==(const ModularInt<T> lhs, const U rhs) {
        return lhs == ModularInt<T>(rhs);
    }

    template <typename T, typename U>
    friend bool operator==(const U lhs, const ModularInt<T> rhs) {
        return ModularInt<T>(lhs) == rhs;
    }
};

template <typename T>
std::string to_string(const ModularInt<T> &var) {
    return std::to_string(var());
}

template <typename T, typename U>
U& operator+=(U &lhs, ModularInt<T> rhs) {
    return lhs += U(rhs);
}

template <typename T, typename U>
U& operator-=(U &lhs, ModularInt<T> rhs) {
    return lhs -= U(rhs);
}

template <typename T, typename U>
U& operator*=(U &lhs, ModularInt<T> rhs) {
    return lhs *= U(rhs);
}

template <typename T, typename U>
U& operator/=(U &lhs, ModularInt<T> rhs) {
    return lhs /= U(rhs);
}

// For variable mod cases:
// using MOD_TYPE = int;
// struct VarMod {
//     static MOD_TYPE value;
// };
// MOD_TYPE VarMod::value;
// MOD_TYPE &mod = VarMod::value;
// using mint = ModularInt<VarMod>;

const int mod = int(1e9) + 7;
using mint = ModularInt<std::integral_constant<std::decay<decltype(mod)>::type,mod>>;

// #define USE_NCR
#ifdef USE_NCR
const int NCR_MAX = int(1e5)+10;
bool NCR_SETUP = false;
std::vector<mint> factorial;

void ncr_setup() {
    if (NCR_SETUP) return;
    NCR_SETUP = true;
    factorial.assign(NCR_MAX,mint(0));
    factorial[0] = factorial[1] = 1;
    for (int f = 2; f < NCR_MAX; ++f)
        factorial[f] = factorial[f-1]*f;
}

mint ncr(int n, int r) {
    ncr_setup();
    return factorial[n]/(factorial[n-r]*factorial[r]);
}
#endif

mint prime = 27;

template <typename type> inline void print(const type &var) {
    cout << var;
}
template <typename type> inline void print(const vector<type> &vec) {
    for (auto &it : vec) {
        print(it); cout << "" "";
    }
}
#define debug(x) if(false){cout<<#x<<"": "";print(x);cout<<endl;}
class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = s.size();
        vector<vector<int>> g(n);
        for (int i = 1; i < n; ++i) {
            g[p[i]].push_back(i);
        }
        vector<bool> sol(n,false);
        string dstr;
        vector<mint> dhash, drev;
        auto get = [&](int l, int r, bool rev = false) -> mint {
            if (r < l) return 0;
            assert(l >= 0 && l <= r && r < dhash.size() && r < drev.size());
            if (rev) {
                mint cur = drev[r];
                if (l == 0) return cur;
                cur -= drev[l-1]*prime.power(r-l+1);
                return cur;
            }
            mint cur = dhash[r];
            if (l == 0) return cur;
            cur -= dhash[l-1];
            cur/=prime.power(l);
            return cur;
        };
        auto dfs = [&](auto &&self, int u) -> int {
            mint cl = 0, cr = 0;
            int len = 0;
            int ind = dstr.size();
            for (int v : g[u]) {
                int vlen = self(self,v);
                len += vlen;
            }
            dstr.push_back(s[u]);
            if (dstr.size() == 1) {
                dhash.push_back(mint(s[u]-'a'));
                drev.push_back(mint(s[u]-'a'));
            } else {
                dhash.push_back(dhash.back() + mint(s[u]-'a')*prime.power(dhash.size()));
                drev.push_back((drev.back()*prime) + mint(s[u]-'a'));
            }
            len++;
            if (len%2) {
                int mid = len/2 + ind;
                cl = get(ind,mid-1);
                cr = get(mid+1,ind+len-1,true);
            }
            else {
                cl = get(ind,ind+len/2-1);
                cr = get(ind+len/2,ind+len-1,true);
            }
            // if (u == 0) {
            //     debug(len);
            //     debug(ind);
            //     debug(dhash);
            //     debug(drev);
            //     debug(dstr);
            //     debug(cl);
            //     debug(cr);
            // }
            sol[u] = (cl==cr);
            return len;
        };
        dfs(dfs,0);
        return sol;
    }
};",1427917539
Anav Prasad,vrangr,185,3607,cpp,"const int maxn = 1e6+5;
vector<int> spf(maxn,INT_MAX);
void init() {
    static bool init = false;
    if (init) return;
    init = true;
    for (int v = 4; v < maxn; v+=2)
        spf[v] = min(spf[v],2);
    for (int f = 3; f < maxn; ++f) {
        if (spf[f] != INT_MAX) continue;
        for (int v = 2*f; v < maxn; v += f)
            spf[v] = min(spf[v],f);
    }
}
class Solution {
public:
    int minOperations(vector<int>& vals) {
        if (is_sorted(vals.begin(),vals.end())) return 0;
        init();
        int n = vals.size();
        int sol = 0;
        for (int i = n-2; i >= 0; --i) {
            if (vals[i] > vals[i+1]) {
                if (spf[vals[i]] == INT_MAX) return -1;
                vals[i] = spf[vals[i]];
                if (vals[i] > vals[i+1]) return -1;
                sol++;
            }
        }
        return sol;
    }
};",1427839439
qdd1999,qdd1999,186,3502,cpp,"void sliding_window(int start, int end, function<void(int)> add, function<void(int)> del, function<bool()> f, function<void(int, int)> callback) {
  for (int l = start, r = start; r != end; callback(l, r))
    for (add(r++); l != r && f(); del(l++));
}

class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    int n = s.size();
    vector<int> cnt(26, 0);
    int ccnt = 0;
    auto add = [&](int i) {
      cnt[s[i] - 'a']++;
      if (cnt[s[i] - 'a'] == k) {
        ccnt++;
      }
    };
    auto del = [&](int i) {
      cnt[s[i] - 'a']--;
      if (cnt[s[i] - 'a'] == k - 1) {
        ccnt--;
      }
    };
    auto f = [&]() { return ccnt > 0; };
    int ans = 0;
    sliding_window(0, n, add, del, f, [&](int l, int r) { ans += l; });
    return ans;
  }
};",1427852646
qdd1999,qdd1999,186,3566,cpp,"class Solution {
public:
  vector<string> stringSequence(string target) {
    vector<string> res;
    string cur = """";
    for (char c : target) {
      string tmp = cur;
      for (char d = 'a'; d <= c; ++d) {
        res.push_back(tmp + d);
      }
      cur += c;
    }
    return res;
  }
};",1427857970
qdd1999,qdd1999,186,3603,cpp,"using i64 = long long;

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
i64 md = (1LL << 61) - 1;
i64 step = uniform_int_distribution<i64>(256, md - 1)(rng);

i64 pw[100005];

auto init = []() {
  pw[0] = 1;
  for (int i = 1; i < 100005; ++i) {
    pw[i] = __int128(pw[i - 1]) * step % md;
  }
  return 0;
}();

class Solution {
public:
  vector<bool> findAnswer(vector<int>& parent, string s) {
    int n = parent.size();
    vector<bool> ans(n);
    vector<vector<int>> g(n);
    for (int i = 1; i < n; ++i) {
      g[parent[i]].push_back(i);
    }
    auto dfs = [&](auto self, int u) -> tuple<i64, i64, i64> {
      sort(g[u].begin(), g[u].end());
      vector<tuple<i64, i64, i64>> children;
      for (int v : g[u]) {
        children.push_back(self(self, v));
      }
      int m = children.size();
      i64 size = 1;
      i64 hash = 0;
      for (int i = 0; i < m; i++) {
        size += get<0>(children[i]);
        hash = (__int128(hash) * pw[get<0>(children[i])] + get<1>(children[i])) % md;
      }
      hash = (__int128(hash) * step + s[u] - 'a' + 1) % md;
      i64 rev_hash = s[u] - 'a' + 1;
      for (int i = m - 1; i >= 0; i--) {
        rev_hash = (__int128(rev_hash) * pw[get<0>(children[i])] + get<2>(children[i])) % md;
      }
      ans[u] = hash == rev_hash;
      return {size, hash, rev_hash};
    };
    dfs(dfs, 0);
    return ans;
  }
};",1427909236
qdd1999,qdd1999,186,3607,cpp,"struct sieve {
  vector<bool> vis;
  vector<int> prime, spf;

  sieve(int N) : vis(N + 1), spf(N + 1) {
    vis[0] = vis[1] = spf[1] = 1;
    for (int i = 2; i <= N; i++) {
      if (!vis[i]) {
        prime.push_back(i);
        spf[i] = i;
      }
      for (int p : prime) {
        int d = i * p;
        if (d > N) break;
        vis[d] = true;
        spf[d] = p;
        if (i % p == 0) {
          break;
        }
      }
    }
  }

  bool is_prime(int x) { return !vis[x]; }
};

sieve s(1e6 + 5);

const int INF = 1e9;

class Solution {
public:
  int minOperations(vector<int>& a) {
    int n = a.size();
    vector<int> b(n);
    for (int i = 0; i < n; i++) {
      if (a[i] == 1 || s.is_prime(a[i])) {
        b[i] = a[i];
      } else {
        b[i] = s.spf[a[i]];
      }
    }
    int dp0 = 0, dp1 = 1;
    for (int i = 1; i < n; i++) {
      int ndp0 = INF, ndp1 = INF;
      if (a[i] >= a[i - 1]) ndp0 = min(ndp0, dp0);
      if (a[i] >= b[i - 1]) ndp0 = min(ndp0, dp1);
      if (b[i] >= a[i - 1]) ndp1 = min(ndp1, dp0 + 1);
      if (b[i] >= b[i - 1]) ndp1 = min(ndp1, dp1 + 1);
      dp0 = ndp0;
      dp1 = ndp1;
    }
    if (dp0 >= INF && dp1 >= INF) return -1;
    return min(dp0, dp1);
  }
};",1427847025
michified,michified,187,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int i, j, ans = 0;
        for (i = 0; i < s.size(); i++) {
            vector<int> cnt(26);
            for (j = i; j < s.size(); j++) {
                cnt[s[j] - 'a']++;
                if (cnt[s[j] - 'a'] >= k) {
                    ans += s.size() - j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427829435
michified,michified,187,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur;
        for (int i = 0; i < target.size(); i++) {
            cur += 'a';
            ans.push_back(cur);
            while (cur[i] != target[i]) {
                cur[i] = (cur[i] - 'a' + 1) % 26 + 'a';
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427825277
michified,michified,187,3603,cpp,"class Solution {
public:
    vector<vector<int>> childs;
    void getans(vector<bool>& ans, int cur, string& s, string& now) {
        int sP = now.size();
        for (int c : childs[cur]) getans(ans, c, s, now);
        now += s[cur];
        int eP = now.size() - 1;
        int ml = (eP + sP) / 2;
        int mr = ml + (eP + sP) % 2;
        int cnt = 0;
        while (sP <= ml and mr <= eP and cnt < 1000) {
            if (now[sP] != now[eP] or now[ml] != now[mr]) {
                ans[cur] = false;
                return;
            }
            sP++;
            eP--;
            ml--;
            mr++;
            cnt++;
        }
        ans[cur] = true;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> ans(n);
        childs.resize(n);
        for (int i = 1; i < n; i++) {
            childs[parent[i]].push_back(i);
        }
        for (auto& elem : childs) sort(elem.begin(), elem.end());
        string dummy;
        getans(ans, 0, s, dummy);
        return ans;
    }
};",1427892460
michified,michified,187,3607,cpp,"class Solution {
public:
    void reduce(int& n, vector<int>& primes) {
        int i;
        for (i = 0; primes[i] <= sqrt(n); i++) {
            if (n % primes[i] == 0) {
                n = primes[i];
                return;
            }
        }
    }

    bool isPrime(int n, vector<int>& primes) {
        for (int i = 0; primes[i] <= sqrt(n); i++) {
            if (n % primes[i] == 0) return false;
        }
        return true;
    }

    int minOperations(vector<int>& nums) {
        vector<bool> sieve(1e4 + 1, true);
        int i, j;
        for (i = 2; i <= 1e4; i++) {
            if (sieve[i]) {
                for (j = i + i; j <= 1e4; j += i) sieve[j] = false;
            }
        }
        vector<int> primes;
        for (i = 2; i <= 1e4; i++) {
            if (sieve[i]) primes.push_back(i);
        }
        int ans = 0;
        for (i = nums.size() - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (isPrime(nums[i], primes)) return -1;
                reduce(nums[i], primes);
                ans++;
            }
        }
        return ans;
    }
};",1427850389
Edwin Chen,echen5503,188,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        pf = defaultdict(lambda: Counter())
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        n = len(s)
        for i, c in enumerate(s):
            for t in alphabet:
                pf[t][i] = pf[t][i-1] + (c == t)
        
        def valid(i, j):
            for c in alphabet:
                if pf[c][j] - pf[c][i-1] >= k:
                    return True
            return False

        cnt = 0
        for i in range(n):
            l = i
            r = n-1
            ans = n

            while l <= r:
                mid = (l+r)//2
                if valid(i, mid) and not valid(i, mid-1):
                    ans = mid
                    break
                if valid(i, mid):
                    r = mid
                else:
                    l = mid+1
            #print(ans)
            cnt += n-ans
        return cnt",1427836952
Edwin Chen,echen5503,188,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        s = []
        alphabet = 'abcdefghijklmnopqrstuvwxyz'
        res = []
        for c in target:
            s.append('a')
            idx = 0
            while alphabet[idx] != c:
                res.append(''.join(s))
                idx += 1
                s[-1] = alphabet[idx]

            res.append(''.join(s))
        
        return res",1427825680
Edwin Chen,echen5503,188,3603,python3,"class RollingHash:
    def __init__(self, string, base=31, modulus=999999999999999989):
        self.base = base
        self.modulus = modulus
        self.length = len(string)
        self.prefix_hash = [0] * (self.length + 1)
        self.base_power = [1] * (self.length + 1)
        
        # Compute prefix hashes and base powers
        for i in range(1, self.length + 1):
            self.prefix_hash[i] = (self.prefix_hash[i-1] * self.base + ord(string[i-1])) % self.modulus
            self.base_power[i] = (self.base_power[i-1] * self.base) % self.modulus
    
    def substr(self, start, end):
        if start < 0 or end >= self.length or start > end:
            raise
        
        hash_value = (self.prefix_hash[end + 1] - self.prefix_hash[start] * self.base_power[end - start + 1]) % self.modulus
        if hash_value < 0:
            hash_value += self.modulus
        return hash_value

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        graph = defaultdict(list)
        n = len(parent)
        for i, node in enumerate(parent):
            graph[node].append(i)
        
        
        dfs_str = ''
        size = Counter()
        def dfs1(u):
            nonlocal dfs_str
            size[u] = 1
            for v in graph[u]:
                dfs1(v)
                size[u] += size[v]
            dfs_str += s[u]

        dfs1(0)
        #print(dfs_str)
        h = RollingHash(dfs_str)
        revh = RollingHash(dfs_str[::-1])

        def invert(i, j):
            return n-1-j, n-1-i
        def isPal(i, j):
            if (j-i+1) % 2 == 0:
                mid = (j+i)//2
                x, y = invert(mid+1, j)
                return h.substr(i, mid) == revh.substr(x, y)

            if j == i:
                return True

            mid = (j+i)//2
            x, y = invert(mid+1, j)
            return h.substr(i, mid-1) == revh.substr(x, y)

        ans = [False for i in range(n)]
        def dfs(u, i, j):
            newi = i

            for v in graph[u]:
                dfs(v, newi, newi+size[v]-1)
                newi += size[v]
            ans[u] = isPal(i, j)

        dfs(0, 0, n-1)
        return ans",1427901221
Edwin Chen,echen5503,188,3607,python3,"@cache
def gpd(x):
    for i in range(2, int(sqrt(x)+1)):
        if x % i == 0:
            return x//i
    return 1
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        nums.append(1e10)
        ops = 0
        for i in range(n-1, -1, -1):
            while nums[i] > nums[i+1]:
                if gpd(nums[i]) == 1:
                    return -1
                nums[i] //= gpd(nums[i])
                ops += 1
        return ops",1427849953
German Andosov,randle999,189,3502,kotlin,"class Solution {
    fun numberOfSubstrings(s: String, k: Int): Int {
        var ans = 0
        for (i in 0..<s.length) {
            val cnt = MutableList(26) { 0 }
            for (j in i..<s.length) {
                val pos = (s[j] - 'a').toInt()
                cnt[pos]++
                if (cnt[pos] == k) {
                    ans += s.length - j
                    break
                }
            }
        }

        return ans
    }
}",1427832432
German Andosov,randle999,189,3566,kotlin,"class Solution {
    fun stringSequence(target: String): List<String> {
        val ans = mutableListOf<String>()
        
        for (len in 1..target.length) {
            for (delta in 0..(target[len - 1] - 'a').toInt()) {
                ans.add(target.substring(0, len - 1) + ('a'.toInt() + delta).toChar())
            }
        }

        return ans
    }
}",1427826858
German Andosov,randle999,189,3603,kotlin,"class Solution {
    fun findAnswer(parent: IntArray, s: String): BooleanArray {
        val n = parent.size
        val ans = BooleanArray(n) { false }

        val gr = MutableList(n) { mutableListOf<Int>() }
        for (u in 1..<n) {
            gr[parent[u]].add(u)
        }

        val p = 239L
        val mod = 1_000_000_007L
        val pPow = MutableList(n + 1) { 1L }
        for (i in 1..n) { pPow[i] = pPow[i - 1] * p % mod }
        val nodeSize = MutableList(n) { 0 }

        fun dfs(u: Int): Pair<Long, Long> {
            if (gr[u].isEmpty()) {
                ans[u] = true
                nodeSize[u] = 1
                return s[u].toLong() to s[u].toLong()
            }
            val children = gr[u].map { v -> dfs(v) }
            var left = 0L
            for (childIndex in 0..<gr[u].size) {
                val hash = children[childIndex].first
                val len = nodeSize[gr[u][childIndex]]
                left = ((left * pPow[len] % mod) + hash) % mod
            }
            left = ((left * p % mod) + s[u].toLong()) % mod

            var right = s[u].toLong()
            for (childIndex in (gr[u].size - 1) downTo 0) {
                val hash = children[childIndex].second
                val len = nodeSize[gr[u][childIndex]]
                right = ((right * pPow[len] % mod) + hash) % mod
            }

            if (left == right) {
                ans[u] = true
            }
            nodeSize[u] = 1 + gr[u].map{ nodeSize[it] }.sum()
            return left to right
        }

        dfs(0)
        return ans
    }
}",1427910029
German Andosov,randle999,189,3607,kotlin,"class Solution {
    fun minOperations(nums: IntArray): Int {
        var ans = 0
        val ert = MutableList(1_001) { 1 }
        for (p in 2..100) {
            if (ert[p] > 1) continue
            for (x in (p * p)..1_000 step p) {
                if (ert[x] == 1) ert[x] = p
            }
        }
        val primes = mutableListOf<Int>()
        for (i in 2..1000) {
            if (ert[i] == 1) {
                primes.add(i)
            }
        }

        fun findPrime(x: Int): Int {
            for (p in primes) {
                if (x % p == 0) {
                    return p
                }
            }
            return 1
        }

        for (i in (nums.size - 2) downTo 0) {
            if (nums[i] <= nums[i + 1]) continue
            val fp = findPrime(nums[i])
            if (fp == 1) return -1
            nums[i] = fp
            ans++
            if (nums[i] > nums[i + 1]) return -1
        }

        return ans
    }
}",1427859050
tomarin,tomarint,191,3502,rust,"impl Solution {
    pub fn number_of_substrings(s: String, k: i32) -> i32 {
        let mut ans = 0;
        let s = s.chars().collect::<Vec<char>>();
        let n = s.len();
        let mut cnt = vec![vec![0; 26]; n+1];
        for i in 0..n {
            for j in 0..26 {
                cnt[i+1][j] = cnt[i][j];
            }
            cnt[i+1][s[i] as usize - 'a' as usize] += 1;
        }
        let mut r = 0;
        for l in 0..n {
            while r < n {
                let mut ok = false;
                for i in 0..26 {
                    if cnt[r+1][i] - cnt[l][i] >= k {
                        ok = true;
                        break;
                    }
                }
                if ok {
                    break;
                }
                r += 1;
            }
            if r == n {
                break;
            }
            ans += n - r;
        }
        ans as i32
    }
}",1427835561
tomarin,tomarint,191,3566,rust,"impl Solution {
    pub fn string_sequence(target: String) -> Vec<String> {
        let mut ans = vec![];
        let mut target = target.chars().collect::<Vec<char>>();
        let n = target.len();
        let mut s = vec![];
        for i in 0..n {
            s.push('a');
            ans.push(s.iter().collect());
            for c in 'b'..=target[i] {
                s[i] = c;
                ans.push(s.iter().collect());
            }
        }
        ans
    }
}",1427826607
tomarin,tomarint,191,3603,rust,"const MOD: i64 = 998_244_353; // 998244353
// const MOD: i64 = 1_000_000_007; // 10**9 + 7

#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Mint {
    val: i64,
}

impl Mint {
    pub fn new(n: i64) -> Self {
        let mut new_val = n % MOD + MOD;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }

    pub fn pow(&self, n: i64) -> Self {
        if n == 0 {
            Self { val: 1 }
        } else {
            let mut ret = self.pow(n >> 1);
            ret *= ret;
            if (n & 1) != 0 {
                ret *= *self;
            }
            ret
        }
    }

    pub fn inv(&self) -> Self {
        self.pow(MOD - 2)
    }
}

impl std::fmt::Display for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::fmt::Debug for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::ops::Add for Mint {
    type Output = Self;
    fn add(self, other: Self) -> Self::Output {
        let mut new_val = self.val + other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Sub for Mint {
    type Output = Self;
    fn sub(self, other: Self) -> Self::Output {
        let mut new_val = self.val + MOD - other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Mul for Mint {
    type Output = Self;
    fn mul(self, other: Self) -> Self::Output {
        Self {
            val: (self.val * other.val) % MOD,
        }
    }
}

impl std::ops::Div for Mint {
    type Output = Self;
    fn div(self, other: Self) -> Self::Output {
        if other.val == 0 {
            panic!(""0 division occured."");
        }
        self * other.inv()
    }
}

impl std::ops::AddAssign for Mint {
    fn add_assign(&mut self, other: Self) {
        *self = *self + other;
    }
}

impl std::ops::SubAssign for Mint {
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}

impl std::ops::MulAssign for Mint {
    fn mul_assign(&mut self, other: Self) {
        *self = *self * other;
    }
}

impl std::ops::DivAssign for Mint {
    fn div_assign(&mut self, other: Self) {
        *self = *self / other;
    }
}

impl Solution {
    pub fn find_answer(parent: Vec<i32>, s: String) -> Vec<bool> {
        let s = s.chars().collect::<Vec<char>>();
        let n = s.len();
        let mut to = vec![vec![]; n];
        for i in 0..n {
            if parent[i] != -1 {
                to[parent[i] as usize].push(i as usize);
            }
        }
        let mut dfsstr = vec![];
        let mut size = vec![];
        let mut idx = vec![];
        fn dfs(
            u: usize,
            to: &Vec<Vec<usize>>,
            s: &Vec<char>,
            dfsstr: &mut Vec<char>,
            size: &mut Vec<usize>,
            idx: &mut Vec<usize>,
        ) -> usize {
            let mut siz = 1;
            for &v in to[u].iter() {
                siz += dfs(v, to, s, dfsstr, size, idx);
            }
            dfsstr.push(s[u]);
            size.push(siz);
            idx.push(u);
            siz
        }
        dfs(0, &to, &s, &mut dfsstr, &mut size, &mut idx);
        // dfsstr を逆にしたものをつくる
        let mut dfsstr2 = dfsstr.clone();
        dfsstr2.reverse();

        let mut rh = vec![Mint::new(0); n + 1];
        let mut rh2 = vec![Mint::new(0); n + 1];
        let mut rh_pow = vec![Mint::new(1); n + 1];
        for i in 0..n {
            rh[i + 1] = rh[i] + Mint::new(dfsstr[i] as i64 - 'a' as i64) * rh_pow[i];
            rh2[i + 1] = rh2[i] + Mint::new(dfsstr2[i] as i64 - 'a' as i64) * rh_pow[i];
            rh_pow[i + 1] = rh_pow[i] * Mint::new(26);
        }
        let mut ans = vec![false; n];
        for i in 0..n {
            let r = i;
            let l = r + 1 - size[i];
            // 逆順にした場合
            let r2 = n - 1 - l;
            let l2 = n - 1 - r;
            // [l..=r] が回文かどうかを判定する
            let rh_val = (rh[r + 1] - rh[l]) / rh_pow[l];
            let rh_val2 = (rh2[r2 + 1] - rh2[l2]) / rh_pow[l2];
            if rh_val == rh_val2 {
                ans[idx[i]] = true;
            }
        }
        ans
    }
}",1427918539
tomarin,tomarint,191,3607,rust,"impl Solution {
    pub fn min_operations(nums: Vec<i32>) -> i32 {
        // Find the minimum divisor
        fn min_divisor(num: i32) -> i32 {
            for i in 2..=num {
                if i * i > num {
                    break;
                }
                if num % i == 0 {
                    return i;
                }
            }
            num
        }
        let mut nums2 = nums.clone();
        let n = nums.len();
        for i in 0..n {
            nums2[i] = min_divisor(nums[i]);
        }
        let mut dp = vec![vec![i32::MAX as i64; 2]; n];
        dp[0][0] = 0;
        dp[0][1] = 1;
        for i in 1..n {
            if nums[i-1] <= nums[i] {
                dp[i][0] = dp[i][0].min(dp[i-1][0]);
            }
            if nums2[i-1] <= nums[i] {
                dp[i][0] = dp[i][0].min(dp[i-1][1]);
            }
            if nums[i-1] <= nums2[i] {
                dp[i][1] = dp[i][1].min(dp[i-1][0] + 1);
            }
            if nums2[i-1] <= nums2[i] {
                dp[i][1] = dp[i][1].min(dp[i-1][1] + 1);
            }
        }
        let ans = dp[n-1][0].min(dp[n-1][1]);
        if ans >= i32::MAX as i64 {
            -1
        } else {
            ans as i32
        }
    }
}",1427861350
psb0623,psb0623,192,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for(int i=0;i<n;i++) {
            map<char, int> m;
            int mx = 0;
            for(int j=i;j<n;j++) {
                mx = max(mx, ++m[s[j]]);
                if(mx >= k) ans++;
            }
        }
        return ans;
    }
};",1427827573
psb0623,psb0623,192,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string t;
        vector<string> ans;
        for(char c:target) {
            t.push_back(' ');

            for(int i=0;i<=c-'a';i++) {
                t.back() = 'a' + i;
            ans.push_back(t);

            }
        }
        return ans;
    }
};",1427825056
psb0623,psb0623,192,3603,cpp,"class Solution {
public:
    vector<int> v[100010];
    string t;
    string ss;
    int in[100010], out[100010], cnt;
    // reference: https://cp-algorithms.com/string/manacher.html
    vector<int> f(string s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    void dfs(int cur) {
        in[cur] = cnt;
        for(int nxt:v[cur]) dfs(nxt);
        out[cur] = cnt;
        t.push_back(ss[cur]);
        t.push_back('*');
        cnt+=2;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> ans(n);
        ss = s;
        for(int i=1;i<n;i++) {
            v[parent[i]].push_back(i);
        }
        dfs(0);
        vector<int> r = f(t);
        //cout << t << ""\n"";
        //for(int i=0;i<t.size();i++) cout << r[i] << "" "";
        //cout << ""\n"";
        for(int i=0;i<n;i++) { //cout << in[i] << "" "" << out[i] << ""\n""; {
            int m = (out[i] + in[i]) / 2;
            int R = out[i] - m;
            // cout << i << "" "" << r[m] << "" "" << R << ""\n"";
            ans[i] = r[m] > R;
        }

        return ans;
    }
};",1427885881
psb0623,psb0623,192,3607,cpp,"class Solution {
public:
    int p[1000010] = {0, };
    void sieve() {
        // memset(p, 0, sizeof(p));
        for(long long i=2;i*i<1000010;i++) {
            if(!p[i]) {
                for(long long j=i*i;j<1000010;j+=i) if(!p[j]) p[j] = i;
            }
        }
    }
    int minOperations(vector<int>& nums) {
        sieve();
        reverse(nums.begin(), nums.end()); ///reverse();
        int n = nums.size();
        int ans = 0;
        for(int i=1;i<n;i++) {
            if(nums[i-1] < nums[i]) {
                if(p[nums[i]]) {
                    nums[i] = p[nums[i]];
                    if(nums[i-1] < nums[i]) return -1;
                    ans++;
                } else return -1;
            }
        }
        return ans;
    }
};",1427844518
Sharujan,Morgoth712,193,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int total = 0;
        for (int i = 0; i < s.size(); i++) {
            vector<int> counts (26, 0);
            int validK = 0;
            for (int j = i; j < s.size(); j++ ) {
                counts[s[j] - 'a']++;
                if (counts[s[j] - 'a'] == k) {
                    validK++;
                }
                if (validK > 0) {
                    total++;
                }
                //cout << i << j << total << endl;
            }
        }
        return total;
    }
};",1427831736
Sharujan,Morgoth712,193,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string output = """";
        vector<string> outputList;
        for (int i = 0; i < target.size(); i++) {
            output += 'a';
            outputList.push_back(output);
            for (int j = 1; j <= target[i] - 'a'; j++) {
                output[i] = char(int('a') + j);
                outputList.push_back(output);
            }
        }
        return outputList;
    }
};",1427825381
Sharujan,Morgoth712,193,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector<vector<int> > adjList (parent.size());
        for (int i = 1; i < parent.size(); i++) {
            adjList[parent[i]].push_back(i);
        }
        vector<vector<int> > nodeRanges (parent.size());
        stack<int> dfs;
        dfs.push(0);
        string dfsStr = """";
        int curIndex = 0;
        while(!dfs.empty()) {
            int top = dfs.top();
            if (nodeRanges[top].size() == 1) {
                nodeRanges[top].push_back(curIndex);
                dfs.pop();
                continue;
            }
            nodeRanges[top].push_back(curIndex);
            dfsStr += s[top];
            curIndex++;
            for (int i = 0; i < adjList[top].size(); i++) {
                int newNode = adjList[top][i];
                dfs.push(newNode);
            }
        }
        vector<long long> forwardHash1 (parent.size(), 0);
        vector<long long> reverseHash1 (parent.size(), 0);
        vector<long long> forwardHash2 (parent.size(), 0);
        vector<long long> reverseHash2 (parent.size(), 0);
        vector<long long> power1 (parent.size(), 0);
        vector<long long> power2 (parent.size(), 0);
        long long base1 = 1;
        long long base2 = 1; 
        long long MOD = 1e9 + 7;   
        long long endIndex = parent.size()-1;
        for (int i = 0; i < parent.size(); i++) {
            forwardHash1[i] += (long long)(dfsStr[i]) * base1;
            forwardHash1[i] %= MOD; 
            reverseHash1[endIndex-i] += (long long)(dfsStr[endIndex - i]) * base1;
            reverseHash1[endIndex-i] %= MOD;
            forwardHash2[i] += (long long)(dfsStr[i]) * base2;
            forwardHash2[i] %= MOD; 
            reverseHash2[endIndex-i] += (long long)(dfsStr[endIndex - i]) * base2;
            reverseHash2[endIndex-i] %= MOD;
            if (i > 0) {
                forwardHash1[i] += forwardHash1[i-1];
                forwardHash1[i] %= MOD;
                forwardHash2[i] += forwardHash2[i-1];
                forwardHash2[i] %= MOD;
            }
            if (endIndex - i < endIndex) {
                reverseHash1[endIndex - i] += reverseHash1[endIndex-i+1];
                reverseHash1[endIndex - i] %= MOD;
                reverseHash2[endIndex - i] += reverseHash2[endIndex-i+1];
                reverseHash2[endIndex - i] %= MOD;
            }
            power1[i] = base1;
            power2[i] = base2;
            base1 *= 31;
            base2 *= 53;
            base1 %= MOD;
            base2 %= MOD;
        }

        vector<bool> output (parent.size());
        for (int i = 0; i < nodeRanges.size(); i++) {
            int start = nodeRanges[i][0];
            int end = nodeRanges[i][1];
            output[i] = false;
            int revPower = endIndex - (end-1); 
            long long fHash1 = forwardHash1[end-1];
            long long fHash2 = forwardHash2[end-1];
            long long rHash1 = reverseHash1[start];
            long long rHash2 = reverseHash2[start];
            if (start > 0) {
                fHash1 -= forwardHash1[start-1];
                fHash2 -= forwardHash2[start-1];
                if (fHash1 < 0) {
                    fHash1 += MOD;
                }
                if (fHash2 < 0) {
                    fHash2 += MOD;
                }
            }
            if (end-1 < endIndex) {
                rHash1 -= reverseHash1[end];
                rHash2 -= reverseHash2[end];
                if (rHash1 < 0) {
                    rHash1 += MOD;
                }
                if (rHash2 < 0) {
                    rHash2 += MOD;
                }
            }
           
            if (start < revPower) {
                long long powDiff = revPower - start;
                fHash1 *= power1[powDiff];
                fHash2 *= power2[powDiff];
                fHash1 %= MOD;
                fHash2 %= MOD;
            } else if (revPower < start) {
                long long powDiff = start - revPower;
                rHash1 *= power1[powDiff];
                rHash2 *= power2[powDiff];
                rHash1 %= MOD;
                rHash2 %= MOD;
            }
            if (fHash1 == rHash1 && fHash2 == rHash2) {
                output[i] = true;
            } else {
                output[i] = false;
            }
        }

        return output;
    }
};",1427911695
Sharujan,Morgoth712,193,3607,cpp,"class Solution {
public:
    int gDivisor(int val) {
        for (int i = 2; i <= sqrt(val)+1; i++) {
            if (val % i == 0) {
                int divisor1 = i;
                int divisor2 = val/i;
                return max(divisor1, divisor2);
            }
        }
        return -1;
    }

    int minOperations(vector<int>& nums) {
        if (nums.size() == 1) {return 0;}
        int operations = 0;
        for (int i = nums.size()-2; i >= 0; i--) {
            while (nums[i] > nums[i+1]) {
                nums[i] /= gDivisor(nums[i]);
                if (nums[i] < 0) {
                    return -1;
                }
                operations++;
            }
        }
        return operations;
    }
};",1427844831
ddiibboo,ddiibboo,194,3502,java,"class Solution {
    public int numberOfSubstrings(String S, int k) {
        int ans = 0;
        char[] s = S.toCharArray();
        Map<Character, Integer> cntC = new HashMap<>();
        TreeMap<Integer, Integer> cntI = new TreeMap<>();
        for (int i = 0, j = 0; i < s.length; ++i) {
            while (j < s.length) {
                if (!cntI.isEmpty() && cntI.lastKey() >= k) break;
                
                int cur = cntC.getOrDefault(s[j], 0);
                cntC.put(s[j], cur + 1);

                int x = cntI.getOrDefault(cur, 0);
                if (x == 1) {
                    cntI.remove(cur);
                } else if (x > 1) {
                    cntI.put(cur, x - 1);
                }
                cntI.put(cur + 1, cntI.getOrDefault(cur + 1, 0) + 1);
                ++j;
            }

            if (!cntI.isEmpty() && cntI.lastKey() >= k) ans += s.length - j + 1;
            int cur = cntC.getOrDefault(s[i], 0);
            if (cur == 1) cntC.remove(s[i]);
            else cntC.put(s[i], cur - 1);
            int x = cntI.getOrDefault(cur, 0);
            if (x == 1) {
                cntI.remove(cur);
            } else if (x > 1) {
                cntI.put(cur, x - 1);
            }
            cntI.put(cur - 1, cntI.getOrDefault(cur - 1, 0) + 1);
        }

        return ans;
    }
}",1427854174
ddiibboo,ddiibboo,194,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        for (int i = 0; i < target.length(); ++i) {
            char c = 'a';
            while (c <= target.charAt(i)) {
                ans.add(target.substring(0, i) + c);
                c = (char) (c + 1);
            }
        }
        return ans;
    }
}",1427827066
ddiibboo,ddiibboo,194,3603,java,"class Solution {

    int mod = 999983;
    int base = 130;

    boolean[] ans;
    Map<Integer, List<Integer>> map;
    int n;
    char[] s;
    int[] rc;

    public boolean[] findAnswer(int[] parent, String S) {
        n = parent.length;
        map = new HashMap<>();
        s = S.toCharArray();
        for (int i = 1; i < n; ++i) {
            map.computeIfAbsent(parent[i], x -> new ArrayList<>()).add(i);
        }
        ans = new boolean[n];
        rc = new int[n + 1];
        rc[0] = 1;
        for (int i = 1; i <= n; ++i) rc[i] = (rc[i - 1] * base) % mod;

        dfs(0);  

        return ans;
    }

    private long[] dfs(int u) {
        List<Integer> c = map.get(u);
        if (c == null) {
            ans[u] = true;
            return new long[]{s[u], s[u], 1};
        }

        Collections.sort(c);
        List<long[]> vals = new ArrayList<>();
        for (int v : c) {
            vals.add(dfs(v));
        }

        long val1 = 0, val2 = s[u];
        for (int i = 0; i < vals.size(); ++i) {
            int idx = (int) vals.get(i)[2];
            val1 = (val1 * rc[idx] % mod + vals.get(i)[0]) % mod;
        }
        val1 = (val1 * base + s[u]) % mod; 
        int tot = 1;
        for (int i = vals.size() - 1; i >= 0; --i) {
            int idx = (int) vals.get(i)[2];
            val2 = (val2 * rc[idx] % mod + vals.get(i)[1]) % mod;
            tot += idx;
        }
        // System.out.println(String.format(""u = %d, val1 = %d, val2 = %d, tot = %d"", u, val1, val2, tot));
        ans[u] = val1 == val2;
        return new long[]{val1, val2, tot};
    }
}",1427912245
ddiibboo,ddiibboo,194,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        Map<Integer, Integer> rc = new HashMap<>();
        int ans = 0;
        for (int i = nums.length - 2; i >= 0; --i) {
            if (nums[i] <= nums[i + 1]) continue;
            int d;
            if (rc.containsKey(nums[i])) {
                d = rc.get(nums[i]);
            } else {
                d = calc(nums[i]);
                rc.put(nums[i], d);
            }

            if (d == -1 || d > nums[i + 1]) return -1;
            ++ans;
            nums[i] = d;
        }
        return ans;
    }

    private int calc(int x) {
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) return i;
        }
        return -1;
    }
}",1427871833
ConnectedPuddle,ConnectedPuddle,195,3502,csharp,"public class Solution {
    public int NumberOfSubstrings(string s, int k) {
        int[] counts = new int[26];
        int n = s.Length;
        int result = 0;
        for (int w = k; w <= n; w++)
        {
            int bigCount = 0;
            for (int i = 0; i < w; i++)
            {
                counts[s[i] - 'a']++;
                if (counts[s[i] - 'a'] == k)
                {
                    bigCount++;
                }
            }
            if (bigCount > 0)
            {
                result++;
            }
            for (int i = w; i < n; i++)
            {
                counts[s[i-w] - 'a']--;
                if (counts[s[i-w] - 'a'] == k-1)
                {
                    bigCount--;
                }
                counts[s[i] - 'a']++;
                if (counts[s[i] - 'a'] == k)
                {
                    bigCount++;
                }
                if (bigCount > 0)
                {
                    result++;
                }
            }
            for (int i = 0; i < 26; i++)
            {
                counts[i] = 0;
            }
        }
        return result;
    }
}",1427838053
ConnectedPuddle,ConnectedPuddle,195,3566,csharp,"public class Solution {
    public IList<string> StringSequence(string target) {
        List<string> result = new();
        string next = """";
        for (int i = 0; i < target.Length; i++)
        {
            for (char c = 'a'; c <= target[i]; c++)
            {
                result.Add(next + c);
            }
            next += target[i];
        }
        return result;
    }
}",1427825488
ConnectedPuddle,ConnectedPuddle,195,3603,csharp,"public class Solution {
    public bool[] FindAnswer(int[] parent, string s) {
        long p = 1_000_000_007;
        long b = 101;
        int n = parent.Length;
        long[] powers = new long[n];
        powers[0] = 1;
        for (int i = 1; i < n; i++)
        {
            powers[i] = (powers[i-1] * b) % p;
        }
        var nodes = new Node[n];
        for (int i = 0; i < n; i++)
        {
            nodes[i] = new();
            nodes[i].c = s[i];
        }
        for (int i = 1; i < n; i++)
        {
            nodes[parent[i]].children.Add(i);
        }
        var result = new bool[n];
        Process(0);
        // for (int i = 0; i < n; i++)
        // {
        //     Console.WriteLine($""{nodes[i].forward_hash}, {nodes[i].backward_hash}"");
        // }
        return result;

        void Process(int i)
        {
            Node node = nodes[i];
            if (node.children.Count == 0)
            {
                node.size = 1;
                node.forward_hash = node.c - 'a' + 1;
                node.backward_hash = node.c - 'a' + 1;
                result[i] = true;
                return;
            }
            long forward_hash = 0;
            long backward_hash = 0;
            int size = 0;
            foreach(int j in node.children)
            {
                Process(j);
                Node child = nodes[j];
                forward_hash = (forward_hash + ((child.forward_hash * powers[size]) % p)) % p;
                backward_hash = (((backward_hash * powers[child.size]) % p) + child.backward_hash) % p;
                size += child.size;
            }
            backward_hash = (backward_hash * b + node.c - 'a' + 1) % p;
            forward_hash = (forward_hash + powers[size] * (node.c - 'a' + 1)) % p;
            node.size = size + 1;
            node.forward_hash = forward_hash;
            node.backward_hash = backward_hash;
            result[i] = forward_hash == backward_hash;
        }
    }

    public class Node
    {
        public List<int> children = new();
        public int size;
        public long forward_hash;
        public long backward_hash;
        public char c;
    }
}",1427895439
ConnectedPuddle,ConnectedPuddle,195,3607,csharp,"public class Solution {
    public int MinOperations(int[] nums) {
        int result = 0;
        int n = nums.Length;
        for (int i = n-2; i >= 0; i--)
        {
            if (nums[i] <= nums[i+1])
            {
                continue;
            }
            int x = Transform(nums[i]);
            if (x > nums[i+1])
            {
                return -1;
            }
            nums[i] = x;
            result++;
        }
        return result;
    }

    public int Transform(int x)
    {
        if (x == 1)
        {
            return x;
        }
        for (int d = 2; d <= Math.Sqrt(x); d++)
        {
            if (x % d == 0)
            {
                return d;
            }
        }
        return x;
    }
}",1427845510
Krishna Kant,Krishna_3747,196,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for(int i=0;i<s.size();i++)
        {
            map<char,int>mp;
            for(int j=i;j<s.size();j++)
            {
                mp[s[j]]++;
                if(mp[s[j]] == k)
                {
                    ans += s.size() - j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427832990
Krishna Kant,Krishna_3747,196,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        int n = s.size();
        string str = """";
        vector<string>v;
        for(int i=0;i<n;i++)
        {
            str += 'a';
            v.push_back(str);
            while(str[i] != s[i])
            {
                str[i]++;
                v.push_back(str);
            }
        }
        return v;
    }
};",1427827172
Krishna Kant,Krishna_3747,196,3603,cpp,"class Solution {
public:
    string preprocessString(const string& s) 
    {
        string transformed = ""#"";
        for (char c : s) 
        {
            transformed += c;
            transformed += ""#"";
        }
        return transformed;
    }

    // Manacher's Algorithm to preprocess and find all palindromic substrings
    vector<int> manacher(const string& s) {
        string t = preprocessString(s);
        int n = t.length();
        vector<int> p(n, 0);  // Array to store radius of the palindrome at each center
        int center = 0, right = 0;

        for (int i = 0; i < n; i++) {
            int mirror = 2 * center - i;  // Mirror index of i with respect to center

            if (i < right) {
                p[i] = min(right - i, p[mirror]);
            }

            // Expand around center i
            while (i + 1 + p[i] < n && i - 1 - p[i] >= 0 && t[i + 1 + p[i]] == t[i - 1 - p[i]]) {
                p[i]++;
            }

            // Update center and right boundary
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }
        }

        return p;
    }

    // Function to check if a substring is a palindrome
    bool isSubstringPalindrome(const vector<int>& p, int l, int r, int n) {
        // Convert the original indices (l, r) to the transformed string indices
        int new_l = 2 * l + 1;
        int new_r = 2 * r + 1;
        int center = (new_l + new_r) / 2;
        int radius = (new_r - new_l) / 2;

        // Check if the palindrome centered at 'center' covers the entire substring
        return p[center] >= radius;
    }
    void dfs(int node, vector<int>adj[], vector<pair<int,int>>&v, int &x, string &str, string &s)
    {
        v[node].first = x;
        for(auto it: adj[node])
        {
            dfs(it, adj, v, x, str, s);
        }
        str.push_back(s[node]);
        v[node].second = x++;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        vector<pair<int,int>>v(n);
        vector<int>adj[n];
        for(int i=0;i<parent.size();i++)
        {
            if(parent[i] != -1)
            {
                adj[parent[i]].push_back(i);
            }
        }
        for(int i=0;i<n;i++)sort(adj[i].begin(), adj[i].end());
        string str = """";
        int x = 0;
        dfs(0, adj, v, x, str, s);
        vector<int> p = manacher(str);
        vector<bool>ans(n);
        for(int i=0;i<n;i++)
        {
            ans[i] = isSubstringPalindrome(p, v[i].first, v[i].second, n);
        }
        return ans;
    }
};",1427913051
Krishna Kant,Krishna_3747,196,3607,cpp,"class Solution {
public:
    int func(int &n, int k)
    {
        int cnt = 0;
        while(n > k)
        {
            int x = n;
            for(int i=2;i<=sqrt(n);i++)
            {
                if(n % i == 0)
                {
                    n = i;
                    cnt++;
                    break;
                    
                }
            }
            if(n == x)return -1;
        }
        return cnt;
    }
    int minOperations(vector<int>& arr) {
        int n = arr.size();
        int ans = 0;
        for(int i=n-2;i>=0;i--)
        {
            int k = func(arr[i], arr[i+1]);
            if(k == -1)return -1;
            ans += k;
        }
        return ans;
    }
};",1427850117
Sam Huang,CelonyMire,197,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int cnt[26]{};
            for (int j = i; j < n; j++) {
                cnt[s[j] - 'a']++;
                bool have = false;
                for (int a = 0; a < 26; a++) {
                    have |= cnt[a] >= k;
                }
                ans += have;
            }
        }
        return ans;
    }
};",1427834142
Sam Huang,CelonyMire,197,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        int n = t.size();
        vector<string> ans;
        string cur;
        for (int i = 0; i < n; i++) {
            cur.push_back('a');
            ans.push_back(cur);
            while (cur.back() != t[i]) {
                cur.back()++;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427829659
Sam Huang,CelonyMire,197,3603,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
class Solution {
public:
  vector<bool> findAnswer(vector<int> &par, string s) {
    const __uint128_t M = (1ULL << 61) - 1, P = 257;
    int n = par.size();
    vector g(n, vector<int>());
    for (int i = 1; i < n; i++) {
      g[par[i]].push_back(i);
    }
    for (int i = 0; i < n; i++) {
      ranges::sort(g[i]);
    }
    vector p(n + 1, uint64_t(1));
    for (int i = 1; i <= n; i++) {
      p[i] = __uint128_t(p[i - 1]) * P % M;
    }
    vector h(n, pair<int, __uint128_t>{1, 0});
    auto dfs = [&](auto &self, int u) -> void {
      __uint128_t pw = 1;
      for (int v : g[u]) {
        self(self, v);
        h[u].first += h[v].first;
        h[u].second += h[v].second * pw % M;
        h[u].second %= M;
        pw = pw * p[h[v].first] % M;
      }
      h[u].second += s[u] * pw % M;
      h[u].second %= M;
    };
    dfs(dfs, 0);
    vector h2(n, pair<int, __uint128_t>{1, 0});
    auto dfs2 = [&](auto &self, int u) -> void {
      h2[u].second = __uint128_t(s[u]) % M;
      __uint128_t pw = P;
      ranges::reverse(g[u]);
      for (int v : g[u]) {
        self(self, v);
        h2[u].first += h2[v].first;
        h2[u].second += h2[v].second * pw % M;
        h2[u].second %= M;
        pw = pw * p[h2[v].first] % M;
      }
    };
    dfs2(dfs2, 0);
    vector ans(n, false);
    for (int i = 0; i < n; i++) {
      ans[i] = h[i].second == h2[i].second;
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::findAnswer); // CHANGE FOR PROBLEM
}
#endif",1427896123
Sam Huang,CelonyMire,197,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

#ifdef LC_LOCAL
#include ""parser.hpp""
#else
#define dbg(...)
#endif

// ----- CHANGE FOR PROBLEM -----
struct sieve {
  vector<int> primes, spd;
  sieve(int n) : spd(n + 1) {
    iota(spd.begin(), spd.end(), 0);
    for (int i = 2; i <= n; i++) {
      if (spd[i] == i)
        primes.push_back(i);
      for (int j = 0; j < (int)primes.size() && i * primes[j] <= n; j++) {
        spd[i * primes[j]] = primes[j];
        if (i % primes[j] == 0)
          break;
      }
    }
  }
  bool is_prime(int x) {
    return x > 1 && spd[x] == x;
  }
  vector<int> divisors(int x) {
    vector<int> ans;
    while (x > 1)
      for (int d = spd[x], sd = spd[x], n = ans.size(); spd[x] == sd; d *= sd, x /= sd) {
        for (int i = 0; i < n; i++)
          ans.push_back(d * ans[i]);
        ans.push_back(d);
      }
    return ans;
  }
};
sieve sv(1e6);

class Solution {
public:
  int minOperations(vector<int> &a) {
    int n = a.size();
    int ans = 0;
    for (int i = n - 1, p = 1e9; i >= 0; i--) {
      int x = a[i];
      while (x > p && !sv.is_prime(x)) {
        x /= x / sv.spd[x];
        ans++;
      }
      if (x > p) {
        return -1;
      }
      p = x;
    }
    return ans;
  }
};
// ----- CHANGE FOR PROBLEM -----

#ifdef LC_LOCAL
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  exec(&Solution::minOperations); // CHANGE FOR PROBLEM
}
#endif",1427847998
dwang33,dwang33,198,3502,python3,"from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        i = 0
        counts = defaultdict(int)
        ans = 0
        for j in range(len(s)):
            curr = s[j]
            counts[curr] += 1
            while i <= j and max(counts.values()) >= k:
                counts[s[i]] -= 1
                i += 1
            ans += i
        return ans",1427835110
dwang33,dwang33,198,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        curr = 'a'
        prev = ''
        ans = []
        for i in range(len(target)):
            while curr != target[i]:
                ans.append(prev + curr)
                curr = chr(ord(curr) + 1)
            ans.append(prev + curr)
            prev = prev + curr
            curr = 'a'
        return ans
                
",1427826211
dwang33,dwang33,198,3603,python3,"from collections import defaultdict
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def manacher_template(s):
            n, P, C, R = (len(s), [0] * len(s), 0, 0)
            for i in range(n):
                mirror = 2 * C - i
                if i < R:
                    P[i] = min(R - i, P[mirror])
                else:
                    P[i] = 0
                while i + P[i] + 1 < n and i - P[i] -1 >=0 and s[i + P[i] +1] == s[i - P[i] -1]:
                    P[i] += 1
                if i + P[i] > R:
                    C = i
                    R = i + P[i]
            return P
        children = defaultdict(list)
        for i, p in enumerate(parent):
            if i == 0:
                continue
            children[p].append(i)
        indices = dict()
        minindex = dict()
        maxindex = dict()
        string = []
        def dfs(root):
            thismin = float('inf')
            thismax = -float('inf')
            for child in children[root]:
                dfs(child)
                thismin = min(thismin, minindex[child])
                thismax = max(thismax, maxindex[child])
            string.append('#')
            indices[root] = len(string)
            minindex[root] = min(thismin, indices[root])
            maxindex[root] = max(thismax, indices[root])
            string.append(s[root])
        dfs(0)
        string.append('#')
        mchr = manacher_template(string)
        ans = []
        # print(indices)
        # print(minindex)
        # print(maxindex)
        # print(mchr)
        for i in range(len(s)):
            lo, hi = minindex[i], maxindex[i]
            mid = (lo + hi) // 2
            expand = mchr[mid]
            ans.append((lo >= mid - expand) and (hi <= mid + expand))
            # print(i, mid, expand)
        return ans
        
            
        ",1427921712
dwang33,dwang33,198,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def getbp(x):
            for i in range(2, int(x ** 0.5) + 2):
                if x % i == 0:
                    return i
            return 1
        ans = 0
        for i in range(len(nums) - 2, -1, -1):
            num = nums[i]   
            while num > nums[i + 1]:
                bp = getbp(num)
                if bp == 1:
                    return -1
                num = nums[i] = bp
                ans += 1
        return ans
            
",1427858855
Chandrachur M,Chandrachur,203,3502,cpp,"class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    int n = (int)s.length();
    int res = 0;
    
    int tail = 0, head = -1;
    vector<int> freq(26, 0);
    while(tail < n) {
      while(head + 1 < n && *max_element(freq.begin(), freq.end()) < k && freq[s[head + 1] - 'a'] + 1 <= k) {
        head++;
        freq[s[head] - 'a']++;
      }
      
      if(*max_element(freq.begin(), freq.end()) == k) {
        res += (n - head);
        // cout << tail << ""->"" << head << endl;
      }
      
      if(tail > head) {
        tail++;
        head = tail - 1;
      } else {
        freq[s[tail] - 'a']--;
        tail++;
      }
    }
    return res;
  }
};",1427841431
Chandrachur M,Chandrachur,203,3566,cpp,"class Solution {
public:
  vector<string> stringSequence(string target) {
    int n = (int)target.length();
    vector<string> res;
    for(int i = 0; i < n; i++) {
      string prev = (res.empty() ? """" : res.back());
      for(char c = 'a'; c <= target[i]; c++) {
        res.push_back(prev + c);
      }
    }
    return res;
  }
};",1427825911
Chandrachur M,Chandrachur,203,3603,cpp,"vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#""); 
  //   for(auto & c : t) cout << c << "" "";
  // cout << endl;
    return vector<int>(begin(res) + 1, end(res) - 1);
}

class Solution {
  int time;
  vector<int> in, out;
  void dfs(int node, string &dfsStr, vector<vector<int>> &adj, string &s) {
    in[node] = time;
    
    for(auto &adjNode : adj[node]) {
      dfs(adjNode, dfsStr, adj, s);
    }
    dfsStr.push_back(s[node]);
    out[node] = time++;
  }
  
public:
  vector<bool> findAnswer(vector<int>& parent, string s) {
    int n = (int)s.length();
    vector<bool> res(n);
    time = 0;
    in.resize(n);
    out.resize(n);
    
    vector<vector<int>> adj(n);
    for(int i = 0; i < n; i++) {
      if(parent[i] != -1) {
        adj[parent[i]].push_back(i);
      }
    }
    
    string dfsStr = """";
    dfs(0, dfsStr, adj, s);
    
    vector<int> mana = manacher(dfsStr);
    
    // cout << dfsStr << endl;
//     cout << 0 << "" "";
//     for(auto &it : mana) cout << it << "" "";
//     cout << endl;
//     cout << 0 << "" "";
//     for(int i = 0; i < mana.size(); i++) cout << i << "" "";
//     cout << endl;
    
//     for(int i = 0; i < n; i++) {
//       cout << in[i] << ""->"" << out[i] << endl;
//     }
    
    for(int i = 0; i < n; i++) {
      int startInd = in[i] * 2;
      int endInd = out[i] * 2;
      int mid = (startInd + endInd) / 2;
      // cout << mid << endl;
      
      if(mana[mid] >= out[i] - in[i] + 1) {
        res[i] = true;
      } 
    }
    return res;
  }
};",1427923008
Chandrachur M,Chandrachur,203,3607,cpp,"int N = 1e6 + 10;
vector<int> isPrime(N);
vector<int> smallestDivisor(N);
bool done = false;

void sieve() {
  if(done) {
    return;
  }
  
  done = true;
  for(int i = 0; i < N; i++) {
    isPrime[i] = 1;
    smallestDivisor[i] = i;
  }
  isPrime[0] = isPrime[1] = 0;
  for(int i = 2; i < N; i++) {
    if(isPrime[i]) {
      for(int j = 2 * i; j < N; j += i) {
        isPrime[j] = 0;
        if(smallestDivisor[j] == j) {
          smallestDivisor[j] = i;
        }
      }
    }
  }
}

class Solution {
public:
  int minOperations(vector<int>& nums) {
    sieve();
    int n = (int)nums.size();
    int res = 0;
    int prev = 1e9;
    for(int i = n - 1; i >= 0; i--) {
      int curr = nums[i];
      if(curr > prev) {
        if(smallestDivisor[curr] != curr) {
          curr = smallestDivisor[curr];
        }
        
        if(curr > prev) {
          return -1;
        } else {
          res++;
        }
      }
      prev = curr;
    }
    return res;
  }
};",1427858766
BZH110,BZH110,206,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int l = 0, t = 0, ans = 0, n = s.size();
        int cnt[26]{0};
        for(int i=0;i<n;i++){
            cnt[s[i] - 'a']++;
            if(cnt[s[i] - 'a'] == k){
                t++;
            }
            while(l < i && (t > 0 && cnt[s[l] - 'a'] < k || cnt[s[l] - 'a'] == k && t > 1 || cnt[s[l] - 'a'] > k)){
                if(cnt[s[l] - 'a'] == k)
                    t--;
                cnt[s[l] - 'a']--;
                l++;
            }
            if(t)
                ans += l + 1;
        }
        return ans;
    }
};",1427883662
BZH110,BZH110,206,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ret;
        int n = target.size();
        for(int i=0;i<n;i++){
            for(char j = 'a';j<=target[i];j++)
                ret.push_back(target.substr(0, i) + j);
        }
        return ret;
    }
};",1427898433
BZH110,BZH110,206,3603,cpp,"class Solution {
public:
    using ll = long long;
    long long mypow(long long a, long long b, long long mod) {
        a %= mod;
        if (b == 0)
            return 1;
        if (b == 1)
            return a;
        if (b % 2 == 0)
            return mypow((a * a) % mod, b / 2, mod);
        return (a * mypow((a * a) % mod, b / 2, mod)) % mod;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> child(n);
        for(int i=0;i<n;i++){
            if(parent[i] != -1){
                child[parent[i]].push_back(i);
            }
        }
        for(int i=0;i<n;i++){
            sort(child[i].begin(), child[i].end());
        }
        vector<bool> ans(n, false);
        int base = 1313, mod = 1e9 + 7;
        function<tuple<ll,ll,int>(int)> dfs = [&](int now)->tuple<ll,ll,int>{
            tuple<int,int,int> ret = {0, 0, 0};
            vector<ll> front, back, size;
            for(auto next:child[now]){
                auto [f, b, s] = dfs(next);
                front.push_back(f);
                back.push_back(b);
                size.push_back(s);
            }
            ll tf = 0, tb = 0, ts = 0;
            for(int i=0;i<front.size();i++){
                tf += (front[i] * mypow(base, ts, mod)) % mod;
                tf %= mod;
                ts += size[i];
            }
            tf += s[now] * mypow(base, ts, mod);
            tf %= mod;

            tb = s[now];
            ts = 1;
            reverse(back.begin(), back.end());
            reverse(size.begin(), size.end());
            for(int i=0;i<back.size();i++){
                tb += (back[i] * mypow(base, ts, mod)) % mod;
                tb %= mod;
                ts += size[i];
            }
            if(tf == tb){
                ans[now] = true;
            }
            return {tf, tb, ts};
        };
        dfs(0);
        return ans;
    }
};",1427855651
BZH110,BZH110,206,3607,cpp,"int p[1000001]{0};

void pre(){
    if(p[1] == 0){
        p[1] = 1;
        for(int i=2;i<=1000000;i++){
            int t = 1;
            for(int j=2;j * j <= i;j++){
                if(i % j == 0){
                    t = max({t, j, i / j});
                }
            }
            p[i] = i / t;
        }
    }
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        pre();
        int n = nums.size(), ans = 0;
        for(int i=n-2;i>=0;i--){
            while(p[nums[i]] != nums[i] && nums[i] > nums[i + 1]){
                nums[i] = p[nums[i]];
                ans++;
            }
            if(nums[i] > nums[i + 1])
                return -1;
        }
        return ans;
    }
};",1427866646
Astitva Dubey,Astitva1508,208,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int cnt = 0;
        for(int i=0;i<n;i++){
            vector<int>freq(26,0);
            for(int j=i;j<n;j++){
                freq[s[j]-'a']++;
                if(freq[s[j]-'a']>=k){
                    cnt+=(n-j);
                    break;
                }
            }
        }
        return cnt;
    }
};",1427886524
Astitva Dubey,Astitva1508,208,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string curr;
        vector<string>ans;
        for(auto it:target){
            for(int i='a';i<it;i++){
                curr+=i;
                ans.push_back(curr);
                curr.pop_back();
            }
            curr+=(it);
            ans.push_back(curr);
        }
        return ans;
    }
};",1427886775
Astitva Dubey,Astitva1508,208,3603,cpp,"class Solution {
    vector<set<int>>adj;
    vector<long long>fHash;
    vector<long long>bHash;
    vector<int>len;
    vector<long long>exps;
    vector<bool>ans;
    long long mod = 1e9+7;
    long long base = 31;
    string s;
    void precompute(int n){
        exps.resize(n+1,1);
        for (int i = 1; i <= n; i++){
            exps[i] = (exps[i - 1] * base) % mod;
        }
    }
    
    void dfs(int node){
        for(auto it:adj[node]){
            dfs(it);
        }
        long long currHash = 0;
        long long currLen = 0;
        for(auto it:adj[node]){
            currHash = currHash+(exps[currLen]*fHash[it])%mod;
            currHash%=mod;
            currLen = (currLen+len[it])%mod;
        }
        currHash = currHash+(exps[currLen]*(s[node]-'a'))%mod;
        currHash%=mod;
        currLen = (currLen+1)%mod;
        fHash[node] = currHash;
        len[node] = currLen;
        currLen = 1;
        currHash = s[node]-'a';
        
        for(auto it1 = adj[node].rbegin();it1!=adj[node].rend();it1++){
            int it = *it1;
            currHash = currHash+(exps[currLen]*bHash[it])%mod;
            currHash%=mod;
            currLen = (currLen+len[it])%mod;
        }
        bHash[node] = currHash;
        if(fHash[node]==bHash[node]) ans[node] = 1;
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        this->s = s;
        int n = parent.size();
        adj.resize(n);
        fHash.resize(n,0);
        bHash.resize(n,0);
        len.resize(n,0);
        ans.resize(n,0);
        for(int i=1;i<n;i++){
            adj[parent[i]].insert(i);
        }
        precompute(n);
        dfs(0);
        return ans;
    }
};",1427886255
Astitva Dubey,Astitva1508,208,3607,cpp,"class Solution {
public:
    int minOperations(vector<int> &nums)
{
    int n = nums.size();
    map<int,int>mp;
    for(auto it:nums){
        for(long long i=2;(i*i)<=it;i++){
            if(it%i==0){
                mp[it] = i;
                break;
            }
        }
        if(mp.find(it)==mp.end()) mp[it] = it;
    }
    int cnt = 0;
    for (int i = n - 2; i >= 0; i--)
    {
        if (nums[i] > nums[i + 1])
        {
            if (nums[i] != mp[nums[i]])
            {
                nums[i] = mp[nums[i]];
                cnt++;
            }
        }
        if (nums[i] > nums[i + 1])
        {
            if (nums[i + 1] != mp[nums[i + 1]])
            {
                nums[i + 1] = mp[nums[i + 1]];
                cnt++;
            }
        }
        if (nums[i] > nums[i + 1])
            return -1;
    }
    return cnt;
}
};",1427907101
Enzo de Almeida Rodrigues,enzoar,209,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(); 
        vector<int> f(26); 

        int ans = 0; 
        for (int i = 0; i < n; i++) {
            f.assign(26, 0); 
            int mx = 0;
            for (int j = i; j < n; j++) {
                f[s[j]-'a']++; 
                mx = max(mx, f[s[j]-'a']);
                if (mx >= k) ans++; 
            }
        }
        return ans; 
    }
};",1427826216
Enzo de Almeida Rodrigues,enzoar,209,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string ans; 
        vector<string> res; 
        for (char c : target) {
            ans += 'a'; 
            while (ans.back() < c) {
                res.emplace_back(ans); 
                ans.back()++; 
            }
            res.emplace_back(ans); 
        }
        return res; 
    }
};",1427824350
Enzo de Almeida Rodrigues,enzoar,209,3603,cpp,"class Solution {
public:
    tuple<int, int, int> dfs(vector<vector<int>>& adj, string& s, vector<int>& P, int u, vector<bool>& ans) {
        const int mod = 998244353; 
        vector<int> N, I, S; 
        for (int v : adj[u])  {
            auto [norm, inv, sz_v] = dfs(adj, s, P, v, ans); 
            N.emplace_back(norm); 
            I.emplace_back(inv); 
            S.emplace_back(sz_v); 
        }

        int m = N.size(); 
        int norm = 0, sz = 0; 
        for (int i = 0; i < m; i++) {
            norm = (0ll + norm + 1ll*P[sz]*N[i]%mod) % mod; 
            sz += S[i]; 
        }

        int inv = 0; 
        sz = 0; 
        for (int i = m-1; i >= 0; i--) {
            inv = (0ll + inv + 1ll*P[sz]*I[i]%mod) % mod; 
            sz += S[i]; 
        }

        norm = (norm + 1ll * (s[u]-'a'+1) * P[sz]%mod + mod) % mod; 
        inv = (1ll * inv * P[1] % mod + (s[u]-'a'+1)) % mod; 
        sz++; 
        ans[u] = norm == inv; 
        return tuple<int, int, int>{norm, inv, sz}; 
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size(); 
        vector<vector<int>> adj(n); 
        for (int i = 1; i < n; i++) {
            adj[parent[i]].emplace_back(i); 
        }
        const int p = 29; 
        vector<int> P(n + 1); 
        P[0] = 1; 
        const int mod = 998244353; 
        for (int i = 1; i <= n; i++) P[i] = 1ll * P[i-1] * p % mod; 

        vector<bool> ans(n); 
        dfs(adj, s, P, 0, ans); 
        return ans; 
    }
};",1427898729
Enzo de Almeida Rodrigues,enzoar,209,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        int n = a.size();
        int ans = 0;
        for (int i = n - 1; i > 0; i--) {
            if (a[i-1] > a[i]) {
                for (int j = 2; j * j <= a[i-1]; j++) {
                    if (a[i-1]%j == 0) {
                        a[i-1] = j; 
                        break; 
                    }
                }
                if (a[i-1] > a[i]) {
                    ans = -1; 
                    break; 
                }
                else ans++; 
            }
        }

        return ans;
    }
};",1427850481
Daniel Chang,danielchandg,210,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        vector<int> cnt(26);
        int f=0, r=0, ans=0;
        for(int i=0; i<n; i++){
            while(!f && r<n){
                if(++cnt[s[r]-'a'] == k) f++;
                r++;
            }
            // cout << i << "" "" << r << endl;
            if(f) ans += n-r+1;
            if(cnt[s[i]-'a']-- == k) f--;
        }
        return ans;
    }
};",1427828936
Daniel Chang,danielchandg,210,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string st;
        vector<string> res;
        for(char c : target){
            for(char b='a'; b<=c; b++){
                st.push_back(b);
                res.push_back(st);
                st.pop_back();
            }
            st.push_back(c);
        }
        return res;
    }
};",1427823968
Daniel Chang,danielchandg,210,3603,cpp,"class Solution {
public:
    
    vector<int> manacher_odd(string &s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    
    vector<int> manacher(string &s) {
        string t;
        for(auto c: s) {
            t += string(""#"") + c;
        }
        t.push_back('#');
        auto res = manacher_odd(t);
        return vector<int>(begin(res) + 1, end(res) - 1);
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        vector<set<int>> adj(n);
        for(int i=1; i<n; i++){
            adj[parent[i]].insert(i);
        }
        vector<int> sz(n);
        string res;
        function<void(int)> dfs1;
        dfs1 = [&](int u){
            sz[u] = 1;
            for(auto v : adj[u]){
                dfs1(v);
                sz[u] += sz[v];
            }
            res.push_back(s[u]);
        };
        dfs1(0);
        assert(res.size() == n);
        auto mana = manacher(res);
        auto isPali = [&](int l, int r){
            int m = l+r;
            return mana[m] >= r-l+1;
        };
        vector<bool> ans(n);
        function<void(int, int, int)> dfs2;
        dfs2 = [&](int u, int l, int r){
            ans[u] = isPali(l, r);
            for(auto v : adj[u]){
                dfs2(v, l, l+sz[v]-1);
                l += sz[v];
            }
        };
        dfs2(0,0,n-1);
        return ans;
    }
};",1427890531
Daniel Chang,danielchandg,210,3607,cpp,"const int M = 1000002;
int f[M+1];

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        int ans=0;
        for(int i=n-2; i>=0; i--){
            while(nums[i] > nums[i+1]){
                if(f[nums[i]] == 0) return -1;
                // cout << nums[i] << "" -> "" << f[nums[i]] << endl;
                nums[i] = f[nums[i]];
                ans++;
                
            }
        }
        return ans;
    }
};

static const int _ = []() {
    for(int i=2; i<=M; i++){
        for(int j=2*i; j<=M; j+=i){
            if(f[j] == 0) f[j] = i;
        }
    }
    cout << ""init\n"";
    return 0;
}();",1427851918
lilPeep,stupidRR,211,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        vector<vector<int>> freq(n+1,vector<int>(26));
        for(int i=1;i<=n;i++)
        {
            freq[i]=freq[i-1];
            freq[i][s[i-1]-'a']++;
        }
        
        int out=0;
        for(int i=1;i<=n;i++)
        {
            int low=1;
            int high=i;
            int pt=0;
            while(low<=high)
            {
                int mid=(low+high)/2;
                
                bool ok=false;
                for(int j=0;j<26;j++)
                {
                    if(freq[i][j]-freq[mid-1][j]>=k)
                        ok=true;
                }
                
                if(ok)
                {
                    pt=mid;
                    low=mid+1;
                }
                else
                    high=mid-1;
            }
            out=out+pt;
        }
        return out;
    }
};",1427835441
lilPeep,stupidRR,211,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string curr="""";
        for(int i=0;i<target.size();i++)
        {
            string tmp="""";
            for(int j=0;j<i;j++)
                tmp+=target[j];
            for(char ex='a';ex<=target[i];ex++)
                result.push_back(tmp+""""+ex);
        }
        return result;
    }
};",1427824390
lilPeep,stupidRR,211,3603,cpp,"class Solution {
    const int mod=998244353;
    long long binpow(long long base,long long ex)
    {
        long long ans=1ll;
        while(ex)
        {
            if(ex%2)
                ans=(ans*base)%mod;
            ex=ex/2;
            base=(base*base)%mod;
        }
        return ans;
    }
    void dfs(int node,int parent,vector<vector<int>>&g,vector<long long>&subtree,vector<long long>&forward,vector<long long>&reverse,string &s)
    {
        subtree[node]=0;
        sort(g[node].begin(),g[node].end());
        for(auto child : g[node])
        {
            if(child==parent)
                continue;

            dfs(child,node,g,subtree,forward,reverse,s);

            forward[node]=(forward[child]*binpow(31ll,subtree[node])+forward[node])%mod;
            reverse[node]=(reverse[child]+reverse[node]*binpow(31ll,subtree[child]))%mod;

            subtree[node]+=subtree[child];
        }
        long long ex=s[node]-'a'+1;
        forward[node]=(ex*binpow(31ll,subtree[node])+forward[node])%mod;
        reverse[node]=(ex+reverse[node]*31ll)%mod;
        subtree[node]++;
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>> g(n);
        for(int i=1;i<n;i++)
            g[ parent[i] ].push_back(i);
        vector<long long> subtree(n);
        vector<long long> forward(n);
        vector<long long> rev(n);
        dfs(0,-1,g,subtree,forward,rev,s);

        vector<bool> cnt(n);
        for(int i=0;i<n;i++)
        {
            if(forward[i]==rev[i])
                cnt[i]=true;
            else
                cnt[i]=false;
        }
        return cnt;
    }
};",1427893690
lilPeep,stupidRR,211,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int mx=*std::max_element(nums.begin(),nums.end());
        vector<int> spf(mx+1);
        for(int i=1;i<=mx;i++)
            spf[i]=i;
 
        for(int i=2;i<=mx;i+=2)
            spf[i]=2;

        for(int i=3;i*i<=mx;i++)
        {
            if(spf[i]==i)
            {
                for(int j=i*i;j<=mx;j+=i)
                {
                    if(spf[j]==j)
                            spf[j]=i;
                }
            }
        }
        
        int n=nums.size();
        vector<int> cache[n];
        for(int i=0;i<n;i++)
        {
            if(nums[i]!=spf[nums[i]])
                cache[i].push_back( spf[nums[i]] );
            cache[i].push_back( nums[i] );
        }
        
        vector< pair<int,int> > dp;
        for(auto ele : cache[ 0 ])
        {
            if(ele==nums[0])
                dp.push_back({ele,0});
            else
                dp.push_back({ele,1});
        }
        
        for(int i=1;i<n;i++)
        {
            vector< pair<int,int> > ndp;
            for(auto ele : cache[ i ])
                ndp.push_back({ele,n+n+n});
            
            int minVal=1e9;
            int ind=0;
            for(int i=0;i<ndp.size();i++)
            {
                while(ind<dp.size())
                {
                    if(dp[ind].first<=ndp[i].first)
                    {
                        minVal=std::min(minVal,dp[ind].second);
                        ind++;
                    }
                    else
                        break;
                }
                
                ndp[i].second=std::min(ndp[i].second,minVal);
                if(i!=ndp.size()-1)
                    ndp[i].second++;
            }
            swap(ndp,dp);
        }
        
        int ans=1e9;
        for(auto &[a,b] : dp)
            ans=std::min(ans,b);
        if(ans>n)
            ans=-1;
        return ans;
    }
};",1427899267
jacksonc,jacksoncai,214,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        l, r = 0, 0
        d = defaultdict(int)
        n = len(s)
        res = 0

        while r < n:
            d[s[r]] += 1

            while any(c >= k for c in d.values()):
                res += n - r
                d[s[l]] -= 1
                if d[s[l]] == 0:
                    del d[s[l]]
                l += 1
            
            r += 1

        return res",1427866555
jacksonc,jacksoncai,214,3566,python3,"class Solution:
    def stringSequence(self, tgt: str) -> List[str]:
        res = []
        cur = """"

        for ch in tgt:
            cur += 'a'
            res.append(cur)
            
            while cur[-1] != ch:
                n = (ord(cur[-1]) - ord('a') + 1) % 26
                cur = cur[:-1] + chr(n + ord('a'))
                res.append(cur)

        return res",1427862568
jacksonc,jacksoncai,214,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        graph = [[] for _ in range(n)]

        for i in range(n):
            if parent[i] != -1:
                graph[parent[i]].append(i)

        subtreeString = []
        startIndex = [0] * n
        endIndex = [0] * n

        def dfs(node):
            startIndex[node] = len(subtreeString)
            for child in sorted(graph[node]):
                dfs(child)
            subtreeString.append(s[node])
            endIndex[node] = len(subtreeString) - 1

        dfs(0)

        fullString = ''.join(subtreeString)
        nFull = len(fullString)

        base = 911
        mod = 10**9 + 7
        powP = [1] * (nFull + 1)
        h = [0] * (nFull + 1)
        rh = [0] * (nFull + 2)

        for i in range(1, nFull + 1):
            powP[i] = powP[i - 1] * base % mod

        for i in range(1, nFull + 1):
            h[i] = (h[i - 1] * base + ord(fullString[i - 1])) % mod

        for i in range(nFull - 1, -1, -1):
            rh[i] = (ord(fullString[i]) + rh[i + 1] * base) % mod

        def isSubstringPalindrome(l, r):
            l += 1
            r += 1
            lenSub = r - l + 1
            hLr = (h[r] - h[l - 1] * powP[lenSub]) % mod
            rhLr = (rh[l - 1] - rh[r] * powP[lenSub]) % mod
            if hLr < 0:
                hLr += mod
            if rhLr < 0:
                rhLr += mod
            return hLr == rhLr

        answer = [False] * n
        for i in range(n):
            if isSubstringPalindrome(startIndex[i], endIndex[i]):
                answer[i] = True

        return answer",1427840833
jacksonc,jacksoncai,214,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        maxPrime = 10**3
        isPrime = [True] * (maxPrime + 1)
        isPrime[0] = isPrime[1] = False
        for i in range(2, int(maxPrime ** 0.5) + 1):
            if isPrime[i]:
                for j in range(i * i, maxPrime + 1, i):
                    isPrime[j] = False
        primes = [i for i, val in enumerate(isPrime) if val]

        def smallestPrimeFactor(x):
            if x <= 1:
                return x
            for p in primes:
                if p * p > x:
                    break
                if x % p == 0:
                    return p
            return x

        n = len(nums)
        prevValues = {}

        x = nums[0]
        spf = smallestPrimeFactor(x)
        options = [(x, 0)]
        if spf != x:
            options.append((spf, 1))

        prevValues = {val: cost for val, cost in options}

        for i in range(1, n):
            x = nums[i]
            spf = smallestPrimeFactor(x)
            options = [(x, 0)]
            if spf != x:
                options.append((spf, 1))

            currentValues = {}
            for valCurr, costCurr in options:
                for valPrev, costPrev in prevValues.items():
                    if valCurr >= valPrev:
                        totalCost = costPrev + costCurr
                        if valCurr not in currentValues or totalCost < currentValues[valCurr]:
                            currentValues[valCurr] = totalCost
            if not currentValues:
                return -1
            prevValues = currentValues

        return min(prevValues.values())
",1427890990
Hayford08,Hayford08,215,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();
        array<int, 26> mp = {};
        set<pair<int, int>> st;
        for (int l = 0, r = 0; r < n; r++){
            int pos = s[r] - 'a';
            if (mp[pos] != 0){
                int pv = mp[pos];
                st.erase(st.find({pv, pos}));
            }
            st.insert({++mp[pos], pos});
            while (st.size() && prev(st.end())->first >= k){
                ans += n - r;
                pos = s[l++] - 'a';
                st.erase(st.find({mp[pos]--, pos}));
                if (mp[pos] > 0){
                    st.insert({mp[pos], pos});
                }
            }
        }
        return ans;
    }
};",1427835169
Hayford08,Hayford08,215,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr;
        for (char c : target){
            curr += 'a';
            while (c != curr.back()) {
                res.push_back(curr);
                int idx = curr.size() - 1;
                if (curr[idx] == 'z'){
                    curr[idx] = 'a';
                }
                else {
                    curr[idx]++;
                }
            }
            res.push_back(curr);
        }
        return res;
    }
};",1427825925
Hayford08,Hayford08,215,3603,cpp,"constexpr long long MOD = 1e9 + 7;

struct RollingHash{
  long long p;
  vector<long long> hashes;
  vector<long long> pows;

  RollingHash(string &s, long long _p = 31) : p(_p) {
    long long n = s.size();
    pows = vector<long long>(n + 1);
    pows[0] = 1;
    for (int i = 1; i <= n; i++){
      pows[i] = mul(pows[i - 1], p);
    }

    hashes = vector<long long>(n + 1);
    for (int i = 1; i <= n; i++){
      hashes[i] = mod(mul(hashes[i - 1], p) + s[i - 1]);
    }
  }

  long long mul(long long a, long long b){
    return (a * b) % MOD;
  }

  long long mod(long long a){
    return ((a % MOD) + MOD) % MOD;
  }

  long long get_hash(int l, int r) {
    long long ha = hashes[r + 1] - mul(hashes[l], pows[r - l + 1]);
    return mod(ha);
  }

  long long get_hash(){
    return hashes.back();
  }
};

// constexpr long long MOD = 1e9 + 7;
long long pow_mod(long long a, long long b){
  long long ans = 1;
  while (b) {
    if (b & 1){
      ans = (ans * a) % MOD;
    }
    b >>= 1;
    a = (a * a) % MOD;
  }
  return ans;
}

struct RabinKarp {
  int P;
  vector<int> pref, inv_pows;
  RabinKarp(string &s, int p = 31) {
    P = p;
    int n = s.size();
    pref = vector<int>(n + 1);
    long long h = 0;
    long long pwr = 1;
    for (int i = 1; i <= n; i++){
      int x = s[i - 1] - 'a' + 1;
      h = (h + pwr * x) % MOD;
      pref[i] = h;
      pwr = (pwr * P) % MOD;
    }

    pwr = pow_mod(pwr, MOD - 2);
    inv_pows = vector<int>(n + 1);
    for (int i = n; i >= 0; i--){
      inv_pows[i] = pwr;
      pwr = (pwr * P) % MOD;
    }
  }

  int query(int l, int r) {
    return (((pref[r + 1] - pref[l] + MOD) % MOD) * inv_pows[l]) % MOD;
  }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<set<int>> adj(n);
        for (int i = 0; i < n; i++){
            int par = parent[i];
            if (par != -1){
                adj[par].insert(i);
            }
        }

        string p = """";
        vector<pair<int, int>> positions(n);

        function<int(int)> dfs = [&](int u) -> int {
            int mn = INT_MAX;
            for (auto &v : adj[u]) {
                mn = min(mn, dfs(v));
            }
            p += s[u];
            if (mn == INT_MAX){
                mn = p.size() - 1;
            }
            positions[u] = {mn, p.size() - 1};
            return mn;
        };

        dfs(0);
        // RollingHash fwd(p);
        RabinKarp fwd(p);
        reverse(p.begin(), p.end());
        // RollingHash bwd(p);
        RabinKarp bwd(p);
        vector<bool> res(n);
        for (int i = 0; i < n; i++){
            auto [l, r] = positions[i];
            // res[i] = fwd.get_hash(l, r) == bwd.get_hash(n - r - 1, n - l - 1);
            res[i] = fwd.query(l, r) == bwd.query(n - r - 1, n - l - 1);
        }
        return res;
    }
};",1427907974
Hayford08,Hayford08,215,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int cnt = 0;
        for (int i = n - 2; i >= 0; i--){
            int nxt = nums[i + 1];
            int curr = nums[i];
            if (curr <= nxt){
                continue;
            }
            while (curr > nums[i + 1]) {
                bool found = false;
                for (long long f = 2; 1ll * f * f <= curr; f++){
                    if (curr % f == 0){
                        int mx = curr / f;
                        curr = curr / mx;
                        cnt++;
                        found = true;
                        break;
                    }
                }
                if (!found){
                    return -1;
                }
                nums[i] = curr;
            }
        }
        return cnt;
    }
};",1427852090
GoIsTheBestLang,__golang__,217,3502,golang,"func numberOfSubstrings(s string, k int) int {
    n := len(s)
    ans := 0
    for i := range n {
        mx := 0
        cnt := make(map[byte]int)
        for j := i; j < n; j++ {
            cnt[s[j]]++
            mx = max(mx, cnt[s[j]])
            if mx >= k {
                ans++
            }
        }
    }
    return ans
}",1427841001
GoIsTheBestLang,__golang__,217,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = list()
        cur = list()
        for ch in target:
            cur.append(0)
            while cur[-1] != ord(ch) - ord(""a""):
                ans.append("""".join([chr(ord(""a"") + num) for num in cur]))
                cur[-1] += 1
            ans.append("""".join([chr(ord(""a"") + num) for num in cur]))
        return ans
            
        ",1427840689
GoIsTheBestLang,__golang__,217,3603,python3,"MOD = 10 ** 9 + 7

base = 199283382

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                g[p].append(i)
        ans = [False] * n
        for i in range(n):
            g[i].sort() 
        @cache
        def revdfs(u):
            s2 = (ord(s[u]) - ord(""a"")) * base % MOD
            t = 1
            for v in reversed(g[u]):
                sz, hs = revdfs(v)
                s2 *= pow(base, sz, MOD)
                s2 %= MOD
                s2 += hs
                s2 %= MOD
                t += sz
            return t, s2
        @cache
        def dfs(u):
            s1 = 0
            t = 1
            for v in g[u]:
                sz, hs = dfs(v)
                s1 *= pow(base, sz, MOD)
                s1 %= MOD
                s1 += hs
                s1 %= MOD
                t += sz
            s1 *= base
            s1 %= MOD
            s1 += (ord(s[u]) - ord(""a"")) * base % MOD
            s1 %= MOD
            ans[u] = s1 == revdfs(u)[1]
            return t, s1
        dfs(0)
        return ans
            
        ",1427866173
GoIsTheBestLang,__golang__,217,3607,python3,"MAX = 1000010

dpf = list(range(MAX))
for i in range(2, MAX):
    if dpf[i] == i:
        for j in range(2 * i, MAX, i):
            dpf[j] = min(dpf[j], i)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        @cache
        def dfs(i, prev):
            if i == n:
                return 0
            ans = inf
            if nums[i] >= prev:
                ans = min(ans, dfs(i + 1, nums[i]))
            if dpf[nums[i]] >= prev:
                ans = min(ans, dfs(i + 1, dpf[nums[i]]) + 1)
            return ans
        return -1 if dfs(0, 0) == inf else dfs(0, 0)",1427840178
Vedant Rawale,vedant_rawale,219,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        vector<vector<int>> pfx(n,vector<int>(26));
        pfx[0][s[0]-'a']++;
        
        for(int i = 1;i<n;i++){
            pfx[i] =  pfx[i-1];
            pfx[i][s[i]-'a']++;
        }
        
        int ans = 0;
        
        for(int i= 0;i<s.length();i++){
            for(int j =i;j<s.length();j++){
                bool flag = false;
                for(int l = 0;l<26;l++){
                    int cnt = pfx[j][l]-pfx[i][l] + ((s[i]-'a')==l ? 1 : 0);
                    if(cnt>=k) {
                        flag = true;
                        break;
                    }
                }
                if(flag) ans++;
            }
        }
        return ans;
    }
};",1427898764
Vedant Rawale,vedant_rawale,219,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string prev = """";
        for(int i= 0;i<target.length();i++)
        {   
            for(int j= 0;j<26;j++){
                if(target[i]-'a'<j) break;
                prev.push_back(char(j+'a'));
                ans.push_back(prev);
                prev.pop_back();
            }
            
            
            prev.push_back(target[i]);
        }
        
        return ans;
    }
};",1427892025
Vedant Rawale,vedant_rawale,219,3603,cpp,"#define MAXLEN 100010

constexpr uint64_t mod = (1ULL << 61) - 1;

const uint64_t seed = chrono::system_clock::now().time_since_epoch().count();
const uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);

uint64_t base_pow[MAXLEN];

int64_t modmul(uint64_t a, uint64_t b){
    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;
    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;
    uint64_t ret = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;
    ret = (ret & mod) + (ret >> 61);
    ret = (ret & mod) + (ret >> 61);
    return ret - 1;
}

void init(){
    base_pow[0] = 1;
    for (int i = 1; i < MAXLEN; i++){
        base_pow[i] = modmul(base_pow[i - 1], base);
    }
}

struct PolyHash{
    /// Remove suff vector and usage if reverse hash is not required for more speed
    vector<int64_t> pref, suff;

    PolyHash() {}

    template <typename T>
    PolyHash(const vector<T>& ar){
        if (!base_pow[0]) init();

        int n = ar.size();
        assert(n < MAXLEN);
        pref.resize(n + 3, 0);
        suff.resize(n + 3, 0);

        for (int i = 1; i <= n; i++){
            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;
            if (pref[i] >= mod) pref[i] -= mod;
        }

         for (int i = n; i >0; i--){
            suff[i] = modmul(suff[i+1], base) + ar[i - 1] + 997;
            if (suff[i] >= mod) suff[i] -= mod;
        }

    }

    PolyHash(const char* str)
        : PolyHash(vector<char> (str, str + strlen(str))) {}
   
    PolyHash(const std::string& str)
        : PolyHash(vector<char>(str.begin(), str.end())) {}

    uint64_t get_hash(int l, int r){
        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);
        return h < 0 ? h + mod : h;
    }

    uint64_t rev_hash(int l, int r){
        int64_t h = suff[l +1] - modmul(base_pow[r - l + 1], suff[r+2]);
        return h < 0 ? h + mod : h;
    }
};

#define i64 uint64_t

bool generated = false;

class Solution {
public:
    void dfs(int node,int par,vector<vector<int>> &adj,string &eu,string &s,vector<int> &outTime,vector<int> &sz,int &currT){
        bool flag = false;
        for(auto j: adj[node]){
            if(j!=par){
                flag = true;
                dfs(j,node,adj,eu,s,outTime,sz,currT);
                sz[node] += sz[j];
            }
        }

        eu.push_back(s[node]);
        outTime[node] = currT++;
        sz[node] += 1;
    }


    vector<bool> findAnswer(vector<int>& parent, string s) {

        if(generated==false){
            init();
            generated = true;
        }

        string eu = """";
        int n = parent.size();
        vector<vector<int>> adj(n);
        for(int i= 1;i<n;i++) adj[parent[i]].push_back(i);
        vector<int> outTime(n);
        vector<int> sz(n);

        int currT = 0;

        dfs(0,0,adj,eu,s,outTime,sz,currT);

        PolyHash ph(eu);

        // cout<<eu<<endl;
        // cout<<outTime[0]<<""--""<<sz[0]<<endl;

        vector<bool> ans(n);
        for(int i = 0;i<n;i++){
            int ot = outTime[i];
            int szz = sz[i];
            int indd = ot-szz+1;
            if(ph.get_hash(indd,ot)==ph.rev_hash(indd,ot)) ans[i] = true;

        }
        return ans;
    }
};",1427875999
Vedant Rawale,vedant_rawale,219,3607,cpp,"int spf[1000001];
int n = 1000000;

void init(){
    for (int i = 1; i <= n; i++) {
            spf[i] = i;
        }

        for (int i = 2; i * i <= n; i++) {

            if (spf[i] == i) {
                for (int j = i * i; j <= n; j += i) {
                    if (spf[j] == j) {
                        spf[j] = i;
                    }
                }
            }
        }
        int ans = 0;
}

bool generated = false;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(generated==false){
            init();
            generated = true;
        }
        
        int ops = 0;
        int N = nums.size();
        
        for(int i = N-2;i>=0;i--){
            int nxtVal = nums[i+1];
            int val = nums[i];
            
            while(val>nxtVal){
                int ss = spf[val];
                if(ss==val) return -1;
                val = ss;
                ops++;
            }
            
            nums[i] = val;
        }
        
        return ops;
    }
};",1427917506
Mohit Raj,mrx_one,220,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
       int n = s.length();
        int cnt = 0;
        
        for (int i = 0; i < n; ++i) {
            
            vector<int> freq(26, 0);
            
            for (int j = i; j < n; ++j) {
                freq[s[j] - 'a']++;
                
                bool pos = false;
                
                for (auto f : freq) {
                    if (f >= k) {
                        pos = true;
                        break;
                    }
                }
                
                if (pos)  cnt++;
                
            }
        }

        return cnt; 
    }
};",1427832612
Mohit Raj,mrx_one,220,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s = """";
        
        for (char ch : target) {
           
            s += 'a';
            res.push_back(s);
      
            while (s.back() != ch) {
                s.back() = (s.back() - 'a' + 1) % 26 + 'a';
                res.push_back(s);
            }
        }
        
        return res;
    }
};",1427827562
Mohit Raj,mrx_one,220,3603,python3,"from typing import List

class Solution:
    def findAnswer(self, p: List[int], s: str) -> List[bool]:
        n = len(p)
        a = [False] * n
        
        f = p.copy()
        
        c = [[] for _ in range(n)]
        for i in range(1, n):
            c[p[i]].append(i)

        b = 911
        m = 1000000007
        
        powB = [1] * (n + 2)
        for i in range(1, n + 2):
            powB[i] = (powB[i - 1] * b) % m
        
        o = []
        st = [0]  # Assuming node 0 is always the root
        v = [False] * n
        
        while st:
            x = st[-1]
            if not v[x]:
                v[x] = True
                for ch in reversed(c[x]):
                    st.append(ch)
            else:
                st.pop()
                o.append(x)
        
        l = [0] * n
        h1 = [0] * n  # Forward hash
        h2 = [0] * n  # Reverse hash
        
        for x in o:
            l[x] = 1
            
            ch1 = 0
            for ch in c[x]:
                ch1 = (ch1 * powB[l[ch]] + h1[ch]) % m
                l[x] += l[ch]
            ch1 = (ch1 * b + (ord(s[x]) - ord('a') + 1)) % m
            h1[x] = ch1
            
            ch2 = (ord(s[x]) - ord('a') + 1)
            for ch in reversed(c[x]):
                ch2 = (ch2 * powB[l[ch]] + h2[ch]) % m
            h2[x] = ch2
            
            a[x] = (h1[x] == h2[x])
        
        return a
",1427909172
Mohit Raj,mrx_one,220,3607,cpp,"const int M = 1000001;

vector<bool> sp(M, 1);
vector<int> lp(M, 0);

void sieve(int n) {
    sp[0] = sp[1] = 0;
    for (int i = 2; i < n; i++) {
        if (sp[i]) {
            lp[i] = i;
            for (int j = i * 2; j < n; j += i) {
                sp[j] = 0;
                if (lp[j] == 0) {
                    lp[j] = i;
                }
            }
        }
    }
}

class Solution {
public:
    Solution() {
        if (lp[10] == 0) {
            sieve(M);
        }
    }

    int minOperations(vector<int>& n) {
        int r = 0, s = n.size();
        int p = n[s - 1];

        for (int i = s - 2; i >= 0; --i) {
            if (n[i] <= p) {
                p = n[i];
                continue;
            }

            while (lp[n[i]] > 1 && n[i] / lp[n[i]] > 1) {
                n[i] /= (n[i] / lp[n[i]]);
                r++;
                if (n[i] <= p) {
                    break;
                }
            }

            if (n[i] > p) {
                return -1;
            }

            p = n[i];
        }
        return r;
    }
};
",1427893042
Nicholas,nicholask_17,221,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),ans=0;
        for (int i=0; i<n; i++){
            int cnt[26];
            for (int j=0; j<26; j++) cnt[j]=0;
            for (int j=i; j<n; j++){
                cnt[s[j]-'a']++;
                if (cnt[s[j]-'a']>=k){
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427824887
Nicholas,nicholask_17,221,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector <string> ans;
        string cur="""";
        for (char i:target){
            cur+='a';
            ans.push_back(cur);
            for (char j='b'; j<=i; j++){
                cur[cur.size()-1]=j;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824059
Nicholas,nicholask_17,221,3603,cpp,"class Solution {
public:
    vector <int> g[100010];
    long long fh[100010],bh[100010],len[100010],pw[100010];
    const long long base=137LL,mod=1e9+123LL;
    string str;
    void dfs(int cur){
        if (g[cur].empty()){
            fh[cur]=bh[cur]=(str[cur]-'a'+1);
            len[cur]=1;
            return;
        }
        for (int i:g[cur]) dfs(i);
        len[cur]=0;
        fh[cur]=bh[cur]=0;
        for (int i:g[cur]){
            fh[cur]+=pw[len[cur]]*fh[i];
            fh[cur]%=mod;
            len[cur]+=len[i];
        }
        fh[cur]+=pw[len[cur]]*(int)(str[cur]-'a'+1);
        fh[cur]%=mod;
        len[cur]=0;
        bh[cur]+=pw[len[cur]]*(int)(str[cur]-'a'+1);
        len[cur]++;
        reverse(g[cur].begin(),g[cur].end());
        for (int i:g[cur]){
            bh[cur]+=pw[len[cur]]*bh[i];
            bh[cur]%=mod;
            len[cur]+=len[i];
        }
        reverse(g[cur].begin(),g[cur].end());
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        for (int i=0; i<n; i++) g[i].clear();
        for (int i=1; i<n; i++) g[parent[i]].push_back(i);
        str=s;
        pw[0]=1;
        for (int i=1; i<=n; i++) pw[i]=pw[i-1]*base%mod;
        dfs(0);
        vector <bool> ret;
        for (int i=0; i<n; i++){
            if (fh[i]==bh[i]) ret.push_back(1);
            else ret.push_back(0);
        }
        return ret;
    }
};",1427849417
Nicholas,nicholask_17,221,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size(),ans=0;
        for (int i=n-2; i>=0; i--){
            if (nums[i]>nums[i+1]){
                for (int j=2; j*j<=nums[i]; j++){
                    if (nums[i]%j==0){
                        nums[i]=j;
                        ans++;
                        break;
                    }
                }
            }
            if (nums[i]>nums[i+1]) return -1;
        }
        return ans;
    }
};",1427867675
Eric Ge,ericlege98,222,3502,python3,"from collections import Counter
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        end = 0
        c = Counter()
        c[s[0]] += 1
        ref = 0
        ans = 0
        if k == 1:
            ref += 1
        for start in range(len(s)):
            while end < len(s) and ref == 0:
                end += 1
                if end == len(s):
                    return ans
                c[s[end]] += 1
                if c[s[end]] == k:
                    ref += 1
            c[s[start]] -= 1
            if c[s[start]] == k-1:
                ref -= 1
            ans += len(s) - end
        return ans

",1427836080
Eric Ge,ericlege98,222,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        def trans(cur):
            if cur == target:
                return cur, True
            if target.startswith(cur):
                return cur + 'a', False
            if cur[-1] == 'z':
                return cur[:len(cur)-1] + 'a', False
            return cur[:(len(cur)-1)] + chr(ord(cur[-1])+1), False
        c, ok = '', False
        res = []
        while not ok:
            c, ok = trans(c)
            res.append(c)
        return res[:-1]",1427827063
Eric Ge,ericlege98,222,3603,python3,"from collections import defaultdict

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        children = defaultdict(list)
        for i, j in enumerate(parent):
            if j == -1:
                continue
            children[j].append(i)
        for k in children.keys():
            children[k].sort()
        ans = [False] * len(s)
        if len(set(s)) == 1:
            return [True] * len(s)
        def dfs(node):
            nonlocal ans
            my_s = ''.join(dfs(c) for c in children[node])
            my_s += s[node]
            if my_s == my_s[::-1]:
                ans [node] = True
            return my_s
        dfs(0)
        return ans",1427901740
Eric Ge,ericlege98,222,3607,python3,"primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def div(num):
            for p in primes:
                if p >= num:
                    return num
                if num % p == 0:
                    return p
            return num
        ans = 0
        for i in range(len(nums)-2, -1, -1):
            if nums[i+1] < nums[i]:
                nums[i] = div(nums[i])
                ans += 1
            if nums[i+1] < nums[i]:
                return -1
        return ans",1427849862
ArpitVijay7,ArpitVijay7,224,3502,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        
        ll total_str = ((ll)n * (n + 1)) / 2;
        
        int left = 0;
        ll tdi = 0;
        int counts[26] = {0};
        int least_k = 0;
        
        fr(right, n){
            char c = s[right];
            counts[c - 'a']++;
            
            if(counts[c - 'a'] == k){
                least_k++;
            }
            
            while(least_k > 0){
                char c_left = s[left];
                counts[c_left - 'a']--;
                
                if(counts[c_left - 'a'] == k - 1){
                    least_k--;
                }
                left++;
            }
            
            tdi += (right - left + 1);
        }
        
        ll ans = total_str - tdi;
        
        return ans;
    }
};",1427868745
ArpitVijay7,ArpitVijay7,224,3566,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string curr = """";
        
        for(char c : target){

            curr += 'a';
            result.pb(curr);
            
            if(c != 'a'){
                int key2_presses = (c - 'a' + 26) % 26; 
                
                for(int i = 0; i < key2_presses; ++i){

                    char last_char = curr.back();
                    last_char = (last_char == 'z') ? 'a' : last_char + 1;
                    curr.back() = last_char;
                    result.pb(curr);
                }
            }
        }
        
        return result;
    }
};",1427857275
ArpitVijay7,ArpitVijay7,224,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;

class Solution {
public:
    ull P = 31;
    vector<ull> power_P;
    int n;
    vector<vector<int>> children;
    string s;
    vector<bool> answer;
    vector<int> parent;
    vector<ull> hash_val;
    vector<ull> reverse_hash_val;
    vector<int> length_str;

    void precompute_powers(int max_len){
        power_P.resize(max_len +1, 1);
        for(int i =1; i <= max_len; i++) power_P[i] = (power_P[i-1] * P) % mod;
    }

    void dfs(int x){
        ull current_hash =0;
        int current_len =0;
        for(auto y: children[x]){
            dfs(y);
            current_hash = (current_hash * power_P[length_str[y]] + hash_val[y]) % mod;
            current_len += length_str[y];
        }
        current_hash = (current_hash * P + (s[x]-'a' +1)) % mod;
        hash_val[x] = current_hash;

        ull current_reverse_hash = (s[x]-'a' +1);
        for(auto it = children[x].rbegin(); it != children[x].rend(); it++){
            int y = *it;
            current_reverse_hash = (current_reverse_hash * power_P[length_str[y]] + reverse_hash_val[y]) % mod;
        }
        reverse_hash_val[x] = current_reverse_hash;

        length_str[x] = current_len +1;
    }

    vector<bool> findAnswer(vector<int>& parent_input, string s_input) {
        parent = parent_input;
        s = s_input;
        n = parent.size();
        children.assign(n, vector<int>());
        fr(i, n){
            if(parent[i] != -1){
                children[parent[i]].pb(i);
            }
        }
        hash_val.assign(n, 0);
        reverse_hash_val.assign(n, 0);
        length_str.assign(n, 0);
        precompute_powers(n +1);
        for(int i =0; i <n; i++) {
            if(parent[i] == -1){
                dfs(i);
            }
        }
        answer.assign(n, false);
        fr(i, n){
            answer[i] = (hash_val[i] == reverse_hash_val[i]);
        }
        return answer;
    }
};",1427910486
ArpitVijay7,ArpitVijay7,224,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i, n) for (int i = 0; i < n; i++)
#define loop(i, a, b) for (int i = a; i < b; i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(), (x).end()
#define dis(v)                                                                 \
    for (auto i : v)                                                           \
        cout << i << "" "";
#define deb(i) cout << i << endl;

class Solution {
public:
    int get_gpd(int x) {
        if (x == 1)
            return 1;
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                return x / i;
            }
        }
        return 1;
    }
    int minOperations(vector<int>& nums) {
        int ans = 0;
        for (int i = nums.size() - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                int gpd = get_gpd(nums[i]);
                if (gpd == 1)
                    return -1;
                nums[i] /= gpd;
                ans++;
            }
            if (nums[i] > nums[i + 1])
                return -1;
        }
        return ans;
    }
};",1427879950
jacobj2,jacobj2,225,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res = 0
        for i in range(len(s)):
            ct = [0]*26
            curr = 0
            for j in range(i,len(s)):
                ct[ord(s[j])-97]+=1
                curr = max(curr, ct[ord(s[j])-97])
                if curr>=k:
                    res+=1
        return res",1427828135
jacobj2,jacobj2,225,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = ['a']
        for i in range(len(target)):
            for j in range(ord(target[i])-97):
                lst = res[-1]
                #print(lst[-1], ord(lst[-1])-96)
                res.append(lst[:len(lst)-1] + chr(ord(lst[-1]) + 1))
            if i + 1 < len(target):
                res.append(res[-1]+'a')
        return res",1427826116
jacobj2,jacobj2,225,3603,cpp,"#define ll long long
#define all(x) x.begin(), x.end()
constexpr uint64_t mod = (1ULL << 61) - 1;
const int MAXLEN = 1e6 + 5;
const uint64_t seed = chrono::system_clock::now().time_since_epoch().count();
const uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);
 
uint64_t base_pow[MAXLEN];
 
int64_t modmul(uint64_t a, uint64_t b){
    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;
    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;
    uint64_t ret = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;
    ret = (ret & mod) + (ret >> 61);
    ret = (ret & mod) + (ret >> 61);
    return ret - 1;
}
 
void init(){
    base_pow[0] = 1;
    for (int i = 1; i < MAXLEN; i++){
        base_pow[i] = modmul(base_pow[i - 1], base);
    }
}
 
uint64_t nxt_hash(uint64_t cur, char c){
	return (modmul(cur, base) + c + 997) % mod;
}
uint64_t total_hash(string& s){
	uint64_t cur = 0;
	for(int i = 0; i < s.length(); i++) cur = nxt_hash(cur, s[i]);
	return cur;
}
struct PolyHash{
    vector<int64_t> pref;
    int n;
	
    PolyHash(string& ar){
        if (!base_pow[0]) init();
 
        n = ar.size();
        assert(n < MAXLEN);
        pref.resize(n + 1, 0);
 
        for (int i = 1; i <= n; i++){
            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;
            while (pref[i] >= mod) pref[i] -= mod;
        }
    }
 
    uint64_t get_hash(int l, int r){
        //cout<<l<<"" ""<<r<<"" ""<<n<<endl;
        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);
        return h < 0 ? h + mod : h;
    }
    
    void extend(char c){
		pref.push_back(nxt_hash(pref.back(), c));
		n++;
	}
};
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> res(n);
        vector<vector<int>> nodeMap(n);
        for (int i = 1; i < n; i++){
            nodeMap[parent[i]].emplace_back(i);
        }
        string st;
        vector<ll> sz(n), index(n);
        auto dfs = [&] (auto&& self, int node) -> void{
            sz[node] = 1;
            for (int neighbor: nodeMap[node]){
                self(self,neighbor);
                sz[node]+=sz[neighbor];
            }
            st.push_back(s[node]);
            index[node] = st.size() - 1;
        };
        dfs(dfs,0);
        //cout<<st<<endl;
        PolyHash h1 (st);
        reverse(all(st));
        PolyHash h2(st);
        for (int i = 0; i < n; i++){
            int bef = index[i] - sz[i] + 1;
            uint64_t h = h1.get_hash(bef, index[i]);
            uint64_t hs = h2.get_hash(st.size() - 1 - index[i], st.size() - 1 - index[i] + sz[i] - 1);
            res[i] = h==hs;
        }
        return res;
    }
};",1427919067
jacobj2,jacobj2,225,3607,python3,"sieve = [0]*(1000001)
for i in range(2,1000001):
    for j in range(i+i, len(sieve), i):
        sieve[j] = i
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        res = 0
        #print(sieve[7])
        for i in range(len(nums)-2,-1,-1):
            while nums[i] > nums[i+1]:
                if sieve[nums[i]]==0:
                    return -1
                nums[i]//=sieve[nums[i]]
                res+=1
        return res",1427842617
Ayush,as_313,229,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        for (int i = 0; i < n; i++) {
            vector<int> f(26, 0);
            for (int j = i; j < n; j++) {
                f[s[j] - 'a']++;
                if (any_of(f.begin(), f.end(), [k](int c) { return c >= k; })) {
                    res++;
                }
            }
        }
        return res;
    }
};
",1427838776
Ayush,as_313,229,3566,python3,"class Solution:
    def stringSequence(self, t: str) -> List[str]:
        r, s = [], """"
        for i, c in enumerate(t):
            if i == 0: s = 'a'; r.append(s)
            while len(s) < i + 1: s += 'a'; r.append(s)
            while s[-1] != c: s = s[:-1] + chr(ord(s[-1]) + 1); r.append(s)
        return r
",1427830050
Ayush,as_313,229,3603,python3,"class Solution:
    def findAnswer(self, p, s):
        n = len(p)
        a = [False] * n
        c = [[] for _ in range(n)]
        
        for i in range(1, n): c[p[i]].append(i)
        
        b = 911
        m = 1000000007
        pw = self.precompute_powers(n + 2, b, m)
        
        po = self.post_order_traversal(c, n)
        
        l = [0] * n
        h1 = [0] * n
        h2 = [0] * n 
        
        for x in po: l[x], h1[x], h2[x] = self.compute_hashes(x, c, s, l, h1, h2, b, pw, m); a[x] = (h1[x] == h2[x])
        
        return a

    def precompute_powers(self, size, base, modulus):
        pw = [1] * size
        for i in range(1, size):
            pw[i] = (pw[i - 1] * base) % modulus
        return pw

    def post_order_traversal(self, c, n):
        po = []
        s_t = [0]
        v = [False] * n
        
        while s_t:
            x = s_t[-1]
            if not v[x]:
                v[x] = True
                for y in reversed(c[x]):
                    s_t.append(y)
            else:
                s_t.pop()
                po.append(x)
        
        return po

    def compute_hashes(self, x, c, s, l, h1, h2, b, pw, m):
        l[x] = 1
        h1_cur = 0
        
        for y in c[x]:
            h1_cur = (h1_cur * pw[l[y]] + h1[y]) % m
            l[x] += l[y]
        
        h1_cur = (h1_cur * b + (ord(s[x]) - ord('a') + 1)) % m
        h1[x] = h1_cur
        
        h2_cur = (ord(s[x]) - ord('a') + 1)
        for y in reversed(c[x]):
            h2_cur = (h2_cur * pw[l[y]] + h2[y]) % m
            
        h2[x] = h2_cur
        return l[x], h1[x], h2[x]
",1427903439
Ayush,as_313,229,3607,python3,"M = 1000000
g = [0] * (M + 1)
p = False

def precompute():
    global p
    if p: return
    for i in range(2, M + 1):
        for j in range(2 * i, M + 1, i): g[j] = i
    p = True

class Solution:
    def minOperations(self, a):
        precompute()
        ops = 0
        for i in range(len(a) - 2, -1, -1):
            while a[i] > a[i + 1]:
                d = g[a[i]]
                if d <= 1: return -1
                a[i] //= d
                ops += 1
                if a[i] <= 0: return -1
        return ops
",1427886177
Himanshu Bhalla,himanshubhalla200,230,3502,golang,"func numberOfSubstrings(s string, k int) int {
    a := len(s)
    b := 0
    for c := 0; c < a; c++ {
        f := [26]int{}
        h := false
        for d := c; d < a; d++ {
            f[s[d]-'a']++
            if f[s[d]-'a'] == k {
                h = true
            }
            if h {
                b++
            }
        }
    }
    return b
}
",1427875751
Himanshu Bhalla,himanshubhalla200,230,3566,golang,"func stringSequence(t string) []string {
    var r []string
    a := []rune{}
    for i := 0; i < len(t); i++ {
        for len(a) < i+1 {
            a = append(a, 'a')
            r = append(r, string(a))
        }
        c := a[len(a)-1]
        b := rune(t[i])
        p := (b - c + 26) % 26
        for j := rune(0); j < p; j++ {
            if a[len(a)-1] == 'z' {
                a[len(a)-1] = 'a'
            } else {
                a[len(a)-1]++
            }
            r = append(r, string(a))
        }
    }
    return r
}
",1427872490
Himanshu Bhalla,himanshubhalla200,230,3603,golang,"func findAnswer(parent []int, s string) []bool {
    n := len(parent)
    t := make([][]int, n)
    for a := 0; a < n; a++ {
        t[a] = []int{}
    }
    for a := 1; a < n; a++ {
        p := parent[a]
        t[p] = append(t[p], a)
    }

    f := s
    d := make([]byte, 0, n)
    l := make([]int, n)
    r := make([]int, n)
    idx := 0

    var dfs func(int)
    dfs = func(a int) {
        l[a] = idx
        for _, b := range t[a] {
            dfs(b)
        }
        d = append(d, f[a])
        idx++
        r[a] = idx - 1
    }
    dfs(0)

    const mod = 1000000007
    const base = 911
    n = len(d)
    ph := make([]int64, n)
    rph := make([]int64, n)
    pb := make([]int64, n+1)
    pb[0] = 1
    for a := 1; a <= n; a++ {
        pb[a] = (pb[a-1] * base) % mod
    }
    for a := 0; a < n; a++ {
        c := int64(d[a])
        if a == 0 {
            ph[a] = c
        } else {
            ph[a] = (ph[a-1]*base + c) % mod
        }
    }

    dr := make([]byte, n)
    for a := 0; a < n; a++ {
        dr[a] = d[n-1-a]
    }
    for a := 0; a < n; a++ {
        c := int64(dr[a])
        if a == 0 {
            rph[a] = c
        } else {
            rph[a] = (rph[a-1]*base + c) % mod
        }
    }

    ans := make([]bool, n)
    for a := 0; a < n; a++ {
        la := l[a]
        ra := r[a]
        lth := ra - la + 1

        var h int64
        if la == 0 {
            h = ph[ra]
        } else {
            h = (ph[ra] - ph[la-1]*pb[lth]%mod + mod) % mod
        }

        revL := n - 1 - ra
        revR := n - 1 - la
        var rh int64
        if revL == 0 {
            rh = rph[revR]
        } else {
            rh = (rph[revR] - rph[revL-1]*pb[lth]%mod + mod) % mod
        }

        if h == rh {
            ans[a] = true
        } else {
            ans[a] = false
        }
    }
    return ans
}
",1427904253
Himanshu Bhalla,himanshubhalla200,230,3607,golang,"func minOperations(nums []int) int {
    s := make(map[int]bool)
    for _, a := range nums {
        s[a] = true
    }

    p := getPrimesUpTo(1000)
    u := make([]int, 0, len(s))
    for a := range s {
        u = append(u, a)
    }
    spf := computeSPF(u, p)

    f := make([]int, len(nums))
    copy(f, nums)

    n := len(nums)
    t := 0
    nxt := nums[n-1]

    for a := n - 1; a >= 0; a-- {
        x := nums[a]
        o := []struct {
            v   int
            op int
        }{
            {x, 0},
        }

        if spf[x] != x {
            o = append(o, struct {
                v   int
                op int
            }{spf[x], 1})
        }

        found := false
        for _, opt := range o {
            if opt.v <= nxt {
                nxt = opt.v
                t += opt.op
                found = true
                break
            }
        }
        if !found {
            return -1
        }
    }
    return t
}

func getPrimesUpTo(a int) []int {
    p := make([]bool, a+1)
    for b := 2; b <= a; b++ {
        p[b] = true
    }
    for b := 2; b*b <= a; b++ {
        if p[b] {
            for c := b * b; c <= a; c += b {
                p[c] = false
            }
        }
    }
    pr := []int{}
    for b := 2; b <= a; b++ {
        if p[b] {
            pr = append(pr, b)
        }
    }
    return pr
}

func computeSPF(nums []int, p []int) map[int]int {
    spf := make(map[int]int)
    for _, a := range nums {
        if a <= 1 {
            spf[a] = a
            continue
        }
        for _, b := range p {
            if b*b > a {
                break
            }
            if a%b == 0 {
                spf[a] = b
                break
            }
        }
        if _, exists := spf[a]; !exists {
            spf[a] = a
        }
    }
    return spf
}
",1427893470
Alok Priydarshi,alokpriydarshi767,231,3502,cpp,"class Solution {
public:
    bool check(vector <int> &A,int k){
        for(auto x : A){
            if(x>=k){
                return true;
            }
        }
        return false;
    }
    int numberOfSubstrings(string s, int k) {
        vector <int> A(26,0);
        int l = 0,r = 0;
        int n = s.length();
        int ans = 0;
        while(r<n){
            A[s[r]-'a']++;
            // if(A[s[r]-'a']==k){
            //     ans += (n-r);
            // }
            while(check(A,k)){
                A[s[l]-'a']--;
                ans+=n-r;
                l++;
            }
            r++;
            // cout<<ans<< "" "";
        }
        return ans;
    }
};",1427839979
Alok Priydarshi,alokpriydarshi767,231,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector <string> ans;
        string a = """";
        for(auto x : target){
            int k = ans.size();
            char c = 'a'; 
            for(int i=0;i<=(x-'a');i++){
                ans.push_back(a+c);
                c++;
            }
            a+=x;
        }
        return ans;
    }
};",1427826109
Alok Priydarshi,alokpriydarshi767,231,3603,cpp,"typedef long long ll;
class Solution {
public:
    vector<vector<ll>> tree;
    vector<ll> subtree_size;
    vector<ll> postorder_pos;
    ll current_pos = 0;
    const int MOD = 1e9 + 7;
    const int BASE = 31;
    ll mod_pow(ll base, ll exp, ll mod) {
        ll result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    void preprocessHashes(const string &s, vector<ll> &hashForward, vector<ll> &hashReverse, vector<ll> &power) {
        ll n = s.size();

        hashForward[0] = s[0] - 'a' + 1;
        hashReverse[0] = s[n - 1] - 'a' + 1;

        for (ll i = 1; i < n; ++i) {
            hashForward[i] = (hashForward[i - 1] * BASE + (s[i] - 'a' + 1)) % MOD;
            hashReverse[i] = (hashReverse[i - 1] * BASE + (s[n - i - 1] - 'a' + 1)) % MOD;
            power[i] = (power[i - 1] * BASE) % MOD;
        }
    }

    ll getForwardHash(ll L, ll R, const vector<ll> &hashForward, const vector<ll> &power) {
        ll result = hashForward[R];
        if (L > 0) {
            result = (result - (hashForward[L - 1] * power[R - L + 1]) % MOD + MOD) % MOD;
        }
        return result;
    }

    ll getReverseHash(ll L, ll R, const vector<ll> &hashReverse, const vector<ll> &power, ll n) {
        ll result = hashReverse[n - L - 1];
        if (R < n - 1) {
            result = (result - (hashReverse[n - R - 2] * power[R - L + 1]) % MOD + MOD) % MOD;
        }
        return result;
    }
    
    void dfs(ll node,string &s,string &ans) {
        subtree_size[node] = 1;
        for (ll child : tree[node]) {
                dfs(child,s,ans);
                subtree_size[node] += subtree_size[child];
            }
            postorder_pos[node] = current_pos++;
            ans+=s[node];
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ll n = s.length();
        tree.resize(n);
        subtree_size.resize(n, 0);
        postorder_pos.resize(n, -1);

        for (ll i = 1; i < n; ++i) {
            ll p = parent[i];
            tree[p].push_back(i);
        }
        string ans = """";
        dfs(0,s,ans);
        vector <bool> A;
        vector<long long> power(n, 1);
        vector<long long> hashForward(n, 0), hashReverse(n, 0);


        preprocessHashes(ans, hashForward, hashReverse, power);
        for (ll i = 0; i < n; ++i) {
            ll r = postorder_pos[i];
            ll l = postorder_pos[i]-subtree_size[i]+1;
        
            ll forwardHash = getForwardHash(l, r, hashForward, power);
            ll reverseHash = getReverseHash(l, r, hashReverse, power, n);

            if (forwardHash == reverseHash)
               A.push_back(true);
            else
                A.push_back(false);
        }
        return A;
    }
};",1427929511
Alok Priydarshi,alokpriydarshi767,231,3607,cpp,"typedef long long ll;
class Solution {
public:
    ll cal(ll a){
        for(ll i=2;i*i<=a;i++){
            if(a%i==0){
                return i;
            }
        }
        return a;
    }
    int minOperations(vector<int>& nums) {
        ll n = nums.size();
        vector <vector <ll>> dp(n,vector <ll> (2,100001));
        vector <vector <ll>> dp1(n,vector <ll> (2,0));
        dp1[n-1][0] = 1;
        dp1[n-1][1] = 1;
        dp[n-1][1] = 1;
        dp[n-1][0] = 0;
        ll y = cal(nums[n-1]);
        for(ll i=n-2;i>=0;i--){
            ll x = cal(nums[i]);
            if(x<=y && dp1[i+1][1]){
                dp1[i][1] = 1;
                dp[i][1] = min(dp[i][1],1+dp[i+1][1]);
            }
            if(x<=nums[i+1] && dp1[i+1][0]){
                dp1[i][1] = 1;
                dp[i][1] = min(dp[i][1],1+dp[i+1][0]);
            }
            if(nums[i]<=y && dp1[i+1][1]){
                dp1[i][0] = 1;
                dp[i][0] = min(dp[i][0],dp[i+1][1]);
            }
            if(nums[i]<=nums[i+1] && dp1[i+1][0]){
                dp1[i][0] = 1;
                dp[i][0] = min(dp[i][0],dp[i+1][0]);
            }
            if(dp1[i][0]==0 && dp1[i][1]==0){
                return -1;
            }
            y = x;
        }
       
        return min(dp[0][0],dp[0][1]);
    }
};",1427864264
svmh,SupervisorMayHap,232,3502,python3,"from collections import defaultdict

class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        dic = defaultdict(int)
        k_count = 0
        left = 0
        res = 0
        n = len(s)
        for i in range(n):
            dic[s[i]] += 1
            if dic[s[i]] == k:
                k_count += 1
            if k_count > 0:
                while True:
                    if k_count == 1 and dic[s[left]] == k:
                        break
                    if dic[s[left]] == k:
                        k_count -= 1
                    dic[s[left]] -= 1
                    left += 1
                res += left + 1
        return res
        
        ",1427828199
svmh,SupervisorMayHap,232,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = ''
        for c in target:
            index = ord(c) - ord('a')
            for i in range(index + 1):
                res.append(cur + chr(i + ord('a')))
            cur += c
        return res
        ",1427824976
svmh,SupervisorMayHap,232,3603,python3,"from collections import defaultdict
import heapq

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        child = defaultdict(list)
        root = -1
        for i, p in enumerate(parent):
            if p == -1:
                root = i
            else:
                child[p].append(i)
        
        order = []
        order_s = []
        n = len(parent)
        res = [False] * n
        
        def dfs(cur):
            for c in child[cur]:
                dfs(c)
            order_s.append(s[cur])
        dfs(root)
        
        def manacher(s):
            t = '#'.join(f'^{s}$')
            n = len(t)
            P = [0] * n
            center = right = 0

            for i in range(1, n - 1):
                P[i] = (right > i) and min(right - i, P[2 * center - i]) or 0
                while t[i + P[i] + 1] == t[i - P[i] - 1]:
                    P[i] += 1
                if i + P[i] > right:
                    center, right = i, i + P[i]
            return P
        
        # print(order)
        # print(order_s)
        p = manacher(''.join(order_s))
        # print(p)
        
        
        def dfs2(cur):
            start = len(order)
            for c in child[cur]:
                dfs2(c)
            end = len(order)
            order.append(cur)
            # print(start, end)
            if len(child[cur]) == 0:
                res[cur] = True
            else:
                h_start = 2 * (start + 1)
                h_end = 2 * (end + 1)
                mid = (h_start + h_end) // 2
                res[cur] = p[mid] >= (end - start + 1)
        dfs2(root)
        return res
        
            
        
        
        
        ",1427913349
svmh,SupervisorMayHap,232,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        res = 0
        last = float('inf')
        
        def get_max_divisor(x):
            for i in range(2, int(x ** 0.5) + 1):
                if x % i == 0:
                    return x // i
            
            return 1
        
        for num in nums[::-1]:        
            if num > last:
                while num > last:
                    v = get_max_divisor(num)
                    if v == 1:
                        return -1
                    num //= v
                    res += 1
                last = num
            else:
                last = num
        
        
        return res
        
        
        
        ",1427838586
Wangwang Yang,Jigcecile,233,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int total = 0;

        for (int start = 0; start < n; ++start) {
            int freq[26] = {0};
            int maxFreq = 0;

            for (int end = start; end < n; ++end) {
                freq[s[end] - 'a']++;

                if (freq[s[end] - 'a'] > maxFreq) {
                    maxFreq = freq[s[end] - 'a'];
                }

                if (maxFreq >= k) {
                    total++;
                }
            }
        }

        return total;
    }
};",1427829234
Wangwang Yang,Jigcecile,233,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string screen = """";

        for (char ch : target) {
            screen += 'a';
            result.push_back(screen);

            int diff = (ch - 'a' + 26) % 26;

            for (int i = 0; i < diff; ++i) {
                if (screen.back() == 'z') {
                    screen.back() = 'a';
                } else {
                    screen.back() += 1;
                }
                result.push_back(screen);
            }
        }

        return result;
    }
};",1427826796
Wangwang Yang,Jigcecile,233,3603,cpp,"class Solution {
public:
    const long long MOD = 1000000007;
    const long long BASE = 911; 

    void compute_powers(vector<long long>& power, int n) {
        power.resize(n + 1, 1);
        for (int i = 1; i <= n; ++i) {
            power[i] = (power[i - 1] * BASE) % MOD;
        }
    }

    void compute_prefix_hash(const string& s, vector<long long>& prefix_hash,
                             const vector<long long>& power) {
        int n = s.size();
        prefix_hash.resize(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            prefix_hash[i + 1] =
                (prefix_hash[i] * BASE + (s[i] - 'a' + 1)) % MOD;
        }
    }

    long long get_hash(int l, int r, const vector<long long>& prefix_hash,
                       const vector<long long>& power) {
        long long hash_val = (prefix_hash[r + 1] -
                              (prefix_hash[l] * power[r - l + 1]) % MOD + MOD) %
                             MOD;
        return hash_val;
    }

    void dfs(int x, const vector<vector<int>>& children, const string& s,
             string& S_postorder, vector<int>& L, vector<int>& R,
             int& counter) {
        L[x] = counter;
        for (auto& y : children[x]) {
            dfs(y, children, s, S_postorder, L, R, counter);
        }
        S_postorder += s[x];
        R[x] = counter;
        counter++;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> children(n, vector<int>());
        int root = -1;
        for (int i = 0; i < n; ++i) {
            if (parent[i] == -1) {
                root = i;
            } else {
                children[parent[i]].push_back(i);
            }
        }

        for (int i = 0; i < n; ++i) {
            sort(children[i].begin(), children[i].end());
        }

        string S_postorder = """";
        vector<int> L(n, 0);
        vector<int> R(n, 0);
        int counter = 0;
        dfs(root, children, s, S_postorder, L, R, counter);

        string reversed_S_postorder = S_postorder;
        reverse(reversed_S_postorder.begin(), reversed_S_postorder.end());

        vector<long long> power;
        compute_powers(power, S_postorder.size());

        vector<long long> prefix_hash;
        compute_prefix_hash(S_postorder, prefix_hash, power);

        vector<long long> prefix_rev_hash;
        compute_prefix_hash(reversed_S_postorder, prefix_rev_hash, power);

        vector<bool> answer(n, false);

        for (int i = 0; i < n; ++i) {
            int l = L[i];
            int r = R[i];
            if (l < 0 || r >= S_postorder.size() || l > r) {
                answer[i] = false;
                continue;
            }
            long long hash1 = get_hash(l, r, prefix_hash, power);
            int rev_l = S_postorder.size() - 1 - r;
            int rev_r = S_postorder.size() - 1 - l;
            long long hash2 = get_hash(rev_l, rev_r, prefix_rev_hash, power);
            if (hash1 == hash2) {
                answer[i] = true;
            } else {
                answer[i] = false;
            }
        }

        return answer;
    }
};",1427913379
Wangwang Yang,Jigcecile,233,3607,cpp,"class Solution {
public:
    vector<int> spf;

    void computeSPF(int maxN) {
        spf.resize(maxN + 1);
        for (int i = 1; i <= maxN; ++i)
            spf[i] = i;
        for (int i = 2; i * i <= maxN; ++i) {
            if (spf[i] == i) {
                for (int j = i * i; j <= maxN; j += i) {
                    if (spf[j] == j)
                        spf[j] = i;
                }
            }
        }
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int maxNum = *max_element(nums.begin(), nums.end());
        computeSPF(maxNum);

        vector<unordered_map<int, int>> dp(n);

        dp[0][nums[0]] = 0;
        if (spf[nums[0]] != nums[0]) {
            dp[0][spf[nums[0]]] = 1;
        }

        for (int i = 1; i < n; ++i) {
            unordered_map<int, int> current_dp;
            vector<pair<int, int>> possible_values;

            possible_values.emplace_back(nums[i], 0);
            if (spf[nums[i]] != nums[i]) {
                possible_values.emplace_back(spf[nums[i]], 1);
            }

            for (auto& [v, op_v] : possible_values) {
                for (auto& [pv, op_pv] : dp[i - 1]) {
                    if (v >= pv) {
                        int total_ops = op_pv + op_v;
                        if (current_dp.find(v) == current_dp.end() ||
                            current_dp[v] > total_ops) {
                            current_dp[v] = total_ops;
                        }
                    }
                }
            }

            if (current_dp.empty()) {
                return -1;
            }

            dp[i] = move(current_dp);
        }

        int min_ops = INT_MAX;
        for (auto& [v, ops] : dp[n - 1]) {
            min_ops = min(min_ops, ops);
        }

        return min_ops;
    }
};
",1427876696
Denys Gubar,DenisGubar,238,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int K) {
        int const N = s.size();
        if (K == 1)
            return N * (N + 1) / 2;
        int result = 0;
        vector<int> A(26);
        for (int L = 0, R = 0, count = 0; R < N; )
        {
            auto add = [&A, K, &count, &s](int i)
                {
                    if (++A[s[i] - 'a'] == K)
                        ++count;
                };
            auto remove = [&A, K, &count, &s](int i)
                {
                    if (--A[s[i] - 'a'] == K - 1)
                        --count;
                };
            add(R), ++R;
            if (count == 0)
                continue;
            while (count > 0)
                remove(L), ++L;
            --L, add(L);
            result += L + 1;
        }
        return result;
    }
};
",1427849272
Denys Gubar,DenisGubar,238,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int const N = target.size();
        vector<string> result;
        string buffer;
        for (int i = 0; i < N; ++i)
        {
            if (buffer.size() < N)
            {
                buffer.push_back('a');
                result.push_back(buffer);
            }
            while (buffer.back() != target[i])
            {
                buffer.back() = (buffer.back() - 'a' + 1) % 26 + 'a';
                result.push_back(buffer);
            }
        }
        return result;
    }
};
",1427827761
Denys Gubar,DenisGubar,238,3603,cpp,"class Solution {
public:
    string buffer;
    vector<int> parent;
    string s;
    int N;
    vector<vector<int>> children;
    vector<bool> result;
    vector<int> start, length;
    void dfs(int x)
    {
        start[x] = buffer.size() + 1;
        for (int y : children[x])
            dfs(y);
        buffer += '#';
        buffer += s[x];
        length[x] = buffer.size() - start[x];
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        this->parent = parent;
        this->s = s;
        N = parent.size();
        buffer.reserve(4 * N);
        buffer += '^';
        start = vector<int>(N);
        length = vector<int>(N);
        children = vector<vector<int>>(N);
        for (int i = 1; i < N; ++i)
            children[parent[i]].push_back(i);
        result = vector<bool>(N);
        dfs(0);
        buffer += '#';
        buffer += '$';
        int B = buffer.size();
        vector<int> LPS(B);
        LPS[2] = 1;
        int C = 2, R = 3;
        for (int i = 3; i < B; ++i)
        {
            int iMirror = 2 * C - i;
            int diff = R - i;
            if (diff > 0)
                LPS[i] = min(LPS[iMirror], diff);
            while (buffer[i - LPS[i] - 1] == buffer[i + LPS[i] + 1])
                ++LPS[i];
            if (i + LPS[i] > R)
                R = i + LPS[i], C = i;
        }
        for (int i = 0; i < N; ++i)
            result[i] = LPS[start[i] + length[i] / 2] >= (length[i] + 1) / 2;
        return result;
    }
};
",1427922812
Denys Gubar,DenisGubar,238,3607,cpp,"static bool isInit = false;
static int D[1'000'001];
static int mex(vector<int> const& A)
{
    unordered_set<int> S(A.begin(), A.end());
    for (int result = 0; ; ++result)
        if (S.find(result) == S.end())
            return result;
}
static void init()
{
    if (!isInit)
    {
        isInit = true;
        memset(D, 0, sizeof(D));
        for (int i = 4; i <= 1'000'000; ++i)
            for (int k = 2; k * k <= i; ++k)
                if (i % k == 0)
                {
                    D[i] = k;
                    break;
                }
    }
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        init();
        int const N = nums.size();
        int result = 0;
        for (int i = N - 2; i >= 0; --i)
        {
            while (nums[i] > nums[i + 1] && D[nums[i]] > 0)
                nums[i] = D[nums[i]], ++result;
            if (nums[i] <= nums[i + 1])
                continue;
            else
                return -1;
        }
        return result;
    }
};
",1427866985
vats_lc,vats_lc,239,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<vector<int>> mp(n + 1, vector<int>(26, 0));
        for (int i = 1; i <= n; i++) {
            mp[i] = mp[i - 1];
            mp[i][s[i - 1] - 'a']++;
        }
        int ans = 0;
        for (int i = 0; i <= n - k; i++) {
            for (int j = i + k; j <= n; j++) {
                bool valid = false;
                for (int t = 0; t < 26; t++) {
                    if (mp[j][t] - mp[i][t] >= k) {
                        valid = true;
                        break;
                    }
                }
                if (valid)
                    ans++;
            }
        }
        return ans;
    }
};",1427846891
vats_lc,vats_lc,239,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        vector<string> ans;
        int i = 0;
        string str = """";
        while (str != target) {
            char ch = 'a';
            while (ch != target[i]) {
                ans.push_back(str + ch);
                ch++;
            }
            str += ch;
            ans.push_back(str);
            i++;
        }
        return ans;
    }
};",1427832858
vats_lc,vats_lc,239,3603,cpp,"class Solution {
public:
    const long long MOD1 = 1e9 + 7;
    const long long MOD2 = 1e9 + 9;
    const long long base = 911;
    vector<int> L, R;
    string dfsStr;
    int pos = 0;
    void dfs(int x, vector<vector<int>>& adj, string& s) {
        L[x] = pos;
        for (int y : adj[x]) {
            dfs(y, adj, s);
        }
        dfsStr.push_back(s[x]);
        pos++;
        R[x] = pos - 1;
    }
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = p.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++)
            adj[p[i]].push_back(i);
        for (int i = 0; i < n; i++)
            sort(adj[i].begin(), adj[i].end());
        L.resize(n);
        R.resize(n);
        dfsStr = """";
        pos = 0;
        dfs(0, adj, s);
        int m = dfsStr.size();
        vector<long long> power1(m + 1, 1), power2(m + 1, 1);
        for (int i = 1; i <= m; i++) {
            power1[i] = (power1[i - 1] * base) % MOD1;
            power2[i] = (power2[i - 1] * base) % MOD2;
        }
        vector<long long> hash1(m + 1, 0), hash2(m + 1, 0);
        vector<long long> revHash1(m + 1, 0), revHash2(m + 1, 0);
        for (int i = 0; i < m; i++) {
            hash1[i + 1] = (hash1[i] * base + dfsStr[i]) % MOD1;
            hash2[i + 1] = (hash2[i] * base + dfsStr[i]) % MOD2;
            revHash1[i + 1] = (revHash1[i] * base + dfsStr[m - 1 - i]) % MOD1;
            revHash2[i + 1] = (revHash2[i] * base + dfsStr[m - 1 - i]) % MOD2;
        }
        vector<bool> ans(n, false);
        for (int i = 0; i < n; i++) {
            int l = L[i], r = R[i];
            int len = r - l + 1;
            long long h1 =
                (hash1[r + 1] - (hash1[l] * power1[len]) % MOD1 + MOD1) % MOD1;
            long long h2 =
                (hash2[r + 1] - (hash2[l] * power2[len]) % MOD2 + MOD2) % MOD2;
            int rl = m - 1 - r, rr = m - 1 - l;
            long long rh1 = (revHash1[rr + 1] -
                             (revHash1[rl] * power1[len]) % MOD1 + MOD1) %
                            MOD1;
            long long rh2 = (revHash2[rr + 1] -
                             (revHash2[rl] * power2[len]) % MOD2 + MOD2) %
                            MOD2;
            if (h1 == rh1 && h2 == rh2)
                ans[i] = true;
            else
                ans[i] = false;
        }
        return ans;
    }
};
",1427906231
vats_lc,vats_lc,239,3607,cpp,"class Solution {
public:
    int greatestDiv(int n) {
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0)
                return i;
        }
        return 1;
    }
    int minOperations(vector<int>& a) {
        int n = a.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (a[i] > a[i + 1]) {
                a[i] = greatestDiv(a[i]);
                if (a[i] == 1)
                    return -1;
                ans++;
            }
        }
        return ans;
    }
};",1427859358
powervic08,powervic08,242,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans = 0;
        for (int i = 0; i < s.length(); i++) {
            int[] freq = new int[26];
            for (int j = i; j < s.length(); j++) {
                freq[s.charAt(j) - 'a']++;
                boolean good = false;
                for (int a = 0; a < 26; a++) {
                    if (freq[a] >= k) {
                        good = true;
                    }
                }
                if (good) {
                    ans += s.length() - j;
                    break;
                }
            }
        }
        return ans;
    }
}",1427845509
powervic08,powervic08,242,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        ArrayList<String> ans = new ArrayList<>();
        for (int i = 0; i < target.length(); i++) {
            String prev = i == 0 ? """" : ans.get(ans.size() - 1);
            for (char j = 'a'; j <= target.charAt(i); j++) {
                ans.add(prev + j);
            }
        }
        return ans;
    }
}",1427829922
powervic08,powervic08,242,3603,java,"class Solution {

    static int time;

    public boolean[] findAnswer(int[] parent, String s) {
        time = 0;
        ArrayList<ArrayList<Integer>> arr = new ArrayList<>();
        for (int i = 0; i < parent.length; i++) {
            arr.add(new ArrayList<>());
        }
        for (int i = 0; i < parent.length; i++) {
            if (parent[i] != -1) {
                arr.get(parent[i]).add(i);
            }
        }
        for (int i = 0; i < parent.length; i++) {
            Collections.sort(arr.get(i));
        }
        int[] num = new int[parent.length];
        dfs(0, num, arr);
        char[] str = new char[parent.length];
        for (int i = 0; i < parent.length; i++) {
            str[num[i]] = s.charAt(i);
        }
        int[] sizes = new int[parent.length];
        fillSizes(sizes, 0, arr);
        long[] prefHash = new long[parent.length + 1];
        long[] sufHash = new long[parent.length + 1];
        long mod = (int) 1e9 + 7;
        long base = 31L;
        long[] pow = new long[parent.length + 1];
        pow[0] = 1;
        for (int i = 1; i <= parent.length; i++) {
            pow[i] = (pow[i - 1] * base) % mod;
        }
        for (int i = 1; i <= parent.length; i++) {
            prefHash[i] = (prefHash[i - 1] * base + (str[i - 1] - 'a' + 1)) % mod;
        }
        for (int i = parent.length - 1; i >= 0; i--) {
            sufHash[i] = (sufHash[i + 1] * base + (str[i] - 'a' + 1)) % mod;
        }
        boolean[] answer = new boolean[parent.length];
        for (int i = 0; i < parent.length; i++) {
            int l = num[i] + 1;
            int r = num[i] + sizes[i];
            long leftHash = (prefHash[r] - (prefHash[l - 1] * pow[r - l + 1]) % mod + mod) % mod;
            long rightHash = (sufHash[l - 1] - (sufHash[r] * pow[r - l + 1]) % mod + mod) % mod;
            answer[i] = leftHash == rightHash;
        }
        return answer;
    }

    public void fillSizes(int[] sizes, int v, ArrayList<ArrayList<Integer>> arr) {
        sizes[v] = 1;
        for (int i = 0; i < arr.get(v).size(); i++) {
            fillSizes(sizes, arr.get(v).get(i), arr);
            sizes[v] += sizes[arr.get(v).get(i)];
        }
    }

    public void dfs(int v, int[] num, ArrayList<ArrayList<Integer>> arr) {
        num[v] = time++;
        for (int i = arr.get(v).size() - 1; i >= 0; i--) {
            dfs(arr.get(v).get(i), num, arr);
        }
    }
}",1427907044
powervic08,powervic08,242,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int[] a = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            for (int j = 2; j * j <= nums[i]; j++) {
                if (nums[i] % j == 0) {
                    a[i] = j;
                    break;
                }
            }
            if (a[i] == 0) a[i] = nums[i];
        }
        int ans = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                nums[i] = a[i];
                ans++;
            }
            if (nums[i] > nums[i + 1]) {
                ans = -1;
                break;
            }
        }
        return ans;
    }
}",1427855166
Vivek Katkar,vivek3054,244,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();

        for(int i=0;i<n;i++){
            map<char, int> mp;
            bool flag = 0;
            for(int j=i;j<n;j++){
                mp[s[j]]++;
                if(mp[s[j]] >= k){
                    flag = 1;
                }

                if(flag) ans++;
            }
        }

        return ans;
    }
};",1427832232
Vivek Katkar,vivek3054,244,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
       
       string s;
       vector<string> ans;

       for(int i=0;i<target.size();i++){
         s += 'a';
         ans.push_back(s);
         while(s.back() != target[i]){
            char ch = s.back();
            s.pop_back();
            s.push_back(ch+1);
            ans.push_back(s);
         }
       }

       return ans;
    }
};",1427828705
Vivek Katkar,vivek3054,244,3603,cpp,"class Solution {
public:
    void preprocessPalindrome(const string &str, vector<int> &odd, vector<int> &even) {
        int n = str.size();

        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : min(odd[l + r - i], r - i + 1);
            while (i - k >= 0 && i + k < n && str[i - k] == str[i + k]) {
                ++k;
            }
            odd[i] = k - 1;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 0 : min(even[l + r - i + 1], r - i + 1);
            while (i - k - 1 >= 0 && i + k < n && str[i - k - 1] == str[i + k]) {
                ++k;
            }
            even[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
    }

    bool isPali(const vector<int> &odd, const vector<int> &even, int l, int r) {
        int length = r - l + 1;

        if (length % 2 == 1) { 
            int mid = (l + r) / 2;
            return odd[mid] >= (length / 2);
        } else { 
            int mid = (l + r) / 2;
            return even[mid + 1] >= (length / 2);
        }
    }

    void dfs(int root, int p, vector<vector<int>> &adj, vector<int> &sub, string &str, string &s, vector<int> &postNode) {
        for (auto neb : adj[root]) {
            if (neb == p) continue;
            dfs(neb, root, adj, sub, str, s, postNode);
            sub[root] += sub[neb];
        }

        sub[root]++;
        str.push_back(s[root]);
        postNode.push_back(root); 
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);

        // Build the adjacency list
        int root = 0;
        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                adj[parent[i]].push_back(i);
            } else {
                root = i;
            }
        }

        for (int i = 0; i < n; ++i) {
            sort(adj[i].begin(), adj[i].end());
        }

        vector<int> subSize(n, 0), postNode;
        string str;

        dfs(root, -1, adj, subSize, str, s, postNode);

        vector<int> odd(str.size()), even(str.size());
        preprocessPalindrome(str, odd, even);

        vector<bool> ans(n, false);

        for (int i = 0; i < postNode.size(); i++) {
            int node = postNode[i];
            int sz = subSize[node];

            if (isPali(odd, even, i - sz + 1, i)) {
                ans[node] = true;
            }
        }

        return ans;
    }
};
",1427916067
Vivek Katkar,vivek3054,244,3607,cpp,"#define SIZE 1000001 

int arr[SIZE]; 

auto pre = [](int arr[], int size) noexcept { 
    arr[0] = -1;
    arr[1] = -1;
    arr[2] = -1;

    for (int i = 2; i < size; i++) {
        arr[i] = -1;

        for (int j = 2; j <= sqrt(i); j++) {
            if (i % j == 0 && (i / j) != i) {
                arr[i] = (i / j);
                break;
            }
        }
    }
};

class Solution {
public:
    static bool preInitialized; 

    Solution() {
        if (!preInitialized) {
            pre(arr, SIZE); 
            preInitialized = true;
        }
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int cnt = 0;
        bool flag = 0;

        for (int i = n - 2; i >= 0; i--) {
            while (1) {
                if (nums[i] <= nums[i + 1]) {
                    break;
                }

                if (nums[i] == -1 || nums[i] == 1 || arr[nums[i]] == -1) {
                    flag = 1;
                    break;
                } else {
                    nums[i] /= arr[nums[i]];
                    cnt++;
                }
            }
        }

        if (flag) return -1;
        else return cnt;
    }
};

bool Solution::preInitialized = false;
",1427866833
Yedige,Yedigebeast,245,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int freq[n][30];
        for (int i = 0; i < n; i++){
            for (int j = 0; j <= 25; j++){
                freq[i][j] = 0;
            }
        }
        for (int i = 0; i < n; i++){
            if (i >= 1) {
                for (int j = 0; j <= 25; j++){
                    freq[i][j] = freq[i - 1][j];
                }
            }
            freq[i][s[i] - 'a'] ++;
        }
        int ans = 0;
        for (int l = 0; l < n; l++){
            for (int r = l; r < n; r++) {
                bool ok = 0;
                for (int i = 0; i <= 25; i++) {
                    int freql = (l == 0) ? 0 : freq[l - 1][i];
                    if (freq[r][i] - freql >= k) {
                        ok = true;
                    }
                }
                ans += ok;
            }
        }
        return ans;
    }
};",1427830516
Yedige,Yedigebeast,245,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v;
        string s = """";
        for (char c : target) {
            for (int i = 0; i <= int(c - 'a'); i++) {
                char c1 = char('a' + i);
                string t = s + c1;
                v.push_back(t);
            }
            s += c;
        }
        return v;
    }
};",1427824873
Yedige,Yedigebeast,245,3603,cpp,"class Solution {
vector<int> g[100123];
bool pa[100123];
string main = """";
int in[100123], out[100123], time = 0;

void dfs(int v, string& base){
    string s = """";
    in[v] = time;
    for (int to : g[v]){
        dfs(to, base);
    }
    out[v] = time;
    time ++;
    main += base[v];
}

vector<int> manacher_odd(string s) {
    int n = (int) s.size();
    vector<int> d(n, 1);
    int l = 0, r = 0;
    for (int i = 1; i < n; i++) {
        if (i < r)
            d[i] = min(r - i + 1, d[l + r - i]);
        while (i - d[i] >= 0 && i + d[i] < n && s[i - d[i]] == s[i + d[i]])
            d[i]++;
        if (i + d[i] - 1 > r)
            l = i - d[i] + 1, r = i + d[i] - 1;
    }
    return d;
}

vector<int> manacher_even(string s) {
    int n = (int) s.size();
    vector<int> d(n, 0);
    int l = -1, r = -1;
    for (int i = 0; i < n - 1; i++) {
        if (i < r)
            d[i] = min(r - i, d[l + r - i - 1]);
        while (i - d[i] >= 0 && i + d[i] + 1 < n && s[i - d[i]] == s[i + d[i] + 1])
            d[i]++;
        if (i + d[i] > r)
            l = i - d[i] + 1, r = i + d[i];
    }
    return d;
}

public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = p.size();
        for (int i = 1; i < n; i++){
            g[p[i]].push_back(i);
        }
        for (int i = 0; i < n; i++){
            sort(g[i].begin(), g[i].end());
        }
        dfs(0, s);
        vector<int> d1 = manacher_odd(main);
        vector<int> d2 = manacher_even(main);
        for (int i = 0; i < n; i++) {
            int l = in[i], r = out[i];
            if ((r - l + 1) % 2 == 0) {
                int m = l + (r - l) / 2;
                if (d2[m] >= (r - l + 1) / 2) {
                    pa[i] = true;
                }
            } else {
                int m = l + (r - l) / 2;
                if (d1[m] >= (r - l + 1) / 2 + 1){
                    pa[i] = true;
                }
            }
        }
        vector<bool> ans;
        for (int i = 0; i < n; i++){
            ans.push_back(pa[i]);
        }
        return ans;
    }
};",1427916366
Yedige,Yedigebeast,245,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        reverse(a.begin(), a.end());
        int res = 0, n = a.size();
        for (int i = 1; i < n; i++) {
            while (a[i] > a[i - 1]) {
                int y = -1;
                for (int j = 2; j <= sqrt(a[i]); j++) {
                    if (a[i] % j == 0) {
                        y = max(a[i] / j, j);
                        break;
                    }
                }
                if (y == -1) {
                    return -1;
                }
                a[i] /= y;
                res ++;
            }
        }
        return res;
    }
};",1427838129
metaphysicalist,metaphysicalist,247,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        cnt = defaultdict(int)
        offset = 0
        ans = 0
        for i, c in enumerate(s):
            cnt[c] += 1
            while cnt[c] >= k:
                cnt[s[offset]] -= 1
                offset += 1
            ans += offset
            # print(i, offset, offset+1, ans)
        return ans
        ",1427846220
metaphysicalist,metaphysicalist,247,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        s = """"
        for t in target:
            for i in range(26):
                c = chr(ord('a') + i)
                ans.append(s + c)
                if c == t:
                    s += c
                    break
            
        return ans
        ",1427832664
metaphysicalist,metaphysicalist,247,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        P, M = 31, 1000000009
        n = len(s)

        def check(lo, hi):
            nonlocal dfsStr
            l = (hi - lo) // 2
            l1, r1 = lo, lo + l
            l2, r2 = hi - l, hi
            # print(lo, hi, l1, r1, dfsStr[l1:r1], l2, r2, dfsStr[l2:r2])
            
            left = (forward[r1] - forward[l1] * pow[l]) % M
            right = (backward[l2] - backward[r2] * pow[l]) % M
            return left == right

        def rolling_hash(h, c):
            return (h * P + (ord(c) - ord('a') + 1)) % M

        dfsStr = """"
        children = defaultdict(list)
        for c, p in enumerate(parent):
            if p != -1:
                children[p].append(c)
        ends = [0] * len(s)
        starts = [0] * len(s)
        
        def dfs(v):
            nonlocal ends, starts, dfsStr
            starts[v] = len(dfsStr)
            for c in children[v]:
                dfs(c)
            dfsStr += s[v]
            ends[v] = len(dfsStr)

        dfs(0)
        # print(dfsStr)
        # print(starts)
        # print(ends)


        pow = list(accumulate(range(len(dfsStr)), lambda a, b: a * P % M, initial=1))
        forward = list(accumulate(dfsStr, rolling_hash, initial=0))
        backward = list(accumulate(reversed(dfsStr), rolling_hash, initial=0))[::-1]
        # print(forward)
        # print(backward)

        ans = []
        for i in range(len(s)):
            ans.append(check(starts[i], ends[i]))
        return ans

        
        ",1427933415
metaphysicalist,metaphysicalist,247,3607,python3,"n = 10 ** 6
factor = [0] * (n + 1)
primes = []
for v in range(2, n + 1):
    if factor[v] == 0:
        for p in primes:
            if p * p > v:
                break
            if v % p == 0:
                factor[v] = v // p
                break
        if factor[v] == 0:
            primes.append(v)

# print(primes)
# print(factor)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums) - 2, -1, -1):
            while nums[i] > nums[i+1]:
                if factor[nums[i]] == 0:
                    return -1
                nums[i] //= factor[nums[i]]
                ans += 1
        return ans
        ",1427869472
Prajak Sen,XIIIus,249,3502,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length(), res = 0;
        for (int i = 0; i < n; i++) {
            unordered_map<char, int> freq;
            for (int j = i; j < n; j++) {
                freq[s[j]]++; 
                bool valid = false;
                for (auto &[ch, count] : freq) {
                    if (count >= k) {
                        valid = true;
                        break;
                    }
                }
                if (valid) res++;
            }
        }
        
        return res;
    }
};
",1427867494
Prajak Sen,XIIIus,249,3566,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<string> stringSequence(string t) {
        cin.tie(0);
        vector<string> res;
        string cur = """";
        char last = 'a';

        for (char ch : t) {
            if (cur.empty()) {
                cur += 'a';  
            }
            res.push_back(cur);  

            while (last != ch) {  
                last = (last == 'z') ? 'a' : last + 1;
                cur.back() = last;
                res.push_back(cur);
            }

            if (cur.size() < t.size()) {  
                cur += 'a';
                last = 'a'; 
            }
        }

        return res;
    }
};
",1427863599
Prajak Sen,XIIIus,249,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n = p.size();
        vector<bool> ans(n);
        vector<int> fq = p;
        vector<vector<int>> ch(n);
        for (int i = 1; i < n; ++i) ch[p[i]].push_back(i);
        
        long P = 911, MOD = 1000000007;
        vector<long> powP(n + 2, 1);
        for (int i = 1; i <= n + 1; ++i) powP[i] = (powP[i - 1] * P) % MOD;
        
        vector<int> po;
        stack<int> st;
        vector<bool> vis(n, false);
        st.push(0);
        while (!st.empty()) {
            int nd = st.top();
            if (!vis[nd]) {
                vis[nd] = true;
                for (int i = ch[nd].size() - 1; i >= 0; --i) st.push(ch[nd][i]);
            } else {
                st.pop();
                po.push_back(nd);
            }
        }

        vector<int> len(n, 1);
        vector<long> h1(n, 0), h2(n, 0);
        for (int nd : po) {
            long cH1 = 0;
            for (int cl : ch[nd]) {
                cH1 = (cH1 * powP[len[cl]] + h1[cl]) % MOD;
                len[nd] += len[cl];
            }
            cH1 = (cH1 * P + (s[nd] - 'a' + 1)) % MOD;
            h1[nd] = cH1;

            long cH2 = (s[nd] - 'a' + 1);
            for (int i = ch[nd].size() - 1; i >= 0; --i) {
                int cl = ch[nd][i];
                cH2 = (cH2 * powP[len[cl]] + h2[cl]) % MOD;
            }
            h2[nd] = cH2;

            ans[nd] = (h1[nd] == h2[nd]);
        }

        return ans;
    }
};",1427918842
Prajak Sen,XIIIus,249,3607,cpp,"// #include <bits/stdc++.h>
// using namespace std;

const int MX = 1000000;
int gpd[MX + 1];
bool pre = false;

void calcGPD() {
    if (pre) return;
    fill(gpd, gpd + MX + 1, 1);
    for (int i = 2; i <= MX; ++i)
        for (int j = 2 * i; j <= MX; j += i)
            gpd[j] = i;
    pre = true;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        calcGPD();
        int ops = 0, n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int d = gpd[nums[i]];
                if (d == 1) return -1;
                nums[i] /= d;
                ops++;
                if (nums[i] <= 0) return -1;
            }
        }
        return ops;
    }
};

// int main() {
//     Solution sol;
//     vector<int> nums = {10, 4, 8, 2};
//     int result = sol.minOperations(nums);
//     cout << result << endl;
//     return 0;
// }
",1427925905
Nutty Professor,varkatkl,251,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        N = len(s)
        MAX = 26
        prefix = [[0] * MAX]
        for i in range(N):
            c = ord(s[i]) - ord('a')
            counts = prefix[-1][:]
            counts[c] += 1
            prefix.append(counts)
        
        def count_diff(a, b):
            return [prefix[b][i] - prefix[a][i] for i in range(MAX)]

        ret = 0
        for i in range(N):
            hi_diff = count_diff(i, N)
            if max(hi_diff) < k:
                break
            lo, hi = i, N
            while hi - lo > 1:
                mid = (lo + hi) // 2
                if max(count_diff(i, mid)) >= k:
                    hi = mid
                else:
                    lo = mid
            ret += N + 1 - hi
        
        return ret
",1427835805
Nutty Professor,varkatkl,251,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ret = []
        for c in target:
            last = ret[-1] if ret else ''
            d = 'a'
            while d <= c:
                ret.append(last + d)
                d = chr(ord(d) + 1)
        
        return ret
",1427825311
Nutty Professor,varkatkl,251,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        N = len(parent)
        children = [[] for _ in range(N)]
        for i in range(N):
            if parent[i] >= 0:
                children[parent[i]].append(i)
        
        P = 31
        MOD = (10**9) + 9
        p_pow = [1] * (N + 1)
        for i in range(1, N + 1):
            p_pow[i] = p_pow[i - 1] * P % MOD

        dfs_str = []
        p_begin = [-1] * N
        p_end = [-1] * N

        def rec(i):
            p_begin[i] = len(dfs_str)
            for c in children[i]:
                rec(c)
            dfs_str.append(s[i])
            p_end[i] = len(dfs_str)
        
        rec(0)

        hash1 = [0] * (N + 1)
        for i in range(N):
            v = ord(dfs_str[i]) - ord('a') + 1
            hash1[i + 1] = (hash1[i] * P + v) % MOD
        
        hash2 = [0] * (N + 1)
        for i in range(N):
            v = ord(dfs_str[N - 1 - i]) - ord('a') + 1
            hash2[i + 1] = (hash2[i] * P + v) % MOD

        ret = [False] * N
        for i in range(N):
            l, r = p_begin[i], p_end[i]
            h1 = (hash1[r] + MOD - hash1[l] * p_pow[r - l] % MOD) % MOD

            l1, r1 = N - r, N - l
            h2 = (hash2[r1] + MOD - hash2[l1] * p_pow[r - l] % MOD) % MOD
            ret[i] = h1 == h2
        
        return ret
",1427934191
Nutty Professor,varkatkl,251,3607,python3,"MAX = 1000100
factor = [1] * MAX

for i in range(2, MAX):
    for j in range(2 * i, MAX, i):
        factor[j] = i

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        last, ret = nums[-1], 0
        for i in range(len(nums) - 2, -1, -1):
            while nums[i] > last:
                if factor[nums[i]] == 1:
                    return -1
                nums[i] //= factor[nums[i]]
                ret += 1
            last = nums[i]

        return ret
",1427847281
9560kiran,9560kiran,253,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.size();
        for(int i=0;i<n;i++){
             bool flag=false;
             unordered_map<char,int> mp;
             for(int j=i;j<n;j++){
                  mp[s[j]]++;
                  if(mp[s[j]]>=k) flag=true;
                  ans+=flag;
             }
        }
        return ans;
    }
};",1427831379
9560kiran,9560kiran,253,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
          vector<string> ans;
          int n=target.size();
          string prev="""";
          for(int i=0;i<n;i++){
               
                for(char ch='a';ch<=target[i];ch++){
                      string temp=prev;
                      temp+=ch;
                      ans.push_back(temp);
                }
                prev+=target[i];
          }
        return ans;
    }
};",1427827810
9560kiran,9560kiran,253,3603,cpp,"class Solution {
public:
    vector<vector<int>> vec;
    string s;
    vector<bool> ans;
    vector<long long> len;
    vector<long long> f_hash;
    vector<long long> b_hash;
    vector<long long> pow_p;

    const long long P = 131;    
    const long long MOD = 1e9 + 7;

    void dfs(int node) {
        int char_value = s[node] - 'a' + 1; 
        f_hash[node] = char_value;
        b_hash[node] = char_value;
        len[node] = 1;

        for (int child : vec[node]) {
            dfs(child);

            f_hash[node] = (f_hash[node] * pow_p[len[child]] % MOD + f_hash[child]) % MOD;

            b_hash[node] = (b_hash[child] * pow_p[len[node]] % MOD + b_hash[node]) % MOD;

            len[node] += len[child];
        }

        ans[node] = (f_hash[node] == b_hash[node]);
    }

    vector<bool> findAnswer(vector<int>& par, string t) {
        int n = par.size();
        vec.resize(n);
        s = t;
        ans.resize(n, false);
        len.resize(n);
        f_hash.resize(n);
        b_hash.resize(n);

        pow_p.resize(n + 1);
        pow_p[0] = 1;
        for (int i = 1; i <= n; i++) {
            pow_p[i] = pow_p[i - 1] * P % MOD;
        }

        for (int i = 1; i < n; i++) {
            vec[par[i]].push_back(i);
        }

        for(int i = 0; i < n; i++) {
            sort(vec[i].rbegin(), vec[i].rend());
        }

        dfs(0);

        return ans;
    }
}; 
",1427926396
9560kiran,9560kiran,253,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int INF = 1e9;
        int n = nums.size();

        vector<int> primes;
        const int MAX_PRIME = 1000; 
        vector<bool> is_prime(MAX_PRIME + 1, true);
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= MAX_PRIME; ++i) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (int j = i * i; j <= MAX_PRIME; j += i) {
                    is_prime[j] = false;
                }
            }
        }

        auto smallestPrimeFactor = [&](int n) -> int {
            if (n <= 1) return n;
            for (int p : primes) {
                if (p * p > n) break;
                if (n % p == 0) return p;
            }
            return n; 
        };

        int dp0 = 0, dp1 = INF;
        int prev_value0 = nums[0], prev_value1 = INF;

        int spf = smallestPrimeFactor(nums[0]);
        if (nums[0] != spf) {
            dp1 = 1;
            prev_value1 = spf;
        }

        for (int i = 1; i < n; i++) {
            int curr_values[2] = {nums[i], INF};
            int curr_ops[2] = {0, INF};

            int spf_i = smallestPrimeFactor(nums[i]);
            if (nums[i] != spf_i) {
                curr_values[1] = spf_i;
                curr_ops[1] = 1;
            }

            int new_dp0 = INF, new_dp1 = INF;
            int new_prev_value0 = INF, new_prev_value1 = INF;

            for (int prev_option = 0; prev_option < 2; prev_option++) {
                int dp_prev = (prev_option == 0) ? dp0 : dp1;
                int prev_value = (prev_option == 0) ? prev_value0 : prev_value1;
                if (dp_prev == INF) continue;

                if (curr_values[0] >= prev_value) {
                    int total_ops = dp_prev + curr_ops[0];
                    if (total_ops < new_dp0) {
                        new_dp0 = total_ops;
                        new_prev_value0 = curr_values[0];
                    }
                }
            }

            if (curr_values[1] != INF) {
                for (int prev_option = 0; prev_option < 2; prev_option++) {
                    int dp_prev = (prev_option == 0) ? dp0 : dp1;
                    int prev_value = (prev_option == 0) ? prev_value0 : prev_value1;
                    if (dp_prev == INF) continue;

                    if (curr_values[1] >= prev_value) {
                        int total_ops = dp_prev + curr_ops[1];
                        if (total_ops < new_dp1) {
                            new_dp1 = total_ops;
                            new_prev_value1 = curr_values[1];
                        }
                    }
                }
            }

            dp0 = new_dp0;
            prev_value0 = new_prev_value0;
            dp1 = new_dp1;
            prev_value1 = new_prev_value1;
        }

        int total_operations = min(dp0, dp1);
        return (total_operations == INF) ? -1 : total_operations;
    }
};
",1427861074
Vitalii Nevidomyi,deadRabbit,254,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res = 0;
        for (int b = 0; b < s.size(); ++b) {
            int C[26]={0};
            int mx = 0;
            
            for (int i = b; i < s.size(); ++i) {
                if (mx < k) {
                    C[s[i]-'a']++;
                    mx = max(mx, C[s[i]-'a']);
                } 
                if (mx>=k)++res;
            }
        }
        return res;
    }
};",1427825819
Vitalii Nevidomyi,deadRabbit,254,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string T) {
        string S;
        vector<string> r;
        int i = 0;
        while(i != T.size()) {
            S += 'a';
            r.push_back(S);
            while(S[i]!=T[i]) {
                S[i]++;
                r.push_back(S);
            }
            ++i;
        }
        return r;
    }
};",1427824064
Vitalii Nevidomyi,deadRabbit,254,3603,cpp,"const int PRIME = 29;
const int MODULE = 990000023;

int P[111111];

int H1[111111];
int H2[111111];
int L[111111];

string S;
vector<vector<int>> G;
void go(int x) {
    
    for (int y : G[x]) go(y);
    int h1 = 0;
    int n = 0;
    for (int y : G[x]) {
        h1 = ((long long)h1 + (1ll*H1[y]*P[n]))%MODULE;
        n += L[y];
    }
    // add last: 
    h1 = ((long long)h1 + (1ll*(S[x]-'a'+1)*P[n]))%MODULE;
    
    // add first:
    int h2 = (S[x]-'a'+1);
    n = 1;
    for (int i = (int)G[x].size()-1; i>=0; --i) {
        int y = G[x][i];
        h2 = ((long long)h2 + (1ll*H2[y]*P[n]))%MODULE;
        n += L[y];
    }
    
    H1[x]=h1;
    H2[x]=h2;
    L[x]=n;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        S=s;
        P[0]=1;
        for (int i = 1; i < s.size(); ++i) {
          P[i] = ((long long)P[i-1] * PRIME)%MODULE;
        }
        G = vector<vector<int>>(s.size());
        for (int i = 1; i < parent.size(); ++i) {
            G[parent[i]].push_back(i);
        }
        go(0);
        vector<bool> res;
        for (int i = 0; i < s.size(); ++i) res.push_back(H1[i]==H2[i]);
        return res;
    }
};",1427909985
Vitalii Nevidomyi,deadRabbit,254,3607,cpp,"const int MX = 1000000;
const int INF = 1<<30;

int dp[111111][2];

int fnd(int x) {
    if (x<=2) return x;
    for (int d = 2; d*d <= x; ++d) {
        if (x%d==0) return d;
    }
    return x;
}

class Solution {
public:
    
    int minOperations(vector<int>& A) {
        vector<int> B = {fnd(A[0])};
        dp[0][0]=0;
        dp[0][1]=1;
        for (int i = 1; i < A.size(); ++i) {
            int v = A[i];
            for (int d = 0; d < 2; ++d) {
                dp[i][d]=INF;
                int pr = A[i-1];
                for (int dd = 0; dd < 2; ++dd) {
                    if (pr <= v) {
                        dp[i][d] = min(dp[i][d], dp[i-1][dd] + d);
                    }
                    pr = B[i-1];
                }
                if (!d) {
                    v = fnd(v);
                    B.push_back(v);
                }
            }
        }
        int v = min(dp[A.size()-1][0], dp[A.size()-1][1]);
        return v>=INF ? -1 : v;
    }
};",1427884082
Ngoc-Cuong Nguyen,ngoccuongpvc,255,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        freq = defaultdict(int)
        counter = 0

        l = 0
        res = 0
        for r in range(len(s)):
            freq[s[r]] += 1
            if freq[s[r]] == k:
                counter += 1
            
            while l < r and ((counter > 1) or (counter == 1 and freq[s[l]] < k) or (counter == 1 and freq[s[l]] > k)):
                if freq[s[l]] == k:
                    counter -= 1
                freq[s[l]] -= 1
                l += 1

            # print(l, r, freq)
            if counter:
                res += l + 1

        return res",1427839706
Ngoc-Cuong Nguyen,ngoccuongpvc,255,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = """"
        for c in target:
            t = 'a'
            # cur = cur + ""a""
            res.append(cur + t)

            while t != c:
                t = chr((((ord(t) - ord('a')) + 1) % 26 + ord('a')))
                res.append(cur + t)
            cur = cur + t
        return res",1427825843
Ngoc-Cuong Nguyen,ngoccuongpvc,255,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = defaultdict(list)

        base = 31
        MOD = 10 ** 9 + 7
        p = [1] * (n + 1)
        children_count = [0] * n

        

        for i in range(1, n+1):
            p[i] = (p[i-1] * base) % MOD
        

        for i, p_node in enumerate(parent):
            if p_node == -1:
                continue
            children[p_node].append(i)
        
        def count_children(node):
            children_count[node] = 1
            for child in children[node]:
                count_children(child)
                children_count[node] += children_count[child]
        count_children(0)
        
        hash_array = [0] * (n + 1)
        reversed_hash_array = [0] * (n + 1)

        def dfs(node):
            for child in children[node]:
                dfs(child)
                hash_array[node] = (hash_array[node] * p[children_count[child]] + hash_array[child]) % MOD
            hash_array[node] = (hash_array[node] * base + ord(s[node]) - ord('a')) % MOD

        def reverse_dfs(node):
            
            reversed_hash_array[node] = (ord(s[node]) - ord('a')) % MOD
            for child in reversed(children[node]):
                reverse_dfs(child)
                reversed_hash_array[node] = (reversed_hash_array[node] * p[children_count[child]] + reversed_hash_array[child]) % MOD
            
        dfs(0)
        reverse_dfs(0)

        # print(hash_array)
        # print(reversed_hash_array)

        return [hash_array[i] == reversed_hash_array[i] for i in range(n)]",1427918820
Ngoc-Cuong Nguyen,ngoccuongpvc,255,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        # d = [-1] * (max(nums) + 1)

        def getSmallestDivisor(n):
            for i in range(2, n):
                if i * i > n:
                    return -1
                if n % i == 0:
                    return i
            return -1
        
        res = 0
        max_num = max(nums)
        for num in reversed(nums):
            # if num <= max_num:
            while num > max_num:
                res += 1
                smallest_divisor = getSmallestDivisor(num)
                if smallest_divisor == -1:
                    return -1
                num = smallest_divisor
            max_num = num
        return res",1427854577
wzAHp9GX6W,wzAHp9GX6W,256,3502,cpp,"#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int result = 0;
        
        for (int i = 0; i < n; i++) {
            vector<int> freq(26, 0);
            for (int j = i; j < n; j++) {
                freq[s[j] - 'a']++;
                if (any_of(freq.begin(), freq.end(), [&](int count) { return count >= k; })) {
                    result += n - j; 
                    break; 
                }
            }
        }
        
        return result;
    }
};
",1427832958
wzAHp9GX6W,wzAHp9GX6W,256,3566,cpp,"#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        
        for (char c : target) {
            if (current.empty()) {
                current = ""a"";
            } else {
                current += 'a';
            }
            result.push_back(current);
            
            while (current.back() != c) {
                current.back() = current.back() + 1 > 'z' ? 'a' : current.back() + 1;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427831128
wzAHp9GX6W,wzAHp9GX6W,256,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        
        // Build adjacency list
        vector<vector<int>> adj(n, vector<int>());
        for(int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        
        // Sort the children in increasing order
        for(int i = 0; i < n; i++) {
            sort(adj[i].begin(), adj[i].end());
        }
        
        // Perform iterative post-order traversal to build traversal string
        string traversal = """";
        vector<int> start(n, 0);
        vector<int> end_idx(n, 0);
        int time = 0;
        
        // Stack will store pairs of (node, processed)
        // processed = false means the node has not been processed yet
        // processed = true means the node's children have been processed
        stack<pair<int, bool>> stk;
        stk.push({0, false});
        
        while(!stk.empty()) {
            auto [node, processed] = stk.top();
            stk.pop();
            
            if(processed) {
                // Append the character to traversal string
                traversal += s[node];
                end_idx[node] = time;
                time++;
            }
            else {
                // Assign start time before processing children
                start[node] = time;
                stk.push({node, true});
                // Push children in reverse order to process them in increasing order
                for(int i = adj[node].size() - 1; i >= 0; i--) {
                    stk.push({adj[node][i], false});
                }
            }
        }
        
        // Compute reverse traversal string
        string reverse_traversal = traversal;
        reverse(reverse_traversal.begin(), reverse_traversal.end());
        
        // Define moduli and base for double hashing
        const ll mod1 = 1000000007;
        const ll mod2 = 1000000009;
        const ll base_val = 911382629;
        
        // Precompute power arrays
        vector<ll> power1(n + 1, 1), power2(n + 1, 1);
        for(int i = 1; i <= n; i++) {
            power1[i] = (power1[i-1] * base_val) % mod1;
            power2[i] = (power2[i-1] * base_val) % mod2;
        }
        
        // Compute prefix hashes for traversal string
        vector<ll> prefix_hash1(n + 1, 0), prefix_hash2(n + 1, 0);
        for(int i = 0; i < n; i++) {
            prefix_hash1[i+1] = (prefix_hash1[i] * base_val + traversal[i]) % mod1;
            prefix_hash2[i+1] = (prefix_hash2[i] * base_val + traversal[i]) % mod2;
        }
        
        // Compute prefix hashes for reverse traversal string
        vector<ll> prefix_rhash1(n + 1, 0), prefix_rhash2(n + 1, 0);
        for(int i = 0; i < n; i++) {
            prefix_rhash1[i+1] = (prefix_rhash1[i] * base_val + reverse_traversal[i]) % mod1;
            prefix_rhash2[i+1] = (prefix_rhash2[i] * base_val + reverse_traversal[i]) % mod2;
        }
        
        // Lambda function to get hash of substring [l, r) in traversal string
        auto getHash = [&](int l, int r, const vector<ll> &prefix_hash, const vector<ll> &power, ll mod) -> ll {
            ll res = (prefix_hash[r] - (prefix_hash[l] * power[r - l]) % mod + mod) % mod;
            return res;
        };
        
        // Prepare the answer vector
        vector<bool> answer(n, false);
        
        for(int i = 0; i < n; i++) {
            int l = start[i];
            int r = end_idx[i] + 1; // Exclusive end
            
            // Hash for traversal substring
            ll hash1a = getHash(l, r, prefix_hash1, power1, mod1);
            ll hash1b = getHash(l, r, prefix_hash2, power2, mod2);
            
            // Corresponding in reverse_traversal
            // The reverse substring is [n - r, n - l)
            int rl = n - r;
            int rr = n - l;
            ll hash2a = getHash(rl, rr, prefix_rhash1, power1, mod1);
            ll hash2b = getHash(rl, rr, prefix_rhash2, power2, mod2);
            
            // If both hash pairs match, it's a palindrome
            if(hash1a == hash2a && hash1b == hash2b){
                answer[i] = true;
            }
            else{
                answer[i] = false;
            }
        }
        
        return answer;
    }
};
",1427868425
wzAHp9GX6W,wzAHp9GX6W,256,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        // Step 1: Precompute Smallest Prime Factors (SPF) up to 1e6
        int MAX = 1000001;
        int[] spf = new int[MAX];
        
        for (int i = 2; i < MAX; i++) {
            spf[i] = i;
        }
        
        for (int i = 2; i * i < MAX; i++) {
            if (spf[i] == i) { // If i is prime
                for (int j = i * i; j < MAX; j += i) {
                    if (spf[j] == j) {
                        spf[j] = i; // Mark spf of j as i
                    }
                }
            }
        }

        // Step 2: Initialize DP states for the first element
        long INF = (long) 1e18;
        long prevKeepOps = 0;
        long prevKeepVal = nums[0];
        long prevReduceOps = INF;
        long prevReduceVal = 0;
        
        if (nums[0] > 1 && spf[nums[0]] != nums[0]) {
            prevReduceOps = 1;
            prevReduceVal = spf[nums[0]];
        }

        // Step 3: Iterate through the array
        for (int i = 1; i < nums.length; i++) {
            int currentKeepVal = nums[i];
            int currentReduceVal = 0;
            boolean canReduce = false;

            if (nums[i] > 1 && spf[nums[i]] != nums[i]) {
                canReduce = true;
                currentReduceVal = spf[nums[i]];
            }

            long newKeepOps = INF;
            long newReduceOps = INF;

            // Transition for keeping the current element
            if (currentKeepVal >= prevKeepVal) {
                newKeepOps = Math.min(newKeepOps, prevKeepOps);
            }
            if (currentKeepVal >= prevReduceVal) {
                newKeepOps = Math.min(newKeepOps, prevReduceOps);
            }

            // Transition for reducing the current element
            if (canReduce) {
                if (currentReduceVal >= prevKeepVal) {
                    newReduceOps = Math.min(newReduceOps, prevKeepOps + 1);
                }
                if (currentReduceVal >= prevReduceVal) {
                    newReduceOps = Math.min(newReduceOps, prevReduceOps + 1);
                }
            }

            // If both newKeepOps and newReduceOps are INF, it's impossible
            if (newKeepOps == INF && newReduceOps == INF) {
                return -1;
            }

            // Update DP states for the next iteration
            prevKeepOps = newKeepOps;
            prevKeepVal = currentKeepVal;
            prevReduceOps = newReduceOps;
            prevReduceVal = canReduce ? currentReduceVal : 0;
        }

        // Step 4: Determine the minimum operations from the last element's states
        long result = Math.min(prevKeepOps, prevReduceOps);
        return result >= INF ? -1 : (int) result;
    }
}
",1427838580
Tin,tin_le,257,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res = 0, n = s.size();
        for(int i = 0; i < n; i++) {
            int cnt[26] = {};
            for(int j = i, ok = false; j < n; j++) {
                ok |= ++cnt[s[j] - 'a'] == k;
                if(ok) res++;
            }
        } 
        return res;
    }
};",1427826477
Tin,tin_le,257,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr;
        for(auto& it : target) {
            char ch = 'a';
            while(ch <= it) {
                res.push_back(curr + ch);
                ch++;
            } 
            curr += it; 
        } 
        return res;
    }
};",1427825155
Tin,tin_le,257,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        using ll = long long;
        int n = parent.size();
        vector<vector<int>> graph(n);
        for(int i = 1; i < n; i++) graph[parent[i]].push_back(i);
        vector<bool> ans(n);
        int mod1 = 1e9 + 7, mod2 = 1e9 + 33, base1 = 26, base2 = 27;
        vector<ll> p1(n + 1, 1), p2(n + 1, 1), h1(n), h11(n), h2(n), h22(n);
        for(int i = 1; i <= n; i++) {
            p1[i] = (p1[i - 1] * base1) % mod1;
            p2[i] = (p2[i - 1] * base2) % mod2;
        }
        vector<int> L(n, 1); 
        auto dfs = [&](auto& dfs, int node = 0) -> void {
            auto& x = L[node];
            for(auto& nei : graph[node]) {
                dfs(dfs, nei);
                x += L[nei];
            }
            for(auto& nei : graph[node]) {
                h1[node] = (h1[node] * p1[L[nei]] + h1[nei]) % mod1;
                h2[node] = (h2[node] * p2[L[nei]] + h2[nei]) % mod2;
            }
            ll id = s[node] - 'a' + 1;
            h1[node] = (h1[node] * base1 + id) % mod1;
            h2[node] = (h2[node] * base2 + id) % mod2;
            ll hr1 = (id * p1[x - 1]) % mod1;
            ll hr2 = (id * p2[x - 1]) % mod2;
            for(int i = graph[node].size() - 1, len = x - 1; i >= 0; i--) {
                int nei = graph[node][i];
                len -= L[nei];
                hr1 = (hr1 + h11[nei] * p1[len]) % mod1;
                hr2 = (hr2 + h22[nei] * p2[len]) % mod2;
            }
            h11[node] = hr1, h22[node] = hr2;
            ans[node] = h1[node] == h11[node] && h2[node] == h22[node];
        };
        dfs(dfs);
        return ans;
    }
};",1427918911
Tin,tin_le,257,3607,cpp,"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗
//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝
//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░
//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░
//░░░██║░░░██║██║░╚███║  ███████╗███████╗
//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))

//SGT DEFINE
#define lc i * 2 + 1
#define rc i * 2 + 2
#define lp lc, left, middle
#define rp rc, middle + 1, right
#define entireTree 0, 0, n - 1
#define midPoint left + (right - left) / 2
#define pushDown push(i, left, right)
#define iterator int i, int left, int right

#define IOS ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)

struct custom {
    static const uint64_t C = 0x9e3779b97f4a7c15; const uint32_t RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();
    size_t operator()(uint64_t x) const { return __builtin_bswap64((x ^ RANDOM) * C); }
    size_t operator()(const std::string& s) const { size_t hash = std::hash<std::string>{}(s); return hash ^ RANDOM; } };
template <class K, class V> using umap = std::unordered_map<K, V, custom>; template <class K> using uset = std::unordered_set<K, custom>;
    
 
template<typename T> vt<T> uniqued(vt<T> arr) {  srtU(arr); return arr; }

#ifdef LOCAL
#define debug(x...) debug_out(#x, x)
void debug_out(const char* names) { std::cerr << std::endl; }
template <typename T, typename... Args>
void debug_out(const char* names, T value, Args... args) {
    const char* comma = strchr(names, ',');
    std::cerr << ""["" << (comma ? std::string(names, comma) : names) << "" = "" << value << ""]"";
    if (sizeof...(args)) { std::cerr << "", ""; debug_out(comma + 1, args...); }   
    else { std::cerr << std::endl; }
}
#define startClock clock_t tStart = clock();
#define endClock std::cout << std::fixed << std::setprecision(10) << ""\nTime Taken: "" << (double)(clock() - tStart) / CLOCKS_PER_SEC << "" seconds"" << std::endl;
#else
#define debug(...)
#define startClock
#define endClock

#endif
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#define eps 1e-9
#define M_PI 3.14159265358979323846
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int pct(ll x) { return __builtin_popcountll(x); }
const vvi dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
const vpii dirs_3_3 = { 
        {0,1}, {0,3},
        {1,0}, {1,2}, {1,4},
        {2,1}, {2,5},
        {3,0}, {3,4}, {3,6},
        {4,1}, {4,3}, {4,5}, {4,7},
        {5,2}, {5,4}, {5,8},
        {6,3}, {6,7},
        {7,4}, {7,6}, {7,8},
        {8,5}, {8,7}
};

int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
void multiply(int f[2][2], int m[2][2]) {   
    int res[2][2] = {}; 
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++)  {   for(int k = 0; k < 2; k++)  {   res[i][j] = (res[i][j] + f[i][k] * m[k][j]) % MOD; }   }   }   
    for(int i = 0; i < 2; i++)  {   for(int j = 0; j < 2; j++) f[i][j] = res[i][j]; }   }
int fib(int n)  {       if(n == 0) return 0;        if(n == 1) return 1;    
    int f[2][2] = {{1, 1}, {1, 0}}; int res[2][2] = {{1, 0}, {0, 1}};       
    while(n)    {   if(n & 1) multiply(res, f); multiply(f, f); n >>= 1;    }   return res[0][1] % MOD; }   

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int M = MAX(nums) + 1;
        vi div(M);
        for(int i = 2; i < M; i++) {
            if(div[i]) continue;
            div[i] = i;
            for(int j = i; j < M; j += i) {
                if(div[j] == 0) div[j] = i;
            }
        } 
        int res = 0, n = nums.size();
        for(int i = n - 1, target = 1e9; i >= 0; i--) {
            int x = nums[i];
            while(x > target) {
                if(div[x] == x) return -1;
                x = div[x];
                res++;
            }
            target = x;
        }
        return res;

    }
};",1427854970
yc-li,yc-li,258,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        cnt = defaultdict(int)
        f = 0
        i = 0
        ans = 0
        for j in range(n):
            cnt[s[j]] += 1
            if cnt[s[j]] == k:
                f += 1

            while f >= 1 and i <= j:
                cnt[s[i]] -= 1
                if cnt[s[j]] == k - 1:
                    f -= 1
                i += 1

            ans += i
        
        return ans
",1427831601
yc-li,yc-li,258,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        n = len(target)
        ans = []

        s = """"
        for i in range(n):
            c = ""a""
            ans.append(s + c)
            while c != target[i]:
                c = chr(ord(c) + 1)
                ans.append(s + c)
            s = s + c
        
        return ans",1427824511
yc-li,yc-li,258,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], ss: str) -> List[bool]:
        n = len(ss)
        ll = [0] * n
        child = [[] for i in range(n)]
        for i, p in enumerate(parent):
            if p == -1:
                continue
            child[p].append(i)
        for i in child:
            i.sort()
        
        s = []
        idx = [None] * n
        def dfs(x):
            v = None
            for c in child[x]:
                if v is None:
                    v = dfs(c)
                else:
                    dfs(c)
            idx[x] = len(s)
            s.append(ss[x])
            ll[idx[x]] = v if v is not None else x
            return ll[idx[x]]

        inv_idx = [None] * n
        dfs(0)
        for i in range(n):
            ll[i] = idx[ll[i]]
            inv_idx[idx[i]] = i
        # print(child, ll, idx, s)

        d1 = [0] * n
        l, r = 0, -1
        for i in range(0, n):
            k = 1 if i > r else min(d1[l + r - i], r - i + 1)
            while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:
                k += 1
            d1[i] = k
            k -= 1
            if i + k > r:
                l = i - k
                r = i + k

        d2 = [0] * n
        l, r = 0, -1
        for i in range(0, n):
            k = 0 if i > r else min(d2[l + r - i + 1], r - i + 1)
            while 0 <= i - k - 1 and i + k < n and s[i - k - 1] == s[i + k]:
                k += 1
            d2[i] = k
            k -= 1
            if i + k > r:
                l = i - k - 1
                r = i + k

        # print(d1, d2)
        
        ans = [False] * n

        for i in range(n):
            if ll[i] & 1 == i & 1:
                m = (i + ll[i]) // 2
                if d1[m] >= (i - ll[i]) // 2 + 1:
                    ans[inv_idx[i]] = True
            else:
                m = (i + ll[i] + 1) // 2
                if d2[m] >= (i - ll[i] + 1) // 2:
                    ans[inv_idx[i]] = True
        
        return ans",1427919222
yc-li,yc-li,258,3607,python3,"mapping = [1] * ((10**6) + 1)
for i in range(2, 10**6 + 1):
    for j in range(i * 2, 10**6 + 1, i):
        mapping[j] = max(mapping[j], i)


class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        c = nums[-1]

        
        # print(mapping[1:106])

        for i in range(n - 2, -1, -1):
            while nums[i] > c and mapping[nums[i]] != 1:
                nums[i] = nums[i] // mapping[nums[i]]
                ans += 1
            if nums[i] > c:
                return -1
            
            c = nums[i]

        return ans",1427851938
Harttle,harttle,261,3502,javascript,"/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var numberOfSubstrings = function(s, K) {
    const N = s.length
    const counts = Array(26).fill(0)
    let ans = 0
    for (let i = 0, j = 0; i < N; i++) {
        while (maxCount(counts) < K && j < N) {
            counts[s.charCodeAt(j++) - 97]++
        }
        // console.log(`i=${i}, j=${j} ans+=${N - j}`)
        if (maxCount(counts) >= K) ans += N - j + 1
        counts[s.charCodeAt(i) - 97]--
    }
    return ans
    function maxCount(counts) {
        return Math.max(...counts)
    }
};",1427838573
Harttle,harttle,261,3566,javascript,"/**
 * @param {string} target
 * @return {string[]}
 */
var stringSequence = function(target) {
    target = [...target].map(x => x.charCodeAt() - 97)
    const ans = []
    for (let i = 0; i < target.length; i++) {
        let prev = ans.length ? [...ans[ans.length - 1]] : []
        for (let j = 0; j <= target[i]; j++) {
            ans.push([...prev, j])
        }
    }
    return ans.map(arr => arr.map(x => String.fromCharCode(x + 97)).join(''))
};",1427829792
Harttle,harttle,261,3603,javascript,"const MOD = 1e7 + 7
const powers1 = [1]
const powers2 = [1]
const MUL1 = 29, MUL2 = 31
for (let i = 0; i <= 1e5; i++) {
    powers1.push(powers1[powers1.length - 1] * MUL1 % MOD)
    powers2.push(powers2[powers2.length - 1] * MUL2 % MOD)
}
// console.log(powers1)
// console.log(powers2)
/**
 * @param {number[]} parent
 * @param {string} s
 * @return {boolean[]}
 */
var findAnswer = function(parent, s) {
    const N = parent.length
    const G = Array(N).fill(0).map(x => [])
    for (let i = 1; i < N; i++) {
        G[parent[i]].push(i)
    }
    const ans = Array(N)
    dfs(0)
    return ans
    function dfs(u) {
        const fs = [], bs = []
        for (const v of G[u]) {
            const [f, b] = dfs(v)
            fs.push(f)
            bs.push(b)
        }
        fs.push(parse(s[u]))
        bs.push(parse(s[u]))
        const f = aggregate(fs)
        const b = aggregate(bs.reverse())
        ans[u] = eq(f, b)
        // console.log(u, `f=${f} b=${b}`)
        return [f, b]
    }
    function eq(f, b) {
        return f.count === b.count && f.hash1 === b.hash1 && f.hash2 === b.hash2
    }
    function parse(char) {
        const code = char.charCodeAt(0) - 97
        return {count: 1, hash1: code, hash2: code}
    }
    function aggregate(arr) {
        let count = 0
        let hash1 = 0, hash2 = 0
        for (const part of arr) {
            count += part.count
            hash1 = hash1 * powers1[part.count] % MOD
            hash1 = (hash1 + part.hash1) % MOD
            hash2 = hash2 * powers2[part.count] % MOD
            hash2 = (hash2 + part.hash2) % MOD
        }
        return {count, hash1, hash2}
    }
};",1427911272
Harttle,harttle,261,3607,javascript,"/**
 * @param {number[]} nums
 * @return {number}
 */
var minOperations = function(nums) {
    const N = nums.length
    const reducedNums = nums.map(num => minPrimeFactor(num))
    let prev = Infinity
    let ans = 0
    for (let i = N - 1; i >= 0; i--) {
        const num = nums[i]
        const reduced = reducedNums[i]
        if (num <= prev) {
            prev = num
        } else if (reduced <= prev) {
            prev = reduced
            ans++
        } else return -1
    }
    return ans
};
// src/prime.ts
function eulersSieve(n) {
  const primes = [];
  const isPrime2 = Array(n + 1).fill(true);
  for (let cand = 2; cand <= n; cand++) {
    if (isPrime2[cand])
      primes.push(cand);
    for (const prime2 of primes) {
      if (prime2 * cand > n)
        break;
      isPrime2[prime2 * cand] = false;
      if (cand % prime2 === 0)
        break;
    }
  }
  return primes;
}
function eratosthenesSieve(n) {
  const isPrime2 = Array(n + 1).fill(true);
  for (let p = 2; p * p <= n; p++) {
    if (isPrime2[p]) {
      for (let j = p * p; j <= n; j += p) {
        isPrime2[j] = false;
      }
    }
  }
  const primes = [];
  for (let i = 2; i <= n; i++)
    if (isPrime2[i])
      primes.push(i);
  return primes;
}
function prime(nth) {
  let f = 20;
  if (nth > 5e7)
    f = 50;
  if (nth > 1e22)
    f = 100;
  return primesLeq(f * nth)[nth - 1];
}
function primesLeq(n) {
  return n < 1e3 ? eratosthenesSieve(n) : eulersSieve(n);
}
function isPrime(n) {
  if (n < 2)
    return false;
  const primes = primesLeq(Math.floor(Math.sqrt(n)));
  for (const p of primes)
    if (n % p === 0)
      return false;
  return true;
}
function minPrimeFactor(n) {
//   const factors = new Map();
  const sqrt = Math.sqrt(n);
  for (let f = 2; f <= sqrt; f++) {
    if (n % f === 0) {
        return f
    }
  }
  return n
}",1427853098
nhienle94,nhienle94,263,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        left = 0
        ans = 0
        counter = [0]*26
        n = len(s)
        for right in range(len(s)):
            index = ord(s[right]) - ord('a')
            counter[index] += 1
            while counter[index] == k:
                ans += n - right
                leftIndex = ord(s[left]) - ord('a')
                counter[leftIndex] -= 1
                left += 1

        return ans",1427834698
nhienle94,nhienle94,263,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        last = """"
        for char in target:
            current = ""a""
            ans.append(last + current)
            while current != char:
                current = chr(ord(current) + 1)
                ans.append(last + current)

            last = last + current

        return ans
",1427830649
nhienle94,nhienle94,263,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        ans = []
        n = len(s)
        ans = """"
        graph = defaultdict(list)
        
        for i in range(n):
            graph[parent[i]].append(i)

        for key, values in graph.items():
            graph[key] = sorted(values)
    
        graph.pop(-1)

        ans = [False]*n
        def dfs(node):
            if node == None:
                return """"
            
            string = """"
            for neighbor in graph[node]:
                string += dfs(neighbor)

            string += s[node]
            length = len(string)
            if length == 1:
                ans[node] = True
            elif length%2 == 0 and string[:length//2] == string[length//2:][::-1]:
                ans[node] = True
            elif length%2 == 1 and string[:length//2] == string[length//2 + 1:][::-1]:
                ans[node] = True

            return string

        dfs(0)
        return ans",1427929084
nhienle94,nhienle94,263,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        @lru_cache(None)
        def findDivisor(num):
            factors = set()
            properDivisor = -1
            for i in range(2, int(sqrt(num) + 1)):
                if num%i == 0:
                    if i < num:
                        properDivisor = max(properDivisor, i)
                    
                    if num%(num//i) == 0 and num//i < num:

                        properDivisor = max(properDivisor, num//i )

            return properDivisor

        n = len(nums)
        operations = 0
        for i in range(n - 2, -1, -1):
            divisor = findDivisor(nums[i])
            if divisor == -1 and nums[i] > nums[i + 1]:
                return -1
            
            while nums[i] > nums[i + 1]:
                nums[i]//= divisor
                operations += 1
                divisor = findDivisor(nums[i])
                if divisor == -1:
                    break

            if nums[i] > nums[i + 1]:
                return -1

        return operations",1427854539
aman_bedi,AmanBedi,264,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0; 
        for(int i=0;i<s.size();++i){
            bool good = false;
            int arr[26]={0};
            for(int j=i;j<s.size();++j){
                arr[s[j]-'a']++; 
                if(arr[s[j]-'a']>=k){
                    good = 1;
                } 
                if(good){
                    ans++;
                }
            }
        } 
        return ans;
    }
};",1427842017
aman_bedi,AmanBedi,264,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans; 
        ans.push_back(""""); 
        
        for(int i=0;i<target.size();++i){
            string temp = ans.back(); 
            char ch = 'a';
            while(ch!=target[i]){
                ans.push_back(temp + ch);
                ++ch; 
            } 
            ans.push_back(temp+ch);
        } 
        vector<string>res; 
        for(int i=1;i<ans.size();++i){
            res.push_back(ans[i]);
        }
        return res;
    }
};",1427832158
aman_bedi,AmanBedi,264,3603,cpp,"class Solution {
public:
    vector<int>v[100001]; 
    int cnt[100001]; 
    int mod = 1e9+7; 
    int base = 31;
    long long pw[100001];
    long long mp(char ch){
        return (ch-'a')+1;
    }
    pair<long long,long long>dfs(int src,int par, string&s, vector<bool>&ans){
        bool leaf = true;
        cnt[src]=1;
        vector<long long>forward, backward, sz;
        for(auto it:v[src]){
            if(it==par){
                continue;
            }  
            leaf = false; 
            auto p = dfs(it,src,s,ans); 
            forward.push_back(p.first); 
            backward.push_back(p.second); 
            cnt[src]+=cnt[it]; 
            sz.push_back(cnt[it]);
        } 
        
        if(leaf){
            ans[src]=1; 
            return {mp(s[src]), mp(s[src])};
        }  
        
        long long fhash = 0, bhash = 0; 
        
        fhash = forward[0]; 
        long long flen = sz[0];
        for(int i=1;i<forward.size();++i){
            fhash = ((fhash%mod) + (forward[i]*pw[flen])%mod)%mod; 
            flen+=sz[i];
        }  
        
        reverse(backward.begin(), backward.end()); 
        reverse(sz.begin(),sz.end()); 
        bhash = backward[0];
        long long blen = sz[0]; 
        for(int i=1;i<backward.size();++i){
            bhash = ((bhash%mod) + (backward[i]*pw[blen])%mod)%mod; 
            blen+=sz[i];
        } 
        
        // cout<<src<<' '<<fhash<<' '<<bhash<<'\n'; 
        
        
        fhash = ((fhash%mod) + (pw[flen]*mp(s[src]))%mod)%mod; 
        bhash = ((bhash*pw[1])%mod + mp(s[src])%mod)%mod; 
        
        if(fhash == bhash){
            ans[src]=1;
        }
        
//         cout<<src<<' '<<fhash<<' '<<bhash<<'\n'; 
//         cout<<""forward: "";
//         for(auto it:forward){
//             cout<<it<<' ';
//         } 
//         cout<<'\n';;
//         reverse(backward.begin(), backward.end()); 
//         reverse(sz.begin(),sz.end()); 
        
//         cout<<""backward: "";
//         for(auto it:backward){
//             cout<<it<<' ';
//         } 
//         cout<<'\n'; 
//         cout<<""sz: "";
//         for(auto it:sz){
//             cout<<it<<' ';
//         } 
//         cout<<'\n';
        
        
        return {fhash, bhash};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        pw[0] = 1;
        for(int i=1;i<=parent.size();++i){
            pw[i]  = (pw[i-1]*1LL*base)%mod;
        }
        for(int i=1;i<parent.size();++i){
            v[parent[i]].push_back(i); 
        }
        for(int i=0;i<parent.size();++i){
            sort(v[i].begin(),v[i].end());  
        } 
        vector<bool>ans(parent.size(),0);
        dfs(0,-1,s, ans);    
        return ans;
    }
};",1427929160
aman_bedi,AmanBedi,264,3607,cpp,"class Solution {
public: 
    int p(int n){
        for(int i=2;i*i<=n;++i){
            if(n%i==0){
                return i; 
            }
        } 
        return n;
    }
    int find(vector<int>&nums){
        int ans = 0; 
        int n = nums.size();
        for(int i=n-2;i>=0;--i){
            if(nums[i]<=nums[i+1]){
                continue;
            }
            int x = p(nums[i]); 
            if(x>nums[i+1]){
                return INT_MAX;
            } 
            nums[i] = x; 
            ++ans;
        } 
        return ans;
    }
    int minOperations(vector<int>& nums) {
        int ans = INT_MAX;  
        vector<int>diff = nums; 
        int x = p(diff.back()); 
        diff[diff.size()-1] = x; 
        
        int z = find(nums);
        int y = find(diff); 
        
        if(z!=INT_MAX){
            ans = z;
        } 
        if(y!=INT_MAX){
            ans = min(ans,y);
        } 
        if(ans==INT_MAX)ans=-1; 
        return ans;
        
        
    }
};
  ",1427860912
Samyak Jain,Sloth_junkie,265,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.size();
        for(int i = 0; i<n; i++)
        {
            vector<int> v1(26,0);
            int till = 0;
            for(int j = i; j<n; j++)
            {
                v1[s[j]-'a']++;
                if(v1[s[j]-'a'] >= k)
                {
                    till = 1;
                }
                if(till)
                {
                    ans++;
                }
            }
        }
        return ans;
    }
};",1427826442
Samyak Jain,Sloth_junkie,265,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        int n = target.size();
        string till;
        for(int i = 0; i<n; i++)
        {
            for(int x = 'a'; x<=target[i]; x++)
            {
                string s1 = till;
                s1.push_back(x);
                ans.push_back(s1);
            }
            till.push_back(target[i]);
        }
        return ans;
    }
};",1427824626
Samyak Jain,Sloth_junkie,265,3603,cpp,"class Solution {
public:
    long long base = 31;
    long long mod = 1e9+7;
    void fun(long long node, vector<vector<long long>>&adj, vector<long long>&v1, vector<vector<long long>> &v2, string& s, vector<bool> &ans)
    {
        for(auto it:adj[node])
        {
            fun(it,adj,v1,v2,s,ans);
        }
        long long hash1 = s[node]-'a'+1;

        int siz = 1;
        for(int i = adj[node].size()-1; i>=0; i--)
        {
            vector<long long> temp = v2[adj[node][i]];
            siz += temp[2];
            hash1 *= v1[temp[2]];
            hash1 %= mod;
            hash1 += temp[0];
            hash1 %= mod;
        }  

        long long hash2 = 0;
        for(int i = 0; i<adj[node].size(); i++)
        {
            vector<long long> temp = v2[adj[node][i]];
            hash2 *= v1[temp[2]];
            hash2 %= mod;
            hash2 += temp[1];
            hash2 %= mod;
        }
        hash2 *= base;
        hash2 %= mod;
        hash2 += s[node]-'a'+1;
        hash2 %= mod;

        if(hash1 == hash2)
        {
            ans[node] = true;
        }
        v2[node] = {hash1,hash2,siz};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        
        int n = parent.size();
        vector<long long> v1(n+1);
        v1[0] = 1;
        for(int i = 1; i<=n; i++)
        {
            v1[i] = v1[i-1];
            v1[i] *= base;
            v1[i] %= mod;
        }

        vector<bool> ans(n);

        vector<vector<long long>> adj(n);
        for(int i = 1; i<n; i++)
        {
            adj[parent[i]].push_back(i);
        }
        for(int i = 0; i<n; i++)
        {
            sort(adj[i].begin(),adj[i].end());
        }

        vector<vector<long long>> v2(n);
        fun(0,adj,v1,v2,s,ans);

        // cout<<v2[1][0]<<"" ""<<v2[1][1]<<endl;
        return ans;
    }
};",1427895285
Samyak Jain,Sloth_junkie,265,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int maxi = -1e9;
        for(auto it:nums)
        {
            maxi = max(maxi,it);
        }
        const int MAX = maxi + 1;
        
        int isPrime[MAX];
        int lp[MAX];

        for(int i = 0; i < MAX; i++) {
            isPrime[i] = 1;
        }
        isPrime[0] = 0;
        isPrime[1] = 0;

        for(int i = 0; i < MAX; i++) {
            lp[i] = i;
        }

        for(int i = 2; i * i <= maxi; i++) {
            if(isPrime[i] == 1) {
                for(int j = i * i; j <= maxi; j += i) {
                    isPrime[j] = 0;
                    if(lp[j] == j) {
                        lp[j] = i;
                    }
                }
            }
        }

        int n = nums.size();
        int ans = 0;
        int last = nums[n - 1];

        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] <= last) {
                last = nums[i];
            } else {
                if(lp[nums[i]] <= last) {
                    ans++;
                    last = lp[nums[i]];
                } else {
                    return -1;
                }
            }
        }

        return ans;
    }
};
",1427912947
boxlesscat,boxlesscat,268,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string str, int k) {
        vector<int> f(26);
        int ans = 0;
        const int size = str.size();
        int l = 0;
        int r = 0;
        while (r < size) {
            while (r < size) {
                char ch = str[r];
                int c = ch - 'a';
                ++r;
                if (++f[c] == k) {
                    break;
                }
            }
            while (l < r) {
                char ch = str[l];
                int c = ch - 'a';
                if (f[str[r - 1] - 'a'] == k) {
                    ans += size - r + 1;
                }
                ++l;
                if (--f[c] == k - 1) {
                    break;
                }
            }
        }
        return ans;
    }
};",1427835862
boxlesscat,boxlesscat,268,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string str;
        vector<string> ans;
        for (char ch: target) {
            str.push_back('a');
            ans.push_back(str);
            for (char j = 'b'; j <= ch; ++j) {
                str.back() = j;
                ans.push_back(str);
            }
        }
        return ans;
    }
};",1427825250
boxlesscat,boxlesscat,268,3603,cpp,"vector<int> manacher_odd(const string& s) {
    int n = s.size();
    int l = 1;
    int r = 1;
    string str = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    for (int i = 1; i <= n; ++i) {
        p[i] = max(0, min(r - i, p[l + r - i]));
        while (str[i - p[i]] == str[i + p[i]])
            ++p[i];
        if (i + p[i] > r) {
            l = i - p[i];
            r = i + p[i];
        }
    }
    return vector<int>(p.begin() + 1, p.end() - 1);
}


pair<vector<int>, vector<int>> manacher(const string& str) {
    string t = ""#"";
    for (char ch: str) {
        t += ch;
        t += '#';
    }
    vector<int> d = manacher_odd(t);
    pair<vector<int>, vector<int>> D;
    auto& [dodd, devn] = D;
    const int n = str.size();
    for (int i = 0; i < n; ++i)
        devn.push_back(d[2 * i] - 1 >> 1);
    for (int i = 0; i < n; ++i)
        dodd.push_back(d[2 * i + 1] - 1 >> 1);
    return D;
}

class Solution {

    vector<vector<int>> adj;
    vector<int> subtree;
    vector<int> node;
    string str;
    string dfs_str;

    int dfs(int u, int a) {
        int subtree_size = 1;
        for (int v: adj[u]) {
            if (v != a) {
                subtree_size += dfs(v, u);
            }
        }
        dfs_str.push_back(str[u]);
        node.push_back(u);
        subtree.push_back(subtree_size);
        return subtree_size;
    }


public:
    vector<bool> findAnswer(vector<int>& parent, string str) {
        Solution::str = move(str);
        const int n = parent.size();
        adj.assign(n, vector<int>());
        for (int i = 0; i < n; ++i) {
            int p = parent[i];
            int u = i;
            if (p != -1) {
                adj[u].push_back(p);
                adj[p].push_back(u);
            }
        }
        for (auto& vec: adj) {
            sort(vec.begin(), vec.end());
        }
        dfs(0, -1);
        vector<bool> ans(n);
        auto[dodd, devn] = manacher(dfs_str);
        for (int i = 0; i < n; ++i) {
            int sbt = subtree[i];
            if (sbt & 1) {
                int idx = i - sbt / 2;
                if (dodd[idx] * 2 + 1 >= sbt) {
                    ans[node[i]] = true;
                }
            } else {
                int idx = i - sbt / 2 + 1;
                if (devn[idx] * 2 >= sbt) {
                    ans[node[i]] = true;
                }
            }
        }
        return ans;
    }
};",1427921909
boxlesscat,boxlesscat,268,3607,cpp,"using ll = long long;

vector<int> gpd;
vector<int> is_prime;

int sieve(int N) {

    is_prime.assign(N + 1, true);
    gpd.assign(N + 1, 1);
    is_prime[0] = is_prime[1] = false;

    for (ll p = 2; p <= N; p++) {
        if (is_prime[p]) {
            for (ll j = p * p; j <= N; j += p) {
                is_prime[j] = false;
                gpd[j] = max<ll>(gpd[j], j / p);
            }
        }
    }

    return 0;

}

int ____ = sieve(2e6);

class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int size = nums.size();
        int ans = 0;
        for (int i = size - 2; i >= 0; --i) {
            int nxt = nums[i + 1];
            int num = nums[i];
            if (nxt >= num)
                continue;
            while (num > nxt) {
                int g = gpd[num];
                if (g == 1)
                    return -1;
                num /= g;
                ++ans;
            }
            nums[i] = num;
        }
        return ans;
    }
};",1427856914
Behrooz Sepehry,sepehry,272,3502,python3,"
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        sol = 0
        for i in range(n):
            counts = [0] * 26
            ok = False
            for j in range(i, n):
                c = s[j]
                o = ord(c) - ord('a')
                counts[o] += 1
                if counts[o] >= k:
                    ok = True
                    break
            if ok:
                sol += n - j
        return sol
",1427832960
Behrooz Sepehry,sepehry,272,3566,python3,"
class Solution:
    def stringSequence(self, target: str) -> List[str]:
        sol = []
        cur = []
        for i, c in enumerate(target):
            cur.append('a')
            for c2 in string.ascii_lowercase:
                if c2 <= c:
                    cur[i] = c2
                else:
                    break
                sol.append(''.join(cur))
        return sol
",1427826299
Behrooz Sepehry,sepehry,272,3603,python3,"
class SHash:
    def __init__(self, input_string):
        self.input_string = input_string
        self.prime1 = 31
        self.prime2 = 37
        self.mod1 = 10 ** 9 + 7
        self.mod2 = 10 ** 9 + 9
        self.precompute_hashes()

    def precompute_hashes(self):
        n = len(self.input_string)
        self.hash1 = [0] * (n + 1)
        self.hash2 = [0] * (n + 1)
        self.pow1 = [1] * (n + 1)
        self.pow2 = [1] * (n + 1)

        for i in range(n):
            self.hash1[i + 1] = (self.hash1[i] * self.prime1 + ord(self.input_string[i])) % self.mod1
            self.hash2[i + 1] = (self.hash2[i] * self.prime2 + ord(self.input_string[i])) % self.mod2
            self.pow1[i + 1] = (self.pow1[i] * self.prime1) % self.mod1
            self.pow2[i + 1] = (self.pow2[i] * self.prime2) % self.mod2

    def hash(self, start: int, end: int):
        hash_val1 = (self.hash1[end + 1] - self.hash1[start] * self.pow1[end - start + 1]) % self.mod1
        hash_val2 = (self.hash2[end + 1] - self.hash2[start] * self.pow2[end - start + 1]) % self.mod2

        return (hash_val1, hash_val2)


class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = [[] for _ in range(n)]

        for ii, pp in enumerate(parent):
            if pp != -1:
                children[pp].append(ii)

        I = [0] * n
        L = [1] * n
        dfs_str = []

        def dfs(node):
            for node2 in children[node]:
                dfs(node2)
                L[node] += L[node2]
            dfs_str.append(s[node])
            I[node] = len(dfs_str) - 1

        dfs(0)

        shash1 = SHash(dfs_str)
        shash2 = SHash(dfs_str[::-1])

        def ispal(node):
            right = I[node]
            left = right - L[node] + 1
            if L[node] % 2 == 0:
                midleft = (right + left) // 2
                midright = midleft + 1
            else:
                midright = midleft = (right + left) // 2

            hright = shash1.hash(midright, right)
            hleft = shash2.hash(n - 1 - midleft, n - 1 - left)
            return hright == hleft

        sol = [ispal(node) for node in range(n)]
        return sol
",1427939095
Behrooz Sepehry,sepehry,272,3607,python3,"
def factorize(n):
    """""" Wheel factorization with {2, 3, 5} basis
    :return: collections.Counter[prime factor, exponent]
    """"""
    f = collections.Counter()

    def compute_exponent(p):
        nonlocal n
        while (n % p) == 0:
            f[p] += 1
            n //= p

    compute_exponent(2)
    compute_exponent(3)
    compute_exponent(5)

    p = 7
    inc = [4, 2, 4, 2, 4, 6, 2, 6]
    inc_len = len(inc)
    i = 0
    while p ** 2 <= n:
        if n % p == 0:
            f[p] += 1
            n //= p
        else:
            p += inc[i]
            i = (i + 1) % inc_len
    if n != 1:
        f[n] += 1
    return f


class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        sol = 0
        for i in range(n - 2, -1, -1):
            x = nums[i]
            if x == 1 or x <= nums[i + 1]:
                continue
            factors = factorize(x)
            mi = min(factors.keys())
            if mi <= nums[i + 1]:
                sol += 1
                nums[i] = mi
            else:
                return -1
        return sol
",1427847295
Tan Kwang Thiag,hardenisthegoat,273,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<vector<int>> v(26);
        int ans = 0;
        int i = 0;
        for (char c:s) v[c-'a'].push_back(i++);
        vector<int> b(s.size(),s.size());
        for (auto& a:v) {
            // for (int i = 0; i < a.size();++i) {
            //    cout << a[i] << ' ';
            // }
            if (a.size()>=k) for (int i = 0; i <= a.size()-k;++i) {
                // ans += (s.size()-a[i+k-1]);
                b[a[i]] = a[i+k-1];
            }
        }
        // for (int i = 0; i < b.size();++i) {
        //        cout << b[i] << ' ';
        //     }
       
        int mn = s.size();
        for (int i = s.size()-1; i>=0; --i) {
            mn = min(mn, b[i]);
            ans+=s.size()-mn;
        }
         // cout << ans << endl;
        return ans;
    }
};",1427851299
Tan Kwang Thiag,hardenisthegoat,273,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v;
        string s = ""a"";
        v.push_back(s);
        while (1) {
            
            if (s[s.size()-1] == target[s.size()-1]) {
                s.push_back('a');
                if (target.size()<s.size()) {
                    return v;
                }
            } else {
                s.back()++;
            }
            v.push_back(s);
        }
        return v;
    }
};",1427827768
Tan Kwang Thiag,hardenisthegoat,273,3603,cpp,"class Solution {
private:
    pair<vector<int>, vector<int>> manachers(string &s) {
      int n = s.size();
      vector<int> v1 = vector<int>(n); // maximum odd length palindrome centered at i
      // here v1[i]=the palindrome has v1[i]-1 right characters from i
      // e.g. for aba, v1[1]=2;
      for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 1 : min(v1[l + r - i], r - i);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {
          k++;
        }
        v1[i] = k--;
        if (i + k > r) {
          l = i - k;
          r = i + k;
        }
      }
      vector<int> v2 = vector<int>(n); // maximum even length palindrome centered at i
      // here v2[i]=the palindrome has v2[i]-1 right characters from i
      // e.g. for abba, v2[2]=2;
      for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(v2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {
          k++;
        }
        v2[i] = k--;
        if (i + k > r) {
          l = i - k - 1;
          r = i + k;
        }
      }
      return {v1,v2};
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector<int> correctpos(s.size());
        vector<vector<int>> al(s.size());
        for (int i = 1; i < parent.size(); ++i) {
            al[parent[i]].push_back(i);
        }
        vector<int> dfsorder;
        
        int gonsofar = 0;
        vector<int> start(s.size());
        vector<int> end(s.size());
        string t = """";
        auto dfs = [&](auto&& dfs, int cur) -> void {
            // int cnt =
            start[cur] = gonsofar;
            for (int i:al[cur]) {
                dfs(dfs, i);
            }
            gonsofar++;
            t.push_back(s[cur]);
            //not inc
            end[cur] = gonsofar;
        };
        dfs(dfs,0);
        auto [a,b] = manachers(t);
        vector<bool> res(s.size());
        //cout << t << endl;
        for (int i = 0; i < s.size(); ++i) {
            int len = end[i]-start[i];
            int mid = (end[i]+start[i])/2;
            //cout << i << ' ' << mid << ' ' << len << endl;
            if (len%2) {
                res[i] = a[mid] >= len/2+1;
            } else {
                res[i] = b[mid] >= len/2;
            }
        }
        return res;
    }
};",1427906311
Tan Kwang Thiag,hardenisthegoat,273,3607,cpp,"class Solution {
private:
    vector<int> spf;
    vector<int> primes;
    bool done = 0;
    void sieve(int N) {
        // cout << N << endl;
        // if (done) return;
        done = 1;
          spf.assign(N, 0);
          for(int i = 2; i < N; i++) {
            if (spf[i] == 0) spf[i] = i, primes.push_back(i);
            int siz = primes.size();
            for (int j = 0; j < siz && i * primes[j] < N && primes[j] <= spf[i]; j++) {
              spf[i * primes[j]] = primes[j];
            }
          }
    }
public:
    int minOperations(vector<int>& nums) {
        int mx = *(max_element(nums.begin(), nums.end()));
        sieve(mx+10);
        int mn = nums.back();
        int tot = 0;
        for (int i = nums.size()-1; i>=0;--i) {
            if (nums[i] > mn) {
                nums[i] = spf[nums[i]];
                if (nums[i] > mn) {
                    return -1;
                } else {
                    tot++;
                    mn = nums[i];
                }
            } else {
                mn = nums[i];
            }
        }
        return tot;
    }
};",1427874388
Tanvir Tareq,tanvirtareq,274,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int mp[26];
        int ans=0;
        for(int i=0;i<s.size();i++) {
            for(int j=0;j<26;j++) mp[j]=0;
            for(int j=i;j<s.size();j++) {
                mp[s[j]-'a']++;
                for(int kk=0;kk<26;kk++) {
                    if(mp[kk]>=k) {
                        ans++;
                        break;
                    }
                }
            }

        }
        return ans;
    }
};",1427834491
Tanvir Tareq,tanvirtareq,274,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v;
        string s;
        for(auto it:target) {
            for(char c='a';c<=it;c++) {
                s.push_back(c);
                v.push_back(s);
                if(c!=it)
                    s.pop_back();
            }
        }
        return v;
    }
};",1427825529
Tanvir Tareq,tanvirtareq,274,3603,cpp,"class Solution {
public:

    const long long MOD1 = 127657753, MOD2 = 987654319;
    const long long p1 = 137, p2 = 277;

    long long power(long long n, long long k, const long long mod) {
        long long ans = 1 % mod;
        n %= mod;
        if (n < 0) n += mod;
        while (k) {
            if (k & 1) ans = (long long) ans * n % mod;
            n = (long long) n * n % mod;
            k >>= 1;
        }
        return ans;
    }

    vector<pair<long long, long long> > h1, h2;

    vector<vector<long long> > g;
    vector<long long> chl;
    long long n;

    vector<bool> ans;
    string ss;

    void dfs(int r) {
        // cout<<r<<endl;
        chl[r]=1;
        for(auto it:g[r]) {
            dfs(it);
            chl[r]+=chl[it];
        }
        pair<long long, long long> hc1={0, 0};
        for(long long i=0;i<g[r].size();i++) {
            hc1.first*=power(p1, chl[g[r][i]], MOD1);
            hc1.second*=power(p2, chl[g[r][i]], MOD2);

            hc1.first%=MOD1;
            hc1.second%=MOD2;
        
            hc1.first+=h1[g[r][i]].first;
            hc1.second+=h1[g[r][i]].second;

            hc1.first%=MOD1;
            hc1.second%=MOD2;
        }
        hc1.first*=power(p1, 1, MOD1);
        hc1.second*=power(p2, 1, MOD2);

        hc1.first%=MOD1;
        hc1.second%=MOD2;

        hc1.first+=ss[r];
        hc1.second+=ss[r];

        hc1.first%=MOD1;
        hc1.second%=MOD2;

        pair<long long, long long> hc2={ss[r], ss[r]};

        for(long long i=(long long)g[r].size()-1;i>=0;i--) {
            hc2.first*=power(p1, chl[g[r][i]], MOD1);
            hc2.second*=power(p2, chl[g[r][i]], MOD2);

            hc2.first%=MOD1;
            hc2.second%=MOD2;
        
            hc2.first+=h2[g[r][i]].first;
            hc2.second+=h2[g[r][i]].second;

            hc2.first%=MOD1;
            hc2.second%=MOD2;
        }

        h1[r]=hc1;
        h2[r]=hc2;

        // if(r==1) {
        //     cout<<h1[r].first<<"" ""<<h1[r].second<<endl;
        //     cout<<h2[r].first<<"" ""<<h2[r].second<<endl<<endl;
        // }

        if(h1[r]==h2[r]) {
            ans[r]=true;
        }
        return;

    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        ss=s;
        n=parent.size();
        ans.resize(n);
        chl.resize(n);
        h1.resize(n);
        h2.resize(n);
        g.resize(n);

        for(long long i=1;i<n;i++) {
            long long it=parent[i];
            if(it==-1) continue;
            g[it].push_back(i);
        }        

        for(int i=0;i<n;i++) {
            sort(g[i].begin(), g[i].end());
        }

        dfs(0);

        return ans;
    }
};",1427923157
Tanvir Tareq,tanvirtareq,274,3607,cpp,"class Solution {
public:
    int dv(long long x) {
        for(long long i=2;i*i<=x;i++) {
            if(x%i==0) return i;
        }
        return x;
    }
    int minOperations(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        for(int i=n-2;i>=0;i--) {
            if(nums[i]<=nums[i+1]) continue;
            int x=dv(nums[i]);
            nums[i]=x;
            if(nums[i]>nums[i+1]) {
                return -1;
            }
            ans++;
        }
        return ans;
    }
};",1427848215
Fasdr,Fasdr,276,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] cnt = new int['z' - 'a' + 1];
        int res = 0;
        int good = 0;
        // first char
        int i = 0;
        for (int j = 0; j < s.length(); j++) {
            char newChar = s.charAt(j);
            if (++cnt[newChar - 'a'] == k) {
                good++;
            }
            while (good > 0 && (good > 1 || cnt[s.charAt(i) - 'a'] != k)) {
                if (cnt[s.charAt(i++) - 'a']-- == k) {
                    good--;
                }
            }
            if (good > 0) {
                res += i + 1;
            }
        }
        return res;
    }
}",1427845424
Fasdr,Fasdr,276,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        res.add("""");
        for (char chr : target.toCharArray()) {
            String last = res.get(res.size() - 1);
            for (char letter = 'a'; letter <= chr; letter++) {
                res.add(last + letter);
            }
        }
        res.remove(0);
        return res;
    }
}",1427834343
Fasdr,Fasdr,276,3603,java,"class Solution {
    
    private List<List<Integer>> adj;
    private String s;
    private int[] start;
    private int[] end;
    private StringBuilder dfsStr;
    
    public boolean[] findAnswer(int[] parent, String s) {
        this.s = s;
        int n = parent.length;
        adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            int u = parent[i];
            int v = i;
            adj.get(u).add(v);
        }
        for (int i = 0; i < n; i++) {
            Collections.sort(adj.get(i));
        }
        start = new int[n];
        end = new int[n];
        dfsStr = new StringBuilder();
        
        dfs(0);
        // System.out.println(Arrays.toString(start));
        // System.out.println(Arrays.toString(end));
        // System.out.println(dfsStr);
        // for (int i = 0; i < n; i++) {
            // System.out.println(i);
            // System.out.println(dfsStr.toString().substring(start[i], end[i] + 1));
        // }
        
        long a = 1000000007;
        long b = 10007;
        long invB = 820925358;
        
        long[] forward = new long[n + 1];
        long[] invPow = new long[n + 1];
        invPow[0] = 1;
        long curPow = 1;
        for (int i = 0; i < n; i++) {
            forward[i + 1] = (forward[i] + curPow * (dfsStr.charAt(i))) % a;
            curPow = (curPow * b) % a;
            invPow[i + 1] = (invPow[i] * invB) % a;
        }
        // System.out.println(Arrays.toString(invPow));
        // System.out.println(Arrays.toString(forward));
        long[] backward = new long[n + 1];
        curPow = 1;
        for (int i = 0; i < n; i++) {
            backward[i + 1] = (backward[i] + curPow * (dfsStr.charAt(n - 1 - i))) % a;
            curPow = (curPow * b) % a;
        }
        // System.out.println(Arrays.toString(backward));
        
        boolean[] res = new boolean[n];
        for (int i = 0; i < n; i++) {
            long f = (forward[end[i] + 1] + a - forward[start[i]]) % a;
            f = (f * invPow[start[i]]) % a;
            int endB = n - 1 - start[i];
            int startB = n - 1 - end[i];
            long bh = (backward[endB + 1] + a - backward[startB]) % a;
            bh = (bh * invPow[startB]) % a;
            res[i] = f == bh;
        }
        
        return res;
    }
    
    private void dfs(int u) {
        start[u] = dfsStr.length();
        for (int v : adj.get(u)) {
            dfs(v);
        }        
        end[u] = dfsStr.length();
        dfsStr.append(s.charAt(u));
    }
    
    
}",1427931319
Fasdr,Fasdr,276,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int res = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] <= nums[i + 1]) {
                continue;
            }
            int bound = (int) Math.sqrt(nums[i]);
            if (bound < nums[i] + 1) {
                bound++;
            }
            bound = Math.min(bound, nums[i + 1]);
            boolean good = false;
            for (int afterDiv = 2; afterDiv <= bound; afterDiv++) {
                if (nums[i] % afterDiv == 0) {
                    res++;
                    nums[i] = afterDiv;
                    good = true;
                    break;
                }
            }
            if (!good) {
                return -1;
            }
        }
        return res;
    }
}",1427873423
TheCleanser,TheCleanser,277,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0; int n = s.length();
        vector<int> prefix[26];
        for(int i = 0; i < 26; i++){
            prefix[i].push_back(0);
        }
        for(char c : s){
            for(int i = 0; i < 26; i++){
                prefix[i].push_back(prefix[i].back() + (c == (i + 'a')));
            }
        }
        
        int l = 0; int r = 0;
        while(r < n){
            bool have = 0;
            for(int i = 0; i < 26; i++){
                have |= (k <= prefix[i][r + 1] - prefix[i][l]);
            }
            
            if(have){
                ans += (n - r);
                l++;                
            }
            else r++;
        }
        return ans;
    }
};",1427831081
TheCleanser,TheCleanser,277,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans; string curr = """";
        for(char c: target){
            curr += 'a';
            while(curr.back() != c){
                ans.push_back(curr);
                curr.back()++;
            }
            ans.push_back(curr);
        }
        return ans;
    }
};",1427825287
TheCleanser,TheCleanser,277,3603,cpp,"#define N 100005
vector<int> adj[N];
string ans = """";
string str;
int idx[N];
int sz[N];


typedef long long int ll;


constexpr uint64_t mod = (1ULL << 61) - 1;
 
const uint64_t seed = chrono::system_clock::now().time_since_epoch().count();
const uint64_t base = mt19937_64(seed)() % (mod / 3) + (mod / 3);

uint64_t base_pow[N];
 
int64_t modmul(uint64_t a, uint64_t b){
    uint64_t l1 = (uint32_t)a, h1 = a >> 32, l2 = (uint32_t)b, h2 = b >> 32;
    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;
    uint64_t ret = (l & mod) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;
    ret = (ret & mod) + (ret >> 61);
    ret = (ret & mod) + (ret >> 61);
    return ret - 1;
}
 
void init(){
    base_pow[0] = 1;
    for (int i = 1; i < N; i++){
        base_pow[i] = modmul(base_pow[i - 1], base);
    }
}
 
struct PolyHash{
    /// Remove suff vector and usage if reverse hash is not required for more speed
    vector<int64_t> pref, suff;
 
    PolyHash() {}
 
    template <typename T>
    PolyHash(const vector<T>& ar){
        if (!base_pow[0]) init();
 
        int n = ar.size();
        assert(n < N);
        pref.resize(n + 3, 0), suff.resize(n + 3, 0);
 
        for (int i = 1; i <= n; i++){
            pref[i] = modmul(pref[i - 1], base) + ar[i - 1] + 997;
            if (pref[i] >= mod) pref[i] -= mod;
        }
 
        for (int i = n; i >= 1; i--){
            suff[i] = modmul(suff[i + 1], base) + ar[i - 1] + 997;
            if (suff[i] >= mod) suff[i] -= mod;
        }
    }
 
    PolyHash(const char* str)
            : PolyHash(vector<char> (str, str + strlen(str))) {}
 
    uint64_t get_hash(int l, int r){
        int64_t h = pref[r + 1] - modmul(base_pow[r - l + 1], pref[l]);
        return h < 0 ? h + mod : h;
    }
 
    uint64_t rev_hash(int l, int r){
        int64_t h = suff[l + 1] - modmul(base_pow[r - l + 1], suff[r + 2]);
        return h < 0 ? h + mod : h;
    }
};

class Solution {
public:
    
    
    void dfs(int curr)
    {
        for(auto it: adj[curr]){
            dfs(it); sz[curr] += sz[it];
        }
        sz[curr]++;
        int sz = ans.size();
        idx[curr] = sz;
        ans += str[curr];
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size(); str = s; ans = """";
        for(int i = 1; i < n; i++){
            int cp = parent[i];
            adj[cp].push_back(i);
        }
        
        dfs(0);
        
        PolyHash p(vector<char>(ans.begin(), ans.end()));
        
        vector<bool> vb(n);
        
        for(int i = 0; i < n; i++){
            int end = idx[i];
            int start = end - sz[i] + 1;
            auto it = p.get_hash(start, end);
            auto it2 = p.rev_hash(start, end);
            vb[i] = (it == it2);
        }
        
        for(int i = 0; i < n + 1; i++){
            adj[i].clear(); sz[i] = 0;
        }
        return vb;
        
    }
};",1427898261
TheCleanser,TheCleanser,277,3607,cpp,"typedef long long int ll;
#define N 1000009
ll smallestPrime[N+1];
bool prime[N+1];
bool done = false;

class Solution {
public:
    

    
    void seive()
    {
        memset(prime, true, sizeof(prime));
        fill(smallestPrime, smallestPrime + N + 1, INT_MAX);
        
        for(int i = 0; i < N + 1; i++){
            smallestPrime[i] = i;
        }

        for (ll p = 2; p * p <= N; p++) {
            if (prime[p]) {
                smallestPrime[p] = p;
                for (ll i = p * p; i <= N; i += p){
                    prime[i] = false;
                    smallestPrime[i] = min(smallestPrime[i], p);
                } 
            }
        }
        
        
        prime[0] = false; prime[1] = false;
        smallestPrime[0] = 0; smallestPrime[1] = 1;

    }
    
    int minOperations(vector<int>& nums) {
        if(!done){
            seive();
            done = true;
        }
        
        int n = nums.size(); int a[n];
        for(int i = 0; i < n; i++){
            a[i] = smallestPrime[nums[i]];

        }

        
        ll dp[2][n];
        dp[0][0] = 0; dp[1][0] = 1;
        
        for(int i = 1; i < n; i++){
            int prev = nums[i-1];
            int primePrev = a[i-1];
            
            dp[0][i] = INT_MAX;
            dp[1][i] = INT_MAX;
            
            if(nums[i] >= nums[i-1]){
                dp[0][i] = min(dp[0][i], dp[0][i-1]);
            }
            if(nums[i] >= a[i - 1]){
                dp[0][i] = min(dp[0][i], dp[1][i-1]);
            }
            
            if(a[i] >= nums[i-1]){
                dp[1][i] = min(dp[1][i], dp[0][i-1] + 1);
            }
            if(a[i] >= a[i -1]){
                dp[1][i] = min(dp[1][i], dp[1][i-1] + 1);
            }
        }
        
        
        ll ans = min(dp[0][n-1], dp[1][n-1]);
        return (ans <= n) ? ans : -1;
        
    }
};",1427873480
Nguyen Thanh Dat,datnguyen03,278,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        total_count = 0
        
        for start in range(n):
            freq_map = defaultdict(int)
            
            for end in range(start, n):
                char = s[end]
                freq_map[char] += 1

                if freq_map[char] >= k:
                    total_count += n - end
                    break
        
        return total_count",1427830264
Nguyen Thanh Dat,datnguyen03,278,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = []
        current_string = """"
        
        for char in target:
            current_string += 'a'
            result.append(current_string)
            
            while current_string[-1] != char:
                last_char = chr(((ord(current_string[-1]) - ord('a') + 1) % 26) + ord('a'))
                current_string = current_string[:-1] + last_char
                result.append(current_string)
        
        return result",1427825187
Nguyen Thanh Dat,datnguyen03,278,3603,python3,"class Solution:
    def findAnswer(self, parents: List[int], s: str) -> List[bool]:
        graph = defaultdict(list)
        for child, parent in enumerate(parents):
            if parent != -1:
                graph[parent].append(child)

        dfs_string = """"
        def dfs1(node):
            nonlocal dfs_string

            for child in graph[node]:
                dfs1(child)
            
            dfs_string += s[node]
        
        dfs1(0)
        # print(dfs_string)
        
        def manacher(s):
            t = '#' + '#'.join(s) + '#'
            n = len(t)
            p = [0] * n
            center = 0
            right = 0
            
            for i in range(n):
                mirror = 2 * center - i
                
                if i < right:
                    p[i] = min(right - i, p[mirror])
                
                while i + p[i] + 1 < n and i - p[i] - 1 >= 0 and t[i + p[i] + 1] == t[i - p[i] - 1]:
                    p[i] += 1
                
                if i + p[i] > right:
                    center = i
                    right = i + p[i]
            
            return p
        
        p = manacher(dfs_string)

        def is_palindrome_query(l, r):
            l = 2 * l + 1
            r = 2 * r + 1
            center = (l + r) // 2
            length = r - l + 1
            
            return p[center] >= length // 2
        
        res = [False] * len(s)
        def dfs2(node, start):
            nonlocal res

            end= start
            for child in graph[node]:
                end = dfs2(child, end)
            
            # print(node, start, end)
            res[node] = is_palindrome_query(start, end)
            return end + 1

        dfs2(0, 0)
        return res",1427877714
Nguyen Thanh Dat,datnguyen03,278,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def sieve_of_eratosthenes(limit):
            is_prime = [True] * limit
            is_prime[0], is_prime[1] = False, False  # 0 và 1 không phải là số nguyên tố
            
            for p in range(2, int(limit**0.5) + 1):
                if is_prime[p]:
                    for multiple in range(p * p, limit, p):
                        is_prime[multiple] = False
            
            primes = [num for num, prime in enumerate(is_prime) if prime]
            return primes
        
        primes = sieve_of_eratosthenes(1001)

        @cache
        def get_next_num(num):
            for prime in primes:
                if num % prime == 0:
                    return prime
            
            return num

        count = 0
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                nums[i] = get_next_num(nums[i])
                count += 1
            
            if nums[i] > nums[i + 1]:
                return -1
            
        return count
        
",1427923753
Sandeep P,Sandeep_P,279,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c=Counter()
        c2=Counter()
        mx=0
        i=0
        n=len(s)
        ans=n*(n+1)//2
        for j in range(n):
            if c[s[j]]!=0:
                c2[c[s[j]]]-=1
            c[s[j]]+=1
            c2[c[s[j]]]+=1
            mx=max(mx,c[s[j]])
            while mx==k:
                if c[s[i]]==mx and c2[mx]==1:
                    mx-=1
                c2[c[s[i]]]-=1
                c[s[i]]-=1
                if c[s[i]]!=0:
                    c2[c[s[i]]]+=1
                i+=1
            ans-=(j-i+1)
        return ans",1427831527
Sandeep P,Sandeep_P,279,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans=[]
        cur=[]
        for x in target:
            for y in range(ord('a'),ord(x)+1):
                ans.append(''.join(cur+[chr(y)]))
            cur.append(x)
        return ans",1427824832
Sandeep P,Sandeep_P,279,3603,python3,"def manacher_odd(s):
    n = len(s)
    s =[""$""] + s + [""^""]
    p = [0] * (n + 2)
    l, r = 1, 1
    for i in range(1, n + 1):
        p[i] = max(0, min(r - i, p[l + (r - i)]))
        while s[i - p[i]] == s[i + p[i]]:
            p[i] += 1
        if i + p[i] > r:
            l = i - p[i]
            r = i + p[i]
    return p[1:-1]
def manacher(s):
    t = []
    for c in s:
        t.append(""#"")
        t.append(c)
    t.append(""#"")
    print(t)
    res = manacher_odd(t)
    return res[1:-1]

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        
        n=len(parent)
        g=defaultdict(list)
        for v,u in enumerate(parent):
            g[u].append(v)
        for i in range(n):
            g[i]=sorted(g[i])

        sz=[0]*n
        pos=[0]*n
        a=[]
        def dfs(u):
            c=1
            for v in g[u]:
                c+=dfs(v)
            sz[u]=c
            pos[u]=len(a)
            a.append(s[u])
            return c
        dfs(0)
        mn=manacher(a)
        #print(mn)
        ans=[False]*n
        for node in range(n):
            p=pos[node]
            size=sz[node]
            mid=p-size//2
            #print(mid)
            if size%2==0:
                mpos=mid*2+1
            else:
                mpos=mid*2
            ans[node]=mn[mpos]>=size
            # print(ans[node])
            # print(mid)
            # print(size, mn[mpos], a[p-size+1:p+1])
        return ans",1427923832
Sandeep P,Sandeep_P,279,3607,python3,"seive=[None]*(10**6)
for i in range(2,len(seive)):
    for j in range(i+i,len(seive),i):
        seive[j]=i
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        limit=nums.pop()
        ans=0
        while nums:
            cur=nums.pop()
            while cur>limit:
                if seive[cur]==None:
                    return -1
                cur//=seive[cur]
                ans+=1
            limit=cur
        return ans",1427843185
satyam singh,MonoLithh,280,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.size();
        for(int i=0;i<n;i++)
        {
            vector<int>hash(26,0);
            int curr=0;
            for(int j=i;j<n;j++)
            {
                hash[s[j]-'a']++;
                curr|=(hash[s[j]-'a']>=k);
                ans+=curr;
            }
        }
        return ans;
    }
};",1427837509
satyam singh,MonoLithh,280,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n=target.size();
        vector<string>ans;
        string curr="""";
        for(int i=0;i<n;i++)
        {
            curr+='a';
            for(char c='a';c<=target[i];c++)
            {
                curr.pop_back();
                curr+=c;
                ans.push_back(curr);
            }
        }
        return ans;
    }
};",1427832622
satyam singh,MonoLithh,280,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
struct HashInfo {
    ll hash1_forward;
    ll hash1_reverse;
    ll hash2_forward;
    ll hash2_reverse;
    int len;
};

class Solution {
public:
    const ll base1 = 911;
    const ll base2 = 3571;
    const ll mod1 = 1000000007;
    const ll mod2 = 1000000009;

    vector<ll> pow_base1; 
    vector<ll> pow_base2;

    void precompute_powers(int n) {
        pow_base1.resize(n + 1, 1);
        pow_base2.resize(n + 1, 1);
        for(int i = 1; i <= n; i++) {
            pow_base1[i] = (pow_base1[i-1] * base1) % mod1;
            pow_base2[i] = (pow_base2[i-1] * base2) % mod2;
        }
    }
    HashInfo dfs(int node, const vector<vector<int>> &tree, const string &s, vector<HashInfo> &hashInfos) {
        HashInfo current;
        current.hash1_forward = 0;
        current.hash2_forward = 0;
        current.hash1_reverse = 0;
        current.hash2_reverse = 0;
        current.len = 0;
        vector<int> children = tree[node];
        sort(children.begin(), children.end());
        vector<HashInfo> childrenInfos;
        for(auto child: children){
            childrenInfos.push_back(dfs(child, tree, s, hashInfos));
        }
        for(auto &childInfo: childrenInfos){
            current.hash1_forward = (current.hash1_forward * pow_base1[childInfo.len] + childInfo.hash1_forward) % mod1;
            current.hash2_forward = (current.hash2_forward * pow_base2[childInfo.len] + childInfo.hash2_forward) % mod2;
            current.len += childInfo.len;
        }
        int c_val = (s[node] - 'a' + 1);
        current.hash1_forward = (current.hash1_forward * base1 + c_val) % mod1;
        current.hash2_forward = (current.hash2_forward * base2 + c_val) % mod2;
        current.len += 1;
        current.hash1_reverse = (current.hash1_reverse * base1 + c_val) % mod1;
        current.hash2_reverse = (current.hash2_reverse * base2 + c_val) % mod2;
        for(int i = childrenInfos.size() - 1; i >= 0; i--){
            HashInfo childInfo = childrenInfos[i];
            current.hash1_reverse = (current.hash1_reverse * pow_base1[childInfo.len] + childInfo.hash1_reverse) % mod1;
            current.hash2_reverse = (current.hash2_reverse * pow_base2[childInfo.len] + childInfo.hash2_reverse) % mod2;
        }
        hashInfos[node] = current;

        return current;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        precompute_powers(n + 1);

        vector<vector<int>> tree(n, vector<int>());
        int root = -1;
        for(int i = 0; i < n; i++){
            if(parent[i] == -1){
                root = i;
            }
            else{
                tree[parent[i]].push_back(i);
            }
        }

        vector<HashInfo> hashInfos(n);
        if(root != -1){
            hashInfos[root] = dfs(root, tree, s, hashInfos);
        }

        vector<bool> answer(n, false);
        for(int i = 0; i < n; i++){
            if(hashInfos[i].hash1_forward == hashInfos[i].hash1_reverse &&
               hashInfos[i].hash2_forward == hashInfos[i].hash2_reverse){
                answer[i] = true;
            }
            else{
                answer[i] = false;
            }
        }

        return answer;
    }
};
",1427923938
satyam singh,MonoLithh,280,3607,cpp,"class Solution {
public:
    // Inline static SPF array shared among all instances
    inline static vector<int> spf;
    // Inline static flag to check if SPF is already computed
    inline static bool is_spf_computed = false;

    // Function to compute the SPF array
    static void computeSPF(int max_val = 1000000) {
        if (is_spf_computed) return; // Already computed

        spf.resize(max_val + 1);
        for (int i = 0; i <= max_val; i++) {
            spf[i] = i;
        }

        for (int i = 2; i * i <= max_val; i++) {
            if (spf[i] == i) { // i is a prime number
                for (int j = i * i; j <= max_val; j += i) {
                    if (spf[j] == j) {
                        spf[j] = i;
                    }
                }
            }
        }

        is_spf_computed = true;
    }

    int minOperations(vector<int>& nums) {
        // Ensure SPF is computed before using it
        computeSPF();

        int n = nums.size();
        int operations = 0;

        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (nums[i] < spf[nums[i]]) { // Prevent infinite loop
                    return -1;
                }
                int fpd = spf[nums[i]];
                if (fpd == 1 || fpd == nums[i]) return -1;
                nums[i] = fpd;
                operations++;
                if (nums[i] <= nums[i + 1]) break;
            }
            if (nums[i] > nums[i + 1]) return -1;
        }

        return operations;
    }
};",1427891748
Yifeng,gaoyf1235,283,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        
        int cnt = 0;
        for(int i = 0; i < n; i++){
            vector<int> freq(26);
            for(int j = i; j < n; j++){
                freq[s[j] - 'a']++;
                for(int c = 0; c < 26; c++){
                    if(freq[c] >= k){
                        cnt++;
                        break;
                    }
                }
            }
        }
        return cnt;
            
        
    }
};",1427831100
Yifeng,gaoyf1235,283,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        int p = 0;
        string cur = ""a"";
        res.push_back(cur);
        for(int i = 0; i < target.size(); i++){
            auto c = target[i];
            while(cur.back() < c){
                cur.back()++;
                res.push_back(cur);
            }
            if(cur.size() < target.size()){
                cur += ""a"";
                res.push_back(cur);
            }
            else break;
        }
        return res;
    }
};",1427826054
Yifeng,gaoyf1235,283,3603,cpp,"class Solution {
    using pii = pair<int, int>;
    void dfs(int cur, vector<vector<int>>& children, string& s, vector<pii>& lr,string& s0){
        lr[cur].first = s0.size();
        for(auto c : children[cur]){
            dfs(c, children, s, lr, s0);
        }
        lr[cur].second = s0.size();
        s0.push_back(s[cur]);
    }
    
    vector<int> manacher_odd(string s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    
    vector<pair<int, int>> manacher(string s) {
        string t;
        for(auto c: s) {
            t += string(""#"") + c;
        }
        auto t_res = manacher_odd(t + ""#"");
        vector<pair<int, int>> s_res;
        for(int i = 0; i < s.size(); i++){
            int odd = t_res[2*i + 1] / 2;
            int even = (t_res[2*i] - 1) / 2;
            s_res.push_back({odd, even});
        }
        return s_res;
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> children(n);
        for(int i = 0; i < n; i++){
            int p = parent[i];
            if(p < 0) continue;
            children[p].push_back(i);
        }
        for(int i = 0; i < n; i++){
            sort(children[i].begin(), children[i].end());
        }
        
        vector<pii> lr(n);
        string ord;
        dfs(0, children, s, lr, ord);
        //cout << ord << endl;
        
        auto pal_len = manacher(ord);
        vector<bool> res(n, false);
        for(int i = 0; i < n; i++){
            auto [l, r] = lr[i];
            
            if((r + l) % 2 == 0){
                int mid = (l + r) / 2;
                auto [odd, even] = pal_len[mid];
                int odd_start = mid - odd + 1;
                if(2*odd - 1 >= r - l + 1){
                    res[i] = true;
                }
            }
            else{
                int mid = (l + r + 1) / 2;
                auto [odd, even] = pal_len[mid];
                int even_start = mid - even;
                if( 2*even >= r - l + 1){
                    res[i] = true;
                }
            }
        }
        return res;
    }
};",1427916572
Yifeng,gaoyf1235,283,3607,cpp,"class Solution {
    using ll = long long;
    vector<ll> LinearSieve(ll n){
        //  minimum prime factor
        vector<ll> lp(n+1);
        vector<ll> pr;
        for (ll i = 2; i <= n; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for (ll j = 0; i * pr[j] <= n; ++j) {
                lp[i * pr[j]] = pr[j];
                if (pr[j] == lp[i]) {
                    break;
                }
            }
        }
        return lp;
    }
public:
    int minOperations(vector<int>& nums) {
        auto max_val = *max_element(nums.begin(), nums.end());
        vector<int> fx(max_val + 1, -1);
        auto lp = LinearSieve(max_val);
        
        int cnt = 0;
        int n = nums.size();
        int mx = nums.back();
        for(int i = n - 2; i >= 0; i--){
            auto x = nums[i];
            if(x > mx){
                x = lp[x];
                cnt++;
            }
            if(x == -1 || x > mx) return -1;
            mx = x;
        }
        return cnt;
    }
};",1427849348
lu-chen-chen,lu-chen-chen,284,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans = 0;
        char[] chars = s.toCharArray();
        int n = chars.length;
        for (int i = 0; i < n; i++) {
            int[] cnt = new int[26];
            for (int j = i; j < n; j++) {
                cnt[chars[j] - 'a']++;
                if (cnt[chars[j] - 'a'] >= k) {
                    ans += n - j;
                    break;
                }
            }
        }
        return ans;
    }
}",1427832121
lu-chen-chen,lu-chen-chen,284,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> list = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        char[] chars = target.toCharArray();
        for (char c : chars) {
            int cur = 0;
            sb.append('a');
            list.add(sb.toString());
            while (cur + 'a' != c) {
                cur++;
                cur %= 26;
                sb.setCharAt(sb.length() - 1, (char) (cur + 'a'));
                list.add(sb.toString());
            }
        }
        return list;
    }
}",1427826231
lu-chen-chen,lu-chen-chen,284,3603,java,"class Solution {
    int n;
    List<Integer>[] lists;
    char[] chars;
    boolean[] ans;
    int[] index;
    int curIndex;
    StringBuilder sb = new StringBuilder();
    StringHash2 sh;

    public boolean[] findAnswer(int[] parent, String s) {
        n = parent.length;
        chars = s.toCharArray();
        lists = new List[n];
        for (int i = 0; i < n; i++) {
            lists[i] = new ArrayList<>();
        }
        for (int i = 1; i < n; i++) {
            lists[parent[i]].add(i);
        }
        for (int i = 0; i < n; i++) {
            lists[i].sort(Comparator.comparingInt(o -> o));
        }
        ans = new boolean[n];
        buildStr(0);
        index = new int[n];
        curIndex = n - 1;
        dfs(0);
        long mod = (long) (1e9) + new Random().nextInt((int) 7e7);
        String str = sb.toString() + sb.reverse();
        sh = new StringHash2(str);
        dfs2(0);
        return ans;
    }

    private int dfs2(int v) {
        int l = index[v];
        for (Integer w : lists[v]) {
            l = Math.min(l, dfs2(w));
        }
        check(l, index[v], v);
        return l;
    }

    private void check(int l, int r, int v) {
        ans[v] = sh.eq(l, r, 2 * n - 1 - r, 2 * n - 1 - l);
    }

    private void dfs(int v) {
        index[v] = curIndex;
        curIndex--;
        for (int i = lists[v].size() - 1; i >= 0; i--) {
            dfs(lists[v].get(i));
        }
    }

    private void buildStr(int v) {
        for (Integer w : lists[v]) {
            buildStr(w);
        }
        sb.append(chars[v]);
    }
}

class StringHash2 {
    StringHash1 sh1;

    StringHash1 sh2;

    public StringHash2(String s) {
        this.sh1 = new StringHash1(s, 131, (long) (1e9 + 7));
        this.sh2 = new StringHash1(s, 13331, (long) (1e9) + new Random().nextInt((int) 7e7));
    }

    /**
     * 下标从0开始，判断[l1, r1]和[l2, r2]是否相等
     */
    public boolean eq(int l1, int r1, int l2, int r2) {
        return sh1.eq(l1, r1, l2, r2) && sh2.eq(l1, r1, l2, r2);
    }
}

class StringHash1 {
    String s;
    long p;
    long[] pow;
    long mod;
    int n;
    long[] hash;

    public StringHash1(String s, long p0, long mod0) {
        p = p0;
        mod = mod0;
        this.s = s;
        char[] chars = s.toCharArray();
        n = chars.length;
        pow = new long[n + 1];
        pow[0] = 1;
        for (int j = 1; j <= n; j++) {
            pow[j] = pow[j - 1] * p % mod;
        }
        // 前j个字符的hash
        hash = new long[n + 1];
        for (int j = 1; j <= n; j++) {
            hash[j] = (hash[j - 1] * p + chars[j - 1]) % mod;
        }
    }

    /**
     * 下标从0开始，判断[l1, r1]和[l2, r2]是否相等
     */
    public boolean eq(int l1, int r1, int l2, int r2) {
        if (l1 < 0 || r1 >= n || l2 < 0 || r2 >= n || l1 > r1 || l2 > r2 || (r1 - l1 != r2 - l2)) {
            return false;
        }
        long h1 = hash(l1, r1);
        long h2 = hash(l2, r2);
        return h1 == h2;
    }

    public long hash(int l, int r) {
        long h;
        h = hash[r + 1] - hash[l] * pow[r - l + 1] % mod;
        h %= mod;
        h += mod;
        h %= mod;
        return h;
    }
}",1427916773
lu-chen-chen,lu-chen-chen,284,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        if (n > 10000) {
            return minOperations1(nums);
        } else {
            return minOperations2(nums);
        }
    }

    public int minOperations1(int[] nums) {
        int n = nums.length;
        int max = Arrays.stream(nums).max().orElse(0);
        int[] arr = new int[max + 1];
        arr[1] = 1;
        for (int i = 2; i <= max; i++) {
            for (int j = i; j <= max; j += i) {
                if (arr[j] == 0) {
                    arr[j] = i;
                }
            }
        }
        int cnt = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (nums[i] == arr[nums[i]]) {
                    return -1;
                }
                nums[i] = arr[nums[i]];
                cnt++;
            }
        }
        return cnt;
    }

    public int minOperations2(int[] nums) {
        int n = nums.length;
        int cnt = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                for (int j = 2; j * j <= nums[i]; j++) {
                    if (nums[i] % j == 0) {
                        nums[i] = j;
                        break;
                    }
                }
                cnt++;
            }
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
        }
        return cnt;
    }
}",1427855245
ZdyyLee,ZdyyLee,285,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        freqs = [0] * 26
        left = -1
        count = 0
        for right, c in enumerate(s):
            freqs[ord(c) - ord('a')] += 1
            while max(freqs) >= k:
                left += 1
                freqs[ord(s[left]) - ord('a')] -= 1

            count += left + 1


        return count",1427863740
ZdyyLee,ZdyyLee,285,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        def next_c(c) -> str:
            offset = (ord(c) - ord('a')+1) % 26
            return chr(ord('a') + offset)
        
        
        ret = []
        seq = """"
        while len(seq) < len(target) or seq[-1] != target[-1]:
            if seq == """" or seq[-1] == target[len(seq) - 1]:
                seq += 'a'
            else:

                seq = seq[:-1] + next_c(seq[-1])
                
            ret.append(seq)

        return ret",1427831766
ZdyyLee,ZdyyLee,285,3603,python3,"class Solution:
    def findAnswer(self, parent: list[int], s: str) -> list[bool]:
        n = len(parent)
        graphs: list[list[int]] = [[] for _ in range(n)]

        base = 27
        mod = 10 ** 18 + 7
        for node, parent in enumerate(parent):
            if parent != -1:
                graphs[parent].append(node)

        for neighbor in graphs:
            neighbor.sort()


        def char_val(node: int) -> int:
            return ord(s[node]) - ord('a') + 1

        forward_list = [0] * n
        def forward_polynomial_dfs(node: int) -> (int, int):
            polys = list(map(forward_polynomial_dfs, graphs[node]))

            ret = 0
            total_len = 0
            for length, val in polys:
                ret = (ret * pow(base, length, mod) + val) % mod
                total_len += length


            ret = (ret * base + char_val(node)) % mod
            total_len += 1
            forward_list[node] = ret
            return total_len, ret

        backward_list = [0] * n
        def back_polynomial_dfs(node: int) -> (int, int):
            polys = list(map(back_polynomial_dfs, reversed(graphs[node])))

            ret = 0
            total_len = 0
            ret = (ret * base + char_val(node)) % mod
            total_len += 1
            for length, val in polys:
                ret = (ret * pow(base, length, mod) + val) % mod
                total_len += length

            backward_list[node] = ret
            return total_len, ret

        forward_polynomial_dfs(0)
        back_polynomial_dfs(0)

        answers = [forward_list[i] == backward_list[i] for i in range(n)]

        return answers


",1427941163
ZdyyLee,ZdyyLee,285,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def dividedby_proper_divisor(num: int) -> int:
            for d in range(2, int(num**0.5)+1):
                if num % d == 0:
                    return d

            return num
        ops = 0
        for index in reversed(range(1, len(nums))):
            if nums[index] < nums[index-1]:
                nums[index-1] = dividedby_proper_divisor(nums[index-1])
                ops += 1
                if nums[index] < nums[index-1]:
                    return -1

        return ops
",1427879024
Sina S,user4607v,286,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] cnt = new int[26];
        int n = s.length();
        int ans = 0;
        int j = -1;
        for(int i =0; i < n; i++){
            while(j < n-1 &&  Arrays.stream(cnt).max().getAsInt() < k){
                j++;
                cnt[s.charAt(j)-'a']++;
            }
            if(Arrays.stream(cnt).max().getAsInt() < k){
                break;
            }
            ans += n-j;
            cnt[s.charAt(i)-'a']--;
        }
        return ans;
    }
}",1427844138
Sina S,user4607v,286,3566,java,"class Solution {
    String toStr(char[] chars, int end){
        StringBuilder sb = new StringBuilder();
        for(int i =0; i <= end;i++){
            sb.append(chars[i]);
        }
        return sb.toString();
    }
    public List<String> stringSequence(String target) {
        int n = target.length();
        List<String> ans = new LinkedList<>();
        char[] chars = new char[n];
        for(int i =0; i < n; i++){
            char ch = 'a'; 
            while(ch != target.charAt(i)){ 
               // System.out.println(i + "":"" + ch + "":"" + target.charAt(i));
                chars[i] = ch;
                ans.add(toStr(chars,i));
                ch++;
            }
            chars[i] = ch;
            ans.add(toStr(chars,i));    
        }
        return ans;
        
    }
}",1427832191
Sina S,user4607v,286,3603,java,"import java.math.BigInteger;
class Solution {
    int dfs(int index, int chIndex){
        start[index] = chIndex;
        for(int e: edges[index]){
            chIndex = dfs(e, chIndex);
        }
        dfsStr[chIndex] = s.charAt(index);
        end[index] = chIndex;
        return chIndex+1;
    }
    String s;
    ArrayList<Integer>[] edges;
    char[] dfsStr;
    int[] start, end;
    public boolean[] findAnswer(int[] parent, String s) {
        this.s = s;
        int n = s.length();
        start = new int[n];
        end = new int[n];
        this.edges = new ArrayList[n];
        for(int i =0; i < n; i++){
            edges[i] = new ArrayList<>();
        }
        for(int i =0; i < n; i++){
            int p  = parent[i];
            if(p != -1){
            edges[p].add(i);
            }
        }
        for(int i =0; i < n; i++){
            Collections.sort(edges[i]);
        }
        this.dfsStr = new char[n];
        dfs(0,0);
        long[] pows = new long[n];
        long mod = (long)Math.pow(10,9) + 7;
        long powInv =  BigInteger.valueOf(26).modInverse(BigInteger.valueOf(mod)).intValue();
        pows[0] = 1;
        long[] powInvs = new long[n];
        powInvs[0] = 1;
        for(int i =1; i < n; i++){
            pows[i] = pows[i-1] * 26;
            pows[i] %= mod;
            powInvs[i] = powInvs[i-1]*powInv;
            powInvs[i] %=  mod;
        }  
        long[] forwardVal = new long[n];
        long[] backwardVal = new long[n];
        for(int i =0; i < n; i++){
            forwardVal[i] = pows[i] * (dfsStr[i]-'a');
            forwardVal[i] %= mod;
            if(i > 0){
                forwardVal[i] += forwardVal[i-1];
                forwardVal[i] %= mod;
            }
        }
        for(int i =n-1; i >= 0; i--){
            backwardVal[i] = pows[n-1-i] * (dfsStr[i]-'a');
            backwardVal[i] %= mod;
            if( i <  n-1){
                backwardVal[i] +=  backwardVal[i+1];
                backwardVal[i] %= mod;
            }
        }
        boolean[] ans = new boolean[n];
        for(int i =0; i < n; i++){
            if(start[i] == end[i]){
                ans[i] = true;
                continue;
            }

            int s1 = start[i];
            int e2 = end[i];
            int s2,e1;
            int mid = (start[i]+end[i])/2;
            if(start[i] %2 == end[i] % 2){
                e1 = mid-1;
                s2 = mid+1;
            }
            else{
                e1 = mid;
                s2 = mid+1;
            }

            long half1Val = forwardVal[e1] - (s1> 0?forwardVal[s1-1] : 0);
            half1Val %= mod;
            if(half1Val < 0){
                half1Val += mod;
            }
            half1Val *= powInvs[start[i]];
            half1Val %= mod;

            long half2Val = backwardVal[s2] - (e2 < n-1?backwardVal[e2+1]:0);
            if(half2Val < 0){
                half2Val += mod;
            }
            half2Val *= powInvs[n-1-end[i]];
            half2Val %= mod;
            if(half1Val == half2Val){
                ans[i] = true;
            }

        }
        return ans;

    }
}",1427941342
Sina S,user4607v,286,3607,java,"class Solution {
    Integer[] mem = new Integer[1000001];
    int getSmallestDiv(int x){
        if(mem[x] != null){
            return mem[x];
        }
        if(x == 1){
            return 1;
        }
        if(x%2 == 0){
            return 2;
        }
        for(int i = 3; i <= Math.sqrt(x); i += 2){
            if(x%i == 0){
                mem[x] = i;
                return i;
            }
        }
        mem[x] = 1;
        return 1;
    }
    public int minOperations(int[] nums) {
        int ans = 0;
        int n = nums.length;
        for(int i =1; i < n; i++){
            if(nums[i] < nums[i-1]){
                for(int j = i-1; j >=0; j--){
                    if(nums[j] <= nums[j+1]){
                        break;
                    }
                     int smallestDiv = getSmallestDiv(nums[j]);
                     if(smallestDiv == 1){
                        return -1;
                     }
                     if(smallestDiv > nums[j+1]){
                        return -1;
                     }
                     nums[j] = smallestDiv;
                     ans++;
                }
            }
        }
        return ans;
    }
}",1427877683
Jimmy,JimmyK4542,287,3502,python,"class Solution(object):
    def numberOfSubstrings(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        n = len(s)
        numsubstrings = 0
        for i in xrange(n):
            counts = [0 for _ in xrange(26)]
            for j in xrange(i,n):
                counts[ord(s[j])-ord('a')] += 1
                if max(counts) >= k:
                    numsubstrings += n-j
                    break
        return numsubstrings
",1427830610
Jimmy,JimmyK4542,287,3566,python,"class Solution(object):
    def stringSequence(self, target):
        """"""
        :type target: str
        :rtype: List[str]
        """"""
        n = len(target)
        prev = ''
        out = []
        for c in target:
            for i in xrange(ord('a'),ord(c)+1):
                out.append(prev+chr(i))
            prev = prev + c
        
        return out
",1427825495
Jimmy,JimmyK4542,287,3603,python,"class Solution(object):
    def findAnswer(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[bool]
        """"""
        n = len(parent)
        children = [[] for _ in xrange(n)]
        for i in xrange(1,n):
            children[parent[i]].append(i)
        
        forward_hash = [-1]*n
        reverse_hash = [-1]*n
        lengths = [-1]*n

        p = 10**9+7
        x = 97
        #xinv = 5*10**8+4
        
        xpow2k = [x]
        pow2 = 1
        while pow2 < n+2:
            xpow2k.append((xpow2k[-1]*xpow2k[-1])%p)
            pow2 *= 2
        
        def computeStuff(i):
            if lengths[i] > -1:
                return forward_hash[i],reverse_hash[i],lengths[i]
            
            cfwds = []
            crevs = []
            clengths = []
            for child in children[i]:
                cfwd,crev,clength = computeStuff(child)
                cfwds.append(cfwd)
                crevs.append(crev)
                clengths.append(clength)
            c = ord(s[i])-ord('a')+1

            lengths[i] = sum(clengths)+1

            fwdhash = 0
            xpow = 1
            for j in xrange(len(clengths)):
                fwdhash += xpow*cfwds[j]
                fwdhash %= p
                L = clengths[j]
                k = 0
                while L > 0:
                    if L%2 == 1:
                        xpow *= xpow2k[k]
                    k += 1
                    L /= 2
            fwdhash += c*xpow
            fwdhash %= p
            forward_hash[i] = fwdhash

            revhash = c
            xpow = x
            for j in xrange(len(clengths)-1,-1,-1):
                revhash += xpow*crevs[j]
                revhash %= p
                L = clengths[j]
                k = 0
                while L > 0:
                    if L%2 == 1:
                        xpow *= xpow2k[k]
                    k += 1
                    L /= 2
            reverse_hash[i] = revhash
            
            return forward_hash[i],reverse_hash[i],lengths[i]
        
        computeStuff(0)
        #print(forward_hash)
        #print(reverse_hash)
        #print(lengths)

        return [forward_hash[i] == reverse_hash[i] for i in xrange(n)]",1427933392
Jimmy,JimmyK4542,287,3607,python,"class Solution(object):
    def minOperations(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        n = len(nums)
        ops = 0
        for i in xrange(n-2,-1,-1):
            if nums[i] > nums[i+1]:
                if nums[i]%2 == 0:
                    p = 2
                else:
                    p = 3
                    while nums[i]%p > 0 and p <= nums[i+1]:
                        p += 2
                if p > nums[i+1]:
                    return -1
                else:
                    nums[i] = p
                    ops += 1

        return ops
",1427845491
l1cache__,l1cache__,288,3502,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pll pair<ll, ll>

#define MOD 1000000007

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int psa[3005][26] = {{}};
		for (int i = 0; i < s.size(); i++) {
			for (int j = 0; j < 26; j++) {
				psa[i+1][j] = psa[i][j];
			}
			psa[i+1][s[i]-'a']++;
		}
		int ans = 0;
		for (int i = 0; i < s.size(); i++) {
			int l = i, r = s.size();
			while (l < r) {
				int m = (l+r)/2;
				bool ok = 0;
				for (int j = 0; j < 26; j++) {
					if (psa[m][j]-psa[i][j] >= k) {
						ok = 1;
						break;
					}
				}
				if (ok) {
					r = m;
				} else {
					l = m+1;
				}
			}
			bool ok = 0;
			for (int j = 0; j < 26; j++) {
				if (psa[l][j]-psa[i][j] >= k) {
					ok = 1;
					break;
				}
			}
			if (ok) {
				ans += s.size()-l+1;
			}
		}
		return ans;
    }
};",1427845488
l1cache__,l1cache__,288,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s = """";
        int idx = 0;
        while (s != target) {
            s += 'a';
            res.push_back(s);
            while (s[idx] != target[idx]) {
                s[idx]++;
                res.push_back(s);
            }
            idx++;
        }
        return res;
    }
};",1427845262
l1cache__,l1cache__,288,3603,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pll pair<ll, ll>

#define MOD 1000000007

ll pow29[100005];

auto build = []() {
	pow29[0] = 1;
	for (int i = 1; i < 100005; i++) pow29[i] = pow29[i-1] * 29 % MOD;
	return 0;
}();

class Solution {
public:
    vector<bool> ans;
    vector<int> adj[100005];
    string cur = """";
    vector<tuple<int, int, int>> queries;
    void dfs(int u, string &s) {
        int l = cur.size();
        for (auto &x : adj[u]) dfs(x, s);
        cur += s[u];
        queries.emplace_back(l, cur.size()-1, u);
    }
    void answer() {
        vector<ll> pre(cur.size()+1), suf(cur.size()+1);
		pre[0] = 1;
		for (int i = 0; i < cur.size(); i++) pre[i+1] = (pre[i] + (pow29[i] * (cur[i] - 'a')) % MOD) % MOD;
		suf[0] = 1;
		for (int i = 0; i < cur.size(); i++) suf[i+1] = (suf[i] + (pow29[i] * (cur[cur.size()-i-1] - 'a')) % MOD) % MOD;
		// for (int i = 0; i < cur.size(); i++) cout << pre[i] << ' ' << suf[i] << '\n';
		// forward hash = pre[r+1]-pre[l]
		// backward hash = suf[n-l]-suf[n-r-1]
		// cout << cur << ' ';
		for (auto &[l, r, u] : queries) {
			ll fhash = (pre[r+1] - pre[l] + MOD) % MOD;
			ll bhash = (suf[cur.size()-l] - suf[cur.size()-r-1] + MOD) % MOD;
			// check if fhash*29^(n-r-1) == bhash*29^l
			// cout << l << ' ' << r << ' ' << u << ' ' << fhash << ' ' << bhash << '\n';
			ans[u] = fhash * pow29[cur.size()-r-1] % MOD == bhash * pow29[l] % MOD;
		}
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ans.resize(parent.size());
        for (int i = 1; i < parent.size(); i++) adj[parent[i]].push_back(i);
        dfs(0, s);
		answer();
        return ans;
    }
};

auto init = [](){return cin.tie(0)->sync_with_stdio(0);}();",1427933785
l1cache__,l1cache__,288,3607,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define pll pair<ll, ll>

#define MOD 1000000007

int largestdiv[1000005];

auto build = []() {
	// largestdiv[i] = largest proper divisor of i
	for (int i = 1; i <= 1000000; i++) {
		for (int j = i*2; j <= 1000000; j += i) {
			largestdiv[j] = i;
		}
	}
	return 0;
}();

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
		for (int i = nums.size()-1; i > 0; i--) {
			while (nums[i-1] > nums[i]) {
				if (largestdiv[nums[i-1]] == 1) {
					return -1;
				}
				ans++;
				nums[i-1] /= largestdiv[nums[i-1]];
			}
		}
		bool ok = 1;
		for (int i = 0; i < nums.size()-1; i++) {
			if (nums[i] > nums[i+1]) {
				ok = 0;
				break;
			}
		}
		if (!ok) return -1;
		return ans;
    }
};",1427845742
Oone,Oone,289,3502,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {-1,0,0,1,1,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
    }
}

class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n=s.length();
        int ans=0;
        for(int i=0;i<n;++i) {
            HashMap<Character, Integer> map = new HashMap<>();
            boolean flag=false;
            for (int j = i; j < n; ++j){
                map.put(s.charAt(j), map.getOrDefault(s.charAt(j), 0) + 1);
                if(map.get(s.charAt(j))>=k)flag=true;
                if(flag)ans++;
            }
        }
        return ans;
    }
}",1427920499
Oone,Oone,289,3566,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {-1,0,0,1,1,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
    }
}

class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        List<String> ans=new ArrayList<>();
        for(char c:target.toCharArray()) {
            char tmp='a';
            sb.append(tmp);
            ans.add(sb.toString());
            while(tmp!=c) {
                tmp = (char) ((tmp - 'a' + 1) % 26 + 'a');
                sb.setCharAt(sb.length() - 1, tmp);
                ans.add(sb.toString());
            }
        }
        return ans;
    }
}",1427914107
Oone,Oone,289,3603,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {-1,0,0,1,1,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
        solution.findAnswer(nums1,""aababa"");
    }
}

class Solution {
    List<List<Integer>> e = new ArrayList<>();
    StringBuilder stringBuilder = new StringBuilder();
    String s;
    int now,n;
    int[] l, r, p;
    char[] c;

    void DFS(int x) {
        l[x] = now + 1;
        for (int v : e.get(x))
            DFS(v);
        stringBuilder.append(s.charAt(x));
        r[x] = ++now;
    }

    void manacher() {
        c[0] = '~';
        c[1] = '#';
        for (int i = 1; i <= n; ++i) {
            c[2 * i + 1] = '#';
            c[2 * i] = stringBuilder.charAt(i - 1);
        }
        for (int i = 1, mid = 0, r = 0; i <= 2 * n + 1; ++i) {
            if (i <= r) p[i] = Math.min(p[(mid << 1) - i], r - i + 1);
            while (c[i-p[i]] == c[i + p[i]]) ++p[i];
            if (p[i] + i > r) {
                r = p[i] + i - 1;
                mid = i;
            }
        }
    }


    public boolean[] findAnswer(int[] parent, String s) {
        n = parent.length;
        this.s = s;
        for (int i = 0; i < n; ++i)
            e.add(new ArrayList<>());
        for (int i = 1; i < n; ++i)
            e.get(parent[i]).add(i);
        l = new int[n];
        r = new int[n];
        DFS(0);
        c = new char[2 * n + 10];
        p = new int[2 * n + 10];
        manacher();
        boolean[] ans = new boolean[n];
        for (int i = 0; i < n; ++i) {
            int mid = (2 * r[i] - 2 * l[i] + 1) / 2 + 2 * l[i];
            ans[i]= p[mid]-1 >= r[i] - l[i] + 1;
        }
        return ans;
    }
}",1427903660
Oone,Oone,289,3607,java,"import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class Main {
    public static void main(String[] args) {
        int[] nums1 = {-1,0,0,1,1,2};
        long[] nums2 = {0, 2, 2};
        int[][] edges = {{0, 1}, {1, 3}, {2, 3}, {2, 4}};
        String[] grid = {""abc"", ""aaaaa"", ""bcdef""};
        Solution solution = new Solution();
    }
}

class Solution {
    public int minOperations(int[] nums) {
        int n=nums.length;
        int ans=0;
        for(int i=n-2;i>=0;i--){
            while(nums[i]>nums[i+1]) {
                boolean flag=false;
                for (int j = 2; j * j <= nums[i]; ++j)
                    if (nums[i] % j == 0) {
                        nums[i] = j;
                        flag=true;
                        ans++;
                        break;
                    }
                if(!flag)break;
            }
            if(nums[i]>nums[i+1])return -1;
        }
        return ans;
    }
}",1427934309
Lambert,Lambert360,290,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length(), total = 0;
        
        for (int start = 0; start < n; ++start) {
            vector<int> freq(26, 0);
            for (int end = start; end < n; ++end) {
                freq[s[end] - 'a']++;
                if (checkFreq(freq, k)) {
                    total += (n - end);
                    break;
                }
            }
        }
        return total;
    }

private:
    bool checkFreq(const vector<int>& freq, int k) {
        for (int count : freq) {
            if (count >= k) return true;
        }
        return false;
    }
};
",1427826062
Lambert,Lambert360,290,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        for (char ch : target) {
            appendCharA(result, current);
            updateToTargetChar(result, current, ch);
        }
        return result;
    }

private:
    void appendCharA(vector<string>& result, string& current) {
        current += 'a';
        result.push_back(current);
    }

    void updateToTargetChar(vector<string>& result, string& current, char targetChar) {
        while (current.back() != targetChar) {
            current.back() = (current.back() == 'z') ? 'a' : current.back() + 1;
            result.push_back(current);
        }
    }
};
",1427823878
Lambert,Lambert360,290,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define vi vector<int>
#define vll vector<long long>
#define pb push_back
#define F first
#define S second

const ll P1 = 911, MOD1 = 999999937;
const ll P2 = 3571, MOD2 = 999999929;

class Solution {
public:
    void dfs(int x, vi &L, vi &R, int &idx, const string &s, string &str, const vector<vi> &adj) {
        L[x] = idx;
        for (int y : adj[x]) {
            dfs(y, L, R, idx, s, str, adj);
        }
        str += s[x];
        R[x] = idx++;
    }

    pair<vll, vll> compute_hash(const string &str, ll P, ll MOD) {
        int N = str.size();
        vll hash(N), powP(N + 1, 1);
        hash[0] = str[0] - 'a' + 1;
        for (int i = 1; i < N; ++i) {
            hash[i] = (hash[i - 1] * P + str[i] - 'a' + 1) % MOD;
        }
        for (int i = 1; i <= N; ++i) {
            powP[i] = (powP[i - 1] * P) % MOD;
        }
        return {hash, powP};
    }

    vector<bool> findAnswer(const vi &parent, const string &s) {
        int n = parent.size();
        vector<vi> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].emplace_back(i);
        }

        vi L(n, 0), R(n, 0);
        string str = """";
        int idx = 0;
        dfs(0, L, R, idx, s, str, adj);
        
        string revStr = string(str.rbegin(), str.rend());
        int N = str.size();
        
        auto [H1, powP1] = compute_hash(str, P1, MOD1);
        auto [H2, powP2] = compute_hash(str, P2, MOD2);
        auto [RH1, powRP1] = compute_hash(revStr, P1, MOD1);
        auto [RH2, powRP2] = compute_hash(revStr, P2, MOD2);

        vector<bool> ans(n, false);
        for (int x = 0; x < n; ++x) {
            int Lx = L[x], Rx = R[x];
            ll hash1_fwd = (Lx > 0) ? (H1[Rx] - H1[Lx - 1] * powP1[Rx - Lx + 1] % MOD1 + MOD1) % MOD1 : H1[Rx];
            ll hash2_fwd = (Lx > 0) ? (H2[Rx] - H2[Lx - 1] * powP2[Rx - Lx + 1] % MOD2 + MOD2) % MOD2 : H2[Rx];

            int A = N - 1 - Rx, B = N - 1 - Lx;
            ll hash1_rev = (A > 0) ? (RH1[B] - RH1[A - 1] * powRP1[B - A + 1] % MOD1 + MOD1) % MOD1 : RH1[B];
            ll hash2_rev = (A > 0) ? (RH2[B] - RH2[A - 1] * powRP2[B - A + 1] % MOD2 + MOD2) % MOD2 : RH2[B];

            if (hash1_fwd == hash1_rev && hash2_fwd == hash2_rev) {
                ans[x] = true;
            }
        }
        return ans;
    }
};
",1427895863
Lambert,Lambert360,290,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

const int MAX_VAL = 1000001;
int gpd_arr[MAX_VAL + 1];
bool precomputed = false;

auto precomputeGPD = []() {
    if (precomputed) return;
    fill(gpd_arr, gpd_arr + MAX_VAL + 1, 1);
    for (int i = 2; i <= MAX_VAL; ++i) {
        for (int j = 2 * i; j <= MAX_VAL; j += i) {
            gpd_arr[j] = i;
        }
    }
    precomputed = true;
};

auto performOps = [](vector<int>& nums, int& ops) {
    int n = nums.size();
    for (int i = n - 2; i >= 0; --i) {
        while (nums[i] > nums[i + 1]) {
            int d = gpd_arr[nums[i]];
            if (d == 1) return -1;
            nums[i] /= d;
            ops++;
            if (nums[i] <= 0) return -1;
        }
    }
    return ops;
};

class Solution {
public:
    int minOperations(vector<int>& nums) {
        precomputeGPD();
        int ops = 0;
        return performOps(nums, ops);
    }
};
",1427909956
Jack Douglas,J-Douglas,293,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        
        for i in range(len(s)):
            maxFreq = 0
            count = {}
            for j in range(i, len(s)):
                if s[j] not in count:
                    count[s[j]] = 0
                count[s[j]] += 1
                maxFreq = max(maxFreq,count[s[j]])
                if maxFreq >= k :
                    ans += 1
        return ans
",1427877720
Jack Douglas,J-Douglas,293,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = [""a""]
        while ans[-1] != target:
            status = ans[-1]
            letter_idx = len(status)-1
            curr_letter = status[-1]
            if curr_letter == target[letter_idx]:
                next_word = status + ""a""
                ans.append(next_word)
            else:
                next_word = status[:-1] + chr(ord(curr_letter)+1)
                ans.append(next_word)
        return ans
            
        ",1427853636
Jack Douglas,J-Douglas,293,3603,python3,"class Solution:
    def isPalindrome(self, s: str) -> bool:
        if len(s)%2 == 0:
            mid = len(s)//2
            return True if s[:mid] == s[mid:][::-1] else False
        else:
            mid = len(s)//2
            return True if s[:mid] == s[mid+1:][::-1] else False
        
    def createGraph(self, parent: List[int]):
        g = {}
        g[0] = []
        for i in range(1, len(parent)):
            if i not in g:
                g[i] = []
            if parent[i] not in g:
                g[parent[i]] = []
            g[parent[i]].append(i)
        return g
    
    def dfs(self, cur, graph, s, ans):
        if len(graph[cur]) == 0:
            ans[cur] = self.isPalindrome(s[cur])
            return (s[cur], ans)
    
        cur_s = """"
        for neighbour in graph[cur]:
            (add_s, ans) = self.dfs(neighbour, graph, s, ans)
            cur_s += add_s
        cur_s += s[cur]
        ans[cur] = self.isPalindrome(cur_s)
        return (cur_s, ans)
        
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        N = len(parent)
        ans = [None]*N
        graph = self.createGraph(parent)
        (full_s, ans) = self.dfs(0, graph, s, ans)
            
        return ans
        
        
        
        
        ",1427935697
Jack Douglas,J-Douglas,293,3607,python3,"class Solution:
    def findLargestProperDivisor(self, num):
        for i in range(2, int(sqrt(num))+1):
            if num%i == 0:
                return num//i
        return -1
    
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)-1,0,-1):
            while nums[i] < nums[i-1]:
                divisor = self.findLargestProperDivisor(nums[i-1])
                if divisor == -1:
                    return -1
                nums[i-1] = nums[i-1]//divisor
                ans += 1
        return ans
            ",1427892839
Sagnik Biswas,SagnikBiswas1049,295,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] freq = new int[26];
        int ct = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int mx = 0;
            freq = new int[26];
            for (int j = i; j < s.length(); j++) {
                freq[s.charAt(j) - 'a']++;
                mx = Math.max(mx, freq[s.charAt(j) - 'a']);
                if (mx >= k) {
                    // System.out.println(i + "" "" + j);
                    ct++;
                }
                
            }
            
        }
        
        return ct;
    }
}",1427829921
Sagnik Biswas,SagnikBiswas1049,295,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<String>();
        StringBuilder curr = new StringBuilder("""");
        
        for (int i = 0; i < target.length(); i++) {
            for (int j = 0; j < 26; j++) {
                if (target.charAt(i) - 'a' == j) {
                    ans.add(curr.toString() + (char) (j + 'a'));
                    curr.append((char)(j+'a'));
                    break;
                } else {
                    ans.add(curr.toString() + (char) (j + 'a'));
                }
            }
        }
        
        
        return ans;
    }
}",1427825137
Sagnik Biswas,SagnikBiswas1049,295,3603,java,"class Solution {
    
    long MOD = (int) (1e9 + 9);
    long base = 103;
    
    boolean[] ans;
    long[] pow;
    ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();
    
    
    int[] sub;
    
    long[] fr;
    long[] re;
    
    int[] value;
    
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        ans = new boolean[n];
        fr = new long[n];
        re = new long[n];
        sub = new int[n];
        value = new int[n];
        for (int i = 0; i < n; i++) {
            value[i] = s.charAt(i) - 'a' + 1;
        }
        
        pow = new long[n];
        pow[0] = 1;
        for (int i = 1; i < n; i++) {
            pow[i] = pow[i-1] * base;
            pow[i] %= MOD;
        }
        
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<Integer>());
        }
        
        for (int i = 1; i < n; i++) {
            adj.get(i).add(parent[i]);
            adj.get(parent[i]).add(i);
        }
        
        
        for (int i = 0; i < adj.size(); i++) {
            Collections.sort(adj.get(i));
        }
        
        
        sub(0, -1);
        dfs(0, -1);
        
        // System.out.println(Arrays.toString(sub));
        
        return ans;
    }
    
    void sub(int u, int par) {
        for (int ne : adj.get(u)) {
            if (ne == par) continue;
            sub(ne, u);
        }
        
        sub[u] = 1;
        for (int ne : adj.get(u)) {
            if (ne == par) continue;
            sub[u] += sub[ne];
        }
    }
    
    void dfs(int u, int par) {
        
        for (int ne : adj.get(u)) {
            if (ne == par) continue;
            
            dfs(ne, u);
        }
        
        // compute forward hash
        
        int len = 0;
        long hash = 0;
        
        for (int ne : adj.get(u)) {
            if (ne == par) continue;
            long add = fr[ne] * pow[len];
            add %= MOD;
            
            hash += add;
            hash %= MOD;
            
            len += sub[ne];
        }
        
        long add = value[u]*pow[len];
        add %= MOD;
        
        hash += add;
        hash %= MOD;
        
        fr[u] = hash;
        
        
        
        
        
        // compute reverse hash
        hash = value[u];
        len = 1;
        
        for (int i = adj.get(u).size() - 1; i >= 0; i--) {
            int ne = adj.get(u).get(i);
            if (ne == par) continue;
            
            // System.out.println(ne + "" "" + len);
            
            add = re[ne] * pow[len];
            add %= MOD;
            
            hash += add;
            hash %= MOD;
            
            
            len += sub[ne];
        }
        
        
        
        re[u] = hash;
        
        if (fr[u] == re[u]) {
            ans[u] = true;
        }
        
    }
    
    /*
    java.lang.ArrayIndexOutOfBoundsException: Index 20 out of bounds for length 20
      at line 114, Solution.dfs
      at line 77, Solution.dfs
      at line 77, Solution.dfs
      at line 52, Solution.findAnswer
      at line 56, __DriverSolution__.__helper__
      at line 89, __Driver__.main
    
    [-1,12,16,6,5,15,14,5,5,6,5,13,14,16,0,14,14,16,1,17]
    ""ikckgdihheffficjhgjh""
    
    */
    
}",1427920148
Sagnik Biswas,SagnikBiswas1049,295,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        // all the elements reduce to largest prime dividing it
        int n = nums.length;
        int ct = 0;
        
        int[] mp = new int[(int)((1e6)+1)];
        
        
        // int[] edgeCase = {9, 10, 18, 20, 2};
        // if (Arrays.equals(nums, edgeCase)) {
        //     return 1;
        // }
        
        
        // System.out.println(mp(25));
        
        // System.out.println(mp(9));
        
        
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] > nums[i+1]) {
                if (mp[nums[i]] == 0) {
                    mp[nums[i]] = mp(nums[i]);
                    if (mp[nums[i]] == 1) {
                        return -1;
                    }
                }
                
                
                
                if (mp[nums[i]] <= nums[i+1]) {
                    ++ct;
                    nums[i] = mp[nums[i]];
                    // System.out.println(Arrays.toString(nums));
                    continue;
                }
                
                
                
                
                
                return -1;
            }
        }
        
       
        
        // for (int i = 0; i < n; i++) {
        //     System.out.print(mp[nums[i]] + "" "");
        // }
        // System.out.println();
        
        return ct;
    }
    
    int mp(int v) {
        for (int i = 2; i*i <= v; i++) {
            if (v%i == 0) return i;
        }
        
        return 1;
    }
}",1427869329
Manan Rathod,Manan04,296,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        ans = 0
        pref = [[0 for i in range(26)] for i in range(n)]
        for i in range(n):
            o = ord(s[i]) - 97
            pref[i][o] += 1
            if(i):
                for j in range(26):
                    pref[i][j] += pref[i - 1][j]
        for i in range(n):
            L = i
            U = n - 1
            take = -1
            while L <= U:
                m = (L + U) >> 1
                f = 0
                for j in range(26):
                    c = pref[m][j]
                    if(i):
                        c -= pref[i - 1][j]
                    if(c >= k):
                        f = 1
                        break
                if(f):
                    take = m
                    U = m - 1
                else:
                    L = m + 1
            if(take != -1):
                ans += n - take
        return ans",1427829195
Manan Rathod,Manan04,296,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        c = []
        for char in target:
            c.append('a')
            ans.append(''.join(map(str, c)))
            for j in range(98, ord(char) + 1):
                c.pop()
                c.append(chr(j))
                ans.append(''.join(map(str, c)))
        return ans",1427825443
Manan Rathod,Manan04,296,3603,python3,"class manacher:
    def __init__(self, s):
        self.t_string = ['#']
        for char in s:
            self.t_string.append(char)
            self.t_string.append('#')
        self.answer = [0] * len(self.t_string)
        self.build()
    def build(self):
        n = len(self.t_string)
        ll = -1
        rr = 0
        for i in range(n):
            self.answer[i] = max(0, min(rr - i, self.answer[ll + rr - i]))
            cur_ans = self.answer[i]
            l = i - cur_ans
            r = i + cur_ans
            while l >= 0 and r < n:
                if(self.t_string[l] == self.t_string[r]):
                    cur_ans += 1
                    l -= 1
                    r += 1
                else:
                    break
            self.answer[i] = cur_ans
            if(i + self.answer[i] > rr):
                ll = i - self.answer[i]
                rr = i + self.answer[i]
    def isPossibleRange(self, l, r):
        # nidx = idx * 2 + 1
        idx = (l + r) >> 1
        nidx = idx * 2 + 1
        if((r - l + 1) % 2 == 0):
            nidx += 1
        ans = self.answer[nidx]
        lidx = l * 2 + 1
        on_left = nidx - lidx + 1
        return ans >= on_left
class Solution:
    def findAnswer(self, p: List[int], s: str) -> List[bool]:
        n = len(p)
        adj = [[] for i in range(n)]
        for i in range(1, n):
            node = i
            nbr = p[i]
            adj[nbr].append(node)
        for i in range(n):
            adj[i].sort(reverse = True)
        subSz = [0] * n
        start = [0] * n
        def dfs(node, dfsStr):
            start[node] = len(dfsStr)
            dfsStr.append(s[node])
            subSz[node] += 1
            for nbr in adj[node]:
                dfs(nbr, dfsStr)
                subSz[node] += subSz[nbr]
        dfsStr = []
        dfs(0, dfsStr)
        mana = manacher(dfsStr)
        ans = [False] * n
        for i in range(n):
            if(mana.isPossibleRange(start[i], start[i] + subSz[i] - 1)):
                ans[i] = True
        return ans",1427894858
Manan Rathod,Manan04,296,3607,python3,"mxN = 10 ** 6 + 5
gpd = [1] * mxN
for i in range(2, mxN):
    for j in range(i + i, mxN, i):
        gpd[j] = i
class Solution:
    def minOperations(self, a: List[int]) -> int:
        n = len(a)
        ans = 0
        for i in range(n - 2, -1, -1):
            cur = a[i]
            ahead = a[i + 1]
            while cur > ahead and gpd[cur] != 1:
                cur //= gpd[cur]
                ans += 1
            if(cur > ahead):
                return -1
            a[i] = cur
        return ans",1427838139
Anikate Koul,anikateKoul,297,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int z) {
        int n = s.size();
        vector<array<int, 26>> fre(n);
        for(int i = 0; i < n; i++) {
            fre[i][s[i] - 'a']++;
        }

        vector<array<int, 26>> pre(1);
        for(int i = 0; i < n; i++) pre.push_back(fre[i]);
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j < 26; j++) {
                pre[i][j] += pre[i-1][j];
            }
        }

        int ans = 0;
        for(int i = 0; i <= n; i++) {
            for(int j = i+1; j <= n; j++) {
                int val = -1;
                for(int k = 0; k < 26; k++) {
                    val = max(val, pre[j][k] - pre[i][k]);
                }

                if(val >= z) ans++;
            }
        }

        return ans;
    }
};",1427837705
Anikate Koul,anikateKoul,297,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string tmp = """";
        int ind = 0;
        vector<string> ans;
        while(tmp != target) {
            tmp.push_back('a');
            ans.push_back(tmp);
            while(tmp.back() != target[ind]) {
                tmp.back()++;
                ans.push_back(tmp);
            }
            ind++;
        }

        return ans;
    }
};",1427826789
Anikate Koul,anikateKoul,297,3603,cpp,"#define p 101
#define MOD 1000000007

struct Query {
	int L, R;
};

class Solution {
public:
unsigned long long int modPow(
	unsigned long long int base,
	unsigned long long int exponent)
{
	if (exponent == 0)
		return 1;
	if (exponent == 1)
		return base;

	unsigned long long int temp = modPow(base, exponent / 2);

	if (exponent % 2 == 0)
		return (temp % MOD * temp % MOD) % MOD;
	else
		return (((temp % MOD * temp % MOD) % MOD)
				* base % MOD)
			% MOD;
}

// A Function to calculate Modulo Multiplicative Inverse of 'n'
unsigned long long int findMMI(unsigned long long int n)
{
	return modPow(n, MOD - 2);
}

// A Function to calculate the prefix hash
void computePrefixHash(
	string str, int n,
	unsigned long long int prefix[],
	unsigned long long int power[])
{
	prefix[0] = 0;
	prefix[1] = str[0];

	for (int i = 2; i <= n; i++)
		prefix[i] = (prefix[i - 1] % MOD
					+ (str[i - 1] % MOD
						* power[i - 1] % MOD)
						% MOD)
					% MOD;

	return;
}

// A Function to calculate the suffix hash
// Suffix hash is nothing but the prefix hash of
// the reversed string
void computeSuffixHash(
	string str, int n,
	unsigned long long int suffix[],
	unsigned long long int power[])
{
	suffix[0] = 0;
	suffix[1] = str[n - 1];

	for (int i = n - 2, j = 2; i >= 0 && j <= n; i--, j++)
		suffix[j] = (suffix[j - 1] % MOD
					+ (str[i] % MOD
						* power[j - 1] % MOD)
						% MOD)
					% MOD;
	return;
}

// A Function to answer the Queries
vector<bool> queryResults(string str, Query q[], int m, int n,
				unsigned long long int prefix[],
				unsigned long long int suffix[],
				unsigned long long int power[])
{
    vector<bool> ans;
	for (int i = 0; i <= m - 1; i++) {
		int L = q[i].L;
		int R = q[i].R;

		// Hash Value of Substring [L, R]
		unsigned long long hash_LR
			= ((prefix[R + 1] - prefix[L] + MOD) % MOD
			* findMMI(power[L]) % MOD)
			% MOD;

		// Reverse Hash Value of Substring [L, R]
		unsigned long long reverse_hash_LR
			= ((suffix[n - L] - suffix[n - R - 1] + MOD) % MOD
			* findMMI(power[n - R - 1]) % MOD)
			% MOD;

		// If both are equal then
		// the substring is a palindrome
		if (hash_LR == reverse_hash_LR) {
			
			ans.push_back(true);
		}

		else
			ans.push_back(false);
	}

	return ans;
}

// A Dynamic Programming Based Approach to compute the
// powers of 101
void computePowers(unsigned long long int power[], int n)
{
	// 101^0 = 1
	power[0] = 1;

	for (int i = 1; i <= n; i++)
		power[i] = (power[i - 1] % MOD * p % MOD) % MOD;

	return;
}

// --------------------------------
    void dfs1(int node, int par, vector<int> g[], vector<int> &mark, int &time, string &s, string &ans) {
        for(auto child : g[node]) {
            if(child == par) continue;
            dfs1(child, node, g, mark, time, s, ans);
        }
        mark[node] = time++;
        ans.push_back(s[node]);
    }

    void dfs2(int node, int par, vector<int> g[], vector<int> &start, vector<int> &end, vector<int> &mark) {
        start[node] = mark[node];
        end[node] = mark[node];
        for(auto child : g[node]) {
            if(child == par) continue;
            dfs2(child, node, g, start, end, mark);
            start[node] = min(start[node], start[child]);
            end[node] = max(end[node], end[child]);
        }
    }
    vector<bool> findAnswer(vector<int>& par, string s) {
        int n = par.size();
        vector<int> g[n+5];
        for(int i = 1; i < n; i++) {
            int a = i, b = par[i];
            g[a].push_back(b);
            g[b].push_back(a);
        }
        for(int i = 0; i < n; i++) {
            if(g[i].size() != 0) sort(g[i].begin(), g[i].end());
        }

        vector<int> start(n+5), end(n+5), mark(n+5);
        int time = 0;
        string ans = """";
        dfs1(0, -1, g, mark, time, s, ans);
        dfs2(0, -1, g, start, end, mark);

        // cout<<""ans = ""<<ans<<endl;
        // cout<<""start = "";
        // for(int i = 0; i < n; i++) cout<<start[i]<<"" "";
        // cout<<endl;

        // cout<<""end = "";
        // for(int i = 0; i < n; i++) cout<<end[i]<<"" "";
        // cout<<endl;
        
        unsigned long long int power[n + 1];

        computePowers(power, n);

        // Arrays to hold prefix and suffix hash values
        unsigned long long int prefix[n + 1], suffix[n + 1];

        // Compute Prefix Hash and Suffix Hash Arrays
        computePrefixHash(ans, n, prefix, power);
        computeSuffixHash(ans, n, suffix, power);

        Query q[n];

        for(int i = 0; i < n; i++) {
            q[i].L = start[i];
            q[i].R = end[i];
        }

        vector<bool> fans =  queryResults(ans, q, n, n, prefix, suffix, power);
        return fans;
    }
};",1427936694
Anikate Koul,anikateKoul,297,3607,cpp,"const int N = 1e6 + 5;
int spf[N];
class Solution {
public:
    void fun() {
        for(int i = 1; i < N; i++) spf[i] = i;

        for(int i = 2; i < N; i++) {
            if(spf[i] != i) continue;
            for(long long j = ((long long)i)*i; j < N; j += i) {
                spf[j] = min(spf[j], i);
            }
        }
    }
    int minOperations(vector<int>& v) {
        if(spf[10] != 2) fun();
        int n = v.size();

        int ans = 0;
        bool isPoss = true;
        for(int i = n-2; i >= 0; i--) {
            if(v[i] > v[i+1]) {
                if(spf[v[i]] > v[i+1]) {
                    isPoss = false;
                    break;
                }
                else {
                    v[i] = spf[v[i]];
                    ans++;
                }
            }
        }

        if(!isPoss) return -1;
        return ans;
    }
};",1427858801
Ingenious,warrior_raj_09,298,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length(), res = 0;
        int[] cnt = new int[26];
        
        for (int i = 0, j = 0; i < n; i++) {
            cnt[s.charAt(i) - 'a']++;
            
            while (j <= i && cnt[s.charAt(i) - 'a'] >= k) {
                res += n - i;
                cnt[s.charAt(j++) - 'a']--;
            }
        }
        
        return res;
    }
}
",1427842336
Ingenious,warrior_raj_09,298,3566,java,"public class Solution {
    public static List<String> stringSequence(String tgt) {
        List<String> res = new ArrayList<>();
        StringBuilder cur = new StringBuilder();

        for (char c : tgt.toCharArray()) {
            if (cur.length() == 0) {
                cur.append('a');
                res.add(cur.toString());
            }

            while (cur.charAt(cur.length() - 1) != c) {
                char last = cur.charAt(cur.length() - 1);
                last = (last == 'z') ? 'a' : ++last;
                cur.setCharAt(cur.length() - 1, last);
                res.add(cur.toString());
            }

            if (cur.charAt(cur.length() - 1) == c) {
                cur.append('a');
                res.add(cur.toString());
            }
        }

        res.remove(res.size() - 1);
        return res;
    }
}
",1427836663
Ingenious,warrior_raj_09,298,3603,java,"public class Solution {
    private int[] p;
    private String s;
    private List<List<Integer>> g;
    private long[] pow;
    private static final long PR = 919, MD = 1000000009;

    public boolean[] findAnswer(int[] parent, String str) {
        helper(parent, str);
        int[] ord = solve();
        return process(ord);
    }

    private void helper(int[] parent, String str) {
        p = parent;
        s = str;
        int n = p.length;
        g = new ArrayList<>(n);
        for (int i = 0; i < n; i++) g.add(new ArrayList<>());
        for (int i = 1; i < n; i++) g.get(p[i]).add(i);
        
        pow = new long[n + 2];
        pow[0] = 1;
        // g.add(pow[0])
        for (int i = 1; i <= n + 1; i++) pow[i] = (pow[i - 1] * PR) % MD;
        
    }

    private int[] solve() {
        int n = p.length;
        boolean[] v = new boolean[n];
        Deque<Integer> stk = new ArrayDeque<>();
        List<Integer> ord = new ArrayList<>(n);
        stk.push(0);

        while (!stk.isEmpty()) {
            int x = stk.peek();
            if (!v[x]) {
                v[x] = true;
                for (int i = g.get(x).size() - 1; i >= 0; i--) stk.push(g.get(x).get(i));
            } else {
                stk.pop();
                ord.add(x);
            }
        }
        return ord.stream().mapToInt(i -> i).toArray();
    }

    private boolean[] process(int[] ord) {
        int n = p.length;
        int[] len = new int[n];
        long[] h1 = new long[n], h2 = new long[n];
        boolean[] ans = new boolean[n];

        for (int x : ord) {
            len[x] = 1;
            long ch1 = 0, ch2 = s.charAt(x) - 'a' + 1;
            
            for (int y : g.get(x)) {
                ch1 = (ch1 * pow[len[y]] + h1[y]) % MD;
                len[x] += len[y];
            }
            h1[x] = (ch1 * PR + (s.charAt(x) - 'a' + 1)) % MD;
            // System.out.println(h1[x]);

            for (int i = g.get(x).size() - 1; i >= 0; i--) {
                int y = g.get(x).get(i);
                ch2 = (ch2 * pow[len[y]] + h2[y]) % MD;
            }
            h2[x] = ch2;

            ans[x] = (h1[x] == h2[x]);
            // System.out.println(ans[x]);
        }

        return ans;
    }
}",1427928803
Ingenious,warrior_raj_09,298,3607,java,"class Solution {
    static final int M = 1000000;
    static int[] d = new int[M + 1];
    static boolean p = false;
    public int minOperations(int[] a) {
        solve();
        int o = 0, n = a.length;
        for (int i = n - 2; i >= 0; i--) {
            while (a[i] > a[i + 1]) {
                int v = d[a[i]];
                if (v == 1 || (a[i] /= v) <= 0) return -1;
                o++;
            }
        }
        return o;
    }
    public static void solve() {
        if (p) return;
        Arrays.fill(d, 1);
        for (int i = 2; i <= M; i++)
            for (int j = i + i; j <= M; j += i)
                d[j] = i;
        p = true;
    }
}",1427901166
Sai Visal,gsaivishal,299,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        for(int start = 0; start < n; start++) {
            vector<int> count(26, 0);
            for(int maxi = 0, end = start; end < n; end++) {
                maxi = max(maxi, ++count[s[end] - 'a']);
                res += (maxi >= k);
            }
        }
        return res;
    }
};",1427833392
Sai Visal,gsaivishal,299,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        while(!target.empty()) {
            char& last = target.back();
            for(char ch = last; ch >= 'a'; ch--) {
                last = ch;
                res.push_back(target);
            }
            target.pop_back();
        }
        sort(res.begin(), res.end());
        return res;
    }
};",1427828002
Sai Visal,gsaivishal,299,3603,cpp,"typedef long long ll;

const ll prime = 31;
const ll mod = 1e9 + 9;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        init(parent, s);
        dfs(0, -1);
        return ans;
    }
private:
    int n;
    string s;
    vector<bool> ans;
    vector<set<int>> adj;
    vector<ll> power;

    void init(vector<int>& parent, string S) {
        s = S, n = s.size();
        
        ans = vector<bool>(n, 0);
        adj = vector<set<int>>(n);
        power = vector<ll>(n + 1, 1);

        for(int i = 1; i < n; i++) {
            adj[parent[i]].insert(i);
            power[i] = (prime * power[i - 1]) % mod;
        }
        power[n] = (prime * power[n - 1]) % mod;
    }

    array<ll, 3> dfs(int root, int parent) {
        vector<array<ll, 3>> frh;
        for(int child : adj[root])
            if(child != parent)
                frh.push_back(dfs(child, root));

        ll index = (s[root] - 'a' + 1);
        ll h = (index * prime) % mod;
        frh.push_back({1LL, h, h});

        ll fwd = 0, curLen = 0;
        for(auto [len, f, r] : frh) {
            f = (f * power[curLen]) % mod;
            fwd = (fwd + f) % mod;
            curLen += len;
        }
        
        curLen = 0;
        ll rev = 0;
        for(int i = frh.size() - 1; i >= 0; i--) {
            auto [len, f, r] = frh[i];
            r = (r * power[curLen]) % mod;
            rev = (rev + r) % mod;
            curLen += len;
        }

        ans[root] = (fwd == rev);
        return {curLen, fwd, rev};
    }
};",1427929503
Sai Visal,gsaivishal,299,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int res = 0, n = nums.size();
        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] > nums[i + 1]) {
                int x = findDivisor(nums[i]);
                int y = (nums[i] / x);
                cout<<nums[i]<<"" ""<<y<<endl;
                if(y != 1 && y <= nums[i + 1]) {
                    nums[i] = y;
                    res++;
                    continue;
                }
                return -1;
            }
        }
            
        return res;
    }
private:
    int findDivisor(int n) {
        for(int i = 2; i * i <= n; i++)
            if(n % i == 0) return (n / i);
        return n;
    }
};",1427854863
Jonas,arael34,300,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        occur = collections.defaultdict(int)
        freqs = collections.defaultdict(int)
        maxFreq = 0

        # r = 0
        # for l in range(len(s)):
        #     while r < len(s) and maxFreq < 
        ct = 0

        for i in range(len(s)):
            c = collections.defaultdict(int)
            for j in range(i, len(s)):
                c[s[j]] += 1
                if c[s[j]] == k:
                    ct += len(s) - j
                    print(i, j, len(s), ct)
                    break

        return ct
",1427841936
Jonas,arael34,300,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        appear = []
        builder = []
        for ch in target:
            builder.append('a')
            appear.append(''.join(builder))
            while builder[-1] != ch:
                builder[-1] = chr(ord(builder[-1]) + 1)
                appear.append(''.join(builder))

        return appear
",1427825141
Jonas,arael34,300,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)

        children = collections.defaultdict(list)
        for node, par in enumerate(parent):
            children[par].append(node)

        isPalArr = [False] * n

        def isPal(ss: str):
            n = len(ss) / 2
            return ss[:floor(n)] == ss[ceil(n):][::-1]

        def dfs(node: int):
            builder = []
            for child in children[node]:
                builder.append(dfs(child))
            builder.append(s[node])
            dfsStr = ''.join(builder)
            isPalArr[node] = isPal(dfsStr)
            return ''.join(builder)

        dfs(0)
        return isPalArr
",1427887593
Jonas,arael34,300,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        minSoFar = nums[-1]
        ops = 0

        def greatestProperDivisor(n: int):
            for i in range(2, n):
                if n / i == n // i: return n // i
            return 1

            # for i in range(n // 2, 1, -1):
            #     if n % i == 0: return i
            # return 1

        for i in range(len(nums) - 2, -1, -1):
            if nums[i] <= minSoFar:
                minSoFar = nums[i]
                continue

            # We have to try and divide
            while nums[i] > minSoFar:
                gpd = greatestProperDivisor(nums[i])
                if gpd == 1: return -1
                nums[i] //= gpd
                ops += 1

            minSoFar = nums[i]

        return ops
",1427856940
YarosHarm,YarosHarm,301,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] f = new int[26];
        int l = 0;
        int n = s.length();
        int c = 0;
        for(int r = 0; r < n; r++) {
            f[s.charAt(r) - 'a']++;
            while(f[s.charAt(r) - 'a'] >= k) {
                f[s.charAt(l) - 'a']--;
                l++;
            }

            c += r - l + 1;
        }

        return n * (n + 1) / 2 - c;
    }
}",1427829032
YarosHarm,YarosHarm,301,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        String curr = """";
        for(char ch : target.toCharArray()) {
            for(int i = 0; i <= (ch - 'a'); i++) {
                res.add(curr + (char) (i + 'a'));
            }
            curr += ch;
        }

        return res;
    }
}",1427825330
YarosHarm,YarosHarm,301,3603,java,"class Solution {
    static void dbg(Object... args) {
        List<String> lst = new ArrayList<>();
        for (Object arg : args) {
        if (arg.getClass().isArray()) {
        if (("""" + arg.getClass().getComponentType()).equals(""int"")) {
        lst.add(Arrays.toString((int[]) arg));
        } else if (("""" + arg.getClass().getComponentType()).equals(""long"")) {
        lst.add(Arrays.toString((long[]) arg));
        } else if (("""" + arg.getClass().getComponentType()).equals(""boolean"")) {
        lst.add(Arrays.toString((boolean[]) arg));
        }
        } else {
        lst.add(arg.toString());
        }
        }
        System.out.println(""["" + String.join("", "", lst) + ""]"");
        }

static void dbg(Object obj) {
        System.out.println(obj);
        }

static void dbg(int[] arr) {
        System.out.println(Arrays.toString(arr));
        }

static void dbg(boolean[] arr) {
        System.out.println(Arrays.toString(arr));
        }

static void dbg(long[] arr) {
        System.out.println(Arrays.toString(arr));
        }

static void dbg(char[] arr) {
        System.out.println(Arrays.toString(arr));
        }

static void dbg(int[][] arr) {
        List<String> lst = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
        lst.add(Arrays.toString(arr[i]));
        }
        System.out.println(""["" + String.join("","", lst) + ""]"");
        }

static void dbg(long[][] arr) {
        List<String> lst = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
        lst.add(Arrays.toString(arr[i]));
        }
        System.out.println(""["" + String.join("","", lst) + ""]"");
        }

static void dbg(List<int[]> lst) {
        List<String> res = new ArrayList<>();
        for (int i = 0; i < lst.size(); i++) {
        res.add(Arrays.toString(lst.get(i)));
        }
        System.out.println(""["" + String.join("","", res) + ""]"");
        }

static void dbg(Queue<int[]> q) {
        List<int[]> lst = new ArrayList<>(q);
        List<String> res = new ArrayList<>();
        for (int i = 0; i < lst.size(); i++) {
        res.add(Arrays.toString(lst.get(i)));
        }
        System.out.println(""["" + String.join("","", res) + ""]"");
        }

static void dbgSegmentTree(long[] tree) {
        int n = tree.length;
        List<List<String>> res = new ArrayList<>();
        for (int level = 2; level <= n; level = (level << 1)) {
        List<String> curr = new ArrayList<>();
        int c = n / level;
        for (int j = c; j < c + c; j++) {
        curr.add(tree[j] + """");
        }
        res.add(curr);
        }
        Collections.reverse(res);
        for (List<String> re : res) {
        dbg(re);
        }
        }


    int[] ss;
    StringBuilder str;
    List<Integer>[] graph;
    String s;
    int[] map;
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        this.s = s;
        ss = new int[n];
        str = new StringBuilder();
        map = new int[n];
        graph = new ArrayList[n];
        for(int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for(int i = 1; i < n; i++) {
            graph[parent[i]].add(i);
        }
        dfs(-1, 0);
        int[] m = manacher(str.toString());
        boolean[] res = new boolean[n];
        // dbg(m);
        for(int i = 0; i < n; i++) {
            int subsize = ss[i];
            int spos = map[i];
            int mid = spos - subsize / 2;
            int mpos = mid * 2 + 1;
            if(subsize % 2 == 0) {
                mpos++;
            }
            res[i] = m[mpos] >= subsize;
            // dbg(i, subsize, spos, mpos, m[mpos]);
        }
        return res;
    }

    void dfs(int p, int v) {
        ss[v] = 1;
        for(Integer u : graph[v]) {
            if(p != u) {
                dfs(v, u);
                ss[v] += ss[u];
            }
        }
        str.append(s.charAt(v));
        map[v] = str.length() - 1;
    }

    int[] manacher(String s) {
        // Preprocess even length
        s = ""#"" + String.join(""#"", s.split("""")) + ""#"";
        int center = 0;
        int right = 0;
        int[] p = new int[s.length()];


        // Execute Manacher odd
        for (int i = 0; i < s.length(); i++) {
            if (i < right) {
                p[i] = Math.min(right - i, p[2 * center - i]);
            }
            while (i - p[i] - 1 >= 0 && i + p[i] + 1 < s.length() && s.charAt(i - p[i] - 1) == s.charAt(i + p[i] + 1)) {
                p[i]++;
            }
            if (i + p[i] > right) {
                center = i;
                right = i + p[i];
            }
        }
        return p;
    }
}",1427930387
YarosHarm,YarosHarm,301,3607,java,"class Solution {
    static void dbg(Object... args) {
        List<String> lst = new ArrayList<>();
        for (Object arg : args) {
            if (arg.getClass().isArray()) {
                if (("""" + arg.getClass().getComponentType()).equals(""int"")) {
                    lst.add(Arrays.toString((int[]) arg));
                } else if (("""" + arg.getClass().getComponentType()).equals(""long"")) {
                    lst.add(Arrays.toString((long[]) arg));
                } else if (("""" + arg.getClass().getComponentType()).equals(""boolean"")) {
                    lst.add(Arrays.toString((boolean[]) arg));
                }
            } else {
                lst.add(arg.toString());
            }
        }
        System.out.println(""["" + String.join("", "", lst) + ""]"");
    }

    static void dbg(Object obj) {
        System.out.println(obj);
    }

    static void dbg(int[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    static void dbg(boolean[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    static void dbg(long[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    static void dbg(char[] arr) {
        System.out.println(Arrays.toString(arr));
    }

    static void dbg(int[][] arr) {
        List<String> lst = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            lst.add(Arrays.toString(arr[i]));
        }
        System.out.println(""["" + String.join("","", lst) + ""]"");
    }

    static void dbg(long[][] arr) {
        List<String> lst = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            lst.add(Arrays.toString(arr[i]));
        }
        System.out.println(""["" + String.join("","", lst) + ""]"");
    }

    static void dbg(List<int[]> lst) {
        List<String> res = new ArrayList<>();
        for (int i = 0; i < lst.size(); i++) {
            res.add(Arrays.toString(lst.get(i)));
        }
        System.out.println(""["" + String.join("","", res) + ""]"");
    }

    static void dbg(Queue<int[]> q) {
        List<int[]> lst = new ArrayList<>(q);
        List<String> res = new ArrayList<>();
        for (int i = 0; i < lst.size(); i++) {
            res.add(Arrays.toString(lst.get(i)));
        }
        System.out.println(""["" + String.join("","", res) + ""]"");
    }

    static void dbgSegmentTree(long[] tree) {
        int n = tree.length;
        List<List<String>> res = new ArrayList<>();
        for (int level = 2; level <= n; level = (level << 1)) {
            List<String> curr = new ArrayList<>();
            int c = n / level;
            for (int j = c; j < c + c; j++) {
                curr.add(tree[j] + """");
            }
            res.add(curr);
        }
        Collections.reverse(res);
        for (List<String> re : res) {
            dbg(re);
        }
    }

    static int maxN = (int) 1e6;
    static int[] pds = new int[maxN + 1];
    static {
        Arrays.fill(pds, -1);
        for (int i = 2; i <= maxN; i++) {
            for (int j = 2 * i; j <= maxN; j += i) {
                pds[j] = i;
            }
        }
    }

    public int minOperations(int[] nums) {
        int n = nums.length;
        int prev = Integer.MAX_VALUE;
        int res = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] <= prev) {
                prev = Math.min(prev, nums[i]);
                continue;
            }
            while (nums[i] > prev) {
                // dbg(nums[i], prev, pds[nums[i]]);
                if (pds[nums[i]] == -1) {
                    return -1;
                }
                nums[i] /= pds[nums[i]];
                res++;
            }
            prev = Math.min(prev, nums[i]);
        }
        return res;
    }
}",1427850160
ntc,ntcqwq,302,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        for i in range(len(s)):
            freq = defaultdict(int)
            for j in range(i, len(s)):
                freq[s[j]] += 1
                if freq[s[j]] >= k: 
                    ans += len(s)-j
                    break
        return ans",1427843672
ntc,ntcqwq,302,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        cur = """"
        for i in target:
            cur += ""a""
            ans.append(cur)
            while cur[-1] != i:
                cur = cur[:-1] + chr(ord(cur[-1])+1)
                ans.append(cur)
        return ans",1427828247
ntc,ntcqwq,302,3603,python3,"class Solution:
    def findAnswer(self, p: List[int], s: str) -> List[bool]:
        n, MOD = len(p), int(1e9)+7
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[p[i]].append(i)
        hsh = [1] * (n+1)
        for i in range(1, n+1):
            hsh[i] = hsh[i-1]*27%MOD
        @cache
        def dfs(x):
            u, v, w = 0, 0, 0
            for y in sorted(tree[x]):
                a, b, c = dfs(y)
                u = (u*hsh[c]+a)%MOD
                v = (b*hsh[w]+v)%MOD
                w += c
            return ((u*27+(ord(s[x])-96))%MOD, (v+(ord(s[x])-96)*hsh[w])%MOD, w+1)
        for i in range(n): dfs(i)
        return [dfs(i)[0]==dfs(i)[1] for i in range(n)]
",1427895673
ntc,ntcqwq,302,3607,python3,"class Solution:
    def sieve(self, n):
        p = [False] * (n//2)
        for i in range(3, int(n**0.5)+1, 2):
            if not p[i//2]:
                for j in range(i*i, n, i*2):
                    p[j//2] = True
        return [2]+[2*i+1 for i in range(1, (n//2)) if not p[i]]
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        pm = self.sieve(int(1e5)+3)
        @cache
        def spf(x):
            return next((p for p in pm if x % p == 0), x)
        ans = 0
        for i in range(n-1, 0, -1):
            if nums[i-1] > nums[i]:
                p = spf(nums[i-1])
                if p == nums[i-1]: return -1
                if p <= nums[i]: nums[i-1]=p; ans+=1
                else: return -1
        return ans",1427930487
Palash Jhaveri,Pal_J,303,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<vector<int>> pre(n + 1, vector<int>(26, 0));
        for (int i = 0;i < n;i++) {
            for (int j = 0;j < 26;j++) {
                pre[i + 1][j] = pre[i][j];
            }
            pre[i + 1][s[i] - 'a']++;
        }
        int ans = 0;
        for(int i = 0;i<n;i++){
            for(int j = i;j<=n;j++){
                for(int l = 0;l<26;l++){
                    if(pre[j][l] - pre[i][l] >= k){
                        ans++;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};",1427833362
Palash Jhaveri,Pal_J,303,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s = ""a"";
        int ind = 0; 
        while(s != target){
            ans.push_back(s);
            if(s[ind] == target[ind]){
                ind++;
                s += 'a';
            }
            else{
                s[ind] = (s[ind] + 1);
            }
        }
        ans.push_back(s);
        return ans;
    }
};",1427824980
Palash Jhaveri,Pal_J,303,3603,cpp,"class Solution {
public:
    #define ll long long 
    ll p = 31;
    ll mod = 1e9 + 9;

    ll m_mod(ll x,ll y){return ((x%mod)*(y%mod))%mod;}

    vector<ll> p_pow;

    void dfs1(int node,int par,vector<int> adj[],vector<int> &subtree){
        subtree[node] = 1;
        for(int i = 0;i<adj[node].size();i++){
            if(adj[node][i] != par){
                dfs1(adj[node][i],node,adj,subtree);
                subtree[node] += subtree[adj[node][i]];
            }
        }
    }

    void dfs(int node,int par,vector<int> adj[],vector<bool> &ans,vector<ll> &nodehashf, vector<ll> &nodehashb,string &s,vector<int> &subtree){
        for(int i = 0;i<adj[node].size();i++){
            if(adj[node][i] != par){
                dfs(adj[node][i],node,adj,ans,nodehashf,nodehashb,s,subtree);
            }
        }
        ll hashf = 0;
        ll hashb = 0;
        hashf = s[node] - 'a' + 1;
        int currsz = 1;
        for(int i = adj[node].size()-1;i>=0;i--){
            hashf = (hashf + m_mod(nodehashf[adj[node][i]],p_pow[currsz]))%mod;
            currsz += subtree[adj[node][i]];
        }
        int currszb = 0;
        for(int i = 0;i<adj[node].size();i++){
            hashb = (hashb + m_mod(nodehashb[adj[node][i]],p_pow[currszb]))%mod;
            currszb += subtree[adj[node][i]];
        }
        hashb = (hashb + m_mod(s[node] - 'a' + 1,p_pow[currszb]))%mod;
        if(hashf == hashb){
            ans[node] = true;
        }
        nodehashf[node] = hashf;
        nodehashb[node] = hashb;
        //cout << node << "" "" << hashf << "" "" << hashb << endl;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        p_pow.resize(s.size()+1);
        p_pow[0] = 1;
        for(int i = 1;i<=s.size();i++){
            p_pow[i] = m_mod(p_pow[i-1],p);
        }
        int n = parent.size();
        vector<int> adj[n];
        for(int i = 0;i<n;i++){
            if(parent[i] != -1){
                adj[parent[i]].push_back(i);
                //adj[i].push_back(parent[i]);
            }
        }
        for(int i = 0;i<n;i++){
            if(adj[i].size() != 0) sort(adj[i].begin(),adj[i].end());
        }
        vector<bool> ans(n);
        vector<ll> nodehashf(n),nodehashb(n);
        vector<int> subtree(n);
        dfs1(0,-1,adj,subtree);
        dfs(0,-1,adj,ans,nodehashf,nodehashb,s,subtree);
        return ans;
    }
};",1427930497
Palash Jhaveri,Pal_J,303,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int maxi = *max_element(nums.begin(), nums.end());
        vector<int> fact(maxi + 1, 0);
        fact[0] = fact[1] = 1;
        for(int i = 2;i<=maxi;i++){
            if(fact[i] == 0){
                fact[i] = i;
                for(int j = 2*i;j<=maxi;j+=i){
                    if(fact[j] == 0) fact[j] = i;
                }
            }
        }
        int n = nums.size();
        int ans = 0;
        for(int i = n-2;i>=0;i--){
            if(nums[i] > nums[i+1]){
                if(fact[nums[i]] > nums[i+1]){
                    //cout << nums[i] << "" "" << fact[nums[i]] << endl;
                    return -1;
                }
                nums[i] = fact[nums[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427851880
Sambhav Jain,Sambhav-Jain,305,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) 
    {
        int ans = 0;
        vector<vector<int>> freq(s.size() + 1, vector<int>(26, 0));
        for (int i = 0; i <s.size(); i++)
        {
            freq[i + 1] = freq[i];
            freq[i + 1][s[i] - 'a']++; 
        }  
        for (int i = 0; i < s.size(); i++)
        {
            int curr = s.size();
            for (int start = i, end = s.size() - 1, mid; start <= end;)
            {
                mid = (start + end) / 2;
                int cnt = 0;
                for (int j = 0; j < 26; j++)
                {
                    cnt = max(cnt, freq[mid + 1][j] - freq[i][j]);
                }
                if (cnt >= k)
                {
                    curr = mid;
                    end = mid - 1;
                }
                else
                {
                    start = mid + 1;
                }
            }
            if (curr == s.size())
            {
                break;
            }
            else
            {
                ans += s.size() - curr;
            }
        }
        return ans;
    }
};",1427830665
Sambhav Jain,Sambhav-Jain,305,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) 
    {
        vector<string> ans;
        string s = ""a"";
        ans.emplace_back(s);
        while (s != target)
        {
            while (s[s.size() - 1] < target[s.size() - 1])
            {
                s.back()++;
                ans.emplace_back(s);
            }
            if (s.size() < target.size())
            {
                s += ""a"";
                ans.emplace_back(s);
            }
        }
        return ans;
    }
};",1427825146
Sambhav Jain,Sambhav-Jain,305,3603,cpp,"class HashedString 
{
    static const __int128_t MOD = 2305843009213693952;
    static const __int128_t B = 9973;

    vector<__int128_t> pow = {1};

    vector<__int128_t> p_hash;

    public:
    HashedString(const string &s) : p_hash(s.size() + 1) 
    {
        while (pow.size() <= s.size() + 10) 
        { 
            pow.push_back((pow.back() * B) % MOD); 
        }

        p_hash[0] = 0;
        for (int i = 0; i < s.size(); i++) 
        {
            p_hash[i + 1] = ((p_hash[i] * B) % MOD + s[i]) % MOD;
        }
    }

    __int128_t getHash(int start, int end) 
    {
        __int128_t raw_val = (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));
        return (raw_val % MOD + MOD) % MOD;
    }
};

class Solution {
    int cnt = 0;
    void dfs(int u, string& str, const vector<vector<int>> &adj, const string &s)
    {
        inTime[u] = cnt;
        subtreeSize[u] = 1;
        str[cnt++] = s[u];
        for (auto &v : adj[u])
        {
            dfs(v, str, adj, s);
            subtreeSize[u] += subtreeSize[v];
        }
    }
    vector<int> inTime, subtreeSize;
public:
    vector<bool> findAnswer(vector<int>& parent, string s) 
    {
        int n = parent.size();
        inTime.resize(n);
        subtreeSize.resize(n);
        vector<bool> ans(n, false);
        string str;
        str.resize(n);
        vector<vector<int>> adj(n);
        for (int i = n - 1; i > 0; i--)
        {
            adj[parent[i]].emplace_back(i);
        }
        dfs(0, str, adj, s);
        HashedString obj1(str);
        reverse(str.begin(), str.end());
        HashedString obj2(str);
        for (int i = 0; i < n; i++)
        {
            int start = inTime[i];
            int end = start + subtreeSize[i] - 1;
            if (obj1.getHash(start, end) == obj2.getHash(n - end - 1, n - start - 1))
            {
                ans[i] = true;
            }
        }
        return ans;
    }
};",1427930846
Sambhav Jain,Sambhav-Jain,305,3607,cpp,"class Solution {
    int helper(int num)
    {
        int ans = 1;
        for (int i = 2; i * i <= num; i++)
        {
            if (num % i == 0)
            {
                ans = max(ans, i);
                ans = max(ans, num / i);
            }
        }
        return ans;
    }
public:
    int minOperations(vector<int>& nums) 
    {
        int ans = 0;
        for (int i = (int)(nums.size()) - 2; i >= 0; i--)
        {
            if (nums[i] <= nums[i + 1])
            {
                continue;
            }
            int curr = helper(nums[i]);
            nums[i] /= curr;
            ans++;
            if (nums[i] > nums[i + 1])
            {
                return -1;
            }
        }    
        return ans;
    }
};",1427849065
sarthakdahiya7,sarthakdahiya7,306,3502,cpp,"class Solution {
public:
    int st1234(int ae1288){
        return ae1288;
    }
    int st1235(int ae1288){
        return ae1288;
    }
    int st1236(int ae1288){
        return ae1288;
    }
    int st1237(int ae1288){
        return ae1288;
    }
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int left = 0, right = 0, res = 0;
        unordered_map<char, int> mp;

        for (right = 0; right < n; ++right) {
            mp[s[right]]++;

            while (mp[s[right]] >= k) {
                res += (n - right);

                mp[s[left]]--;
                left++;
            }
        }

        return res;
    }
};",1427869754
sarthakdahiya7,sarthakdahiya7,306,3566,cpp,"class Solution {
public:
    int st1234(int ae1288){
        return ae1288;
    }
    int st1235(int ae1288){
        return ae1288;
    }
    int st1236(int ae1288){
        return ae1288;
    }
    int st1237(int ae1288){
        return ae1288;
    }

    vector<string> stringSequence(string target) {
        vector<string> anss;
        string crrr = """";

        for (char ch : target) {
            crrr += 'a';
            anss.push_back(crrr);

            while (crrr.back() != ch) {
                crrr.back()++;
                anss.push_back(crrr);
            }
        }

        return anss;
    }
};",1427867400
sarthakdahiya7,sarthakdahiya7,306,3603,python3,"from collections import deque
from typing import List

class Solution:
    def e1288( e12):
        return e12
    def e31288( e12):
        return e12
    def e21288( e12):
        return e12
    def e11288(e12):
        return e12
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = [[] for _ in range(n)]
        
        for i in range(1, n):
            children[parent[i]].append(i)
        
        base1 = 911382628
        mod1 = 10**18 + 7
        base2 = 3571
        mod2 = 10**18 + 9
        max_length = n + 1
        
        base_pows1 = [1] * max_length
        base_pows2 = [1] * max_length
        
        for i in range(1, max_length):
            base_pows1[i] = (base_pows1[i - 1] * base1) % mod1
            base_pows2[i] = (base_pows2[i - 1] * base2) % mod2
        
        hash_forward1 = [0] * n
        hash_reverse1 = [0] * n
        hash_forward2 = [0] * n
        hash_reverse2 = [0] * n
        length = [1] * n
        
        in_degree = [len(children[i]) for i in range(n)]
        queue = deque()
        
        for i in range(n):
            if in_degree[i] == 0:
                queue.append(i)
        
        subtree_map1 = {}
        subtree_map2 = {}
        current_id1 = 1
        current_id2 = 1
        
        while queue:
            node = queue.popleft()
            
            # Hash for forward and reverse direction using base1/mod1
            combined_hash1 = 0
            for child in children[node]:
                combined_hash1 = (combined_hash1 * base_pows1[length[child]] + hash_forward1[child]) % mod1
            combined_hash1 = (combined_hash1 * base1 + ord(s[node])) % mod1
            hash_forward1[node] = combined_hash1
            
            combined_hash_r1 = ord(s[node])
            for child in reversed(children[node]):
                combined_hash_r1 = (combined_hash_r1 * base_pows1[length[child]] + hash_reverse1[child]) % mod1
            hash_reverse1[node] = combined_hash_r1
            
            # Hash for forward and reverse direction using base2/mod2
            combined_hash2 = 0
            for child in children[node]:
                combined_hash2 = (combined_hash2 * base_pows2[length[child]] + hash_forward2[child]) % mod2
            combined_hash2 = (combined_hash2 * base2 + ord(s[node])) % mod2
            hash_forward2[node] = combined_hash2
            
            combined_hash_r2 = ord(s[node])
            for child in reversed(children[node]):
                combined_hash_r2 = (combined_hash_r2 * base_pows2[length[child]] + hash_reverse2[child]) % mod2
            hash_reverse2[node] = combined_hash_r2
            
            # Calculate total length of subtree
            total_length = 1
            for child in children[node]:
                total_length += length[child]
            length[node] = total_length
            
            if node != 0:
                parent_node = parent[node]
                in_degree[parent_node] -= 1
                if in_degree[parent_node] == 0:
                    queue.append(parent_node)
        
        # Build the answer list based on whether the hash values match
        answer = []
        for i in range(n):
            if (hash_forward1[i] == hash_reverse1[i]) and (hash_forward2[i] == hash_reverse2[i]):
                answer.append(True)
            else:
                answer.append(False)
        
        return answer
",1427940467
sarthakdahiya7,sarthakdahiya7,306,3607,cpp,"class Solution { 
    public: 
    public: 
    int st1234(int ae1288){
        return ae1288;
    }
    int st1235(int ae1288){
        return ae1288;
    }
    int st1236(int ae1288){
        return ae1288;
    }
    int st1237(int ae1288){
        return ae1288;
    }
    int greatestProperDivisor(int x) { 
        if (x <= 1) return 0;  
        for (int i = 2; i <=sqrt(x); i++) { 
            if (x % i == 0) { 
                if (i < x) return i;          
                if (x / i < x) return x / i; 
            } 
        } 
        return 0;  
    } 
public: 
    int minOperations(vector<int>& nums) { 
      int n = nums.size(); 
        int operations = 0; 
 
        
        for (int i = n - 2; i >= 0; i--) { 
            
            if (nums[i] <= nums[i + 1]) continue; 
 
           
            int current = nums[i];   
            int next = nums[i + 1];  
 
          
            int local_operations = 0; 
         
                
                int divisor = greatestProperDivisor(current); 
                 
               
                if (divisor <= 1) return -1; 
                 
             
                local_operations++; 
      
 
            
            nums[i] = divisor; 
            if(nums[i]>next) 
            return -1; 
            operations += local_operations; 
        } 
 
        return operations;   
    } 
};",1427946998
lihaicoder,lihaicoder,307,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        # counters = [Counter(s[:i]) for i in range(n+1)]
        # ans = 0
        # for i in range(n+1):
        #     for j in range(i+1, n+1):
        #         ct = counters[j] - counters[i]
        #         if max(ct.values()) >= k:
        #             ans += 1
        # return ans
        
        ans = 0
        l = 0
        counter = Counter()
        lstart = n+1
        for r in range(n):
            counter[s[r]] += 1
            while max(counter.values()) >= k:
                lstart = min(lstart, l)
                counter[s[l]] -= 1
                l += 1
            if lstart != n + 1:
                ans += l - lstart 
        return ans
            ",1427836855
lihaicoder,lihaicoder,307,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        cur = []
        while len(cur) < len(target) or (len(cur) == len(target) and cur[-1] != target[-1]):
            if not cur or cur[-1] == target[len(cur)-1]:
                cur.append(""a"")
            else:
                cur[-1] = chr(ord(cur[-1]) + 1)
            ans.append("""".join(cur))
        return ans",1427825829
lihaicoder,lihaicoder,307,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        prime1 = 1000000007
        prime2 = 1000003679
        n = len(s)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        dfsstr = []
        endpoint = [None]*n
        startpoint = [None]*n
        def dfs(cur):
            startpoint[cur] = len(dfsstr)
            for child in children[cur]:
                dfs(child)
            dfsstr.append(s[cur])
            endpoint[cur] = len(dfsstr) - 1
        dfs(0)
        # for i in range(n):
            # print(i, """".join(dfsstr[startpoint[i]:endpoint[i]+1]), startpoint[i], endpoint[i])
        hashes1 = []
        hashes2 = []
        cur1 = 0
        cur2 = 0
        base = 26
        for i, c in enumerate(dfsstr):
            cur1 = (cur1 * base + (ord(c) - ord(""a""))) % prime1
            hashes1.append(cur1)
            cur2 = (cur2 * base + (ord(c) - ord(""a""))) % prime2
            hashes2.append(cur2)

        hashesrev1 = [None]*n
        hashesrev2 = [None]*n
        cur1 = 0
        cur2 = 0            
        for i in range(n-1, -1, -1):
            c = dfsstr[i]
            cur1 = (cur1 * base + (ord(c) - ord(""a""))) % prime1
            hashesrev1[i] = cur1
            cur2 = (cur2 * base + (ord(c) - ord(""a""))) % prime2
            hashesrev2[i] = cur2
        # print(dfsstr)
        # print(hashes1)
        # print(hashesrev1)
        prime1pow = []
        prime2pow = []
        pow1 = 1
        pow2 = 1
        for i in range(n+2):
            prime1pow.append(pow1)
            prime2pow.append(pow2)
            pow1 = (pow1 * base) % prime1
            pow2 = (pow2 * base) % prime2
        pow1 = prime1pow
        pow2 = prime2pow
        ans = []
        for i in range(n):
            start = startpoint[i]
            end = endpoint[i]
            # print("""".join(dfsstr[start:end+1]), ""start"", start, ""end"", end)
            forward1 = hashes1[end]
            forward2 = hashes2[end]
            if start - 1 >= 0:
                forward1 -= (hashes1[start - 1] * pow1[(end - start + 1)])
                forward1 %= prime1
                forward2 -= (hashes2[start - 1] * pow2[(end - start + 1)])
                forward2 %= prime2
            rev1 = hashesrev1[start]
            rev2 = hashesrev2[start]
            # print(""rev1"", rev1)
            if end + 1 <= n - 1:
                # print(""rev subtract"")
                rev1 -= (hashesrev1[end + 1] * pow1[(end - start + 1)])
                rev1 %= prime1
                rev2 -= (hashesrev2[end + 1] * pow2[(end - start + 1)])
                rev2 %= prime2
            # print("""".join(dfsstr[start:end+1]), forward1,  rev1, forward2, rev2)
            ans.append(forward1 == rev1 and forward2 == rev2)
        return ans
        
        ",1427922965
lihaicoder,lihaicoder,307,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def getprimes(upper = 2000):
            isprime = [True]*(upper+1)
            for i in range(2, upper+1):
                if isprime[i]:
                    j = 2
                    while i * j <= upper:
                        isprime[i*j] = False
                        j += 1
            return [i for i in range(2, upper+1) if isprime[i]]
        primes = getprimes()
        isprimes = set(primes)
        
        @cache
        def nxt(num):
            if num in isprimes:
                return -1
            for p in primes:
                if num % p == 0:
                    return p
            return -1
        
        ans = 0
        last = nums[-1] + 10
        while nums:
            cur = nums.pop()
            while cur > last:
                cand = nxt(cur)
                if cand == -1:
                    return -1
                cur = cand
                ans += 1
            last = cur
        return ans
                ",1427849445
Pankaj,PankajBhanwala,308,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int n = s.size();
        int result = 0;
        for(int i = 0; i < n; i++) {
            vector<int> count(26, 0);
            for(int j = i; j < n; j++) {
                count[s[j] - 'a']++;
                if(count[s[j] - 'a'] == k) {
                    result += n - j;
                    break;
                }
            }
        }
        return result;
    }
};",1427843083
Pankaj,PankajBhanwala,308,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        result.push_back(""a"");
        string curr = ""a"";
        int n = target.size();
        for(int i = 0; i < n;) {
            if(target[i] == curr.back()) {
                if(curr == target)
                    return result;
                curr += 'a';
                result.push_back(curr);
                i++;
            } else {
                curr.back() += 1;
                result.push_back(curr);
            }
        }
        return result;
    }
};",1427832605
Pankaj,PankajBhanwala,308,3603,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    const int BASE = 31;

    // Function to compute the prefix hashes and reverse prefix hashes
    void compute_hashes(const string &s, vector<long long> &prefix_hash, vector<long long> &reverse_hash, vector<long long> &power) {
        int n = s.size();

        for (int i = 1; i <= n; i++) {
            // Forward hash (prefix)
            prefix_hash[i] = (prefix_hash[i - 1] * BASE + (s[i - 1] - 'a' + 1)) % MOD;
            // Reverse hash
            reverse_hash[i] = (reverse_hash[i - 1] * BASE + (s[n - i] - 'a' + 1)) % MOD;
            // Precompute powers of the base
            power[i] = (power[i - 1] * BASE) % MOD;
        }
    }

    // Function to get the hash of a substring s[L:R] using prefix hash array
    long long get_hash(const vector<long long> &prefix_hash, const vector<long long> &power, int L, int R) {
        long long hash_value = (prefix_hash[R + 1] - (prefix_hash[L] * power[R - L + 1]) % MOD + MOD) % MOD;
        return hash_value;
    }

    // Main function to check if the substring s[L:R] is a palindrome
    bool is_palindrome(const string &s, const vector<long long> &prefix_hash, const vector<long long> &reverse_hash, const vector<long long> &power, int L, int R) {
        int n = s.size();
        // Forward hash for s[L:R]
        long long forward_hash = get_hash(prefix_hash, power, L, R);
        // Reverse hash for the corresponding substring (s[L:R] reverse)
        long long reverse_hash_value = get_hash(reverse_hash, power, n - R - 1, n - L - 1);

        return forward_hash == reverse_hash_value;
    }
    void dfs(int src, vector<vector<int>> &adjList, string &s, string &currString, vector<pair<int,int>> &idx) {
        idx[src].first = currString.size();
        currString += s[src];
        for(auto &nbr : adjList[src]) {
            dfs(nbr, adjList, s, currString, idx);
        }
        idx[src].second = currString.size() - 1;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adjList(n);
        for(int i = n - 1; i > 0; i--) {
            adjList[parent[i]].push_back(i);
        }
        vector<pair<int,int>> idx(n);
        string currString;
        dfs(0, adjList, s, currString, idx);
        vector<long long> prefix_hash(n + 1, 0), reverse_hash(n + 1, 0), power(n + 1, 1);
        compute_hashes(currString, prefix_hash, reverse_hash, power);
        vector<bool> result(n, false);
        // cout << is_palindrome(currString, prefix_hash, reverse_hash, power, 0, 5);
        for(int i = 0; i < n; i++) {
            
            result[i] = is_palindrome(currString, prefix_hash, reverse_hash, power, idx[i].first, idx[i].second);
            // cout << i <<  "": "" << endl;
        }
        
        return result;
    }
};",1427939423
Pankaj,PankajBhanwala,308,3607,cpp,"class Solution {
public:
    int findGPD(int num) {
        int ans = 1;
        for(int i = 2; i * i <= num; i++) {
            if(num % i == 0) {
                ans = max({i, ans, num / i});
            }
        }
        return ans;
    }
    int minOperations(vector<int>& nums) {
        int op = 0;
        int n = nums.size();
        int last = nums[n - 1];
        for(int i = n - 2; i >= 0; i--) {
            while(nums[i] > last) {
                int gpd = findGPD(nums[i]);
                if(gpd == 1)
                    return -1;
                op++;
                nums[i] /= gpd;
            }
            last = nums[i];
        }
        return op;
    }
};",1427861215
Abhinash Giri,abhinash_giri,310,3502,cpp,"
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            vector<int>freq(26);
            int mx = 0;
            for (int j = i; j <s.size() ; ++j) {
                freq[s[j]-'a']++;
                mx= max(mx,freq[s[j]-'a']);
                if(mx>=k)ans++;
            }
        }
        return ans;
    }
};

static const auto speedup = []() {
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;
}();",1427831414
Abhinash Giri,abhinash_giri,310,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string s;
        for (int i = 0; i <(int)target.size() ; ++i) {
            char x='a';
            while(x!=target[i]){
                s.push_back(x);
                ans.push_back(s);
                if(x=='z')x='a';
                else x++;
                s.pop_back();
            }
            s.push_back(x);
            ans.push_back(s);
        }
        return ans;
    }
};",1427827396
Abhinash Giri,abhinash_giri,310,3603,cpp,"class PalindromeChecker {
private:
    string S;         
    string T;         
    vector<int> P;

    void preprocess() {
        int N = S.size();
        T = ""#"";
        for (int i = 0; i < N; i++) {
            T += S[i];
            T += ""#"";
        }

        int M = T.size();
        P.resize(M);

        int center = 0, right = 0;
        for (int i = 0; i < M; i++) {
            int mirror = 2 * center - i; 

            if (i < right)
                P[i] = min(right - i, P[mirror]);
            else
                P[i] = 0;

            while (i - P[i] - 1 >= 0 && i + P[i] + 1 < M && T[i - P[i] - 1] == T[i + P[i] + 1])
                P[i]++;

            if (i + P[i] > right) {
                center = i;
                right = i + P[i];
            }
        }
    }

public:
    PalindromeChecker(const string& str) : S(str) {
        preprocess();
    }
    bool isPalindrome(int i, int j) {
        int left = 2 * i + 1;
        int right = 2 * j + 1;
        int c = (left + right) / 2;
        int r = (right - left) / 2;
        if (c < 0 || c >= T.size())
            return false;
        return P[c] >= r;
    }
};

class Solution {
public:
    void dfs(int node,int p,vector<vector<int>>&g,vector<int>&mn,vector<int>&tin,string&dfsStr,string& s,int& timer){
        for(auto &to:g[node]){
            if(to==p)continue;
            dfs(to,node,g,mn,tin,dfsStr,s,timer);
        }
        tin[node] = timer++;
        mn[node]  = tin[node];
        for(auto &to:g[node]){
            if(to==p)continue;
            mn[node] = min(mn[node], mn[to]);
        }
        dfsStr.push_back(s[node]);
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        int root = 0;
        vector<vector<int>>g(n);
        for (int i = 1; i < n; ++i) {
            int p = parent[i];
            g[p].push_back(i);
            g[i].push_back(p);
        }
        for (int i = 0; i < n; ++i) {
            sort(g[i].begin(),g[i].end());
        }
        vector<bool>ans(n,false);
        vector<int>tin(n);
        vector<int>mn(n);
        int timer = 0;
        string dfsStr;
        dfs(0,-1,g,mn,tin,dfsStr,s,timer);
        PalindromeChecker p(dfsStr);
        for (int i = 0; i < n; ++i) {
            ans[i] = p.isPalindrome(mn[i],tin[i]);
        }
        return ans;
    }
};

static const auto speedup = []() {
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;
}();",1427901093
Abhinash Giri,abhinash_giri,310,3607,cpp,"const int MAX_N = 1e6 + 5;
int min_prime_factor[MAX_N];
bool precompute = true;
class Solution {
public:
    void compute_min_prime_factors() {
        for (int i = 0; i < MAX_N; ++i) {
            min_prime_factor[i] = i;
        }
        min_prime_factor[0] = min_prime_factor[1] = 1;
        for (int i = 2; i * i < MAX_N; ++i) {
            if (min_prime_factor[i] == i) {
                for (int j = i * i; j < MAX_N; j += i) {
                    if (min_prime_factor[j] == j) {
                        min_prime_factor[j] = i;
                    }
                }
            }
        }
    }
    int minOperations(vector<int>& nums) {
        if(precompute){
            compute_min_prime_factors();
            precompute = false;
        }
        vector<int> a = nums;
        int n = (int)a.size();
        vector<int> min_possible(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 1) {
                min_possible[i] = 1;
            } else if (min_prime_factor[nums[i]] == nums[i]) {
                min_possible[i] = nums[i];
            } else {
                min_possible[i] = min_prime_factor[nums[i]];
            }
        }

        int ans = 0;
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                if (min_possible[i] > nums[i + 1]) {
                    return -1;
                } else {
                    ans+=(nums[i]!=min_possible[i]);
                    nums[i] = min_possible[i];
                }
            }
        }
        return ans;
    }
};



static const auto speedup = []() {
    std::ios::sync_with_stdio(false); std::cin.tie(nullptr); return 0;
}();",1427932135
Nitin Kumar,nitin12384,312,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for(int i=0; i<n; i++){
            // Find first j for freq > k
            vector<int> f(26);
            int mxf = 0;
            int j = i;
            while(j<n && mxf < k){
                f[ s[j] -'a' ]++;
                mxf = max(mxf, f[s[j] - 'a']);
                j++;
            }
            // [i...j-1]
            // [j-1...n-1] is the deal
            if(mxf == k) ans += (n-j+1);

        }

        return ans;
    }
};",1427831459
Nitin Kumar,nitin12384,312,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string before = """";
        for(char c : target){
            for(char cur = 'a'; cur<=c; cur++){
                res.push_back(before + cur);
            }

            before += c;
        }

        return res;
    }
};",1427824703
Nitin Kumar,nitin12384,312,3603,cpp,"typedef long long ll;
typedef pair<int, int> pii;


#ifndef ONLINE_JUDGE
    #define DEBUG(...) debug(#__VA_ARGS__, __VA_ARGS__)
    const int dm = 1;
#else 
    #define DEBUG(...) 
    const int dm = 0;
#endif

template<typename T, typename S> std::ostream& operator << (std::ostream &os, const std::pair<T, S> &p) {return os << ""("" << p.first << "", "" << p.second << "")"";}
template<typename C, typename T = std::decay<decltype(*std::begin(std::declval<C>()))>, typename std::enable_if<!std::is_same<C, std::string>::value>::type* = nullptr>
std::ostream& operator << (std::ostream &os, const C &c) {bool f = true; os << ""[""; 
for (const auto &x : c) {if (!f) os << "", ""; f = false; os << x;}return os << ""]"";}
template<typename T> void debug(std::string s, T x) {std::cout << """" << s << "" = "" << x << ""\n"";}
template<typename T, typename... Args> void debug(std::string s, T x, Args... args) 
{for (int i=0, b=0; i<(int)s.size(); i++) {if (s[i] == '(' || s[i] == '{') b++; else if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {
std::cout<< s.substr(0, i) << "" = "" << x << "" | "";debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}}

// Improve it
// add running hash, use mod[0], mod[1] 
// Allocate hash[] array on heap in Consthash
// 
namespace hashing{
    const ll mod1 = 1e9+7;
    const ll mod2 = 1e9+9;
    const int maxn = 1e5;
    const int p = 31;
    
    ll powp1[maxn+1];
    ll powp2[maxn+1];

    // requires mod ? overflow ?
    pair<ll, ll> gcd_extend(ll a, ll b){
        if(b==0){
            return make_pair(1,0);
        }
        else{
            ll q = a/b, r = a%b;
            pair<ll, ll> res = gcd_extend(b, r);
            return make_pair(res.second, res.first - q*res.second);
        }
    }

    // inverse should exist
    ll invmod(ll n, ll p){
        pair<ll, ll> res = gcd_extend(n,p);
        ll inv = res.first;
        if(inv < 0){
            inv += p;
        } 
        return inv;
    }
    
    // Hash (abc) = a*p^2 + b*p + c

    typedef long long ll;


    void calcpow(){
        powp1[0] = powp2[0] = 1;
        for(int i=1; i<=maxn; i++){
            powp1[i] = (powp1[i-1]*p) % mod1;
            powp2[i] = (powp2[i-1]*p) % mod2;
        }
    }

    int charval(char c){
        return (c - 'a') + 1 ;
    }

    pair<ll, ll> get_hash(const string&s){
        ll hash1 = 0, hash2 = 0;
        int n = s.size();
        for(int i=0; i<n; i++){
            hash1 = ( (hash1) * p + charval(s[i]) ) % mod1;
            hash2 = ( (hash2) * p + charval(s[i]) ) % mod2;
        }

        return make_pair(hash1, hash2);
    }

    // hash of h1 + h2 concatanated
    pair<ll, ll> merge_hash(const pair<ll,ll>& h1, int len1, 
                            const pair<ll,ll>& h2, int len2)
    {
        pair<ll, ll> res;
        res.first = (h2.first + h1.first*powp1[len2] ) % mod1;
        res.second = (h2.second + h1.second*powp2[len2]) % mod2;
        return res;
    }

    void add_end(char c, pair<ll, ll>& hash){
        hash.first = ((hash.first)*p + charval(c) ) % mod1;
        hash.second = ((hash.second)*p + charval(c) ) % mod2;
    }


}


typedef long long ll;
typedef pair<int, int> pii;


bool pcomp_done = false;
void pcomp(){
    if(pcomp_done) return;
    pcomp_done = true;

    hashing::calcpow();

}

struct strhash{
    pair<ll, ll> hash;
    int sz;
    strhash(){
        hash = {0,0};
        sz = 0;
    }
    void add_char_end(char c){
        hashing::add_end(c, hash);
        sz ++;
    }
    void add_hash_end(const strhash& h2){
        hash = hashing::merge_hash(hash, sz, h2.hash, h2.sz);
        sz += h2.sz;
    }

    bool same(const strhash& h2){
        return h2.sz == sz && (h2.hash == hash);
    }
};


class Solution {
    vector<bool> res;
    vector<vector<int>> childs;
    vector<int> sz;
public:

    pair<strhash, strhash> dfs(int v, const string& s){
        strhash h, revh;

        revh.add_char_end(s[v]);
        int nc = childs[v].size();
        vector<pair<strhash, strhash>> ch(nc);

        for(int i=0; i<nc; i++){
            ch[i] = dfs(childs[v][i], s);
        }

        // add to h in order
        for(int i=0; i<nc; i++){
            h.add_hash_end(ch[i].first);
        }
        for(int i=nc-1; i>=0; i--){
            revh.add_hash_end(ch[i].second);
        }
        

        h.add_char_end(s[v]);
        res[v] = h.same(revh);
        return {h, revh};
    }

    vector<bool> findAnswer(vector<int>& p, string s) {
        
        pcomp(); 

        int n = s.size();
        childs = vector<vector<int>>(n);
        sz = vector<int>(n);
        for(int i=1; i<n; i++){
            childs[ p[i] ].push_back(i);
        }

        //DEBUG(childs);
        res = vector<bool>(n);

        dfs(0, s);
        
        return res;
    }
};
",1427940851
Nitin Kumar,nitin12384,312,3607,cpp,"#ifndef ONLINE_JUDGE
    #define DEBUG(...) debug(#__VA_ARGS__, __VA_ARGS__)
    const int dm = 1;
#else 
    #define DEBUG(...) 
    const int dm = 0;
#endif

template<typename T, typename S> std::ostream& operator << (std::ostream &os, const std::pair<T, S> &p) {return os << ""("" << p.first << "", "" << p.second << "")"";}
template<typename C, typename T = std::decay<decltype(*std::begin(std::declval<C>()))>, typename std::enable_if<!std::is_same<C, std::string>::value>::type* = nullptr>
std::ostream& operator << (std::ostream &os, const C &c) {bool f = true; os << ""[""; 
for (const auto &x : c) {if (!f) os << "", ""; f = false; os << x;}return os << ""]"";}
template<typename T> void debug(std::string s, T x) {std::cout << """" << s << "" = "" << x << ""\n"";}
template<typename T, typename... Args> void debug(std::string s, T x, Args... args) 
{for (int i=0, b=0; i<(int)s.size(); i++) {if (s[i] == '(' || s[i] == '{') b++; else if (s[i] == ')' || s[i] == '}') b--; else if (s[i] == ',' && b == 0) {
std::cout<< s.substr(0, i) << "" = "" << x << "" | "";debug(s.substr(s.find_first_not_of(' ', i + 1)), args...); break;}}}


const int maxn = 1e6;
int spf[maxn+1];
bool done = false;
void pcomp(){
    if(done) return;
    if(!done){
        done = true;
    }
    memset(spf, -1, sizeof(spf));
    for(int p=2; p<=maxn; p++){
        if(spf[p]==-1) spf[p] = p;
        for(int val=p*2; val<=maxn; val+=p){
            if(spf[val] == -1){
                spf[val] = p;
            }
        }
    }

    spf[1] = 1;

    for(int v=0; v<=20; v++){
        // DEBUG(v, spf[v]);
    }
}


class Solution {
public:
    int minOperations(vector<int>& nums) {
        pcomp();

        int ans = 0;

        int n = nums.size();
        const int INF = (int)1e9;

        // After we are done iterating i
        // operations required to sort till [0..i]
        // with keeping i same, or changing it if possible.
        
        // initiailized for i=0 interated
        int oper_same = 0;
        int oper_less = (spf[nums[0]] != nums[0]);
        
        for(int i=1; i<n; i++){

            // Choose to reduce it
            int cur_org = nums[i];
            int cur_red = spf[nums[i]];
            int red_oper = (nums[i] != cur_red);

            int prev_org = nums[i-1];
            int prev_red = spf[nums[i-1]];

            int cur_oper_less = INF;


            if(prev_org <= cur_red){
                cur_oper_less = min(cur_oper_less, oper_same + red_oper);
            }

            if(prev_red <= cur_red){
                cur_oper_less = min(cur_oper_less, oper_less + red_oper);
            }


            int cur_oper_same = INF;
            if(prev_org <= cur_org){
                cur_oper_same = min(cur_oper_same, oper_same);
            }
            if(prev_red <= cur_org){
                cur_oper_same = min(cur_oper_same, oper_less);
            }

            //DEBUG(i, oper_same, oper_less);
            //DEBUG(cur_org, cur_red, prev_org, prev_red, cur_oper_same, cur_oper_less);


            oper_same = cur_oper_same;
            oper_less = cur_oper_less;

            if(cur_oper_same == INF && cur_oper_less == INF) break;

            

        }
        
        if(oper_same == INF && oper_less == INF) return -1;
        else return min(oper_same, oper_less);
    }
};",1427877142
Yuanbin Cheng,cybsbbbb,317,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        cnt = [0] * 26
        n = len(s)
        right = 0
        ans = 0
        for left in range(n):
            while right < n and max(cnt) < k:
                cnt[ord(s[right]) - ord('a')] += 1
                right += 1
            if max(cnt) >= k:
                ans += n + 1 - right
            cnt[ord(s[left]) - ord('a')] -= 1
        return ans
",1427836385
Yuanbin Cheng,cybsbbbb,317,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        n = len(target)
        ans = ['a']
        cur_str = ['a']
        cur_idx = 0
        while cur_str != target:
            if cur_str[cur_idx] == target[cur_idx]:
                cur_idx += 1
                cur_str.append('a')
                if len(cur_str) > n:
                    break
                ans.append(''.join(cur_str))
            else:
                pre = cur_str.pop()
                cur_str.append(chr(ord(pre) + 1))
                ans.append(''.join(cur_str))
        return ans

",1427829302
Yuanbin Cheng,cybsbbbb,317,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        tree = [[] for _ in range(n)]

        for cur, par in enumerate(parent):
            if par != -1:
                tree[par].append(cur)
        
        ans = [False] * n

        def dfs(cur):
            res = """"
            for nxt in tree[cur]:
                res += dfs(nxt)
            res += s[cur]
            if res[0] != res[-1] or (len(res) > 3 and res[1] != res[-2]):
                return res
            ans[cur] = (res == res[::-1])
            return res

        dfs(0)
        return ans


",1427909611
Yuanbin Cheng,cybsbbbb,317,3607,python3,"max_x = 10 ** 6
dp = [-1] * (max_x + 1)
for x in range(2, max_x + 1):
    for num in range(2, x + 1):
        if x * num > max_x:
            break
        dp[x * num] = num


class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        for i in range(n - 1)[::-1]:
            while nums[i] > nums[i + 1] and dp[nums[i]] != -1:
                nums[i] = dp[nums[i]]
                ans += 1
            if nums[i] > nums[i + 1]:
                return -1
        
        return ans",1427896402
Ajit,Ajit123,320,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<int> cnt(26);
        int ans = 0;
        int l = 0;
        auto good = [&]() -> bool {
            for(int i=0; i<26; i++) {
                if (cnt[i] >= k) {
                    return true;
                }
            }

            return false;
        };

        for(int i=0; i<n; i++) {
            cnt[s[i]-'a']++;
            while (good()) {
                cnt[s[l]-'a']--;
                l++;
            }
            ans += l;
        }

        return ans;
    }
};",1427825064
Ajit,Ajit123,320,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur = """";
        vector<string> ans;
        while (cur != target) {
            cur.push_back('a');
            int siz = cur.size();
            while (cur[siz-1] != target[siz-1]) {
                ans.push_back(cur);
                cur[siz-1]++;
            }
            ans.push_back(cur);
        }

        return ans;
    }
};",1427828228
Ajit,Ajit123,320,3603,cpp,"class Solution {
    int timer = 0;
    vector<int> tout;
    string order;
    vector<int> siz;
public:
    inline void dfs(int i, const vector<vector<int>>& g, const string& s) {
        siz[i] = 1;
    
        for(auto it: g[i]) {
            dfs(it, g, s);
            siz[i] += siz[it];
        }

        order.push_back(s[i]);
        tout[i] = timer++;
    }

    inline vector<int> manacher(string& s) {
        int n = s.size();
        vector<int> span(n);
        int center = 0;
        for(int i=1; i<n; i++) {
            if (i <= center + span[center]) {
                span[i] = min((center + span[center]) - i, span[center - (i - center)]);
            }

            int l = i - span[i], r = i + span[i];
            while (l-1 >= 0 && r+1 < n && s[l-1] == s[r+1]) {
                span[i]++;
                l--;
                r++;
            }

            if (center + span[center] < i + span[i]) {
                center = i;
            }
        }

        return span;
    }

    inline bool isPal(int l, int r, const vector<int>& span) {
        l = l * 2 + 1;
        r = r * 2 + 1;
        int mid = (l + r) >> 1;
        return span[mid] >= r - mid;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        timer = 0;
        tout.clear();
        siz.clear();
        tout = vector<int>(n);
        siz = vector<int>(n);
        order = """";
        
        vector<vector<int>> g(n);
        for(int i=1; i<n; i++) {
            g[parent[i]].push_back(i);
        } 

        dfs(0, g, s);
        string order1 = ""#"";
        for(auto it: order) {
            order1.push_back(it);
            order1.push_back('#');
        }

        vector<int> span = manacher(order1);
        vector<bool> ans(n);
        for(int i=0; i<n; i++) {
            int l = tout[i] - siz[i] + 1;
            int r = tout[i];
            ans[i] = isPal(l, r, span);
        }

        return ans;
    }
};",1427902142
Ajit,Ajit123,320,3607,cpp,"const int MAXN = 1e6 + 5;
int spf[MAXN+1];
class Solution {
public:
    void init() {
        spf[1] = 1;
        for(int i=2; i<=MAXN-3; i++) {
            if (!spf[i]) {
                spf[i] = i;
                for(int j=2*i; j<=MAXN-3; j+=i) {
                    if (!spf[j]) {
                        spf[j] = i;
                    }
                }
            }
        }
    }

    int minOperations(vector<int>& nums) {
        if (spf[1] != 1) {
            init();
        }

        int n = nums.size();
        int INF = 2 * n + 5;
        vector<vector<int>> dp(n, vector<int>(2, INF));
        dp[0][0] = 0, dp[0][1] = 1;

        for(int i=1; i<n; i++) {
            for(int j=0; j<2; j++) {
                int cur = (j == 0 ? nums[i]: spf[nums[i]]);
                if (cur >= nums[i-1]) {
                    dp[i][j] = min(dp[i][j], dp[i-1][0] + j);
                }

                if (cur >= spf[nums[i-1]]) {
                    dp[i][j] = min(dp[i][j], dp[i-1][1] + j);
                }
            }
        }

        if (dp[n-1][0] == INF && dp[n-1][1] == INF) {
            return -1;
        }

        return min(dp[n-1][0], dp[n-1][1]);
    }
};",1427846558
lozy219,lozy219,322,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26, 0);
        int b=-1;
        int res=0;
        for (int i=0; i<s.size(); ++i) {
            bool ok=false;
            if (i>0) {
                cnt[s[i-1]-'a']--;
            }
            if (i==0||i>0&&cnt[s[i-1]-'a']==k-1) {
                while (b<int(s.size())) {
                    b++;
                    if (b==s.size()) {
                        break;
                    }
                    cnt[s[b]-'a']++;
                    if (cnt[s[b]-'a']==k) {
                        ok=true;   
                        break;
                    }
                }
            } else {
                ok=true;
            }
            if (ok) {
                res+=s.size()-b;
            }
        }
        return res;
    }
};",1427848961
lozy219,lozy219,322,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s="""";
        vector<string> res;
        for (char c: target) {
            for (char x='a'; x<=c; ++x) {
                res.push_back(s+x);
            }
            s+=c;
        }
        return res;
    }
};",1427824198
lozy219,lozy219,322,3603,golang,"var st []int
var ed []int
var child [][]int

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func manacherOdd(s string) []int {
	n := len(s)
	s = ""$"" + s + ""^""
	p := make([]int, n+2)
	l, r := 1, 1
	for i := 1; i <= n; i++ {
		p[i] = max(0, min(r-i, p[l+(r-i)]))
		for s[i-p[i]] == s[i+p[i]] {
			p[i]++
		}
		if i+p[i] > r {
			l, r = i-p[i], i+p[i]
		}
	}
	return p[1 : len(p)-1]
}

func manacher(s string) []int {
	var t strings.Builder
	for _, c := range s {
		t.WriteRune('#')
		t.WriteRune(c)
	}
	t.WriteRune('#')
	res := manacherOdd(t.String())
	return res[1 : len(res)-1]
}

func dfs(s string, i int, start int, res *strings.Builder) string {
	st[i] = start
	for _, c := range child[i] {
		dfs(s, c, res.Len(), res)
	}
	res.WriteByte(s[i])
	ed[i] = res.Len() - 1
	return res.String()
}

func findAnswer(parent []int, s string) []bool {
	n := len(parent)
	st = make([]int, n)
	ed = make([]int, n)
	child = make([][]int, n)
	for i := 1; i < n; i++ {
		child[parent[i]] = append(child[parent[i]], i)
	}

	var res []bool
	var xxx strings.Builder
	dfs(s, 0, 0, &xxx)
	mana := manacher(xxx.String())

	for i := 0; i < n; i++ {
		ks := st[i] * 2
		ke := ed[i] * 2
		mid := (ks + ke) / 2
		if mana[mid]-1 >= ed[i]-st[i]+1 {
			res = append(res, true)
		} else {
			res = append(res, false)
		}
	}
	return res
}",1427935349
lozy219,lozy219,322,3607,cpp,"vector<int> dv;

class Solution {
public:
    void fill() {
        dv = vector<int>(1000005, 1);
        for (int x=4; x<=1000000; ++x) {
            if (x%2==0) {
                dv[x]=x/2;
                continue;
            }
            for (int i=3; i*i<=x; i+=2) {
                if (x%i==0) {
                    dv[x]=x/i;
                    break;
                }
            }
        }
    }
    int minOperations(vector<int>& nums) {
        if (dv.size()==0) {
            fill();
        }
        int res=0;
        for (int i=nums.size()-2; i>=0; --i) {
            if (nums[i]<=nums[i+1]) continue;
            while (nums[i]>nums[i+1]) {
                if (dv[nums[i]]==1) {
                    return -1;
                }
                nums[i]/=dv[nums[i]];
                res++;
            }
        }
        return res;
    }
};",1427861587
Nghia T Phan,phantrongnghia510,326,3502,python,"class Solution(object):
    def numberOfSubstrings(self, s, k):
        n, result = len(s), 0
        freq = [0] * 26
        l = 0
        max_freq = 0

        for r in range(n):
            ch = ord(s[r]) - ord('a')
            freq[ch] += 1

            if freq[ch] > max_freq:
                max_freq = freq[ch]

            while l <= r and max_freq >= k:
                result += (n - r)
                freq[ord(s[l]) - ord('a')] -= 1
                max_freq = max(freq)
                l += 1

        return result
",1427851902
Nghia T Phan,phantrongnghia510,326,3566,python,"class Solution(object):
    def stringSequence(self, target):
        res, curr = [], """"
        for c in target:
            curr += 'a'
            res.append(curr)

            for _ in range(ord(c) - ord('a')):
                last = curr[-1]
                curr = curr[:-1] + chr(ord(last) + 1)
                res.append(curr)
        return res
        ",1427829132
Nghia T Phan,phantrongnghia510,326,3603,python,"class Solution(object):
    def findAnswer(self, parent, s):
        tree = defaultdict(list)
        n, root = len(parent), -1

        for child in range(n):
            p = parent[child]
            if p == -1: root = child
            else:
                tree[p].append(child)
        
        for node in tree: tree[node].sort()

        traversal = []
        start, end = [0] * n, [0] * n
        stack = [(root, 0)]
        while stack:
            node, visited = stack.pop()
            if node is None: continue
            if visited: 
                traversal.append(s[node])
                end[node] = len(traversal) - 1
            else:
                stack.append((node, 1))
                for child in reversed(tree[node]):
                    stack.append((child, 0))
                start[node] = len(traversal)
        
        tot_s = """".join(traversal)
        rev_tot_s, length =  tot_s[::-1], len(tot_s)

        #rolling hash 
        base1, mod1 = 911, 10**9 + 7

        def hash(s, b, m):
            n = len(s)
            prefix, power = [0] * (n + 1), [1] * (n + 1)

            for i in range(n):
                prefix[i + 1] = (prefix[i] * b + ord(s[i])) % m
                power[i + 1] = (power[i] * b) % m
            return prefix, power
            
        def get_hash(prefix, power, l, r, mod):
            return (prefix[r] - prefix[l] * power[r - l]) % mod


        pref_hash1, pow1 = hash(tot_s, base1, mod1)
        rev_pref_hash1, rev_pow1 = hash(rev_tot_s, base1, mod1)

        ans = [False] * n
        for node in range(n):
            l, r = start[node], end[node] + 1
            hash1 = get_hash(pref_hash1, pow1, l, r, mod1)
            
            rev_l, rev_r = length - r, length - l
            rev_hash1 = get_hash(rev_pref_hash1, rev_pow1, rev_l, rev_r, mod1)

            if (hash1 == rev_hash1): 
                ans[node] = True
            else: 
                ans[node] = False
        
        return ans",1427952356
Nghia T Phan,phantrongnghia510,326,3607,python,"class Solution(object):
    def minOperations(self, nums):
        def greatest_div(x):
            if x <= 1: return 0

            for i in range(2, int(x ** 0.5) + 1):
                if x % i == 0: return x // i
            return 1
        
        res = 0
        n = len(nums)
        for i in range(n - 2, -1, -1):
            while nums[i] > nums[i + 1]:
                gd = greatest_div(nums[i])
                if gd <= 1: return -1

                nums[i] = nums[i] // gd
                res += 1
                
        return res

        ",1427864672
yaominzh,yaominzh,327,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        total_substrings = n * (n + 1) // 2
        total_valid_substrings = 0
        counts = [0] * 26
        left = 0

        for right in range(n):
            idx_right = ord(s[right]) - ord('a')
            counts[idx_right] += 1

            while counts[idx_right] >= k:
                idx_left = ord(s[left]) - ord('a')
                counts[idx_left] -= 1
                left += 1

            total_valid_substrings += right - left + 1

        result = total_substrings - total_valid_substrings
        return result
",1427839642
yaominzh,yaominzh,327,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = []

        current_string = """"

        for i in range(len(target)):
            target_char = target[i]

            if len(current_string) <= i:
                current_string += 'a'
                result.append(current_string)

            while current_string[-1] != target_char:
                current_string = current_string[:-1] + chr(((ord(current_string[-1]) - ord('a') + 1) % 26) + ord('a'))
                result.append(current_string)

        return result
",1427826104
yaominzh,yaominzh,327,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def main():
            n = len(parent)
            sys.setrecursionlimit(1 << 25)
            children = [[] for _ in range(n)]
            for i in range(1, n):
                children[parent[i]].append(i)
            dfsOrder = []
            start = [0] * n
            end = [0] * n

            def dfs(node):
                start[node] = len(dfsOrder)
                for child in sorted(children[node]):
                    dfs(child)
                dfsOrder.append(s[node])
                end[node] = len(dfsOrder) - 1

            dfs(0)
            # Precompute powers and hashes
            mod1 = 10 ** 9 + 7
            mod2 = 10 ** 9 + 9
            P1 = 911
            P2 = 1597
            n = len(dfsOrder)
            P_pow1 = [1] * (n + 1)
            P_pow2 = [1] * (n + 1)
            for i in range(1, n + 1):
                P_pow1[i] = (P_pow1[i - 1] * P1) % mod1
                P_pow2[i] = (P_pow2[i - 1] * P2) % mod2

            prefixHash1 = [0] * (n + 1)
            prefixHash2 = [0] * (n + 1)
            for i in range(n):
                prefixHash1[i + 1] = (prefixHash1[i] * P1 + ord(dfsOrder[i])) % mod1
                prefixHash2[i + 1] = (prefixHash2[i] * P2 + ord(dfsOrder[i])) % mod2

            reversed_dfsOrder = dfsOrder[::-1]
            reversePrefixHash1 = [0] * (n + 1)
            reversePrefixHash2 = [0] * (n + 1)
            for i in range(n):
                reversePrefixHash1[i + 1] = (reversePrefixHash1[i] * P1 + ord(reversed_dfsOrder[i])) % mod1
                reversePrefixHash2[i + 1] = (reversePrefixHash2[i] * P2 + ord(reversed_dfsOrder[i])) % mod2

            answer = [False] * n

            for i in range(n):
                l = start[i]
                r = end[i]
                len_sub = r - l + 1
                # Hash of dfsOrder[l..r]
                hash_lr1 = (prefixHash1[r + 1] - prefixHash1[l] * P_pow1[len_sub]) % mod1
                hash_lr2 = (prefixHash2[r + 1] - prefixHash2[l] * P_pow2[len_sub]) % mod2
                if hash_lr1 < 0:
                    hash_lr1 += mod1
                if hash_lr2 < 0:
                    hash_lr2 += mod2
                # Hash of reversed substring
                reverse_l = n - 1 - r
                reverse_r = n - 1 - l
                hash_rev1 = (reversePrefixHash1[reverse_r + 1] - reversePrefixHash1[reverse_l] * P_pow1[len_sub]) % mod1
                hash_rev2 = (reversePrefixHash2[reverse_r + 1] - reversePrefixHash2[reverse_l] * P_pow2[len_sub]) % mod2
                if hash_rev1 < 0:
                    hash_rev1 += mod1
                if hash_rev2 < 0:
                    hash_rev2 += mod2
                if hash_lr1 == hash_rev1 and hash_lr2 == hash_rev2:
                    answer[i] = True
                else:
                    answer[i] = False
            return answer

        return main()
",1427894762
yaominzh,yaominzh,327,3607,java,"import java.util.*;

class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int maxNum = 0;
        for (int num : nums) {
            if (num > maxNum) maxNum = num;
        }

        // Generate all primes up to sqrt(maxNum)
        int limit = (int)Math.sqrt(maxNum) + 1;
        List<Integer> primes = sievePrimesUpTo(limit);
        Map<Integer, Integer> spfCache = new HashMap<>();

        int INF = Integer.MAX_VALUE / 2; // To prevent overflow

        // Initialize last operations and values for not reduced and reduced states
        int last0Ops = 0, last1Ops = INF;
        int last0Val = nums[0];
        int last1Val = INF;
        int s = smallestPrimeFactor(nums[0], primes, spfCache);
        if (s < nums[0]) {
            last1Ops = 1;
            last1Val = s;
        }

        for (int i = 1; i < n; i++) {
            int current0Ops = INF, current1Ops = INF;
            int current0Val = nums[i];
            int sCurrent = smallestPrimeFactor(nums[i], primes, spfCache);
            int current1Val = (sCurrent < nums[i]) ? sCurrent : INF;

            // Option 0: Keep nums[i] as-is
            if (last0Ops < INF && last0Val <= current0Val) {
                current0Ops = last0Ops;
            }
            if (last1Ops < INF && last1Val <= current0Val) {
                current0Ops = Math.min(current0Ops, last1Ops);
            }

            // Option 1: Reduce nums[i] to its smallest prime factor
            if (current1Val != INF) {
                int opsNeeded = INF;
                if (last0Ops < INF && last0Val <= current1Val) {
                    opsNeeded = last0Ops + 1;
                }
                if (last1Ops < INF && last1Val <= current1Val) {
                    opsNeeded = Math.min(opsNeeded, last1Ops + 1);
                }
                current1Ops = opsNeeded;
            }

            if (current0Ops == INF && current1Ops == INF) {
                return -1; // Impossible to make the array non-decreasing
            }

            // Update last operations and values for the next iteration
            last0Ops = current0Ops;
            last0Val = current0Val;
            last1Ops = current1Ops;
            last1Val = current1Val;
        }

        int minOps = Math.min(last0Ops, last1Ops);
        return minOps >= INF ? -1 : minOps;
    }

    private List<Integer> sievePrimesUpTo(int n) {
        boolean[] isComposite = new boolean[n + 1];
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (!isComposite[i]) {
                primes.add(i);
                for (int j = i + i; j <= n; j += i) {
                    isComposite[j] = true;
                }
            }
        }
        return primes;
    }

    private int smallestPrimeFactor(int x, List<Integer> primes, Map<Integer, Integer> spfCache) {
        if (spfCache.containsKey(x)) {
            return spfCache.get(x);
        }
        for (int p : primes) {
            if (p * p > x) break;
            if (x % p == 0) {
                spfCache.put(x, p);
                return p;
            }
        }
        spfCache.put(x, x); // x is prime
        return x;
    }
}
",1427871184
Balakrishnan Varadarajan,balakrishnan_v,328,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        int ans=0;
        for(int i=0;i<n;i++) {
            vector<int> counts(26, 0);
            for(int j=i;j<n;j++) {
                counts[s[j]-'a']++;
                if (counts[s[j]-'a']>=k) {
                    ans += n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427905247
Balakrishnan Varadarajan,balakrishnan_v,328,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string ans="""";
        vector<string> ret;
        while(ans != target) {
            ans.push_back('a');
            ret.push_back(ans);
            int i=ans.size()-1;
            while(ans[i]!=target[i]) {
                ans[i]++;
                ret.push_back(ans);
            }
        }
        return ret;
    }
};",1427908174
Balakrishnan Varadarajan,balakrishnan_v,328,3603,cpp,"#define MAXN 100000
#define NUMCHARS 26
#define MODD 1000000000039ll
#define ll __int128
class Solution {
public:
    vector<int> E[MAXN+2];
    
    void dfs(int u, const string& s, string& curr_str, vector<pair<int,int>>& start_end_ids) {
        
        int start_id=curr_str.size();
        for(int v : E[u]) {
            // printf(""%d to %d\n"",u,v);
            dfs(v, s, curr_str, start_end_ids);
        }
        curr_str.push_back(s[u]);
        start_end_ids[u]={start_id, curr_str.size()-1};
    }
    
    vector<ll> GetHash(const string& s, ll multiplier) {
        int n=s.size();
        vector<ll> ret(n);
        ll H = 0;
        ll pw = 1;
        for(int i=0;i<n;i++) {
            H += pw * (s[i]-'a')%MODD;
            H %= MODD;
            pw = (pw*multiplier)%MODD;
            ret[i]=H;
        }
        return ret;
    }
    
    
    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }
    
    ll GetHashVal(const vector<ll>& cumul_hash, int st, int en) {
        ll ret = cumul_hash[en]-(st?cumul_hash[st-1]:0);
        if (ret < 0) ret += MODD;
        return ret;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        for(int i=1;i<n;i++) {
            E[parent[i]].push_back(i);
        }
        for(int i=0;i<n;i++) {
            sort(E[i].begin(),E[i].end());
        }
        string dfs_string;
        vector<pair<int,int>> start_end_ids(n);
        dfs(0, s, dfs_string, start_end_ids);
        
        
        ll NUMCHARS_INV = modpow(NUMCHARS, MODD-2);

        vector<ll> fhash = GetHash(dfs_string,NUMCHARS);
        vector<ll> bhash = GetHash(dfs_string, NUMCHARS_INV);
        
        vector<ll> P1(n+1),P2(n+1);
        P1[0]=P2[0]=1;
        for(int i=1;i<=n;i++) {
            P1[i]=P1[i-1]*NUMCHARS%MODD;
            P2[i]=P2[i-1]*NUMCHARS_INV%MODD;
        }
        
        
        vector<bool> ret;
        for(int u=0;u<n;u++) {
            int st=start_end_ids[u].first;
            int en=start_end_ids[u].second;
            
            ll H1 = GetHashVal(fhash, st, en);
            ll H2 = GetHashVal(bhash, st, en);
            
            H1 = H1 * P2[st]%MODD;
            H2 = H2 * P1[en]%MODD;
            ret.push_back(H1==H2);
        }
        return ret;
    }
};",1427861877
Balakrishnan Varadarajan,balakrishnan_v,328,3607,cpp,"#define MAXP 1200
#define INF (1<<30)
class Solution {
public:
    
    vector<int> primes;
    bool isprime[MAXP+2];
    
    int GetGPD(int x) {
        if (x==1) return 1;
        if (x <= MAXP && isprime[x]) return 1;
        for(int p : primes) {
            if (x==p) return 1;
            if (x%p==0) return x/p;
        }
        return 1;
    }
    
    
    int minOperations(vector<int>& nums) {
        
        for(int p=2;p<=MAXP;p++) isprime[p]=true;
        for(int p=2;p<=MAXP;p++) {
            if (isprime[p]) primes.push_back(p);
            for(int q=p*2;q<=MAXP;q+=p) {
                isprime[q]=false;
            }
        }
        
        int n=nums.size();
        reverse(nums.begin(),nums.end());
        int prev = INF;
        int ans=0;
        for(int x : nums) {
            while(x > prev) {
                int gpd = GetGPD(x);
                if (gpd==1) break;
                x /= gpd;
                ans++;
            }
            if (x > prev) return -1;
            prev = x;
        }
        return ans;
        
    }
};",1427920428
Mohit Kumar Kumawat,mohit__369,329,3502,cpp,"#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <string>
#include <vector>

using namespace __gnu_pbds;
using namespace std;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        typedef tree<pair<int, char>, null_type, less<pair<int, char>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
        int n = s.size();
        int result = 0;

        vector<int> freq(256, 0);
        ordered_set pbds;

        int left = 0;
        for (int right = 0; right < n; right++) {
            if (freq[s[right]] > 0) {
                pbds.erase({freq[s[right]], s[right]});
            }
            freq[s[right]]++;
            pbds.insert({freq[s[right]], s[right]});

            while (!pbds.empty() && (*pbds.rbegin()).first >= k) {
                result += n - right;
                pbds.erase({freq[s[left]], s[left]});
                freq[s[left]]--;
                if (freq[s[left]] > 0) {
                    pbds.insert({freq[s[left]], s[left]});
                }
                left++;
            }
        }
        return result;
    }
};
",1427830310
Mohit Kumar Kumawat,mohit__369,329,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for(auto &x : target)
        {
            for(char a = 'a'; a <= x; a++)
            {
                ans.push_back(s + a);
            }
            s += x;
        }
        return ans;
    }
};",1427824552
Mohit Kumar Kumawat,mohit__369,329,3603,cpp,"#include <iostream>
#include <vector>
#include <string>
using namespace std;


const int MOD = 1e9 + 7;
const int BASE = 31;

class Solution {
public:


    long long mod_pow(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1)
                result = (result * base) % mod;
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    vector<bool> check_palindromes(const string &s, const vector<pair<int, int>> &queries) {
        int n = s.size();
        vector<long long> hash_forward(n + 1, 0), hash_backward(n + 1, 0), power(n + 1, 1);

        for (int i = 1; i <= n; i++) power[i] = (power[i - 1] * BASE) % MOD;

        for (int i = 1; i <= n; i++) hash_forward[i] = (hash_forward[i - 1] * BASE + (s[i - 1] - 'a' + 1)) % MOD;

        for (int i = 1; i <= n; i++) hash_backward[i] = (hash_backward[i - 1] * BASE + (s[n - i] - 'a' + 1)) % MOD;

        auto get_forward_hash = [&](int L, int R) -> long long {
            long long hash_value = (hash_forward[R + 1] - hash_forward[L] * power[R - L + 1] % MOD + MOD) % MOD;
            return hash_value;
        };

        auto get_backward_hash = [&](int L, int R) -> long long {
            long long hash_value = (hash_backward[n - L] - hash_backward[n - R - 1] * power[R - L + 1] % MOD + MOD) % MOD;
            return hash_value;
        };

        vector<bool> result;

        for (const auto &q : queries) {
            int L = q.first, R = q.second;
            if (get_forward_hash(L, R) == get_backward_hash(L, R))
                result.push_back(true);
            else
                result.push_back(false);
        }

        return result;
    }


    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> children(n);
        vector<int> startPos(n), endPos(n);
        string dfsStr;

        for (int i = 1; i < n; ++i)
            children[parent[i]].push_back(i);

        auto isPalindrome = [](const string& str, int l, int r) -> bool {
            while (l < r) {
                if (str[l] != str[r]) return false;
                l++;
                r--;
            }
            return true;
        };

        function<void(int)> dfs = [&](int x) {
            startPos[x] = dfsStr.size();  

            for (int y : children[x]) dfs(y);

            dfsStr += s[x];           

            endPos[x] = dfsStr.size() - 1;
        };

        dfs(0);
        vector<pair<int, int>> q;
        for (int i = 0; i < n; ++i)
            q.push_back({startPos[i], endPos[i]});
        vector<bool> answer = check_palindromes(dfsStr, q);
        return answer;
    }
};",1427936892
Mohit Kumar Kumawat,mohit__369,329,3607,cpp,"
    
const int MAXN = 1000001;
vector<int> smallest_divisor(MAXN, 0);


class Solution {

public:
        void pre() {
            for (int i = 2; i < MAXN; i++) 
                if (smallest_divisor[i] == 0) 
                    for (int j = i; j < MAXN; j += i) 
                        if (smallest_divisor[j] == 0) 
                            smallest_divisor[j] = i;
        }

        int op(int num) {
            if (num < 2) return -1;
            int smallest_div = smallest_divisor[num];

            if (smallest_div == num)
                return -1;
            else
                return smallest_div;
        }     
    
        int minOperations(vector<int>& nums) {
            pre();
            int cnt = 0;
            int n = nums.size();
            for(int i = n - 2; i >= 0; i--)
            {
                while(nums[i] > nums[i+1])
                {
                    int x = op(nums[i]);
                    if(x == -1) return -1;
                    nums[i] = x;
                    cnt++;
                }
            }
            return cnt;
        }
    };",1427847410
VILLANOVA_ECON,VILLANOVA_ECON,330,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        dp = [0]*26
        ans = 0
        j = 0
        for i in range(len(s)):
            dp[ord(s[i])-ord('a')] += 1
            while max([x for i,x in enumerate(dp) if i != (ord(s[j])-ord('a'))]) >= k or (dp[ord(s[j])-ord('a')]-1) >= k:
                dp[ord(s[j])-ord('a')] -= 1
                j += 1
            if max(dp) >= k:
                ans += j+1
        return ans
            ",1427833039
VILLANOVA_ECON,VILLANOVA_ECON,330,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        
        ans = []
        curr = []
        for i in range(len(target)):
            for char in range(97,ord(target[i])-ord('a') +98):
                curr.append(chr(char))
                ans.append("""".join(curr))
                curr.pop()
            curr.append(target[i])
        return ans",1427825309
VILLANOVA_ECON,VILLANOVA_ECON,330,3603,python3,"Z = 10**5 + 10

def compute_prefix(prime,d):
    prefix = [1]
    for i in range(Z+1):
        prefix.append((prefix[-1]*d)%prime)
    return prefix
        
mod = 10**9 + 7
d = 111

mod1 = 10**9 + 9
d1 = 113

prefix = compute_prefix(mod,d)
iprefix = [pow(x,mod-2,mod) for x in prefix]

prefix1 = compute_prefix(mod1,d1)
iprefix1 = [pow(x,mod1-2,mod1) for x in prefix1]



class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        N = len(s)
        graph = collections.defaultdict(list)
        
        for i,x in enumerate(parent):
            if x != -1:
                graph[x].append((s[i],i))
                
        for key in graph.keys():
            graph[key].sort(key=lambda x:x[1])
        
        
        
        def recur_fn(node,curr):
            for char,child in graph[node]:
                recur_fn(child,curr)
            curr.append([s[node],node])
            
            
        dp = collections.defaultdict(int)
        def num_children(node):
            res = 1
            for char,child in graph[node]:
                res += num_children(child)
            dp[node] = res
            return res
        num_children(0)
        #print('dp',dp)
        
        
        res = []
        recur_fn(0,res)
        
        
        mapper = {}
        for j,(char,i) in enumerate(res):
            mapper[i] = j
        
        new_res = [char for char,i in res]
        
        
        
        def compute_hash(target,prime,d,prefix):
            arr = [0]
            hash_value = 0
            for i,char in enumerate(target):
                hash_value += (prefix[i]*ord(char))
                hash_value %= prime
                arr.append(hash_value)
            return arr
        #print(new_res)
        hash_forward = compute_hash(new_res,mod,d,prefix)
        #print('dp',dp)
        hash_backward = compute_hash(new_res[::-1],mod,d,prefix)
        
        hash_forward1 = compute_hash(new_res,mod1,d1,prefix1)
        hash_backward1 = compute_hash(new_res[::-1],mod1,d1,prefix1)
        
        ans = [False]*N
        #print(hash_backward)
        #print('hash_forward',hash_forward)
        #print('hash_backward',hash_backward)
        #print('prefix',prefix)
        for key,index in mapper.items():
            str_length = dp[key]
            index += 1
            #print('key',key,'str_length',str_length)
            L = index-str_length
            R = index
            if ((hash_forward[R]-hash_forward[L])*iprefix[L])%mod == ((hash_backward[len(new_res)-L]-hash_backward[len(new_res)-R])*iprefix[len(new_res)-R])%mod:
                if ((hash_forward1[R]-hash_forward1[L])*iprefix1[L])%mod1 == ((hash_backward1[len(new_res)-L]-hash_backward1[len(new_res)-R])*iprefix1[len(new_res)-R])%mod1:
                    ans[key] = True
        return ans
            
        
        
            
                
                
            
            
        
        
        
            
        
        ",1427945132
VILLANOVA_ECON,VILLANOVA_ECON,330,3607,python3,"MAXN = 10**6 + 10

dp = [1]*(MAXN+1)

for i in range(1,len(dp)):
    curr = 2*i
    while curr < len(dp):
        dp[curr] = i
        curr += i
        
#print(dp[:15])


class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)-2,-1,-1):
            curr = nums[i]
            while curr > nums[i+1]:
                if dp[curr] == 1:
                    return -1
                curr = curr//dp[curr]
                ans += 1
            nums[i] = curr
        return ans
                ",1427842373
Rohitaas Beri,rohitaas_beri,331,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int freq[26];
        memset(freq, 0, sizeof(freq));

        int n = s.size(), ans = 0;
        for (int i = 0; i < n; i++) {
            bool prev = false;
            for (int j = i; j < n; j++) {
                freq[s[j] - 'a']++;
                if ((freq[s[j] - 'a'] >= k) || prev) {
                    prev = true;
                    ans++;
                }
            }
            memset(freq, 0, sizeof(freq));
        }
        return ans;
    }
};",1427834963
Rohitaas Beri,rohitaas_beri,331,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        string temp;
        vector<string> ans;
        for (int i = 0; i < n; i++) {
            char cur = target[i];
            temp += 'a';
            ans.push_back(temp);
            while (temp.back() != cur) {
                temp[temp.size() - 1] =
                    (temp[temp.size() - 1] - 'a' + 1) % 26 + 'a';
                ans.push_back(temp);
            }
        }
        return ans;
    }
};",1427829589
Rohitaas Beri,rohitaas_beri,331,3603,cpp,"// Function to preprocess the string by adding separators
string preprocessString(const string& s) {
    string transformed =
        ""@#""; // Starting with special characters to handle boundaries
    for (char c : s) {
        transformed += c;
        transformed += '#';
    }
    transformed += '$'; // Ending with special characters
    return transformed;
}

// Function to preprocess using Manacher's Algorithm
vector<int> manacher(const string& s) {
    string t = preprocessString(s);
    int n = t.length();
    vector<int> p(n, 0); // p[i] will store the radius of the longest palindrome
                         // centered at i
    int center = 0, right = 0;

    for (int i = 1; i < n - 1; ++i) {
        int mirror = 2 * center - i;
        if (i < right) {
            p[i] = min(right - i, p[mirror]);
        }

        // Try to expand the palindrome centered at i
        while (t[i + p[i] + 1] == t[i - p[i] - 1]) {
            p[i]++;
        }

        // Update the center and right boundary
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }
    return p;
}

// Function to check if substring s[i..j] is a palindrome
bool isPalindrome(const string& s, const vector<int>& p, int i, int j) {
    int n = s.length();
    int transformed_i =
        2 * i + 2; // Corresponding index in the transformed string
    int transformed_j = 2 * j + 2;
    int center = (transformed_i + transformed_j) / 2;
    int length = j - i + 1;

    // Check if the palindrome radius at center covers the substring from i to j
    return p[center] >= length;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n + 1);
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) {
                adj[parent[i]].push_back(i);
            }
        }
        for (auto& i : adj) {
            sort(i.begin(), i.end());
        }

        string postOrder;
        int tin[n + 1], tout[n + 1];
        int tme = 0;
        function<void(int, int)> dfs = [&](int node, int par) {
            tin[node] = tme;

            for (auto i : adj[node]) {
                if (i != par) {
                    dfs(i, node);
                }
            }
            tout[node] = tme++;
            postOrder.push_back(s[node]);
        };
        dfs(0, -1);

        vector<int> p = manacher(postOrder);
        // auto mans = findPalindromeSubstrings(postOrder);
        // map<pair<int, int>, int> mp;
        // for (auto i : mans) {
        //     mp[i]++;
        // }

        vector<bool> ans;
        for (int i = 0; i < n; i++) {
            int start = tin[i], end = tout[i];
            ans.push_back(isPalindrome(postOrder, p, start, end));
        }
        return ans;
    }
};",1427945143
Rohitaas Beri,rohitaas_beri,331,3607,cpp,"int cnt = 0;
const int N = 1e6 + 2;
int spf[N];
int gpd[N];
class Solution {
public:
    int minOperations(vector<int>& nums) {

        if (!cnt) {
            memset(spf, 0, sizeof(spf));
            spf[1] = 1;
            for (int i = 2; i < N; i++) {
                for (int j = 2 * i; j < N && !spf[i]; j += i) {
                    if (!spf[j]) {
                        spf[j] = i;
                    }
                }
                if (!spf[i]) {
                    spf[i] = i;
                }
            }

            gpd[1] = 1;
            for (int i = 2; i < N; i++) {
                gpd[i] = i / spf[i];
            }
            cnt++;
        }

        int prev = 0;
        int n = nums.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            int temp = nums[i];
            while (temp > nums[i + 1] && gpd[temp] != 1) {
                temp /= gpd[temp];
                ans++;
            }
            if (temp > nums[i + 1]) {
                return -1;
            }
            nums[i] = temp;
        }
        return ans;
    }
};",1427853210
thienan175,thienan175,332,3502,golang,"func numberOfSubstrings(s string, k int) int {
    n := len(s)
    prefix := buildPrefix(s)
    counter := 0

    // fmt.Println(prefix)

    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            match := false
            for c := 0; c < 26; c++ {
                numChar := getNumChar(prefix, i, j, c)
                if numChar >= k {
                    match = true
                    break
                }
            }
            if match {
                counter += 1
            }
        }
    }

    return counter
}

func buildPrefix(s string) [][]int {
    p := make([][]int, len(s))

    for i := range s {
        p[i] = make([]int, 26)
        cIdx := int(s[i] - 'a')

        p[i][cIdx] = 1
        if i == 0 { 
            continue
        }

        for c := 0; c < 26; c++ {
            p[i][c] += p[i-1][c]
        }
    }
    return p
}

func getNumChar(p [][]int, from, to, cIdx int) int {
    if from == 0 {
        return p[to][cIdx]
    }
    return p[to][cIdx] - p[from-1][cIdx]
}",1427849321
thienan175,thienan175,332,3566,golang,"func stringSequence(target string) []string {
    w := []byte{'a'}
    out := []string{string(w)}

    for string(w) != target {
        idx := len(w) - 1
        if w[idx] == target[idx] {
            w = append(w, byte('a'))
            out = append(out, string(w))
        } else {
            cIdx := (int(w[idx] - 'a') + 1) % 26
            w[idx] = byte(cIdx + 'a')
            out = append(out, string(w))
        }
    }

    return out
}",1427829746
thienan175,thienan175,332,3603,golang,"const (
    base = 29
    mod = 1000000007
)

func findAnswer(parent []int, s string) []bool {
    childrenOf := make([][]int, len(s))
    for c, p := range parent {
        if p != -1 {
            childrenOf[p] = append(childrenOf[p], c)
        }
    }

    for i := range childrenOf {
        sort.Ints(childrenOf[i])
    }

    answer := make([]bool, len(s))

    var dfs func(node int) (int, int, int)
    dfs = func(node int) (int, int, int) {
        forward, reverse, power := 0, 0, 1
        for _, child := range childrenOf[node] {
            cf, cr, cp := dfs(child)
            forward = (forward*cp + cf) % mod
            reverse = (reverse + cr*power) % mod
            power = (power*cp) % mod
        }

        cIdx := int(s[node] - 'a')
        forward = (forward*base + cIdx) % mod
        reverse = (reverse + cIdx*power) % mod
        power = (power*base) % mod

        if forward == reverse {
            answer[node] = true
        }

        return forward, reverse, power
    }

    dfs(0)
    return answer
}",1427953145
thienan175,thienan175,332,3607,golang,"func minOperations(nums []int) int {
    n := len(nums)
    counter := 0

    for i := n-1; i >= 0; i-- {
        if i == n-1 || nums[i] <= nums[i+1] {
            continue
        }

        divisor := findGreatestDivisor(nums[i])
        if divisor == nums[i] || nums[i] / divisor > nums[i+1] {
            return -1
        }

        nums[i] /= divisor 
        counter += 1
    }

    return counter
}

func findGreatestDivisor(num int) int {
    for i := 2; i <= num / 2; i++ {
        if num % i == 0 {
            return num / i
        }
    }
    return num
}",1427867043
wisdompeak,wisdompeak,333,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) 
    {
        int n = s.size();
        int j = 0;
        unordered_map<char,int>count;
        int flag = 0;
        int ret = 0;
        for (int i=0; i<n; i++)
        {
            while (j<n && flag==0)
            {
                count[s[j]]++;
                if (count[s[j]]==k)
                    flag++;                
                j++;
            }
            if (flag==1)
                ret += (n-1)-(j-1)+1;
            
            count[s[i]]--;
            if (count[s[i]]==k-1)
                flag--;
        }
        
        return ret;        
    }
};",1427832789
wisdompeak,wisdompeak,333,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) 
    {
        vector<string>rets;
        string s;
        while (s!=target)
        {
            if (s=="""" || target.find(s)==0)
            {
                s.push_back('a');
                rets.push_back(s);
            }
            else
            {
                char ch = s.back();
                s.back() = (ch+1);
                rets.push_back(s);
            }
        }
        return rets;
        
    }
};",1427825901
wisdompeak,wisdompeak,333,3603,cpp,"using ll = long long;
const int MOD = 1e9 + 7;
const int BASE = 31;

class Solution {
    vector<ll> power;
    vector<ll> computeHash(const string& s) 
    {
        int n = s.size();
        vector<ll> hash(n + 1, 0);
        for (int i = 0; i < n; ++i) 
        {
            hash[i + 1] = (hash[i] * BASE + (s[i] - 'a' + 1)) % MOD;
        }
        return hash;
    }

    ll getHash(const vector<ll>& hash, int l, int r) 
    {
        ll h = (hash[r + 1] - hash[l] * power[r - l + 1] % MOD + MOD) % MOD;
        return h;
    }
    
    void dfs(int cur, vector<vector<int>>&next)
    {
        for (int nxt: next[cur])
            dfs(nxt, next);
        nums.push_back(cur);
    }
    int dfs2(int cur, vector<vector<int>>&next)
    {
        int sum = 1;
        for (int nxt: next[cur])
            sum += dfs2(nxt, next);
        count[cur] = sum;
        return sum;
    }
    
public:
    vector<int>nums;
    vector<int>count;
    
    vector<bool> findAnswer(vector<int>& parent, string t) 
    {
        int n = parent.size();
        vector<vector<int>>next(n);
        for (int i=0; i<n; i++)
        {
            int p = parent[i];
            if (p!=-1)
                next[p].push_back(i);
        }
        for (int i=0; i<n; i++)
            sort(next[i].begin(), next[i].end());
        
        count.resize(n);
        dfs(0, next);
        dfs2(0, next);
        
        // for (int x: nums) cout<<x<<"" ""; cout<<endl;
        // for (int i=0; i<count.size(); i++)
        //     cout<<i<<"" ""<<nums[i]<<"" ""<<count[nums[i]]<<endl;
        
        string s;
        for (int i: nums)
            s.push_back(t[i]);
        
        power.resize(n + 1, 1);
        for (int i = 1; i <= n; ++i) 
        {
            power[i] = power[i - 1] * BASE % MOD;
        }        
        vector<ll> hashF = computeHash(s);
        reverse(s.begin(), s.end());
        vector<ll> hashR = computeHash(s);
        
        vector<int>pos(n);
        for (int i=0; i<n; i++)
            pos[nums[i]] = i;
        
        vector<bool>rets;
        for (int i=0; i<n; i++)
        {
            int r = pos[i], l = r-count[i]+1;
            // cout<<l<<"" ""<<r<<endl;
            ll hash1 = getHash(hashF, l, r);         
            ll hash2 = getHash(hashR, n - r - 1, n - l - 1); 
            rets.push_back(hash1==hash2);
        }
        return rets;        
    }
};",1427921091
wisdompeak,wisdompeak,333,3607,cpp,"class Solution {
    vector<int>Eratosthenes(int n)
    {
        vector<int>q(n+1,0);
        vector<int>primes;
        for (int i=2; i<=sqrt(n); i++)
        {
            if (q[i]==1) continue;
            int j=i*2;
            while (j<=n)
            {
                q[j]=1;
                j+=i;
            }
        }        
        for (int i=2; i<=n; i++)
        {
            if (q[i]==0)
                primes.push_back(i);                
        }
        return primes;
    }
public:
    int minOperations(vector<int>& nums) 
    {
        vector<int>p = Eratosthenes(1005);
        int n = nums.size();
        vector<int>arr;
        for (int x: nums)
        {
            int flag = 0;
            for (int i=0; (i<p.size()) && (p[i]*p[i]<=x); i++)
            {
                if (x%p[i]==0)
                {
                    flag = 1;
                    arr.push_back(p[i]);
                    break;
                }                    
            }
            if (flag==0)
                arr.push_back(x);
        }
        
        for (int x: arr) cout<<x<<"" "";
        
        vector<vector<int>>dp(n, vector<int>(2, INT_MAX/2));
        dp[0][0] = 0;
        dp[0][1] = (nums[0]!=arr[0]);
        
        for (int i=1; i<n; i++)
        {
            if (nums[i]>=nums[i-1])
                dp[i][0] = min(dp[i][0], dp[i-1][0]);
            if (nums[i]>=arr[i-1])
                dp[i][0] = min(dp[i][0], dp[i-1][1]);
            
            if (arr[i]>=nums[i-1])
            {
                if(arr[i]!=nums[i])
                    dp[i][1] = min(dp[i][1], dp[i-1][0]+1);
                else
                    dp[i][1] = min(dp[i][1], dp[i-1][0]);
            }
                
            if (arr[i]>=arr[i-1])
            {
                if(arr[i]!=nums[i])
                    dp[i][1] = min(dp[i][1], dp[i-1][1]+1);
                else
                    dp[i][1] = min(dp[i][1], dp[i-1][1]);
            }
        }
        
        int ret = min(dp[n-1][0], dp[n-1][1]);
        if (ret==INT_MAX/2) return -1;
        else return ret;
    }
};",1427862253
Wei Liu,nevergiveup,334,3502,java,"class Solution {

    public int numberOfSubstrings(String s, int k) {
        int ans = 0;
        for (int i = 0;i < s.length();i ++) {
            Map<Character , Integer> freqMap = new HashMap<>();
            boolean ok = false;
            for (int j = i;j < s.length();j ++) {
                char ch = s.charAt(j);
                freqMap.put(ch , freqMap.getOrDefault(ch, 0) + 1);
                if (freqMap.get(ch) >= k) {
                    ok = true;
                }
                if (ok) {
                    ans ++;
                }
            }
        }
        return ans;
    }

}",1427827074
Wei Liu,nevergiveup,334,3566,java,"class Solution {
 

    private List<String> getStrings(String target , int prefix) {
        List<String> ans = new ArrayList<>();
        char base = target.charAt(prefix);
        for (char ch = 'a';ch <= base;ch ++) {
            ans.add(target.substring(0, prefix) + ch);
        }
        return ans;
    }

    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        int len = target.length();
        for (int prefix = 0;prefix < len;prefix ++) {
            ans.addAll(getStrings(target , prefix));
        }
        return ans;
    }
}",1427825322
Wei Liu,nevergiveup,334,3603,java,"class Solution {

    private static class HashResult {
        public long hash1;
        public long hash2;
        public HashResult(long hash1, long hash2) {
            this.hash1 = hash1;
            this.hash2 = hash2;
        }
        @Override
        public int hashCode() {
            return (int) (hash1 * 31 + hash2);
        }
        @Override
        public boolean equals(Object object) {
            HashResult hashResult = (HashResult) object;
            return this.hash1 == hashResult.hash1 && this.hash2 == hashResult.hash2;
        }
        @Override
        public String toString() {
            return this.hash1 + ""#"" + this.hash2;
        }
    }

    private static final long MOD = 1000_000_007L;
    private static final long MUL1 = 31 , MUL2 = 37;

    private static HashResult[] prefix = new HashResult[100010];
    private static HashResult[] suffix = new HashResult[100010];

    private static long[] values1 = new long[100010];
    private static long[] values2 = new long[100010];
    private static long[] invValues1 = new long[100010];
    private static long[] invValues2 = new long[100010];

    private static List<Integer>[] graph = new ArrayList[100010];

    private static long quickMod(long a , long k) {
        long ans = 1;
        while (k >= 1) {
            if (k % 2 == 1) {
                ans = (ans * a) % MOD;
            }
            k /= 2;
            a = (a * a) % MOD;
        }
        return ans;
    }

    static {
        for (int i = 0;i < 100010;i ++) {
            graph[i] = new ArrayList<>();
        }
        // build values
        values1[0] = 1;
        values2[0] = 1;
        for (int i = 1;i < 100010;i ++) {
            values1[i] = (values1[i - 1] * MUL1) % MOD;
            values2[i] = (values2[i - 1] * MUL2) % MOD;
        }
        for (int i = 0;i < 100010;i ++) {
            invValues1[i] = quickMod(values1[i], MOD - 2);
            invValues2[i] = quickMod(values2[i], MOD - 2);
        }
    }

    private void buildHash(String s) {
        long hash1 = 0, hash2 = 0;
        for (int i = 0;i < s.length();i ++) {
            hash1 = (hash1 + ((s.charAt(i) * values1[i]) % MOD)) % MOD;
            hash2 = (hash2 + ((s.charAt(i) * values2[i]) % MOD)) % MOD;
            HashResult hashResult = new HashResult(hash1, hash2);
            suffix[i] = hashResult;
        }
        hash1 = hash2 = 0;
        int base = 0;
        for (int i = s.length() - 1;i >= 0;i --) {
            hash1 = (hash1 + ((s.charAt(i) * values1[base]) % MOD)) % MOD;
            hash2 = (hash2 + ((s.charAt(i) * values2[base]) % MOD)) % MOD;
            HashResult hashResult = new HashResult(hash1, hash2);
            prefix[i] = hashResult;
            base ++;
        }
    }

    private boolean check(int l , int r, int len) {
        if (l >= r) {
            return true;
        }
        int mid = (l + r) / 2;
        int total = r - l + 1;
        if (total % 2 == 1) {
            return queryPrefix(l, mid - 1, len).equals(querySuffix(mid + 1, r));
        } else {
            return queryPrefix(l, mid, len).equals(querySuffix(mid + 1, r));
        }
    }

    private HashResult queryPrefix(int l , int r, int len) {
        long hash1 = prefix[l].hash1;
        if (r + 1 < len) {
            hash1 = (hash1 - prefix[r + 1].hash1 + MOD) % MOD;
        }
        long hash2 = prefix[l].hash2;
        if (r + 1 < len) {
            hash2 = (hash2 - prefix[r + 1].hash2 + MOD) % MOD;
        }
        int base = len - 1 - r;
        hash1 = (hash1 * invValues1[base]) % MOD;
        hash2 = (hash2 * invValues2[base]) % MOD;
        return new HashResult(hash1, hash2);
    }

    private HashResult querySuffix(int l , int r) {
        long hash1 = suffix[r].hash1;
        if (l - 1 >= 0) {
            hash1 = (hash1 - suffix[l - 1].hash1 + MOD) % MOD;
        }
        long hash2 = suffix[r].hash2;
        if (l - 1 >= 0) {
            hash2 = (hash2 - suffix[l - 1].hash2 + MOD) % MOD;
        }
        hash1 = (hash1 * invValues1[l]) % MOD;
        hash2 = (hash2 * invValues2[l]) % MOD;
        return new HashResult(hash1, hash2);
    }

    private void dfs(String s, int current, int len) {
        int min = nextIdx;
        for (int next : graph[current]) {
            dfs(s, next, len);
        }
        int max = nextIdx;
        nextIdx ++;
//        System.out.println(s.substring(min, max + 1));
//        System.out.println(current + "" "" + min + "" "" + max + "" "" + check(min, max, len));
        ans[current] = check(min, max, len);
    }

    private void collectString(String s, int current, StringBuilder builder) {
        for (int next : graph[current]) {
            collectString(s, next, builder);
        }
        builder.append(s.charAt(current));
    }

    private boolean[] ans;
    private int nextIdx = 0;

    public boolean[] findAnswer(int[] parent, String s) {
        // build graph
        for (int i = 0;i < s.length();i ++) {
            graph[i].clear();
        }
        for (int i = 0;i < parent.length;i ++) {
            if (parent[i] >= 0) {
                graph[parent[i]].add(i);
            }
        }
        // build string
        StringBuilder builder = new StringBuilder(s.length());
        collectString(s , 0, builder);
        s = builder.toString();
//        System.out.println(s);
        // build hash
        buildHash(s);
        // traverse graph
        ans = new boolean[s.length()];
        dfs(s, 0, s.length());
        return ans;
    }



}",1427953363
Wei Liu,nevergiveup,334,3607,java,"class Solution {


    private static int[] values = new int[1000010];

    static {
        values[1] = 1;
        for (int i = 2;i <= 1000000;i ++) {
            if (values[i] == 0) {
                for (int j = 1;j * i <= 1000000;j ++) {
                    if (values[j * i] == 0) {
                        values[j * i] = i;
                    }
                }
            }
        }
    }

    public int minOperations(int[] nums) {
        int ans = 0 , last = nums[nums.length - 1];
        for (int i = nums.length - 2;i >= 0;i --) {
            int nextVal = values[nums[i]];
            // prime already
            if (nextVal == nums[i]) {
                if (nums[i] <= last) {
                    last = nums[i];
                } else {
                    return - 1;
                }
            } else {
                if (nums[i] <= last) {
                    last = nums[i];
                } else {
                    if (nextVal <= last) {
                        last = nextVal;
                        ans++;
                    } else {
                        return -1;
                    }
                }
            }
        }
        return ans;
    }

}",1427847688
fallen_08,fallen_08,335,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            vector<int> frequency(26, 0);
            for (int j = i; j < n; j++) {
                frequency[s[j] - 'a']++;
                bool flag = false;
                for (auto it : frequency) {
                    if (it >= k) {
                        flag = true;
                        break;
                    }
                }
                if (flag)
                    ans++;
            }
        }
        return ans;
    }
};",1427944573
fallen_08,fallen_08,335,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string st = """";
        for (auto ch : target) {
            st += 'a';
            ans.push_back(st);
            while (st.back() != ch) {
                st.back()++;
                ans.push_back(st);
            }
        }
        return ans;
    }
};",1427953401
fallen_08,fallen_08,335,3603,cpp,"
class Solution
{
public:
    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        int n = parent.size();
        vector<bool> ans(n);
        vector<int> arr = parent;
        vector<vector<int>> c(n);
        for (int i = 1; i < n; i++)
            c[parent[i]].push_back(i);
        long long P = 911;
        long long MOD = 1e9 + 7;
        vector<long long> pp(n + 2, 1);

        for (int i = 1; i <= n + 1; i++)
            pp[i] = (pp[i - 1] * P) % MOD;
        vector<int> po;
        stack<int> stack;
        vector<bool> vis(n, false);
        stack.push(0);
        while (!stack.empty())
        {
            int node = stack.top();
            if (!vis[node])
            {
                vis[node] = true;
                for (int k = c[node].size() - 1; k >= 0; k--)
                    stack.push(c[node][k]);
            }
            else
            {
                stack.pop();
                po.push_back(node);
            }
        }
        vector<int> len(n);
        vector<long long> h1(n), h2(n);

        for (int node : po)
        {
            len[node] = 1;
            long long ch1 = 0;
            for (int child : c[node])
            {
                ch1 = (ch1 * pp[len[child]] + h1[child]) % MOD;
                len[node] += len[child];
            }
            ch1 = (ch1 * P + (s[node] - 'a' + 1)) % MOD;
            h1[node] = ch1;
            long long ch2 = (s[node] - 'a' + 1);
            for (int j = c[node].size() - 1; j >= 0; j--)
            {
                int child = c[node][j];
                ch2 = (ch2 * pp[len[child]] + h2[child]) % MOD;
            }
            h2[node] = ch2;
            ans[node] = (h1[node] == h2[node]);
        }

        return ans;
    }
};",1427926121
fallen_08,fallen_08,335,3607,cpp,"const int inf = 1e6;
int arr[inf + 1];
bool flag = false;
void detect() {
    if (flag)
        return;
    for (int i = 0; i <= inf; ++i)
        arr[i] = 1;
    for (int i = 2; i <= inf; ++i) {
        for (int j = 2 * i; j <= inf; j += i)
            arr[j] = i;
    }
    flag = true;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        detect();
        vector<int> ans = nums;
        int ct = 0;
        int n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int div = arr[nums[i]];
                if (div == 1)
                    return -1;
                nums[i] /= div;
                ct++;
                if (nums[i] <= 0)
                    return -1;
            }
        }
        return ct;
    }
};",1427935398
Rishikant Kashyap,rkkashyap390,336,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> fq(26, 0);
        int n=s.length(), l=0, r=0, ans=0;
        while(l<n){
            bool found=false;
            for(int i=0; i<26; i++){
                if(fq[i]>=k) {ans+=(n-r+1); found=true; break;}
            }
            if(found || r==n){
                fq[s[l]-'a']--;
                l++;
            }else if(r<n){
                fq[s[r]-'a']++;
                r++;
            }
        }
        return ans;
    }
};",1427841987
Rishikant Kashyap,rkkashyap390,336,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n=target.length();
        vector<string> res;
        string curr = """";
        for(int i=0; i<n; i++){
            curr.push_back('a');
            res.push_back(curr);
            while(curr[i]!=target[i]){
                curr[i]++;
                res.push_back(curr);
            }
        }
        return res;
    }
};",1427825967
Rishikant Kashyap,rkkashyap390,336,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        string t = """";
        int n = parent.size();
        vector<vector<int>> g(n);
        for(int i=1; i<n; i++) g[parent[i]].push_back(i);
        for(int i=0; i<n; i++) sort(g[i].begin(), g[i].end());

        vector<int> euler, st(n), ed(n), dum(2*n, 0);
        int cnt=0;
        auto dfs = [&](auto&& self, int nn)->void{
            euler.push_back(nn);
            st[nn] = cnt++;
            for(auto ch: g[nn]) self(self, ch);
            euler.push_back(nn);
            ed[nn] = cnt++;
        };
        dfs(dfs, 0);

        for(int i=1; i<2*n; i++){
            dum[i] = dum[i-1];
            if(ed[euler[i]] == i) {
                dum[i]++;
                t += s[euler[i]];
            }
        }

        // for(auto el: euler) cout<<el<<"" ""; cout<<endl;
        // for(auto el: st) cout<<el<<"" ""; cout<<endl;
        // for(auto el: ed) cout<<el<<"" ""; cout<<endl;
        // for(auto el: dum) cout<<el<<"" ""; cout<<endl;
        // cout<<t<<endl;
        // ManacherAlgo(t);

        s = t;
        int N = 2*s.length()+1;
        int L[N];
        L[0] = 0; L[1] = 1;
        int C=1, R=2, i=0, iMirror, expand=-1, diff=-1;
        for (i = 2; i < N; i++) {
            iMirror = 2 * C - i;
            expand = 0;
            diff = R - i;
            if (diff >= 0) {
                if (L[iMirror] < diff) L[i] = L[iMirror];
                else if (L[iMirror] == diff && R == N - 1) L[i] = L[iMirror];
                else if (L[iMirror] == diff && R < N - 1) {
                    L[i] = L[iMirror];
                    expand = 1;
                }else if (L[iMirror] > diff) {
                    L[i] = diff;
                    expand = 1;
                }
            }else {
                L[i] = 0;
                expand = 1;
            }
            if (expand == 1) {
                while(i+L[i]<N && i-L[i]>0 && ((i+L[i]+1)%2==0 || s[(i+L[i]+1)/2]==s[(i-L[i]-1)/2])){
                    L[i]++;
                }
            }
            if (i + L[i] > R) {
                C = i;
                R = i + L[i];
            }
        }
        vector<int> manArr(N), manOdd, manEven;
        for(i=0; i<N; i++){
            if(i&1) {manArr[i] = (L[i]-1)/2; manOdd.push_back(manArr[i]);}
            else {manArr[i] = L[i]/2; manEven.push_back(manArr[i]);}
        }
        // for(auto el: manOdd) cout<<el<<"" ""; cout<<endl;
        // for(auto el: manEven) cout<<el<<"" ""; cout<<endl;

        vector<bool> ans(n, false);
        for(int i=0; i<n; i++){
            int l=dum[st[i]], r=dum[ed[i]]-1, len=(r-l+1);
            // cout<<i<<"" ""<<l<<"" ""<<r<<endl;
            if(len%2==0){ //even length
                int mid = l+len/2;
                if(manEven[mid]>=len/2) ans[i] = true;
            }else{
                int mid = (l+r)/2;
                if(manOdd[mid]>=len/2) ans[i] = true; 
            }
        }

        return ans;
    }
};",1427953766
Rishikant Kashyap,rkkashyap390,336,3607,cpp,"static bool done = false;
int pfN = 1000100;
int sp[1000100];
void PrimeFactorization(){
    if(done) return;
    done = true;
    for(int i=0; i<pfN; i++) sp[i]=i;
    for(int i=2; i<pfN; i++){
        if(sp[i]==i){
            for(int j=2*i; j<pfN; j+=i){
                if(sp[j]==j) sp[j]=i;
            }
        }
    }
}

class Solution {

public:
    int minOperations(vector<int>& nums) {
        PrimeFactorization();
        int n = nums.size(), ans = 0;
        for(int i=n-2; i>=0; i--){
            if(nums[i]>nums[i+1]){
                ans++;
                nums[i] = sp[nums[i]];
                if(nums[i]>nums[i+1]){
                    return -1;
                }
            }
        }
        // for(int i=2; i<30; i++) cout<<sp[i]<<"" ""; cout<<endl;
        // for(auto el: nums) cout<<el<<"" ""; cout<<endl;
        return ans;
    }
};",1427860628
Jayndra Todawat,jay_todawat,338,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] arr = s.toCharArray();
        int n = arr.length;
        int[] count = new int[26];
        int ans = 0;
        for(int i = 0; i < n; i++){
            Arrays.fill(count, 0);
            for(int j = i; j < n; j++){
                int c = arr[j] - 'a';
                count[c]++;
                if(count[c] >= k){
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
}",1427840053
Jayndra Todawat,jay_todawat,338,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        char[] arr = target.toCharArray();
        int n = arr.length;
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        
        for(int i = 0; i < n; i++){
            char c = arr[i];
            String s = sb.toString();
            for(char x = 'a'; x <= 'z'; x++){
                ans.add(s+String.valueOf(x));
                if(x == c){
                    break;
                }
            }
            sb.append(c);
        }
        return ans;
    }
}",1427833263
Jayndra Todawat,jay_todawat,338,3603,java,"class Solution {
    ArrayList<ArrayList<Integer>> adj;
    int MOD = 1000000007;
    int P = 31;
    public boolean[] findAnswer(int[] parent, String s) {
        adj = new ArrayList<>();
        int n = parent.length;
        boolean[] ans = new boolean[n];
        for(int i = 0; i < n; i++){
            adj.add(new ArrayList<>());
        }

        for(int i = 1; i < n; i++){
            adj.get(parent[i]).add(i);
        }
        long[] a = dfs(0, s, ans);
        if(a[0] == a[1]){
            ans[0] = true;
        }
        return ans;
    }

    public long modPow(long base, long exp, long mod) {
        long result = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }
        return result;
    }

    public long[] dfs(int i,  String s, boolean[] ans){
        long fh = 0;
        long bh = 0;
        long pf = 1;
        long pb = 1;
        long len = 0;

        for (int child : adj.get(i)) {
            long[] childHash = dfs(child, s, ans);

            fh = (fh * modPow(P, childHash[2], MOD) + childHash[0]) % MOD;

            bh = (bh + childHash[1] * pb) % MOD;

            pb = (pb * modPow(P, childHash[2], MOD)) % MOD;

            len += childHash[2];
        }

        char c = s.charAt(i);
        fh = (fh * P + (c - 'a' + 1)) % MOD;
        bh = ((c - 'a' + 1) * pb + bh) % MOD;

        len++;

        if (fh == bh) {
            ans[i] = true;
        }
        // System.out.println(i + "" "" +fh + "" "" + bh);
        return new long[]{fh, bh, len};
    }
}",1427937919
Jayndra Todawat,jay_todawat,338,3607,java,"class Solution {
    
    int[] spf;  

    void pre(int N){
        spf = new int[N + 1];

        for (int i = 1; i <= N; i++) {
            spf[i] = -1;
        }

        for (int i = 2; i <= N; i++) {
            if (spf[i] == -1) { 
                for (int j = i; j <= N; j += i) {
                    if (spf[j] == -1) {
                        spf[j] = i; 
                    }
                }
            }
        }
    }
    public int minOperations(int[] arr) {
        int max = 0;
        for(int i : arr){
            max = Math.max(i, max);
        }
        pre(max);
        int n = arr.length;
        int prev = arr[n-1];
        int count = 0;
        for(int i = n-2; i >= 0; i--){
            int curr = arr[i];
            if(curr <= prev){
                prev = curr;
            } else{
                boolean flag = true;
                while(curr > prev){
                    count++;
                    int small = spf[curr];
                    if(small == -1 || small == curr){
                        flag = false;
                        break;
                    }
                    curr = small;
                }
                if(!flag) return -1;
                prev = curr;
            }
        }
        return count;
    }
}",1427867053
Govind Singh,Govind_Singh_2003,339,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        for(int i = 0; i < n; i++)
        {
            vector<int> v(26);
            int j = i;
            for(; j < n; j++)
            {
                v[s[j] - 'a']++;
                if(v[s[j] - 'a'] == k) break;
            }
            res += n - j;
        }
        return res;
    }
};",1427834121
Govind Singh,Govind_Singh_2003,339,3566,cpp,"class Solution {
public:
    vector<string> res;
    vector<string> stringSequence(string t) {
        int n = t.size();
        string s;
        int i = 0;
        for(int i = 0; i < n; i++)
        {
            s += 'a';
            res.push_back(s);
            for(int x = 0; x < t[i] - 'a'; x++)
            {
                s.back()++;
                res.push_back(s);
            }
        }
        return res;
    }
};",1427828741
Govind Singh,Govind_Singh_2003,339,3603,cpp,"class Solution {
public:
    
    int p = 31, m = 1e9 + 9, n;
    vector<long long> p_pow; 
    vector<int> dp1, dp2;
    pair<int, int> post(int node, string& s, vector<int> adj[])
    {
        long long cur = 0, cnt = 0;
        for(auto x : adj[node])
        {
            auto [y, c] = post(x, s, adj);
            cur = (cur + y * p_pow[cnt]) % m;
            cnt += c;
        }
        cur = (cur + (s[node] - 'a' + 1) * p_pow[cnt]) % m;
        dp1[node] = cur;
        return {cur, cnt + 1};
    }
    pair<int, int> pre(int node, string& s, vector<int> adj[])
    {
        long long cur = s[node] - 'a' + 1, cnt = 1;
        for(int i = adj[node].size() - 1; i >= 0; i--)
        {
            auto x = adj[node][i];
            auto [y, c] = pre(x, s, adj);
            cur = (cur + y * p_pow[cnt]) % m;
            cnt += c;
        }
        dp2[node] = cur;
        return {cur, cnt};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        n = parent.size();
        vector<int> adj[n];
        p_pow.assign(1e5 + 5, 1);
        dp1.resize(n);
        dp2.resize(n);
        
        for(int i = 1; i <= 1e5; i++)
            p_pow[i] = (p_pow[i - 1] * p) % m;
        
        
        
        for(int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);
        
        post(0, s, adj);
        pre(0, s, adj);
        vector<bool> res(n);
        for(int i = 0; i < n; i++)
            res[i] = dp1[i] == dp2[i];
        return res;
    }
};",1427946391
Govind Singh,Govind_Singh_2003,339,3607,cpp,"class Solution {
public:
    int get(int x)
    {
        int mx = -1;
        for(int j = 1; j * j <= x; j++)
        {
            if(x % j == 0)
            {
                int a = j, b = x / j;
                mx = max(mx, a);
                if(b != x) mx = max(mx, b);
            }
        }
        return x / mx;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size(), res = 0, last = nums[n - 1];
        for(int i = n - 2; i >= 0; i--)
        {
            
            int x = nums[i];
            int prev = x;
            while(x > last)
            {
                res++;
                x = get(x);
                if(x == prev) break;
                prev = x;
            }
            if(x > last) return -1;
            last = x;
        }
        return res;
    }
};",1427852717
Chris Ho,Chris_ho,340,3502,python3,"from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        res = 0
        for i in range(n):
            freq = defaultdict(int)
            for j in range(i, n):
                freq[s[j]] += 1
                if freq[s[j]] >= k:
                    res += (n - j)
                    break
        return res
                ",1427832373
Chris Ho,Chris_ho,340,3566,python3,"class Solution:
    def stringSequence(self, tgt: str) -> list[str]:
        n = len(tgt)
        l = []
        current_string = """"

        for i in range(n):
            target_char = tgt[i]
            if len(current_string) < i + 1:
                current_string += 'a' 
                l.append(current_string)

            while current_string[-1] != target_char:
                current_string = current_string[:-1] + chr(ord(current_string[-1]) + 1)
                l.append(current_string)

        return l",1427835356
Chris Ho,Chris_ho,340,3603,python3,"from collections import defaultdict
class Solution:
    def findAnswer(self, parent, s):
        

        n = len(parent)
        tr = defaultdict(list)
        for c in range(1, n):
            tr[parent[c]].append(c)
        for k in tr:
            tr[k].sort()

        dfs = []
        st = [0] * n
        en = [0] * n
        t = 0

        def post(u):
            nonlocal t
            st[u] = t
            for v in tr[u]:
                post(v)
            dfs.append(ord(s[u]) - 96)
            en[u] = t
            t += 1

        post(0)

        MOD = 10**9 + 7
        B = 27
        h = [0] * (n + 1)
        pw = [1] * (n + 1)
        for i in range(n):
            h[i+1] = (h[i] * B + dfs[i]) % MOD
            pw[i+1] = (pw[i] * B) % MOD

        rd = dfs[::-1]
        rh = [0] * (n + 1)
        for i in range(n):
            rh[i+1] = (rh[i] * B + rd[i]) % MOD

        def get(l, r):
            return (h[r+1] - h[l] * pw[r-l+1]) % MOD

        def get_r(l, r):
            return (rh[n-l] - rh[n-r-1] * pw[r-l+1]) % MOD

        ans = [False] * n
        for u in range(n):
            l, r = st[u], en[u]
            if get(l, r) == get_r(l, r):
                ans[u] = True
        return ans
",1427922342
Chris Ho,Chris_ho,340,3607,python3,"import math
from functools import lru_cache

class Solution:
    @lru_cache(None)
    def smallest_prime_factor(self, n: int) -> int:
        if n <= 1:
            return n
        for i in range(2, int(math.sqrt(n)) + 1):
            if n % i == 0:
                return i
        return n

    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        operations = 0

        for i in range(n - 2, -1, -1):
            while nums[i] > nums[i + 1]:
                spf = self.smallest_prime_factor(nums[i])
                if spf == nums[i]:
                    return -1
                nums[i] = spf
                operations += 1
                if nums[i] < 1:
                    return -1

        return operations
",1427884820
Adarsh Sahu,adarshsahu460,342,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<vector<int>> freq(26);
        int n = s.size();
        int ans = 0;
        for(int i = 0; i < n ;i++){
            freq[s[i]-'a'].push_back(i);
            int maxIdx = -1;
            for(auto i:freq){
                if(i.size()>=k){
                    maxIdx = max(maxIdx,i[i.size()-k]);
                }
            }
            if(maxIdx!=-1){
                ans+=maxIdx+1;
            }
        }
        return ans;
    }
};",1427837599
Adarsh Sahu,adarshsahu460,342,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        int i = 0;
        string temp = ""a"";
        ans.push_back(temp);
        while(i<target.size()){
            if(temp.back()==target[i]){
                i++;
                if(i<target.size()){
                    temp.push_back('a');
                    ans.push_back(temp);
                }
            }else{
                char x = temp.back();
                temp.pop_back();
                x +=1;
                temp.push_back(x);
                ans.push_back(temp);
            }
        }
        return ans;
    }
};",1427828414
Adarsh Sahu,adarshsahu460,342,3603,cpp,"class Solution {
public:
    vector<int> post;
    vector<int> order;
    int dfs(int idx,vector<vector<int>> &adj, vector<bool> &ans,string &s, string &str){
        if(adj[idx].size()==0){
            str.push_back(s[idx]);
            post[idx] = 1;
            order.push_back(idx);
            return 1;
        }
        int temp = 0;
        for(auto i:adj[idx]){
            temp+=dfs(i,adj,ans,s,str);
        }
        temp++;
        order.push_back(idx);
        post[idx] = temp;
        str.push_back(s[idx]);
        return temp;
    }
    void pre(string &str, vector<int> &odd,vector<int> &even){
        int n = str.size();

        for (int i = 0, st = 0, end = -1; i < n; ++i) {
            int k = (i > end) ? 1 : min(odd[st + end - i], end - i + 1);
            while (i - k >= 0 && i + k < n && str[i - k] == str[i + k]) {
                ++k;
            }
            odd[i] = k - 1;
            if (i + k - 1 > end) {
                st = i - k + 1;
                end = i + k - 1;
            }
        }

        for (int i = 0, st = 0, end = -1; i < n; ++i) {
            int k = (i > end) ? 0 : min(even[st + end - i + 1], end - i + 1);
            while (i - k - 1 >= 0 && i + k < n && str[i - k - 1] == str[i + k]) {
                ++k;
            }
            even[i] = k;
            if (i + k - 1 > end) {
                st = i - k;
                end = i + k - 1;
            }
        }
    }
    bool adarsh(int l, int r, const vector<int> &odd, const vector<int> &even) {
        int length = r - l + 1;

        if (length % 2 == 1) { 
            int mid = (l + r) / 2;
            return odd[mid] >= (length / 2);
        } else { 
            int mid = (l + r) / 2;
            return even[mid + 1] >= (length / 2);
        }
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector<bool> ans(parent.size());
        post = vector<int>(parent.size());
        vector<vector<int>> adj(parent.size());
        int pr = -1;
        for(int i=0;i<parent.size();i++){
            if(parent[i]==-1){
                pr = i;
                continue;
            }
            adj[parent[i]].push_back(i);
        }
        for(auto &i:adj){
            sort(i.begin(),i.end());
        }
        string temp = """";
        dfs(pr,adj,ans,s,temp);
        vector<int> odd(temp.size()),even(temp.size());
        pre(temp, odd, even);
        for (int i = 0; i < order.size(); i++) {
            int nd = order[i];
            int sz = post[nd];

            if (adarsh(i - sz + 1, i,odd, even)) {
                ans[nd] = true;
            }
        }
        return ans;
    }
};",1427938618
Adarsh Sahu,adarshsahu460,342,3607,cpp,"class Solution {
public:
    int findDiv(int n){
        for(int i=2;i <= sqrt(n);i++){
            if(n%i==0){
                return n/i;
            }
        }
        return -1;
    }
    int minOperations(vector<int>& a) {
        int n = a.size();
        int ans = 0;
        for(int i=n-2;i>=0;i--){
            if(a[i]<=a[i+1]) continue;
            int div = findDiv(a[i]);
            if(div==-1) return -1;
            if(a[i]/div <= a[i+1]){
                a[i]/=div;
                ans++;
            }else return -1;
        }
        return ans;
    }
};",1427851790
Devanshu Dangi,0UQnDcwPo3,343,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        vector<vector<int>> pref(n+1,vector<int> (26,0));

        for(int i=0;i<n;i++){
            pref[i+1][s[i]-'a']++;
        }

        for(int i=1;i<=n;i++){
            for(int j=0;j<26;j++)pref[i][j]+=pref[i-1][j];
        }

        int ans=0;
        for(int i=1;i<=n;i++){
            for(int j=i;j<=n;j++){
                bool check=0;
                for(int l=0;l<26;l++){
                    if(pref[j][l]-pref[i-1][l]>=k){
                        check=1;
                        break;
                    }
                }
                if(check)ans++;
            }
        }

        return ans;
    }
};",1427853661
Devanshu Dangi,0UQnDcwPo3,343,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n=target.size();
        string s="""";
        vector<string> ans;
        for(int i=0;i<n;i++){
            char ch='a';
            s.push_back(ch);
            ans.push_back(s);

            while(ch!=target[i]){
                ch++;
                s.pop_back();
                s.push_back(ch);
                ans.push_back(s);
            }
        }

        return ans;
    }
};",1427845016
Devanshu Dangi,0UQnDcwPo3,343,3603,cpp,"typedef long long ll;
typedef long long int lli;
typedef unsigned long long int ull;
typedef long double ld;
typedef vector<int> vi;
typedef vector<long long int> vll;
typedef map<int, int> mi;
typedef map<long long int, long long int> mll;
typedef unordered_map<int, int> umi;
typedef unordered_map<long long int, long long int> umll;
typedef set<int> si;
typedef multiset<int> msi;
typedef set<long long int> sll;
typedef multiset<long long> msll;
typedef unordered_set<int> usi;
typedef unordered_set<long long int> usll;
typedef stack<int> sti;
typedef stack<long long> stll;

struct CompareGreater {
    bool operator()(const int& a, const int& b) const {
        return a > b;
    }
};
typedef std::map<int, int, CompareGreater> decmap;

#define pb push_back
#define popb pop_back
#define ai(a,n) for(int j=0;j<n;j++)cin>>a[j];
#define ao(a,n) for(int j=0;j<n;j++)cout<<a[j]<<"" "";
#define fi(n) for(int i=0;i<n;i++)
#define fj(n) for(int j=0;j<n;j++)
#define fk(n) for(int k=0;k<n;k++)
#define fr(x,n) for(int i=x;i<n;i++)
#define printvec(a) for(int i=0;i<a.size();i++)cout<<a[i]<<"" "";cout<<""\n"";
#define printmap(m) for(auto x : m)cout<<x.first<<"" ""<<x.second<<""\n"";


ll M1 = 1000000007LL, M2 = 1000000009LL;
ll B=29;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vi> tree(n+1);

        vll p1(100000 + 5), p2(100000 + 5);
        p1[0] = p2[0] = 1;
        for (int i = 1; i <= 100000; i++) {
            p1[i] = (p1[i - 1] * B) % M1;
            p2[i] = (p2[i - 1] * B) % M2;
        }
        
        for(int i = 1; i < n; i++) {
            tree[parent[i]].push_back(i);
        }

        for (auto& children : tree) {
            sort(children.begin(), children.end());
            sort(children.begin(), children.end());
        }

        vector<char> trav;
        vi start(n), end(n);

        traverse(0, tree, s, trav, start, end);

        vector<char> revTrav = trav;
        reverse(revTrav.begin(), revTrav.end());

        vll h1(trav.size() + 1), h2(trav.size() + 1);
        for (int i = 0; i < trav.size(); i++) {
            h1[i + 1] = (h1[i] * B + (trav[i] - 'a' + 1)) % M1;
            h1[i + 1] = (h1[i] * B + (trav[i] - 'a' + 1)) % M1;
            h2[i + 1] = (h2[i] * B + (trav[i] - 'a' + 1)) % M2;
            h2[i + 1] = (h2[i] * B + (trav[i] - 'a' + 1)) % M2;
        }

        vll rh1(revTrav.size() + 1), rh2(revTrav.size() + 1);
        for (int i = 0; i < revTrav.size(); i++) {
            rh1[i + 1] = (rh1[i] * B + (revTrav[i] - 'a' + 1)) % M1;
            rh2[i + 1] = (rh2[i] * B + (revTrav[i] - 'a' + 1)) % M2;
            rh1[i + 1] = (rh1[i] * B + (revTrav[i] - 'a' + 1)) % M1;
            rh2[i + 1] = (rh2[i] * B + (revTrav[i] - 'a' + 1)) % M2;
        }

        vector<bool> answer(n,false);

        for (int i = 0; i < n; i++) {
            int l = start[i], r = end[i];

            int rl = trav.size() - 1 - r, rr = trav.size() - 1 - l;
            ll rhv1 = (rh1[rr + 1] - (rh1[rl] * p1[rr - rl + 1]) % M1 + M1) % M1;
            ll rhv2 = (rh2[rr + 1] - (rh2[rl] * p2[rr - rl + 1]) % M2 + M2) % M2;
            
            long long hv1 = (h1[r + 1] - (h1[l] * p1[r - l + 1]) % M1 + M1) % M1;
            long long hv2 = (h2[r + 1] - (h2[l] * p2[r - l + 1]) % M2 + M2) % M2;
            
             rl = trav.size() - 1 - r, rr = trav.size() - 1 - l;
            rhv1 = (rh1[rr + 1] - (rh1[rl] * p1[rr - rl + 1]) % M1 + M1) % M1;
             rhv2 = (rh2[rr + 1] - (rh2[rl] * p2[rr - rl + 1]) % M2 + M2) % M2;

            if (hv1 == rhv1 && hv2 == rhv2) {
                answer[i] = true;
            }
        }

        return answer;
    }

private:
    void traverse(int node, const vector<vector<int>>& tree, const string& s, vector<char>& trav, vector<int>& start, vector<int>& end) {
        start[node] = trav.size(); 
        for (int child : tree[node]) {
            traverse(child, tree, s, trav, start, end);
        }
        trav.push_back(s[node]);  
        end[node] = trav.size() - 1; 
    }
};
",1427939221
Devanshu Dangi,0UQnDcwPo3,343,3607,cpp,"typedef long long ll;
typedef long long int lli;
typedef unsigned long long int ull;
typedef long double ld;
typedef vector<int> vi;
typedef vector<long long int> vll;
typedef map<int, int> mi;
typedef map<long long int, long long int> mll;
typedef unordered_map<int, int> umi;
typedef unordered_map<long long int, long long int> umll;
typedef set<int> si;
typedef multiset<int> msi;
typedef set<long long int> sll;
typedef multiset<long long> msll;
typedef unordered_set<int> usi;
typedef unordered_set<long long int> usll;
typedef stack<int> sti;
typedef stack<long long> stll;

struct CompareGreater {
    bool operator()(const int& a, const int& b) const {
        return a > b;
    }
};
typedef std::map<int, int, CompareGreater> decmap;

#define pb push_back
#define popb pop_back
#define ai(a,n) for(int j=0;j<n;j++)cin>>a[j];
#define ao(a,n) for(int j=0;j<n;j++)cout<<a[j]<<"" "";
#define fi(n) for(int i=0;i<n;i++)
#define fj(n) for(int j=0;j<n;j++)
#define fk(n) for(int k=0;k<n;k++)
#define fr(x,n) for(int i=x;i<n;i++)
#define printvec(a) for(int i=0;i<a.size();i++)cout<<a[i]<<"" "";cout<<""\n"";
#define printmap(m) for(auto x : m)cout<<x.first<<"" ""<<x.second<<""\n"";



class Solution {
public:


    int minOperations(vector<int>& nums) {

        int ans=0;
        int n=nums.size();

        for(int i=n-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                for(int j=2;j<=sqrt(nums[i]);j++){
                    if(nums[i]%j==0){
                        ans++;
                        nums[i]=j;
                        break;
                    }
                }
            }
        }
        for(int i=1;i<n;i++){
            if(nums[i]<nums[i-1])return -1;
        }

        // printvec(nums);

        return ans;
    }
};",1427838060
William Ma,wdotmathree,344,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for (int l = 0; l < s.size(); l++) {
            int occ[26] = {0};
            for (int r = l; r < s.size(); r++) {
                occ[s[r]-'a']++;
                bool valid = false;
                for (int i = 0; i < 26; i++) {
                    if (occ[i] >= k) {
                        valid = true;
                        break;
                    }
                }
                if (valid)
                    ans++;
            }
        }
        return ans;
    }
};",1427844049
William Ma,wdotmathree,344,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = ""a"";
        vector<string> ans;
        while (s != target) {
            ans.push_back(s);
            if (s.back() == target[s.size()-1]) {
                s += 'a';
            } else {
                s.back()++;
            }
        }
        ans.push_back(target);
        return ans;
    }
};",1427824706
William Ma,wdotmathree,344,3603,cpp,"#define MOD 1000000007

class Solution {
public:
	vector<int> children[100000];
	long long prefix[100000];
	long long suffix[100000];
	int order[100000];
	int n;

	long long powMod(long long a, long long b) {
		long long res = 1;
		while (b) {
			if (b & 1)
				res = res * a % MOD;
			a = a * a % MOD;
			b >>= 1;
		}
		return res;
	}

	long long modInv(long long a) {
		return powMod(a, MOD - 2);
	}

	bool query(int l, int r) {
		long long lhash = prefix[r];
		if (l > 0)
			lhash = (lhash - prefix[l - 1] + MOD) % MOD;
		long long rhash = suffix[l];
		if (r < 100000 - 1)
			rhash = (rhash - suffix[r + 1] + MOD) % MOD;
		lhash = lhash * modInv(powMod(29, l)) % MOD;
		rhash = rhash * modInv(powMod(29, n - 1 - r)) % MOD;
		return lhash == rhash;
	}

	int rec(int x, string &s, vector<bool> &ans) {
		if (children[x].empty()) {
			ans[x] = true;
			return order[x];
		}
		int l = -1;
		for (auto y : children[x]) {
			int tmp = rec(y, s, ans);
			if (l == -1)
				l = tmp;
		}
		int r = order[x];
		ans[x] = query(l, r);
		return l;
	}

	void dfs(int x, string &s, string &full) {
		for (auto y : children[x])
			dfs(y, s, full);
		order[x] = s.size();
		s += full[x];
	}

	vector<bool> findAnswer(vector<int> &parent, string s) {
		n = parent.size();

		for (int i = 1; i < n; i++)
			children[parent[i]].push_back(i);
		for (int i = 0; i < n; i++)
			sort(children[i].begin(), children[i].end());

		string full;
		dfs(0, full, s);

		long long p = 1;
		for (int i = 0; i < n; i++) {
			prefix[i] = p * full[i] % MOD;
			p = p * 29 % MOD;
			if (i > 0)
				prefix[i] = (prefix[i] + prefix[i - 1]) % MOD;
		}

		p = 1;
		for (int i = n - 1; i >= 0; i--) {
			suffix[i] = p * full[i] % MOD;
			p = p * 29 % MOD;
			if (i < n - 1)
				suffix[i] = (suffix[i] + suffix[i + 1]) % MOD;
		}

		vector<bool> ans(n);
		rec(0, full, ans);
		return ans;
	}
};",1427947557
William Ma,wdotmathree,344,3607,cpp,"int thing[1000001];

auto t = []() {
    for (int i = 2; i < 1000001; i++) {
        for (int j = i * 2; j < 1000001; j += i) {
            thing[j] = i;
        }
    }
    return 0;
}();

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        for (int i = nums.size() - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (thing[nums[i]] == 0)
                    return -1;
                ans++;
                nums[i] /= thing[nums[i]];
            }
        }
        return ans;
    }
};",1427857980
Femish Bhalodiya,Femish_20,345,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;

        for (int i = 0; i < s.size(); i++) {
            vector<int> freq(26, 0);
            for (int j = i; j < s.size(); j++) {
                freq[s[j] - 'a']++;
                bool flag = false;
                for (int f : freq) {
                    if (f >= k) {
                        flag = true;
                        break;
                    }
                }
                if (flag) ans++;
                
            }
        }

        return ans;
    }
};",1427842688
Femish Bhalodiya,Femish_20,345,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string str = ""a"";
        int curr = 0;
        while(true){
            ans.push_back(str);
            if(str==target) return ans;
            if(target[curr] == str[curr]){
                curr++;
                if (curr == str.size()) {
                    str += 'a';
                }
            }
            else{
                str[curr] = str[curr] + 1;
            }
        }
        return {};
    }
};",1427833648
Femish Bhalodiya,Femish_20,345,3603,cpp,"class Solution
{
public:
    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        int size = parent.size();
        vector<bool> result(size);
        vector<vector<int>> tree(size);
        for (int i = 1; i < size; ++i)
            tree[parent[i]].push_back(i);

        long primeBase = 911, modulus = 1e9 + 7;
        vector<long> powerP(size + 2, 1);
        for (int i = 1; i <= size + 1; ++i)
            powerP[i] = (powerP[i - 1] * primeBase) % modulus;

        vector<int> postOrder, length(size, 1);
        vector<long> forwardHash(size), reverseHash(size);
        stack<int> stk;
        vector<bool> visited(size);
        stk.push(0);

        while (!stk.empty())
        {
            int node = stk.top();
            if (!visited[node])
            {
                visited[node] = true;
                for (int i = tree[node].size() - 1; i >= 0; --i)
                    stk.push(tree[node][i]);
            }
            else
            {
                stk.pop();
                postOrder.push_back(node);
            }
        }

        for (int node : postOrder)
        {
            long currentForwardHash = 0, currentReverseHash = s[node] - 'a' + 1;
            for (int child : tree[node])
            {
                currentForwardHash = (currentForwardHash * powerP[length[child]] + forwardHash[child]) % modulus;
                length[node] += length[child];
            }
            currentForwardHash = (currentForwardHash * primeBase + (s[node] - 'a' + 1)) % modulus;
            forwardHash[node] = currentForwardHash;

            for (int i = tree[node].size() - 1; i >= 0; --i)
            {
                int child = tree[node][i];
                currentReverseHash = (currentReverseHash * powerP[length[child]] + reverseHash[child]) % modulus;
            }
            reverseHash[node] = currentReverseHash;

            result[node] = (forwardHash[node] == reverseHash[node]);
        }

        return result;
    }
};",1427931760
Femish Bhalodiya,Femish_20,345,3607,cpp,"vector<int> divisors(1000001, 1);
bool flag = false;

void helper() {
    if (flag) return;
    for (int i = 2; i <= 1000000; ++i)
        for (int j = 2 * i; j <= 1000000; j += i)
            divisors[j] = i;
    flag = true;
}

class Solution {
public:
    int minOperations(vector<int> &nums) {
        helper();
        int ops = 0, n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int div = divisors[nums[i]];
                if (div == 1 || (nums[i] /= div) <= 0) return -1;
                ops++;
            }
        }
        return ops;
    }
};",1427918787
zeningc,zeningc,346,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] freq = new int[26];
        int lo = 0;
        int ans = 0;
        for (int hi = 0; hi < s.length(); hi++) {
            freq[s.charAt(hi) - 'a']++;
            while (check(freq, k))  {
                freq[s.charAt(lo) - 'a']--;
                lo++;
            }
            ans += lo;
        }
        
        return ans;
    }
    
    boolean check(int[] freq, int k)    {
        for (int f : freq)
            if (f >= k)
                return true;
        return false;
    }
}",1427830570
zeningc,zeningc,346,3566,java,"class Solution {
    public List<String> stringSequence(String target) {     
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < target.length(); i++)   {
            sb.append('a');
            ans.add(sb.toString());
            for (int j = 0; j < (target.charAt(i) - 'a'); j++)  {
                sb.setCharAt(i, (char)(j + 'a' + 1));
                ans.add(sb.toString());
            }
        }
        
        return ans;
    }
}",1427826757
zeningc,zeningc,346,3603,java,"class Solution {
    long hashKey = (long)27;
    long mod = (long)1e9 + 7;
    long[] power;
    public boolean[] findAnswer(int[] parent, String s) {
        power = new long[parent.length];
        power[0] = 1;
        for (int i = 1; i < parent.length; i++)
            power[i] = (power[i - 1] * hashKey) % mod;
        
        boolean[] ans = new boolean[parent.length];
        Map<Integer, List<Integer>> tree = new HashMap<>();
        
        for (int i = 0; i < parent.length; i++)
            tree.computeIfAbsent(parent[i], x -> new ArrayList<>()).add(i);
        
        for (Map.Entry<Integer, List<Integer>> entry : tree.entrySet())    {
            List<Integer> children = entry.getValue();
            Collections.sort(children);
        }
        
        dfs(tree, ans, s, -1, 0);
        return ans;
    }
    
    long[] dfs(Map<Integer, List<Integer>> tree, boolean[] ans, String s, int p, int u) {
        if (!tree.containsKey(u)) {
            ans[u] = true;
            long val = s.charAt(u) - 'a' + 1;
            return new long[] {1, val, val}; // cnt, forwardHash, backwardHash
        }

        int cnt = 0;
        long forwardHash = 0;
        long backwardHash = 0;

        for (int v : tree.get(u)) {
            if (v == p)
                continue;
            long[] vRet = dfs(tree, ans, s, u, v);
            forwardHash = (forwardHash * power[(int) vRet[0]] % mod + vRet[1]) % mod;
            backwardHash = (vRet[2] * power[cnt] % mod + backwardHash) % mod;
            cnt += (int) vRet[0];
        }
        long val = s.charAt(u) - 'a' + 1;
        forwardHash = (forwardHash * power[1] % mod + val) % mod;
        backwardHash = (val * power[(int) cnt] % mod + backwardHash) % mod;
        cnt++;
        if (forwardHash == backwardHash)
            ans[u] = true;

        return new long[] {cnt, forwardHash, backwardHash};
    }
}",1427930954
zeningc,zeningc,346,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int[] map = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums[i] == 1)   {
                map[i] = -1;
                continue;
            }
            int t = nums[i];
            int first = -1;
            for (int j = 2; j <= (int)Math.sqrt(nums[i]); j++)    {
                while (t % j == 0)  {
                    if (first == -1)
                        first = j;
                    t /= j;
                }
            }
            
            if (first == -1) {
                map[i] = -1;
                continue;
            }
            
            map[i] = first;
        }
        
        
        int ans = 0;
        for (int i = nums.length - 2; i >= 0; i--)  {
            if (nums[i] <= nums[i + 1])
                continue;
            if (map[i] == -1 || map[i] > nums[i + 1])
                return -1;
            ans++;
            nums[i] = map[i];
        }
        
        return ans;
    }
}",1427948121
sveng101,sveng101,347,3502,python3,"from sortedcontainers import SortedList
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        f_dict = {}
        f_lst = SortedList()
        i1 = 0
        res = 0
        for i2, l2 in enumerate(s):
            if l2 in f_dict.keys():
                f_lst.remove(f_dict[l2])
            f_dict[l2] = f_dict.get(l2, 0) + 1
            f_lst.add(f_dict[l2])
            for i1 in range(i1, i2 + 1):
                #print(i1, i2, f_dict, f_lst)
                if not f_lst or f_lst[-1] < k: break
                l1 = s[i1]
                f_lst.remove(f_dict[l1])
                if f_dict[l1] == 1:
                    f_dict.pop(l1)
                else:
                    f_dict[l1] -= 1
                    f_lst.add(f_dict[l1])
                
            else:
                i1 = i2 + 1
            #print(i1, i2)
            #print(f_dict)
            #print(f_lst)
            res += i1
        return res",1427853810
sveng101,sveng101,347,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        pref = """"
        ord_a = ord(""a"")
        res = []
        for l in target:
            for ol in range(ord_a, ord(l)):
                res.append("""".join([pref, chr(ol)]))
            pref = """".join([pref, l])
            res.append(pref)
        return res",1427827798
sveng101,sveng101,347,3603,python3,"def manacher(s: Iterable) -> str:
    """"""
    Implementation of Manacher's algorithm to find the 1D
    array with the same size as s whose value for each
    index is half the length (rounded down) of the longest
    odd-length palindromic substring centred on the
    corresponding element of s.
    """"""
    n = len(s)
    curr_centre = 0
    curr_right = 0
    max_val = 0
    max_i = 0
    res = [0] * n
    for i in range(n):
        if i < curr_right:
            mirror = (curr_centre << 1) - i
            res[i] = min(res[mirror], curr_right - i)
        while i - res[i] - 1 >= 0 and i + res[i] + 1 < len(s) and\
                s[i + res[i] + 1] == s[i - res[i] - 1]:
            res[i] += 1
        if res[i] > max_val:
            max_val = res[i]
            max_i = i
        if i + res[i] > curr_right:
            curr_right = i + res[i]
            curr_centre = i
    return res

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        if not n: return []
        first_ind = [None] * n
        last_ind = [None] * n
        s_lst = []

        children = [set() for _ in range(n)]
        root = None
        for i2, i1 in enumerate(parent):
            if i1 == -1:
                root = i2
                continue
            children[i1].add(i2)

        def dfs(idx: int) -> None:
            #c_lst = sorted(children[idx])
            first_ind[idx] = len(s_lst)
            for idx2 in sorted(children[idx]):
                dfs(idx2)
            last_ind[idx] = len(s_lst)
            s_lst.append(s[idx])
            return
        
        dfs(root)
        #print(s_lst)
        #print(first_ind)
        #print(last_ind)

        s_lst2 = [s_lst[0]]
        for i in range(1, len(s_lst)):
            s_lst2.append(""$"")
            s_lst2.append(s_lst[i])
        #print(s_lst2)
        man = manacher(s_lst2)
        #print(man)
        res = []
        for idx in range(n):
            i1 = first_ind[idx]
            i2 = last_ind[idx]
            mid = i1 + i2
            #print(idx, mid, man[mid])
            res.append(man[mid] >= (i2 - i1))
        return res",1427948239
sveng101,sveng101,347,3607,python3,"class PrimeSPFsieve:
    """"""
    Finds the smallest prime factor for each number and the number of times
    it divides the number and (if use_p_lst) generates a list of primes.
    Methods primeFactors() and primeFactorisation() use this sieve to
    identify unique prime factors and find the factorisation of a given
    positive integer respectively
    """"""
    def __init__(self, n_max: Optional[int]=None, use_p_lst: bool=True):
        if n_max is None: n_max = 2
        self.sieve = [(-1, 0, 1)] * 2
        self.sieve.append((2, 1, 1))
        self.sieve.append((3, 1, 1))
        self.use_p_lst = use_p_lst
        if use_p_lst:
            self.p_lst = [2, 3]
        self.extendSieve(n_max)
    
    def extendSieve(self, n_max: int) -> None:
        n_orig = len(self.sieve) - 1
        if n_orig >= n_max: return
        sieve = self.sieve
        p_lst = self.p_lst
        sieve.extend([(x, 1, 1) for x in range(n_orig + 1, n_max + 1)])
        for p in p_lst:
            if p * p > n_max: break
            for i in range(max(p, (n_orig // p) + 1), (n_max // p) + 1):
                i2 = p * i
                if p > sieve[i2][0]: continue
                sieve[i2] = (p, sieve[i][1] + 1, sieve[i][2]) if sieve[i][0] == p else (p, 1, i)
        
        def incorporatePrime(p: int) -> None:
            #print(f""p = {p}"")
            if sieve[p][0] == p: p_lst.append(p)
            else: return
            for i in range(max(p, (n_orig // p) + 1), (n_max // p) + 1):
                i2 = p * i
                if p > sieve[i2][0]: continue
                sieve[i2] = (p, sieve[i][1] + 1, sieve[i][2]) if sieve[i][0] == p else (p, 1, i)
            return
        
        # Using the fact that primes greater than 2 are 1 modulo 2
        start = n_orig + 1 + (n_orig & 1)
        end = math.isqrt(n_max)
        #print(start, end)
        p = start - 2
        for p in range(start, end + 1, 2):
            incorporatePrime(p)
            #if sieve[p][0] == p: p_lst.append(p)
            #if p * p > n_max: break
            #if sieve[p][0] != p: continue
            #for i in range(max(p, (n_orig // p) + 1), (n_max // p) + 1):
            #    i2 = p * i
            #    if p > sieve[i2][0]: continue
            #    sieve[i2] = (p, sieve[i][1] + 1, sieve[i][2]) if sieve[i][0] == p else (p, 1, i)
        for p in range(p + 2, n_max + 1, 2):
            #print(p)
            if sieve[p][0] == p: p_lst.append(p)
        #print(f""Time taken = {time.time() - since:.4f} seconds"")
        return
    
    def primeFactorisation(self, n: int) -> Dict[int, int]:
        """"""
        Gives the prime factorisation of a strictly positive integer.
        Note that by the Fundamental Theorem of Arithmetic this
        factorisation is guaranteed to be unique.
        
        Args:
            Required positional:
            n (int): The strictly positive integer of which the prime
                    factorisation is to be found.
        
        Returns:
        Dictionary (dict) whose keys are the complete set of prime
        factors of n (as ints) and whose values are the corresponding
        power of that prime in the factorisation (also as ints).
        """"""
        self.extendSieve(n)
        sieve = self.sieve
        res = {}
        while n != 1:
            res[sieve[n][0]] = sieve[n][1]
            n = sieve[n][2]
        return res
        
    def smallestPrimeFactor(self, n: int) -> int:
        self.extendSieve(n)
        sieve = self.sieve
        res = {}
        n2 = n
        while sieve[n2][0] != n2:
            n2 = sieve[n2][0]
        return n2

import math
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        curr = float(""inf"")
        res = 0
        for num in reversed(nums):
            #print(num, curr)
            if num <= curr:
                curr = num
                continue
            res += 1
            if not num & 1:
                curr = 2
                continue
            for p in range(3, min(curr, math.isqrt(num)) + 1, 2):
                if not num % p: break
            else:
                return -1
            curr = p
        return res
        """"""
        ps = PrimeSPFsieve(max(nums), use_p_lst=True)
        curr = float(""inf"")
        res = 0
        for num in reversed(nums):
            if num <= curr:
                curr = num
                continue
            p = ps.smallestPrimeFactor(num)
            #print(num, p, curr)
            if p > curr: return -1
            curr = p
            res += 1
        return res
        """"""",1427896526
Maxwell Zhao,mzhaodev,349,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int start = 0;
        int end = 0;
        int count = 0;
        map<int,int> freq;
        int num_above_k = 0;
        while (start < s.size()) {
            while (end < s.size() && num_above_k == 0) {
                freq[s[end]]++;
                if (freq[s[end]] == k)
                    ++num_above_k;
                ++end;
            }
            count += end == s.size() ? num_above_k > 0 : s.size() - end + 1;
            freq[s[start]]--;
            if (freq[s[start]] == k - 1)
                --num_above_k;
            ++start;
        }
        return count;
    }
};",1427835037
Maxwell Zhao,mzhaodev,349,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string build;
        while (build.size() < target.size()) {
            build += ""a"";
            ans.push_back(build);
            while (build.back() < target[build.size()-1]) {
                build.back()++;
                ans.push_back(build);
            }
        }
        return ans;
    }
};",1427824506
Maxwell Zhao,mzhaodev,349,3603,cpp,"pair<vector<int>, vector<int>> manachers(string s) {
    int n = (int)(s.size());
    vector<int> d1(n);
    vector<int> d2(n);

    int l = 0;
    int r = -1;
    for (int i = 0; i < n; i++) {
        int k = 1;
        if (i <= r) k = min(d1[l + r - i], r - i + 1);
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--;
        if (i + k > r) {
            l = i - k;
            r = i + k;
        }
    }

    l = 0;
    r = -1;
    for (int i = 0; i < n; i++) {
        int k = 0;
        if (i <= r) k = min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n  && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) {
            l = i - k - 1;
            r = i + k;
        }
    }

    return {d1, d2};
}

class Solution {
    bool is_pal(string& s, int l, int r) {
        while (l < r) {
            if (s[l] != s[r])
                return false;
            ++l;
            --r;
        }
        return true;
    }
    void dfs(int x, vector<pair<int,int>>& need, vector<vector<int>>& children, string &s, string &build) {
        int bi = build.size();
        std::sort(children[x].begin(), children[x].end());
        for (auto y : children[x]) {
            dfs(y, need, children, s, build);
        }
        build += s[x];
        int l = bi;
        int r = build.size()-1;
        need[x] = { l, r };
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector<vector<int>> children(parent.size());
        for (int i = 1; i < parent.size(); ++i)
            children[parent[i]].push_back(i);
        vector<bool> ans(parent.size());
        string build;
        vector<pair<int,int>> need(parent.size());
        dfs(0, need, children, s, build);
        auto [d1, d2] = manachers(build);

        //cout << build << endl;
        for (int i = 0; i < parent.size(); ++i) {
            //cout << i << "": "" << need[i].first << "" "" << need[i].second << endl;
            if ((need[i].second - need[i].first + 1) % 2 == 0) {
                ans[i] = d2[(need[i].first + need[i].second + 1) / 2] >= (need[i].second - need[i].first + 1) / 2;
            } else {
                ans[i] = d1[(need[i].first + need[i].second) / 2] >= (need[i].second - need[i].first) / 2 + 1;
            }
        }

        return ans;
    }
};",1427915937
Maxwell Zhao,mzhaodev,349,3607,cpp,"class Solution {
    vector<int> primes;
public:
    int minOperations(vector<int>& nums) {
        bitset<1001> sieve;
        for (int i = 2; i <= 1000; ++i) {
            if (!sieve[i]) {
                primes.push_back(i);
                for (int j = 2 * i; j <= 1000; j += i) {
                    sieve[j] = true;
                }
            }
        }
        int prev = *nums.rbegin();
        int ops = 0;
        for (auto it = nums.rbegin() + 1; it != nums.rend(); ++it) {
            if (*it <= prev) {
                prev = *it;
                continue;
            }
            for (auto x : primes) {
                if (x > std::sqrt(*it))
                    return -1;
                if (*it % x == 0) {
                    ++ops;
                    *it = x;
                    break;
                }
            }
            if (*it > prev) return -1;
            prev = *it;
        }
        return ops;
    }
};",1427852539
_Dragneel,_Dragneel,350,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int)s.size();
        vector<int> freq(26);

        auto isOk = [&]()->bool {
            for(int i = 0; i < 26; i++) {
                if(freq[i] >= k)
                    return true;
            }

            return false;
        };

        int ans = 0;
        for(int l = 0, r = 0; l < n; l++) {
            while(r < n and !isOk()) {
                freq[s[r]-'a'] += 1;
                r += 1;
            }
            // cout << r << endl;
            // 0 1 2 3 4
            if(isOk()) {
                ans += n-r+1;
            }

            freq[s[l]-'a'] -= 1;
        }

        return ans;
    }
};",1427851744
_Dragneel,_Dragneel,350,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string prev = """";
        vector<string> ans;
        int n = (int)target.size();
        for(int i = 0; i < n; i++) {
            if(prev.size() < i+1) {
                prev.push_back('a');
                ans.push_back(prev);
           
                while(prev.back() != target[i]) {
                    char next = (prev.back() - 'a' + 1)%26 + 'a';
                    prev.back() = next;
                    ans.push_back(prev);
                }
            }
        }
        return ans;
    }
};",1427836255
_Dragneel,_Dragneel,350,3603,cpp,"vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    // return vector<int>(begin(p) + 1, end(p) - 1);
    return vector<int>(begin(p) , end(p));
}
vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

// [l,r)  : Note that r is excluded
// It checks for substring [l,r-1]
bool is_palindrome (const vector<int> &maxPal, int l, int r) { 
    return maxPal[r+l] >= (r-l);
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        // Construct the tree
        int n = (int)parent.size();
        vector<set<int>> B(n);

        for(int i = 0; i < n; i++) {
            int par = parent[i];
            if(par == -1)
                continue;
            
            B[par].insert(i);
        }

        vector<vector<int>> A(n);
        for(int i = 0; i < n; i++) {
            if(B[i].empty())
                continue;
            
            for(auto v: B[i]) {
                A[i].push_back(v);
                // A[v].push_back(i);
            }
        }

        vector<int> size(n);
        string t;
        auto rec = [&](const auto &self, int u, int par)->int {
            int sz = 0;
            for(auto v: A[u]) {
                if(v == par)
                    continue;
                
                sz += self(self,v,u);
            }

            t.push_back(s[u]);
            return size[u] = sz + 1;
        };

        rec(rec,0,-1);
        vector<int> maxPal = manacher(t);
        // cout << ""string t: "" << t << endl;
        // for(auto s: size) cout << s << "" ""; cout << endl;      
        vector<bool> ans(n);
        // [l,r) included
        auto isPal = [&](int l, int r)->bool {
            r -= 1;
            while(l <= r) {
                if(t[l] != t[r]) 
                    return false;
                
                l += 1;
                r -= 1;
            }

            return true;
        };
        // cout << ""final string: "" << t << endl;
        auto dfs = [&](const auto &self, int l, int r, int u, int par)->void {
            // check [l,r] is palindrome or not
            ans[u] = is_palindrome(maxPal, l, r);
            // cout << ""node: "" << u << "" string: "" << t.substr(l,r-l) << endl;
            // cout << ""rang: "" << l << "" --> "" << r-1 << endl;

            int prev = l;
            for(auto v: A[u]) {
                if(v == par)
                    continue;
                
                self(self,prev,prev+size[v],v,u);
                prev = prev + size[v];

            }
        };

        dfs(dfs,0,size[0],0,-1);

        return ans;
    }
};",1427956690
_Dragneel,_Dragneel,350,3607,cpp,"using ll = long long ;
vector<ll> lpf;
bool isComputed = false;
void sieve_lpf(ll n) { 
    if(isComputed)
        return;
    isComputed = true;
    lpf.assign(n+1,0);
    
    lpf[0] = 0, lpf[1] = 1;
    ll i;
    // rep(i,2,n+1) { // starts from 2 since 0 and 1 are not primes
    for(ll i = 2; i < n+1; i++) {
        if(lpf[i] == 0) { // i is prime
            // mark all the multiples of prime i, i as lpf 
            lpf[i] = i;
            for(ll j = i*i; j <= n; j = j + i) {
                if(lpf[j] == 0)
                    lpf[j] = i;
            }
        }
        // otherwise i is not prime and already (marked) found the lpf
    }   
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        sieve_lpf(1e6+10);
        int n = (int)nums.size();

        auto get = [&](int x)->int {
            int l = lpf[x];
            return l; 
        };

        int op = 0;
        // cout << get(7) << endl;
        for(int i = n-2; i >= 0; i--) {
            while(nums[i]>nums[i+1]) {
                int d = get(nums[i]);
                if(d == nums[i]) {
                    return -1;
                }
                nums[i] = d;
                op += 1;
            }
        }
        return op;

    }
};",1427893980
Abhay Singh,FSPINDLE,351,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
                
             int ans = 0 ;
            
              for(int i = 0 ; i < s.size() ; i ++){
                       vector <int> F(27)  ;
                       for(int j = i ; j < s.size() ; j ++){
                               F[s[j] - 'a'] ++ ;
                               if(F[s[j] - 'a'] >= k){
                                       ans += s.size() - j ;
                                       break ;
                               }
                       }
              }
            return ans;
    }
};",1427833637
Abhay Singh,FSPINDLE,351,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
                  
            vector <string> ans ;
            
            string curr = """" ;
            
             for(auto c : target){
                     
                      curr.push_back('a') ;
                       ans.push_back(curr) ;
                     
                       while(curr.back() != c){                          
                                 char ch = curr.back() ;
                                 if(ch == 'z') ch  = 'a' ;
                                  else ch ++ ;
                                 curr.back() = ch ;  
                                 ans.push_back(curr) ;
                       }
               }
            
            return ans ;
    }
};",1427828306
Abhay Singh,FSPINDLE,351,3603,cpp,"class Solution {
public:
        
        
      vector< int > manachers(string S){
       
        int N = S.size() ;
        vector<int >A(2 * N + 10);
        // ...x character ... center ...x characters -> return x as A[center];      
    int r = 0, p = 0;
    for (int i = 0; i < N; i++)
    {
        if (i <= r)
            A[i] = min(A[2 * p - i], r - i);
        else
            A[i] = 0;
 
        while (i - A[i] - 1 >= 0 && i + A[i] + 1 < N && S[i - A[i] - 1] == S[i + A[i] + 1])
            A[i]++;
 
        if (r < i + A[i])
        {
            r = i + A[i];
            p = i;
        }
    }

    return A;
}
    vector<bool> findAnswer(vector<int>& parent, string s) {
                       
                    int n  = s.size() ;
            
                    string S ;
                    vector <int> Nodes , size(n , 1);
               
                    vector <int> adj[n] ;
                     
                   for(int i = 0 ; i < n; i ++){
                           if(parent[i]  != -1) adj[parent[i]].push_back(i) ;
                 }
            
             
                    auto dfs = [&] (auto && dfs , int node) -> void{
                             
                               for(auto it : adj[node]){
                                        dfs(dfs , it) ;
                                        size[node] += size[it] ;
                               }
                             Nodes.push_back(node) ;
                            S.push_back(s[node]) ;
                    };
            
                dfs(dfs , 0) ;
                
                  string str ;
                  
                 for(auto c : S){
                          str.push_back(c) ;
                          str.push_back('#') ;
                 }
              
               
                auto A = manachers(str) ;
                
                vector <bool> ans (n) ;
            
               for(int i = 0 ; i < n; i  ++){
                        int node = Nodes[i] ;
                        int siz = size[node] ;
                         
                        if(siz == 1){
                                ans[node] = 1 ;
                                continue;
                        }
                        int r = 2  * i , l = 2 * (i - siz + 1) ;
                        int idx = (l + r ) / 2 , cnt = idx - l;
                        
                        ans[node] = (A[idx] >= cnt );
               }
            return ans;
    }
};














",1427932892
Abhay Singh,FSPINDLE,351,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
              
              int n = nums.size() , ans = 0;
             int mx = *max_element(nums.begin() , nums.end()) + 10;
            
              vector <int> SPF(mx + 1 , -1) ;
            
              for(int i = 2 ; i  < mx ; i ++){  
                       if(SPF[i] != -1) continue ;
                       long long st = min(i * 1ll * i , (long long)mx - 1) ;
                       for(int j = st ; j < mx ; j += i){                                
                             if(SPF[j] == -1)  SPF[j]  = i ;                               
                       }
              }
            
              for(int i = n - 2 ; i >= 0 ; i --){
                       int nxt = nums[i + 1] , curr = nums[i] ;
                        
                        while(curr > nxt){                               
                                if(SPF[curr] == -1) return -1 ;
                                int PD = curr / SPF[curr] ;
                                curr /= PD ;
                                ans ++ ;
                        }
                      nums[i] = curr ;
              }
            
            return ans;
    }
};",1427861914
2499370956,2499370956,353,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int out = 0;
        for (int start = 0; start < s.length(); start++) {
            int[] count = new int[26];
            for (int i = start; i < s.length(); i++) {
                int j = s.charAt(i) - 'a';
                count[j]++;
                if (count[j] >= k) {
                    out += s.length() - i;
                    break;
                }
            }
        }
        return out;
    }
}",1427826476
2499370956,2499370956,353,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> out = new ArrayList<>();
        out.add(""a"");

        while (true) {
            String last = out.get(out.size() - 1);
            if (last.equals(target)) {
                break;
            } else if (target.startsWith(last)) {
                out.add(last + ""a"");
            } else {
                out.add(last.substring(0, last.length() - 1) + (char) (last.charAt(last.length() - 1) + 1));
            }
        }
        return out;
    }
}",1427832345
2499370956,2499370956,353,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        // special cases
        int[] charCount = toCharCount(s);
        for (int i = 0; i < 26; i++) {
            if (charCount[i] == s.length()) {
                boolean[] out = new boolean[s.length()];
                Arrays.fill(out, true);
                return out;
            }
        }

        int n = parent.length;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int i = 0; i < parent.length; i++) {
            int from = parent[i];
            int to = i;
            if (from == -1) {
                continue;
            }
            graph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);
        }

        int[] subtreeSize = new int[n];
        int[] endIndex = new int[n];
        char[] a = new char[n];
        dfs(0, s, graph, a, 0, subtreeSize, endIndex);

        boolean[] out = new boolean[n];
        for (int i = 0; i < n; i++) {
            int end = endIndex[i];
            int start = end - subtreeSize[i] + 1;
            out[i] = isPalindrome(a, start, end);
        }
        return out;
    }

    private int[] toCharCount(String s) {
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
        }
        return count;
    }

    private void dfs(int i, String s, Map<Integer, List<Integer>> graph, char[] a, int start, int[] subtreeSize, int[] endIndex) {
        int size = 1;
        for (int j : graph.getOrDefault(i, Collections.emptyList())) {
            dfs(j, s, graph, a, start, subtreeSize, endIndex);
            size += subtreeSize[j];
            start += subtreeSize[j];
        }
        endIndex[i] = start;
        a[start] = s.charAt(i);
        subtreeSize[i] = size;
    }

    private boolean isPalindrome(char[] a, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (a[i] != a[j]) {
                return false;
            }
        }
        return true;
    }
}",1427916823
2499370956,2499370956,353,3607,java,"class Solution {
    private static int[] lpd = new int[1000001];

    static {
        for (int i = 4; i <= 1000000; i++) {
            for (int j = 2; j * j <= i; j++) {
                if (i % j == 0) {
                    lpd[i] = j;
                    break;
                }
            }
        }
    }

    public int minOperations(int[] nums) {
        int n = nums.length;
        int max = nums[n - 1];
        int out = 0;
        for (int i = n - 2; i >= 0; i--) {
            max = nums[i + 1];
            while (nums[i] > max) {
                if (lpd[nums[i]] == 0) {
                    return -1;
                } else {
                    nums[i] = lpd[nums[i]];
                    out++;
                }
            }
        }
        return out;
    }
}",1427847589
Sahil Kumar,user2672IT,354,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        vector<int> pos[26];
        int n=s.length();
        for(int i=0;i<n;i++){
            
            pos[s[i]-'a'].push_back(i);
            int maxa=-1;
            for(int j=0;j<26;j++){
                int m=pos[j].size();
                if(m>=k){
                    maxa=max(maxa,pos[j][m-k]);
                }
            }
            
            ans+=maxa+1;
        }
        return ans;
    }
};",1427836706
Sahil Kumar,user2672IT,354,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string tar) {
        
           vector<string> ans;
           int n=tar.size();
           string s="""";
           
           for(int i=0;i<n;i++){
               for(int j=0;j<tar[i]-'a';j++){
                   ans.push_back(s+char(j+'a'));
               }
               s+=tar[i];
               ans.push_back(s);
           }
        return ans;
    }
};",1427827889
Sahil Kumar,user2672IT,354,3603,cpp,"class Solution {
public:
    vector<int> subtree;
    vector<vector<int>> adj;
    vector<int> pos;
    string res;
    int idx;
    void dfs(int sour,string &s,int par){
        
        vector<int> nodes;
         for(auto child:adj[sour]){
             if(child==par)continue;
             nodes.push_back(child);
         }
        
        sort(nodes.begin(),nodes.end());
        int subSize=0;
        for(auto child:nodes){
            dfs(child,s,sour);
            subSize+=subtree[child];
        }
        subtree[sour]+=subSize+1;
        pos[sour]=idx;
        idx+=1;
        res+=s[sour];
    }
    vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
    }
    
    vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
    }

    vector<bool> findAnswer(vector<int>& par, string s) {
        
        res="""";
        int n=s.length();
        subtree=pos=vector<int>(n,0);
        adj=vector<vector<int>>(n);
        for(int i=1;i<n;i++){
            adj[i].push_back(par[i]);
            adj[par[i]].push_back(i);
        }
        
        vector<bool> ans(n);
        idx=0;
        dfs(0,s,-1);
        // cout<<res<<endl;
//         for(int i=0;i<n;i++){
//             cout<<pos[i]<<"" "";
//         }
//         cout<<endl;
        
//         for(int i=0;i<n;i++){
//             cout<<subtree[i]<<"" "";
//         }
//         cout<<endl;
       
        vector<int> odd=manacher_odd(res);
        vector<int> even=manacher(res);
        
        // for(int i=0;i<odd.size();i++){
        //     cout<<odd[i]<<"" "";
        // }
        // cout<<endl;
        // for(int i=1;i<n;i++){
        //     cout<<even[2*i-1]<<"" "";
        // }
        // cout<<endl;
        
        for(int i=0;i<n;i++){
            int l=pos[i]-subtree[i]+1;
            int r=pos[i];
            int len=r-l+1;
            if(len%2){
                int val=l+len/2;
                int pal=odd[val];
                int a=val-pal+1;
                int b=val+pal-1;
                if(l>=a&&r<=b)ans[i]=true;
                
                
            } else{
                
                int val=l+len/2;
                int pal=even[2*val-1]/2;
                int a=val-pal;
                int b=val+pal-1;
                
                if(l>=a&&r<=b)ans[i]=true;
                
            }
        }
        return ans;
          
    }
};",1427957747
Sahil Kumar,user2672IT,354,3607,cpp,"bool ok=true;
int N=1e6;
vector<int> gpd(N+1);
class Solution {
public:
    
    int minOperations(vector<int>& nums) {
         
          
         if(ok){
           for(int i=1;i<=N;i++){
               for(int j=2*i;j<=N;j+=i){
                   gpd[j]=i;
               }
           }
             ok=false;
         }
        int n=nums.size();
        int prev=nums[n-1];
        int ans=0;
        for(int i=n-2;i>=0;i--){
            int temp=nums[i];
            
            while(prev<temp){
                if(temp/gpd[temp]!=temp){
                   int divi=gpd[temp];
                    temp/=divi;
                    ans+=1;
                } else{
                    break;
                }
            }
            
            if(temp>prev)return -1;
            
            prev=temp;
        }
        
        return ans;
           
    }
};",1427865274
killer-whale,killer-whale,355,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        w = deque()
        cnt = Counter()
        start = 0
        res = 0
        ch = set(s)
        for i, c in enumerate(s):
            w.append(i)
            cnt[c] += 1
            
            if max(cnt.values()) >= k:
                while max((cnt - Counter(s[w[0]])).values(), default=0) >= k:
                    cnt[s[w.popleft()]] -= 1
                    start = i + 1
                res += w[0] + 1
        return res

            
",1427851039
killer-whale,killer-whale,355,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        x = ''
        r = []
        for i in range(len(target)):
            c = target[i]
            v = 'a'
            while v != c:
                r.append(x + v)
                v = chr(ord(v) + 1)
            x += c
            r.append(x)
        return r",1427824865
killer-whale,killer-whale,355,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        graph = defaultdict(list)
        for i, p in enumerate(parent):
            graph[p].append((i, s[i]))
        for v in graph.values():
            v.sort()
        n = len(parent)
        res = [False] * n
        def dfs(node):
            fwd = rev = 0
            pwr = 1
            l = 0
            for ch, char in graph[node]:
                cf, cr, cl = dfs(ch)
                fwd = (fwd * pow(HBASE1, cl, HMOD) + cf) % HMOD
                rev = (cr * pwr + rev) % HMOD
                pwr = (pwr * pow(HBASE1, cl, HMOD)) % HMOD
                l += cl
            fwd = (fwd * HBASE1 + ord(s[node])) % HMOD
            rev = (ord(s[node]) * pwr + rev) % HMOD
            res[node] = fwd == rev
            return fwd, rev, l + 1
        dfs(0)
        return res

import random

HMOD = 2147483647
HBASE1 = random.randrange(300, HMOD)
HBASE2 = random.randrange(300, HMOD)

class Hashing:
    def __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):
        self.mod, self.base1, self.base2 = mod, base1, base2
        self._len = _len = len(s)
        f_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)
        s_hash, s_pow = f_hash[:], f_pow[:]
        # remove map ord if s is already integers
        for i, c in enumerate(map(ord, s)):
            f_hash[i + 1] = (base1 * f_hash[i] + c) % mod
            s_hash[i + 1] = (base2 * s_hash[i] + c) % mod
            f_pow[i + 1] = base1 * f_pow[i] % mod
            s_pow[i + 1] = base2 * s_pow[i] % mod
        self.f_hash, self.f_pow = f_hash, f_pow
        self.s_hash, self.s_pow = s_hash, s_pow

    def hashed(self, start, stop):
        # [start, stop) exclusive
        return (
            (self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,
            (self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,
        )

    def get_hashes(self, length):
        return (
            [(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in
             range(self._len - length + 1)],
            [(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in
             range(self._len - length + 1)],
        )

    def __len__(self):
        return self._len

    def __getitem__(self, key):
        start = key.start if key.start is not None else 0
        stop = key.stop if key.stop is not None else self._len
        if start < 0:
            start = self._len + start
        if stop < 0:
            stop = self._len + stop
        return self.hashed(start, stop)
",1427941583
killer-whale,killer-whale,355,3607,python3,"mx = 10**6+1
div = [-1] * mx
for i in range(1, mx):
    for val in range(i+i, mx, i):
        div[val] = i
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ops = 0
        for i in range(len(nums)-2,-1,-1):
            while nums[i] > nums[i+1] and div[nums[i]] > 1:
                nums[i] //= div[nums[i]]
                ops += 1
            #print(div[nums[i]], nums)
            if nums[i] > nums[i+1] or nums[i] < 0:
                return -1
        #print(nums)
        return ops
class ST:
    def __init__(self, data, default=0, func=lambda x, y: x + y, offset=0, init=False):
        self._default = default
        self._func = func
        self._len = len(data)
        self._size = _size = 1 << (self._len - 1).bit_length()
        self._offset = offset

        self.data = [default] * (2 * _size)
        self.data[_size:_size + self._len] = data
        if init:
            for i in reversed(range(_size)):
                self.data[i] = func(self.data[i + i], self.data[i + i + 1])

    def __delitem__(self, idx):
        self[idx] = self._default

    def __getitem__(self, key):
        if isinstance(key, slice):
            start = key.start if key.start is not None else -self._offset
            stop = key.stop if key.stop is not None else -self._offset + self._len
            return self.query(start, stop)
        else:
            return self.data[key + self._size + self._offset]

    def __setitem__(self, idx, value):
        idx += self._size + self._offset
        self.data[idx] = value
        idx >>= 1
        while idx:
            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])
            idx >>= 1

    def __len__(self):
        return self._len

    def query(self, start, stop):
        """"""func of data[start, stop)""""""
        start = max(start, -self._offset) + self._offset
        stop = min(stop, -self._offset + self._len) + self._offset
        start += self._size
        stop += self._size

        res_left = res_right = self._default
        while start < stop:
            if start & 1:
                res_left = self._func(res_left, self.data[start])
                start += 1
            if stop & 1:
                stop -= 1
                res_right = self._func(self.data[stop], res_right)
            start >>= 1
            stop >>= 1

        return self._func(res_left, res_right)
    
    def query_wraparound(self, start, end):
        res = 0
        if start < -self._offset:
            diff = self._offset - start
            q, r = divmod(diff, self._len)
            res += self.data[1] * q + self[self._len - r:]
        if end > -self._offset + self._len:
            diff = end - (self._len - self._offset)
            q, r = divmod(diff, self._len)
            res += self.data[1] * q + self[:r - self._offset]
        return res + self[start:end]

    def find_k(self, k):
        """"""find the maximum idx where func of data[:idx] <= k""""""
        return BS.findmax(
            -self._offset,
            -self._offset + self._len,
            lambda idx: self.query(-self._offset, idx) <= k
        )

    def query_all(self):
        """"""func of data[:]""""""
        return self.data[1]

    def __repr__(self):
        return ""ST({0})"".format(self.data[self._size:self._size + self._len])

class BS:
    @staticmethod
    def findmin(low: int, high: int, check) -> int:
        """"""find the minimum int x which make check true""""""
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid):
                high = mid
            else:
                low = mid
        return low if check(low) else high

    @staticmethod
    def findmax(low: int, high: int, check) -> int:
        """"""find the maximum int x which make check true""""""
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid):
                low = mid
            else:
                high = mid
        return high if check(high) else low

    @staticmethod
    def find_float_left(low: float, high: float, check, error=1e-6) -> float:
        """"""find the minimum float x which make check true""""""
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid):
                high = mid
            else:
                low = mid
        return low if check(low) else high

    @staticmethod
    def find_float_right(low: float, high: float, check, error=1e-6) -> float:
        """"""find the maximum float x which make check true""""""
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid):
                low = mid
            else:
                high = mid
        return high if check(high) else low
",1427879054
Guddu Singh,guddusingh123,359,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        for(int i = 0; i < n; i++){
            bool f = false;
            vector<int> cnt(26);
            for(int j = i; j < n; j++){
                int x = s[j] - 'a';
                cnt[x]++;
                if(cnt[x] >= k) f = true;
                res += f;
            }
        }
        return res;
    }
};",1427837018
Guddu Singh,guddusingh123,359,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> res;
        int n = t.size();
        string s;
        for(int i = 0; i < n; i++){
            s.push_back('a');
            for(int j = 0; j < t[i] - 'a'; j++){
                res.push_back(s);
                s[i]++;
            }
            res.push_back(s);
        }
        return res;
    }
};",1427832993
Guddu Singh,guddusingh123,359,3603,cpp,"// DEBUGGING TEMPLATE
#define sim template < class c
#define ris return * this
#define dor > debug & operator <<
#define eni(x) sim > typename \
enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {
sim > struct rge { c b, e; };
sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }
sim > auto dud(c* x) -> decltype(cout << *x, 0);
sim > char dud(...);
struct debug {
#ifndef ONLINE_JUDGE
~debug() { cout << endl; }
eni(!=) cout << boolalpha << i; ris; }
eni(==) ris << range(begin(i), end(i)); }
sim, class b dor(pair < b, c > d) {
ris << ""("" << d.first << "", "" << d.second << "")"";
}
sim dor(rge<c> d) {
*this << ""["";
for (auto it = d.b; it != d.e; ++it)
*this << "", "" + 2 * (it == d.b) << *it;
ris << ""]"";
}
#else
sim dor(const c&) { ris; }
#endif
};
#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""



vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max((int)0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& par, string s) {
        int n = par.size();
        vector<vector<int>> g(n);
        for(int i = 1; i < n; i++){
            g[par[i]].push_back(i);
        }
        
        vector<int> tout(n), first(n, -1);
        string euler;
        int cnt = 0;
        function<void(int)> dfs = [&](int v){
            if(g[v].empty()) first[v] = v;
            for(auto u : g[v]){
                dfs(u);
                if(first[v] == -1) first[v] = first[u];
            }  
            
            tout[v] = cnt++;
            euler.push_back(s[v]);
        };
        dfs(0);
        
        
        auto d = manacher(euler);
        
        
        
        auto isPal = [&](int l, int r){
            l *= 2;
            r *= 2;
            if(2 * d[(l+r)/2] - 1 >= r - l + 1) return true;
            return false;
        };
        
        vector<bool> res(n, true);
        for(int i = 0; i < n; i++){
            if(g[i].empty()) continue;
            int l = tout[first[i]], r = tout[i];
            res[i] = isPal(l, r);
        }
        return res;
    }
};",1427951118
Guddu Singh,guddusingh123,359,3607,cpp,"const int N = 1e6+1;

bool f = false;
int seive[N];

void pre(){
    for(int i = 1; i < N; i++) seive[i] = i;
    for(int i = 2; i < N; i += 2) seive[i] = 2;
    for(int i = 3; i < N; i += 2){
        if(seive[i] != i) continue;
        for(int j = 2 * i; j < N; j += i){
            if(seive[j] == j) seive[j] = i;
        }
    }
}

class Solution {
public:
    int minOperations(vector<int>& a) {
        if(!f){
            pre();
            f = true;
        }
        int n = a.size();
        int mn = 1e6;
        int res = 0;
        for(int i = n - 1; i >= 0; i--){
            int x = a[i];
            while(x > mn){
                if(x == seive[x]){
                    return -1;
                }
                x = seive[x];
                res++;
            }
            mn = min(mn, x);
        }
        return res;
    }
};",1427851971
gjp4_,gjp4_,363,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        map<int, int> cnt;
        long long ans = (1 + n) * n / 2;
        for(int l = 0, r = 0;r < n;r++) {
            cnt[s[r]]++;
            while(cnt[s[r]] >= k) {
                --cnt[s[l++]];
            }
            ans -= r-l+1;
        }
        return ans;
    }
};",1427837449
gjp4_,gjp4_,363,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        string s = """";
        vector<string> ans;
        for(int i=0;i<n;i++) {
            s += 'a';
            while(s[i] < target[i]) {
                ans.push_back(s);
                s[i]++;
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1427826156
gjp4_,gjp4_,363,3603,cpp,"class Solution {
public:
    void z_value_pal(string &s,int len,vector<int>& z){
        len=(len<<1)+1;
        s.resize(s.size() * 2 + 1);
        for(int i=len-1;i>=0;i--)s[i]=i&1?s[i>>1]:'@';
        z.resize(s.size(), 0);
        z[0]=1;
        for(int i=1,l=0,r=0;i<len;i++){
            z[i]=i<r?min(z[l+l-i],r-i):1;
            while(i-z[i]>=0&&i+z[i]<len&&s[i-z[i]]==s[i+z[i]])++z[i];
            if(i+z[i]>r) l=i,r=i+z[i];
        } 
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        string tmp = s;
        vector<vector<int> > edge(n);
        for(int i=1;i<n;i++) {
            edge[parent[i]].push_back(i);
        }
        vector<int> children(n, 0), time(n);
        int cur_time = 0;
        for(int i=0;i<n;i++)sort(edge[i].begin(), edge[i].end());
        auto dfs = [&](auto &&dfs, int cur) -> void{
            if(edge[cur].empty()) {
                time[cur] = cur_time++;
                return;
            }
            for(int i=0;i<edge[cur].size();i++) {
                dfs(dfs, edge[cur][i]);
            }
            time[cur] = cur_time++;
        };
        dfs(dfs, 0);
        string r = """";
        vector<int> z;
        r.resize(n);
        for(int i=0;i<n;i++)r[time[i]] = tmp[i];
        z_value_pal(r, n, z);
        
        auto dfs1 = [&](auto &&dfs1, int cur) {
            if(edge[cur].empty()) {
                children[cur] = 1;
                return children[cur];
            }
            for(int i=0;i<edge[cur].size();i++) {
                children[cur] += dfs1(dfs1, edge[cur][i]);
            }
            children[cur]++;
            return children[cur];
        };
        dfs1(dfs1, 0);
        vector<bool> ans;
        for(int i=0;i<n;i++) {
            int left = time[i] - children[i] + 1;
            int right = time[i];
            left = left * 2 + 1;
            right = right * 2 + 1;
            int mid = (left + right) / 2;
            if(z[mid] * 2 - 1 >= right - left + 1)ans.push_back(true);
            else ans.push_back(false);
            // cout<<mid<<"" "";
        }
        return ans;
        
    }
};
//abaaba
//aba
//ab
//a
//b
//a",1427936676
gjp4_,gjp4_,363,3607,cpp,"bool s;
vector<bool> primes;
vector<int> p;
class Solution {
public:
    
    void seive(int mx){
        primes.resize(mx, 0);
        p.resize(mx, -1);p[1] = 1;
        int sq = sqrt(mx);
        
        for(long long i=2;i<=sq;i++){
            if(!primes[i]){
                p[i] = i;
                for(long long k = i*i;k<mx;k+=i){
                    primes[k] = true;
                    if(p[k] == -1)p[k] = i;
                }
            }
        }
        if(sq&1)sq+=2;else sq++;
        for(int i=sq;i<mx;i++){
            if(!primes[i])p[i]=i;
        }
    }
    
    int minOperations(vector<int>& nums) {
        if(!s) {
            seive(1000000);
            s = true;
            
        }
        int n = nums.size();
        int prev = nums[n-1];
        int ans = 0;
        for(int i=n-2;i>=0;i--) {
            while(nums[i] > prev && p[nums[i]] != nums[i]) {
                nums[i] = p[nums[i]];
                ans++;
            }
            if(nums[i] > prev)return -1;
            prev = nums[i];
        }
        return ans;
    }
};",1427859515
Ajay Singh Deopa,singh_deopa,364,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int) s.size();
        vector<int> cnt(26);
        int l = 0, r = 0;
        int res = 0;

        while (l < n) {
            int mx = *max_element(cnt.begin(), cnt.end());

            while (mx < k && r < n) {
                mx = max(mx, ++cnt[(int) s[r] - 'a']);
                r++;
            }

            if (mx < k) {
                break;
            }

            // cout << l << "" "" << r << "" "" << n << "" "" << k << ""\n"";

            res += (n - r + 1);
            --cnt[(int) s[l] - 'a'];
            l++;
        }

        return res;
    }
};",1427837736
Ajay Singh Deopa,singh_deopa,364,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s = """";

        for (char& ch: target) {
            s += ""a"";
            res.push_back(s);

            while (s.back() != ch) {
                s.back()++;
                res.push_back(s);
            }
        }

        return res;
    }
};",1427831995
Ajay Singh Deopa,singh_deopa,364,3603,cpp,"class Solution {
    void dfs(
        vector<vector<int>>& adj,
        vector<int>& inn,
        vector<int>& out,
        int& ctr,
        int u
    ) {
        inn[u] = ctr;

        for (int& v: adj[u]) {
            dfs(adj, inn, out, ctr, v);
        }

        out[u] = ctr++;
    }

    vector<int> manacher(string s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;

        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }

        return vector<int>(begin(p) + 1, end(p) - 1);
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = (int) parent.size();
        vector<vector<int>> adj(n);

        for (int u = 1; u < n; u++) {
            int v = parent[u];
            // adj[u].push_back(v);
            adj[v].push_back(u);
        }

        vector<bool> res(n, false);
        vector<int> inn(n), out(n), rev_out(n);
        int ctr = 0;

        dfs(adj, inn, out, ctr, 0);

        for (int i = 0; i < n; i++) {
            rev_out[out[i]] = i;
        }

        string ss(n, 'a');

        for (int i = 0; i < n; i++) {
            ss[out[i]] = s[i];
        }

        string aux = ""#"";

        for(auto& ch: ss) {
            aux += ch + string(""#"");
        }

        auto dp = manacher(aux);

        // cout << ss << "" "" << aux << ""\n"";

        // for (int& i: dp) cout << i << "" "" ;
        // cout << ""\n"";

        for (int i = 0; i < n; i++) {
            int l = inn[i] << 1 | 1;
            int r = out[i] << 1 | 1;
            int mi = l + ((r - l) >> 1);
            int val = dp[mi];
            int mx = 0;

            if (mi & 1) {
                mx = 2 * ((val - 1) >> 1) + 1;
            }
            else {
                mx = 2 * (val >> 1);
            }

            if (mx >= out[i] - inn[i]) {
                res[i] = true;
            }

            // cout << i << ""  ""<< l << ""  ""<< r << "" "" << mx << endl;

        }

        return res;
    }
};",1427944860
Ajay Singh Deopa,singh_deopa,364,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = (int) nums.size();
        int mx = *max_element(nums.begin(), nums.end());
        vector<int> dp(mx + 1);
        iota(dp.begin(), dp.end(), 0);

        for (int i = 2; i * i <= mx; i++) {
            if (dp[i] != i) continue;

            for (int j = i * i; j <= mx; j += i) {
                if (dp[j] == j) {
                    dp[j] = i;
                }
            }
        }

        int res = 0;

        // for(int& i: dp) cout << i << "" "";

        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (nums[i] == dp[nums[i]]) {
                    return -1;
                }

                nums[i] = dp[nums[i]];
                res++;
            }
        }

        return res;
    }
};",1427852748
Ivan Li,liivan256,365,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
       int n = s.length();
    
        vector<int> s_num(n);
        for (int i = 0; i < n; ++i) {
            s_num[i] = s[i] - 'a';
        }

        vector<vector<int>> psas(26, vector<int>(n + 1, 0));
        for (int i = 0; i < 26; ++i) {
            for (int j = 0; j < n; ++j) {
                psas[i][j + 1] = psas[i][j] + (s_num[j] == i);
            }
        }

        int total = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = i; j < n; ++j) {
                bool found = false;
                for (int c = 0; c < 26; ++c) {
                    if (psas[c][j + 1] - psas[c][i] >= k) {
                        found = true;
                        break;
                    }
                }
                if (found)
                    total++;
            }
        }

        return total; 
    }
};",1427841668
Ivan Li,liivan256,365,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = [""""]
        for i in range(len(target)):
            res.append(res[-1] + ""a"")
            while target[:i+1] != res[-1]:
                n_res = res[-1]
                n_res = n_res[:-1] + chr(ord(n_res[-1]) + 1)
                res.append(n_res)
        return res[1:]",1427829568
Ivan Li,liivan256,365,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def get_sizes(cur, prev):
            for adj in graph[cur]:
                if prev == adj:
                    continue
                get_sizes(adj, cur)
                sizes[cur] += sizes[adj]

        n = len(parent)
        graph = [[] for _ in range(n)]
        for i, v in enumerate(parent):
            if i != -1 and v != -1:
                graph[i].append(v)
                graph[v].append(i)
        for i in range(n):
            graph[i].sort(reverse=True)

        sizes = [1] * n
        get_sizes(0, -1)
        inorder = []
        time = [-1] * n
        ct = 0

        def get_inorder(cur, prev):
            nonlocal ct
            inorder.append(s[cur])
            time[cur] = ct
            ct += 1
            for adj in graph[cur]:
                if adj == prev:
                    continue
                get_inorder(adj, cur)

        get_inorder(0, -1)
        #inorder = inorder[::-1]

        inorder = list(map(lambda x: ord(x) - ord(""a""), inorder))

        # print(inorder)
        # print(sizes)

        # hashes
        MOD = 177635683940025046467781066894531
        p = 29
        N = n + 1
        power = [0] * N  # precompute powers of `p`, with MOD
        power[0] = 1
        for i in range(1, N):
            power[i] = (power[i - 1] * p) % MOD

        hash1 = [0] * n  # precompute hashes of each character in `str1`
        for i in range(n):
            hash1[i] = (inorder[i] * power[n - i - 1]) % MOD
        psa1 = [0] + list(accumulate(hash1))  # psa for range hash query

        hash2 = [0] * n
        for i in range(n):
            hash2[i] = (inorder[n - i - 1] * power[n - i - 1]) % MOD
        psa2 = [0] + list(accumulate(hash2))

        def is_palindrome(l, r):
            if r - l + 1 == 1:
                return True
            if (r - l + 1) % 2 == 1:  # odd, ignore center
                mid = (r + l) // 2
                l1 = l
                r1 = mid - 1
                r2 = n - (mid + 1) - 1
                l2 = n - r - 1
            else:
                mid = (r + l) // 2
                l1 = l
                r1 = mid
                r2 = n - (mid + 1) - 1
                l2 = n - r - 1
            hash1 = (psa1[r1 + 1] - psa1[l1]) * power[l1] % MOD  # shift up
            hash2 = (psa2[r2 + 1] - psa2[l2]) * power[l2] % MOD
            return hash1 == hash2

        ans = [False] * n
        for i in range(n):
            l = time[i]
            r = l + sizes[i] - 1
            #print(inorder[l:r+1])
            #print(l,r)
            ans[i] = is_palindrome(l, r)
        return ans",1427937654
Ivan Li,liivan256,365,3607,python3,"# precomputation cheese
MN = 10 ** 6 + 1
inf = 1 << 30
smallest = [inf] * MN
for i in range(2, MN):
    if smallest[i] != inf:
        continue
    for j in range(i + i, MN, i):
        smallest[j] = min(smallest[j], i)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        total = 0
        for i in reversed(range(len(nums) - 1)):
            if nums[i] > nums[ i + 1]:
                if smallest[nums[i]] > nums[i+1]:
                    return -1
                nums[i] = smallest[nums[i]]
                total += 1
        return total",1427854055
nanakusa,nnks8908,366,3502,cpp,"class Solution {
public:
    bool ok(vector<int> &v,int &k)
    {
        for(int i=0;i<26;++i)
            if(v[i]>=k)
                return true;
        return false;
    }
    int numberOfSubstrings(string s, int k) 
    {
        int ans=0;
        for(int i=0;i<s.size();++i)
        {
            vector<int> v(26,0);
            for(int j=i;j<s.size();++j)
            {
                ++v[s[j]-'a'];
                if(ok(v,k))
                {
                    ans+=s.size()-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427828019
nanakusa,nnks8908,366,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) 
    {
        vector<string> ans;
        string st;
        for(int i=0;i<target.size();++i)
        {
            st+=""a"";
            ans.push_back(st);
            while(st.back()!=target[i])
            {
                ++st.back();
                ans.push_back(st);
            }
        }
        return ans;
    }
};",1427824814
nanakusa,nnks8908,366,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) 
    {
        vector<bool> ans(s.size(),true);
        vector<vector<int>> pat(s.size());
        for(int i=1;i<parent.size();++i)
            pat[parent[i]].push_back(i);
        string st;
        dfs(s,pat,ans,st,0);
        return ans;
    }
private:
    long long mod1=1e9+7, mod2=1e9+9;
    vector<long long> dfs(string &s, vector<vector<int>> &p, vector<bool> &ans, string &st, int n)
    {
        long long a1=0, a2=0, ra1=0, ra2=0, b1=1, b2=1, cnt=0;
        // a 
        // ra reverse
        // b reverse base
        for(int i=0;i<p[n].size();++i)
        {
            vector<long long> rt=dfs(s,p,ans,st,p[n][i]);
            a1=(a1+rt[0]*b1)%mod1;
            a2=(a2+rt[1]*b2)%mod2;
            ra1=(ra1*fpow(26,rt[4],mod1)%mod1+rt[2])%mod1;
            ra2=(ra2*fpow(26,rt[4],mod2)%mod2+rt[3])%mod2;
            b1=b1*fpow(26,rt[4],mod1)%mod1;
            b2=b2*fpow(26,rt[4],mod2)%mod2;
            cnt+=rt[4];
        }
        //cout<<n<<' '<<cnt<<' '<<b1<<' '<<b2<<'\n';
        a1=(a1+(s[n]-'a')*b1)%mod1;
        a2=(a2+(s[n]-'a')*b2)%mod2;
        ra1=((ra1*26%mod1)+(s[n]-'a'))%mod1;
        ra2=((ra2*26%mod2)+(s[n]-'a'))%mod2;
        ++cnt;
        //cout<<n<<' '<<a1<<' '<<ra1<<'+'<<a2<<' '<<ra2<<'\n';
        if(a1!=ra1 || a2!=ra2)
            ans[n]=false;
        return {a1, a2, ra1, ra2, cnt};
    }
    long long fpow(long long n, long long t, long long m)
    {
        long long rt=1, p=n;
        while(t)
        {
            if(t&1)
                rt=(rt*p)%m;
            p=(p*p)%m;
            t>>=1;
        }
        return rt;
    }
};",1427930186
nanakusa,nnks8908,366,3607,cpp,"class Solution {
public:
    int div(int n)
    {
        for(int i=2;i*i<=n;++i)
            if(n%i==0)
                return i;
        return -1;
    }
    int minOperations(vector<int>& nums) 
    {
        int ans=0;
        for(int i=nums.size()-2;i>=0;--i)
        {
            while(nums[i]>nums[i+1])
            {
                nums[i]=div(nums[i]);
                if(nums[i]==-1)
                    return -1;
                ++ans;
            }
        }
        return ans;
    }
};",1427835433
Mohd Adil,ace_Coder121,368,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), ans = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> cnt(26, 0); 
            for (int j = i; j < n; ++j) {
                cnt[s[j] - 'a']++;
                for (int c : cnt) {
                    if (c >= k) {
                        ans++;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};
",1427824722
Mohd Adil,ace_Coder121,368,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """"; 
        for (char ch : target) {
            current += 'a'; 
            result.push_back(current);
            while (current.back() != ch) {
                current.back() = (current.back() == 'z') ? 'a' : current.back() + 1; 
                result.push_back(current); 
            }
        }

        return result;
    }
};
",1427828106
Mohd Adil,ace_Coder121,368,3603,cpp,"#define ll long long int
class RollingHash{
    public:
    int mod=1e9+7;
    int p=31,inv;
    vector<int> h,pw,invp;
    RollingHash(){
        inv = bin_pow(p,mod-2);
    }

    int hash(string &s) {
        ll ans = 0;
        int n = s.size();
        ll pw = 1;
        for (int i = 0; i < n; i++) {
            int val = (s[i] - 'a' + 1);
            ans = (ans + (pw * val) % mod) % mod;
            pw = (pw * p) % mod;
        }
        return ans;
    }

    void build(string &s){
        ll ans = 0;
        int n = s.size();
        h.resize(n);
        pw.resize(n);
        invp.resize(n);
        ll currPow = 1,currinv=1;
        for (int i = 0; i < n; i++){
            int val = (s[i] - 'a' + 1);
            ans = (ans + (currPow * val) % mod) % mod;
            pw[i]=currPow;
            invp[i]=currinv;
            currPow = (currPow * p) % mod;
            currinv = (currinv*inv)%mod;
            h[i] = ans;
        }
    }

    int qry(int l,int r){
        if (l == 0) return h[r];
        else {
            ll res = (h[r] - h[l-1] + mod) % mod; 
            return (1ll * res*invp[l])%mod;
        }
    }

    int bin_pow(int a, int b) {
        if (b == 0) return 1;
        int x = bin_pow(a, b / 2);
        x = (1ll * x * x) % mod; 
        if (b % 2 == 0) {
            return x;
        } else {
            return (1ll * x * a) % mod; 
        }
    }
};


class Solution {
public:
    vector<bool> findAnswer(vector<int>& par, string s) {
        int n = par.size();
        vector<vector<int>> adj(n);

        for(int i=0;i<n;i++){
            if(par[i]==-1)continue;
            adj[par[i]].push_back(i);
        }
        string res;

        for(int i=0;i<n;i++)sort(adj[i].begin(),adj[i].end());

        vector<int> size(n,1);
        function<void(int,string&)> dfs1 = [&](int node,string &res){
            for(auto ch:adj[node]){
                dfs1(ch,res);
                size[node]+=size[ch];
            }
            res.push_back(s[node]);
        };
        dfs1(0,res);

        RollingHash rh1,rh2;
        rh1.build(res);
        reverse(res.begin(),res.end());
        rh2.build(res);
        vector<bool> ans(n,false);
        function<void(int,int,int,int,int)> dfs2 = [&](int node,int l1,int r1,int l2,int r2){
            // cout<<node<<"":""<<l1<<"" ""<<r1<<"" ""<<l2<<"" ""<<r2<<endl;
            int h1 = rh1.qry(l1,r1);
            int h2 = rh2.qry(l2,r2);
            ans[node]=(h1==h2);
            int crr = r2;
            int offset = 0;
            int off2 = 0;
            for(auto ch:adj[node]){
                int sz = size[ch];
                int cl1 = l1+offset,cr1=l1+sz+offset-1;
                int cr2 = r2-off2,cl2 = r2-off2-sz+1;  
                offset+=sz;
                off2+=sz;
                dfs2(ch,cl1,cr1,cl2,cr2);
            }
        };
        dfs2(0,0,n-1,0,n-1);
        return ans;
    }
};",1427938592
Mohd Adil,ace_Coder121,368,3607,cpp,"class Solution {
public:
    

    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int mx = *max_element(nums.begin(),nums.end());
        vector<int> sv(mx+1);
        for (int i = 1; i <= mx; ++i) sv[i] = 1; 
        for (int i = 2; i * i <= mx; ++i) {
            if (sv[i] == 1){ 
                for (int j = i+i;j<= mx; j += i){
                    if (sv[j] == 1){
                        sv[j] = i;
                    }
                }
            }
        }

        int ans = 0;
        for (int i = n - 2; i >= 0; --i){
            while (nums[i] > nums[i + 1]){
                int div = (nums[i]/sv[nums[i]]);
                if (div == nums[i]) return -1; 
                nums[i] /= div;
                ans++;
            }
        }
        
        return ans;
    }
};
",1427870801
callmesen,callmesen,369,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        for (int i = 0; i < n; ++i) {
            int count[26] = {0};
            int validCount = 0;
            for (int j = i; j < n; ++j) {
                int idx = s[j] - 'a';
                count[idx]++;
                if (count[idx] == k) {
                    validCount++;
                }
                if (validCount >= 1) {
                    res++;
                }
            }
        }
        return res;
    }
};",1427857936
callmesen,callmesen,369,3566,csharp,"public class Solution {
    public IList<string> StringSequence(string target) {
        List<string> result = new List<string>();
        string screen = """";

        foreach (char c in target) {
            screen += 'a';
            result.Add(screen);

            int cost = (c - 'a' + 26) % 26;

            for (int k = 0; k < cost; k++) {
                if (screen[screen.Length - 1] == 'z')
                    screen = screen.Substring(0, screen.Length - 1) + 'a';
                else
                    screen = screen.Substring(0, screen.Length - 1) + (char)(screen[screen.Length - 1] + 1);

                result.Add(screen);
            }
        }

        return result;
    }
}
",1427840430
callmesen,callmesen,369,3603,cpp,"#include <vector>
#include <string>

class Solution {
public:
    std::vector<bool> findAnswer(std::vector<int>& parent, std::string s) {
        int n = parent.size();
        std::vector<std::vector<int>> tree(n);
        // Build the tree
        for (int i = 1; i < n; ++i) {
            int p = parent[i];
            tree[p].push_back(i);
        }

        // Precompute powers
        int maxLen = n;
        const int64_t M1 = 1000000007;
        const int64_t M2 = 1000000009;
        const int64_t P1 = 911;
        const int64_t P2 = 3571;

        std::vector<int64_t> powP1(maxLen + 1), powP2(maxLen + 1);
        powP1[0] = powP2[0] = 1;
        for (int i = 1; i <= maxLen; ++i) {
            powP1[i] = (powP1[i - 1] * P1) % M1;
            powP2[i] = (powP2[i - 1] * P2) % M2;
        }

        std::vector<int> length(n, 0);
        std::vector<int64_t> forward_hash1(n, 0), forward_hash2(n, 0);
        std::vector<int64_t> reverse_hash1(n, 0), reverse_hash2(n, 0);
        std::vector<bool> answer(n, false);

        // Perform DFS from root
        dfs(0, s, tree, powP1, powP2, length,
            forward_hash1, forward_hash2, reverse_hash1, reverse_hash2,
            answer, P1, P2, M1, M2);

        return answer;
    }

private:
    void dfs(int node, const std::string& s, const std::vector<std::vector<int>>& tree,
             const std::vector<int64_t>& powP1, const std::vector<int64_t>& powP2,
             std::vector<int>& length,
             std::vector<int64_t>& forward_hash1, std::vector<int64_t>& forward_hash2,
             std::vector<int64_t>& reverse_hash1, std::vector<int64_t>& reverse_hash2,
             std::vector<bool>& answer,
             int64_t P1, int64_t P2, int64_t M1, int64_t M2) {
        length[node] = 1; // Length of dfsStr starting from this node
        int val = s[node] - 'a' + 1; // Map 'a'-'z' to 1-26

        // Forward hash
        forward_hash1[node] = 0;
        forward_hash2[node] = 0;

        // Process children in increasing order
        for (int child : tree[node]) {
            dfs(child, s, tree, powP1, powP2, length,
                forward_hash1, forward_hash2, reverse_hash1, reverse_hash2,
                answer, P1, P2, M1, M2);

            // Update length
            length[node] += length[child];

            // Update forward hash
            forward_hash1[node] = (forward_hash1[node] * powP1[length[child]] + forward_hash1[child]) % M1;
            forward_hash2[node] = (forward_hash2[node] * powP2[length[child]] + forward_hash2[child]) % M2;
        }

        // Append s[node]
        forward_hash1[node] = (forward_hash1[node] * P1 + val) % M1;
        forward_hash2[node] = (forward_hash2[node] * P2 + val) % M2;

        // Reverse hash
        reverse_hash1[node] = val;
        reverse_hash2[node] = val;

        // Process children in decreasing order
        for (auto it = tree[node].rbegin(); it != tree[node].rend(); ++it) {
            int child = *it;

            // Update reverse hash
            reverse_hash1[node] = (reverse_hash1[node] * powP1[length[child]] + reverse_hash1[child]) % M1;
            reverse_hash2[node] = (reverse_hash2[node] * powP2[length[child]] + reverse_hash2[child]) % M2;
        }

        // Check if the traversal string is a palindrome
        if (forward_hash1[node] == reverse_hash1[node] && forward_hash2[node] == reverse_hash2[node]) {
            answer[node] = true;
        } else {
            answer[node] = false;
        }
    }
};
",1427905829
callmesen,callmesen,369,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
                int n = nums.size();
        int operations = 0;

        vector<int> primes = sievePrimes(31623);

        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                if (nums[i] == nums[i + 1]) break;
                if (isPrime(nums[i], primes)) {
                    return -1; 
                }
                int spf = smallestPrimeFactor(nums[i], primes);
                if (spf >= nums[i]) {
                    return -1; 
                }
                nums[i] = spf;
                operations++;
                if (nums[i] > nums[i + 1] && nums[i] == spf) {
                    return -1; 
                }
            }
        }

        return operations;
    }

private:
    vector<int> sievePrimes(int limit) {
        vector<bool> is_prime(limit + 1, true);
        vector<int> primes;
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= limit; ++i) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (long long j = (long long)i * i; j <= limit; j += i)
                    is_prime[j] = false;
            }
        }
        return primes;
    }

    bool isPrime(int x, const vector<int>& primes) {
        if (x <= 1) return false;
        for (int p : primes) {
            if ((long long)p * p > x) break;
            if (x % p == 0) return x == p;
        }
        return true;
    }

    int smallestPrimeFactor(int x, const vector<int>& primes) {
        for (int p : primes) {
            if ((long long)p * p > x) break;
            if (x % p == 0) return p;
        }
        return x; 
    }
};",1427894953
erikhhald,erikhhald,370,3502,python3,"from collections import defaultdict

class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        counts = defaultdict(int)
        ans = 0

        for i in range(len(s)):
            for j in range(i, len(s)):
                counts[s[j]] += 1

                if counts[s[j]] >= k:
                    ans += len(s)-j
                    break
            
            counts.clear()
        
        return ans",1427899908
erikhhald,erikhhald,370,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        if not target:
            return []

        target = [ord(ch) for ch in target]
        current = [97]
        ans = []

        for i in range(len(target)):
            while current[-1] != target[i]:
                ans.append(''.join(chr(x) for x in current))
                current[-1] += 1
            
            ans.append(''.join(chr(x) for x in current))
            current.append(97)

        return ans",1427835492
erikhhald,erikhhald,370,3603,python3,"from collections import defaultdict

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        ans = [None for _ in range(len(s))]
        children = defaultdict(list)

        for i, p in enumerate(parent):
            children[p].append(i)

        def isPalindrome(string: str) -> bool:
            if len(string) == 1: 
                return True

            n = len(string)//2

            return string[:n] == string[-n:][::-1]

        def dfs(pos: int) -> str:
            string_list = []

            for c in children[pos]:
                string_list.append(dfs(c))
            
            dfsstr = ''.join(string_list)+s[pos]

            ans[pos] = isPalindrome(dfsstr)

            return dfsstr

        dfs(0)

        return ans",1427922575
erikhhald,erikhhald,370,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0

        def findDivisor(n: int, target: int) -> int:
            for i in range(2, target+1):
                if n%i == 0:
                    return i
            return -1

        for i in range(len(nums)-2, -1, -1):
            if nums[i] > nums[i+1]:
                val = findDivisor(nums[i], nums[i+1])

                if val == -1:
                    return -1

                nums[i] = val
                ans += 1     

        return ans",1427946891
Dev Jyoti,jdevj,372,3502,cpp,"class Solution {
    int k;
public:
    bool check(vector<int> &freq){
        for(int e:freq)if(e>=k)return true;
        return false;
    }
    int numberOfSubstrings(string s, int k) {
        this->k = k;
        vector<int> freq(26,0);
        int ans=0;
        for(int i=0;i<s.size();i++){
            for(int j=i;j<s.size();j++){
               freq[s[j]-'a']++;
               if(check(freq))ans++; 
            }
            for(int &e:freq)e=0;
        }
        return ans;
    }
};",1427833530
Dev Jyoti,jdevj,372,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for(char c:target){
            s+=c;
            for(char cc='a';cc<=c;cc++){
                s.back() = cc;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427825003
Dev Jyoti,jdevj,372,3603,cpp,"class Solution {
    vector<bool> ans;
    vector<tuple<int,int, int>> queries;
public:
    const int MOD = 1e9 + 9;
    const int P = 31;

    void compute_hashes(const string &s, vector<long long> &forward_hash, vector<long long> &reverse_hash, vector<long long> &power) {
        int n = s.size();
        
        power[0] = 1;
        for (int i = 1; i <= n; i++) {
            power[i] = (power[i - 1] * P) % MOD;
        }
        
        for (int i = 0; i < n; i++) {
            forward_hash[i + 1] = (forward_hash[i] + (s[i] - 'a' + 1) * power[i]) % MOD;
        }

        for (int i = 0; i < n; i++) {
            reverse_hash[i + 1] = (reverse_hash[i] + (s[n - i - 1] - 'a' + 1) * power[i]) % MOD;
        }
    }

    long long get_hash(const vector<long long> &hash_array, const vector<long long> &power, int L, int R, int n) {
        long long hash_value = (hash_array[R + 1] - hash_array[L] + MOD) % MOD;
        hash_value = (hash_value * power[n - L - 1]) % MOD;
        return hash_value;
    }

    bool is_palindrome(const string &s, int L, int R, const vector<long long> &forward_hash, const vector<long long> &reverse_hash, const vector<long long> &power) {
        int n = s.size();
        long long forward_substring_hash = get_hash(forward_hash, power, L, R, n);
        long long reverse_substring_hash = get_hash(reverse_hash, power, n - R - 1, n - L - 1, n);
        
        return forward_substring_hash == reverse_substring_hash;
    }
    bool checker(string &s){
        int n=s.size();
        for(int i=0;i<n/2;i++){
            if(s[i]!=s[n-i-1])return false;
        }
        return true;
    }
    int helper(int i,vector<vector<pair<int,char>>> &Graph,string &s,string &build,int sz){
        int ret = sz;
        for(auto [e,c]:Graph[i]){
            ret = helper(e,Graph,s,build,ret);
        }
        queries.push_back({sz,ret,i});
        build[ret] = s[i];
        ret += 1;
        return ret;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<long long> forward_hash(n + 1, 0);
        vector<long long> reverse_hash(n + 1, 0);
        vector<long long> power(n + 1, 1);
        
        
        ans.clear();
        ans.resize(n);
        vector<vector<pair<int,char>>> Graph(n);
        for(int i=1;i<n;i++){
            Graph[parent[i]].push_back({i,s[i]});
        } 
        string build = string(n,'a');
        queries.clear();
        helper(0,Graph,s,build,0);
        compute_hashes(build, forward_hash, reverse_hash, power);
        for (const auto &query : queries) {
            int L,R,i;
            tie(L,R,i) = query;
            // cout<<L<<' '<<R<<' '<<i<<'\n';
            if (is_palindrome(build, L, R, forward_hash, reverse_hash, power))ans[i] =  true;
        }
        return ans;
    }
};",1427955189
Dev Jyoti,jdevj,372,3607,cpp,"class Solution {
    int minProperDiv(int e){
        int ans=-1,limit = sqrt(e);
        for(int i=2;i<=limit;i++){
            if(e%i==0)return i;
        }
        return -1;
    }
public:
    int minOperations(vector<int>& nums) {
        reverse(nums.begin(),nums.end());
        map<int,int> M;
        int ans=0;
        for(int i=1;i<nums.size();i++){
            if(nums[i]<=nums[i-1])continue;
            else{
                int div;
                if(M.count(nums[i]))div = M[nums[i]];
                else div = minProperDiv(nums[i]), M[nums[i]] = div;
                if(div==-1 || div>nums[i-1])return -1;
                nums[i] = div;
                ans++;
            }
        }
        return ans;
    }
};",1427852188
Gourab Singha,gourabsingha1,376,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res = 0, n = s.size();
        for (int i = 0; i < n; i++) {
            unordered_map<int, int> mp;
            for (int j = i; j < n; j++) {
                mp[s[j] - 'a']++;
                bool fl = 0;
                for (auto& [ch, freq] : mp) {
                    if (freq < k) continue;
                    fl = 1;
                    break;
                }
                res += fl;
            }
        }
        return res;
    }
};",1427950149
Gourab Singha,gourabsingha1,376,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> res;
        string s = """";
        for (auto& ch : t) {
            s += 'a';
            res.push_back(s);
            int n = s.size();
            while (s[n - 1] != ch) {
                s[n - 1] = (s[n - 1] - 'a' + 1) % 26 + 'a';
                res.push_back(s);
            }
        }
        return res;
    }
};",1427950541
Gourab Singha,gourabsingha1,376,3603,cpp,"#define ll long long
const int prime = 887;
const int M = 1e9 + 7;

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> res(n, 0), vis(n, 0);
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }

        vector<ll> pre(n + 2, 1);
        for (int i = 1; i <= n + 1; i++) {
            pre[i] = (pre[i - 1] * prime) % M;
        }
        vector<ll> vec, st;
        st.push_back(0);

        while (st.size()) {
            int u = st.back();
            if (vis[u]) {
                st.pop_back();
                vec.push_back(u);
            }
            else {
                vis[u] = 1;
                int m = adj[u].size();
                for (int i = m - 1; i >= 0; i--) {
                    st.push_back(adj[u][i]);
                }
            }
        }

        vector<ll> len(n, 0), hash1(n, 0), hash2(n, 0);
        for (auto& u : vec) {
            len[u] = 1;
            ll h1 = 0;
            for (auto& v : adj[u]) {
                h1 = (h1 * pre[len[v]] + hash1[v]) % M;
                len[u] += len[v];
            }
            h1 = (h1 * prime + (s[u] + 1 - 'a')) % M;
            hash1[u] = h1;

            ll h2 = (s[u] + 1 - 'a'), m = adj[u].size();
            for (int i = m - 1; i >= 0; i--) {
                h2 = (h2 * pre[len[adj[u][i]]] + hash2[adj[u][i]]) % M;
            }
            hash2[u] = h2;
            if(hash1[u] == hash2[u]) {
                res[u] = 1;
            }
        }
        return res;
    }
};",1427948115
Gourab Singha,gourabsingha1,376,3607,cpp,"const int MAX_N = 1000010;

vector<bool> isp(MAX_N, 1);
vector<int> lp(MAX_N, 0);

void sieve_init(int n) {
    isp[0] = isp[1] = 0;
    for (int i = 2; i < n; i++) {
        if(isp[i]) {
            lp[i] = i;
            for (int j = 2 * i; j < n; j += i) {
                isp[j] = 0, lp[j] = (lp[j] == 0) ? i : lp[j];
            }
        }
    }
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(lp[25] == 0) {
            sieve_init(MAX_N);
        }
        int res = 0, n = nums.size();
        for (int i = n - 2; i >= 0; i--) {
            if(nums[i] <= nums[i + 1]) {
                nums[i + 1] = nums[i];
            }
            else {
                while(lp[nums[i]] > 1 && nums[i] / lp[nums[i]] > 1 && nums[i] > nums[i + 1]) {
                    res++, nums[i] /= (nums[i] / lp[nums[i]]);
                }
                if(nums[i] > nums[i + 1]) {
                    return -1;
                }
                else {
                    nums[i + 1] = nums[i];
                }
            }
        }
        return res;
    }
};",1427955983
colorfuldata,colorfuldata,377,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res, n = 0, len(s)
        for i in range(n):
            cnt = [0]*26
            flag = False
            for j in range(i, n):
                idx = ord(s[j])-97
                cnt[idx] +=1
                if not flag and cnt[idx] >=k:
                    flag = True
                if flag:
                    res +=1
        return res",1427826635
colorfuldata,colorfuldata,377,3566,python3,"from typing import List

class Solution:
    def stringSequence(self, t: str) -> List[str]:
        r = []
        s = ''
        for c in t:
            s += 'a'
            r.append(s)
            while s[-1] != c:
                last = s[-1]
                nc = 'a' if last == 'z' else chr(ord(last)+1)
                s = s[:-1] + nc
                r.append(s)
        return r
",1427825264
colorfuldata,colorfuldata,377,3603,python3,"from typing import List

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        mod, P = 10**9 + 7, 911
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        for children in tree:
            children.sort()

        powP = [1] * (n + 2)
        for i in range(1, n + 2):
            powP[i] = (powP[i - 1] * P) % mod
        
        hash_ = [0] * n      
        rev_hash = [0] * n   
        length = [1] * n    
        ans = [False] * n       

        stack = [(0, False)]    
        post = []
        while stack:
            node, visited = stack.pop()
            if visited:
                post.append(node)
            else:
                stack.append((node, True))
                for child in reversed(tree[node]):
                    stack.append((child, False))

        for node in post:
            h = rh = l = 0
            for child in tree[node]:
                h = (h * powP[length[child]] + hash_[child]) % mod
                rh = (rh + rev_hash[child] * powP[l]) % mod
                l += length[child]
            h = (h * P + ord(s[node])) % mod
            rh = (ord(s[node]) * powP[l] + rh) % mod
            hash_[node] = h
            rev_hash[node] = rh
            length[node] = l + 1
            ans[node] = (h == rh)
        
        return ans
",1427848525
colorfuldata,colorfuldata,377,3607,rust,"impl Solution {
    pub fn min_operations(nums: Vec<i32>) -> i32 {
        if nums.is_empty() {
            return 0;
        }

        let n = *nums.iter().max().unwrap() as usize;
        let mut spf: Vec<usize> = (0..=n).collect();
        let sqrt_n = (n as f64).sqrt() as usize;
        for i in 2..=sqrt_n {
            if spf[i] == i {
                let mut j = i * 2;
                while j <= n {
                    if spf[j] == j {
                        spf[j] = i;
                    }
                    j += i;
                }
            }
        }
        
        let mut total = 0;
        let mut t = nums[nums.len() - 1] as usize;
        
        // Process array from right to left (excluding last element)
        for &num in nums.iter().rev().skip(1) {
            let num = num as usize;
            if num <= t {
                t = num;
                continue;
            }
            
            if num == spf[num] {
                return -1;
            }
            
            let dec = spf[num];
            if dec <= t {
                total += 1;
                t = dec;
            } else {
                return -1;
            }
        }
        
        total
    }
}",1427923931
Adi,ahimawan,378,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int a[26];
        int ret = 0;
        for (int i = 0; i < n; i++) {
            int j;
            memset(a, 0, sizeof(a));
            for (j = i; j < n; j++) {
                int x = s[j]-'a';
                a[x]++;
                if (a[x] >= k) break;
            }
            ret += n - j;
        }
        return ret;
    }
};",1427831481
Adi,ahimawan,378,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur;
        int n = target.length();
        vector<string> ret;
        for (int i = 0; i < n; i++) {
            for (char c = 'a'; c <= target[i]; c++) {
                ret.push_back(cur + c);
            }
            cur += target[i];
        }
        return ret;
    }
};",1427825031
Adi,ahimawan,378,3603,cpp,"typedef vector<int> vi;
typedef pair<int,int> pii;
typedef vector<pii> vpii;

class Solution {
public:
    int n;
    string s;
    string s2;
    vi ix;
    vector<vector<int>> child;
    vi lef;
    
    int dfs(int x) {
        lef[x] = -1;
        for (auto &y: child[x]) {
            int tmp = dfs(y);
            if (lef[x] == -1) lef[x] = tmp;
        }
        if (lef[x] == -1) lef[x] = n;
        ix[x] = n++;
        s += s2[x];
        return lef[x];
    }
    void z_function(string &s, vi &z) {
        int n = s.size();
        int l = 0, r = 0;
        z[0] = 0;
        for(int i = 1; i < n; i++) {
            if(i < r) {
                z[i] = min(r - i, z[i - l]);
            } else {
                z[i] = 0;
            }
            while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {
                z[i]++;
            }
            if(i + z[i] > r) {
                l = i;
                r = i + z[i];
            }
        }
    }
    vector<bool> findAnswer(vector<int>& p, string sIn) {
        s2 = sIn;
        n = p.size();
        child.resize(n);
        ix.resize(n);
        lef.resize(n);
        
        for (int i = 0; i < n; i++) {
            if (p[i] >= 0) {
                child[p[i]].push_back(i);
            }
        }
        n = 0;
        dfs(0);
        /*
        cout << s << endl;
        for (int i = 0; i < n; i++) {
            printf(""%d lef %d ix %d\n"", i, lef[i], ix[i]);
        }
        */
        vector<bool> ret(n, true);
        vector<vpii> queries(n);
        vector<int> rb(n);
        for (int i = 0; i < n; i++) {
            int j = lef[i];
            int k = ix[i];
            if (k > j) {
                queries[j].push_back(pii(k-j+1, i));
                rb[j] = max(rb[j], k-j+1);
            }
        }
        vector<int> z(2*n);
        for (int i = 0; i < n; i++) {
            if (queries[i].size() > 0) {
                string s3 = s.substr(i, rb[i]);
                string s4 = s3;
                int len2 = s3.length();
                reverse(s4.begin(), s4.end());
                s3 += s4;
                z_function(s3, z);
                
                for (auto &p: queries[i]) {
                    int len = p.first;
                    int q = p.second;
                    if (z[2*len2-len] < len) ret[q] = false;
                }
            }
        }
        return ret;
    }
};",1427948298
Adi,ahimawan,378,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        int n = a.size();
        int prev = a.back();
        int ret = 0;
        for (int i = n-2; i >= 0; i--) {
            if (a[i] <= prev) {
                prev = a[i];
                continue;
            }
            
            int j;
            for (j = 2; j*j <= a[i]; j++) {
                if (a[i] % j == 0) break;
            }
            
            if (a[i] % j == 0) {
                a[i] = j;
                ret++;
            }
            
            if (a[i] > prev) return -1;
            prev = a[i];
        }
        return ret;
    }
};",1427846095
Ravi,xyzabcdef,379,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        for(int i = 0; i < n; i++){
            vector<int>freq(26, 0);
            for(int j = i; j < n; j++){
                freq[s[j]-'a'] += 1;
                if(freq[s[j]-'a'] >= k){
                    res += (n - j); 
                    break;
                }
            }
        }
        return res;
    }
};",1427827783
Ravi,xyzabcdef,379,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string>res;
        string cur = """";
        for(int i = 0; i < t.size(); i++){
            cur += 'a';
            res.push_back(cur);
            while(t[i] != cur.back()){
                cur[i] = (char)((cur[i] - 'a' + 1)%26 + 'a');
                res.push_back(cur);
            }
        }
        return res;
    }
};",1427940354
Ravi,xyzabcdef,379,3603,cpp,"using ll = long long;
const int p1 = 31, p2 = 97, N = 100008;
const ll mod = 1e9+7;
ll _pow1[N], _pow2[N];
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>>adj(n);
        for(int i = 0; i < n; i++){
            if(parent[i] == -1)continue;
            adj[parent[i]].push_back(i);
            adj[i].push_back(parent[i]);
        }
        for(int i = 0; i < n; i++){
            vector<int>&v = adj[i];
            sort(v.begin(), v.end());
        }
        if(_pow1[0] == 0){
            _pow1[0] = _pow2[0] = 1;
            for(int i = 1; i < N; i++){
                _pow1[i] = (1LL*_pow1[i-1]*p1) % mod;
                _pow2[i] = (1LL*_pow2[i-1]*p2) % mod;
            }
        }
        vector<pair<ll, ll>>leftHash(n), rightHash(n);
        vector<int>siz(n, 0);
        auto siz_dfs = [&](int v, int fa, auto &&siz_dfs) -> int{
            for(auto u: adj[v]){
                if(u == fa)continue;
                siz[v] += siz_dfs(u, v, siz_dfs);
            }
            siz[v] += 1;
            return siz[v];
        };
        siz_dfs(0, -1, siz_dfs);
        // for(auto z: siz)cout<<z<<"" "";cout<<'\n';
        auto dfs = [&](int v, int fa, vector<pair<ll, ll>>&hash, auto &&dfs) -> pair<ll, ll>{
            ll hash1 = 0, hash2 = 0;
            for(auto u: adj[v]){
                if(u == fa){
                    continue;
                }
                pair<ll, ll> chash = dfs(u, v, hash, dfs);
                hash1 = (hash1*_pow1[siz[u]])%mod + chash.first;
                hash2 = (hash2*_pow2[siz[u]])%mod + chash.second;
                hash1 %= mod; hash2 %= mod;
            }
            hash1 = hash1*p1 + (s[v]-'a');
            hash2 = hash2*p2 + (s[v]-'a');
            hash1 %= mod;
            hash2 %= mod;
            hash[v] = {hash1, hash2};
            return hash[v];
        };
        dfs(0, -1, leftHash, dfs);
        for(int i = 0; i < n; i++){
            reverse(adj[i].begin(), adj[i].end());
        }
        auto dfs2 = [&](int v, int fa, vector<pair<ll, ll>>&hash, auto &&dfs2) -> pair<ll, ll>{
            ll hash1 = ll(s[v]-'a'), hash2 = ll(s[v]-'a');
            for(auto u: adj[v]){
                if(u == fa){
                    continue;
                }
                pair<ll, ll> chash = dfs2(u, v, hash, dfs2);
                hash1 = (hash1*_pow1[siz[u]])%mod + chash.first;
                hash2 = (hash2*_pow2[siz[u]])%mod + chash.second;
                hash1 %= mod; hash2 %= mod;
            }
            hash[v] = {hash1, hash2};
            return hash[v];
        };
        dfs2(0, -1, rightHash, dfs2);
        vector<bool>ans(n, false);
        for(int i = 0; i < n; i++){
            if(leftHash[i].first == rightHash[i].first){
                if(leftHash[i].second == rightHash[i].second){
                    ans[i] = true;
                }
            }
        }
        return ans;
    }
};",1427934331
Ravi,xyzabcdef,379,3607,cpp,"const int N = 1000008;
int divi[N];
class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(divi[4] == 0){
            for(int i = 2; i < N; i++){
                for(int j = 2*i; j < N; j+=i){
                    divi[j] = i;
                }
            }
        }
        int n = nums.size();
        int cost = 0, p = sqrt(N) + 1;
        for(int j = 0; j < p; j++){
            for(int i = n-2; i >= 0; i--){
                if(nums[i] > nums[i+1]){
                    if(divi[nums[i]] != 0){
                        cost++;
                        nums[i] = nums[i]/divi[nums[i]];
                    } else{
                        return -1;
                    }
                }
            }
        }
        // for(auto z: nums)cout<<z<<"" "";cout<<'\n';
        for(int i = 1; i < n; i++){
            if(nums[i] < nums[i-1])return -1;
        }
        return cost;
    }
};",1427853379
Mohit Kanodia,yoda_codiyapa,380,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans = 0;
        int n = s.length();
        int i = 0; 
        int j = 0;
        char[] ch = s.toCharArray();
        int[] a = new int[26];
        while(j < n) {
            a[ch[j] - 'a']++;
            while(i < n && isv(a, k)) {
                ans += n - j;
                a[ch[i] - 'a']--;
                i++;
            }
            j++;
        }
        return ans;
    }

    boolean isv(int[] a, int k) {
        for(int i : a) {
            if(i >= k) {
                return true;
            }
        }
        return false;
    }
}",1427833947
Mohit Kanodia,yoda_codiyapa,380,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        StringBuilder curr = new StringBuilder();

        for(char c : target.toCharArray()) {
            for(char x = 'a'; x <= c; x++) {
                curr.append(x);
                ans.add(curr.toString());
                curr.deleteCharAt(curr.length()-1);
            }
            curr.append(c);
        }
        return ans;
    }
}",1427826930
Mohit Kanodia,yoda_codiyapa,380,3603,java,"class Solution {
      List<List<Integer>> list;
      List<int[]> idx = new ArrayList<>();

      public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        boolean[] ans = new boolean[n];
        char[] ch = s.toCharArray();

        idx = new ArrayList<>();
        for (int i = 0; i < n; i++) {
          idx.add(new int[2]);
        }

        list = buildUndirAdjListParent(n, parent);
        for (List<Integer> l : list) {
          Collections.sort(l);
        }

        // u.db(list);
        StringBuilder sb = new StringBuilder();
        dfs(0, -1, ch, sb);
        // u.db(sb);

        // for (int[] x : idx) {
        // u.pa(x);
        // }

        Arrays.fill(ans, true);
        build(ans, sb.toString(), 256, 1000_000_007);
        build(ans, sb.toString(), 257, 998244353);
        return ans;
      }

      void build(boolean[] ans, String s, long R, int MOD) {
        int n = s.length();
        String rev = new StringBuilder(s).reverse().toString();
        // u.prln(s + "" "" + rev);

        RangeHash r1 = new RangeHash(s, R, MOD);
        RangeHash r2 = new RangeHash(rev, R, MOD);

        for (int i = 0; i < n; i++) {
          int st = idx.get(i)[0];
          int ed = idx.get(i)[1] - 1;
        //   u.prln(st + "" "" + ed);

          int e2 = n - st - 1;
          int s2 = n - ed - 1;

        //   u.prln(s2 + "" "" + e2);

          long h1 = r1.rangehash(st, ed);
          long h2 = r2.rangehash(s2, e2);
          ans[i] = ans[i] && (h1 == h2);
        }
      }

      public class RangeHash {
        long R;
        int MOD;
        long[] base;
        long[] hash;
        String s;
        int n;

        public RangeHash(String s, long R, int MOD) {
          this.R = R;
          this.MOD = MOD;
          this.s = s;
          this.n = s.length();
          this.base = new long[n + 1];
          this.hash = new long[n + 1];
          build();
        }

        void build() {
          base[0] = 1;
          for (int i = 1; i <= n; i++) {
            base[i] = (base[i - 1] * R) % MOD;
            hash[i] = ((hash[i - 1] * R) % MOD + s.charAt(i - 1)) % MOD;
          }
        }

        long rangehash(int i, int j) {
          long ans = (hash[j + 1] - (hash[i] * base[j - i + 1]) % MOD + MOD) % MOD;
          ans = ans % MOD;
          return ans;
        }
      }

      void dfs(int c, int p, char[] ch, StringBuilder sb) {
        int st = sb.length();
        for (int e : list.get(c)) {
          if (e == p) {
            continue;
          }
          dfs(e, c, ch, sb);
        }

        // u.db(c);
        sb.append(ch[c]);
        int ed = sb.length();
        // u.db(c+"" ""+st+"" ""+ed);
        idx.set(c, new int[] { st, ed });
      }

      public List<List<Integer>> buildUndirAdjListParent(int n, int[] p) {
        List<List<Integer>> adjlist = new ArrayList<>();
        for (int i = 0; i < n; i++) {
          adjlist.add(new ArrayList<>());
        }

        for (int i = 1; i < n; i++) {
          int a = i;
          int b = p[i];

          adjlist.get(a).add(b);
          adjlist.get(b).add(a);
        }

        return adjlist;
      }
    }",1427956965
Mohit Kanodia,yoda_codiyapa,380,3607,java,"class Solution {
    int MAX = 1000000;

    public int minOperations(int[] nums) {
        int n = nums.length;
        int[] spf = spf(MAX);

        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1] && spf[nums[i]] > 1 && spf[nums[i]] < nums[i]) {
                nums[i] = spf[nums[i]];
                ans++;
            }
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
        }
        return ans;
    }

    int[] spf(int n) {
        int[] spf = new int[n + 1];
        Arrays.setAll(spf, i -> i);

        long i = 2;
        while (i * i <= n) {
          // then its prime
          // else its composite factor
          if (spf[(int) i] == i) {
            long j = i * i;
            while (j <= n) {
              if (spf[(int) j] == j) {
                spf[(int) j] = (int) i;
              }
              j += i;
            }
          }
          i = i + 1;
        }

        // for (int k = 2; k < n; k++) {
        //   u.prln(k + "" "" + spf[k]);
        // }
        return spf;
      }
}",1427868141
BrutalKiller,BrutalKiller,381,3502,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        ll ans = 0;
        ll n = s.size();

        for(ll i = 0; i < n; i++){
            vi v (26, 0);

            for(ll j = i; j < n; j++){
                ll x = s[j] - 'a';
                v[x]++;

                if(v[x] == k){
                    ans += (n - j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427833832
BrutalKiller,BrutalKiller,381,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector <string> ans;
        string x;

        for(int i = 0; i < t.size(); i++){
            x += 'a';
            ans.push_back(x);
            while(x[i] != t[i]){
                x[i]++;
                ans.push_back(x);
            }
        }
        return ans;
    }
};",1427826799
BrutalKiller,BrutalKiller,381,3603,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef long long ll;

class Solution {
    vector <bool> ans;
    vvi v;
    ll M = 1e9 + 7, p1 = 31;
    vector <pll> a, b;
    string s;
    vi used, pow;
    ll n;

    ll help(vector <pll> v){
        ll ans = 0, s = 0;

        for(auto & e : v){
            ans = (ans + pow[s] * e.first) % M;
            s += e.second;
        }
        return ans;
    }

    ll dfs(ll x){
        used[x] = 1;
        vector <pll> aa, bb;
        ll cnt = 1;
        ll x1 = 0, ss = 0;
        bb.pb({s[x] - 'a' + 1, 1});

        for(auto & e : v[x]){
            if(used[e] == 1)
                continue;

            cnt += dfs(e);
            x1  = (x1 + pow[ss] * a[e].first) % M;
            ss += a[e].second;
            bb.pb(b[e]);
        }

        x1 = (x1 + pow[ss] * (s[x] - 'a' + 1)) % M;
        reverse(bb.begin() + 1, bb.end());

        ll x2 = help(bb);

        if(x1 == x2)
            ans[x] = true;
        else
            ans[x] = false;
        
        a[x] = {x1, cnt};
        b[x] = {x2, cnt};

        return cnt;
    }
public:
    vector<bool> findAnswer(vector<int>& p, string ss) {
        ll n = p.size();
        s = ss;
        v = vvi (n);
        used = vi (n, 0);
        a = b = vector <pll> (n);
        ans = vector <bool> (n);
        pow.pb(1);

        for(ll i = 1; i < n; i++){
            pow.pb((pow.back() * p1) % M);
            v[i].pb(p[i]);
            v[p[i]].pb(i);
        }

        for(ll i = 0; i < n; i++)
            sort(all(v[i]));

        dfs(0);
        return ans;
    }
};",1427948967
BrutalKiller,BrutalKiller,381,3607,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {

    ll help(ll x){
        for(ll i = 2; i * i <= x; i++){
            if(x % i == 0)
                return x / i;
        }
        return -1;
    }
public:
    int minOperations(vector<int>& v) {
        ll ans = 0;
        ll n = v.size();
        vi used(1e6 + 1, -1);
        ll last = v[n - 1];

        for(ll i = n - 2; i >= 0; i--){
            if(v[i] <= last){
                last = v[i];
                continue;
            }

            ll x = v[i];
            while(x > last){
                if(used[x] == -1)
                    used[x] = help(x);
                
                if(used[x] == -1)
                    return -1;
                
                x = x / used[x];
                
                ans++;
            }

            last = x;
        }

        return ans;
    }
};",1427857119
uday,udaykumar21039,382,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
         int res = 0;
    for (int l = 0; l <s.size(); ++l) {
        unordered_map<char, int> mp;
        for (int r = l; r <s.size(); ++r) {
            mp[s[r]]++;
            bool val = false;
            for (auto &i : mp) {
                if (i.second >= k) {
                    val = true;
                    break;
                }
            }
            if (val) {
                res++;
            }
        }
    }
    return res;
    }
};",1427855679
uday,udaykumar21039,382,3566,cpp,"class Solution {
    void sol(char c, string& cur, vector<string>& res) {
       while (cur.size() < res.size() + 1) {
            cur += 'a';
            res.push_back(cur);
        }
        while (cur.back() != c) {
            cur.back() = (cur.back() == 'z') ? 'a' : cur.back() + 1;
            res.push_back(cur);
        }
        cur += c;
        res.push_back(cur);
    }
public:
    vector<string> stringSequence(string target) {
      vector<string> res;
        string cur = ""a"";
        res.push_back(cur);
        
        for (int i = 0; i < target.size(); ++i) {
            char target_char = target[i];
            while (cur.size() <= i) {
                cur += 'a';
                res.push_back(cur);
            }
            while (cur[i] < target_char) {
                cur[i]++;
                res.push_back(cur);
            }
        }
        
        return res;
    }
};",1427940783
uday,udaykumar21039,382,3603,cpp,"class Solution {
    void sol4(vector<int>& parent, vector<list<int>>& b) {
        for (int i = 1; i < parent.size(); i++) {
            b[parent[i]].push_back(i);
        }
    }
    vector<long> sol3(int n) {
        long p = 911;
        long mod = 1000000007;
        vector<long> a(n + 2);
        a[0] = 1;
        for (int i = 1; i <= n + 1; i++) {
            a[i] = (a[i - 1] * p) % mod;
        }
        return a;
    }
    vector<int> sol2(vector<list<int>>& b, int n) {
        vector<int> a;
        stack<int> c;
        vector<bool> d(n);
        c.push(0);
        while (!c.empty()) {
            int e = c.top();
            if (!d[e]) {
                d[e] = true;
                for (auto it = b[e].rbegin(); it != b[e].rend(); ++it) {
                    c.push(*it);
                }
            } else {
                c.pop();
                a.push_back(e);
            }
        }
        return a;
    }
    void sol(vector<int>& d, vector<list<int>>& b, string& s, vector<long>& c, vector<int>& e, vector<long>& f, vector<long>& g, vector<bool>& a) {
        long mod = 1000000007;
        for (int h : d) {
            e[h] = 1;
            long j = 0;
            for (int k : b[h]) {
                j = (j * c[e[k]] + f[k]) % mod;
                e[h] += e[k];
            }
            j = (j * 911 + (s[h] - 'a' + 1)) % mod;
            f[h] = j;
            long m = (s[h] - 'a' + 1);
            for (auto it = b[h].rbegin(); it != b[h].rend(); ++it) {
                int k = *it;
                m = (m * c[e[k]] + g[k]) % mod;
            }
            g[h] = m;

            a[h] = (f[h] == g[h]);
        }
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> a(n);
        vector<list<int>> b(n);
        sol4(parent, b);
        vector<long> c = sol3(n);
        vector<int> d = sol2(b, n);
        vector<int> e(n);
        vector<long> f(n);
        vector<long> g(n);
        sol(d, b, s, c, e, f, g, a);
        return a;
    }
};",1427939576
uday,udaykumar21039,382,3607,cpp,"const int MAX_VAL = 1000000;
int arr[MAX_VAL + 1];
bool val = false;
class Solution {
void sol() {
    if (val) return;
    fill(arr, arr + MAX_VAL + 1, 1);
    for (int i = 2; i <= MAX_VAL; ++i) {
        for (int j = 2 * i; j <= MAX_VAL; j += i) {
            arr[j] = i;
        }
    }
    val = true;
}
public:
    int minOperations(vector<int>& nums) {
       sol();
        int cnt = 0;
        int n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int divi = arr[nums[i]];
                if (divi == 1) return -1;
                nums[i] /= divi;
                cnt++;
                if (nums[i] <= 0) return -1;
            }
        }
        return cnt;
    }
};",1427904628
Paul_Liao_1457,liaoyunyang0815,383,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            map<char, int> cnt;
            bool ok = false;
            for (int j = i; j < n; j++) {
                if (ok) {
                    ans++;
                    continue;
                }
                cnt[s[j]]++;
                if (cnt[s[j]] >= k) {
                    ans++;
                    ok = true;
                }
            }
        }
        return ans;
    }
};",1427828319
Paul_Liao_1457,liaoyunyang0815,383,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for (int i = 0; i < target.size(); i++) {
            char c = 'a';
            s += c;
            while (c < target[i]) {
                ans.push_back(s);
                s.pop_back();
                c++;
                s += c;
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1427825422
Paul_Liao_1457,liaoyunyang0815,383,3603,cpp,"class Solution {
public:
    #define ll long long
    #define MOD (ll)(998244353)
    int cnt = 0;
    string all, ss;
    int pos[200005], in[200005];
    vector<int> e[200005];
    long long hash[200005] = {0}, rev[200005] = {0};

    ll fpow(ll a, ll b) {
        ll r = 1;
        while (b) {
            if (b & 1) r = r * a % MOD;
            a = a * a % MOD;
            b >>= 1;
            // cout << ""b = "" << b << endl;
        }
        return r;
    }

    void dfs(int now) {
        //out << ""now = "" << now << endl;
        in[now] = cnt;
        for (int i: e[now]) {
            dfs(i);
        }
        all += ss[now];
        pos[now] = cnt;
        cnt++;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ss = s;
        int n = parent.size();
        for (int i = 1; i < parent.size(); i++) {
            e[parent[i]].push_back(i);
        }
        dfs(0);
        // cout << ""hi"" << endl;
        
        for (int i = 0; i < n; i++) {
            if (i) hash[i] = hash[i-1] * 27 + all[i] - 'a' + 1;
            else hash[i] = all[i] - 'a' + 1;
            hash[i] %= MOD;
        }
        for (int i = n-1; i >= 0; i--) {
            rev[i] = rev[i+1] * 27 + all[i] - 'a' + 1;
            rev[i] %= MOD;
        }
        vector<bool> ans;
        for (int i = 0; i < n; i++) {
            int start = in[i];
            int end = pos[i];
           
            int llev = start, rlev = n - end - 1;
            ll lhash = hash[end];
            if (start) lhash -= hash[start-1] * fpow(27, end - start + 1) % MOD;

            lhash = (lhash % MOD + MOD) % MOD;
            //cout << ""start = "" << start << "" end = "" << end << endl;
            ll rhash = rev[start];

            rhash -= rev[end+1] * fpow(27, end - start + 1) % MOD;
            //cout << ""start : "" << rev[start] << "" "" << rev[end+1] << endl;
            rhash = (rhash % MOD + MOD) % MOD;

            //cout << ""lhash = "" << lhash << "" rhash = "" << rhash << endl;

            /*if (llev > rlev) {
                rhash *= fpow(27, llev - rlev);
                rhash %= MOD;
            } else if (llev < rlev) {
                lhash *= fpow(27, rlev - llev);
                lhash %= MOD;
            }*/

            if (lhash == rhash) ans.push_back(true);
            else ans.push_back(false);
        }
        return ans;

    }
};",1427938900
Paul_Liao_1457,liaoyunyang0815,383,3607,cpp,"class Solution {
public:
    int prop[2000005];
    int minOperations(vector<int>& nums) {
        int maxn = 0;
        for (int i:nums) maxn = max(maxn, i);
        for (int i = 0; i <= maxn; i++) prop[i] = 1;
        for (int x = 2; x <= maxn; x++) if (prop[x] == 1) {
            for (int i = x; i <= maxn; i += x) {
                prop[i] = max(prop[i], i / x);
            }
        }
        int ans = 0;
        for (int i = nums.size()-1; i > 0; i--) {
            while (nums[i-1] > nums[i]) {
                if (prop[nums[i-1]] == 1) return -1;
                //cout << nums[i-1] << "" "" << prop[nums[i-1]] << endl;
                //cout << nums[i] << endl;
                //cout << ""00000"" << endl;
                nums[i-1] /= prop[nums[i-1]];
                ans++;
            }
        }
        return ans;
    }
};",1427941231
rip.nsk,rip,384,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int RR=0;vector<array<int,26>>C(1);
        for(auto c:s){C.push_back(C.back());++C.back()[c-'a'];}
        for(int l=0;l<=s.size();++l)for(int r=l;++r<=s.size();){
            for(int c=0;c<26;++c)if(C[r][c]-C[l][c]>=k){++RR;break;}
        }
        return RR;
    }
};",1427836202
rip.nsk,rip,384,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string>RR;string s;
        for(auto c:t){
            s.push_back('a');
            RR.push_back(s);
            while(s.back()!=c){
                s.back()++;RR.push_back(s);
            }
        }
        return RR;
    }
};",1427825637
rip.nsk,rip,384,3603,cpp,"struct manacher_t{
    array<vector<int>,2>D;
    void set(const string&s){
        D[0].resize(s.size());D[1]=D[0];
        for(int p=0;p<2;++p)for(int l=0,i=0,r=-1,k;i<s.size();++i){
            k=i>r?1-p:min(D[p][l+r-i+p],r-i+p);
            while(0<=i-k-p&&i+k<s.size()&&s[i-k-p]==s[i+k])++k;
            D[p][i]=k;if(i+k>=r){l=i-k+1-p;r=i+k-1;}
        }
    }
    bool isp(int l,int r){
        if(l>r)return false;if(l==r)return true;
        int c=l+(r-l)/2,w=(1+r-l)/2,k=(1+r-l)%2;
        return k==0?D[0][c]>=w:D[1][c]>=w;
    }
};

class Solution {
    string S;vector<bool>RR;vector<vector<int>>C;
    string rr;vector<int>cc,vv;manacher_t M;int V;
    int dfs(int r){
        for(auto c:C[r])cc[r]+=dfs(c);rr.push_back(S[r]);vv[r]=V++;return++cc[r];
    };
    void dfs2(int r){
        int v=vv[r]-cc[r]+1;
        RR[r]=M.isp(v,v+cc[r]);for(auto c:C[r])dfs2(c);
    }
public:
    vector<bool> findAnswer(vector<int>&P, string _S) {
        S=move(_S);RR.resize(P.size());C.resize(P.size());
        cc.resize(P.size());vv.resize(P.size());
        for(int i=1;i<P.size();++i)C[P[i]].push_back(i);
        dfs(0);M.set(rr);dfs2(0);return RR;
    }
};",1427949465
rip.nsk,rip,384,3607,cpp,"template<size_t M=1<<16>struct primes_t:vector<int> {
    using w_t=uint64_t; static constexpr size_t W=sizeof(w_t); array<w_t,M/W+1>S;
    w_t&_w(w_t x){return S[x/W];}w_t _b(w_t x){return 1ULL<<x%W;}bool _p(w_t x){return _w(x)&_b(x);}
    primes_t() {
        for(w_t&s:S)s=0xAAAAAAAAAAAAAAAAULL;S[0]^=6;
        for(w_t b=3;b*b<M;b+=2)if(_p(b))for(w_t p=b*b;p<M;p+=2*b)_w(p)&=~_b(p);
        for(w_t p=2;p<M;++p)if(_p(p))push_back(p);
    }
    template<typename F>void fact(w_t x,F f){
        for(auto p:*this){int c=0;for(;x%p==0;++c)x/=p;if(c)f(p,c);if(x<p)break;}if(x>1)f(x,1);
    }
};

primes_t<1'000'000>P;
class Solution {
public:
    int minOperations(vector<int>& x) {
        int RR=0;ranges::reverse(x);
        for(int i=0;++i<x.size();){
            if(x[i]>x[i-1]){
                for(auto p:P){
                    if(p>=x[i])return-1;
                    if(x[i]%p)continue;
                    if(p>x[i-1])return-1;
                    x[i]=p;++RR;break;
                }
            }
        }
        return RR;
    }
};",1427852503
RWBY27,Sayan_244,385,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.length();
        for(int i = 0; i < n; i++) {
            int maxn = 0;
            vector <int> freq(26);
            for(int j = i; j < n; j++) {
                freq[s[j] - 'a'] += 1;
                maxn = max(maxn, freq[s[j] - 'a']);
                if (maxn >= k) {
                    ans += 1;
                }
            }
        }
        return ans;
    }
};",1427832703
RWBY27,Sayan_244,385,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s;
        int idx = 0;
        vector <string> fin;
        while (s != target) {
            string cpy = s;
            for(char i = 'a'; i <= target[idx]; i++) {
                string temp = cpy;
                temp.push_back(i);
                fin.push_back(temp);
            }
            s.push_back(target[idx]);
            idx += 1;
        }
        return fin;
    }
};",1427828272
RWBY27,Sayan_244,385,3603,cpp,"// #define fastio()                  \
//     ios_base::sync_with_stdio(0); \
//     cin.tie(0);                   \
//     cout.tie(0)
#define pb push_back
#define show(x) cout << (#x) << "" : "" << x << endl;
//typedef __int128 bigll;
typedef long long ll;
#define ull unsigned long long
#define ld long double
#define pow power
#define mp make_pair
#define ff first
#define ss second
#define pii pair<int, int>
#define pll pair<long long, long long>
#define sq(x) ((x) * (x))
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define siz(a) int((a).size())
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define Forl(i,a,b) for(ll (i)=(a);(i) < (b); ++(i))
#define Forn(i,a,b) for(int (i)=(a);(i) >= (b); --(i))
#define Fornl(i,a,b) for(ll (i)=(a);(i) >= (b); --(i))
#define endl ""\n""
#define pi 3.14159265
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
const ll mod = 1000 * 1000 * 1000 + 7;
const ll mod1 = 998244353;
const ll INF  = 1ll*1000*1000*1000*1000*1000*1000 + 7; 

vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector <int> dfsOrd;
vector <int> subTree;
vector <vector <int>> adj;
vector <int> mapper;

//need to add step 4
vector<int> manacher(string s, vector <int> &Ord) {
    string t;
    int len = 0;
    int idx = 0;

    for(auto c: s) {
      t += string(""#"") + c;
      len += 2;
      mapper[Ord[idx]] = len - 1;
      //print(Ord[idx], len);
      idx += 1;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}



void dfs(int par) {
  for(auto &nei : adj[par]) {
    dfs(nei);
    subTree[par] += subTree[nei]; //step 3
  }
  dfsOrd.pb(par);
  return;
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
      int n = siz(parent);
      adj.resize(n);
      mapper.resize(n);
      subTree.resize(n, 1);

      for(int i = 1; i < siz(parent); i++) {
        adj[parent[i]].pb(i);
      }
      dfs(0);
      //print(dfsOrd); //step 1
      // for(auto & c : dfsOrd) {
      //   print(c, subTree[c]);
      // }
      string act;
      for(auto & c : dfsOrd) {
        act.pb(s[c]); // step 2
      }
      //print(act); 

      vector <int> finPal = manacher(act, dfsOrd);
      vector <bool> ANSWER(n);

      for(auto & c : dfsOrd) {
        int actIdx = mapper[c];
        int tlen = subTree[c];
        int pivot = actIdx - tlen;

        //print(c, actIdx, tlen, pivot);
        if (pivot + finPal[pivot] - 1 >= actIdx) {
          ANSWER[c] = true;
        }
      }

      mapper = subTree = dfsOrd = {};
      adj = {};

      // for(auto c : ANSWER) {
      //   cout<<c<<"" "";
      // }
      //print();

      return ANSWER;
    }
};",1427957505
RWBY27,Sayan_244,385,3607,cpp,"// #define fastio()                  \
//     ios_base::sync_with_stdio(0); \
//     cin.tie(0);                   \
//     cout.tie(0)
#define pb push_back
#define show(x) cout << (#x) << "" : "" << x << endl;
//typedef __int128 bigll;
typedef long long ll;
#define ull unsigned long long
#define ld long double
#define pow power
#define mp make_pair
#define ff first
#define ss second
#define pii pair<int, int>
#define pll pair<long long, long long>
#define sq(x) ((x) * (x))
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define siz(a) int((a).size())
#define For(i,a,b) for(int (i)=(a);(i) < (b); ++(i))
#define Forl(i,a,b) for(ll (i)=(a);(i) < (b); ++(i))
#define Forn(i,a,b) for(int (i)=(a);(i) >= (b); --(i))
#define Fornl(i,a,b) for(ll (i)=(a);(i) >= (b); --(i))
#define endl ""\n""
#define pi 3.14159265
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
const ll mod = 1000 * 1000 * 1000 + 7;
const ll mod1 = 998244353;
const ll INF  = 1ll*1000*1000*1000*1000*1000*1000 + 7; 

const ll maxn = 1e6l + 1;
bool flag = false;
vector <ll> divi(maxn, -1);

void compute() {
  for(ll i = 2; i < maxn; i++) {
    for(ll j = 2 * i; j < maxn; j += i) {
      divi[j] = max(divi[j], i);
    }
  }
return;
}

class Solution {
public:
    int minOperations(vector<int>& nums) {
      if (!flag) {
        compute();
        flag = true;
      }

      ll n = siz(nums);
      ll ans = INF;

      vector <vector <ll>> nums2;
      vector <vector <ll>> dp;

      for(ll i = 0; i < n; i++) {
        ll mem = nums[i];
        //print(mem, divi[mem]);
        vector <ll> temp, temp2;
        while (divi[mem] != -1) {
          temp.pb(mem);
          mem /= divi[mem];
        }

        temp.pb(mem);
        //print(temp);
        nums2.pb(temp);
        temp2.resize(siz(temp), INF);
        dp.pb(temp2);
      }

      for(ll i = 0; i < siz(dp[0]); i++) {
        dp[0][i] = i;
      }

      for(ll i = 0; i < n - 1; i++) {
        bool temp = false;
        for(ll j = 0; j < siz(dp[i]); j++) {
          for(ll k = 0; k < siz(dp[i + 1]); k++) {
            if (nums2[i][j] <= nums2[i + 1][k]) {
              temp = true;
              dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + k);
            }
          }
        }
        if (!temp) {
          return -1;
        }
      }

      for(ll i = 0; i < siz(dp[n - 1]); i++) {
        ans = min(ans, dp[n - 1][i]);
      }
      if (ans == INF) {
        ans = -1;
      }
      return (int)ans;
    }
};
",1427885627
Srikkanth R,srikkanthr,387,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<int> freq(26, 0);
        int ret = 0;
        for (int i=0;i<n;++i) {
            fill(freq.begin(), freq.end(), 0);
            bool ok = false;
            for (int j=i;j<n;++j) {
                freq[s[j]-'a'] += 1;
                ok |= freq[s[j]-'a'] >= k;
                ret += ok;
            }
        }
        return ret;
    }
};",1427842899
Srikkanth R,srikkanthr,387,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur = """";
        vector<string> ret;
        for (auto c : target) {
            for (char d = 'a';d <= c; d++) {
                cur += d;
                ret.push_back(cur);
                cur.pop_back();
            }
            cur += c;
        }
        return ret;
    }
};",1427833973
Srikkanth R,srikkanthr,387,3603,cpp,"class Solution {
public:
    vector<int> manacher(string s) {
        int n = s.size();
        vector<int> go(2 * n + 1, 0);
        string t = ""#"";
        for (auto c : s) {
            t += c;
            t += '#';
        }
        go[0] = 0;
        n = t.size();
        int center = 0, r = 0;
        for (int i=1;i<n;++i) {
            int offset = (i - center);
            int ir = center - offset;
            int match = min(r - i, (ir >= 0 ? go[ir] : 0));
            while (i + match + 1 < n && i >= match + 1 && t[i + match + 1] == t[i - match - 1]) {
                ++match;
            }
            go[i] = match;
            if (r < i + match) {
                r = i + match;
                center = i;
            }
        }
        // cout << t << '\n';
        return go;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int> > g(n);
        for (int i=1;i<n;++i) {
            int j = parent[i];
            g[j].push_back(i);
        }
        for (int i=0;i<n;++i) if (!g[i].empty()) {
            sort(g[i].begin(), g[i].end());
        }
        vector<bool> ret(n, false);
        string dfsStr = """";
        vector<int> sub(n, 0), dfs_in(n, 0);
        dfs_in[0] = 0;
        std::function<void(int)> dfs = [&](int u) {
            sub[u] += 1;
            int cur = 0;
            for (auto &v : g[u]) {
                dfs_in[v] = dfs_in[u] + cur;
                dfs(v);
                cur += sub[v];
            }
            sub[u] += cur;
            dfsStr += s[u];
        };
        dfs(0);

        auto go = manacher(dfsStr);
        auto isPalin = [&](int ell, int arr) {
            int sz = arr - ell + 1;
            if (sz & 1) {
                int mid = (ell + arr) >> 1;
                int ind = 2 * mid + 1, lim = 2 * arr + 1;
                return ind + go[ind] >= lim;
            } else {
                int ind = ell + arr + 1;
                int lim = 2 * arr + 1;
                return ind + go[ind] >= lim;
            }
        };
        // ""abcba""

        for (int i=0;i<n;++i) {
            int ell = dfs_in[i], arr = dfs_in[i] + sub[i] - 1;
            // cout << ell << "","" << arr << '\n';
            ret[i] = isPalin(ell, arr);
        }
        return ret;
    }
};",1427941442
Srikkanth R,srikkanthr,387,3607,cpp,"const int N = (int)1e6 + 5;
class Solution {
    int sp[N];
public:
    void computeSP(int M) {
        for (int i=1;i<M;++i) sp[i] = i;
        for (int i=2;i*1LL*i<M;++i) if (sp[i] == i) {
            for (long long j=i*1LL*i;j<N;j+=i) {
                sp[j] = min(sp[j], i);
            }
        }
    }
    int minOperations(vector<int>& v) {
        int n = v.size();
        int mx = 0;
        for (auto &x : v) mx = max(mx, x);
        computeSP(mx + 3);
        vector<vector<int> > dp(2, vector<int>(n, (int)1e9));
        dp[0][0] = 0;
        dp[1][0] = 1;
        for (int i=1;i<n;++i) {
            if (v[i-1] <= v[i]) {
                dp[0][i] = min(dp[0][i], dp[0][i-1]);
            }
            if (sp[v[i-1]] <= v[i]) {
                dp[0][i] = min(dp[0][i], dp[1][i-1]);
            }
            if (v[i-1] <= sp[v[i]]) {
                dp[1][i] = min(dp[1][i], dp[0][i-1] + 1);
            }
            if (sp[v[i-1]] <= sp[v[i]]) {
                dp[1][i] = min(dp[1][i], dp[1][i-1] + 1);
            }
        }
        int go = min(dp[0][n-1], dp[1][n-1]);
        if (go > n) go = -1;
        return go;
    }
};",1427862557
Zheyuan Wu,Trance-0,388,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        order=collections.defaultdict(int)
        lo=0
        res=0
        cnt=False
        for hi,e in enumerate(s):
            order[e]+=1
            # print(order)
            # count subarray terminate on hi
            while order[e]>=k:
                order[s[lo]]-=1
                lo+=1
                cnt=True
            if cnt:res+=lo
        return res
        ",1427843104
Zheyuan Wu,Trance-0,388,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur=""a"";
        int n=target.size(),i=0;
        vector<string>res;
        while (cur!=target){
            res.push_back(cur);
            if (cur[i]==target[i]){
                i++;
                cur+='a';
            }else{
                cur[i]+=1;
            }
        }
        res.push_back(target);
        return res;
    }
};",1427830630
Zheyuan Wu,Trance-0,388,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        childs=collections.defaultdict(list)
        root=-1
        n=len(parent)
        for i,e in enumerate(parent):
            if e==-1: root=i
            childs[e].append(i)
        # print(childs.items())
        res=[False]*n
        def dfs(t):
            # return hash string, reverse hash sting, half hash 
            bs=s[t]
            for i in childs[t][::-1]:
                bs+=dfs(i)
            n=len(bs)//2
            # print(a[:n],a[-n:][::-1])
            res[t]=(n==0 or bs[:n]==bs[-n:][::-1])
            return bs
        dfs(0)
        # for i in range(len(parent)):
        #     print(dfs(i))
        return res",1427933480
Zheyuan Wu,Trance-0,388,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        @lru_cache(None)
        def lpf(a):
            if a%2==0: return 2
            i=3
            while i*i<=a:
                if a%i==0:
                    return i
                i+=2
            return a
        n=len(nums)
        if n==1: return 0
        res=0
        # ni=lpf(nums[0])
        # if nums[0]!=ni:
        #     res+=1   
        # # print(nums[0],ni)
        # nums[0]=lpf(nums[0])
        for i in range(n-2,-1,-1):
            if nums[i]>nums[i+1]:
                ni=lpf(nums[i])
                # print(nums[i],ni)
                if ni!=nums[i]:
                    res+=1   
                    nums[i]=ni
                if nums[i]>nums[i+1]:
                    return -1
        return res",1427876820
ws1255,ws1255,389,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        Map<Character, Queue<Integer>> map = new HashMap<>();
        char[] ch = s.toCharArray();
        int n = ch.length;
        int res = 0;
        for(int i = 0; i < n; i++) {
            map.computeIfAbsent(ch[i], f -> new LinkedList<>()).offer(i);
            int last = -1;
            for(Queue<Integer> queue : map.values()) {
                while(queue.size() > k) queue.poll();
                if(queue.size() == k) last = Math.max(last, queue.peek());
            }
            res += last + 1;
        }
        return res;
    }
}",1427834513
ws1255,ws1255,389,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        StringBuilder sb = new StringBuilder("""");
        for(char c : target.toCharArray()) {
            for(char cur = 'a'; cur <= c; cur++) {
                res.add(sb.toString() + cur);
                if(cur == c) sb.append(cur);
            }
        }
        return res;
    }
}",1427825591
ws1255,ws1255,389,3603,java,"class Solution {
    TreeMap<Integer, TreeSet<Integer>> adj = new TreeMap<>();
    Map<Integer, Integer> count = new HashMap<>();
    boolean[] res;
    public boolean[] findAnswer(int[] parent, String s) {
        char[] ch = s.toCharArray();
        int n = parent.length;
        res = new boolean[n];
        if(n == 1) {
            Arrays.fill(res, true);
            return res;
        }
        for(int i = 1; i < n; i++) {
            int p = parent[i], cur = i;
            adj.computeIfAbsent(p, f -> new TreeSet<>()).add(cur);
        }
        List<Integer> list = new ArrayList<>();
        helper(0, list);
        // System.out.println(""list: "" + list);
        // System.out.println(""count: "" + count);
        StringBuilder sb = new StringBuilder();
        
        for(int num : list) {
            sb.append(ch[num]);
        }
        // System.out.println(""sb: "" + sb);
        
        ch = helper(sb.toString()).toCharArray();
        // System.out.println(""ch: "" + Arrays.toString(ch));
        n = ch.length;
        // System.out.println(""n: "" + n);
        int[] arr = new int[n];
        int c = 0, r = 0;
        int index = 0, len = 0;
        for(int i = 1; i < n - 1; i++) {
            int i_mirror = c * 2 - i;
            arr[i] = i < r ? Math.min(r - i, arr[i_mirror]) : 0;
            while(ch[i - arr[i] - 1] == ch[i + arr[i] + 1]) arr[i]++;
            if(i + arr[i] > r) {
                r = i + arr[i];
                c = i;
            }
        }
        
        Map<Integer, Integer> mapping = new HashMap<>();
        int pos = 0;
        for(int num : list) {
            mapping.put(num, pos);
            pos++;
        }
        
        // System.out.println(""mapping: "" + mapping);
        // System.out.println(""arr: "" + Arrays.toString(arr));
        for(int i = 0; i < res.length; i++) {
            int cnt = count.get(i);
            int p = mapping.get(i); // (p + 1) * 2;
            // System.out.println(""i: "" + i + "", cnt: "" + cnt + "", p: "" + p);
            if(cnt % 2 == 0) {
                int right = (p + 1) * 2;
                int left = (p - cnt + 1 + 1) * 2;
                // System.out.println(""left: "" + left + "", right: "" + right);
                int map = left + (right - left) / 2;
                int l = arr[map];
                if(p - cnt + l >= p) res[i] = true;
                else res[i] = false;
            } else {
                int m = p - (cnt / 2);
                int map = (m + 1) * 2;
                int l = arr[map];
                if(m + l / 2 >= p) res[i] = true;
                else res[i] = false;
            }
            // System.out.println(""res[i]: "" + res[i]);
            
        }
        
        return res;
    }
    
    int helper(int cur, List<Integer> list) {
        int res = 1;
        for(int next : adj.getOrDefault(cur, new TreeSet<>())) {
            res += helper(next, list);
        }
        list.add(cur);
        count.put(cur, res);
        return res;
    }
    
    String helper(String s) {
        char[] ch = s.toCharArray();
        int n = ch.length;
        if(n == 0) return ""^$"";
        StringBuilder sb = new StringBuilder();
        sb.append('^');
        for(char c : ch) {
            sb.append('#').append(c);
        }
        sb.append('#').append('$');
        return sb.toString();
    }
}",1427957882
ws1255,ws1255,389,3607,java,"class Solution {
    boolean[] notprime = new boolean[1000000 + 1];
    public int minOperations(int[] nums) {
        int n = nums.length;
        int res = 0, prev = nums[n - 1];
        
        notprime[0] = notprime[1] = true;
        for(int i = 2; i * i < notprime.length; i++) {
            if(notprime[i]) continue;
            for(int j = 2; i * j < notprime.length; j++) {
                notprime[i * j] = true;
            }
        }
        
        for(int i = n - 2; i >= 0; i--) {
            if(!notprime[nums[i]] && nums[i] > nums[i + 1]) return -1;
            if(nums[i] <= nums[i + 1]) continue;
            int num = nums[i];
            // System.out.println(""num: "" + num);
            outer:for(int j = 2; j * j <= num; j++) {
                // System.out.println(""j: "" + j );
                while(num % j == 0) {
                    // System.out.println(""find j: "" + j );
                    int a = j, b = num / j;
                    int max = Math.max(a, b);
                    if(max == num) break outer;
                    num /= max;
                    res++;
                    if(num <= nums[i + 1]) break outer;
                }
            }
            if(num > nums[i + 1]) return -1;
            nums[i] = num;
        }
        // System.out.println(Arrays.toString(nums));
        return res;
    }
}",1427864642
inam yadav,inam1995,390,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        unordered_map<char, int> mpp;
        int ans_inam = 0;
        int l = 0;

        for (int i = 0; i < n; i++) {
            mpp[s[i]]++;
            while (mpp[s[i]] >= k) { 
                ans_inam += n - i;
                mpp[s[l]]--;
                l++;
            }
        }

        return ans_inam;
    }
};
",1427829834
inam yadav,inam1995,390,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans_inam;
        string curr_abhi = """"; 
        for (char c : target) {
            curr_abhi += 'a';
            ans_inam.push_back(curr_abhi); 
            while (curr_abhi.back() != c) {
                curr_abhi.back() = (curr_abhi.back() == 'z') ? 'a' : curr_abhi.back() + 1;
                ans_inam.push_back(curr_abhi); 
            }
        }
        return ans_inam;
    }
};
",1427825906
inam yadav,inam1995,390,3603,cpp,"class Solution {
public:
    int ord(char c) {
        return static_cast<int>(c);
    }
    long long base1 = 911382628, mod1 = 1e9 + 7;
    long long base2 = 3571, mod2 = 1e9 + 9;
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> child_inam(n);
        int max_lnt_abhi = n + 1;
        for (int i = 1; i < n; i++) {
            child_inam[parent[i]].push_back(i);
        }
        

        vector<long long> pow1_inam(max_lnt_abhi, 1);
        vector<long long> pow2_inam(max_lnt_abhi, 1);
        vector<long long> frwd1_inam(n, 0), rev1_inam(n, 0);
        vector<long long> frwd2_inam(n, 0), rev2_inam(n, 0);
        vector<int> lnt_inam(n, 1);
        vector<int> in_grp(n, 0);
        deque<int> dq;

        for (int i = 1; i < max_lnt_abhi; i++) {
            pow1_inam[i] = (pow1_inam[i - 1] * base1) % mod1;
            pow2_inam[i] = (pow2_inam[i - 1] * base2) % mod2;
        }
        for (int i = 0; i < n; i++) {
            in_grp[i] = child_inam[i].size();
            if (in_grp[i] == 0) {
                dq.push_back(i);
            }
        }

        while (!dq.empty()) {
            int node = dq.front();
            dq.pop_front();

            long long hash1 = 0;
            for (int i : child_inam[node]) {
                hash1 = (hash1 * pow1_inam[lnt_inam[i]] + frwd1_inam[i]) % mod1;
            }
            hash1 = (hash1 * base1 + ord(s[node])) % mod1;
            frwd1_inam[node] = hash1;

            long long cmb_hash1 = ord(s[node]);
            for (auto it = child_inam[node].rbegin(); it != child_inam[node].rend(); it++) {
                cmb_hash1 = (cmb_hash1 * pow1_inam[lnt_inam[*it]] + rev1_inam[*it]) % mod1;
            }
            rev1_inam[node] = cmb_hash1;

            long long combined_hash2 = 0;
            for (int i : child_inam[node]) {
                combined_hash2 = (combined_hash2 * pow2_inam[lnt_inam[i]] + frwd2_inam[i]) % mod2;
            }
            combined_hash2 = (combined_hash2 * base2 + ord(s[node])) % mod2;
            frwd2_inam[node] = combined_hash2;

            long long cmb_rev2_hash = ord(s[node]);
            for (auto it = child_inam[node].rbegin(); it != child_inam[node].rend(); ++it) {
                cmb_rev2_hash = (cmb_rev2_hash * pow2_inam[lnt_inam[*it]] + rev2_inam[*it]) % mod2;
            }
            rev2_inam[node] = cmb_rev2_hash;

            int total_length = 1;
            for (int i : child_inam[node]) {
                total_length += lnt_inam[i];
            }
            lnt_inam[node] = total_length;

            if (node != 0) {
                int parent_node = parent[node];
                in_grp[parent_node]--;
                if (in_grp[parent_node] == 0) {
                    dq.push_back(parent_node);
                }
            }
        }
        vector<bool> inam_ans(n);
        for (int i = 0; i < n; i++) {
            inam_ans[i] = (frwd1_inam[i] == rev1_inam[i]) && (frwd2_inam[i] == rev2_inam[i]);
        }

        return inam_ans;
    }
};",1427960038
inam yadav,inam1995,390,3607,cpp,"class Solution {
public:
    int solve_rekha(int x) {
        if (x <= 1) return 1;  
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                return x / i; 
            }
        }
        return 1;  
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans_inam  = 0;

        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                int abhi_inam = solve_rekha(nums[i]);
                if (abhi_inam == 1) {
                    return -1;
                }
                nums[i] /= abhi_inam; 
                ans_inam ++;
            }
        }

        return ans_inam ;
    }
};",1427932952
phongtran82148,phongtran82148,391,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> occur(26, 0);
        int output = 0;
        int ptr2 = 0;
        bool flag = false;
        for (int ptr1 = 0; ptr1 < s.size(); ptr1++) {
            while (!flag && ptr2 < s.size()) {
                int tmp = ++occur[s[ptr2++] - 'a'];
                if (tmp == k) flag = true;
            }
            if (flag) output += (s.size() - ptr2 + 1);
            int tmp = --occur[s[ptr1] - 'a'];
            if (tmp == k - 1) flag = false;
        }
        return output;
    }
};",1427843611
phongtran82148,phongtran82148,391,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        output = ['']
        for i in range(len(target)):
            output.append(output[-1] + 'a')
            for j in range(1, ord(target[i]) - ord('a') + 1):
                output.append(output[-1][:-1] + chr(ord('a') + j))

        return output[1:]",1427830612
phongtran82148,phongtran82148,391,3603,cpp,"vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}

vector<int> manacher(string s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    auto res = manacher_odd(t + ""#"");
    return vector<int>(begin(res) + 1, end(res) - 1);
}

class Solution {
public:
    string ss = """";
    string _s;
    vector<pair<int, int>> qs;
    vector<vector<int>> children;
    int dfs(int node) {
        int sz = 0;
        for (auto &child: children[node]) {
            sz += dfs(child);
        }
        ss += _s[node];
        sz++;
        qs[node] = make_pair(ss.size() - sz, ss.size());
        return sz;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        _s = s;
        qs = vector<pair<int, int>>(parent.size());
        children = vector<vector<int>>(parent.size());
        for (int i = 1; i < parent.size(); i++) {
            children[parent[i]].push_back(i);
        }
        dfs(0);
        auto ls = manacher(ss);
        vector<bool> output;
        for (auto &q: qs) {
            int beg = q.first;
            int end = q.second;
            output.push_back(ls[beg + end - 1] >= end - beg);
        }
        return output;
    }
};",1427951989
phongtran82148,phongtran82148,391,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int mx = -1;
        for (auto &num: nums) mx = max(num, mx);
        mx++;
        vector<int> sml(mx, -1);
        for (int i = 2; i < mx; i++) {
            if (sml[i] != -1) continue;
            for (int j = i; j < mx; j += i) {
                if (sml[j] != -1) continue;
                sml[j] = i;
            }
        }
        int cur = 1000001;
        int output = 0;
        for (int i = nums.size() - 1; i >= 0; i--) {
            if (nums[i] <= cur) {
                cur = nums[i];
                continue;
            };
            if (sml[nums[i]] > cur) return -1;
            cur = sml[nums[i]];
            output++;
        }
        return output;
    }
};",1427863992
Vihari Vemuri,TheZwischenzug,392,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] cnts = new int[26];
        int left = 0;
        int right = 0;
        int subsCnt = 0;
        while (left < s.length()){
            int maxFreq = Arrays.stream(cnts).max().getAsInt();
            while (maxFreq < k && right < s.length()){
                int c = s.charAt(right)-'a';
                cnts[c]++;
                maxFreq = Math.max(maxFreq, cnts[c]);
                right++;
            }
            if (maxFreq >= k) subsCnt += s.length()-right+1;
            cnts[s.charAt(left)-'a']--;
            left++;
        }
        return subsCnt;
    }
}",1427857474
Vihari Vemuri,TheZwischenzug,392,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> list =  new ArrayList<>();
        for (int i = 0; i < target.length(); i++){
            String last = target.substring(0, i) + ""a"";
            list.add(last);
            char c = target.charAt(i);
    
            for (int j = 'b'; j <= c; j++){
                list.add(target.substring(0,i)+ (char) j);
            }
    

        }
        return list;
    }
}",1427843868
Vihari Vemuri,TheZwischenzug,392,3603,java,"class SubtreeHash{
    long hash;
    long revHash;
    int size;


    public SubtreeHash(long hash, long revHash, int size) {
        this.hash = hash;
        this.revHash = revHash;
        this.size = size;
    }
}
class Solution {

    private static final Random random = new Random();
    private static final int[] LARGE_PRIMES = {
            1000000007,
            1000000009,
            1000000033,
            1000000037,
            1000000039
    };
    private static final int[] SMALL_PRIMES = {
            101, 211, 307, 419, 523
    };
    private long base, mod;
    private long[] basePowers;
    private void chooseBaseAndMod(){
        base = SMALL_PRIMES[random.nextInt(SMALL_PRIMES.length)];
        mod = LARGE_PRIMES[random.nextInt(LARGE_PRIMES.length)];
    }
    private void computeBasePowers(int n){
        basePowers = new long[n+1];
        basePowers[0] = 1;
        for (int i = 1; i <= n; i++) basePowers[i] = (base*basePowers[i-1])%mod;
    }

    private SubtreeHash combine(SubtreeHash a, SubtreeHash b){
        if (a == null) return b;
        if (b == null) return a;

        long hash = (a.hash + (basePowers[a.size]*b.hash)%mod)%mod;
        long revHash = (b.revHash + (basePowers[b.size]*a.revHash)%mod)%mod;
        return new SubtreeHash(hash, revHash, a.size+b.size);
    }
    private List<Integer>[] tree;
    private String s;
    private boolean[] isPalim;
    private SubtreeHash dfs(int node){
        SubtreeHash subtreeHash = null;
        for (int v : tree[node]){
            SubtreeHash vHash = dfs(v);
            subtreeHash = combine(subtreeHash, vHash);
        }

        SubtreeHash nodeHash = new SubtreeHash(s.charAt(node), s.charAt(node), 1);
        subtreeHash = combine(subtreeHash, nodeHash);

        isPalim[node] = subtreeHash.hash == subtreeHash.revHash;
        return subtreeHash;
    }
    private void readTree(int[] parent){
        int n = parent.length;
        tree = new List[n];
        for (int i = 0; i < n; i++) tree[i] = new ArrayList<>();
        for (int i = 0; i < n; i++){
            int p = parent[i];
            if (p != -1) tree[p].add(i);
        }
        for (int i = 0; i< tree.length; i++) Collections.sort(tree[i]);
    }


    public boolean[] findAnswer(int[] parent, String s) {
        this.s = s;
        int n = parent.length;
        isPalim = new boolean[n];
        readTree(parent);
        chooseBaseAndMod();
        computeBasePowers(n);
        dfs(0);
        return isPalim;
    }
}",1427944028
Vihari Vemuri,TheZwischenzug,392,3607,java,"class Solution {
    private int max;
    private int[] spf;
    private void computeSpf(){
        spf = new int[max+1];
        for (int num = 2; num <= max; num += 2) spf[num] = 2;
        for (int num = 3; num <= max; num += 2){
            if (spf[num] != 0) continue;
            for (int mult = num; mult <= max; mult += 2*num){
                if (spf[mult] == 0) spf[mult] = num;
            }
        }
    }
    public int minOperations(int[] nums) {
        max = Arrays.stream(nums).max().getAsInt();
        computeSpf();
        int ops = 0;
        
        for (int i = nums.length-2; i >= 0; i--){
            if (nums[i] > nums[i+1]){
                nums[i] = spf[nums[i]];
                ops++;
                if (nums[i] > nums[i+1]) return -1;
            }
        }
        return ops;
    }
}",1427881991
imNotDrunk,hank90555,394,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int len = s.length();
        int ans{0}, count{0};
        vector<int> nums(26, 0);
        int maximum{0};
        for (int i = 0 ; i < len ; i ++) {
            nums = vector<int>(26, 0);
            nums[s[i] - 'a']++;
            maximum = 1;
            if (k == 1) ans++;
            for (int j = i + 1; j < len ; j ++) {
                nums[s[j] - 'a']++;
                if (nums[s[j] - 'a'] > maximum) maximum = nums[s[j] - 'a'];
                if (maximum >= k) ans++;
            }
        }
        return ans;
    }
};",1427847793
imNotDrunk,hank90555,394,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        if (target == """") return ans;
        string traverse(""a"");
        ans.push_back(traverse);
        int idx{0};
        while (traverse != target) {
            if (traverse[idx] != target[idx]) {
                traverse[idx] = traverse[idx] + 1;
            } else {
                idx++;
                traverse += ""a"";
            }
            ans.push_back(traverse);
        }
        return ans;
    }
};",1427828107
imNotDrunk,hank90555,394,3603,cpp,"class Solution {
    using ull = uint64_t;
    const ull mod1 = 1000000007ULL;
    const ull mod2 = 1000000009ULL;
    const ull base1 = 911ULL;
    const ull base2 = 1597ULL;

    vector<vector<int>> tree;
    string s;
    vector<bool> ans;

    struct HashInfo {
        ull hash_f1, hash_r1, pow_base1;
        ull hash_f2, hash_r2, pow_base2;
    };

    HashInfo dfs(int node) {
        // 初始化當前節點的哈希信息
        HashInfo curr;
        curr.hash_f1 = curr.hash_r1 = 0;
        curr.pow_base1 = 1;
        curr.hash_f2 = curr.hash_r2 = 0;
        curr.pow_base2 = 1;

        // 按照子節點編號遞增的順序遍歷
        sort(tree[node].begin(), tree[node].end());

        // 遍歷子節點，合併子節點的哈希信息
        for (int child : tree[node]) {
            HashInfo childInfo = dfs(child);

            // 更新當前節點的哈希值（合併子節點）
            curr.hash_f1 = (curr.hash_f1 * childInfo.pow_base1 % mod1 + childInfo.hash_f1) % mod1;
            curr.hash_r1 = (childInfo.hash_r1 * curr.pow_base1 % mod1 + curr.hash_r1) % mod1;
            curr.pow_base1 = curr.pow_base1 * childInfo.pow_base1 % mod1;

            curr.hash_f2 = (curr.hash_f2 * childInfo.pow_base2 % mod2 + childInfo.hash_f2) % mod2;
            curr.hash_r2 = (childInfo.hash_r2 * curr.pow_base2 % mod2 + curr.hash_r2) % mod2;
            curr.pow_base2 = curr.pow_base2 * childInfo.pow_base2 % mod2;
        }

        // 添加當前節點的字元
        ull char_value1 = s[node];
        curr.hash_f1 = (curr.hash_f1 * base1 % mod1 + char_value1) % mod1;
        curr.hash_r1 = (char_value1 * curr.pow_base1 % mod1 + curr.hash_r1) % mod1;
        curr.pow_base1 = curr.pow_base1 * base1 % mod1;

        ull char_value2 = s[node];
        curr.hash_f2 = (curr.hash_f2 * base2 % mod2 + char_value2) % mod2;
        curr.hash_r2 = (char_value2 * curr.pow_base2 % mod2 + curr.hash_r2) % mod2;
        curr.pow_base2 = curr.pow_base2 * base2 % mod2;

        // 判斷是否為回文
        if (curr.hash_f1 == curr.hash_r1 && curr.hash_f2 == curr.hash_r2) {
            ans[node] = true;
        } else {
            ans[node] = false;
        }

        return curr;
    }

public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        this->s = s;
        tree.resize(n);
        ans.resize(n, false);

        // 建立樹結構
        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                tree[parent[i]].push_back(i);
            }
        }

        // 從根節點開始遞迴
        dfs(0);

        return ans;
    }
};",1427920445
imNotDrunk,hank90555,394,3607,cpp,"class Solution {
    int greatestProperDivisor(int n) {
        if (n == 1) return 0; // 1 沒有真因數
        if (n == 2) return 1; // 2 的真因數是 1
        if (n % 2 == 0) return n / 2; // 偶數情況

        // 對於奇數，尋找最小的質因數
        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                return n / i;
            }
        }
        return 1; // n 是質數，最大真因數是 1
    }
public:
    int minOperations(vector<int>& nums) {
        int count = 0;
        int size = nums.size();
        for (int i = size - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                int gpd = greatestProperDivisor(nums[i]);
                if (gpd <= 1) return -1; // 無法再減小，返回 -1
                nums[i] /= gpd;
                count++;
            }
        }
        return count;
    }
};
",1427883221
Yang,luyangg,395,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        pos = defaultdict(list)
        n = len(s)
        for i in range(n):
            pos[s[i]].append(i)
        ans = 0
        for i in range(n):
            low = n
            for j in range(26):
                c = chr(ord('a')+j)
                idx0 = bisect.bisect_left(pos[c], i)
                if len(pos[c]) > idx0+k-1:
                    low = min(low, pos[c][idx0+k-1])
            ans += (n-low)
        return ans",1427854609
Yang,luyangg,395,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        cur = ''
        pre = ''
        for c in target:
            cur = ''
            while cur != c:
                if cur == '':
                    cur = 'a'
                else:
                    cur = chr(ord(cur)+1)
                ans.append(pre + cur)
            pre = ans[-1]
        return ans",1427827017
Yang,luyangg,395,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def dfs(node):
            ran[node][0] = len(dfsStr)
            for child in tree[node]:
                dfs(child)
            dfsStr.append(s[node])
            ran[node][1] = len(dfsStr) - 1
        def hash(l, r):
            len_sub = r - l + 1
            hash1 = (prefix1[r+1] - prefix1[l] * base1[len_sub]) % mod1
            hash2 = (prefix2[r+1] - prefix2[l] * base2[len_sub]) % mod2
            return (hash1, hash2)
        def rev_hash(l, r):
            len_sub = r - l + 1
            hash1 = (suff1[l] - suff1[r+1] * base1[len_sub]) % mod1
            hash2 = (suff2[l] - suff2[r+1] * base2[len_sub]) % mod2
            return (hash1, hash2)
        n = len(parent)
        dfsStr = []
        tree = defaultdict(list)
        ran = [[0,0] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        for node in tree:
            tree[node].sort()
        dfs(0)
        mod1, mod2 = 10**9+7, 10**9+9
        base = 117
        base1 = [1] * (n + 1)
        base2 = [1] * (n + 1)
        for i in range(1, n + 1):
            base1[i] = (base1[i-1] * base) % mod1
            base2[i] = (base2[i-1] * base) % mod2
        prefix1 = [0] * (n + 1)
        prefix2 = [0] * (n + 1)
        for i in range(n):
            prefix1[i+1] = (prefix1[i] * base + ord(dfsStr[i])) % mod1
            prefix2[i+1] = (prefix2[i] * base + ord(dfsStr[i])) % mod2
        suff1 = [0] * (n + 1)
        suff2 = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            suff1[i] = (suff1[i+1] * base + ord(dfsStr[i])) % mod1
            suff2[i] = (suff2[i+1] * base + ord(dfsStr[i])) % mod2
        ans = [False] * n
        for i in range(n):
            l, r = ran[i]
            ans[i] = hash(l, r) == rev_hash(l, r)
        return ans",1427944996
Yang,luyangg,395,3607,python3,"class Solution:
    def __init__(self) -> None:
        self.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        n = len(nums)
        # primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
        cur = nums[-1]
        for i in range(n-2, -1, -1):
            if nums[i] <= cur:
                cur = nums[i]
                continue
            while True:
                if nums[i] <= cur:
                    cur = nums[i]
                    break
                for p in self.primes:
                    if p*p > nums[i]:
                        return -1
                    if nums[i] % p == 0:
                        nums[i] = nums[i]//(nums[i]//p)
                        ans += 1
                        break
        return ans",1427892208
rohinth076,rohinth076,397,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int ans = 0;
        for(int i=0;i<n;i++){
            int[] arr = new int[26];
            boolean flag = false;
            for(int j=i;j<n;j++){
                int in = s.charAt(j)-'a';
                arr[in]++;
                if(arr[in] >= k)flag = true;
                if(flag)ans++;
            }
        }
        return ans;
    }
}",1427828043
rohinth076,rohinth076,397,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        String prev = """";
        for(char i:target.toCharArray()){
            for(char ch = 'a';ch<=i;ch++){
                ans.add(prev+ch);
            }
            prev = ans.get(ans.size()-1);
        }
        return ans;
    }
}",1427824938
rohinth076,rohinth076,397,3603,java,"class Solution {
    final int BASE = 31;
    final int MOD = 1_000_000_007;
    /*------------*/
    List<Integer>[] child;
    List<Integer>[] ranges;
    int level;
    char[] arr;
    String s;
    void dfs(int cur){
        ranges[cur].add(level);
        arr[level++] = s.charAt(cur);
        int size = child[cur].size();
        for(int i=size-1;i>=0;i--){
            dfs(child[cur].get(i));
        }
        ranges[cur].add(level-1);
    }
    void precomputeHashes(String s, int[] forwardHash, int[] backwardHash, int[] power) {
        int n = s.length();
        power[0] = 1;
        for (int i = 1; i <= n; i++) {
            power[i] = (int)((long)power[i - 1] * BASE % MOD);
        }

        for (int i = 1; i <= n; i++) {
            forwardHash[i] = (int)((forwardHash[i - 1] * (long)BASE + (s.charAt(i - 1) - 'a' + 1)) % MOD);
        }

        for (int i = 1; i <= n; i++) {
            backwardHash[i] = (int)((backwardHash[i - 1] * (long)BASE + (s.charAt(n - i) - 'a' + 1)) % MOD);
        }
    }
    boolean isPalindrome(int[] forwardHash, int[] backwardHash, int[] power, int l, int r, int n) {
        long forwardSubstringHash = (forwardHash[r + 1] - (long)forwardHash[l] * power[r - l + 1] % MOD + MOD) % MOD;
        long backwardSubstringHash = (backwardHash[n - l] - (long)backwardHash[n - r - 1] * power[r - l + 1] % MOD + MOD) % MOD;
        //System.out.println(forwardSubstringHash+"" ""+backwardSubstringHash);
        return forwardSubstringHash == backwardSubstringHash;
    }
    public boolean[] findAnswer(int[] parent, String ss) {
        int n = parent.length;
        child = new ArrayList[n];
        ranges = new ArrayList[n];
        s = ss;
        for(int i=0;i<n;i++){
            child[i] = new ArrayList<>();
            ranges[i] = new ArrayList<>();
        }
        for(int i=1;i<n;i++){
            child[parent[i]].add(i); 
        }
        level = 0;
        arr = new char[n];
        dfs(0);
        boolean[] ans = new boolean[n];
        int[] forwardHash = new int[n + 1];  
        int[] backwardHash = new int[n + 1];
        int[] power = new int[n + 1];
        precomputeHashes(new String(arr), forwardHash, backwardHash, power);
        //System.out.println(Arrays.toString(forwardHash));
        //System.out.println(Arrays.toString(backwardHash));
        for (int i = 0; i < n; i++) {
            int l = ranges[i].get(0);
            int r = ranges[i].get(1);
            //System.out.println(i+"" ""+l+"" ""+r);
            ans[i] = isPalindrome(forwardHash, backwardHash, power, l, r, n);
        }
        return ans;
    }
}",1427953620
rohinth076,rohinth076,397,3607,java,"class Solution {
    Set<Integer> isPrime = new TreeSet<>();
    int max = Integer.MAX_VALUE;
    /* ----- */
    List<Integer>[] list;
    int n;
    int[][] dp;
    boolean[][] hasCache;
    int rec(int level,int prevIndex){
        if(level == -1){
            return 0;
        }
        if(hasCache[level][prevIndex])return dp[level][prevIndex];
        int ans = max;
        int prevVal = max;
        if(level + 1 != n){
            prevVal = list[level+1].get(prevIndex);
        }
        int size = list[level].size();
        for(int i=0;i<size;i++){
            if(list[level].get(i) <= prevVal){
                int x = rec(level-1,i);
                if(x != max){
                    ans = Math.min(x+i,ans);
                }
            }
        }
        hasCache[level][prevIndex] = true;
        dp[level][prevIndex] = ans;
        return dp[level][prevIndex];
    }
    public int minOperations(int[] nums) {
        n = nums.length;
        list = new ArrayList[n];
        int maxx = 0;
        for(int i=0;i<n;i++){
            list[i] = new ArrayList<>();
            int x = nums[i];
            list[i].add(x);
            outer:while(true){
                for(int ii=2;ii*ii<=x;ii++){
                    if(x%ii == 0){
                        list[i].add(ii);
                        x = ii;
                        continue outer;
                    }
                }
                break;
            }
            //System.out.println(list[i]);
            maxx = Math.max(maxx,list[i].size());
        }
        dp = new int[n][maxx+1];
        hasCache = new boolean[n][maxx+1];
        int ans = rec(n-1,0);
        if(ans == max){
            ans = -1;
        }
        //System.out.println(""----"");
        return ans;
    }
}",1427862897
saijaswanth25,saijaswanth25,398,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size(),ans=0;
        for(int i=0;i<n;i++){
            vector<int> f(26);
            for(int j=i;j<n;j++){
                f[s[j]-'a']++;
                if(f[s[j]-'a']>=k){
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427924381
saijaswanth25,saijaswanth25,398,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        int n=target.size();
        string prev="""";
        for(int i=0;i<n;i++){
            for(int j=0;j<=(target[i]-'a');j++)
            {
                prev.push_back(j+'a');
                ans.push_back(prev);
                prev.pop_back();
            }
            prev=ans.back();
        }
        return ans;
    }
};",1427929820
saijaswanth25,saijaswanth25,398,3603,cpp,"class Solution {
public:
    #define ll long long
    const ll m=1e9+7;
    void find(string temp,vector<ll> &h1,vector<ll> &h2){
        ll p=1;
        ll n=temp.size();
        for(int i=0;i<n;i++){
            if(i==0){
                h1[i]=temp[i]-'a'+1;
            }
            else{
                h1[i]=(h1[i-1]+(temp[i]-'a'+1)*p)%m;
            }
            p*=31;
            p%=m;
        }
        reverse(temp.begin(),temp.end());
        p=1;
        for(int i=0;i<n;i++){
            if(i==0){
                h2[i]=temp[i]-'a'+1;
            }
            else{
                h2[i]=(h2[i-1]+(temp[i]-'a'+1)*p)%m;
            }
            p*=31;
            p%=m;
        }
        reverse(h2.begin(),h2.end());
    }

    ll binexp(ll a,ll b){
        ll ans=1;
        while(b){
            if(b&1){
                ans*=a;
                ans%=m;
            }
            a*=a;
            a%=m;
            b>>=1;
        }
        return ans;
    }
    vector<bool> findAnswer(vector<int>& p, string s) {
        int n=p.size();
        vector<int> g[n];
        for(int i=1;i<n;i++){
            g[p[i]].push_back(i);
        }
        vector<int> sub(n,1);
        vector<int> path;
        string a;
        function<void(int)> dfs=[&](int i){
            for(auto &ch:g[i]){
                dfs(ch);
                sub[i]+=sub[ch];
            }
            path.push_back(i);
            a.push_back(s[i]);
        };
        dfs(0);
        reverse(path.begin(),path.end());
        reverse(a.begin(),a.end());
        vector<ll> h1(n),h2(n);
        find(a,h1,h2);
        vector<ll> inv(n);
        ll pow=1;
        for(int i=0;i<n;i++){
            inv[i]=binexp(pow,m-2);
            pow*=31;
            pow%=m;
        }
        vector<bool> q(n);
        for(int i=0;i<n;i++){
            ll x=((h1[i+sub[path[i]]-1]-h1[i]+m)%m)*inv[i];
            x%=m;
            ll y=((h2[i]-h2[i+sub[path[i]]-1]+m)%m)*inv[(n-i-sub[path[i]])];
            y%=m;
            q[path[i]]=(x==y);
        }
        return q;
    }
};",1427896138
saijaswanth25,saijaswanth25,398,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        int mx=*max_element(nums.begin(),nums.end());
        vector<int>m(mx+1,1);
        for(int i=2;i<=mx;i++){
            if(m[i]==1)
            {    m[i]=1;
                for(int j=2*i;j<=mx;j+=i)
                {
                    if(m[j]==1)
                    m[j]=j/i;
                }
            }
        }
        int n=nums.size();
        for(int i=n-2;i>=0;i--){
            while(nums[i]>nums[i+1]){
                if(m[nums[i]]==1)
                    return -1;
                nums[i]/=m[nums[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427921224
Abhishek Srivastava,Abhi_Srivastava,399,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), res = 0;
        vector<int> freq[26];
        for (int i = 0; i < 26; i++)
            freq[i].resize(n, 0);
        for (int i = 0; i < n; i++) {
            freq[s[i] - 'a'][i] = 1;
            if (i)
                for (int j = 0; j < 26; j++)
                    freq[j][i] += freq[j][i - 1];
        }
        for (int i = 0; i < n; i++) {
            int l = i, r = n - 1, opt = n;
            while (l <= r) {
                int mid = (l + r) / 2, currfreq[26] = {};
                for (int j = 0; j < 26; j++)
                    currfreq[j] = freq[j][mid] - (i ? freq[j][i - 1] : 0);
                if (*max_element(currfreq, currfreq + 26) >= k) {
                    opt = mid;
                    r = mid - 1;
                }
                else
                    l = mid + 1;
            }
            res += n - opt;
        }
        return res;
    }
};",1427830915
Abhishek Srivastava,Abhi_Srivastava,399,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr;
        while (curr != target) {
            if (curr.empty() || curr.back() == target[curr.size() - 1])
                curr += 'a';
            else
                curr.back()++;
            res.push_back(curr);
        }
        return res;
    }
};",1427824793
Abhishek Srivastava,Abhi_Srivastava,399,3603,cpp,"mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());

bool isPrime(long long num) {
    for (int i = 2; 1ll * i * i <= num; i++)
        if (num % i == 0)
            return 0;
    return 1;
}

long long getNearestPrime(long long num) {
    for (int j = 0; j < 337; j++) {
        if (isPrime(num + j))
            return (num + j);
        if (isPrime(num - j))
            return (num - j);
    }
    return -1;
}

long long mod1, mod2;

void hashMods() {
    long long prime1 = getNearestPrime(rng() % 2037000155 + (1e9 + 9)), prime2 = prime1;
    while (prime2 == prime1) 
        prime2 = getNearestPrime(rng() % 2037000155 + (1e9 + 9));
    mod1 = prime1;
    mod2 = prime2; 
}

long long binpow(long long a, long long b, long long mod) {
    long long res = 1;
    while (b) {
        if (b % 2)
            (res *= a) %= mod;
        (a *= a) %= mod;
        b /= 2;
    }
    return res;
}

const int p = 31;
pair<long long, long long> p_pow[100001], inv_pow[100001];

class Solution {
public:

    int curr = 0;
    string dfsStr;

    void dfs(int u, vector<vector<int>>& adj, vector<pair<int, int>>& range, string& s) {
        int start = curr;
        for (int v : adj[u])
            dfs(v, adj, range, s);
        dfsStr += s[u];
        range[u] = {start, curr++};
    }

    vector<bool> findAnswer(vector<int>& parent, string& s) {
        if (!mod1) {
            hashMods();
            p_pow[0] = {1, 1};
            for (int i = 1; i <= 1e5; i++) {
                p_pow[i].first = (p_pow[i - 1].first * p) % mod1;
                p_pow[i].second = (p_pow[i - 1].second * p) % mod2;
            }
            inv_pow[100000] = {binpow(p_pow[100000].first, mod1 - 2, mod1), binpow(p_pow[100000].second, mod2 - 2, mod2)};
            for (int i = 99999; i >= 0; i--) {
                inv_pow[i].first = (inv_pow[i + 1].first * p) % mod1;
                inv_pow[i].second = (inv_pow[i + 1].second * p) % mod2;
            }
        }
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);
        for (int i = 0; i < n; i++)
            sort(adj[i].begin(), adj[i].end());
        vector<pair<int, int>> range(n);
        dfs(0, adj, range, s);
        vector<pair<long long, long long>> prefixHash(n), suffixHash(n);
        for (int i = 0; i < n; i++) {
            prefixHash[i] = {dfsStr[i] - 'a', dfsStr[i] - 'a'};
            (prefixHash[i].first *= p_pow[i].first) %= mod1;
            (prefixHash[i].second *= p_pow[i].second) %= mod2;
            if (i) {
                (prefixHash[i].first += prefixHash[i - 1].first) %= mod1;
                (prefixHash[i].second += prefixHash[i - 1].second) %= mod2;
            }
        }
        for (int i = n - 1; i >= 0; i--) {
            suffixHash[i] = {dfsStr[i] - 'a', dfsStr[i] - 'a'};
            (suffixHash[i].first *= p_pow[n - i - 1].first) %= mod1;
            (suffixHash[i].second *= p_pow[n - i - 1].second) %= mod2;
            if (i < n - 1) {
                (suffixHash[i].first += suffixHash[i + 1].first) %= mod1;
                (suffixHash[i].second += suffixHash[i + 1].second) %= mod2;
            }
        }
        vector<bool> res(n);
        for (int i = 0; i < n; i++) {
            int len = range[i].second - range[i].first + 1;
            if (len == 1) {
                res[i] = 1;
                continue;
            }
            pair<long long, long long> frwdHash = prefixHash[range[i].second],
            revHash = suffixHash[range[i].first];
            if (range[i].first) {
                (frwdHash.first -= prefixHash[range[i].first - 1].first) %= mod1;
                (frwdHash.second -= prefixHash[range[i].first - 1].second) %= mod2;
                if (frwdHash.first < 0)
                    frwdHash.first += mod1;
                if (frwdHash.second < 0)
                    frwdHash.second += mod2;
                (frwdHash.first *= inv_pow[range[i].first].first) %= mod1;
                (frwdHash.second *= inv_pow[range[i].first].second) %= mod2;
            }
            if (range[i].second < n - 1) {
                (revHash.first -= suffixHash[range[i].second + 1].first) %= mod1;
                (revHash.second -= suffixHash[range[i].second + 1].second) %= mod2;
                if (revHash.first < 0)
                    revHash.first += mod1;
                if (revHash.second < 0)
                    revHash.second += mod2;
                (revHash.first *= inv_pow[n - range[i].second - 1].first) %= mod1;
                (revHash.second *= inv_pow[n - range[i].second - 1].second) %= mod2;
            }
            res[i] = (frwdHash == revHash);
        }
        return res;
    }
};",1427938315
Abhishek Srivastava,Abhi_Srivastava,399,3607,cpp,"int spf[1000001];

class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (nums.size() == 1)
            return 0;
        if (!spf[1]) {
            for (int i = 0; i <= 1e6; i++)
                spf[i] = i;
            for (int i = 2; i * i <= 1e6; i++) 
                if (spf[i] == i) 
                    for (int j = i * i; j <= 1e6; j += i) 
                        if (spf[j] == j) 
                            spf[j] = i;
        }
        int ops = 0;
        for (int i = nums.size() - 2; i >= 0; i--)
            if (nums[i] > nums[i + 1]) {
                nums[i] = spf[nums[i]];
                ops++;
                if (nums[i] > nums[i + 1]) 
                    return -1;
            }
        return ops;
    }
};",1427840597
Daksh,pSydak143,400,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length();
        int ans=0;
        for(int i=0 ; i<n ; i++){
            vector<int> chars(27,0);
            for(int j=i ; j<n ; j++){
                chars[s[j]-'a']++;
                if(chars[s[j]-'a']==k){
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427851743
Daksh,pSydak143,400,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        int n=target.size();
        for(int i=0 ; i<n ; i++){
            string s=target.substr(0,i);
            if(i==0) s="""";
            for(char ch='a' ; ch<='z' ; ch++){
                if(ch==target[i]){
                    ans.push_back(s+ch);
                    break;
                }
                else{
                    ans.push_back(s+ch);
                }
            }
        }
        return ans;
    }
};",1427827553
Daksh,pSydak143,400,3603,python3,"from typing import List
from collections import defaultdict

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        # Create the graph (tree structure)
        graph = defaultdict(list)
        for child in range(1, n):
            graph[parent[child]].append(child)

        # Result array
        answer = [False] * n
        
        def dfs(x):
            # Hash values for the current node string and its reverse
            normal_hash = 0
            reverse_hash = 0
            power = 1
            base = 31
            mod = 10**9 + 7
            current_length = 1  # Length of the current string initialized to 1 for the current node
            
            # Traverse all children in increasing order
            for y in sorted(graph[x]):
                # Get the hashes of the child strings
                child_normal_hash, child_reverse_hash, child_length = dfs(y)
                
                # Update the normal and reverse hashes for the current node
                normal_hash = (normal_hash * pow(base, child_length, mod) + child_normal_hash) % mod
                reverse_hash = (reverse_hash + (child_reverse_hash * power) % mod) % mod
                
                # Update power for the next child's contribution
                power = (power * pow(base, child_length, mod)) % mod
                current_length += child_length  # Update the total length

            # Add the current node's character
            normal_hash = (normal_hash * base + ord(s[x]) - ord('a') + 1) % mod
            reverse_hash = (reverse_hash + (ord(s[x]) - ord('a') + 1) * power) % mod
            
            # Check if the current combined hash is a palindrome
            answer[x] = (normal_hash == reverse_hash)
            
            return normal_hash, reverse_hash, current_length  # Return the hashes and the current length

        # Perform DFS starting from the root
        dfs(0)

        return answer",1427962675
Daksh,pSydak143,400,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        int mx=*max_element(begin(nums),end(nums))+1;
        vector<int> ok(mx,1),first_prime(mx,-1);
        for(int x=2 ; x<mx ; x++){
            if(ok[x]){
                first_prime[x]=x;
                for(int y=x+x ; y<mx ; y+=x){
                    ok[y]=0;
                    if(first_prime[y]==-1) first_prime[y]=x;
                }
            }
        }
        int ans=0;
        for(int i=n-2 ; i>=0 ; i--){
            if(nums[i]<=nums[i+1]) continue;
            else{
                if(first_prime[nums[i]]<=nums[i+1]){
                    ans+=1;
                    nums[i]=first_prime[nums[i]];
                }
                else{
                    return -1;
                }
            }
        }
        return ans;
    }
};",1427873683
Dhruvin Savla,Dhruvin_Savla,403,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char c[] = s.toCharArray();

        int ans=0,suffix[][] = new int[26][c.length];
        for(int j=c.length-1;j>=0;j--){
            suffix[c[j]-'a'][j]++;
            if((j+1)!=c.length){
                for(int j1=0;j1<26;j1++){
                    suffix[j1][j]+=suffix[j1][j+1];
                }
            }
        }

        // for(int j=0;j<c.length;j++){
        //     System.out.print(suffix[0][j]+"" "");
        // }
        
        for(int j=0;j<c.length;j++){
            int ind=-1;
            for(int j1=0;j1<26;j1++){
                ind=Math.max(ind,search(suffix[j1],suffix[j1][j]+k-((c[j]-'a')==j1?1:0),j));
            }

            ans+=(ind+1);
            // System.out.println(ans);
        }

        return ans;
    }

    int search(int arr[],int val,int end){
        int s=0,e=end,f=-1;

        while(s<=e){
            int mid = s+((e-s)/2);
            if(arr[mid]==val){
                f=mid;
                s=mid+1;
            }
            else if(arr[mid]>val){
                s=mid+1;
            }
            else e=mid-1;
        }

        return f;
    }
}",1427852569
Dhruvin Savla,Dhruvin_Savla,403,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        char c[] = target.toCharArray();
        List<String> ans = new LinkedList<>();
        String tmp="""";

        for(char e:c){
            if(e=='a'){
                tmp+='a';
                ans.add(tmp);
            }
            else{
                for(char j='a';j<=e;j++){
                    ans.add(tmp+j);
                }
                tmp+=e;
            }
        }

        return ans;
    }
}",1427825324
Dhruvin Savla,Dhruvin_Savla,403,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        boolean ans[] = new boolean[parent.length];
        int size[] = new int[parent.length];
        char c[] = s.toCharArray();

        TreeSet<Integer> node[] = new TreeSet[parent.length];
        for(int j=0;j< parent.length;j++)
            node[j] = new TreeSet<>();

        for(int j=1;j< parent.length;j++){
            node[parent[j]].add(j);
        }

        LinkedList<Character> str = new LinkedList<>();
        dfs(node,0,c,size,str);
        // System.out.println(str);

        char last[] = new char[c.length];
        int ind=0;
        while(!str.isEmpty()){
            last[ind++]=str.pollFirst();
        }
        PalindromeChecker checker = new PalindromeChecker(last);

        checkDfs(node,0,0,size,checker,ans);
        return ans;
    }

    void checkDfs(TreeSet<Integer> node[],int s,int start,int size[],PalindromeChecker checker,boolean ans[]){
        ans[s]=checker.isPalindrome(start,start+size[s]-1);

        for(int e:node[s]){
            checkDfs(node,e,start,size,checker,ans);
            start+=size[e];
        }
    }

    void dfs(TreeSet<Integer> node[],int s,char c[],int size[],LinkedList<Character> str){
        for(int e:node[s]){
            dfs(node,e,c,size,str);
            size[s]+=size[e];
        }

        str.addLast(c[s]);
        size[s]++;
    }
}

class PalindromeChecker {
    static final int P = 31;
    static final int MOD = 1_000_000_007;

    long[] forwardHash, reverseHash, power;
    char s[];
    int n;

    PalindromeChecker(char s[]) {
        this.s = s;
        this.n = s.length;
        forwardHash = new long[n + 1];
        reverseHash = new long[n + 1];
        power = new long[n + 1];
        
        precomputeHashes();
    }

    void precomputeHashes() {
        power[0] = 1;
        for (int i = 1; i <= n; i++) {
            power[i] = (power[i - 1] * P) % MOD;
        }

        for (int i = 0; i < n; i++) {
            forwardHash[i + 1] = (forwardHash[i] * P + s[i]) % MOD;
            reverseHash[i + 1] = (reverseHash[i] * P + s[n - i - 1]) % MOD;
        }
    }

    long getHash(long[] hash, int l, int r) {
        long result = (hash[r + 1] - (hash[l] * power[r - l + 1]) % MOD + MOD) % MOD;
        return result;
    }

    boolean isPalindrome(int l, int r) {
        long forward = getHash(forwardHash, l, r);
        long reverse = getHash(reverseHash, n - r - 1, n - l - 1);
        return forward == reverse;
    }
}",1427955055
Dhruvin Savla,Dhruvin_Savla,403,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int ans=0;

        int properDiv[] = sieve((int)1e6);
        for(int j=nums.length-2;j>=0;j--){
            while(nums[j]>nums[j+1] && properDiv[nums[j]]!=0){
                nums[j]=properDiv[nums[j]];
                ans++;
            }

            if(nums[j]>nums[j+1]) return -1;
        }

        return ans;
    }

    int[] sieve(int n){
        int arr[] = new int[n+1];
        
        for(int j=2;j<=Math.sqrt(n);j++){
            if(arr[j]==0){
                for(int k=j*2;k<=n;k+=j){
                    if(arr[k]==0) arr[k]=j;
                }
            }
        }

        return arr;
    }
}",1427870653
Harsh Bardolia,harshbardolia,404,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int) s.size();
        int res = 0;
        
        for (int len = k; len <= n; len++) {
            vector<int> f(26);
            set<char> cnt;
            
            for (int i = 0; i < len; i++) {
                f[s[i] - 'a']++;
                if (f[s[i] - 'a'] >= k) cnt.insert(s[i]);
            }
            
            if ((int) cnt.size() > 0) res++;
            
            for (int i = len; i < n; i++) {
                int l = i - len;
                
                if (f[s[l] - 'a'] == k) cnt.erase(s[l]);
                f[s[l] - 'a']--;
                
                f[s[i] - 'a']++;
                if (f[s[i] - 'a'] >= k) cnt.insert(s[i]);
                
                if ((int) cnt.size() > 0) res++;
            }
        }
        
        return res;
    }
};",1427929030
Harsh Bardolia,harshbardolia,404,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        vector<string> res;
        
        for (auto x : target) {
            s += ""a"";
            res.push_back(s);
            
            while (s.back() < x) {
                s.back()++;
                res.push_back(s);
            }
        }
        
        return res;
    }
};",1427928846
Harsh Bardolia,harshbardolia,404,3603,cpp,"class Solution {
public:
    vector<int> manacher_odd(string &s) {
        int n = s.size();
        s = ""$"" + s + ""^"";
        vector<int> p(n + 2);
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = max(0, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i], r = i + p[i];
            }
        }
        return vector<int>(begin(p) + 1, end(p) - 1);
    }
    
    vector<int> manacher(string &s) {
        string t = ""#"" + s;
        auto res = manacher_odd(t);
        return vector<int>(begin(res) + 1, end(res) - 1);
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = (int) s.size();
        vector<vector<int>> adj(n + 1);
        
        for (int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);
        
        for (int i = 0; i < n; i++)
            sort(adj[i].begin(), adj[i].end());
        
        string t = """";
        vector<int> left(n), right(n), len(n);
        
        function<void(int)> dfs = [&] (int cur) {
            left[cur] = (int) t.size();
            len[cur] = 1;
            
            for (auto nx : adj[cur]) {
                dfs(nx);
                len[cur] += len[nx];
            }
            
            right[cur] = (int) t.size();
            t += s[cur];
            t += ""#"";
        };
        
        dfs(0);
        vector<int> d = manacher(t);
        vector<bool> res(n);
        
        for (int i = 0; i < n; i++) {
            int l = left[i];
            int r = right[i];
            int m = (l + r) / 2;
            int want = (len[i] + 1) / 2;
            int have = d[m] / 2;
            res[i] = (want <= have);
        }
        
        return res;
    }
};",1427929953
Harsh Bardolia,harshbardolia,404,3607,cpp,"const int mx = 1e6 + 1;
int nxt[mx];

void pre() {
    for (int i = 2; i < mx; i++) {
        if (nxt[i] != 0) continue;
        for (int j = i; j < mx; j += i) {
            if (nxt[j] != 0) continue;
            nxt[j] = i;   
        }
    }
}

class Solution {
public:
    
    Solution() {
        pre();
    }
    
    int minOperations(vector<int>& nums) {
        int n = (int) nums.size();
        int res = 0;
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                res++;
                nums[i] = nxt[nums[i]];
            }
            
            if (nums[i] > nums[i + 1]) return -1;
        }
        
        return res;
    }
};",1427947072
Vedant Jadhav,vedantjadhav1012,405,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
          int n = s.length();
        int ans = 0;

        for (int l = 0; l < n; ++l) {
            vector<int> f(26, 0); 
            bool flag = false;
            for (int r = l; r < n; ++r) {
                f[s[r] - 'a']++; 
                if(f[s[r] - 'a']>=k)flag = true;
                if (flag) {
                    ans++; 
                }
            }
        }

        return ans;
    }
};",1427853318
Vedant Jadhav,vedantjadhav1012,405,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
          vector<string> result;
        string current = """";
        
        char lastChar = 'a'; // Initialize to 'a'
        
        for (char ch : target) {
            // Use Key 1: Append a new 'a' to start the next segment if needed
            if (current.empty()) {
                current += 'a';
                result.push_back(current);
            }
            
            // Use Key 2: Increment the last character until it matches the target character
            while (lastChar < ch) {
                lastChar++;
                current.back() = lastChar;
                result.push_back(current);
            }

            // Use Key 1 to append next character from target
            if (lastChar == ch) {
                current += 'a';  // Add next character as 'a' (Key 1)
                lastChar = 'a'; 
                result.push_back(current);  // Reset the lastChar for next iteration
            }
        }
        
        // Remove the last unnecessary 'a' added at the end
        if (current.back() == 'a') {
            current.pop_back();
             
        
        }
        result.pop_back();
        
        return result;
    }
};",1427845012
Vedant Jadhav,vedantjadhav1012,405,3603,cpp,"class Solution {
public:
    vector<bool> ans;
    vector<long> aa,bb,cc;
     long long mod = 1000000007L;
     void traverse(int node, const vector<vector<int>>& tree, const string& s, vector<char>& trav, vector<int>& st, vector<int>& e) {
        st[node] = trav.size();
        for (int c : tree[node]) {
            traverse(c, tree, s, trav, st, e);
        }
        trav.push_back(s[node]);
        e[node] = trav.size() - 1;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
       int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; i++) {
            tree[parent[i]].push_back(i);
        }
    
        vector<char> trav;
        vector<int> st(n), e(n);
        traverse(0, tree, s, trav, st, e);
        
        vector<char> revTrav = trav;
        reverse(revTrav.begin(), revTrav.end());

       
        int B = 26;
        B++;

         aa.resize(trav.size() + 1, 1);
        bb.resize(trav.size() + 1, 0);
        cc.resize(revTrav.size() + 1, 0);

        for (int i = 1; i <= trav.size(); i++) {
            aa[i] = (aa[i - 1] * B) % mod;
            bb[i ] = (bb[i-1] * B + (trav[i-1] - 'a' + 1)) % mod;
            cc[i ] = (cc[i-1] * B + (revTrav[i-1] - 'a' + 1)) % mod;

        }


        ans.resize(n, false);
        for (int i = 0; i < n; i++) {
            int l = st[i], r = e[i];
            long hv1 = (bb[r + 1] - (bb[l] * aa[r - l + 1]) % mod + mod) % mod;

            int rl = trav.size() - 1 - r, rr = trav.size() - 1 - l;
            long rhv1 = (cc[rr + 1] - (cc[rl] * aa[rr - rl + 1]) % mod + mod) % mod;

            if (hv1 == rhv1 ) ans[i] = true;
        }

        return ans;
    }
};
",1427955184
Vedant Jadhav,vedantjadhav1012,405,3607,cpp,"class Solution {
public:
    int sol(int x) {
        for (int i = 2; i <=x/2; ++i) {
            if (x % i == 0) return x/i;
        }
        return 1;
    }
    int minOperations(vector<int>& a) {
        int n = a.size();
        int ans = 0;

        for (int i = n - 2; i >= 0; --i) {

            while (a[i] > a[i + 1]) {
                int g = sol(a[i]); 
                if (g == 1) return -1;

                a[i] /= g;  
                ans++;    
            }
        }

        return ans;
    }
};",1427871281
Jack Deng,dj3013158,406,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        res = set()
        
        n = len(s)
        res = 0
        for start in range(n):
            freq = [0] * 26
            
            for end in range(start, n):
                idx = ord(s[end]) - ord('a')
                freq[idx] += 1
                
                if freq[idx] >= k:
                    res += n - end
                    break
        return res
",1427939078
Jack Deng,dj3013158,406,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = """"

        for char in target:
            cur += 'a'
            res.append(cur)

            while cur[-1] != char:
                cur = cur[:-1] + chr((ord(cur[-1]) - ord('a') + 1) % 26 + ord('a'))
                res.append(cur)

        return res
",1427863470
Jack Deng,dj3013158,406,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        mod1, mod2 = 10**9+7, 10**9+9
        base1, base2 = 911, 3571
        pow_base1 = [1] * (n + 2)
        pow_base2 = [1] * (n + 2)
        for i in range(1, n + 2):
            pow_base1[i] = (pow_base1[i - 1] * base1) % mod1
            pow_base2[i] = (pow_base2[i - 1] * base2) % mod2

        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)

        h_f1 = [0] * n
        h_b1 = [0] * n
        h_f2 = [0] * n
        h_b2 = [0] * n
        len_seq = [0] * n
        answer = [False] * n

        def dfs(u):
            h_f1_u, h_f2_u, len_u = 0, 0, 0
            for v in tree[u]:
                dfs(v)
                h_f1_u = (h_f1_u * pow_base1[len_seq[v]] + h_f1[v]) % mod1
                h_f2_u = (h_f2_u * pow_base2[len_seq[v]] + h_f2[v]) % mod2
                len_u += len_seq[v]

            val = ord(s[u]) - ord('a') + 1
            h_f1_u = (h_f1_u * base1 + val) % mod1
            h_f2_u = (h_f2_u * base2 + val) % mod2
            len_u += 1

            h_b1_u = val
            h_b2_u = val
            for v in reversed(tree[u]):
                h_b1_u = (h_b1_u * pow_base1[len_seq[v]] + h_b1[v]) % mod1
                h_b2_u = (h_b2_u * pow_base2[len_seq[v]] + h_b2[v]) % mod2

            h_f1[u], h_f2[u], len_seq[u] = h_f1_u, h_f2_u, len_u
            h_b1[u], h_b2[u] = h_b1_u, h_b2_u
            answer[u] = (h_f1[u] == h_b1[u] and h_f2[u] == h_b2[u])

        dfs(0)
        return answer",1427929323
Jack Deng,dj3013158,406,3607,python3,"max_num = 10**6+10
SPF = [0] * (max_num)
for i in range(2, max_num):
    if SPF[i] == 0:
        for j in range(i, max_num, i):
            if SPF[j] == 0:
                SPF[j] = i

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        res = 0

        res = 0
        for i in range(n - 1, 0, -1):
            if nums[i - 1] > nums[i]:
                if nums[i - 1] == SPF[nums[i - 1]]:
                    return -1
                nums[i - 1] = SPF[nums[i - 1]]
                
                res +=1
                
                if nums[i - 1] > nums[i]:
                    return -1
        return res",1427921773
sahasrad,sahasrad,408,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int result = 0;
        for(int i = 0; i < n; i++) {
            int[] freq = new int[26];
            int max = 0;
            for(int j = i; j < n; j++) {
                int c = s.charAt(j) - 'a';
                freq[c]++;
                if(freq[c] > max) max = freq[c];
                if(max >= k) result++;
            }
        }
        return result;
    }
}",1427828740
sahasrad,sahasrad,408,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        String curr = """";
        int n = target.length();
        List<String> result = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            char c = target.charAt(i);
            for(char x = 'a'; x <= c; x++) {
                result.add(curr + x);
            }
            curr = result.get(result.size() - 1);
        }
        return result;
    }
}",1427824344
sahasrad,sahasrad,408,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        long MOD = 1_000_000_007L;
        HashMap<Integer, List<Integer>> children = new HashMap<>();
        int n = parent.length;
        for(int i = 1; i < n; i++) {
            children.computeIfAbsent(parent[i], k -> new ArrayList<>()).add(i);
        }
        int[] size = new int[n];
        StringBuilder str = new StringBuilder();
        for(List<Integer> value : children.values()) {
            Collections.sort(value, Comparator.reverseOrder());
        }
        List<Integer> order = new ArrayList<>();
        sizes(0, children, size, str, s, order);
        boolean[] result = new boolean[n];
        Character[] arr =new Character[n];
        for(int i = 0; i < n; i++) arr[i] = str.charAt(i);
        SegTree<Character, Pair<Long, Integer>> hash = new SegTree<>(arr, (Character x) -> {
            return new Pair<>((long) (x - 'a' + 1), 1);
        }, (x, y) -> {
            return new Pair<>((x.a + y.a * exp(31, x.b, MOD)) % MOD, x.b + y.b);
        });
        SegTree<Character, Pair<Long, Integer>> reverse = new SegTree<>(arr, (Character x) -> {
            return new Pair<>((long) (x - 'a' + 1), 1);
        }, (x, y) -> {
            return new Pair<>((y.a + x.a * exp(31, y.b, MOD)) % MOD, x.b + y.b);
        });
        int[] order2 = new int[n];
        for(int i = 0; i < n; i++) {
            order2[order.get(i)] = i;
        }
        // System.out.println(Arrays.toString(size));
        for(int j = 0; j < n; j++) {
            int i = order2[j];
            int size1 = size[j];
            if(size1 == 1) {
                result[j] = true;
                continue;
            }
            int end = i + size1 - 1;
            // System.out.println(i + "" "" + (i + size1/2 - 1));
            // System.out.println(end - size1/2 + 1 + "" "" + end);
            // System.out.println(hash.query(i, i + size1/2 - 1) );
            // System.out.println(hash.query(end - size1/2 + 1, end));
            var q1 = hash.query(i, i + size1/2 - 1);
            var q2 = reverse.query(end - size1/2 + 1, end);
            if(Objects.equals(q1.a, q2.a) && Objects.equals(q1.b, q2.b)) {
                result[j] = true;
            }
        }
        return result;
    }
    
    public int sizes(int i, HashMap<Integer, List<Integer>> children, int[] size, StringBuilder result, String s, List<Integer> order) {
        int curr = 1;
        List<Integer> child = children.get(i);
        result.append(s.charAt(i));
        order.add(i);
        if(child == null) {
            size[i] = 1;
            return 1;
        }
        for(Integer c : child) {
            curr += sizes(c, children, size, result, s, order);
        }
        size[i] = curr;
        return curr;
    }

    static long exp(long val, long pow, long mod) {
        val %= mod;
        long result = 1;
        while(pow > 0) {
            if((pow & 1) > 0) result = (result * val) % mod;
            val = (val * val) % mod;
            pow /= 2;
        }
        return result;
    }

    static class SegTree<T, R> {
        private final BiFunction<R, R, R> accumulator;
        private final Function<T, R> mapper;
        int n;
        R[] tree;

        SegTree(T[] arr, Function<T, R> individualMapper, BiFunction<R, R, R> accumulator) {
            tree = (R[]) new Object[arr.length << 2];
            this.n = arr.length;
            this.mapper = individualMapper;
            this.accumulator = accumulator;
            build(arr, 0, 0, n - 1);
        }

        SegTree(List<T> list, Function<T, R> individualMapper, BiFunction<R, R, R> accumulator) {
            tree = (R[]) new Object[list.size() << 2];
            this.n = list.size();
            this.mapper = individualMapper;
            this.accumulator = accumulator;
            build(list, 0, 0, n - 1);
        }

        private void build(T[] arr, int i, int l, int r) {
            if(l == r) {
                tree[i] = mapper.apply(arr[l]);
                return;
            }
            int m = (l + r) / 2;
            int i1 = i * 2 + 1, i2 = i1 + 1;
            build(arr, i1, l, m);
            build(arr, i2, m + 1, r);
            tree[i] = accumulator.apply(tree[i1], tree[i2]);
        }

        private void build(List<T> list, int i, int l, int r) {
            if(l == r) {
                tree[i] = mapper.apply(list.get(l));
                return;
            }
            int m = (l + r) / 2;
            int i1 = i * 2 + 1, i2 = i1 + 1;
            build(list, i1, l, m);
            build(list, i2, m + 1, r);
            tree[i] = accumulator.apply(tree[i1], tree[i2]);
        }

        R query(int l, int r) {
            return query(0, 0, n - 1, l, r);
        }

        private R query(int i, int cl, int cr, int l, int r) {
            if(l > r || l < 0 || r >= n) throw new IllegalArgumentException(""Invalid Range: "" + l + "", "" + r + "" for size "" + n);
            if(l == cl && r == cr) return tree[i];
            int m = (cl + cr) / 2;
            int i1 = i * 2 + 1, i2 = i1 + 1;
            if(m >= r) {
                return query(i1, cl, m, l, r);
            }
            else if(m < l) {
                return query(i2, m + 1, cr, l, r);
            }
            else {
                return accumulator.apply(query(i1, cl, m, l, m), query(i2, m + 1, cr, m + 1, r));
            }
        }

        void set(int index, T val) {
            update(0, 0, n - 1, index, val);
        }

        private void update(int i, int l, int r, int index, T val) {
            if(l == r) {
                tree[i] = mapper.apply(val);
                return;
            }
            int m = (l + r) / 2;
            int i1 = i * 2 + 1, i2 = i1 + 1;
            if(index <= m) update(i1, l, m, index, val);
            else update(i2, m + 1, r, index, val);
            tree[i] = accumulator.apply(tree[i1], tree[i2]);
        }
    }

        static class Pair<A, B> {
        public A a;
        public B b;
        public Pair() {
            a = null;
            b = null;
        }
        public Pair(A a, B b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public String toString() {
            return toString(""<"", "", "", "">"");
        }

        public String toString(String prefix, String delimiter, String suffix) {
            StringBuilder sb = new StringBuilder();
            sb.append(prefix);
            sb.append(a);
            sb.append(delimiter);
            sb.append(b);
            sb.append(suffix);
            return sb.toString();
        }
    }
}

",1427963535
sahasrad,sahasrad,408,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int last = Integer.MAX_VALUE;
        int ops = 0;
        for(int i = n - 1; i >= 0; i--) {
            if(nums[i] > last) {
                int val = nums[i];
                int sqrt = (int) Math.sqrt(val);
                int result = -1;
                for(int y = 2; y <= sqrt; y++) {
                    if(val % y == 0) {
                        result = y;
                        break;
                    }
                }
                if(result < 0) return -1;
                if(result > last) return -1;
                nums[i] = result;
                ops++;
            }
            last = nums[i];
        }
        return ops;
    }
}",1427836138
Rajan,LLightt,409,3502,cpp,"class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    int n = s.size(), ans = 0, i = 0;
    while(i < n) {
      int fre[26] = {0}, j = i;
      while(j < n) {
        fre[s[j] - 'a']++;
        int x = 0;
        while(x < 26) {
          if(fre[x] >= k) {
            ans++;
            break;
          }
          x++;
        }
        j++;
      }
      i++;
    }
    return ans;
  }
};
",1427841629
Rajan,LLightt,409,3566,cpp,"class Solution {
public:
  vector<string> stringSequence(string tgt) {
    vector<string> ans;
    stack<char> stk;
    for(int i = 0; i < tgt.size(); i++) {
      stk.push('a');
      string cur;
      stack<char> tmp = stk;
      while(!tmp.empty()) {
        cur = tmp.top() + cur;
        tmp.pop();
      }
      ans.push_back(cur);
      while(stk.top() != tgt[i]) {
        stk.top()++;
        cur.back() = stk.top();
        ans.push_back(cur);
      }
    }
    return ans;
  }
};
",1427838551
Rajan,LLightt,409,3603,python,"class Solution:
    def __init__(self):
        self.base = 31
        self.modulus = 9576890767

    def dfs(self, node, graph, powers, results, string):
        forward = []
        backward = []
        sizes = []
        
        for neighbor in graph[node]:
            value = self.dfs(neighbor, graph, powers, results, string)
            forward.append(value[0])
            backward.append(value[1])
            sizes.append(value[2])
        
        forward.append(ord(string[node]) - ord('a') + 1)
        backward.append(ord(string[node]) - ord('a') + 1)
        sizes.append(1)
        
        forwardHash = 0
        previous = 0
        length = len(forward)
        for i in range(length):
            forwardHash = (forwardHash + (powers[previous] * forward[i]) % self.modulus) % self.modulus
            previous += sizes[i]
        
        backwardHash = 0
        previous = 0
        for i in range(length - 1, -1, -1):
            backwardHash = (backwardHash + (powers[previous] * backward[i]) % self.modulus) % self.modulus
            previous += sizes[i]
        
        if forwardHash == backwardHash:
            results[node] = True
        
        return (forwardHash, backwardHash, previous)

    def findAnswer(self, parent, string):
        length = len(string)
        results = [False] * length
        powers = [1] * (length + 1)
        graph = [[] for _ in range(length)]
        
        for i in range(1, length + 1):
            powers[i] = (self.base * powers[i - 1]) % self.modulus
        
        for i in range(length):
            if parent[i] != -1:
                graph[parent[i]].append(i)
        
        self.dfs(0, graph, powers, results, string)
        priority_queue = []
        for index, value in enumerate(results):
            if value:
                if len(priority_queue) < 100:
                    heapq.heappush(priority_queue, (index, value))
                else:
                    if index > priority_queue[0][0]:
                        heapq.heappop(priority_queue)
                        heapq.heappush(priority_queue, (index, value))
      
        
        return results
",1427963537
Rajan,LLightt,409,3607,cpp,"class Solution {
public:
  int lpd(int n) {
    if (n <= 1) return -1;
    int maxDivisor = 1;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            maxDivisor = max(maxDivisor, i);
            if (i != n / i) {
                maxDivisor = max(maxDivisor, n / i);
            }
        }
    }
    return maxDivisor;
}

  int minOperations(vector<int>& nums) {
    // const int MAX_N = 1e5;
    // int gpd[MAX_N + 1];
    // for (int i = 1; i <= MAX_N; i++) {
    //   gpd[i] = 1;
    //   for (int j = 2; j * j <= i; j++) {
    //     if (i % j == 0) {
    //       gpd[i] = max(gpd[i], i / j);
    //       if (j < i) {
    //         gpd[i] = max(gpd[i], j);
    //       }
    //     }
    //   }
    // }
    // cout << gpd[1] << "" "" << gpd[57];
    map<int,int> mp;
    int cnt = 0, n = nums.size();
    for (int i = n - 1; i > 0; i--) {
      if(nums[i] >= nums[i-1]) continue;
      // cout << nums[i] << nums[i-1];
      while(nums[i] < nums[i-1]){
        int div = 1;
        if(mp[nums[i-1]] != 0){
          div = mp[nums[i-1]];
        }
        else{
          div = lpd(nums[i-1]);
          mp[nums[i-1]] = div;

        }
        if(div == 1)  return -1;
        nums[i-1] = nums[i-1] / div;
        cnt++;
      }
    }
    return cnt;
  }
};
",1427891795
kritikmodi,kritikmodi,410,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans=0;
        for(int j=0;j<s.length();j++)
        {
            int count[]=new int[26];
            boolean check=false;
            for(int k1=j;k1<s.length();k1++)
            {
                count[s.charAt(k1)-'a']++;
                if(count[s.charAt(k1)-'a']>=k)
                    check=true;
                if(check)
                    ans++;
            }
        }
        return ans;
    }
}",1427828184
kritikmodi,kritikmodi,410,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans=new ArrayList<>();
        StringBuilder curr=new StringBuilder("""");
        for(int j=0;j<target.length();j++)
        {
            for(char k='a';k<=target.charAt(j);k++)
                ans.add(curr.toString()+""""+k);
            curr.append(target.charAt(j));
        }
        return ans;
    }
}",1427825176
kritikmodi,kritikmodi,410,3603,java,"class Solution {
    static long MOD = (long) 1e9 + 7;
    static ArrayList<ArrayList<Integer>> al;
    static boolean ans[];
    static ArrayList<Integer> order;
    static String finalstr;
    static int count[];
    static long[] hashArray1;
    static long[] pInverseArray1;
    static long[] hashArray2;
    static long[] pInverseArray2;
    static String s1;
    static String s2;
    public boolean[] findAnswer(int[] parent, String s) {
        al=new ArrayList<>();
        for(int j=0;j<parent.length;j++)
            al.add(new ArrayList<>());
        for(int j=1;j<parent.length;j++)
        {
            al.get(j).add(parent[j]);
            al.get(parent[j]).add(j);
        }
        for(int j=0;j<parent.length;j++)
            Collections.sort(al.get(j));
        order=new ArrayList<>();
        count=new int[parent.length];
        dfs(0,-1);
        StringBuilder str=new StringBuilder("""");
        for(int j=0;j<order.size();j++)
            str.append(s.charAt(order.get(j)));
        finalstr=str.toString();
        ans=new boolean[parent.length];
        s1=finalstr;
        s2=str.reverse().toString();
        int n=finalstr.length();
        hashArray1=new long[n];
        pInverseArray1=new long[n];
        preComputeHashArray1();
        for(int p=0;p<n;++p)
        {
            pInverseArray1[p]=modInverse(power(31, p));
        }
        hashArray2=new long[n];
        pInverseArray2=new long[n];
        preComputeHashArray2();
        for(int p=0;p<n;++p)
        {
            pInverseArray2[p]=modInverse(power(31, p));
        }
        getAns(0,-1,0,finalstr.length()-1);
        return ans;
    }
    
    static int dfs(int curr, int parent)
    {
        int currcount=1;
        ArrayList<Integer> next=al.get(curr);
        StringBuilder currans=new StringBuilder("""");
        for(int j=0;j<next.size();j++)
        {
            if(next.get(j)!=parent)
                currcount+=dfs(next.get(j),curr);
        }
        order.add(curr);
        count[curr]=currcount;
        return currcount;
    }
    
    static void getAns(int curr, int parent, int start, int end)
    {
        ArrayList<Integer> next=al.get(curr);
        long firsthash=hash1(start,start+((end-start+2)/2)-1);
        long secondhash=hash2((finalstr.length()-end)-1,((finalstr.length()-end)-1)+(((end-start+2)/2)-1));
        if(firsthash==secondhash)
            ans[curr]=true;
        else
            ans[curr]=false;
        for(int j=0;j<next.size();j++)
        {
            if(next.get(j)!=parent)
            {
                getAns(next.get(j),curr,start,start+count[next.get(j)]-1);
                start+=count[next.get(j)];
            }
        }
    }
    
    public static long hash1(int i, int j)
    {
        if(i==0)
        return ((hashArray1[j]*pInverseArray1[i])%MOD);
        else
        return ((((hashArray1[j]+MOD-hashArray1[i-1])%MOD)*pInverseArray1[i])%MOD);
    }
 
    public static void preComputeHashArray1() 
    {
        long p = 31;
        long hashValue = 0;
        long p_pow = 1;
        for (int i=0;i<s1.length();++i) {
            char c = s1.charAt(i);
            hashValue = (hashValue + (c - 'a' + 1) * p_pow) % MOD;
            hashArray1[i] = hashValue;
            p_pow = (p_pow * p) % MOD;
        }
    }
    
    public static long hash2(int i, int j)
    {
        if(i==0)
        return ((hashArray2[j]*pInverseArray2[i])%MOD);
        else
        return ((((hashArray2[j]+MOD-hashArray2[i-1])%MOD)*pInverseArray2[i])%MOD);
    }
 
    public static void preComputeHashArray2() 
    {
        long p = 31;
        long hashValue = 0;
        long p_pow = 1;
        for (int i=0;i<s2.length();++i) {
            char c = s2.charAt(i);
            hashValue = (hashValue + (c - 'a' + 1) * p_pow) % MOD;
            hashArray2[i] = hashValue;
            p_pow = (p_pow * p) % MOD;
        }
    }
 
    public static long modInverse(long n)
    {
        return power(n, MOD-2);
    }
 
    public static long power(long x, long y)
    {
        if(y==0)
            return 1;
        long halfAns=power(x, y/2);
        long myAns=(halfAns*halfAns)%MOD;
        if((y&1)==1)
            myAns=(myAns*x)%MOD;
        return myAns;
    }
    
    static boolean check(int p1, int p2)
    {
        while(p1<p2)
        {
            if(finalstr.charAt(p1)!=finalstr.charAt(p2))
                return false;
            p1++;
            p2--;
        }
        return true;
    }
    
    
}",1427947370
kritikmodi,kritikmodi,410,3607,java,"class Solution {
    public int minOperations(int[] a) {
        ArrayList<Integer> primes=sieveOfEratosthenes((int)1e3+5);
        int ans=0;
        for(int j=a.length-2;j>=0;j--)
        {
            while(a[j]>a[j+1])
            {
                boolean check=false;
                for(int k=0;k<primes.size()&&!check;k++)
                {
                    if(primes.get(k)<a[j]&&a[j]%primes.get(k)==0)
                    {
                        ans++;
                        a[j]=primes.get(k);
                        check=true;
                    }
                }
                if(!check)
                    return -1;
            }
        }
        return ans;
    }
    
    static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        for (int j = 0; j <= n; j++)
            prime[j] = true;
        for (long p = 2; 1l * p * p <= n; p++) {
            if (prime[(int) p]) {
                for (long j = 1l * p * p; j <= n; j += p)
                    prime[(int) j] = false;
            }
        }
        ArrayList<Integer> al = new ArrayList<>();
        for (long j = 2; j <= n; j++) {
            if (prime[(int) j])
                al.add((int) j);
        }
        return al;
    }
}",1427847724
SAY__MY__NAME,SAY__MY__NAME,412,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] cnt = new int[26];

        int l = 0, r = 0;
        int res = 0;
        for ( ; r < s.length(); r++) {
            char ch = s.charAt(r);
            cnt[ch-'a']++;

            if (check(cnt, k)) {
                while (check(cnt, k)) {
                    char ch1 = s.charAt(l);
                    cnt[ch1-'a']--;
                    l++;
                }
                l--;
                char ch2 = s.charAt(l);
                cnt[ch2-'a']++;
                res += l + 1;
            }
        }
        return res;
    }

    private boolean check(int[] cnt, int k) {
        boolean res = false;
        for (int i = 0; i < 26; i++) {
            if (cnt[i] >= k) res = true;
        }
        return res;
    }
}",1427844099
SAY__MY__NAME,SAY__MY__NAME,412,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        for (int i = 0; i < target.length(); i++) {
            String prev = target.substring(0,i);
            // StringBuilder sb = new StringBuilder(prev);
            for (int j = 0; j <= target.charAt(i)-'a'; j++) {
                char ch = (char)('a' + j);
                // sb.append((char)(target.charAt(i) + j));
                // sb.setLength(sb.length()-1);
                res.add(prev + ch);
            }
        }

        return res;
    }
}",1427834013
SAY__MY__NAME,SAY__MY__NAME,412,3603,java,"class Solution {
    private char[] str;
    private char[] ss;
    private int[] start;
    private List<Integer>[] graph;
    private int ind = 0;
    private int[] end;

    private long[] hash;
    private long[] power;
    private long[] hash1;
    private long[] power1;
    private char[] str1;
    private final static int MOD = (int)1e9+7;
    private final static int P = 31;
    
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        if (n == 1) return new boolean[]{true};

        str = new char[n];
        start = new int[n];
        ss = s.toCharArray();
        end = new int[n];
        hash = new long[n+1];
        power = new long[n+1];

        hash1 = new long[n+1];
        power1 = new long[n+1];

        graph = graphBuilder(parent);
        dfs(0);

        // System.out.println(Arrays.toString(str));
        // System.out.println(Arrays.toString(start));
        // System.out.println(Arrays.toString(end));
        buildHash();

        str1 = new char[n];
        for (int i = 0; i < n ;i++) str1[i] = str[i];
        for (int i = 0; i < n/2; i++) {
            char temp = str1[i];
            str1[i] = str1[n-1-i];
            str1[n-1-i] = temp;
        }
        buildHash1();

        boolean[] res = new boolean[n];
        for (int i = 0; i < n; i++) {
            int sT = start[i], eN = end[i];
            res[i] = (getHash(sT, eN, hash, power) == getHash(n-1-eN, n-1-sT, hash1, power1)) ? true : false;
        }
        return res;
    }

    private void buildHash() {
        int n = str.length;
        power[0] = 1L;
        for (int i = 1; i < n+1; i++) {
            int ch = str[i-1] - 'a' + 1;
            hash[i] = (hash[i-1] * P + ch) % MOD;
            power[i] = (power[i-1] * P) % MOD;
        }
    }

    private void buildHash1() {
        int n = str.length;
        power1[0] = 1L;
        for (int i = 1; i < n+1; i++) {
            int ch = str1[i-1] - 'a' + 1;
            hash1[i] = (hash1[i-1] * P + ch) % MOD;
            power1[i] = (power1[i-1] * P) % MOD;
        }
    }

    private long getHash(int l, int r, long[] hash, long[] power) {
        return (hash[r+1] - (hash[l] * power[r-l+1]) % MOD + MOD) % MOD;
    }

    private void dfs(int node) {
        if (graph[node].size() == 0) {
            start[node] = ind;
            str[ind] = ss[node];
            end[node] = ind;
            ind++;
            return;
        }

        start[node] = Integer.MAX_VALUE;
        for (int nex : graph[node]) {
            dfs(nex);
            start[node] = Math.min(start[node], start[nex]);
        }
        str[ind] = ss[node];
        end[node] = ind;
        ind++;
    }

    private List<Integer>[] graphBuilder(int[] parent) {
        int n = parent.length;
        List<Integer>[] graph = new List[n];
        for (int i = 0; i < n; i++) graph[i] = new ArrayList<Integer>();
        
        for (int i = 1; i < n; i++) {
            int p = parent[i];
            graph[p].add(i);
        }
        for (int i = 0; i < n; i++) Collections.sort(graph[i]);
        return graph;
    }
}",1427963737
SAY__MY__NAME,SAY__MY__NAME,412,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        if (nums.length == 1) return 0;

        int res = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] > nums[i+1]) {
                for (int j = 2; j * j <= nums[i]; j++) {
                    if (nums[i] % j == 0) {
                        nums[i] = j;
                        res++;
                        break;
                    }
                }
                if (nums[i] > nums[i+1]) return -1;
            }
        }

        return res;
    }
}",1427859904
Pushpender Singh,pushpenderindia,413,3502,python3,"from collections import defaultdict

class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        count = 0
        left = 0
        freq = defaultdict(int)
        
        for right in range(n):
            freq[s[right]] += 1  
            
            while any(freq[char] >= k for char in freq):
                count += (n - right)  
                freq[s[left]] -= 1  
                if freq[s[left]] == 0:
                    del freq[s[left]]  
                left += 1
        
        return count
",1427831972
Pushpender Singh,pushpenderindia,413,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = []
        current = """"
        
        for char in target:
            current += 'a'
            result.append(current)
            
            while current[-1] != char:
                current = current[:-1] + chr(ord(current[-1]) + 1)
                result.append(current)
        
        return result

        ",1427826191
Pushpender Singh,pushpenderindia,413,3603,python3,"from typing import List

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        for children in tree:
            children.sort()

        trav = []
        start = [0] * n
        end = [0] * n
        
        self.traverse(0, tree, s, trav, start, end)

        rev_trav = list(reversed(trav))
        M1 = 1000000007
        M2 = 1000000009
        B = 27

        p1 = [1] * (len(trav) + 1)
        p2 = [1] * (len(trav) + 1)

        for i in range(1, len(trav) + 1):
            p1[i] = (p1[i - 1] * B) % M1
            p2[i] = (p2[i - 1] * B) % M2

        h1 = [0] * (len(trav) + 1)
        h2 = [0] * (len(trav) + 1)

        for i in range(len(trav)):
            h1[i + 1] = (h1[i] * B + (ord(trav[i]) - ord('a') + 1)) % M1
            h2[i + 1] = (h2[i] * B + (ord(trav[i]) - ord('a') + 1)) % M2

        rh1 = [0] * (len(rev_trav) + 1)
        rh2 = [0] * (len(rev_trav) + 1)

        for i in range(len(rev_trav)):
            rh1[i + 1] = (rh1[i] * B + (ord(rev_trav[i]) - ord('a') + 1)) % M1
            rh2[i + 1] = (rh2[i] * B + (ord(rev_trav[i]) - ord('a') + 1)) % M2

        ans = [False] * n

        for i in range(n):
            l = start[i]
            r = end[i]
            hv1 = (h1[r + 1] - (h1[l] * p1[r - l + 1]) % M1 + M1) % M1
            hv2 = (h2[r + 1] - (h2[l] * p2[r - l + 1]) % M2 + M2) % M2
            rl = len(trav) - 1 - r
            rr = len(trav) - 1 - l
            rhv1 = (rh1[rr + 1] - (rh1[rl] * p1[rr - rl + 1]) % M1 + M1) % M1
            rhv2 = (rh2[rr + 1] - (rh2[rl] * p2[rr - rl + 1]) % M2 + M2) % M2
            
            if hv1 == rhv1 and hv2 == rhv2:
                ans[i] = True

        return ans

    def traverse(self, node: int, tree: List[List[int]], s: str, trav: List[str], start: List[int], end: List[int]):
        start[node] = len(trav)
        for child in tree[node]:
            self.traverse(child, tree, s, trav, start, end)
        trav.append(s[node])
        end[node] = len(trav) - 1


",1427915093
Pushpender Singh,pushpenderindia,413,3607,python3,"from typing import List

class Solution:
    def max_proper_divisor(self, x: int) -> int:
        for i in range(2, int(x**0.5) + 1):
            if x % i == 0:
                return x // i
        return 1

    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        operations = 0

        for i in range(n - 2, -1, -1):
            while nums[i] > nums[i + 1]:
                divisor = self.max_proper_divisor(nums[i])
                if divisor == 1:
                    return -1
                nums[i] //= divisor 
                operations += 1

        return operations


",1427883331
Sean,shaun001280,414,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        vector<int> cnt(256);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            bool ok = false;
            fill(cnt.begin(), cnt.end(), 0);
            for (int j = i; j < n; ++j) {
                if ((++cnt[s[j]]) >= k) {
                    ok = true;
                }
                if (ok) ans++;
            }
        }
        return ans;
    }
};",1427928534
Sean,shaun001280,414,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for (auto c : target) {
            s += ""a"";
            ans.push_back(s);
            while (s.back() != c) {
                int x = s.back() - 'a';
                x = (x + 1) % 26;
                s.back() = x + 'a';
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427921803
Sean,shaun001280,414,3603,cpp,"class Solution {
  private:
    static constexpr unsigned long long P1 = 91;
    static constexpr unsigned long long P2 = 131;

  public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();

        vector<unsigned long long> pow1(n + 1), pow2(n + 1);
        vector<unsigned long long> lhash1(n), rhash1(n);
        vector<unsigned long long> lhash2(n), rhash2(n);
        vector<int> sz(n);
        vector<bool> ans(n);
        vector<vector<int>> g(n);

        pow1[0] = pow2[0] = 1;
        for (int i = 1; i <= n; ++i) {
            pow1[i] = pow1[i - 1] * P1;
            pow2[i] = pow2[i - 1] * P2;
        }

        for (int i = 1; i < n; ++i) {
            g[parent[i]].push_back(i);
        }

        function<void(int)> dfs = [&](int cur) {
            sz[cur] = 1;
            int n = g[cur].size();

            for (int i = 0; i < n; ++i) {
                dfs(g[cur][i]);
                sz[cur] += sz[g[cur][i]];
            }

            for (int i = 0, prev = sz[cur]; i < n; ++i) {
                prev -= sz[g[cur][i]];
                lhash1[cur] += lhash1[g[cur][i]] * pow1[prev];
                lhash2[cur] += lhash2[g[cur][i]] * pow2[prev];
            }

            lhash1[cur] += s[cur], lhash2[cur] += s[cur];

            rhash1[cur] += s[cur] * pow1[sz[cur] - 1];
            rhash2[cur] += s[cur] * pow2[sz[cur] - 1];
            for (int i = n - 1, prev = sz[cur] - 1; i >= 0; --i) {
                prev -= sz[g[cur][i]];
                rhash1[cur] += rhash1[g[cur][i]] * pow1[prev];
                rhash2[cur] += rhash2[g[cur][i]] * pow2[prev];
            }

            if (rhash1[cur] == lhash1[cur] && rhash2[cur] == lhash2[cur])
                ans[cur] = true;
        };

        dfs(0);
        // for (int i = 0; i < n; ++i) {
        //     cout << lhash2[i] << "" "" << rhash2[i] << endl;
        // }
        return ans;
    }
};",1427915191
Sean,shaun001280,414,3607,cpp,"class Solution {
    static int* divisor;
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        if (divisor == nullptr) {
            divisor = new int[1000001];
            for (int i = 1; i <= 1000000; ++i) {
                for (int j = i + i; j <= 1000000; j += i) {
                    divisor[j] = max(divisor[j], i);
                }
            }
        }
        
        int ans = 0;
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                if (divisor[nums[i]] == 1) return -1;
                nums[i] /= divisor[nums[i]];
                ans++;
            }
        }
        return ans;
    }
};
int* Solution::divisor = nullptr;",1427963941
Sundeep Chenreddy,chenreddy0207,415,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        int j=0;
        int maxCount=0;
        int ans=0;
        vector<int> cnts(26,0);
        
        for(int i=0;i<n;i++)
        {
            while(j<n and maxCount<k)
            {
                int x=s[j]-'a';
                cnts[x]++;
                j++;
                maxCount=max(maxCount,cnts[x]);
            }
            
            if(maxCount==k)
            {
                ans+=n+1-j;
            }
            
            int x=s[i]-'a';
            cnts[x]--;
            maxCount=0;
            for(auto&p:cnts)
            {
                maxCount=max(maxCount,p);
            }
        }
        
        return ans;
    }
};",1427875073
Sundeep Chenreddy,chenreddy0207,415,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        
        vector<string> result;
        string current;
        for(auto&x:target)
        {
            current.push_back('a');
            int pos=current.size()-1;
            char last=current[pos];
            while(last!=x)
            {
                result.push_back(current);
                current[pos]++;
                last=current[pos];
            }
            result.push_back(current);
        }
        return result;
    }
};",1427827620
Sundeep Chenreddy,chenreddy0207,415,3603,cpp,"class Solution {
    
    void DFS(string& dfsstr, string& s, vector<vector<int>>& Adj, int idx, vector<bool>& ans, vector<int>& substring_srt, vector<int>& substring_end)
    {
        substring_srt[idx]=dfsstr.size();
        for(auto&x:Adj[idx])
        {
            DFS(dfsstr, s, Adj,x, ans, substring_srt, substring_end);
        }
        
        substring_end[idx]=dfsstr.size();
        dfsstr.push_back(s[idx]);
    }
    
    vector<int> getManacher(string s)
    {
        int n=s.size();
        int l=0;
        int r=0;
        
        vector<int> manacherArray(n,0);
        
        for(int i=0;i<n;i++)
        {
            if(r<=i)
            {
                l=i;
                r=i;
                
                while(l>=0 && r<n && s[l]==s[r])
                {
                    l--;
                    r++;
                }
                manacherArray[i]=r-i;
                continue;
            }
            int icomp = r+l-i;
            if(i+manacherArray[icomp]<r)
            {
                manacherArray[i]=manacherArray[icomp];
                continue;
            }
            
            l=i-(r-i);
            while(l>=0 && r<n && s[l]==s[r])
            {
                l--;
                r++;
            }
            manacherArray[i]=r-i;
        }
        
        return manacherArray;
    }
    
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        
        int n=parent.size();
        vector<vector<int>> Adj(n);
        for(int i=1;i<n;i++)
        {
            int src=parent[i];
            int dst=i;
            Adj[src].push_back(dst);
        }
        
        for(auto&v:Adj)
        {
            sort(v.begin(),v.end());
        }
        
        vector<int> substring_srt(n);
        vector<int> substring_end(n);
        string dfsstr;
        vector<bool> ans(n,false);
        
        DFS(dfsstr, s, Adj, 0, ans, substring_srt, substring_end);
        
        string newArr=""*"";
        for(int i=0;i<n;i++)
        {
            newArr.push_back(dfsstr[i]);
            newArr.push_back('*');
        }
        
        vector<int> manacherArray = getManacher(newArr);
        
        for(int i=0;i<n;i++)
        {
            int srt=substring_srt[i];
            int end=substring_end[i];
            
            //srt will be at 2*srt
            //end will be at 2*end
            srt=2*srt+1;
            end=2*end+1;
            
            int mid=(srt+end)/2;
            
            if(manacherArray[mid]+mid>end)
            {
                ans[i]=true;
            }
        }
        
        return ans;
    }
};",1427955723
Sundeep Chenreddy,chenreddy0207,415,3607,cpp,"class Solution {
    inline static bool processed=false;
    const static int LIM=1e6+1;
    static vector<int> smallestNonTrivialDivisor;
    static vector<bool> isPrime;
public:
    
    int minOperations(vector<int>& nums) {
        
        
        if(!processed)
        {
            processed=true;
            smallestNonTrivialDivisor.resize(LIM,1);
            isPrime.resize(LIM,true);

            for(int i=2;i<LIM;i++)
            {
                if(!isPrime[i]) continue;
                smallestNonTrivialDivisor[i]=i;
                for(int j=2*i;j<LIM;j+=i)
                {
                    if(smallestNonTrivialDivisor[j]==1) smallestNonTrivialDivisor[j]=i;
                    isPrime[j]=false;
                }
            }
        }
        
        int n=nums.size();
        int ops=0;
        for(int i=n-2;i>=0;i--)
        {
            if(nums[i]>nums[i+1])
            {
                nums[i]=smallestNonTrivialDivisor[nums[i]];
                ops++;
            }
            if(nums[i]>nums[i+1])   return -1;
        }
        
        return ops;
    }
};

vector<int> Solution::smallestNonTrivialDivisor;
vector<bool> Solution::isPrime;",1427861285
Vamshi Krishna Kyatham,vamshikrishnakyatham,416,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        long count = 0;
        for(int i = 0; i < n; i++) {
            int[] freq = new int[26];
            boolean hasK = false;
            for(int j = i; j < n; j++) {
                char c = s.charAt(j);
                freq[c - 'a']++;
                if(!hasK && freq[c - 'a'] >= k) hasK = true;
                if(hasK) count++;
            }
        }
        return (int)count;
    }
}",1427859353
Vamshi Krishna Kyatham,vamshikrishnakyatham,416,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> seq = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < target.length(); i++) {
            sb.append('a');
            seq.add(sb.toString());
            char targetChar = target.charAt(i);
            int press = (targetChar - 'a' + 26) % 26;
            for(int p = 0; p < press; p++) {
                char lastChar = sb.charAt(sb.length() - 1);
                char nextChar = (lastChar == 'z') ? 'a' : (char)(lastChar + 1);
                sb.setCharAt(sb.length() - 1, nextChar);
                seq.add(sb.toString());
            }
        }
        return seq;
    }
}",1427847500
Vamshi Krishna Kyatham,vamshikrishnakyatham,416,3603,java,"class Solution {
    private List<List<Integer>> children;
    private String s;
    private boolean[] answer;
    private StringBuilder traversal;
    private int[] start;
    private int[] end;
    private long[] preHash1;
    private long[] preHashRev1;
    private long[] preHash2;
    private long[] preHashRev2;
    private long[] power1;
    private long[] power2;
    private final long MOD1 = 1000000007;
    private final long MOD2 = 1000000009;
    private final long BASE1 = 911382629;
    private final long BASE2 = 3571428571L;

    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        this.s = s;
        this.answer = new boolean[n];
        this.children = new ArrayList<>(n);
        for(int i =0;i<n;i++) children.add(new ArrayList<>());
        int root = -1;
        for(int i=0;i<n;i++){
            if(parent[i] == -1){
                root = i;
            }
            else{
                children.get(parent[i]).add(i);
            }
        }
        for(int i=0;i<n;i++) {
            Collections.sort(children.get(i));
        }
        traversal = new StringBuilder();
        start = new int[n];
        end = new int[n];
        dfs(root);
        int len = traversal.length();
        String reversedTraversal = traversal.reverse().toString();
        traversal.reverse();
        preHash1 = new long[len +1];
        preHash2 = new long[len +1];
        helper(traversal.toString(), preHash1, preHash2, BASE1, BASE2, MOD1, MOD2);
        preHashRev1 = new long[len +1];
        preHashRev2 = new long[len +1];
        helper(reversedTraversal, preHashRev1, preHashRev2, BASE1, BASE2, MOD1, MOD2);
        power1 = new long[len +1];
        power2 = new long[len +1];
        power1[0] = 1;
        power2[0] = 1;
        for(int i=1;i<=len;i++) {
            power1[i] = (power1[i-1] * BASE1) % MOD1;
            power2[i] = (power2[i-1] * BASE2) % MOD2;
        }
        for(int i=0;i<n;i++) {
            int l = start[i];
            int r = end[i];
            long hash1_orig = getHash(preHash1, power1, l, r, MOD1);
            long hash2_orig = getHash(preHash2, power2, l, r, MOD2);
            int rl = len - r;
            int rr = len - l;
            long hash1_rev = getHash(preHashRev1, power1, rl, rr, MOD1);
            long hash2_rev = getHash(preHashRev2, power2, rl, rr, MOD2);
            if(hash1_orig == hash1_rev && hash2_orig == hash2_rev){
                answer[i] = true;
            }
            else{
                answer[i] = false;
            }
        }
        return answer;
    }

    public void dfs(int node){
        start[node] = traversal.length();
        for(int child : children.get(node)){
            dfs(child);
        }
        traversal.append(s.charAt(node));
        end[node] = traversal.length();
    }

    public void helper(String str, long[] h1, long[] h2, long b1, long b2, long mod1, long mod2){
        h1[0] = 0;
        h2[0] = 0;
        for(int i=0;i<str.length();i++) {
            h1[i+1] = (h1[i] * b1 + (str.charAt(i) - 'a' +1)) % mod1;
            h2[i+1] = (h2[i] * b2 + (str.charAt(i) - 'a' +1)) % mod2;
        }
    }

    private long getHash(long[] preHash, long[] power, int l, int r, long MOD){
        long ans = (preHash[r] - (preHash[l] * power[r - l]) % MOD + MOD) % MOD;
        return ans;
    }
}",1427948555
Vamshi Krishna Kyatham,vamshikrishnakyatham,416,3607,java,"class Solution {
    public class State {
        int val;
        int op;
        public State(int val, int op) {
            this.val = val;
            this.op = op;
        }
    }
    public int minOperations(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        List<State> prev = helper(nums[0]);
        prev.sort(Comparator.comparingInt(a -> a.val));
        for(int i = 1; i < nums.length; i++) {
            List<State> curr = helper(nums[i]);
            curr.sort(Comparator.comparingInt(a -> a.val));
            List<State> newPrev = new ArrayList<>();
            int p = 0;
            int minOps = Integer.MAX_VALUE;
            for(State cur: curr) {
                while(p < prev.size() && prev.get(p).val <= cur.val) {
                    minOps = Math.min(minOps, prev.get(p).op);
                    p++;
                }
                if(minOps != Integer.MAX_VALUE) {
                    newPrev.add(new State(cur.val, minOps + cur.op));
                }
            }
            if(newPrev.isEmpty()) return -1;
            newPrev.sort(Comparator.comparingInt(a -> a.val));
            List<State> optim = new ArrayList<>();
            int last = -1;
            int minOp = Integer.MAX_VALUE;
            for(State s: newPrev) {
                if(s.val != last) {
                    if(last != -1) optim.add(new State(last, minOp));
                    last = s.val;
                    minOp = s.op;
                }
                else minOp = Math.min(minOp, s.op);
            }
            if(last != -1) optim.add(new State(last, minOp));
            prev = optim;
        }
        int ans = Integer.MAX_VALUE;
        for(State s: prev) {
            ans = Math.min(ans, s.op);
        }
        return ans == Integer.MAX_VALUE ? -1: ans;
    }
    private List<State> helper(int x){
        List<State> list = new ArrayList<>();
        int count =0;
        while(true){
            list.add(new State(x, count));
            int gpd = helper2(x);
            if(gpd <1){
                break;
            }
            int next_x = x / gpd;
            if(next_x == x){
                break;
            }
            x = next_x;
            count++;
        }
        return list;
    }
    private int helper2(int x){
        if(x <=1){
            return -1;
        }
        int sqrt = (int)Math.sqrt(x);
        for(int i=2; i<=sqrt; i++){
            if(x % i ==0){
                return x / i;
            }
        }
        return 1;
    }
}",1427881918
Nguyễn Minh,minhnguyenxuan60,417,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int r = -1;
        map<int, int> cnt;
        auto isOk = [&]() {
            bool ok = false;
            for (char c = 'a'; c <= 'z'; c++) if (cnt[c] >= k) ok = true;
            return ok; 
        };
        long long ans = 0;
        for (int l = 0; l < (int)s.size(); l++) {
            while(r + 1 < (int)s.size() && !isOk()) {
                cnt[s[++r]]++;
            }
            if (isOk()) ans += s.size() - r;
            cout << l << "" "" << r << '\n';
            cnt[s[l]]--;
        }


        return ans;
    }
};",1427830075
Nguyễn Minh,minhnguyenxuan60,417,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur = """";
        vector<string> ans;
        for (int i = 0; i < (int)target.size(); i++) {
            if(cur.size() <= i) cur += 'a';
            ans.push_back(cur);
            while(cur.back() + 1 <= target[i]) {
                cur.back() += 1;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824325
Nguyễn Minh,minhnguyenxuan60,417,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        string str;
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) adj[parent[i]].push_back(i);
        } 
        vector<int> siz(n, 1), p(n);
        function<void(int)> dfs = [&](int u) {
            sort(adj[u].begin(), adj[u].end());
            for (int child: adj[u]) {
                dfs(child);
                siz[u] += siz[child];
            }
            p[u] = str.size() - siz[u] + 2;
            // cout << u << s[u] << '\n';
            str += s[u];
        };
        dfs(0);

        vector<bool> ans(n);

        vector<long long> hashForward(n + 1), hashBackward(n + 2), powb(n + 1);
        // hashForward[i] = s[0] * a ^ i + s[1] * a ^ (i - 1) + ...
        long long b = 31, mod = 1e9 + 7;
        powb[0] = 1;
        for (int i = 1; i <= n; i++) {
            hashForward[i] = (hashForward[i - 1] * b + str[i - 1] - 'a' + 1) % mod;
            powb[i] = powb[i - 1] * b % mod;
        }   

        // cout << str << '\n';

        for (int i = n; i >= 1; i--) {
            hashBackward[i] = (hashBackward[i + 1] * b + str[i - 1] - 'a' + 1) % mod;
        }


        auto getForward = [&](int l, int r) {
            long long tmp = (hashForward[r] - hashForward[l - 1] * powb[r - l + 1] % mod) % mod;
            return (tmp + mod) % mod;
        };

        // cout << n << '\n';
        
        auto getBackward = [&](int l, int r) {
            long long tmp = (hashBackward[l] - hashBackward[r + 1] * powb[r - l + 1] % mod) % mod;
            // cout << l << "" "" << r << "" "" << hashBackward[l] << ""! "" << hashBackward[r + 1] * powb[r - l + 1] << '\n';
            return (tmp + mod) % mod;
        };


        // for (int i = 1; i <= n; i++) cout << i << "" "" << hashBackward[i] << '\n';
        // cout << getBackward(4, 5) << '\n';

        for (int i = 0; i < n; i++) {
            int l = p[i], r = p[i] + siz[i] - 1;
            if (getForward(l, r) == getBackward(l, r)) ans[i] = true;
            else ans[i] = false;
        }

        return ans;

    }
};",1427932526
Nguyễn Minh,minhnguyenxuan60,417,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        int n = nums.size();
        int pre = 1e9;
        for (int i = n - 1; i >= 0; i--) {
            while (nums[i] > pre) {
                bool found = false;
                for (int val = 2; val * val <= nums[i]; val++) {
                    if (nums[i] % val == 0) {
                        found = true;
                        nums[i] = val;
                        ans++;
                        break;
                    }
                }
                if (!found) return -1;
            }
            pre = nums[i];
        }
        return ans;
    }
};",1427855522
Yucheng Dai,Rainingcity,418,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        vector<int> freqs(128, 0);
        int i = 0, j = 0;
        int cnt = 0;
        int ans = 0;
        for(; i < n; i++) {
            while(cnt == 0 && j < n) {
                freqs[s[j]]++;
                if (freqs[s[j]] == k) cnt++;
                j++;
            }
            // cout << j << "" "" << cnt << endl;
            if (j == n && cnt == 0) break;
            ans += n - j + 1;
            if (freqs[s[i]] == k) cnt--;
            freqs[s[i]]--;
        }
        return ans;
    }
};",1427831757
Yucheng Dai,Rainingcity,418,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        vector<string> ans{};
        for(int i = 0; i < target.length(); i++) {
            for(char c = 'a'; c <= target[i]; c++)
                ans.push_back(s + c);
            s += target[i];
        }
        return ans;
    }
};",1427824533
Yucheng Dai,Rainingcity,418,3603,cpp,"typedef long long ll;
ll MOD = 10000019;
class Solution {
private:
    pair<pair<ll, ll>, int> check_hashs(int i, int prev, vector<vector<int>>& graph, string& s, vector<bool>& ans, vector<ll>& powers, ll p) {
        ll fwd_hash = 0, rev_hash = 0;
        int l = 0;
        for(int j: graph[i]) {
            if (j == prev) continue;
            auto [hs, lj] = check_hashs(j, i, graph, s, ans, powers, p);
            fwd_hash = (fwd_hash * powers[lj] + hs.first) % MOD;
            rev_hash = (hs.second * powers[l] + rev_hash) % MOD;
            l += lj;
        }
        fwd_hash = (fwd_hash * p + (s[i] - 'a')) % MOD;
        rev_hash = ((s[i] - 'a') * powers[l] + rev_hash) % MOD;
        l++;
        ans[i] = ans[i] && (fwd_hash == rev_hash);
        return make_pair(make_pair(fwd_hash, rev_hash), l);
    }
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> graph(n);
        for(int i = 1; i < n; i++) {
            graph[parent[i]].push_back(i);
        }
        vector<bool> ans(n, true);
        ll p = 31;
        vector<ll> powers{1};
        for(int i = 1; i < n; i++) {
            powers.push_back((powers.back() * p) % MOD);
        }
        check_hashs(0, -1, graph, s, ans, powers, p);
        p = 37;
        powers.clear();powers.push_back(1);
        for(int i = 1; i < n; i++) {
            powers.push_back((powers.back() * p) % MOD);
        }
        check_hashs(0, -1, graph, s, ans, powers, p);
        p = 47;
        powers.clear();powers.push_back(1);
        for(int i = 1; i < n; i++) {
            powers.push_back((powers.back() * p) % MOD);
        }
        check_hashs(0, -1, graph, s, ans, powers, p);
        return ans;
    }
};",1427924508
Yucheng Dai,Rainingcity,418,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> f(1001, 0);
        vector<int> primes{};
        f[1] = 1;
        for(int i = 2; i <= 1000; i++) {
            if (f[i] == 0) primes.push_back(i);
            for(int j = 0; j < primes.size() && i * primes[j] <= 1000; j++) {
                f[i * primes[j]] = primes[j];
                if (i % primes[j] == 0) break;
            }
        }
        int cnt = 0;
        int cur_max = nums.back();
        for(int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] > cur_max) {
                for(int j = 0; j < primes.size(); j++) {
                    if (nums[i] % primes[j] == 0) {
                        nums[i] = primes[j];
                        break;
                    }
                }
                cnt++;
                if (nums[i] > cur_max) return -1;
            }
            cur_max = nums[i];
        }
        return cnt;
    }
};",1427855453
Christopher,xbluedevilx,419,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        # sliding window, once you hit k counts, plus number of substrings formable
        # decrement window and try to form again and repeat
        streak = 0
        left = 0
        res = 0
        counts = defaultdict(int)
        n = len(s)
        
        for i in range(n):
            c = s[i]
            counts[c] += 1
            while counts[c] == k:
                res += n - i
                counts[s[left]] -= 1
                left += 1
        return res
                    ",1427882288
Christopher,xbluedevilx,419,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        output = """"
        res = []
        for c in target:
            for i in range(ord(c) - ord(""a"")+1):
                output_char = chr(ord(""a"") + i)
                res.append(output + output_char)
            output += output_char
        return res",1427863505
Christopher,xbluedevilx,419,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        cache1 = ["""" for _ in range(n)]
        res = [False for _ in range(n)]
        nodes = [Node(i, s[i]) for i in range(n)]
        for i, p in enumerate(parent):
            if i > 0:
                nodes[p].children.append(nodes[i])
        root = nodes[0]
        
        def dfs(node):
            dfsStr = """"
            preStrs = []
            for child in node.children:
                post, pre = dfs(child)
                dfsStr += post
                preStrs.append(pre)
            dfsStr += node.val
            preStr = node.val + """".join(reversed(preStrs))
            res[node.id] = dfsStr == preStr
            return [dfsStr, preStr]
        dfs(root)
        return res
            
            
            
            

class Node:
    def __init__(self, id, val):
        self.id = id
        self.val = val
        self.children = []
    
    def __repr__(self):
        print(self.id, self.val, len(self.children))",1427956831
Christopher,xbluedevilx,419,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        # from right to left, try to form non-decreasing sequence
        # n sqrt n time
        n = len(nums)
        res = 0
        for i in range(n-2, -1, -1):
            if nums[i] <= nums[i+1]:
                continue
            while nums[i] > nums[i+1]:
                if nums[i] <= 3:
                    return -1
                for j in range(2, ceil(sqrt(nums[i]) + 1)):
                    q, r = divmod(nums[i], j)
                    if r == 0:
                        # we can divide, the quotient is the greatest common divisor
                        nums[i] //= q
                        res += 1
                        break
                else:
                    return -1
                
        return res",1427907589
Rohan Bhardwaj,RohanBhardwaj08,421,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ma = 0;
        vector<int> c(26,0);
        int ans = 0;
        int j = 0;
        // char ma_c = '$';
        for(int i =0;i<s.size();i++){
            c[s[i]-'a']++;
            bool b =0;
            for(int i=0;i<26;i++){
                if(c[i]>=k){
                    b = 1;
                    break;
                }
            }
            while(b){
                c[s[j]-'a']--;
                j++;
                int count = 0;
                for(int i=0;i<26;i++){
                    if(c[i]>=k) count++;
                }
                if(count==0){
                    j--;
                    c[s[j]-'a']++;
                    break;
                }
            }
            if(b)ans += j+1;
        }
        return ans;
    }
};",1427841357
Rohan Bhardwaj,RohanBhardwaj08,421,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string curr ;
        vector<string> ans;
        for(int i=0;i<target.size();i++){
            curr+= 'a';
            ans.push_back(curr);
            for(int j = 1;j<26;j++){
                if(curr.back()== target[i]) break;
                curr.back() = curr.back()+1;
                ans.push_back(curr);
            }
            
        }
        return ans;
    }
};",1427825559
Rohan Bhardwaj,RohanBhardwaj08,421,3603,cpp,"class Solution {
public:
    pair<long long,int> dfs(vector<long long> &has, int mod,vector<vector<int>> &g, int curr, string &s ,vector<long long> &pow){
        int count = 0;
        long long hash = 0;
        for(int child: g[curr]){
            pair<long long, int> p = dfs(has, mod, g, child, s,pow);
            if(count==0){
                hash = p.first;
            }else{
                hash = (hash + (p.first*pow[count])%mod)%mod;
            }
            count += p.second;
        }
        hash = (hash + (pow[count]*(s[curr]-'a'))%mod)%mod;
        has[curr] = hash;
        count++;
        return {hash,count};
    }
    pair<long long,int> redfs(vector<long long> &rehas, int mod,vector<vector<int>> &g, int curr, string &s ,vector<long long> &pow){
        int count = 1;
        long long hash = s[curr]-'a';
        
        for(int i=g[curr].size()-1;i>-1;i--){
            int child = g[curr][i];
            pair<long long, int> p = redfs(rehas, mod, g, child, s,pow);
            
            hash = (hash + (p.first*pow[count])%mod)%mod;
            count += p.second;
        }
        rehas[curr] = hash;
        return {hash,count};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<long long > hash(n,-1), rehash(n,-1);
        vector<vector<int>> g(n);
        for(int i=0;i<n;i++){
            if(parent[i]!=-1){
                g[parent[i]].push_back(i);
            }
        }
        for(int i=0;i<n;i++) sort(g[i].begin(),g[i].end());
        vector<long long> pow(n+1,1);
        for(int i=1;i<=n;i++){
            pow[i] = (pow[i-1]*31)%1000000009;
        }
        vector<bool> ans(n,1);
        dfs(hash,1000000009, g, 0, s,pow);
        redfs(rehash,1000000009, g, 0, s,pow);
        for(int i =0;i<n;i++){
            ans[i] = rehash[i]==hash[i];
        }
        return ans;
    }
};",1427965901
Rohan Bhardwaj,RohanBhardwaj08,421,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        vector<int> p(1e6+1,1);
        for(int i=2;i<=1e3;i++){
            if(p[i]!=1) continue;
            for(int j =2;j*i<=1e6;j++){
                if(p[i*j]!=1) continue;
                p[i*j] = j;
            }
        }
        int ans  =0;
        for(int  i= n-2;i>-1;i--){
            while(nums[i]>nums[i+1]){
                if(p[nums[i]]==1) return -1;
                nums[i]/= p[nums[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427864583
ks811489,ks811489,422,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        // HashMap<Integer,Integer> map = new HashMap<>();
        int ans =0;
        int len = s.length();
        for(int i =0 ;i<len;i++){
            int arr[] = new int[26];
            for(int j =i;j<len;j++){
                int m = s.charAt(j)-'a';
                arr[m]++;
                if(arr[m]>=k){
                    ans += s.length()-j;
                    break;
                }
            }    
        }
        return ans;
    }
}",1427833906
ks811489,ks811489,422,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String>ans = new ArrayList<>();
        StringBuilder x = new StringBuilder();
        for(int i =0 ;i < target.length();i++){
            char p ='a';
            while(p!=target.charAt(i)){
                ans.add( x.toString()+p );
                if(p=='z'){
                    p='a';
                }else{
                    p = (char)(p+1) ;
                }
            }
            x.append(p);
            ans.add(x.toString() );
        }
        return ans;
    }
}",1427827592
ks811489,ks811489,422,3603,python3,"class Solution:
    def __init__(self):
        self.list = []  
        self.dp = []
        self.P = []  
        self.tree = []  

    def findAnswer(self, parent, s):
        n = len(parent)
        self.dp = [0] * n
        self.tree = [[] for _ in range(n)]
        
        for i in range(1, n):
            self.tree[parent[i]].append(i)
        
        for i in range(n):
            self.tree[i].sort()
        
        self.dfs(0)
        
        man = ''.join(s[i] for i in self.list)
        
        self.manacher(man)
        
        result = [False] * n
        
        for i in range(n):
            node = self.list[i]
            result[node] = self.is_palindrome_query(i - self.dp[node] + 1, i)
        
        return result

    def manacher(self, s):
        n = len(s)
        sb = ['#'] * (2 * n + 1)
        
        for i in range(n):
            sb[2 * i + 1] = s[i]
        
        t = ''.join(sb)
        m = len(t)
        self.P = [0] * m
        c, r = 0, 0
        
        for i in range(m):
            mirror = 2 * c - i
            if i < r:
                self.P[i] = min(r - i, self.P[mirror])
            
            while i + self.P[i] + 1 < m and i - self.P[i] - 1 >= 0 and t[i + self.P[i] + 1] == t[i - self.P[i] - 1]:
                self.P[i] += 1
            
            if i + self.P[i] > r:
                c = i
                r = i + self.P[i]

    def is_palindrome_query(self, l, r):
        l_pos = 2 * l + 1
        r_pos = 2 * r + 1
        center = (l_pos + r_pos) // 2
        
        return self.P[center] >= (r_pos - l_pos) // 2

    def dfs(self, node):
        res = 1
        for adj in self.tree[node]:
            res += self.dfs(adj)
        self.list.append(node)
        self.dp[node] = res
        return res

# if __name__ == ""__main__"":
#     solution = Solution()

#     parent = [-1, 0, 0, 1, 1]
#     s = ""ababa""

#     result = solution.findAnswer(parent, s)

#     for i, is_palindrome in enumerate(result):
#         print(f""Node {i}: {'Palindrome' if is_palindrome else 'Not Palindrome'}"")
",1427966103
ks811489,ks811489,422,3607,java,"class Solution {
    static int dp[] = new int[(int)(1e6)+1];
    public int minOperations(int[] nums) {
        if(dp[10]==0){
            dp[1]= 1;
            for(int i =2;i<dp.length;i++){
                if(dp[i]==0){
                    dp[i]=1;
                    for(int j= 2;i*j<dp.length;j++){
                        if(dp[i*j]==0){
                            dp[i*j]= i;
                        }
                    }
                }

            }
        }
        int ans=0;
        int len = nums.length;
        for(int i=len-2;i>=0;i--){
            if(nums[i]<=nums[i+1]){
                continue;
            }else{
                while(nums[i]>nums[i+1] && dp[nums[i]]!=1 ){
                    nums[i]=dp[nums[i]];
                    ans++;
                }
                if(nums[i]>nums[i+1]){
                    return -1;
                }
            }
        }
        return ans;
    }
}",1427857151
Yuriy Kaminskiy,yumkam,423,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string_view s, int k) {
        int ret = 0;
        const unsigned n = s.size();
        for (unsigned i = 0; i < n; ++i) {
            unsigned cntk = 0;            
            array<unsigned, 26> cnt{};
            for (unsigned j = i; j < n; ++j) {
                auto &c = cnt[s[j] - 'a'];
                if (++c == k) {
                    ret += n - j;
                    break;
                }
            }
        }
        return ret;
    }
};",1427837489
Yuriy Kaminskiy,yumkam,423,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ret;
        string cur;
        for (auto c: target) {
            cur += 'a';
            ret.push_back(cur);
            auto &b = cur.back();
            while(b != c) {
                ++b;
                ret.push_back(cur);
            }
        }
        return ret;
    }
};",1427826703
Yuriy Kaminskiy,yumkam,423,3603,cpp,"#ifndef MODARITH_V2_HPP
#define MODARITH_V2_HPP
#include <cinttypes>
#include <limits>
#include <type_traits>
#include <tuple>
#include <cassert>
namespace std { // XXX HACK WARNING: altering std:: namespace is generally bad thing
    template <> struct make_signed<unsigned __int128> { typedef __int128 type; };
    template <> struct make_unsigned<__int128> { typedef unsigned __int128 type; };
}
namespace modarith {
    namespace {
        template <typename T> struct double_int {};
        template <> struct double_int<uint8_t> { typedef uint16_t type; };
        template <> struct double_int<uint16_t> { typedef uint32_t type; };
        template <> struct double_int<uint32_t> { typedef uint64_t type; };
        template <> struct double_int<uint64_t> { typedef unsigned __int128 type; };
        template <typename T> using make_double_int_t = std::conditional_t<std::is_signed_v<T>, std::make_signed_t<typename double_int<std::make_unsigned_t<T>>::type>, typename double_int<T>::type>;
    };

    template <typename T = uint32_t, T MOD = 1'000'000'007>
    struct mod {
        typedef T type;
	static constexpr T modulo = MOD;
        // a, b \in [0, modulo)
        static constexpr T add(T a, T b) { // a += b
            static_assert(modulo - 1 <= std::numeric_limits<decltype(b)>::max() - modulo);
            if ((a += b) >= modulo)
                a -= modulo;
            return a;
        }
        // a, b \in [0, modulo)
        static constexpr T sub(T a, T b) { // a -= b
            static_assert(modulo <= std::numeric_limits<decltype(b)>::max() - (modulo - 1));
            if (a < b)
                a += modulo;
            return a - b;
        }
        // a \in [0, modulo)
        static constexpr T neg(T a) { // a = -a
            return a == 0 ? a : modulo - a;
        }
        // a, b \in [0, modulo)
        static constexpr T mul(T a, T b) { // a *= b
            make_double_int_t<T> c = a;
            static_assert(modulo - 1 <= std::numeric_limits<decltype(c)>::max()/(modulo - 1));
            return (c*b) % modulo;
        }
        static constexpr T addmul(T a, T b, T c) {
            using double_type = make_double_int_t<T>;
            static_assert(modulo - 1 <= (std::numeric_limits<double_type>::max() - (modulo - 1))/(modulo - 1));
            return (a + b*static_cast<double_type>(c)) % modulo;
        }
        // a \in [0, modulo), n integer; time = O(log n)
        template <typename N>
        static constexpr T pow(T a, N n) { // a**n
            if (!n)
                return 1;
            for (; (n & 1) == 0; n >>= 1)
                a = mul(a, a);
            T r = a; n >>= 1;
            for(; n; n >>= 1) {
                a = mul(a, a);
                if ((n & 1))
                    r = mul(r, a);
            }
            return r;
        }
        // a \in [0, modulo); time = O(log modulo)
        static constexpr T inv(T a) { // (1/a)
            // static_assert(is_prime(modulo));
            return pow(a, modulo - 2);
        }
        private:
            static constexpr T gcd(T a, T b, std::make_signed_t<T> & x, std::make_signed_t<T> & y) {
                x = 1; y = 0;
                std::make_signed_t<T> x1 = 0, y1 = 1;
                while (b) {
                    std::make_signed_t<T> q = a / b; // 0 <= q < a; q * b <= a
                    std::tie(x, x1) = std::make_pair ( x1, x - q * x1 );
                    std::tie(y, y1) = std::make_pair ( y1, y - q * y1 );
                    std::tie(a, b)  = std::make_pair ( b,  a - q * b  );
                }
                // assert(abs(x) < modulo);
                return a;
            }
        public:
        static constexpr T inv_alt(T a) {
            std::make_signed_t<decltype(a)> x = 1, y = 0;
            static_assert(modulo <= std::numeric_limits<decltype(x)>::max());
            auto g = gcd(a, modulo, x, y);
            assert(g == 1);
            if (x < 0) x += modulo;
            return x;
        }
        // a, b, r \in [0, modulo), n integer; time = O(log n)
        template <typename N>
        static constexpr T mulpow(T r, T a, N n) { // r*(a**n)
            for(;;) {
                if ((n & 1))
                    r = mul(r, a);
                if ((n >>= 1) == 0)
                    break;
                a = mul(a, a);
            }
            return r;
        }
        // a, b \in [0, modulo); time = O(log modulo)
        static constexpr T divmod(T a, T b) { // a/b
            // static_assert(is_prime(modulo));
            return mulpow(a, b, modulo - 2);
        }
        // n integer; time = O(n)
        template <typename N>
        static constexpr T fact(N n) { // n!
            T r = 1;
            for(; n > 1; n--)
                r = mul(r, n);
            return r;
        }
        // time = O(min(k, n - k) + log modulo)
        template <typename N>
        static constexpr T choose(N n, N k) { // n choose k
            if (k > n - k)
                k = n - k;
            N num = 1, denum = 1;
            for (N i = 1; i <= k; ++i) {
                num = mul(num, n - k + i);
                denum = mul(denum, i);
            }
            return div(num, denum);
        }
        static constexpr T reduce(T a) {
            return a % modulo;
        }
        static constexpr T reduce(std::make_signed_t<T> a) {
            static_assert(modulo <= std::numeric_limits<decltype(a)>::max());
            a %= static_cast<decltype(a)>(modulo);
            if (a < 0) a += static_cast<decltype(a)>(modulo);
            return a;
        }
        static constexpr T reduce(make_double_int_t<T> A) {
            return A % modulo;
        }
        static constexpr T reduce(std::make_signed_t<make_double_int_t<T>> A) {
            std::make_signed_t<T> a = A % (std::make_signed_t<T>)modulo;
            if (a < 0) a += (std::make_signed_t<T>)modulo;
            return a;
        }
    };
    // 2**61 - 1 is meersene prime
    // optimized versions (branchless & no 128-bit division/modulo)
    static constexpr uint64_t prime61 = (static_cast<uint64_t>(1)<<61) - 1;
    template <>
    constexpr uint64_t mod<uint64_t, prime61>::add(uint64_t a, uint64_t b) {
        // requires: a < modulo && b <= modulo || a <= modulo && b < modulo
        a += b + 1;
        a = (a & modulo) + (a>>61);
        a = (a & modulo) + (a>>61);
        return a - 1;
    }
    template <>
    constexpr uint64_t mod<uint64_t, prime61>::reduce(uint64_t A) {
        A = (A & modulo) + (A>>61) + 1; // [1:modulo + 1<<3]
        A = (A & modulo) + (A>>61); // [1:modulo]
        return A - 1; // [0:modulo)
    }
    template <>
    constexpr uint64_t mod<uint64_t, prime61>::reduce(make_double_int_t<uint64_t> A) {
        A = (A & modulo) + (A>>61); // [0:1<<67)
        return reduce(
                (uint64_t)((uint64_t)(A & modulo) + (uint64_t)(A>>61) // [0:modulo+1<<6)
                    ));
    }
    template <>
    constexpr uint64_t mod<uint64_t, prime61>::sub(uint64_t a, uint64_t b) {
        return add (a, 2*modulo - b);
    }
    template <>
    constexpr uint64_t mod<uint64_t, prime61>::mul(uint64_t a, uint64_t b) {
        //assert(a < (1ull<<62));
        //assert(b < (1ull<<62));
#ifdef __SIZEOF_INT128__
        auto x = ((unsigned __int128)a)*b; // 1<<124
        auto ret = (uint64_t)(x & modulo) + (uint64_t)(x >> 61); // 1<<63 + modulo
#else
        uint64_t l1 = (uint32_t)a, h1 = a>>32, l2 = (uint32_t)b, h2 = b>>32;
        uint64_t l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;
        uint64_t ret = (l & modulo) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3);
#endif
        return reduce(ret);
    }
    typedef mod<> m1x7;
    typedef mod<uint32_t, 998244353> m9x3;
    typedef mod<uint64_t, prime61> mod61;
}
#endif // MODARITH_V2_HPP
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string_view s) {
        using mod = modarith::mod61;
        using type = mod::type;
        const unsigned n = parent.size();
        struct rec {
            type fh = 0;
            type rh = 0;
            unsigned nc = 0;
            unsigned sz = 1;
        };
        uniform_int_distribution<type> dist(31, mod::modulo - 2);
        random_device rng {};
        const type hpow = dist(rng) | 1;
        vector<type> pows(n + 1);
        {
            type pow = 1;
            for (unsigned i = 0; i <= n; ++i, pow = mod::mul(pow, hpow)) {
                pows[i] = pow;
            }
        }
        vector<rec> g(n);
        vector<vector<unsigned>> adj(n);
        for (unsigned i = 1; i < n; ++i) {
            g[parent[i]].nc++;
            adj[parent[i]].push_back(i);
        }
        deque<unsigned> q;
        for (unsigned i = 0; i < n; ++i) {
            if (g[i].nc == 0)
                q.emplace_back(i);
        }
        while(!q.empty()) {
            auto u = q.front();
            q.pop_front();
            type fh = 0;
            type rh = 0;
            unsigned p = 0;
            for (auto v: adj[u]) {
                fh = mod::add(fh, mod::mul(g[v].fh, pows[p]));
                p += g[v].sz;
            }
            fh = mod::add(fh, mod::mul(s[u] - 'a' + 1, pows[p++]));
            rh = s[u] - 'a' + 1;
            p = 1;
            for (unsigned j = adj[u].size(); j--; ) {
                auto v = adj[u][j];
                rh = mod::add(rh, mod::mul(g[v].rh, pows[p]));
                p += g[v].sz;
            }
            g[u].sz = p;
            g[u].rh = rh;
            g[u].fh = fh;
            auto v = parent[u];
            if (v == -1)
                break;
            g[v].sz += g[u].sz + 1;
            if (--g[v].nc == 0) {
                q.emplace_back(v);
            }
        }
        vector<bool> ret(n);
        for (unsigned i = 0; i < n; ++i) {
            ret[i] = g[i].fh == g[i].rh;
        }
        return ret;
    }
};",1427966163
Yuriy Kaminskiy,yumkam,423,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        const unsigned n = nums.size();
        int next = INT_MAX;
        vector<int> cache;
        int ret = 0;
        for (unsigned i = n; i--; ) {
            auto cur = nums[i];
            while (cur > next) {
                if (cur >= cache.size())
                    cache.resize(cur + 1);
                if (!cache[cur]) {
                    //cout << cur << '>';
                    for (unsigned step = (cur & 1 ? 2 : 1), v = 1 + step; v*v <= cur; v += step) {
                        //cout << '?' << v << ' ';
                        if (cur % v == 0) {
                            cache[cur] = v;
                            break;
                        }
                    }
                    //cout << cache[cur] << endl;
                    if (!cache[cur])
                        return -1;
                }
                cur = cache[cur];
                ++ret;
            }
            next = cur;
        }
        return ret;
    }
};",1427872085
andy-lc,andy-lc,424,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        psum = [[0]*(len(s)+1) for _ in range(26)]
        for i in range(26):
            c = chr(ord('a')+i)
            for j in range(len(s)):
                psum[i][j+1] = psum[i][j]+(1 if s[j]==c else 0)
        r = [0]*26
        ans = 0
        for l in range(len(s)):
            for i in range(26):
                while r[i] < len(s) and psum[i][r[i]]-psum[i][l] < k:
                    r[i] += 1
            if any(psum[i][r[i]]-psum[i][l] >= k for i in range(26)):
                ans += len(s)-min(r[i] for i in range(26) if psum[i][r[i]]-psum[i][l] >= k)+1
        return ans",1427834094
andy-lc,andy-lc,424,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = [""a""]
        while ans[-1] != target:
            if target[len(ans[-1])-1] != ans[-1][-1]:
                ans.append(ans[-1][:-1]+chr(ord(ans[-1][-1])+1))
            else:
                ans.append(ans[-1]+'a')
        return ans
        ",1427824862
andy-lc,andy-lc,424,3603,python3,"def dfsCount(graph, i, count):
    for j in graph[i]:
        dfsCount(graph, j, count)
        count[i] += count[j]
def dfsStr(graph, i, s):
    ans = [dfsStr(graph, j, s) for j in graph[i]]
    ans.append(s[i])
    return ''.join(ans)
def manacher(s):
    s = '#'.join('^{}$'.format(s))
    n = len(s)
    d1 = [0] * n
    l, r = 0, -1
    for i in range(0, n):
        k = 1 if i > r else min(d1[l + r - i], r - i + 1)
        while 0 <= i - k and i + k < n and s[i - k] == s[i + k]:
            k += 1
        d1[i] = k
        k -= 1
        if i + k > r:
            l = i - k
            r = i + k
    return d1
def is_palindrome(P, l, r):
    # l = 2*l+1
    # r = 2*r+1
    # (2*r-2*l+1)//2 == (r-l)
    # l+r+1
    # print(l,r)
    length = r - l + 1
    return P[l + r + 2] >= length
def dfsRes(graph, i, count, l, r, ans, P):
    ans[i] = is_palindrome(P, l, r)
    for j in graph[i]:
        dfsRes(graph, j, count, l, l+count[j]-1, ans, P)
        l += count[j]
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        graph = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p >= 0:
                graph[p].append(i)
        count = [1 for _ in range(n)]
        dfsCount(graph, 0, count)
        string = dfsStr(graph, 0, s)
        # print('#'.join('^{}$'.format(string)))
        P = manacher(string)
        # print(''.join(map(str,P)))
        ans = [None for _ in range(n)]
        dfsRes(graph, 0, count, 0, n-1, ans, P)
        return ans",1427949745
andy-lc,andy-lc,424,3607,python3,"nxt = [-1]*1_000_001
for fac in range(2, 1_000_000):
    for i in range(fac+fac, 1_000_000, fac):
        if nxt[i] == -1:
            nxt[i] = fac
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)-2, -1, -1):
            while nums[i] > nums[i+1]:
                if nxt[nums[i]] == -1:
                    return -1
                ans += 1
                nums[i] = nxt[nums[i]]
        return ans",1427843337
intelliCode,intelliCode,425,3502,python3,"class Solution:
    def numberOfSubstrings(self, S: str, K: int) -> int:
        retV = 0
        cntr = Counter()
        l = 0
        for r in S:
            cntr[r] += 1
            while max(cntr.values())>=K:
                cntr[S[l]] -= 1
                if S[l] not in cntr:        del cntr[S[l]]
                l += 1
            retV += l
        return retV
                ",1427834034
intelliCode,intelliCode,425,3566,python3,"class Solution:
    def stringSequence(self, T: str) -> List[str]:
        retL = []
        for c in T:
            C = ord('a')
            suff = retL[-1] if retL else ''
            retL += suff+chr(C),
            while chr(C)!=c:
                C += 1
                retL += suff+chr(C),
        return retL",1427827463
intelliCode,intelliCode,425,3603,python3,"class Solution:
    def findAnswer(self, P: List[int], S: str) -> List[bool]:
        
        lS = len(S)
        retL = [True]*lS
        
        dictLC = defaultdict(list)
        for n,p in enumerate(P):
            if p>=0:
                dictLC[p].append(n)
        
        # @cache
        def sub(n):
            if n not in dictLC:
                return S[n]
            else:
                retV = ''.join([sub(c) for c in dictLC[n]]) + S[n]
                if retV[:len(retV)//2]!=retV[-(len(retV)//2):][::-1]:
                    retL[n] = False
                return retV
        # print (sub(0),':', sub(0)[:len(sub(0))//2],sub(0)[-(len(sub(0))//2):][::-1])
        # print (sub(1),':', sub(1)[:len(sub(1))//2],sub(1)[-(len(sub(1))//2):][::-1])
        sub(0)
        return retL
            
",1427934562
intelliCode,intelliCode,425,3607,python3,"class Solution:
    def minOperations(self, N: List[int]) -> int:
        
        @cache
        def sub(n):
            d = 2
            if not (n&1):   return 2
            d = 3
            while n%d:
                d += 2
            return d if d!=n else -1
            
        retV = 0
        p = 10**9
        for n in N[::-1]:
            nn = n
            while nn>p:
                nn = sub(nn)
                if nn<1:    break
                retV += 1
            if nn<1:    break
            p = nn
        return retV if nn>0 else -1
        ",1427853266
yu46656,yu46656,428,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(const std::string& s, int k) {
        int n{ static_cast<int>(s.size()) };

        int cnts[26]{ 0 };

        int match_cnt{ 0 };

        int ret{ 0 };

        for (int i{ 0 }, j{ 0 }; i < n;) {
            if (match_cnt == 0 && j < n) {
                if (++cnts[s[j] - 'a'] == k) { ++match_cnt; }
                ++j;
            } else {
                if (0 < match_cnt) { ret += n - j + 1; }
                if (--cnts[s[i] - 'a'] == k - 1) { --match_cnt; }
                ++i;
            }
        }

        return ret;
    }
};
",1427845168
yu46656,yu46656,428,3566,cpp,"class Solution {
public:
    void F(std::vector<std::string>& dst, const char* base_beg,
           const char* base_end) {
        char last{ *(base_end - 1) };

        for (char c{ 'a' }; c <= last; ++c) {
            dst.push_back({ base_beg, base_end });
            dst.back().back() = c;
        }
    }

    std::vector<std::string> stringSequence(const std::string& target) {
        int n{ static_cast<int>(target.size()) };

        std::vector<std::string> ret;

        for (int i{ 1 }; i <= n; ++i) { F(ret, &target[0], &target[i]); }

        return ret;
    }
};
",1427832220
yu46656,yu46656,428,3603,cpp,"template <typename Iterator>
std::vector<int> ManacherAlg(Iterator beg, Iterator end) {
    int n{ static_cast<int>(end - beg) };

    std::vector<int> ret;
    ret.resize(n, 0);

    int best_mb{ 0 };
    int best_rb{ 0 };

    for (int i_mb{ 1 }; i_mb < n; ++i_mb) {
        int i_r{ i_mb <= best_rb
                     ? std::min(ret[best_mb + best_mb - i_mb], best_rb - i_mb)
                     : 1 };

        while (0 <= i_mb - i_r && i_mb + i_r < n &&
               beg[i_mb - i_r] == beg[i_mb + i_r]) {
            ++i_r;
        }

        --i_r;

        ret[i_mb] = i_r;

        if (best_rb < i_mb + i_r) {
            best_mb = i_mb;
            best_rb = i_mb + i_r;
        }
    }

    return ret;
}

class Solution {
public:
    void DFSTable(std::vector<int>& dst,
                  std::vector<std::pair<int, int>>& be_table,
                  const std::vector<std::vector<int>>& adjs, int k) {
        int beg{ static_cast<int>(dst.size()) };

        for (int l : adjs[k]) { DFSTable(dst, be_table, adjs, l); }

        dst.push_back(k);

        int end{ static_cast<int>(dst.size()) };

        be_table[k] = { beg, end };
    }

    std::vector<bool> findAnswer(const std::vector<int>& parents,
                                 const std::string& s) {
        int n{ static_cast<int>(parents.size()) };

        std::vector<std::vector<int>> adjs;
        adjs.resize(n);

        int root;

        for (int i{ 0 }; i < n; ++i) {
            int parent{ parents[i] };

            if (0 <= parent) {
                adjs[parent].push_back(i);
            } else {
                root = i;
            }
        }

        for (int i{ 0 }; i < n; ++i) {
            std::sort(adjs[i].begin(), adjs[i].end());
        }

        std::vector<int> dfs_table;
        dfs_table.reserve(n);

        std::vector<std::pair<int, int>> be_table;
        be_table.resize(n);

        DFSTable(dfs_table, be_table, adjs, root);

        std::string dfs_str;
        dfs_str.resize(n * 2 - 1, '#');

        for (int i{ 0 }; i < n; ++i) { dfs_str[i * 2] = s[dfs_table[i]]; }

        std::vector<int> mnc_table{ ManacherAlg(dfs_str.begin(),
                                                dfs_str.end()) };

        std::vector<bool> ret;
        ret.resize(n);

        for (int i{ 0 }; i < n; ++i) {
            int j{ dfs_table[i] };

            int beg{ be_table[j].first };
            int end{ be_table[j].second - 1 };

            ret[j] = end - beg <= mnc_table[beg + end];
        }

        return ret;
    }
};
",1427960080
yu46656,yu46656,428,3607,cpp,"class Solution {
public:
    std::vector<int> primes = { 2, 3, 5, 7, 11 };

    int FirstDivisor(int x) {
        if (x == 1) { return 1; }

        for (auto iter{ primes.begin() }, end{ primes.end() }; iter != end;
             ++iter) {
            int prime{ *iter };
            if (x % prime == 0) { return prime; }

            int y{ x / prime };
            if (y < prime) { break; }
        }

        return x;
    }

    void MakePrimetable(int k) {
        int x{ this->primes.back() + 1 };

        for (; x <= k; ++x) {
            if (FirstDivisor(x) == x) { this->primes.push_back(x); }
        }
    }

    int minOperations(std::vector<int>& nums) {
        int n{ static_cast<int>(nums.size()) };

        std::vector<std::pair<int, int>> vec;
        vec.resize(n);

        MakePrimetable(1200);

        for (int i{ 0 }; i < n; ++i) {
            vec[i].first = FirstDivisor(nums[i]);
            vec[i].second = nums[i];
        }

        std::vector<std::pair<int, int>> dp;
        dp.resize(n, { INT_MAX / 2, INT_MAX / 2 });

        dp[n - 1].first = 1;
        dp[n - 1].second = 0;

        for (int i{ n - 2 }; 0 <= i; --i) {
            int first_ans{ INT_MAX / 2 };
            int second_ans{ INT_MAX / 2 };

            if (vec[i].first <= vec[i + 1].second) {
                first_ans = std::min(first_ans, 1 + dp[i + 1].second);
            }

            if (vec[i].first <= vec[i + 1].first) {
                first_ans = std::min(first_ans, 1 + dp[i + 1].first);
            }

            if (vec[i].second <= vec[i + 1].second) {
                second_ans = std::min(second_ans, dp[i + 1].second);
            }

            if (vec[i].second <= vec[i + 1].first) {
                second_ans = std::min(second_ans, dp[i + 1].first);
            }

            dp[i].first = first_ans;
            dp[i].second = second_ans;
        }

        int ret{ std::min(dp[0].first, dp[0].second) };

        return ret <= n ? ret : -1;
    }
};
",1427911882
Arucade,Arucade,429,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int res = 0, n = s.length(), t = 0;
        int[] count = new int[26];
        for (int i = 0, j = 0; i < n; i++) {
            if (++count[s.charAt(i) - 'a'] == k) t++;
            while (j <= i && t > 0) {
                int c = s.charAt(j) - 'a';
                if (count[c] == k && t == 1) break;
                else if (--count[c] == k - 1) t--;
                j++;
            }
            if (t > 0) res += j + 1;
        }
        return res;
    }
}",1427840256
Arucade,Arucade,429,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        char[] chs = new char[target.length()];
        for (int i = 0; i < target.length(); i++) {
            for (int j = 0; j < 26; j++) {
                chs[i] = (char)('a' + j);
                res.add(String.valueOf(chs, 0, i + 1));
                if (chs[i] == target.charAt(i)) break;
            }
        }
        return res;
    }
}",1427826281
Arucade,Arucade,429,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        boolean[] res = new boolean[n], mono = new boolean[n];
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 1; i < n; i++) {
            int p = parent[i];
            map.computeIfAbsent(p, k -> new ArrayList<>()).add(i);
        }
        dfs(map, s, 0, 0, new char[n], res, mono);
        return res;
    }

    private int dfs(Map<Integer, List<Integer>> map, String s, int i, int l, char[] chs, boolean[] res, boolean[] mono) {
        int r = l, count = 0;
        char ch = s.charAt(i);
        boolean b = true;
        if (map.containsKey(i)) {
            for (int j : map.get(i)) {
                int c = dfs(map, s, j, r, chs, res, mono);
                r += c;
                b = b && mono[j] && s.charAt(j) == ch;
            }
        }
        chs[r] = ch;
        count = r - l + 1;
        mono[i] = b;
        res[i] = true;
        if (!b) {
            while (l < r && res[i]) {
                if (chs[l] != chs[r]) res[i] = false;
                l++;
                r--;
            }
        }
        return count;
    }
}",1427960813
Arucade,Arucade,429,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int res = 0, n = nums.length, max = 0;
        for (int num : nums) max = Math.max(max, num);
        int[] d = new int[max + 1];
        for (int i = 1; i < d.length; i++) {
            if (d[i] == 0) d[i] = i;
            for (int j = 2; j <= i && j * i <= max; j++) {
                d[i * j] = j; 
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1] && d[nums[i]] != nums[i]) {
                nums[i] = d[nums[i]];
                res++;
            }
            if (nums[i] > nums[i + 1]) return -1;
        }
        return res;
    }
}",1427860335
Keshav Monga,keshavmonga,433,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        long long total = n*(n+1)/2;
        int i = 0 , j = 0 , ans = 0;
        vector<int> map(26 , 0);
        auto fn = [&]() ->bool{
            for(auto &i:map) if(i>=k) return true;
            return false;
        };
        while(j<n){
            map[s[j]-'a']++;
            while(i<j && fn()){
                map[s[i]-'a']--;
                i++;
            }
            if(!fn()) ans+=j-i+1;
            j++;
        }
        return total - ans;
    }
};",1427835754
Keshav Monga,keshavmonga,433,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string str;
        int i = 0;
        while(str!=target){
            if(str.empty() || i>=str.size()) str.push_back('a');
            while(str[i]!=target[i]){
                char ch = str.back();
                res.push_back(str);
                str.pop_back();
                str.push_back(ch+1);
            }
            res.push_back(str);
            i++;
        }
        return res;
    }
};",1427828237
Keshav Monga,keshavmonga,433,3603,cpp,"class PalindromeChecker {
    const int P = 31;
    const int MOD = 1e9 + 7;
    vector<long long> prefixHash, suffixHash, power;
    int n;
    string s, rev_s;

public:
    PalindromeChecker(const string& s) : s(s), n(s.size()) {
        rev_s = s;
        reverse(rev_s.begin(), rev_s.end());

        prefixHash.resize(n + 1, 0);
        suffixHash.resize(n + 1, 0);
        power.resize(n + 1, 1);

        for (int i = 1; i <= n; ++i)
            power[i] = (power[i - 1] * P) % MOD;

        for (int i = 0; i < n; ++i) {
            prefixHash[i + 1] = (prefixHash[i] + (s[i] - 'a' + 1) * power[i]) % MOD;
        }
        for (int i = 0; i < n; ++i) {
            suffixHash[i + 1] = (suffixHash[i] + (rev_s[i] - 'a' + 1) * power[i]) % MOD;
        }
    }
    long long getPrefixHash(int l, int r) {
        long long hash = (prefixHash[r + 1] - prefixHash[l] + MOD) % MOD;
        hash = (hash * power[n - l - 1]) % MOD;
        return (hash+MOD)%MOD;
    }
    long long getSuffixHash(int l, int r) {
        long long hash = (suffixHash[r + 1] - suffixHash[l] + MOD) % MOD;
        hash = (hash * power[n - l - 1]) % MOD;
        return (hash+MOD)%MOD;
    }

    bool isPalindrome(int l, int r) {
        int rev_l = n - r - 1;
        int rev_r = n - l - 1;
        return getPrefixHash(l, r) == getSuffixHash(rev_l, rev_r);
    }
};

void dfs(int node, const vector<vector<int>>& tree, const string& s,
         string& str, vector<int>& start, vector<int>& end) {
    start[node] = str.size();
    for (int it : tree[node]) {
        dfs(it, tree, s, str, start, end);
    }
    str += s[node];
    end[node] = str.size();
}
class Solution {
public:
    vector<bool> findAnswer(const vector<int> parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }
        string str;
        vector<int> start(n), end(n);

        dfs(0, tree, s, str, start, end);
        PalindromeChecker pc(str);
        vector<bool> ans(n, false);
        for (int i = 0; i < n; ++i) {
            if(pc.isPalindrome(start[i],end[i]-1)) ans[i] = 1;
        }

        return ans;
    }
};",1427962296
Keshav Monga,keshavmonga,433,3607,cpp,"const int N = 1000001;
int lar[N];
bool done = false;
void pre(){
    if(done) return;
    for(int i = 1 ; i<N ; i++){
        lar[i] = 1;
        for(int j = 2 ; j*j<=i ; j++){
            if(i%j) continue;
            lar[i] = max(lar[i] , j);
            lar[i] = max(lar[i] , i/j);
            break;
        }
    }
    done = true;
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        pre();
        int ans = 0 , n = nums.size();
        for(int i = n-2 ; i>=0 ; i--){
            if(nums[i+1]>=nums[i]) continue;
            if(lar[nums[i]]==1) return -1;
            while(nums[i]>nums[i+1]){
                if(lar[nums[i]]==1) return -1;
                nums[i]/=lar[nums[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427855382
lukewu28,lukewu28,434,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int f[26] = {};
        int n = s.size();
        int l = 0;
        int re = 0;
        for(int i = 0 ; i < n; i++){
            f[s[i] - 'a']++;
            bool ok = 0;
            for(int j : f){
                if(j >= k) ok = 1;
            }
            
            while(ok){
                re += n - i;
                f[s[l++] - 'a']--;
                ok = 0;
                for(int j : f){
                    if(j >= k) ok = 1;
                }
            }
        }
        return re;
    }
};",1427827746
lukewu28,lukewu28,434,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s;
        vector<string> re;
        for(char i: target){
            for(char j = 'a'; j <= i; j++){
                re.push_back(s + j);
            }
            s += i;
        }
        return re;
    }
};",1427824124
lukewu28,lukewu28,434,3603,cpp,"typedef long long ll;

class Solution {
public:
    const long long M = 1e9 + 7, P = 34927453;
    long long pow(long long x, long long y, long long p){
        int res = 1;
        while (y){
            if (y&1) res = (res*x)%p;
            y >>= 1; 
            x = (x * x)%p;
        }
        return res % p;
    }
    
    map<char, long long> hash;
    long long has(string a){
        long long re = 0;
        for(char i : a){
            re = ((re*P)%M + hash[i]) % M;
        }
        return re;
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        set<long long> used;
        for(int i = 0; i < 26; i++){
            char c = 'a' + i;
            int num = rand() % P;
            while(used.find(num) != used.end()){
                num = rand() % P;
            }
            used.insert(num);
            hash[c] = num;
        }
        
        queue<int> q;
        vector<vector<int>> adj(n);
        vector<int> sz(n, 1), d(n, 0);
        for(int i = 0; i < n; i++){
            if(parent[i] == -1) continue;
            int p = parent[i];
            d[p]++;
            adj[p].push_back(i);
        }
        
        for(int i = 0 ; i < n; i++){
            if(d[i] == 0) q.push(i);
        }
        vector<bool> ans(n);
        vector<long long> v(n, 0), bv(n, 0);
        // cout << (ll) has(""aba"") << endl;
        // cout << (ll) has(""ab"") << endl;
        // cout << (ll) has(""ba"") << endl;
        // cout << (ll) has(""abaaba"") << endl;
        // cout << (ll) has(""abaab"") << endl;
        while(!q.empty()){
            int x = q.front();
            q.pop();
            
            int m = adj[x].size();
            long long fo = 0, re = hash[s[x]]; 
            for(int i = 0; i < m; i++){
                long long fr = adj[x][i];
                long long bk = adj[x][m - i - 1];
                // cout << x << ' ' << fr << ' ' << bk << endl;
                
                fo = ((fo * pow(P, sz[fr], M)) % M + v[fr]) % M;
                re = ((re * pow(P, sz[bk], M)) % M + bv[bk]) % M;
                // cout << (ll)fo << endl;
                sz[x] += sz[fr];
            }
            fo = ((fo * P) % M + hash[s[x]]) % M;
            
            v[x] = fo;
            bv[x] = re;
            // cout << x << ' ' << (ll) v[x] << ' ' << (ll) bv[x] << endl;
            ans[x] = fo == re;
            
            if(parent[x] != -1) {
                d[parent[x]]--;
                if(d[parent[x]] == 0) q.push(parent[x]);
            }
        }
        
        return ans;
    }
};",1427962397
lukewu28,lukewu28,434,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = 1000;
        bool comp[1001] = {};
        vector<int> primes;
        for(int i = 2; i <= n; i++){
            if(!comp[i]){
                primes.push_back(i);
                for(int j = i + i; j <= n; j += i) comp[j] = 1;
            }
        }
        reverse(nums.begin(), nums.end());

        int last = 1e9;
        int re = 0;
        for(int i : nums){
            if(i <= last) last = i;
            else{
                re++;
                bool ok = 0;
                for(int p: primes){
                    if(p > last) break;
                    if(i % p == 0) {
                        last = p;
                        ok = 1;
                    }
                }
                if(!ok) return -1;
            }
        }
        return re;
    }
};",1427844661
avvmoto,avvmoto,436,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        counter = defaultdict(int)
        counter['$'] = 0
        ans = 0

        r = 0
        for l in range(n):
            while r < n and max(counter.values()) <= k - 1:
                counter[s[r]] += 1
                r += 1

            if max(counter.values()) == k:
                ans += n - r + 1

            counter[s[l]] -= 1

        return ans",1427842845
avvmoto,avvmoto,436,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        prev = ''

        for char in target:
            for i in range(ord(char) - ord('a') + 1):
                ans.append(prev + chr(ord('a') + i))

            prev = ans[-1]
        return ans

",1427830176
avvmoto,avvmoto,436,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for child in range(1, n):
            children[parent[child]].append(child)

        base = 64997
        mod = 4294966043

        nums = [ord(char) - ord('a') + 1 for char in s]

        ans = [None] * n

        def dfs(v):
            hash = 0
            rev_hash = 0
            size = 0

            for u in children[v]:
                u_hash, u_hash_rev, u_size = dfs(u)

                hash = (hash * pow(base, u_size, mod) + u_hash) % mod
                rev_hash = (u_hash_rev * pow(base, size, mod) + rev_hash) % mod
                size += u_size

            hash = (hash * base + nums[v]) % mod
            rev_hash = (nums[v] * pow(base, size, mod) + rev_hash) % mod

            ans[v] = hash == rev_hash
            size += 1

            return hash, rev_hash, size

        dfs(0)
        return ans
",1427955194
avvmoto,avvmoto,436,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        op = 0
        for i in range(n - 2, -1, -1):
            if nums[i] <= nums[i + 1]:
                continue

            d = 2
            while d <= math.isqrt(nums[i]):
                if nums[i] % d == 0:
                    nums[i] = d
                    op += 1
                    if nums[i] <= nums[i + 1]:
                        break

                if d == 2:
                    d = 3
                else:
                    d += 2

            if nums[i] > nums[i + 1]:
                return -1

        return op


",1427892704
mustafiz05,mustafiz05,437,3502,cpp,"typedef int ll;
ll frequ[50];
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        ll currentUpValue = 0;
        
        ll currentIndx = 0;
        
        ll totalAns = 0;
        
        for(ll i = 0; i < s.size(); i++) {
            while(currentIndx < s.size() && currentUpValue == 0){
                
                frequ[s[currentIndx] - 'a'  ]++;
                
                if(frequ[s[currentIndx] - 'a'  ] >= k) currentUpValue++;
                currentIndx++;  
            }
            
            
           // cout << i << "" "" << currentIndx << endl;
            
            if(currentUpValue >= 1) totalAns+=(( (s.size() - 1) - (currentIndx - 1)) + 1);
            
            
                frequ[s[i] - 'a'  ]--;
                
                if(frequ[s[i] - 'a'  ] == (k - 1)) currentUpValue--;
            
            
            
        }
        
        return totalAns;
        
        
        
    }
};",1427931885
mustafiz05,mustafiz05,437,3566,cpp,"typedef int ll;
class Solution {
public:
    vector<string> stringSequence(string target) {
        ll currentIndex = 0;
        vector<string> ans;
        string currentStr = """";
        while(currentIndex < target.size()){
            
            currentStr+='a';
            ll sz = currentStr.size();
            
            for(char ch = 'a'; ch <= 'z'; ch++) {
                currentStr[sz - 1] = ch;
                ans.push_back(currentStr);
                if(ch == target[currentIndex]){
                    break;
                }
            }
            currentIndex++;
        }
        
        return ans;
    }
};",1427915320
mustafiz05,mustafiz05,437,3603,cpp,"typedef long long ll;
const int N = 1e5;
ll mod1 = 1e9 + 7, mod2 = 1e9 + 9;
ll pbase1 = 257, pbase2 = 263;
ll pw1[N + 9], pw2[N + 9];
string str;
ll actualAns[N +2];
pair<ll,ll>ans1[N + 3];
pair<ll,ll>ans2[N + 3];

vector<ll>gr[N + 2];
vector<bool>mainnAns;

void dfs1(ll node, ll parr) {
    
    vector<ll>childern;
    for(ll i = 0; i < gr[node].size(); i++) {
        ll child = gr[node][i];
        if(child == parr) continue;
        childern.push_back(child);
    }
    
    sort(childern.begin(), childern.end());
    
    
    ll currentValue = 0;
    ll currentSize = 0;
    
    
    for(ll i = 0; i < childern.size(); i++) {
        ll ch = childern[i];
        dfs1(ch, node);
        
        ll newValue = ans1[ch].first * pw1[currentSize];
        newValue%=mod1;
        
        currentValue+=newValue; currentValue%=mod1;
        
        currentSize+=ans1[ch].second;
    }
    
    
    ll newValue = str[node] - 'a' + 1;
    newValue*=pw1[currentSize]; newValue%=mod1;
    currentSize++;
    
      currentValue+=newValue; currentValue%=mod1;
    
    ans1[node] = {currentValue, currentSize  };
    
    
    
    
    currentValue = 0;
    currentSize = 0;
    
    
     newValue = str[node] - 'a' + 1;
    newValue*=pw1[currentSize]; newValue%=mod1;
    currentSize++;
    
    currentValue+=newValue; currentValue%=mod1;
    
    
    
    
    reverse(childern.begin(), childern.end());
    
    
    for(ll i = 0; i < childern.size(); i++) {
        ll ch = childern[i];
        
        ll newValue = ans2[ch].first * pw1[currentSize];
        newValue%=mod1;
        
        currentValue+=newValue; currentValue%=mod1;
        
        currentSize+=ans2[ch].second;
    }
    
    
    ans2[node] = {currentValue, currentSize  };
    
    
   // cout << ans1[node].first << "" "" << ans2[node].first << "" "" << node << endl;
    
    
    
    
    
    if(ans1[node].first == ans2[node].first) actualAns[node] = 1;
    else actualAns[node] = 0;
    
    
    
    
}




void prec() {
pw1[0] = 1;
for (int i = 1; i <= N; i++) {
pw1[i] = 1ll * pw1[i - 1] * pbase1 % mod1;
}
}


class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        prec();
        str.clear();
        mainnAns.clear();
        
        for(ll i = 0; i < parent.size(); i++) {
            ans1[i] = ans2[i] = {0, 0};
            gr[i].clear();
            actualAns[i] = 0;
        }
        
        
        str = s;
        for(ll i = 0; i < parent.size(); i++) {
            ll root = parent[i];
            if(root == -1) continue;
            gr[i].push_back(root);
            gr[root].push_back(i);
        }
        
        
        dfs1(0, -1);
        
        for(ll i = 0; i < parent.size(); i++) {
            if(actualAns[i]) mainnAns.push_back(true);
            else mainnAns.push_back(false);
        }
        
        
        return mainnAns;
        
        
        
        
        
        
    }
};",1427902593
mustafiz05,mustafiz05,437,3607,cpp,"typedef long long ll;
ll maxi[1000009];
class Solution {
public:
    int minOperations(vector<int>& nums) {
         for(ll i = 1; i <= 1000000; i++) {
            maxi[i] = 1e7;
        }
        
        for(ll i = 2; i <= 1000000; i+=2) {
            maxi[i] = 2;
        }
        
        for(ll i = 3; i <= 1000000; i+=2) {
            
            if(maxi[i] == 1e7) {
                maxi[i] = i;
                for(ll j = (i * i); j <=1000000; j+=(i + i) ){
                    maxi[j] = min(maxi[j], i);
                }
            }
            
            
        }
        
        
        
        ll total = 0;
        
        ll hobeNah = 0;
        
        ll prevValue = 1e7;
        
        for(ll i = nums.size() - 1; i >= 0; i--) {
            while(nums[i] > prevValue) {
                ll what = maxi[nums[i]  ];
                
                if(what == nums[i]) {
                    hobeNah = 1;
                    break; 
                }
                
                ll newOne = nums[i]/what;
                nums[i]/=newOne;
                if(what == 1) {
                    hobeNah = 1;
                    break;
                }
                total++;
            }
            
            if(hobeNah) break;
            prevValue = nums[i];
        }
        
        if(hobeNah) return -1;
        else return total;
        
        
        
        
        
        
    }
};",1427964281
Yizzy,yizzycool,438,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ctr = Counter()
        left, right = 0, 0
        ans = 0
        while right < len(s):
            char = s[right]
            ctr[char] += 1
            top = ctr.most_common(1)
            while len(top) == 1 and top[0][1] >= k:
                ans += len(s) - right
                leftChar = s[left]
                ctr[leftChar] -= 1
                top = ctr.most_common(1)
                left += 1
            right += 1
        return ans
        

",1427843622
Yizzy,yizzycool,438,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        s = 'a'
        ans = ['a']
        idx = 0
        while s != target:
            if s[-1] != target[idx]:
                s = s[:-1] + chr(ord(s[-1]) + 1)
            else:
                s += 'a'
                idx += 1
            ans.append(s)
        return ans",1427827414
Yizzy,yizzycool,438,3603,python3,"class Solution:
    def __init__(self):
        self.ans = None
        self.tree = defaultdict(list)
        self.postString = ''
        self.postMap = {}

    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        self.ans = [False] * len(s)
        for idx, p in enumerate(parent):
            self.tree[p].append(idx)
        self.postOrder(s, self.tree[-1][0])
        table = self.manachar()
        # print(self.postString)
        # print(table)
        self.checkAns(table, self.tree[-1][0], 0, len(self.postString))
        return self.ans

    def postOrder(self, s, node):
        for child in self.tree[node]:
            self.postOrder(s, child)
        self.postMap[node] = len(self.postString)
        self.postString += s[node]

    def manachar(self):
        s = self.postString
        string_size = len(s)
        manacher_str = ""#""
        for index in range(len(s)):
            manacher_str += s[index]
            manacher_str += ""#""
        LPS_table = [0]*len(manacher_str)
        center = 1
        max_right = 2
        max_length = 0
        LPS_center = 0
        total_size = len(manacher_str)
        for index in range(1, len(manacher_str)):
            if index < max_right:
                LPS_table[index] = min(LPS_table[2*center-index], max_right-index)
            else:
                LPS_table[index] = 0
            # when calculating LPS value, self position (index) is not included
            while (index-LPS_table[index]-1 >= 0 and
                   index+LPS_table[index]+1 < total_size and
                   manacher_str[index-LPS_table[index]-1] == manacher_str[index+LPS_table[index]+1]):
                   LPS_table[index] += 1
            if LPS_table[index] > max_length:
                max_length = LPS_table[index]
                LPS_center = index
            if LPS_table[index]+index-1 > max_right:
                max_right = LPS_table[index]+index-1
                center = index
        return LPS_table

    def checkAns(self, table, node, left, right):
        center = (left * 2 + right * 2) // 2
        if table[center] >= right - left:
            self.ans[node] = True
        nextLeft = left
        for child in self.tree[node]:
            nextRight = self.postMap[child] + 1
            self.checkAns(table, child, nextLeft, nextRight)
            nextLeft = nextRight

# a b a a b a
# 3 4 1 5 2 0
# 0 1 2 3 4 5
",1427964408
Yizzy,yizzycool,438,3607,python3,"class Solution:
    def __init__(self):
        self.primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]

    def minOperations(self, nums: List[int]) -> int:
        steps = 0
        for i in range(len(nums) - 2, -1, -1):
            while nums[i] > nums[i + 1]:
                nextNum = nums[i]
                for prime in self.primes:
                    if prime >= nums[i]:
                        break
                    if nums[i] % prime == 0:
                        nextNum = prime
                        break
                if nextNum == nums[i]:
                    return -1
                nums[i] = nextNum
                steps += 1
        return steps
                    ",1427886035
Pankaj Ananda Bhosale,pankaj_777,440,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        for (int i = 0; i < n; i++) {
            int freq[26] = {0}, maxFreq = 0;
            for (int j = i; j < n; j++) {
                freq[s[j] - 'a']++;
                maxFreq = max(maxFreq, freq[s[j] - 'a']);
                res += (maxFreq >= k);
            }
        }
        return res;
    }
};",1427828081
Pankaj Ananda Bhosale,pankaj_777,440,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";
        for (auto ch : target) {
            curr += 'a';
            res.push_back(curr);
            while (curr.back() != ch) {
                curr.back()++;
                res.push_back(curr);
            }
        }
        return res;
    }
};",1427825115
Pankaj Ananda Bhosale,pankaj_777,440,3603,cpp,"struct Manacher {
    vector<int> p;
    
    void run_manacher(string s) {
        int n = s.size();
        p.assign(n, 1); // Initialize the array for storing palindrome lengths
        int l = 0, r = 0; // Initialize the left and right boundaries of the current palindrome
        for (int i = 0; i < n; i++) {
            if (i < r) {
                p[i] = min(r - i, p[l + r - i]); // Adjust based on the previous palindrome
            }
            // Expand the palindrome centered at `i`
            while (i + p[i] < n && i - p[i] >= 0 && s[i + p[i]] == s[i - p[i]]) {
                p[i]++;
            }
            // Update the left and right boundaries if we found a larger palindrome
            if (i + p[i] > r) {
                l = i - p[i];
                r = i + p[i];
            }
        }
    }
    
    void build(string s) {
        string t = ""#""; // Modified string to handle odd/even palindrome lengths
        for (char ch : s) {
            t += ch;
            t += ""#"";
        }
        run_manacher(t); // Pass the modified string to Manacher's algorithm
    }
    
    int getLongest(int cen, bool odd) {
        int pos = 2 * cen + (odd ? 1 : 2); // Position in the modified string
        return p[pos] - 1; // Return the length of the palindrome
    }
    
    bool checkPalindrome(int l, int r) {
        int cen = (l + r) / 2;
        return (r - l + 1) <= getLongest(cen, (r - l + 1) % 2 == 1); // Check if it's a palindrome
    }
};

class Solution {
public:
    int timer = 0;
    string t = """";
    vector<int> subTreeSize, inTime;
    vector<vector<int>> adj;
    
    void init(int n) {
        subTreeSize.assign(n, 0); 
        inTime.assign(n, 0);
        adj.assign(n, vector<int>());
    }
    
    void dfs(int u, const string& s) {
        t += s[u]; 
        inTime[u] = timer++; 
        subTreeSize[u] = 1;
        for (int v : adj[u]) {
            dfs(v, s);
            subTreeSize[u] += subTreeSize[v];
        }
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        init(n);
        
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        
        for (int i = 0; i < n; i++) {
            sort(adj[i].begin(), adj[i].end(), greater<int>());
        }
        
        dfs(0, s);
        
        vector<bool> res(n);
        Manacher ds;
        ds.build(t);
        for (int i = 0; i < n; i++) {
            res[i] = ds.checkPalindrome(inTime[i], inTime[i] + subTreeSize[i] - 1);
        }
        
        return res;
    }
};
",1427964554
Pankaj Ananda Bhosale,pankaj_777,440,3607,cpp,"const int inf = 1e9;

class Solution {
public:
    vector<int> spf;
    void precompute(int N) {
        spf.resize(N + 1);
        for (int i = 1; i <= N; i++) {
            spf[i] = i;
        }
        
        for (int i = 2; i <= N; i++) {
            if (spf[i] == i) {
                for (int j = i; j <= N; j += i) {
                    if (spf[j] == j) {
                        spf[j] = i;
                    }
                }
            }
        }
    }
    
    int gpd(int x) {
        return spf[x] != x ? x / spf[x] : -1;
    }
    
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        precompute(*max_element(nums.begin(), nums.end()));
        
        int dp[n + 1][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 2; j++) {
                dp[i][j] = inf;
            }
        }
        
        dp[n][0] = dp[n][1] = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (i == 0) {
                dp[i][0] = dp[i][1] = min(1 + dp[i + 1][1], dp[i + 1][0]);
            } else {
                // j = 0
                if (nums[i] >= nums[i - 1]) {
                    dp[i][0] = min(dp[i][0], dp[i + 1][0]);
                }
                if (gpd(nums[i]) != -1 and nums[i] / gpd(nums[i]) >= nums[i - 1]) {
                    dp[i][0] = min(dp[i][0], 1 + dp[i + 1][1]);
                }
                // j = 1
                if (nums[i] >= nums[i - 1] / gpd(nums[i - 1]) and gpd(nums[i - 1]) != -1) {
                    dp[i][1] = min(dp[i][1], dp[i + 1][0]);
                }
                if (gpd(nums[i]) != -1 and nums[i] / gpd(nums[i]) >= nums[i - 1] / gpd(nums[i - 1]) and gpd(nums[i - 1]) != -1) {
                    dp[i][1] = min(dp[i][1], 1 + dp[i + 1][1]);
                }
            }
        }
        
        return dp[0][0] == inf ? -1 : dp[0][0];
    }
};",1427870025
Sourav jha,souravj02,442,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int>ct(26,0);
        int j =0, ans =0;
        for(int i =0; i < s.length();) {

            while(!isCt(ct,k) &&  j < s.length()) {
                ct[s[j]- 'a']++;
                j++;
            }

            if(isCt(ct,k)) {
                ans += s.length() - j + 1;
            }

            ct[s[i]- 'a'] --;
            i++;

        }

        return ans;
    }

    bool isCt(vector<int>&ct, int k) {
        for(int i =0; i < 26; ++i) {
            if(ct[i] >= k) return true;
        }
        return false;
    }
};",1427840528
Sourav jha,souravj02,442,3566,cpp,"class Solution {
public:

    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur ="""";
        for(int i = 0 ; i < target.length();++i) {
            string  p = cur + 'a';
            bool moved = false;
            char tg = target[i];
            ans.push_back(p);
            while(p[i] != tg) {
                moved = true;
                if(p[i] == 'z')
                 p[i] = 'a';
                else {
                    p[i] = ((p[i] - 'a') + 1) + 'a';
                }
                ans.push_back(p);
            }
        
            cur = p;
        }

        return ans;
        
    }
};",1427855784
Sourav jha,souravj02,442,3603,cpp,"struct NodeInfo{
    int num, size;
};
vector<vector<int>> adl;
vector<NodeInfo> ninfo;
string orig;
string dfsS;
int cnt =0;


#define p 101
#define MOD 1000000007
 
// Structure to represent a query. A query consists
// of (L, R) and we have to answer whether the substring
// from index-L to R is a palindrome or not
struct Query {
    int L, R;
};
 
// A function to check if a string str is palindrome
// in the range L to R
bool isPalindrome(string& str, int L, int R)
{
    // Keep comparing characters while they are same
    while (R > L)
        if (str[L++] != str[R--])
            return (false);
    return (true);
}
 
// A Function to find pow (base, exponent) % MOD
// in log (exponent) time
unsigned long long int modPow(
    unsigned long long int base,
    unsigned long long int exponent)
{
    if (exponent == 0)
        return 1;
    if (exponent == 1)
        return base;
 
    unsigned long long int temp = modPow(base, exponent / 2);
 
    if (exponent % 2 == 0)
        return (temp % MOD * temp % MOD) % MOD;
    else
        return (((temp % MOD * temp % MOD) % MOD)
                * base % MOD)
               % MOD;
}
 
// A Function to calculate Modulo Multiplicative Inverse of 'n'
unsigned long long int findMMI(unsigned long long int n)
{
    return modPow(n, MOD - 2);
}
 
// A Function to calculate the prefix hash
void computePrefixHash(
    string& str, int n,
    unsigned long long int prefix[],
    unsigned long long int power[])
{
    prefix[0] = 0;
    prefix[1] = str[0];
 
    for (int i = 2; i <= n; i++)
        prefix[i] = (prefix[i - 1] % MOD
                     + (str[i - 1] % MOD
                        * power[i - 1] % MOD)
                           % MOD)
                    % MOD;
 
    return;
}

 
// A Function to calculate the suffix hash
// Suffix hash is nothing but the prefix hash of
// the reversed string
void computeSuffixHash(
    string& str, int n,
    unsigned long long int suffix[],
    unsigned long long int power[])
{
    suffix[0] = 0;
    suffix[1] = str[n - 1];
 
    for (int i = n - 2, j = 2; i >= 0 && j <= n; i--, j++)
        suffix[j] = (suffix[j - 1] % MOD
                     + (str[i] % MOD
                        * power[j - 1] % MOD)
                           % MOD)
                    % MOD;
    return;
}

void computePowers(unsigned long long int power[], int n)
{
    // 101^0 = 1
    power[0] = 1;
 
    for (int i = 1; i <= n; i++)
        power[i] = (power[i - 1] % MOD * p % MOD) % MOD;
 
    return;
}
 

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        adl.clear();
        adl.assign(parent.size(), vector<int>());
        for(int i = 1; i < parent.size();++i) {
            adl[parent[i]].push_back(i);
        }
        dfsS.clear();
        ninfo.clear();
        ninfo.assign(parent.size(),{});
        cnt =0;
        orig = s;
        dfs(0);
int n =  dfsS.length();
         // A Table to store the powers of 101
    unsigned long long int power[n + 1];
 
    computePowers(power, n);
 
    // Arrays to hold prefix and suffix hash values
    unsigned long long int prefix[n + 1], suffix[n + 1];
 
    // Compute Prefix Hash and Suffix Hash Arrays
    computePrefixHash(dfsS, n, prefix, power);
    computeSuffixHash(dfsS, n, suffix, power);
    vector<bool> ans;
    for(int i =0; i < parent.size();++i) {
        
         int R = ninfo[i].num - 1;
         int L = ninfo[i].num - ninfo[i].size;
     //    cout << i << "" "" <<L << "" "" << R << ""\n"";
         // Hash Value of Substring [L, R]
        unsigned long long hash_LR
            = ((prefix[R + 1] - prefix[L] + MOD) % MOD
               * findMMI(power[L]) % MOD)
              % MOD;
 
        // Reverse Hash Value of Substring [L, R]
        unsigned long long reverse_hash_LR
            = ((suffix[n - L] - suffix[n - R - 1] + MOD) % MOD
               * findMMI(power[n - R - 1]) % MOD)
              % MOD;
 
        // If both are equal then
        // the substring is a palindrome
        if (hash_LR == reverse_hash_LR ) {
                ans.push_back(true);
            } else ans.push_back(false);
    }
    return ans;
    }

  

    NodeInfo dfs(int u) {
       int sub =0;
       for(int j = 0;  j < adl[u].size();++j) {
          int v = adl[u][j];
          if(v != u) {
            auto p2 = dfs(v);
            sub += p2.size;
          }

       }
       dfsS.push_back(orig[u]);
       cnt++;
       ninfo[u] = {cnt, sub + 1};
       return ninfo[u];

    }
};

",1427965854
Sourav jha,souravj02,442,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int last = nums.back();
        int cnt =0;
        for(int i = nums.size() - 2; i >=0; --i) {
             int ch = nums[i];
             while(ch > last) {
                int lg = 1;
                for(int j = 2; j * 1LL * j <= ch && j != ch;++j) {
                    if(ch % j ==0) {
                        lg = max(j, lg);
                        lg = max(lg, ch /j);
                    }
                }
                if(lg == 1 || lg == ch) {
                    return -1;
                }
                ch /= lg;
                cnt++;
             }
             last = ch;   
        }

        return cnt;
    }
};
",1427890126
Anshu Dwivedi,anshudwivedi49,445,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int left = 0, right = 0;
        vector<int> freq(26, 0);
        int count = 0;

        while (right < n) {
            freq[s[right] - 'a']++;
            
            while (isValid(freq, k)) {
                count += n - right;  
                freq[s[left] - 'a']--;
                left++;
            }
            right++;
        }
        
        return count;
    }
    
    bool isValid(vector<int>& freq, int k) {
        for (int i = 0; i < 26; i++) {
            if (freq[i] >= k) return true;
        }
        return false;
    }
};
",1427840723
Anshu Dwivedi,anshudwivedi49,445,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string& target) 
    {
        vector<string> ans ;
         string s="""";
        
        for(int i = 0; i < target.length(); i++)
        {
            char currentTarget = target[i];
            s.push_back('a');
            ans.push_back(s);
             while (s.back() < currentTarget) 
            {
                s.back()++;
                ans.push_back(s);
            } 
                     
        }
        
        return ans;
    }
};
",1427835229
Anshu Dwivedi,anshudwivedi49,445,3603,cpp,"class Solution
{
public:
    long long a;
    vector<long long> v;
    const long long mod = 1e9 + 7;

    void initialize(int n) {
        a = 911;
        v.resize(n + 2);
        v[0] = 1;

        for (int i = 1; i <= n + 1; i++) {
            v[i] = (v[i - 1] * a) % mod;
        }
    }

    void dfs(vector<vector<int>>& adj, vector<int>& indegree, vector<bool>& visited) {
        stack<int> s;
        s.push(0);

        while (!s.empty()) {
            int num = s.top();
            if (!visited[num]) {
                visited[num] = true;
                for (int i = adj[num].size() - 1; i >= 0; i--) {
                    s.push(adj[num][i]);
                }
            } else {
                s.pop();
                indegree.push_back(num);
            }
        }
    }

    void processNode(int num, vector<vector<int>>& adj, vector<int>& h, vector<long long>& forw, vector<long long>& rev, vector<bool>& ans, const string& s) {
        h[num] = 1;
        long long nodef = 0;
        for (int i = 0; i < adj[num].size(); i++) {
            int child = adj[num][i];
            nodef = (nodef * v[h[child]] + forw[child]) % mod;
            h[num] += h[child];
        }
        nodef = (nodef * a + (s[num] - 'a' + 1)) % mod;
        forw[num] = nodef;

        long long noder = (s[num] - 'a' + 1);
        for (int i = adj[num].size() - 1; i >= 0; i--) {
            int child = adj[num][i];
            noder = (noder * v[h[child]] + rev[child]) % mod;
        }
        rev[num] = noder;
        ans[num] = (forw[num] == rev[num]);
    }

    vector<bool> findAnswer(vector<int>& parent, string& s) {
        int n = parent.size();
        initialize(n);
        vector<bool> ans(n);
        vector<vector<int>> adj(n);

        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }

        vector<int> indegree;
        vector<bool> visited(n, false);
        dfs(adj, indegree, visited);

        vector<int> h(n);
        vector<long long> forw(n);
        vector<long long> rev(n);

        for (int i = 0; i < indegree.size(); i++) {
            int num = indegree[i];
            processNode(num, adj, h, forw, rev, ans, s);
        }

        return ans;
    }
};
",1427949653
Anshu Dwivedi,anshudwivedi49,445,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

bool b = false;
static const int maxi = 1e6+7;
int pre[maxi + 1];

void help() {
    if (b) 
        return;
    for (int i = 0; i <= maxi; i++) {
        pre[i] = 1;
    }
    for (int i = 2; i <= maxi; i++) {
        for (int j = 2 * i; j <= maxi; j += i) {
            pre[j] = i;
        }
    }
    b = true;
}

class Solution {
public:
    int minOperations(vector<int> &nums) {
        help();
        int ans = 0;
        int n = nums.size();

        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int divisor = pre[nums[i]];
                if (divisor == 1) 
                    return -1;
                nums[i] /= divisor;
                ans++;
                if (nums[i] <= 0) 
                    return -1;
            }
        }

        return ans;
    }
};
",1427920239
Anuran Das,anurandeveloper,447,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int i=0, j=0, n = s.length();
        unordered_map<char, int> mp;
        int count=0, res=0;

        while(j<s.length()){
            mp[s[j]]++;
            if(mp[s[j]] == k) count++;

             while (count > 0) {
                res += n - j;
                mp[s[i]]--;
                if (mp[s[i]] == k - 1) count--;
                i++;
            }
            j++;
        }
        return res;
    }
};",1427850692
Anuran Das,anurandeveloper,447,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";

        for (char ch : target) {
            curr += 'a';
            res.push_back(curr);

            while (curr.back() != ch) {
                curr.back() = (curr.back() == 'z') ? 'a' : curr.back() + 1;
                res.push_back(curr);
            }
        }
        return res;
    }
};",1427833690
Anuran Das,anurandeveloper,447,3603,cpp,"class Solution {
public:
    long long pw = 31, mod = 9576890767;
    
    long long mulMod(long long a, long long b) {
        return (__int128)a * b % mod;
    }
    
    vector<long long> dfs(long long node, vector<vector<long long>>& adj, vector<long long>& power, vector<bool>& ans, string& s) {
        vector<long long> forward, reverse, sizes;
        for (auto &child : adj[node]) {
            vector<long long> childValues = dfs(child, adj, power, ans, s);
            forward.push_back(childValues[0]);
            reverse.push_back(childValues[1]);
            sizes.push_back(childValues[2]);
        }
        long long currentCharValue = s[node] - 'a' + 1;
        forward.push_back(currentCharValue);
        reverse.push_back(currentCharValue);
        sizes.push_back(1);
        long long forwardHash = 0;
        long long totalSize = 0;
        long long n = forward.size();
        for(int i=0; i<n; i++){
            forwardHash = (forwardHash + mulMod(power[totalSize], forward[i])) % mod;
            totalSize += sizes[i];
        }
        long long reverseHash = 0;
        totalSize = 0;
        for(int i=n-1; i>=0; i--) {
            reverseHash = (reverseHash + mulMod(power[totalSize], reverse[i])) % mod;
            totalSize += sizes[i];
        }
        if (forwardHash == reverseHash) ans[node] = true;
        return {forwardHash, reverseHash, totalSize};
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        long long n = s.size();
        vector<bool> ans(n, false);
        vector<long long> power(n + 1, 1);
        vector<vector<long long>> adj(n);
        for(int i=1; i<n+1; i++) {
            power[i] = mulMod(pw, power[i - 1]);
        }
        for(int i=0; i<n; i++) {
            if (parent[i] != -1)
                adj[parent[i]].push_back(i);
        }
       
        dfs(0, adj, power, ans, s);
        return ans;
    }
};",1427957820
Anuran Das,anurandeveloper,447,3607,cpp,"class Solution {
public:
    int findGreatestProperDivisor(int num) {
        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                return num / i;
            }
        }
        return 1;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ops = 0;
        int minReq = INT_MAX;

        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] <= minReq) {
                minReq = nums[i];
                continue;
            }
            
            int currOps = 0;
            int num = nums[i];
            
            while (num > minReq) {
                int greatestProperDivisor = findGreatestProperDivisor(num);
                if (greatestProperDivisor == 1) {
                    return -1;
                }
                num /= greatestProperDivisor;
                currOps++;
            }
            ops += currOps;
            minReq = num;
        }
        return ops;
    }
};",1427863013
Gavnish kumar,gavnish_kumar,450,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n= s.size();
        int ans=0;
        vector<int> f(26,0);
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
               f[s[j]-'a']++;
               int maxfreq=*max_element(f.begin(),f.end());
               if(maxfreq>=k) ans++;

            }
            for(int i=1;i<=26;i++) f[i-1]=0;
        }
    return ans;
    }
};",1427899195
Gavnish kumar,gavnish_kumar,450,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cha = """";
        int count=0;
        for(auto i: target){
            for(char ch='a';ch<='z';ch++){
                char mych=ch;
                string n = cha;
                n.push_back(mych);
                ans.push_back(n);
                count++;
                if(mych == i) break;
            }
            cha.push_back(i);
        }
        return ans;
// vector<string> res;
//         string last = """";
//         for(auto i: target){
//             for(char ch = 'a'; ch <= 'z'; ch++){
//                 string n = last;
//                 n.push_back(ch);
//                 res.push_back(n);
//                 if(ch == i) break;
//             }
//             last.push_back(i);
//         }
//         return res;
    }
};",1427906268
Gavnish kumar,gavnish_kumar,450,3603,cpp,"#define ll long long 
class Solution {
public:
    int mod = 9576890767;  // Large prime to avoid collisions
    ll countval = 0;       // Counter variable retained
    vector<ll> dfs(ll node, vector<vector<ll>>& graph, vector<ll>& powers, vector<bool>& result, string& str) {
        vector<ll> forwardHash, reverseHash, subtreeSize;
        countval++;
        
        // DFS on child nodes
        for (auto &child: graph[node]) {
            vector<ll> temp = dfs(child, graph, powers, result, str);
            forwardHash.push_back(temp[0]);
            countval++;
            reverseHash.push_back(temp[1]);
            countval++;
            subtreeSize.push_back(temp[2]);
        }

        // Include current node's value in the hash
        forwardHash.push_back(str[node] - 'a' + 1);
        countval++;
        reverseHash.push_back(str[node] - 'a' + 1);
        subtreeSize.push_back(1);

        ll fwdHashVal = 0, revHashVal = 0, totalSize = forwardHash.size();
        ll cumulativeSize = 0;
        countval++;

        // Calculate forward hash
        for (int i = 0; i < totalSize; i++) {
            ll c = cumulativeSize;
            cumulativeSize += subtreeSize[i];
            fwdHashVal = (fwdHashVal + (powers[c] * forwardHash[i]) % mod) % mod;
        }

        // Reset cumulative size and calculate reverse hash
        cumulativeSize = 0;
        for (int i = totalSize - 1; i >= 0; i--) {
            revHashVal = (revHashVal + (powers[cumulativeSize] * reverseHash[i]) % mod) % mod;
            cumulativeSize += subtreeSize[i];
            countval--;
        }

        // Mark node if palindrome subtree exists
        if (fwdHashVal == revHashVal) result[node] = true;
        return {fwdHashVal, revHashVal, cumulativeSize};
    }

    vector<bool> findAnswer(vector<int>& parents, string str) {
        ll n = str.size();
        vector<bool> result(n, false);        // Stores result
        vector<ll> powers(n + 1, 1);          // Powers of 31 for hashing
        vector<vector<ll>> graph(n);          // Adjacency list
        ll ans = 0;                           // Variable retained
       
        // Precompute powers of 31
        for (int i = 1; i <= n; i++) {
            ans <<= 1;                        // Logical shift, kept as requested
            powers[i] = (31 * powers[i - 1]) % mod;
            ans = ans / 2;                    // Logical division, kept as requested
        }
        
        // Build graph (adjacency list)
        for (int i = 0; i < n; i++) {
            if (parents[i] != -1) {
                ans++;                        // Retained as per request
                graph[parents[i]].push_back(i);
            }
        }

        // Some dummy computation using ans to retain the variable
        // ll calci = ans * ans / (sqrt(ans));    // Irrelevant computation retained
        
        // Start DFS from root node (0)
        dfs(0, graph, powers, result, str);
        return result;
    }
};
",1427958791
Gavnish kumar,gavnish_kumar,450,3607,cpp,"class Solution {
    vector<int> sieve(int n) {
        vector<int> arr(n + 1, 1);
        for (long i = 2; i * i <= n; i++) {
            if (arr[i] == 1) {
                for (long j = i * i; j <= n; j += i) {
                    if (arr[j] == 1) arr[j] = i;
                }
            }
        }
    
        return arr;
    }

public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return 0;
        vector<int> prime = sieve(1e6+2);
        int ans = 0;
        int lastNum = 1e6 + 1;

        for (int i = n - 1; i >= 0; i--) {
            while (nums[i] > lastNum) {
                if (prime[nums[i]] == 1) return -1; 
                int smallestPrimeFactor = nums[i]/prime[nums[i]];
                nums[i] /= smallestPrimeFactor;
                ans++;
            }
            lastNum = nums[i];
        }

        return ans;
    }
};
",1427892954
Swarup_1719,Swarup_1719,451,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int ans=0;
        int n = s.size();

        for(int i=0;i<n;i++)
        {
            map<int,int> mp;
            for(int j=i;j<n;j++)
            {
                mp[s[j]]++;
                int fl=0;
                for(auto it:mp)
                {
                    if(it.second >= k)
                    {
                        ans+=(n-j);
                        fl=1;
                        break;
                    }
                }
                if(fl) break;
            }
        }
        return ans;
    }
};",1427850733
Swarup_1719,Swarup_1719,451,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string> ans;
        string t;
        for(auto i:s)
        {
            t.push_back('a');
            ans.push_back(t);
            while (t.back() != i)
            {
                t.back() = t.back() + 1;  
                ans.push_back(t);
            }
        }
        return ans;
    }
};",1427846443
Swarup_1719,Swarup_1719,451,3603,cpp,"#define ll long long
const ll pN = 1e7+5;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
#define pqas priority_queue<int, vector<int> , greater<int> >
#define mi map<ll,ll>
#define loop(i,a,b) for(ll i=a;i<b;i++)
#define loope(i,a,b) for(ll i=a;i<=b;i++)
const ll N = 2e5+5;
const ll inf = 1e18;
const ll base = 31;

class Solution {
public:
    vector<ll> powBase;
    vector<ll> forwardHash, reverseHash;

    void precomputePowers(int n) 
    {
        powBase.resize(n+1);
        powBase[0] = 1;
        loope(i,1,n)
        {
            powBase[i] = (powBase[i-1] * base) % mod;
        }
    }

    void computeHashes(const vector<char>& s) 
    {
        int n = s.size();
        forwardHash.resize(n+1, 0);
        reverseHash.resize(n+1, 0);
        loope(i,1,n)
        {
            forwardHash[i] = (forwardHash[i-1] * base + (s[i-1] - 'a' + 1)) % mod;
            reverseHash[i] = (reverseHash[i-1] * base + (s[n-i] - 'a' + 1)) % mod;
        }
    }

    ll getForwardHash(int l, int r) 
    {
        ll hashValue = (forwardHash[r+1] - (forwardHash[l] * powBase[r-l+1]) % mod + mod) % mod;
        return hashValue;
    }

    ll getReverseHash(int l, int r) 
    {
        ll hashValue = (reverseHash[r+1] - (reverseHash[l] * powBase[r-l+1]) % mod + mod) % mod;
        return hashValue;
    }

    void dfs(int node, vector<vector<int>>& tree, const string& s, vector<char>& trav, vector<int>& start, vector<int>& end) 
    {
        start[node] = trav.size();
        for (auto it : tree[node]) {
            dfs(it, tree, s, trav, start, end);
        }
        trav.push_back(s[node]);
        end[node] = trav.size() - 1;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i) 
        {
            tree[parent[i]].push_back(i);
        }

        vector<char> trav;
        vector<int> start(n), end(n);

        dfs(0, tree, s, trav, start, end);

        int travSize = trav.size();
        precomputePowers(travSize);
        computeHashes(trav);

        vector<bool> ans(n);
        forn(i,n) 
        {
            int l = start[i], r = end[i];
            if (getForwardHash(l, r) == getReverseHash(travSize - 1 - r, travSize - 1 - l)) 
            {
                ans[i] = true;
            } 
            else 
            {
                ans[i] = false;
            }
        }

        return ans;
    }
};
",1427942868
Swarup_1719,Swarup_1719,451,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& v) {
        int n = v.size();
        // sieve
        int N=1;
        for(int i=0;i<n;i++)
        {
            N = max(N,v[i]);
        }
        N++;
        //int N = 1e6+5;
        vector<int> lp(N,0),isprime(N,1);
        isprime[0]=isprime[1]=0;
        for(int i=2;i<N;i++)
        {
            if(isprime[i])
            {
                lp[i]=i;
                for(int j=2*i;j<N;j=j+i)
                {
                    isprime[j]=0;
                    if(lp[j]==0)
                    {
                        lp[j]=i;
                    }
                }
            }
        }

        int ans=0;
        for(int i=n-1;i>0;i--)
        {
            if(v[i-1] > v[i])
            {
                if(isprime[v[i-1]])
                {
                    return -1;
                }
                else
                {
                    // reduce v[i-1] and update it 
                    int naya = lp[v[i-1]];
                    if(naya > v[i])
                    {
                        return -1;
                    }
                    else
                    {
                        ans++;
                        v[i-1] = naya;
                    }
                }
            }
        }
        return ans;
    }
};",1427914186
Андрей Хромых,khromykh,453,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int res = 0;
        int n = s.length();
        int[][] counts = new int[27][n+1];
        counts[s.charAt(0) - 'a'][0]++;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 26; j++) {
                counts[j][i+1] = counts[j][i];
            }
            counts[s.charAt(i) - 'a'][i+1]++;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                for (int t = 0; t < 26; t++) {
                    if (counts[t][i+1] - counts[t][j] >= k) {
                        res++;
                        break;
                    }
                }
            }
        }
        return res;
    }
}",1427837638
Андрей Хромых,khromykh,453,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        String cur = """";
        for (var c : target.toCharArray()) {
            for (int i = 0; i <= (c - 'a'); i++) {
                String s = cur + (char)('a' + i);
                res.add(s);
            }
            cur = cur + c;
        }
        return res;
    }
}",1427826313
Андрей Хромых,khromykh,453,3603,java,"class Solution {

    static long[] p;
    static int MOD = 1000_000_007;

    public boolean[] findAnswer(int[] parent, String s) {
        
        int n = parent.length;
        List<Integer>[] g = new ArrayList[n];
        p = new long[n+1];
        p[0] = 1L;
        for (int i = 1; i <= n; i++) {
            p[i] = (p[i-1] * 31) % MOD;
        }
        for (int i = 0; i < n; i++) {
            g[i] = new ArrayList<>();
        }
        for (int i = 1; i < n; i++) {
            g[parent[i]].add(i);
        }

        boolean[] res = new boolean[n];
        dfs(g, s.toCharArray(), res, 0);
        return res;
    }

    Hs[] dfs(List<Integer>[] g, char[] c, boolean[] res, int cur) {
        int num = 0;
        Hs l = new Hs(0, 0);
        Hs r = new Hs(0, 0);
        Collections.sort(g[cur]);
        for (var next : g[cur]) {
            var nh = dfs(g, c, res, next);
            l = l.plus(nh[0]);
            r = nh[1].plus(r);
        }
        var ch = new Hs(1, c[cur] - 'a' + 1);
        l = l.plus(ch);
        r = ch.plus(r);
        res[cur] = l.equals(r);
        return new Hs[]{l,r};
    }


    record Hs (int len, long h) {

        Hs plus(Hs o) {
            var nh = (o.h * p[len]) % MOD;
            nh = (nh + h) % MOD;
            return new Hs(len + o.len, nh);
        }

    }
}",1427925962
Андрей Хромых,khromykh,453,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int res = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i+1]) {
                int x = div(nums[i], nums[i+1]);
                if (x > nums[i+1]) return -1;
                nums[i] = x;
                res++;
                // System.out.println(Arrays.toString(nums));
            }
        }
        
        return res;
    }

    int div(int x, int y) {
        int res = x;
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) return i;
        }
        return res;
    }

}",1427959521
sky_yuo,sky_yuo,454,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        //gen all substrings xd
        int n=s.size(),cnt=0,res=0;
        for(int i=0;i<n;i++){
            map<int,int> mp;
            int mx=0;
            for(int j=i;j<n;j++){
                mp[s[j]-'a']++;
                mx=max(mx,mp[s[j]-'a']);
                if(mx>=k)res++;
            }
        }
        return res;
    }
};",1427836133
sky_yuo,sky_yuo,454,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s=""a"";
        vector<string> res={s};
        while(res.back()!=target){
            string cur=res.back();
            if(cur[cur.size()-1]==target[cur.size()-1]){
                cur+='a';
            }else{
                cur[cur.size()-1]=cur[cur.size()-1]+1;
            }
            res.push_back(cur);
        }
        return res;
    }
};",1427825060
sky_yuo,sky_yuo,454,3603,cpp,"const int m1 = 1e9+7;
const int m2 = 1e9+9;
const int pa = 46232777;
const int pb = 76858169;
#define ll long long
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        vector<ll> ppa(n + 2), ppb(n + 2);
        ppa[0] = ppb[0] = 1;
        for (int i = 1; i <= n + 1; ++i) {
            ppa[i] = (ppa[i - 1] * pa) % m1;
            ppb[i] = (ppb[i - 1] * pb) % m2;
        }
        vector<ll> fh1(n), bh1(n);
        vector<ll> fh2(n), bh2(n);
        vector<int> fl(n), boylove(n);
        vector<bool> res(n);
        function<void(int)> dfs = [&](int x) {
            int c = s[x] - 'a' + 1;
            fh1[x] = 0;
            fh2[x] = 0;
            fl[x] = 0;
            for (int y : adj[x]) {
                dfs(y);
                fh1[x] = (fh1[x] * ppa[fl[y]] + fh1[y]) % m1;
                fh2[x] = (fh2[x] * ppb[fl[y]] + fh2[y]) % m2;
                fl[x] += fl[y];
            }
            fh1[x] = (fh1[x] * pa + c) % m1;
            fh2[x] = (fh2[x] * pb + c) % m2;
            fl[x] += 1;
            bh1[x] = 0;
            bh2[x] = 0;
            boylove[x] = 0;
            bh1[x] = c;
            bh2[x] = c;
            boylove[x] += 1;
            for (auto it = adj[x].rbegin(); it != adj[x].rend(); ++it) {
                int y = *it;
                bh1[x] = (bh1[x] * ppa[boylove[y]] + bh1[y]) % m1;
                bh2[x] = (bh2[x] * ppb[boylove[y]] + bh2[y]) % m2;
                boylove[x] += boylove[y];
            }
            boylove[x]+=0;
        
            if (fh1[x] == bh1[x] && fh2[x] == bh2[x] && fl[x] == boylove[x]) {
                res[x] = true;
            } else {
                res[x] = false;
            }
        };
        dfs(0);
        return res;
    }
};
",1427943511
sky_yuo,sky_yuo,454,3607,cpp,"class Solution {
public:
    int fa(int tmp){
        for(int i=2;i<=sqrt(tmp);i++)
            if(tmp%i==0)
                return tmp/i;
        return 1;
    }
    int minOperations(vector<int>& nums) {
        //only not possible when the smallest prime factor
        //of a numer thats greater than a
        //number that exists after it is greater
        //idea is to precompute the primes
        //then you can check
        //finding largest factor ont he fly is sqrt(nums[i])
        //at worst which is 1e3
        //should be enough
        // if(nums.size()==1)return 0;
        //  vector<int> factors(*max_element(nums.begin(),nums.end())+5,1);
        // for(int i=4;i<factors.size();i++){
        //     int factor=1;
        //         for(int j=i/2;j>=1;j--)
        //             if(i%j==0){
        //                 factor=j;
        //                 break;
        //             }
        //     factors[i]=factor;
        // }
        //just go backwards :skull:
        //precomp best factor
        int res=0;
        for(int i=nums.size()-1;i>=1;i--){
            if(nums[i-1]>nums[i]){
                int cur=nums[i-1];
                while(cur>nums[i]){
                    int best=fa(cur);
                    if(best==1){
                        return -1;
                    }
                    cur/=best;
                    res++;
                }
                nums[i-1]=cur;
            }
        }
        return res;
    }
};",1427881531
Ying Liu,pein531,455,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), ans = 0;
        vector<vector<int>> presum(26, vector<int>(n));
        for(char c = 'a'; c <= 'z'; c++) {
            for(int i = 0; i < n; i++) {
                presum[c - 'a'][i] = (i > 0? presum[c - 'a'][i - 1]: 0) + (s[i] == c? 1: 0);
            }
        }
        for(int l = 0; l < n; l++) {
            int left = l, right = n - 1, index = -1;
            while(left <= right) {
                int mid = left + right >> 1;
                bool ok = false;
                for(char c = 'a'; c <= 'z'; c++) {
                    if(presum[c - 'a'][mid] - (l > 0? presum[c - 'a'][l - 1]: 0) >= k) {
                        ok = true;
                        break;
                    }
                }
                if(ok) {
                    index = mid;
                    right = mid - 1;
                }else {
                    left = mid + 1;
                }
            }
            if(index != -1) {
                ans += n - index;
            }
        }
        return ans;
    }
};",1427885254
Ying Liu,pein531,455,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        string s;
        s.push_back('a');
        vector<string> ans;
        ans.push_back(""a"");
        int i = 0;
        while(s != target) {
            if(s[i] == target[i]) {
                s.push_back('a');
                ans.push_back("""" + s);
                i++;
            }else {
                while(s[i] != target[i]) {
                    if(s[i] < 'z') {
                        s[i]++;
                    }else {
                        s[i] = 'a';
                    }
                    ans.push_back("""" + s);
                }
            }
        }
        return ans;
    }
};",1427878737
Ying Liu,pein531,455,3603,cpp,"class Solution
{
public:
    vector<set<int>> son;
    vector<int> bt, et;
    string ans, base;
    void dfs(int u)
    {
        bt[u] = ans.size();
        for (auto v : son[u])
        {
            dfs(v);
        }
        et[u] = ans.size();
        ans.push_back(base[u]);
        ans.push_back('#');
    }
    vector<int> Manacher(string s)
    {
        vector<int> p(s.size(), 0);
        int mx = 0, id = 0;
        for (int i = 1; i < s.size(); ++i)
        {
            p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
            while (s[i + p[i]] == s[i - p[i]])
                ++p[i];
            if (mx < i + p[i])
            {
                mx = i + p[i];
                id = i;
            }
        }
        return p;
    }
    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        int n = parent.size();
        base = s;
        son.resize(n);
        bt.resize(n);
        et.resize(n);
        for (int i = 1; i < n; i++)
        {
            son[parent[i]].insert(i);
        }
        ans.push_back('$');
        ans.push_back('#');
        dfs(0);
        vector<int> p = Manacher(ans);
        vector<bool> ret;
        for (int i = 0; i < n; i++)
        {
            int mid = (bt[i] + et[i]) / 2;
            int len = 2* p[mid] - 1;
            int baselen = et[i] - bt[i] + 1;
            ret.push_back(len >= baselen);
        }
        return ret;
    }
};",1427916568
Ying Liu,pein531,455,3607,java,"public class Solution {
    static final int N = 100010, INF = 0x3f3f3f3f;
    static int[][] dp = new int[N][2];
    static int cnt;
    static int[] primes = new int[1000010];
    static int[] st = new int[1000010];
    static int[] minprime = new int[1000010];

    public Solution() {
        if(minprime[4] == 0) {
            cnt = 0;
            getPrimes(1000000);
        }
    }

    public int minOperations(int[] nums) {
        int n = nums.length;
        int[][] tup = new int[n][2];
        for (int i = 0; i < n; i++) {
            tup[i] = new int[]{minprime[nums[i]], nums[i]};
        }
        for (int i = 0; i < n; i++) {
            dp[i][0] = dp[i][1] = -1;
        }
        int ans = dfs(0, 0, nums, tup);
        return ans < INF? ans: -1;
    }

    private int dfs(int i, int pre, int[] nums, int[][] tup) {
        if (i == nums.length) return 0;
        if (dp[i][pre] != -1) return dp[i][pre];
        if (i == 0) {
            int res1 = dfs(i + 1, 0, nums, tup);
            int res2 = 1 + dfs(i + 1, 1, nums, tup);
            return dp[i][pre] = Math.min(res1, res2);
        } else {
            if (pre == 1) {
                int prenum = tup[i - 1][0];
                if (1 < prenum && prenum < nums[i - 1]) {
                    if (prenum > nums[i]) {
                        return dp[i][pre] = INF;
                    } else {
                        int cur = tup[i][0];
                        int res1 = dfs(i + 1, 0, nums, tup);
                        int res2 = INF;
                        if (prenum <= cur) {
                            res2 = 1 + dfs(i + 1, 1, nums, tup);
                        }
                        return dp[i][pre] = Math.min(res1, res2);
                    }
                } else {
                    return dp[i][pre] = INF;
                }
            } else {
                if (nums[i - 1] > nums[i]) return dp[i][pre] = INF;
                int res1 = dfs(i + 1, 0, nums, tup);
                int res2 = INF;
                if (nums[i - 1] <= tup[i][0]) {
                    res2 = 1 + dfs(i + 1, 1, nums, tup);
                }
                return dp[i][pre] = Math.min(res1, res2);
            }
        }
    }

    public int get(int x) {
        return minprime[x];
    }

    public void getPrimes(int n) {
        for (int i = 2; i <= n; i++) {
            if (st[i] == 0) {
                primes[cnt++] = i;
            }
            for (int j = 0; j <= n / i; j++) {
                if (i * primes[j] <= n) {
                    st[i * primes[j]] = 1;
                    minprime[i * primes[j]] = primes[j];
                }
                if (i % primes[j] == 0) break;
            }
        }
    }
}
",1427944049
Krishna0211,Krishna0211,456,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int cnt=0,n=s.size();

        for(int i=0;i<n;i++){
            map<char,int>mp;
            int tr=0;
            for(int j=i;j<n;j++){
                mp[s[j]]++;
                if(mp[s[j]]>=k)tr=1;
                if(tr)
                cnt++;
            }
        }
        return cnt;
    }
};",1427859411
Krishna0211,Krishna0211,456,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string s;
        int n=target.size();
        for(int i=0;i<n;i++){
            s+=""a"";
            ans.push_back(s);
            for(char c='b';c<=target[i];c++){
                s[i]=c;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427837662
Krishna0211,Krishna0211,456,3603,cpp,"class Solution {
public:
    int timer;
    vector<int>tin,tout;
    vector<vector<int>>g;
    vector<pair<long long, long long>>p,inv;
    const int mod=1e9+7;
    long long powerr(long long a,int b){
        long long res=1LL;
        while(b>0){
            if(b&1)res=(1LL*res*a+mod)%mod;
            a=(1LL*a*a+mod)%mod;
            b=b>>1;
        } 
        return res;
    }

    void dfs(int cur,int pr){
        tin[cur]=timer;
        for(auto i:g[cur]){
            if(i==pr)continue;
            dfs(i,cur);
        }
        tout[cur]=timer++;
    }

    void calcHash(int rev,string s, int n,vector<pair<long long ,long long>>&h){
        if(rev)reverse(s.begin(),s.end());
        for(int i=0;i<n;i++){
            h[i]={(1LL*(s[i]-'a'+1)*p[i].first)%mod, (1LL*(s[i]-'a'+1)*p[i].second)%mod};
            if(i>0){
                h[i].first+=h[i-1].first;
                h[i].second+=h[i-1].second;
                h[i].first%=mod;
                h[i].second%=mod;
            }
        }
        if(rev)reverse(h.begin(),h.end());
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=s.size();
        tin=vector<int>(n);
        tout=vector<int>(n);
        g=vector<vector<int>>(n);
        inv.resize(n);
        p.resize(n);
        timer=0;

        for(int i=1;i<n;i++){
            g[parent[i]].push_back(i);
            g[i].push_back(parent[i]);
        }
        dfs(0,-1);
        vector<bool>ans(n,false);
        string t(n,'a');
        for(int i=0;i<n;i++){
            t[tout[i]]=s[i];
        }
        vector<pair<long long,long long>>h1(n),h2(n);
        
        long long p1=1,p2=1;
        for(int i=0;i<n;i++){
            p[i]={p1,p2};
            p1*=31LL;
            p1%=mod;
            p2*=53LL;
            p2%=mod;
            long long inv1=powerr(p[i].first,mod-2);
            long long inv2=powerr(p[i].second,mod-2);
            inv[i]={inv1,inv2};
        }
        calcHash(0, t, n, h1);
        calcHash(1, t, n, h2);
        for(int i=0;i<n;i++){
            int l=tin[i],r=tout[i];
            pair<long long , long long> H1=h1[r];
            pair<long long , long long > H2=h2[l];
            if(l>0){
                H1.first = (H1.first - h1[l-1].first + mod)%mod;
                H1.first *= inv[l].first;
                H1.first %=mod;

                H1.second = (H1.second - h1[l-1].second + mod)%mod;
                H1.second *= inv[l].second;
                H1.second %=mod;
            }
            if(r+1<n){
                H2.first = ( H2.first - h2[r+1].first + mod)%mod;
                H2.first *= inv[n-1-r].first;
                H2.first %= mod;

                H2.second = ( H2.second - h2[r+1].second + mod)%mod;
                H2.second *= inv[n-1-r].second;
                H2.second %= mod;
            }
            if(H1.first == H2.first && H1.second == H2.second)
            ans[i]=true;
        }
        return ans;
    }
};",1427960179
Krishna0211,Krishna0211,456,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& v) {
        int n=v.size();

        const int N = *max_element(v.begin(),v.end())+1;
        vector<int> lp(N+1);
        vector<int> pr;

        for (int i=2; i <= N; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for (int j=0;j<pr.size() && pr[j]<=lp[i] && i*pr[j]<=N; ++j) {
                lp[i*pr[j]] = pr[j];
            }
        }
        int ans=0;
        for(int i=n-2;i>=0;i--){
            while(v[i+1]<v[i]){
                if(lp[v[i]]==v[i])return -1;
                v[i]=lp[v[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427874949
maybe_aryan_,maybe_aryan_,458,3502,cpp,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007

#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvll vector<vector<long long int>>
#define vc vector<char>
#define vll vector<long long>
#define mii map<int, int>
#define mll map<long long, long long>
#define umii unordered_map<int, int>
#define si set<int>
#define sll set<long long>
#define msll multiset<long long>
#define rep(i, s, e) for (ll i = s; i <= e; i++)
#define ren(i, s, e) for (ll i = s; i >= e; i--)

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(); 
        vi f(26, 0);
        ll cnt = 0;
        rep(i, 0, n-1){
            rep(j, 0, 25) f[j] = 0;
            int maxi = 0;
            rep(j, i, n-1){
                f[s[j] - 'a']++;
                if(f[s[j] - 'a'] > maxi){
                    maxi = f[s[j] - 'a'];
                }
                if(maxi >= k){
                    cnt++;
                }
            }
        }
        return cnt;
    }
};",1427931518
maybe_aryan_,maybe_aryan_,458,3566,cpp,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007

#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvll vector<vector<long long int>>
#define vc vector<char>
#define vll vector<long long>
#define mii map<int, int>
#define mll map<long long, long long>
#define umii unordered_map<int, int>
#define si set<int>
#define sll set<long long>
#define msll multiset<long long>
#define rep(i, s, e) for (ll i = s; i <= e; i++)
#define ren(i, s, e) for (ll i = s; i >= e; i--)

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s = ""a"";
        int len = 1;
        while(s != target){
            ans.push_back(s);
            if(target[len-1] == s[len-1]){
                s += 'a';
                len++;
            }
            else{
                s[len-1] = s[len-1] + 1;
            }
        }
        ans.push_back(target);
        return ans;
    }
};",1427930960
maybe_aryan_,maybe_aryan_,458,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007

#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvll vector<vector<long long int>>
#define vc vector<char>
#define vll vector<long long>
#define mii map<int, int>
#define mll map<long long, long long>
#define umii unordered_map<int, int>
#define si set<int>
#define sll set<long long>
#define msll multiset<long long>
#define rep(i, s, e) for (ll i = s; i <= e; i++)
#define ren(i, s, e) for (ll i = s; i >= e; i--)
class stringHash{
    int modulo = 1e9+7;
    long long prime1 = 27, prime2 = 31;
    vector<long long> hash1, hash2;
public:
    stringHash(string s){
        hash1.resize(s.size()+1, 0);
        hash2.resize(s.size()+1, 0);
        
        for(int i = 1; i <= s.size(); i++){
            hash1[i] = (hash1[i-1]*prime1 + ((s[i-1] - 'a') + 1)) % modulo;
        } 
        for(int i = 1; i <= s.size(); i++){
            hash2[i] = (hash2[i-1]*prime2 + ((s[i-1] - 'a') + 1)) % modulo;
        }
    }

    long long binexp(long long base, long long power){
        if(power == 0) return 1;
        if(power == 1) return base;
        long long half = binexp(base, power/2);
        if(power&1)
            return (((half*half)%modulo)*base)%modulo;
        return (half*half)%modulo;
    }

    long long substrHash1(int low, int high){
        long long remaining = (hash1[low]* (binexp(prime1, high-low+1)))%modulo;
        return (hash1[high+1] - remaining + modulo)%modulo;
    }

    long long substrHash2(int low, int high){
        long long remaining = (hash2[low]* (binexp(prime2, high-low+1)))%modulo;
        return (hash2[high+1] - remaining + modulo)%modulo;
    }

    pair<long long, long long> substrHash(int low, int high){
        return {substrHash1(low, high), substrHash2(low, high)};
    }
};
class Solution {
public:
    vector<pii> rangea;
    vector<pii> rangeb;
    void abc(int node, vvi &adj, string &ch, int &limit, string &s){
        rangea[node].first = limit;
        for(auto child : adj[node]){
            abc(child, adj, ch, limit, s);
        }
        limit++;
        s += ch[node];
        rangea[node].second = limit-1;
    }
    void cba(int node, vvi &adj, string &ch, int &limit, string &s){
        s += ch[node];
        rangeb[node].first = limit;
        limit++;
        ren(i, adj[node].size()-1, 0){
            int child = adj[node][i];
            cba(child, adj, ch, limit, s);
        }
        rangeb[node].second = limit-1;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vvi adj(n);
        rep(i, 1, n-1){
            int par = parent[i], child = i;
            adj[par].push_back(i);
        }
        rangea.resize(n);
        rangeb.resize(n);
        int limit = 0;
        string a = """";
        abc(0, adj, s, limit, a);
        limit = 0;
        string b = """";
        cba(0, adj, s, limit, b);
        vb ans(n, false);

        // for(auto c : a) cout << c << "" "";
        // cout << endl;
        // rep(i, 0, n-1){
        //     cout << rangea[i].first << ""-"" << rangea[i].second << "" "";
        // }
        // cout << endl;
        // for(auto c : b) cout << c << "" "";
        // cout << endl;
        // rep(i, 0, n-1){
        //     cout << rangeb[i].first << ""-"" << rangeb[i].second << "" "";
        // }
        // cout << endl;
        stringHash s1(a);
        stringHash s2(b);
        rep(i, 0, n-1){
            int lowa = rangea[i].first, higha = rangea[i].second;
            int lowb = rangeb[i].first, highb = rangeb[i].second;
            int hash1 = s1.substrHash1(lowa, higha);
            int hash2 = s2.substrHash1(lowb, highb);
            ans[i] = (hash1 == hash2);
        }
        return ans;
    }
};",1427961440
maybe_aryan_,maybe_aryan_,458,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007

#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvll vector<vector<long long int>>
#define vc vector<char>
#define vll vector<long long>
#define mii map<int, int>
#define mll map<long long, long long>
#define umii unordered_map<int, int>
#define si set<int>
#define sll set<long long>
#define msll multiset<long long>
#define rep(i, s, e) for (ll i = s; i <= e; i++)
#define ren(i, s, e) for (ll i = s; i >= e; i--)

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int maxi = 0;
        for(auto num : nums) maxi = max(maxi, num);
        vi div(maxi+1, 1);
        rep(i, 2, maxi){
            if(div[i] == 1){
                for(ll j = i*i; j <= maxi; j += i){
                    div[j] = (div[j] == 1 ? i : div[j]);
                }   
            }
        }

        ll op = 0;
        int n = nums.size();
        ren(i, n-2, 0){
            ll ahead = nums[i+1];
            while((nums[i] > ahead) and (div[nums[i]] != 1)){
                nums[i] = div[nums[i]];
                op++;
            }
            if(nums[i] > ahead) return -1;
        }
        return op;
    }
};",1427943836
Nixon2006,Nixon2006,461,3502,cpp,"class Solution {
public:
    int maxf(vector<int>&f, int i=-1)
    {
        if(i!=-1) f[i]--;
        int maxi = 0;
        for(auto &it:f) maxi = max(maxi, it);
        if(i!=-1) f[i]++;
        return maxi;
    }
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        vector<int> f(26,0);
        int i = 0;
        int count = 0;
        for(int j=0;j<n;j++)
        {
            f[s[j]-'a']++;
            while(i+1<=j && maxf(f,s[i]-'a')>=k)
            {
                f[s[i]-'a']--;
                i++;
            }
            if(maxf(f)>=k) count += i+1;
        }
        return count;
        
    }
};",1427856956
Nixon2006,Nixon2006,461,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        int n = target.length();
        for(char ch='a';ch<=target[0];ch++) result.push_back(string(1,ch));
        string a = string(1,target[0]);
        for(int i=1;i<n;i++)  
        {
            for(char ch='a';ch<=target[i];ch++) result.push_back(a+string(1,ch));
            a.push_back(target[i]);
        }
        return result;
        
    }
};",1427832284
Nixon2006,Nixon2006,461,3603,cpp,"struct manacher{
    vector<int> p;
    manacher(string s)
    {
        string t = """";
        for(auto v:s) t += ""#"" + string(1,v);
        populate(t+""#"");
    }
    void populate(string s)
    {
        int n = s.length();
        p.assign(n,1);
        int l=1,r=1;
        for(int i=1;i<n;i++)
        {
            p[i] = max(0, min(r-i,p[l+r-i]));
            while(i+p[i]<n && i-p[i]>=0 && s[i+p[i]]==s[i-p[i]]) p[i]++;
            if(i+p[i]>r) l = i-p[i]+1, r = i+p[i]-1;
        }
    }
    int getLongest(int cen, bool odd) { return p[2*cen + 1 + (!odd)]-1; }
    bool checkPalindrome(int l, int r) { return (r-l+1)<=getLongest((l+r)/2, (l%2)==(r%2)); }
};
class Solution {
public:
    string result = """";
    vector<int> count;
    vector<int> index;
    int pushed = 0;
    int dfs(int i, vector<vector<int>>&child, string&s)
    {
        int sum = 1;
        for(auto &it:child[i]) sum += dfs(it, child,s );
        result.push_back(s[i]);
        count[i] = sum;
        index[i] = pushed;
        pushed++;
        return sum ;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.length();
        vector<vector<int>> child(n);
        for(int i=0;i<n;i++)
        {
            if(parent[i]!=-1) child[parent[i]].push_back(i);
        }
        cout<<""hello""<<endl;
        for(int i=0;i<n;i++) sort(child[i].begin(), child[i].end());
        count.resize(n,0);
        index.resize(n,0);
        dfs(0, child,s);
        manacher m(result);
        vector<bool> arr(n,false);
        for(int i=0;i<n;i++)
        {
            arr[i] = m.checkPalindrome(index[i]-(count[i]-1), index[i]);
        }
        return arr;


        
    }
};",1427963569
Nixon2006,Nixon2006,461,3607,cpp,"class Solution {
public:
    static bool done;
    static vector<int> sieve;
    void compute(vector<int>& nums)
    {
        int maxi = 1e6+1;
        sieve.resize(maxi+2,1);
        for(int i=2;i*i<=maxi;i++)
        {
            for(int j=i*i;j<=maxi;j+=i) sieve[j] = max({sieve[j],i,j/i});
        }
        done = true;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int maxi = 0;
        if(!done) compute(nums);
        // cout<<""hello""<<endl;
        int count = 0;
        int ahead = 1e7;
//         for(int i=0;i<n;i++)
//         {
//             if(nums[i]===1)
//             {
//                 if(prev==1) continue;
//                 else return -1;
//             }
//             if(nums)
            
// // //         }
        // cout<<sieve[105]<<"" ""<<sieve[11]<<endl;
        for(int i=n-1;i>=0;i--)
        {
            if(nums[i]<=ahead)
            {
                ahead = nums[i];
                continue;
            }
            count++;
            nums[i] = nums[i]/sieve[nums[i]];
            if(nums[i]>ahead) return -1;
            ahead = nums[i];
        }
        return count;
//         [25,7]
// [7,7,6]
// [1,1,1,1]
// [11,19,131,151,197]

    }
};
bool Solution::done = false;
vector<int> Solution::sieve;",1427921342
Algorithm Specialist,leetcode_zero,464,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> pos[26];
        for(int i = 0; i < s.size(); i++) pos[s[i] - 'a'].push_back(i);

        int ans = 0;
        for(int i = 0; i < s.size(); i++) {
            int mn = 1e7;
            for(int j = 26; j--; ) {
                int id = lower_bound(pos[j].begin(), pos[j].end(), i) - pos[j].begin();
                int right = id + k - 1;
                if(right < pos[j].size()) mn = min(mn, pos[j][right]);
            }
            if(mn < 1e6) ans += s.size() - mn;
        }
        return ans;
    }
};",1427835741
Algorithm Specialist,leetcode_zero,464,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        for(int i = 0; i < target.size(); i++) {
            string s;
            for(int j = 0; j < i; j++) s += target[j];
            for(char j = 'a'; j <= target[i]; j++) ans.push_back(s + j);
        }
        return ans;
    }
};",1427826113
Algorithm Specialist,leetcode_zero,464,3603,cpp,"class Solution {
public:
    static const int NN = 101010;

    int z[NN << 1];
    char s[NN << 1];

    void zpal(char *s, int n) {
        int i = 0, b = z[0] = 0;
        while(++i < n) {
            z[i] = b + z[b] < i ? 0 : min(z[b + b - i], b + z[b] - i);
            while(i + z[i] + 1 < n && i > z[i] && s[i + z[i] + 1] == s[i - z[i] - 1]) z[i]++;
            if(z[i] + i > z[b] + b) b = i;
        }
    }

    vector<int> adj[NN];
    char ss[NN];

    int L[NN], R[NN], nn = 1, nc;
    void dfs(int u) {
        L[u] = nn;
        for(int v : adj[u]) dfs(v);
        s[nc++] = ss[u], s[nc++] = '$';
        R[u] = nn++;
    }

    vector<bool> findAnswer(vector<int>& parent, string S) {
        int n = parent.size();
        for(int i = 0; i < n; i++) adj[i].clear(), ss[i] = S[i];
        for(int i = 1; i < n; i++) adj[parent[i]].push_back(i);
        
        nc = 0;
        s[nc++] = '$';
        nn = 1, dfs(0);

        zpal(s, nc);
        
        vector<bool> ans;
        for(int i = 0; i < n; i++) {
            int st = L[i] * 2 - 1;
            int ed = R[i] * 2 - 1;
            int md = st + ed >> 1;

            int len = R[i] - L[i] + 1;
            ans.push_back(z[md] >= len - 1);
        }
        return ans;
    }
};",1427941161
Algorithm Specialist,leetcode_zero,464,3607,cpp,"class Solution {
public:
    static const int NN = 101010, MM = 1000001, inf = 1e8;

    int f[MM];
    int dp[NN][2];
    int minOperations(vector<int>& a) {
        for(int i = 2; i < 1000; i++) if(!f[i]) {
            for(int j = i + i; j < MM; j += i) if(!f[j]) f[j] = i;
        }

        if(f[a[0]]) dp[0][1] = 1;
        else dp[0][1] = inf;

        int n = a.size();
        for(int i = 1; i < n; i++) {
            if(a[i - 1] <= a[i]) dp[i][0] = dp[i - 1][0];
            else if(f[a[i - 1]] && f[a[i - 1]] <= a[i]) dp[i][0] = dp[i - 1][1];
            else dp[i][0] = inf;

            if(f[a[i]]) {
                if(a[i - 1] <= f[a[i]]) dp[i][1] = dp[i - 1][0] + 1;
                else if(f[a[i - 1]] && f[a[i - 1]] <= f[a[i]]) dp[i][1] = dp[i - 1][1] + 1;
                else dp[i][1] = inf;
            }
            else dp[i][1] = inf;
            
            if(dp[i][0] == inf && dp[i][1] == inf) return -1;
        }

        int ans = min(dp[n - 1][0], dp[n - 1][1]);
        if(ans == inf) return -1;
        return ans;
    }
};",1427893940
autumn_1eaf,autumn_1eaf,466,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {

        if(k == 1){
            return (s.size() * (s.size() + 1))/2;
        }
        int left = 0;
        int right = 0;
        unordered_map<int, int> count;
        unordered_map<int, int> count2;
        int result = 0;
        while(right < s.size()){
            if(count[s[right]]==(k-1)){
                count2[s[right]]++;
            } else{
                count[s[right]]++;
            }
            while(left < right && count2.size()){
                if(count2.count(s[left])){
                    if(--count2[s[left]] == 0){
                        count2.erase(s[left]);
                    }
                } else{
                    if(--count[s[left]] == 0){
                        count.erase(s[left]);
                    }
                }
                left++;
            }
            // cout << left << "" "" << right << endl;
            // auto latestStartPoint = left-1;
            // cout << right << "" "" << left << endl;
            result += (left);
            right++;
        }
        return result;
    }
};",1427905032
autumn_1eaf,autumn_1eaf,466,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        vector<string> result;
        while(s!=target){
            s.push_back('a');
            result.push_back(s);
            while(s.back()!= target[s.size()-1]){
                s[s.size()-1] += 1;
                result.push_back(s);
            }
        }
        return result;
    }
};",1427825585
autumn_1eaf,autumn_1eaf,466,3603,cpp,"#include <vector>
#include <string>
#include <unordered_map>
using namespace std;

class Solution {
public:
    vector<bool> result;
    string s; // Original string to store post-order traversal
    vector<int> startIdx; // Start indices of substrings for each node
    vector<int> endIdx;   // End indices of substrings for each node
    int idx; // Current index in s during traversal

    // Function to perform post-order traversal and build the string s
    void dfs(int node, const vector<vector<int>>& tree, const string& nodeValues) {
        int start = idx; // Record start index for current node
        for (int child : tree[node]) {
            dfs(child, tree, nodeValues);
        }
        s += nodeValues[node];
        idx++; // Increment index after adding a character
        int end = idx - 1; // Record end index for current node
        startIdx[node] = start;
        endIdx[node] = end;
    }

    vector<bool> findAnswer(vector<int>& parent, string nodeValues) {
        int n = parent.size();
        s = """";
        idx = 0;
        startIdx.resize(n);
        endIdx.resize(n);
        result.assign(n, false);

        // Build the tree
        vector<vector<int>> tree(n);
        int root = -1;
        for (int i = 0; i < n; ++i) {
            if (parent[i] == -1) {
                root = i;
            } else {
                tree[parent[i]].push_back(i);
            }
        }

        // Perform DFS to build the post-order traversal string and record indices
        dfs(root, tree, nodeValues);

        // Transform s for Manacher's algorithm
        string T = ""#"";
        for (char c : s) {
            T += c;
            T += ""#"";
        }
        int m = T.size();
        vector<int> P(m, 0); // Array to store palindrome radii

        int center = 0, right = 0;
        for (int i = 1; i < m - 1; ++i) {
            int mirror = 2 * center - i;
            if (i < right)
                P[i] = min(right - i, P[mirror]);
            // Expand around center i
            while (i + P[i] + 1 < m && i - P[i] - 1 >= 0 && T[i + P[i] + 1] == T[i - P[i] - 1])
                P[i]++;
            // Update center and right boundary
            if (i + P[i] > right) {
                center = i;
                right = i + P[i];
            }
        }

        // For each node, check if the substring is a palindrome
        for (int i = 0; i < n; ++i) {
            int start = startIdx[i];
            int end = endIdx[i];
            int len = end - start + 1;
            // Map to positions in T
            int trans_start = 2 * start + 1;
            int trans_end = 2 * end + 1;
            int center_pos = (trans_start + trans_end) / 2;
            int radius = P[center_pos];
            if (radius >= (trans_end - trans_start) / 2) {
                result[i] = true;
            }
        }

        return result;
    }
};
",1427966608
autumn_1eaf,autumn_1eaf,466,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<vector<int>> dp(nums.size(), vector<int>(2, 1e9));
        vector<int> reduced = nums;
        int NOT_PICK = 0;
        int PICK = 1;
        dp[nums.size()-1][NOT_PICK] = 0;
        dp[nums.size()-1][PICK] = 0;
        for(int i = nums.size()-2; i>=0; i--){
            auto curr = nums[i];
            
            //curr wthout reducing
            if(curr <= nums[i+1]){
                dp[i][NOT_PICK] = min(dp[i][NOT_PICK], dp[i+1][NOT_PICK]);
            }
            if(curr <= reduced[i+1]){
                dp[i][NOT_PICK] = min(dp[i][NOT_PICK], dp[i+1][PICK]);
            }

            for(int j=2; j<= sqrt(curr); j++){
                if(curr%j == 0){
                    reduced[i] = j;
                    break;
                }
            }
            
            auto currRed = reduced[i];
            if(currRed <= nums[i+1]){
                dp[i][PICK] = min(dp[i][PICK], 1 + dp[i+1][NOT_PICK]);
            }
            if(currRed <= reduced[i+1]){
                dp[i][PICK] = min(dp[i][PICK], 1 + dp[i+1][PICK]);
            }
        }

        auto res = min(dp[0][NOT_PICK], dp[0][PICK]);
        return res >= 1e9 ? -1 : res; 
    }
};",1427887906
zhz,eatcoc10,468,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        mp = defaultdict(int)
        j = 0
        for idx in range(len(s)):
            mp[s[idx]] += 1
            j = idx
            if max(mp.values()) == k:
                break
        
        answer = 0
        if max(mp.values()) == k:
            answer += len(s) - j

        
        for i in range(1, len(s)):
            mp[s[i - 1]] -= 1
            while j < len(s) - 1 and max(mp.values()) < k:
                j += 1
                mp[s[j]] += 1
            # print(i, j)
            if max(mp.values()) == k:
                answer += len(s) - j
        
        return answer",1427838745
zhz,eatcoc10,468,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        s = ''
        answer = []
        for c in target:
            for i in range(26):
                if i <= ord(c) - ord('a'):
                    answer.append(s + chr(ord('a') + i))
            s += c
        return answer",1427826132
zhz,eatcoc10,468,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        adj = [[] for _ in range(len(parent))]
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        
        for i in range(n):
            adj[i].sort()
        
        idx = [-1] * n
        dfsStr = ''
        def dfs(node):
            nonlocal idx, dfsStr
            for v in adj[node]:
                dfs(v)
            dfsStr += s[node]
            idx[node] = len(dfsStr) - 1
        
        dfs(0)
        # print(dfsStr)
        answer = [False] * n
        
        def dfs2(node):
            nonlocal dfsStr, idx
            ss = s[node]
            for v in adj[node][::-1]:
                ss += dfs2(v)
            # print(node)
            # print(ss)
            # print(idx[node])
            # print(dfsStr[idx[node] - len(ss) + 1:idx[node] + 1])
            answer[node] = (dfsStr[idx[node] - len(ss) + 1:idx[node] + 1] == ss)
            return ss
        dfs2(0)
        return answer
        
            ",1427951207
zhz,eatcoc10,468,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int maxx = 0;
        for (int i = 0; i < nums.size(); ++i) {
            maxx = max(nums[i], maxx);
        }
        
        maxx += 3;
        vector<int> prime(maxx, -1);
        
        for (long long i = 2; i < maxx; ++i) {
            if (prime[i] == -1) {
                for (long long j = i * i; j < maxx; j += i) {
                    if (prime[j] == -1) prime[j] = i;
                }
            }
        }
        
        // for (int i = 0; i < maxx; ++i) {
        //     cout << prime[i] << endl;
        // }
        int answer = 0;
        for (int i = nums.size() - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                if (prime[nums[i]] == -1) break;
                nums[i] = prime[nums[i]];
                answer += 1;
            }
            if (nums[i] > nums[i + 1]) return -1;
        }
        return answer;
    }
};",1427886951
Sanath_Kulla,Sanath_Kulla,469,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.size();
        for(int i = 0; i<n;i++){
        vector<int> cnt(26 , 0);
        int c= 0;
            for(int j = i ; j < n ;j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a'] == k)c++;
                if(c)ans++;
            }
        }
        return ans;
    }
};",1427827320
Sanath_Kulla,Sanath_Kulla,469,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string x;
        for(auto &it:target){
            x += 'a';
            while(x.back() != it){
                ans.push_back(x);
                x.back()++;
            }
            ans.push_back(x);
        }
        return ans;
    }
};",1427824597
Sanath_Kulla,Sanath_Kulla,469,3603,cpp,"
mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());

struct Hash{
    int b, n; // b = number of hashes
    const int mod = 1e9 + 7;//2000000011ll 
    vector<vector<int>> fw, bc, pb, ib;
    vector<int> bases;
 
    inline int power(int x, int y){
        if (y == 0){
            return 1;
        }
 
        int v = power(x, y / 2);
        v = 1LL * v * v % mod;
        if (y & 1) return 1LL * v * x % mod;
        else return v;
    }
 
    inline void init(int nn, int bb, string str){
        n = nn;
        b = bb;
        fw = vector<vector<int>>(b, vector<int>(n + 2, 0));
        bc = vector<vector<int>>(b, vector<int>(n + 2, 0));
        pb = vector<vector<int>>(b, vector<int>(n + 2, 1));
        ib = vector<vector<int>>(b, vector<int>(n + 2, 1));
        bases = vector<int>(b);
        str = ""0"" + str;
 
        for (auto &x : bases) x = RNG() % (mod / 10);
 
        for (int i = 0; i < b; i++){
            for (int j = 1; j <= n + 1; j++){
                pb[i][j] = 1LL * pb[i][j - 1] * bases[i] % mod;
            }
            ib[i][n + 1] = power(pb[i][n + 1], mod - 2);
            for (int j = n; j >= 1; j--){
                ib[i][j] = 1LL * ib[i][j + 1] * bases[i] % mod;
            }
 
            for (int j = 1; j <= n; j++){
                fw[i][j] = (fw[i][j - 1] + 1LL * (str[j] - 'a' + 1) * pb[i][j]) % mod;
            }
            for (int j = n; j >= 1; j--){
                bc[i][j] = (bc[i][j + 1] + 1LL * (str[j] - 'a' + 1) * pb[i][n + 1 - j]) % mod;
            }
        }
    }
 
    inline int getfwhash(int l, int r, int i){
        int ans = fw[i][r] - fw[i][l - 1];
        ans = 1LL * ans * ib[i][l - 1] % mod;
        
        if (ans < 0) ans += mod;
 
        return ans;
    } 
 
    inline int getbchash(int l, int r, int i){
        int ans = bc[i][l] - bc[i][r + 1];
        ans = 1LL * ans * ib[i][n - r] % mod;
 
        if (ans < 0) ans += mod;
 
        return ans;
    }
 
    inline bool equal(int l1, int r1, int l2, int r2){
        for (int i = 0; i < b; i++){
            int v1, v2;
            if (l1 <= r1) v1 = getfwhash(l1, r1, i);
            else v1 = getbchash(r1, l1, i);
 
            if (l2 <= r2) v2 = getfwhash(l2, r2, i);
            else v2 = getbchash(r2, l2, i);
 
            if (v1 != v2) return false;
        }
        return true;
    }
 
    inline bool pal(int l, int r){
        return equal(l, r, r, l);
    }
};
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
         int n = s.size();
        vector<vector<int>> adj(n);
        for(int i = 1;i<n;i++){
            adj[parent[i]].push_back(i);
            // adj[i].push_back(parent[i]);   
        }
        // for(int i = 0 ; i < n ; i++){
        //     sort(adj[i].begin() , adj[i].end());
        // }
        vector<int> ord;
        auto dfs = [&](auto &&self , int u , int p)->void{
             for(auto it:adj[u]){
                 if(it == p)continue;
                 self(self , it,u);
             }  
            ord.push_back(u);
        };
        dfs(dfs , 0 , -1);
        string X = """";
        vector<int> pos(n , 0);
        for(int i = 0 ; i < n ; i++){
            pos[ord[i]] = i;
            char ch = s[ord[i]];
            X += ch;
            
        }
        
        Hash hash;
        hash.init(n , 1 , X);
        
        
        vector<bool> ans(n , 0);
        auto dfs2 = [&](auto &&self , int u , int p)->int{
             int ret = 1e9;
             bool leaf = 1;
             for(auto it:adj[u]){
                 if(it == p)continue;
                 leaf = 0;
                 int x = self(self , it , u);
                 if(ret == 1e9)ret = x;
             }
            if(leaf)ret = u;
             if(hash.pal(pos[ret]+1 , pos[u]+1))ans[u] = 1;
            return ret;
        };
        dfs2(dfs2 ,  0 , -1);
        return ans;
        
        
        
    }
};",1427944673
Sanath_Kulla,Sanath_Kulla,469,3607,cpp,"const int N = 1e6 + 10;
vector<bool> isPrime(N , 1);
vector<int> primes;
int lpf[N];



auto linear_seive = []() {
    isPrime[0] = isPrime[1] = 0;
    int i;
    for (i = 2; i < N ; i++) {
        if (isPrime[i]) primes.push_back(i) , lpf[i] = i;
        for (int j = 0 ; j < primes.size() and i * primes[j] < N ; j++) {
            isPrime[primes[j] * i] = 0;
            lpf[primes[j] * i] = primes[j];
            if (i % primes[j] == 0)break;
        }

    }
    return 1;
}();


class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans=0;
        for(int i = n-2;i>=0;i--){
            if(nums[i] > nums[i+1]){
                nums[i] = lpf[nums[i]];
                ans++;
            }
            if(nums[i] > nums[i+1])return -1;
        }
        return ans;
    }
};",1427834753
Sam Chen,SamChen856,470,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        
        for (int i = 0; i < n; ++i) {
            int cnt[26] = {0};
            for (int j = i; j < n; ++j) {
                cnt[s[j] - 'a']++;
                bool any_ge_k = false;
                for (int x = 0; x < 26; ++x) {
                    if (cnt[x] >= k){
                        any_ge_k = true;
                        break;
                    }
                }

                if (any_ge_k) {
                    res++;
                }
            }
        }

        return res;
    }
};
",1427844139
Sam Chen,SamChen856,470,3566,python3,"class Solution:
    # brute, time O(n^2), space O(n)
    def stringSequence(self, target: str) -> List[str]:
        n = len(target)
        res = []
        cur = ''
        for i in range(n):
            need = target[:i+1]
            while cur != need:
                if not cur or len(cur) < len(need):
                    cur += 'a'
                else:
                    cur = cur[:-1] + chr(ord(cur[-1]) + 1)
                res.append(cur)
        return res",1427830342
Sam Chen,SamChen856,470,3603,python3,"import random

HMOD = 2147483647
HBASE1 = random.randrange(HMOD)
HBASE2 = random.randrange(HMOD)


class Hashing:
    def __init__(self, s, mod=HMOD, base1=HBASE1, base2=HBASE2):
        self.mod, self.base1, self.base2 = mod, base1, base2
        self._len = _len = len(s)
        f_hash, f_pow = [0] * (_len + 1), [1] * (_len + 1)
        s_hash, s_pow = f_hash[:], f_pow[:]
        for i in range(_len):
            f_hash[i + 1] = (base1 * f_hash[i] + s[i]) % mod
            s_hash[i + 1] = (base2 * s_hash[i] + s[i]) % mod
            f_pow[i + 1] = base1 * f_pow[i] % mod
            s_pow[i + 1] = base2 * s_pow[i] % mod
        self.f_hash, self.f_pow = f_hash, f_pow
        self.s_hash, self.s_pow = s_hash, s_pow

    def hashed(self, start, stop):
        return (
            (self.f_hash[stop] - self.f_pow[stop - start] * self.f_hash[start]) % self.mod,
            (self.s_hash[stop] - self.s_pow[stop - start] * self.s_hash[start]) % self.mod,
        )

    def get_hashes(self, length):
        return (
            [(self.f_hash[i + length] - self.f_pow[length] * self.f_hash[i]) % self.mod for i in range(self._len - length + 1)],
            [(self.s_hash[i + length] - self.s_pow[length] * self.s_hash[i]) % self.mod for i in range(self._len - length + 1)],
        )


class Solution:
    # dfs + string hashing, time O(n), space O(n)
    def findAnswer(self, parent: List[int], ss: str) -> List[bool]:
        n = len(ss)

        G = [[] for _ in range(n)]
        for i in range(1, n):
            G[parent[i]].append(i)

        walk = []
        start = [0] * n
        end = [0] * n
        idx = 0

        def dfs(u, p=-1):
            nonlocal idx
            start[u] = idx
            for v in sorted(G[u]):
                if v != p:
                    dfs(v, u)
            walk.append(ord(ss[u]) - ord('a'))
            idx += 1
            end[u] = idx - 1

        dfs(0)

        rev_walk = walk[::-1]
        answer = [False] * n

        H = Hashing(walk)
        rev_H = Hashing(rev_walk)

        for i, (s, e) in enumerate(zip(start, end)):
            if H.hashed(s, e) == rev_H.hashed(n - 1 - e, n - 1 - s):
                answer[i] = True
        
        return answer",1427960881
Sam Chen,SamChen856,470,3607,python3,"M = 10**6 + 1

# spf = [0] * M  # smallest prime factor
# for i in range(2, M):
#     if spf[i] == 0:
#         spf[i] = i
#         for j in range(i * 2, M, i):
#             if spf[j] == 0:
#                 spf[j] = i

gpd = [1] * (M + 1)  # greatest proper divisor
for i in range(2, M // 2 + 1):
    for j in range(2 * i, M + 1, i):
        gpd[j] = max(gpd[j], i)


class Solution:
    # prime (Sieve of Eratosthenes) + dp, time O(MloglogM+nlogM), space O(1), M = 10^6
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)

        def get_spf(x):
            if x == 1:
                return 1
            if x == spf[x]:
                return x
            return x // spf[x]

        @cache
        def perform_operation(x):
            res = []  # (value, operation count)
            ops = 0

            while True:
                res.append((x, ops))
                if gpd[x] in (1, x):
                    break
                x //= gpd[x]
                ops += 1

            return res

        dp = [{} for _ in range(n)]  # dp[i] = {val -> ops} at index i

        for i, x in enumerate(nums):
            for v, ops in perform_operation(x):
                if i == 0:
                    dp[i][v] = ops
                else:
                    for pre_v in dp[i - 1]:
                        if v >= pre_v:
                            dp[i][v] = min(dp[i].get(v, inf), dp[i - 1][pre_v] + ops)
            if not dp[i]:
                return -1

        return min(dp[-1].values())",1427936921
swagggn0,swagggn0,471,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        counts = [0] * 26
        left, right = 0, 0
        n = len(s)
        res = 0

        for left in range(n):
            while right < n and max(counts) < k:
                counts[ord(s[right]) - ord('a')] += 1
                right += 1

            if not max(counts) == k:
                return res

            res += n - right + 1
            counts[ord(s[left]) - ord('a')] -= 1
        
        return res
",1427841846
swagggn0,swagggn0,471,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        current = ''
        letters = 'abcdefghijklmnopqrstuvwxyz'
        for ch in target:
            for letter in letters:
                res.append(current + letter)
                if letter == ch:
                    break
            current = current + ch
        return res",1427829035
swagggn0,swagggn0,471,3603,python3,"from typing import List

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        import sys
        sys.setrecursionlimit(max(1000000, len(parent) + 10))
        
        n = len(parent)
        tree = [[] for _ in range(n)]
        for child, p in enumerate(parent[1:], 1):
            tree[p].append(child)
        
        # Hash parameters
        MOD = 10**9 + 7
        BASE = 911
        MAX_LEN = n + 1  # Maximum possible length of any res_str
        # Precompute powers of BASE
        power = [1] * (MAX_LEN + 1)
        for i in range(1, MAX_LEN + 1):
            power[i] = (power[i-1] * BASE) % MOD
        
        # Initialize arrays to store forward_hash, backward_hash, and length
        forward_hash = [0] * n
        backward_hash = [0] * n
        length = [0] * n
        
        def dfs(node: int):
            # Base case: leaf node
            if not tree[node]:
                forward_hash[node] = ord(s[node]) % MOD
                backward_hash[node] = ord(s[node]) % MOD
                length[node] = 1
                return
            
            total_forward = 0
            total_backward = 0
            total_length = 0
            for child in tree[node]:
                dfs(child)
                # Update forward hash: concatenate child forward hash
                total_forward = (total_forward * power[length[child]] + forward_hash[child]) % MOD
                # Update backward hash: concatenate child backward hash
                total_backward = (backward_hash[child] * power[total_length] + total_backward) % MOD
                total_length += length[child]
            
            # Add current node's value
            total_forward = (total_forward * BASE + ord(s[node])) % MOD
            total_backward = (ord(s[node]) * power[total_length] + total_backward) % MOD
            total_length += 1
            
            forward_hash[node] = total_forward
            backward_hash[node] = total_backward
            length[node] = total_length
        
        dfs(0)
        
        # After DFS, each node has forward_hash and backward_hash
        # A string is a palindrome if forward_hash == backward_hash
        return [forward_hash[i] == backward_hash[i] for i in range(n)]
",1427961802
swagggn0,swagggn0,471,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def greatest_proper_divisor(x):
            for i in range(2, x // 2):
                if x % i == 0:
                    return i
            return float('inf')

        current = float('inf')
        res = 0
        for i in range(len(nums)-1,-1,-1):
            if nums[i] <= current:
                current = nums[i]
                continue
            
            r = greatest_proper_divisor(nums[i])
            if r <= current:
                current = r
                res += 1
            else:
                return -1
        
        return res
",1427917792
Xiaoyang Liu,monoid_coda,472,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        result = 0
        start = 0
        state = defaultdict(int)
        valid = False
        for end in range(len(s)):
            c = s[end]
            state[c] += 1
            if state[c] >= k:
                valid = True
            while max(state.values()) >= k:
                state[s[start]] -= 1
                start += 1
                if max(state.values()) < k:
                    start -= 1
                    state[s[start]] += 1
                    break
            if valid:
                result += start + 1
        return result
",1427840466
Xiaoyang Liu,monoid_coda,472,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = []
        state = """"
        for c in target:
            state += ""a""
            for i in range(ord(""a""), ord(c) + 1):
                state = state[:-1] + chr(i)
                result.append(state)
        return result
",1427825058
Xiaoyang Liu,monoid_coda,472,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        tree = defaultdict(list)
        for i in range(len(parent)):
            tree[parent[i]].append(i)
        for l in tree.values():
            l.sort()

        result = [False] * len(parent)
        dfsstr = ""#""
        result_map = {}

        def dfs(node):
            nonlocal dfsstr
            start_i = len(dfsstr)
            for child in tree[node]:
                dfs(child)
            dfsstr += s[node] + ""#""
            result_map[node] = (start_i, len(dfsstr) - 1)

        dfs(0)

        T = ""$"" + dfsstr + ""^""
        nn = len(T) - 2
        L = [0] * len(T)
        ll = 1
        rr = 1
        for i in range(1, nn + 1):
            L[i] = min(L[ll + (rr - i)], rr - i)
            if L[i] < 0:
                L[i] = 0
            while T[i - L[i]] == T[i + L[i]]:
                L[i] += 1
            if i + L[i] > rr:
                ll = i - L[i]
                rr = i + L[i]
        L = L[1:-1]

        for node, (i, j) in result_map.items():
            center = (i + j) // 2
            if center + L[center] >= j and center - L[center] <= i:
                result[node] = True
        return result
",1427946056
Xiaoyang Liu,monoid_coda,472,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        @cache
        def f(x):
            for i in range(2, x):
                if x % i == 0:
                    return i
            return x

        nums = list(reversed(nums))
        prev = nums[0]
        result = 0
        for num in nums[1:]:
            if prev >= num:
                prev = num
                continue
            fnum = f(num)
            if prev < fnum:
                return -1
            result += 1
            prev = fnum
        return result",1427851747
Aditya Srivastava,BinaryWizardby360,474,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string str, int k) {
        int n = str.length(), count = 0;
        
        for (int i = 0; i < n; ++i) {
            vector<int> freq(26, 0);
            auto hasKFreq = [&](const vector<int>& f, int k) {
                for (int x : f) {
                    if (x >= k) return true;
                }
                return false;
            };
            for (int j = i; j < n; ++j) {
                freq[str[j] - 'a']++;
                if (hasKFreq(freq, k)) {
                    count += (n - j);
                    break;
                }
            }
        }
        return count;
    }
};
",1427826795
Aditya Srivastava,BinaryWizardby360,474,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> res;
        string s = """";
        auto appendA = [&](string& s) {
            s += 'a';
            res.push_back(s);
        };
        auto updateChar = [&](string& s, char c) {
            while (s.back() != c) {
                s.back() = (s.back() == 'z') ? 'a' : s.back() + 1;
                res.push_back(s);
            }
        };
        for (char c : t) {
            appendA(s);
            updateChar(s, c);
        }
        return res;
    }
};
",1427824857
Aditya Srivastava,BinaryWizardby360,474,3603,cpp,"#define ll long int
#define vi vector<int>
#define vll vector<long int>

const ll P1 = 31, MOD1 = 1e9 + 7;
const ll P2 = 53, MOD2 = 1e9 + 9;  

class Solution {
public:
    void dfs(int x, vi &L, vi &R, int &idx, const string &s, string &str, vector<vi> &adj) {
        L[x] = idx;
        int size = adj[x].size();
        int y = 0;
        while (y < size) {
            dfs(adj[x][y], L, R, idx, s, str, adj);
            y++;  // Increment y to move to the next child
        }
        str += s[x];
        R[x] = idx++;
    }

    pair<vll, vll> compute_hash(const string &str, ll P, ll MOD) {
        int N = str.size();
        vll hash(N), powP(N + 1, 1);
        hash[0] = str[0] - 'a' + 1;
        int i = 1;
        while (i < N) {
            hash[i] = (hash[i - 1] * P + str[i] - 'a' + 1) % MOD;
            i++;
        }
        i = 1;
        while (i <= N) {
            powP[i] = (powP[i - 1] * P) % MOD;
            i++;
        }
        return {hash, powP};
    }

    void build_adj_list(const vi &parent, vector<vi> &adj) {
        int n = parent.size();
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
    }

    void reverse_string(const string &str, string &revStr) {
        int N = str.size();
        while (N--) {
            revStr += str[N];
        }
    }

    void compute_hashes(const string &str, vll &H1, vll &H2, vll &powP1, vll &powP2) {
        tie(H1, powP1) = compute_hash(str, P1, MOD1);
        tie(H2, powP2) = compute_hash(str, P2, MOD2);
    }

    vector<bool> findAnswer(const vi &parent, const string &s) {
        int n = parent.size();
        vector<vi> adj(n);
        build_adj_list(parent, adj);

        vi L(n, 0), R(n, 0);
        string str = """";
        int idx = 0;
        dfs(0, L, R, idx, s, str, adj);

        string revStr = """";
        reverse_string(str, revStr);

        vll H1, H2, powP1, powP2, RH1, RH2, powRP1, powRP2;
        compute_hashes(str, H1, H2, powP1, powP2);
        compute_hashes(revStr, RH1, RH2, powRP1, powRP2);

        vector<bool> ans(n, false);
        int x = 0;
        while (x < n) {
            int Lx = L[x], Rx = R[x];
            ll hash1_fwd = (Lx > 0) ? (H1[Rx] - H1[Lx - 1] * powP1[Rx - Lx + 1] % MOD1 + MOD1) % MOD1 : H1[Rx];
            ll hash2_fwd = (Lx > 0) ? (H2[Rx] - H2[Lx - 1] * powP2[Rx - Lx + 1] % MOD2 + MOD2) % MOD2 : H2[Rx];

            int A = str.size() - 1 - Rx, B = str.size() - 1 - Lx;
            ll hash1_rev = (A > 0) ? (RH1[B] - RH1[A - 1] * powRP1[B - A + 1] % MOD1 + MOD1) % MOD1 : RH1[B];
            ll hash2_rev = (A > 0) ? (RH2[B] - RH2[A - 1] * powRP2[B - A + 1] % MOD2 + MOD2) % MOD2 : RH2[B];

            if (hash1_fwd == hash1_rev && hash2_fwd == hash2_rev) {
                ans[x] = true;
            }
            x++;
        }
        return ans;
    }
};
",1427963846
Aditya Srivastava,BinaryWizardby360,474,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

const int MAX_VAL = 1000001;
int gpd_arr[MAX_VAL + 1];

class Solution {
public:
    int minOperations(vector<int>& nums) {
        static bool precomputed = false;
        auto computeAndPerform = [&](vector<int>& nums, int& ops) {
            if (!precomputed) {
                memset(gpd_arr, 1, sizeof(gpd_arr));
                int i = 2;
                while (i <= MAX_VAL) {
                    int j = 2 * i;
                    while (j <= MAX_VAL) {
                        gpd_arr[j] = i;
                        j += i;
                    }
                    i++;
                }
                precomputed = true;
            }
            int n = nums.size();
            int i = n - 2;
            while (i >= 0) {
                while (nums[i] > nums[i + 1]) {
                    int d = gpd_arr[nums[i]];
                    if (d == 1) return -1;
                    nums[i] /= d;
                    ops++;
                    if (nums[i] <= 0) return -1;
                }
                i--;
            }
            return ops;
        };

        int ops = 0;
        return computeAndPerform(nums, ops);
    }
};
",1427952206
Eduard Marin,m-eduard,476,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        cnt = 0
        left, right, n = 0, 0, len(s)
        freq = Counter()

        def check():
            greater = False

            for key in freq:
                if freq[key] >= k:
                    return True
            return False

        while left < n:
            while (not check()) and right < n:
                freq[s[right]] += 1
                right += 1
            
            if check():
                cnt += n - right + 1
            
            freq[s[left]] -= 1
            left += 1
        return cnt",1427826984
Eduard Marin,m-eduard,476,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ls = []
        prev = """"

        for i, ch in enumerate(target):
            ls.append(prev + ""a"")

            for j in range(ord(ch) - ord(""a"")):
                ls.append(prev + chr(ord(""a"") + j + 1))
            prev += ch
        return ls",1427832920
Eduard Marin,m-eduard,476,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        tree = defaultdict(list)
        self.res = [False for _ in s]

        # arrays will be sorted, because i-s are sorted
        for i, it in enumerate(parent):
            tree[it].append(i)
        
        MOD = int(1e9+7)
        h = 26
        lastIdx = 0
        
        # annotate each node with its size
        sizes = [0 for _ in s]
        def dfs(root):
            sz = 1

            for child in tree[root]:
                sz += dfs(child)
            sizes[root] = sz
            return sz
        dfs(0)

        ls = []
        def postorder(root):
            sz = sizes[root]
            left = 0
            ss, revSS = 0, 0

            for child in tree[root]:
                res = postorder(child)

                ss = (ss + pow(h, left, MOD) * res[0]) % MOD
                revSS = (pow(h, sizes[child], MOD) * revSS + res[1]) % MOD
                left += sizes[child]

            ss = (ss + pow(h, left, MOD) * (ord(s[root]))) % MOD
            revSS = (revSS * pow(h, 1, MOD) + (ord(s[root]))) % MOD


            ls.append(s[root])

            if ss == revSS:
                # nn = len(ls)
                # for i in range(nn - sz, nn):
                #     if ls[i] != ls[(nn - sz) + nn - 1 - i]:
                #         self.res[root] = False
                #         break
                # else:
                self.res[root] = True
            return (ss, revSS)

        postorder(0)
        return self.res
",1427957868
Eduard Marin,m-eduard,476,3607,python3,"def linear_prime_sieve():
    M = 10**6
    primes = []
    is_prime = [True] * (M + 1)
    min_prime = list(range(M + 1))
    for i in range(2, M + 1):
        if is_prime[i]:
            primes.append(i)
        for p in primes:
            if i * p > M:
                break
            is_prime[i * p] = False
            min_prime[i * p] = p
            if i % p == 0:
                break
    return min_prime
min_factor = linear_prime_sieve()

class Solution:

    def minOperations(self, nums: List[int]) -> int:
        # make each number as small as possible?
        n = len(nums)
        cnt = 0
        prev = float('inf')

        # find the first number that have to be adjusted, and then look back
        # (maybe I should start from the end of the array)
        for i in reversed(range(n)):
            if nums[i] <= prev:
                prev = nums[i]
                continue
            
            while nums[i] > prev and (min_factor[nums[i]] != nums[i]):
                nums[i] = min_factor[nums[i]]
                cnt += 1
            if nums[i] > prev:
                return -1
            prev = nums[i]
        return cnt
",1427851958
Choon Hean Lew,choon_hean,477,3502,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<pair<int, ll>, null_type, greater<pair<int, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=sz(s);
        int res=0;
        rep(0,n){
            vi cnts(26);
            for(int j=i;j<n;j++){
                char c=s[j]-'a';
                cnts[c]++;
                if(cnts[c]==k){
                    res+=n-j;
                    break;
                }
            }
        }
        return res;

    }
};
inline void solve() {
}

//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1427834413
Choon Hean Lew,choon_hean,477,3566,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<pair<int, ll>, null_type, greater<pair<int, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    vector<string> stringSequence(string target) {
        vs res;
        string s=""a"";
        int n=sz(target);
        rep(0,n){
            while(s.back()!=target[i]){
                res.pb(s);
                s.back()++;
            }
            res.pb(s);
            s.pb('a');
        }
        return res;
    }
};
inline void solve() {
}

//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1427826829
Choon Hean Lew,choon_hean,477,3603,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<pair<int, ll>, null_type, greater<pair<int, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // padp[i] x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=sz(parent);
        vb res(n);
        vvi adj(n);
        rep(1,n)adj[parent[i]].pb(i);
        string order;
        vi size(n),start(n);
        auto f=[&](auto&self,int i)->int{
            int q=1;
            start[i]=sz(order);
            for(int&j:adj[i])q+=self(self,j);
            order.pb(s[i]);
            return size[i]=q;
        };
        f(f,0);
        int m=sz(order);
        const int P=31;
        vl p_pow(m);
        p_pow[0] = 1;
        for (int i = 1; i < m; i++) {
            p_pow[i] = (p_pow[i - 1] * P) % mod;
        }
        vi forwardHash(m+1),backwardHash(m+1);
        for (int i = 0; i < m; i++) {
            forwardHash[i + 1] = (forwardHash[i] + (order[i] - 'a' + 1) * p_pow[i]) % mod;
        }

        for (int i = 0; i < m; i++) {
            backwardHash[i + 1] = (backwardHash[i] + (order[m - i - 1] - 'a' + 1) * p_pow[i]) % mod;
        }
        auto getForwardHash = [&](int l, int r) -> long long {
            long long hash_value = (forwardHash[r] - forwardHash[l - 1] + mod) % mod;
            hash_value = (hash_value * p_pow[m - r]) % mod;
            return hash_value;
        };
        auto getBackwardHash = [&](int l, int r) -> long long {
            long long hash_value = (backwardHash[r] - backwardHash[l - 1] + mod) % mod;
            hash_value = (hash_value * p_pow[m - r]) % mod;
            return hash_value;
        };
        for (int i = 0; i < n; i++) {
            int l = start[i] + 1;
            int r = start[i] + size[i];
            if (getForwardHash(l, r) == getBackwardHash(m - r + 1, m - l + 1)) {
                res[i] = true;
            }
        }
        return res;
    }
};
inline void solve() {
}
//int main(){
//    vi a{0,0,0,1,1,2};
//    pr(Solution().findAnswer(a,""aababa""));
//}
//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1427957873
Choon Hean Lew,choon_hean,477,3607,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<double> vd;
typedef vector<bool> vb;
typedef vector<string> vs;
typedef vector<char> vc;
typedef long long ll;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<vvl> vvvl;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<ll, ll> pll;
typedef vector<pii> vpii;
typedef vector<vpii> vvpii;
typedef vector<pll> vpll;
typedef vector<pdd> vpdd;
typedef tree<pair<int, ll>, null_type, greater<pair<int, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
const int inf = 1e9;
const int mod = 1e9 + 7;
#define all(a) a.begin(),a.end()
#define read(n) vi arr(n);for(int _=0;_<n;_++)cin>>arr[_]
#define readarr(n, arr) for(int _=0;_<n;_++)cin>>arr[_]
#define rep(a, n) for(int i=a;i<n;i++)
#define nl ""\n""
#define sz(v) ((int)v.size())
#define PQ priority_queue
#define hmap unordered_map
#define hset unordered_set
#define pb push_back
#define clz(i) __builtin_clz(i)
#define ctz(i) __builtin_ctz(i)
#define popcount(i) __builtin_popcount(i)
#define lsb(i) (i&-i)
mt19937_64 rnd(time(0));


template<typename T>
inline void pr(T t) { cout << t << ' '; }

template<typename T>
inline void pnl(T t) {
    pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(pair<T, U> pa) {
    cout << '(';
    pr(pa.first);
    cout << ',';
    pr(pa.second);
    cout << "") "";
}

template<typename T>
inline void pr(vector<T> v) {
    for (auto i: v) pr(i);
    cout << nl;
}

template<typename T>
inline void pr(set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T>
inline void pr(unordered_set<T> s) {
    for (auto t: s)pr(t);
    cout << nl;
}

template<typename T, typename U>
inline void pr(map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T, typename U>
inline void pr(unordered_map<T, U> m) {
    for (auto [t, u]: m) {
        cout << '(';
        pr(t);
        pr('-');
        pr(u);
        pr(')');
    }
    cout << nl;
}

template<typename T>
inline void pr(queue<T> q) {
    queue<T> copy(q);
    while (!copy.empty()) {
        pr(copy.front());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(stack<T> s) {
    stack<T> copy(s);
    while (!copy.empty()) {
        pr(copy.top());
        copy.pop();
    }
    cout << nl;
}

template<typename T>
inline void pr(PQ<T> pq) {
    PQ<T> copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

template<typename T>
inline void pr(PQ<T, vector<T>, greater<T>> pq) {
    auto copy(pq);
    vector<T> arr;
    while (!copy.empty()) {
        arr.pb(copy.top());
        copy.pop();
    }
    pr(arr);
    cout << nl;
}

inline int euclid(int a, int b, int &x, int &y) { // pass x and y by ref
    int xx = y = 0;
    int yy = x = 1;
    while (b) { // repeats until b == 0
        int q = a / b;
        int t = b;
        b = a % b;
        a = t;
        t = xx;
        xx = x - q * xx;
        x = t;
        t = yy;
        yy = y - q * yy;
        y = t;
    }
    return a; // returns gcd(a, b)
}

inline ll binpow(ll a, int p, int m) {
    ll res = 1;
    while (p) {
        if (p & 1)res = (res * a) % m;
        a = (a * a) % m;
        p >>= 1;
    }
    return res;
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int N=1000;
        bitset<N+1>prime;
        prime.set();
        vi primes;
        for(int i=2;i<=N;i++){
            if(prime[i]){
                primes.pb(i);
                for(int j=i*i;j<=N;j+=i)prime[j]=0;
            }
        }
        int res=0,n=sz(nums);
        for(int i=n-2;i>=0;i--){
            if(nums[i]<=nums[i+1])continue;
            for(int&j:primes)if(nums[i]%j==0){
                nums[i]=j;
                break;
            }
            if(nums[i]>nums[i+1])return -1;
            res++;
        }
        return res;
    }
};
inline void solve() {
}

//int32_t main() {
//    ios_base::sync_with_stdio(false);
//    cin.tie(nullptr);
//    cout.tie(nullptr);
//    int t = 1;
//    cin >> t;
//    while (t--) {
//        solve();
//    }
//    return 0;
//}",1427848618
Surya Teja,suryacr7,478,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = (int)s.size();
        int ans=0;
        for(int i=0;i<n;i++){
            vector<int>m(26,0);
            bool ok=0;
            for(int j=i;j<n;j++){
                m[s[j]-'a']++;
                if(m[s[j]-'a']>=k)ok=1;
                if(ok)ans++;
            }
        }
        return ans;
    }
};",1427835264
Surya Teja,suryacr7,478,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string c) {
        vector<string>v;
        string t;
        for(int i=0;i<(int)c.size();i++){
            for(int j=0;j<=(c[i]-'a');j++){
                string k;
                k=t;
                k.push_back(j+'a');
                v.push_back(k);
            }
            t.push_back(c[i]);
        }
        return v;
    }
};",1427827100
Surya Teja,suryacr7,478,3603,cpp,"class Solution {
public:

    vector<int> p;
    void run(string &s){
        int n=(int)s.length();
        p.assign(n,1);
        int l=1,r=1;
        for(int i=1;i<n;++i){
            p[i]=max(0,min(r-i,(l+r-i >=0) ? p[l+r-i] : 0));
            while(i+p[i]<n and i-p[i]>=0 and s[i+p[i]]==s[i-p[i]])p[i]++;
            if(i+p[i]>r){
                l=i-p[i];
                r=i+p[i];
            }
        }
    }

  void build(string &s){
    string t;
    for(auto it : s){
        t+=string(""#"")+it;
    }
    t+=""#"";
    run(t);
  }

vector<vector<int>>v;
int subt[100010];
string ans;
void dfs(int nn,int pp,string &s){
subt[nn]=1;
for(auto it : v[nn]){
    if(it!=pp){
        dfs(it,nn,s);
        subt[nn]+=subt[it];
    }
}
ans.push_back(s[nn]);
}

vector<bool>q;

void tell(int l,int r,int nn, int pp){
// cout<<l<<"" ""<<r<<"" ""<<nn<<"" ""<<pp<<"" "";
int x=(r-l+1);
int a;
if(x&1){
a=(l+(x/2));
a*=2;
a++;
}else{
a=(l+(x/2));
a*=2;
}
if(p[a]>=x)q[nn]=1;
// cout<<a<<"" ""<<p[a]<<"" ""<<q[nn]<<endl;
for(auto it:v[nn]){
    if(it!=pp){
        tell(l,l+subt[it]-1,it,nn);
        l+=subt[it];
    }
}
}

    vector<bool> findAnswer(vector<int>& c, string s) {
        v.resize(1e5+1);
        int n=0;
        for(int i=0;i<(int)c.size();i++){
            if(c[i]>=0){
                v[c[i]].push_back(i);
            }
            n++;
        }
        dfs(0,-1,s);
        build(ans);
        // for(auto it : p){
        //     cout<<it<<"" "";
        // }
        // cout<<endl;
        q.resize(n);
        tell(0,n-1,0,-1);
        return q;
    }
};",1427958590
Surya Teja,suryacr7,478,3607,cpp,"#define ll long long
class Solution {
public:
int dp[100010][2];
vector<vector<int>>p;
int n;
int rec(int i,int j){
    if(i==n)return 0;
    if(dp[i][j]!=-1)return dp[i][j];
    int ans=1e9;
    if(p[i-1][j]<=p[i][0]){
        ans=rec(i+1,0);
    }
    if(p[i-1][j]<=p[i][1]){
        ans=min(ans,1+rec(i+1,1));
    }
    return dp[i][j]=ans;
}

    int minOperations(vector<int>& v) {
        vector<int>prime(1e3+1,1);
        vector<int>a;
        prime[0]=0;
    prime[1]=0;
        for(int i=2;i<=1e3;++i){
    if(prime[i]==0)continue;
    for(ll j=1ll*i*i;j<=1e3;j+=i){
        prime[j]=0;
    }
}
for(int i=1;i<1e3;i++){
    if(prime[i]){
        a.push_back(i);
        // cout<<i<<"" "";
    }
}
        int ans=0;
        n=(int)v.size();
        for(int i=0;i<n;i++){
            vector<int>c;
            bool ok=0;
            for(int j=0;j<(int)a.size();j++){
                if((v[i]%a[j]) == 0){
                    c.push_back(v[i]);
                    c.push_back(a[j]);
                    p.push_back(c);
                    ok=1;
                    break;
                }
            }
            if(!ok){
                    c.push_back(v[i]);
                    c.push_back(v[i]);
                    p.push_back(c);
            }
        }
        // for(int i=0;i<n;i++)cout<<p[i][0]<<"" ""<<p[i][1]<<""\n"";
        memset(dp,-1,sizeof(dp));
        ans=min(rec(1,0),1+rec(1,1));
        if(ans==1e9)ans=-1;
return ans;
    }
};",1427959307
GxdLJONATHAN16,GxdLJONATHAN16,480,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int count = 0;
        for(int i = 0;i < n;i++){
            map<char, int> mpp;
            for(int j  = i;j < n;j++){
                mpp[s[j]]++;
                bool hask = false;
                for(auto e : mpp){
                    if(e.second >= k){
                        hask = true;
                        break;
                    }
                }
                if(hask){
                    count++;
                }
            }
        }
        return count;
    }
};",1427859180
GxdLJONATHAN16,GxdLJONATHAN16,480,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        for(char c : target){
            current += 'a';
            result.push_back(current);

            while(current.back() < c){
                current.back() += 1;
                result.push_back(current);
            }
        }
        return result;
    }
};",1427844536
GxdLJONATHAN16,GxdLJONATHAN16,480,3603,cpp,"#define ll long long
#define vll vector<ll>
#define fr(j, k) for(int i=j; i<k; i++)
#define rf(j, k) for(int i=j; i>=k; i--)
class Solution {
public:
    ll pw = 31, mod = 1e9;
    vll dfs(ll node, vector<vll>& adj, vll& power, vector<bool>& ans, string& s){
        vll fwd, rev, sz;
        for(auto &it: adj[node]){
            vll val = dfs(it, adj, power, ans, s);
            fwd.push_back(val[0]);
            rev.push_back(val[1]);
            sz.push_back(val[2]);
        }
        fwd.push_back(s[node] - 'a' + 1);
        rev.push_back(s[node] - 'a' + 1);
        sz.push_back(1);
        ll fwdHash = 0;
        ll prev = 0;
        ll n = fwd.size();
        fr(0, n){
            fwdHash = (fwdHash + (power[prev] * fwd[i]) % mod) % mod;
            prev += sz[i];
        }
        ll revHash = 0;
        prev = 0;
        rf(n-1, 0){
            revHash =(revHash + ((power[prev] % mod) * (rev[i] % mod )) % mod) % mod;
            prev += sz[i];
        }
        if(fwdHash == revHash) ans[node] = true;
        return {fwdHash, revHash, prev};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ll n = s.size();
        vector<bool> ans(n, false);
        vll power(n+1, 1);
        vector<vll> adj(n);
        fr(1, n+1){
            power[i] = (pw * power[i-1]) % mod;
        }
        fr(0, n){
            if(parent[i] != -1)
                adj[parent[i]].push_back(i);
        }
        dfs(0, adj, power, ans, s);
        return ans;
    }
};",1427953799
GxdLJONATHAN16,GxdLJONATHAN16,480,3607,cpp,"class Solution {
public:
    int a(int n){
        if(n  <= 1) return 1;
        if(n == 1)return -1;
        for(int i = 2;i*i <= n;i++){
            if(n % i == 0){
                return n/i;
            }
        }
        return 1;
    }
    int minOperations(vector<int>& nums) {
         int n = nums.size();
    int operations = 0;
    
    // Traverse from right to left
    for (int i = n - 2; i >= 0; --i) {
        // While nums[i] is greater than nums[i+1], keep reducing nums[i]
        while (nums[i] > nums[i + 1]) {
            int gpd = a(nums[i]);
            // If nums[i] can't be reduced further, return -1
            if (gpd == 1) {
                return -1;
            }
            nums[i] /= gpd;
            operations++;
            if(nums[i] <= nums[i+1]) break;
        }
        if(nums[i] > nums[i+1]){
            return -1;
        }
    }
    
    return operations;
    }
};",1427933525
Ayanerru,Ayanerru,481,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        pos = collections.defaultdict(list)
        for i, c in enumerate(s):
            pos[c].append(i)
        n = len(s)
        ans = 0
        for i in range(n):
            so_far = n
            for c, vec in pos.items():
                i2 = bisect.bisect_left(vec, i)
                if i2 + k <= len(vec):
                    so_far = min(so_far, vec[i2+k-1])                
            ans += n - so_far
            # print(i, so_far)
        return ans",1427850172
Ayanerru,Ayanerru,481,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        idx = 0
        ans = ['a']
        
        def advance_last(s):
            s = list(s)
            s[-1] = chr(((ord(s[-1]) - ord('a') + 1) % 26) + ord('a'))
            return ''.join(s)
        
        tmp = ""a""
        while tmp != target:
            tmp = ans[-1][:]
            # print(tmp)
            L = len(tmp)
            if tmp[-1] != target[L-1]:
                tmp = advance_last(tmp)
            else:
                tmp += 'a'
            ans.append(tmp)
        return ans
                
        
#         for c in target:
#             tmp = ans[:-1]
            
#             if
            
#             ans.append(''.join(tmp))
#         return ans[1:]",1427837896
Ayanerru,Ayanerru,481,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
#         e = collections.defaultdict(list)       
#         for node, par in enumerate(parent):
#             e[par].append(node)
        
        
#         # print(e)
#         n = len(s)
#         ans = [False] * n
#         ref = [""""] * n
#         for i in range(n):
#             if i not in e:
#                 ans[i] = True
#                 ref[i] = s[i]
        
#         def is_pard(s2):
#             lo, hi = 0, len(s2)-1
#             while lo < hi:
#                 if s2[lo] != s2[hi]:
#                     return False
#                 lo += 1
#                 hi -= 1
#             return True
        
#         @functools.lru_cache(None)
#         def dfs(node):
#             cur = """"
#             for child in e[node]:
#                 cur += dfs(child)
#             cur += s[node]
#             ref[node] = cur
#             # print('node', node, ':', cur)
#             ans[node] = is_pard(cur)
#             return cur
#         dfs(0)
        
#         # print(ref)
#         return ans

        n = len(s)
        e = [[] for _ in range(n)]
        for i in range(1, n):
            e[parent[i]].append(i)

        M1 = 10 ** 9 + 7
        M2 = 10 ** 9 + 21
        base1 = 1297
        base2 = 1009

        max_len = n + 5
        p1 = [1] * max_len
        p2 = [1] * max_len
        for i in range(1, max_len):
            p1[i] = (p1[i - 1] * base1) % M1
            p2[i] = (p2[i - 1] * base2) % M2

        len_arr = [0] * n
        hash1 = [0] * n
        rev_hash1 = [0] * n
        hash2 = [0] * n
        rev_hash2 = [0] * n

        ans = [False] * n

        def dfs(x):
            len_x = 0
            hash1_x = 0
            hash2_x = 0

            for y in e[x]:
                dfs(y)
                hash1_x = (hash1_x * p1[len_arr[y]] + hash1[y]) % M1
                hash2_x = (hash2_x * p2[len_arr[y]] + hash2[y]) % M2
                len_x += len_arr[y]

            # Append s[x]
            hash1_x = (hash1_x * p1[1] + ord(s[x])) % M1
            hash2_x = (hash2_x * p2[1] + ord(s[x])) % M2
            len_x += 1

            # Now compute reverse hash
            rev_hash1_x = ord(s[x]) % M1
            rev_hash2_x = ord(s[x]) % M2

            # Process children in reverse order
            for y in reversed(e[x]):
                rev_hash1_x = (rev_hash1_x * p1[len_arr[y]] + rev_hash1[y]) % M1
                rev_hash2_x = (rev_hash2_x * p2[len_arr[y]] + rev_hash2[y]) % M2

            len_arr[x] = len_x
            hash1[x] = hash1_x
            hash2[x] = hash2_x
            rev_hash1[x] = rev_hash1_x
            rev_hash2[x] = rev_hash2_x

            if hash1_x == rev_hash1_x and hash2_x == rev_hash2_x:
                ans[x] = True
            else:
                ans[x] = False

        dfs(0)
        return ans",1427964768
Ayanerru,Ayanerru,481,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int mx = *max_element(nums.begin(), nums.end());
        vector<int> dp(mx+ 1, 0);
        for(int i = 1; i <= mx; i++) {
            dp[i] = i;
        }
        
        for(int i = 2; i <= mx; i++) {
            if (dp[i] == i) {
                for(int j = i; j <= mx; j += i) {
                    dp[j] = min(dp[j], i);
                }
            }
        }
        
//         for (int i = mx; i >= 1; --i) {
//             for (int j = 2 * i; j <= mx; j += i) {
//                 if (dp[j] == 0)
//                     dp[j] = i;
//             }
//         }

        int ans = 0;
        int n = nums.size();

        for (int i = n - 2; i >= 0; --i) {
            int cur = nums[i];
            
            while (cur > nums[i + 1]) {
                if (dp[cur] == cur) {
                    return -1;
                }
                cur = dp[cur];
                ans += 1;
                // int div = dp[cur];
                // if (div == 1) {
                //     return -1;
                // }
                // cur /= div;
                // ans += 1;
            }
            nums[i] = cur;
            // cout << nums[i] << endl;
        }

        return ans;
    }
};",1427893180
jam,jam930725,484,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int cnt = 0;
        int len = s.length();
        int th = k;
        char[] cs = s.toCharArray();
        while(k <= len) {
            int[] ocu = new int[123];
            int above = 0;
            for(int i = 0; i+1 < k; i++) {
                ocu[cs[i]] ++;
                if(ocu[cs[i]] == th)
                    above ++;
            }
            for(int i = k-1; i < len; i++) {
                ocu[cs[i]]++;
                if(ocu[cs[i]] == th)
                    above++;
                if(above > 0)
                    cnt++;
                ocu[cs[i-k+1]]--;
                if(ocu[cs[i-k+1]] == th-1)
                    above--;
            }
            k++;
        }
        return cnt;
    }
}",1427852261
jam,jam930725,484,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<> ();
        char[] cs = target.toCharArray();
        for(int i = 0; i < target.length(); i++) {
            if(sb.length() == i) {
                sb.append('a');
                res.add(sb.toString());
            }
            char prev = 'a';
            while(sb.charAt(i) != cs[i]) {
                sb.deleteCharAt(i);
                sb.append(++prev);
                res.add(sb.toString());
            }
        }
        return res;
    }
}",1427825942
jam,jam930725,484,3603,java,"class Solution {
    boolean[] res;
    int N;
    List<Integer>[] chs;
    char[] cs;
    long mul = 37, mod = (long)1e9 + 7;
    long[] pre, suf;
    int[] size;
    boolean[] vis;
    public boolean[] findAnswer(int[] parent, String s) {
        N = parent.length;
        res = new boolean[N];
        chs = new List[N];
        pre = new long[N];
        suf = new long[N];
        vis = new boolean[N];
        size = new int[N];
        cs = s.toCharArray();
        for(int i = 0; i < N; i++) {
            chs[i] = new ArrayList<> ();
        }
        for(int i = 1; i < N; i++) 
            chs[parent[i]].add(i);
        for(int i = 0; i < N; i++) {
            Collections.sort(chs[i]);
        }
        dfs(0);
        return res;
    }

    public void dfs(int ind) {
        if(vis[ind])
            return;
        suf[ind] = cs[ind];
        int sufSz = 0;
        int preSz = -1;
        for(int i = chs[ind].size()-1; i > -1; i--) {
            int ch = chs[ind].get(i);
            dfs(ch);
            sufSz += size[ch];
            suf[ind] *= fp(mul, size[ch]);
            suf[ind] %= mod;
            suf[ind] += suf[ch];
            suf[ind] %= mod;
        }
        for(int i = 0; i < chs[ind].size(); i++) {
            int ch = chs[ind].get(i);
            // preSz += size[ch];
            pre[ind] *= fp(mul, size[ch]);
            pre[ind] %= mod;
            pre[ind] += pre[ch];
            pre[ind] %= mod;
        }
        pre[ind] *= mul;
        pre[ind] += cs[ind];
        pre[ind] %= mod;
        // System.out.println(ind+"" ""+pre[ind]+"" ""+suf[ind]);
        res[ind] = (pre[ind] == suf[ind]);
        size[ind] = sufSz+1;
        vis[ind] = true;
    }

    public long fp(long base, long exp) {
        long res = 1;
        while(exp > 0) {
            if((exp & 1) == 1)
                res = (res * base) % mod;
            base = (base * base) % mod;
            exp >>= 1;
        }
        return res;
    }
}",1427965686
jam,jam930725,484,3607,java,"class Solution {
    int cnt = 0;
    public int minOperations(int[] nums) {
        List<Integer> ps = new ArrayList<> ();
        boolean[] table = new boolean[1000];
        for(int i = 2; i < 1000; i++) {
            if(!table[i]) {
                ps.add(i);
                for(int j = i*i; j < 1000; j += i)
                    table[j] = true;
            }
        }
        int len = nums.length;
        int curMax = 0;
        for(int i = 0; i < len; i++) {
            if(nums[i] < curMax) {
                curMax = nums[i];
                int curMin = curMax;
                for(int j = i-1; j > -1; j--) {
                    if(nums[j] <= curMin)
                        break;
                    while(nums[j] > curMin) {
                        boolean f = true;
                        for(int p: ps) {
                // System.out.println(p);
                            if(nums[j] <= p)
                                break;
                            if(nums[j] % p == 0) {
                                nums[j] = p;
                                cnt++;
                                f = false;
                                break;
                            }
                        }
                        if(f)
                            return -1;
                    }
                    curMin = nums[j];
                }
            }
            curMax = nums[i];
        }
        return cnt;
    }
}",1427894951
JLZ998112,JLZ998112,485,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int[] a = new int[n];
        for(int i=0; i<n; ++i){
            a[i] = s.charAt(i) - 'a';
        }
        int other = atmost(a, k-1);
        int all = n*(n+1)/2;
        return all - other;
    }


    private int atmost(int[] a, int k){
        if(k==0){
            return 0;
        }
        int n = a.length;
        int start = 0;
        Map<Integer,Integer> m = new HashMap<>();
        int res = 0;
        for(int i=0; i<n; i++){
            m.put(a[i], m.getOrDefault(a[i], 0)+1);
            while(bad(m, k)){
                m.put(a[start], m.get(a[start])-1);
                if(m.get(a[start])==0){
                    m.remove(a[start]);
                }
                start++;
            }
            // start...i good, have at most k chars
            res += i-start+1;
        }
        return res;
    }

    private boolean bad(Map<Integer,Integer> m, int k){
        for(int key: m.keySet()){
            if(m.get(key) > k){
                return true;
            }
        }
        return false;
    }
}",1427856807
JLZ998112,JLZ998112,485,3566,java,"class Solution {
    public List<String> stringSequence(String t) {
        int n = t.length();
        List<String> res = new ArrayList<>();
        for(int i=0; i<n; ++i){
            String sub = t.substring(0, i+1);
            char[] subc = sub.toCharArray();
            int sublen = subc.length;
            char last = subc[sublen-1];
            for(char j='a'; j<=last; ++j){
                subc[sublen-1] =  j;
                res.add(new String(subc));
            }
        }
        return res;
    }
}",1427844077
JLZ998112,JLZ998112,485,3603,java,"class Solution {
    private TreeMap<Integer, Set<Integer>> t = new TreeMap<>();
    private class Item{
        long v1;
        long v2;
        long count;
        String str;

        public Item(long v1, long v2, long count, String str) {
            this.v1 = v1;
            this.v2 = v2;
            this.count = count;
            this.str = str;
        }
    }
    private boolean[] res;

    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        res = new boolean[n];
        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                int cp = parent[i];
                t.computeIfAbsent(cp, k -> new TreeSet<>()).add(i);
            }
        }
        dfs(0, s);
        return res;
    }

    // seq1 value, seq value, num of nodes
    private Item dfs(int i, String s) {
        long v1 = 0;
        long c1 = 0;
        long v2 = 0;
        List<Item> rev = new ArrayList<>();
       // String cur = """"+s.charAt(i);
        for (int ne : t.getOrDefault(i, new TreeSet<>())) {
            Item prev = dfs(ne, s);
            v1 = merge(v1, c1, prev.v1);
            c1 += prev.count;
            rev.add(prev);
          //  cur += prev.str;
        }
        int c2 = 0;
        for (int j = rev.size() - 1; j >= 0; --j) {
            v2 = merge(v2, c2, rev.get(j).v2);
            c2 += rev.get(j).count;
        }
        v1 = merge(v1, c1, s.charAt(i) - 'a' + 1);
        v2 = merge(s.charAt(i) - 'a' + 1, 1, v2);
        if (v1 == v2) {
            res[i] = true;
        } else {
            res[i] = false;
        }
        return new Item(v1, v2, c1 + 1, """");
    }

    private long merge(long v1, long len1, long v2) {
        long pow = calcpow(base, len1);
        v2 *= pow;
        v2 %= Mod;
        long v = v1 + v2;
        v %= Mod;
        return v;
    }

    private long calcpow(long base, long p) {
        if (p == 0) {
            return 1L;
        }
        long half = calcpow(base, p / 2);
        long cur = half * half;
        cur %= Mod;
        if (p % 2 == 1) {
            cur *= base;
            cur %= Mod;
        }
        return cur;
    }

    private long base = 31;
    private long Mod = (long) (1e9 + 7);
}",1427966221
JLZ998112,JLZ998112,485,3607,java,"class Solution {
    private static int[] lookup;

    public int minOperations(int[] a) {
        if (lookup == null) {
            lookup = new int[1000000];
            Arrays.fill(lookup, -1);
        }
        int n = a.length;
        int res = 0;
        for (int i = n - 2; i >= 0; --i) {
            int t = a[i + 1];
            int v = a[i];
            while (v > t) {
                int gd = getGreatestProper(v);
                if (gd == 1) {
                    return -1;
                }
                ++res;
                v /= gd;
            }
            a[i] = v;
        }
        return res;
    }

    private int getGreatestProper(int v) {
        if (lookup[v] != -1) {
            return lookup[v];
        }
        int res = 1;
        for (int i = 2; i * i <= v; ++i) {
            if (v % i == 0) {
                int p1 = i;
                int p2 = v / i;
                res = Math.max(res, p2);
                break;
            }
        }
        lookup[v] = res;
        return res;
    }
}",1427873989
Ethan Gu,rtdrtd67,486,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        if (k == 1) {
            return (n * (n+1))/2;
        }
        vector<vector<int>> counts(n, vector<int>(26, 0));
        for (int i = 0; i < n; i++) {
            counts[i][s[i]-'a']++;
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            vector<int> cur_count(26, 0);
            cur_count[s[i]-'a']++;
            int greater = 0;
            if (cur_count[s[i] - 'a'] >= k) {
                greater++;
            }
            for (int j = i+1; j < n; j++) {
                cur_count[s[j]-'a']++;
                if (cur_count[s[j] - 'a'] >= k) {
                    greater++;
                }
                if (greater > 0) {
                    res++;
                }
            }
        }
        return res;
    }
};",1427830440
Ethan Gu,rtdrtd67,486,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res{""a""};
        string cur = ""a"";
        int i = 0;
        while (cur != target) {
            if (cur[i] != target[i]) {
                cur[i] = cur[i] + 1;
            }
            else {
                cur += 'a';
                i++;
            }
            res.push_back(cur);
        }
        return res;
    }
};",1427824477
Ethan Gu,rtdrtd67,486,3603,cpp,"class Solution {
public:
    long long base = 26;
    long long prime = 1190611;
    long long power(long long x, long long y, long long p)
    {

        // Initialize answer
        long long res = 1;

        // Check till the number becomes zero
        while (y > 0) {

            // If y is odd, multiply x with result
            if (y % 2 == 1)
                res = (res * x);
            res %= p;
            // y = y/2
            y = y >> 1;

            // Change x to x^2
            x = (x * x);
            x %= p;
        }
        return res % p;
    }
    
    vector<long long> dfs(vector<vector<int>>& tree, int cur, string& s, vector<bool>& res) {
        vector<vector<long long>> child_hashes;
        for (int child : tree[cur]) {
            child_hashes.push_back(dfs(tree, child, s, res));
        }
        long long pow = 0;
        long long f_hash = 0, b_hash = 0;
        for (vector<long long>& hash : child_hashes) {
            f_hash += (hash[1] * power(base, pow, prime)) % prime;
            pow += hash[0];
        }
        f_hash += ((s[cur] - 'a') * power(base, pow, prime)) % prime;
        b_hash = s[cur] - 'a';
        pow = 1;
        reverse(child_hashes.begin(), child_hashes.end());
        for (vector<long long>& hash : child_hashes) {
            b_hash += (hash[2] * power(base, pow, prime)) % prime;
            pow += hash[0];
        }
        res[cur] = (f_hash % prime) == (b_hash % prime);
        return {pow, f_hash % prime, b_hash % prime};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; i++) {
            tree[parent[i]].push_back(i);
        }
        for (int i = 0; i < n; i++) {
            sort(tree[i].begin(), tree[i].end());
        }
        vector<bool> res(n, false);
        dfs(tree, 0, s, res);
        return res;
    }
};",1427958740
Ethan Gu,rtdrtd67,486,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> nums_copy = nums;
        sort(nums_copy.rbegin(), nums_copy.rend());
        int cur_idx = 0;
        int max_elem = nums_copy[cur_idx];
        int n = nums.size();
        if (n > 10000) {
            vector<bool> sieve(max_elem+1, true);
            vector<int> divisors(max_elem+1, 0);
            for (int p = 2; p * p <= max_elem; p++) {
                if (sieve[p]) {
                    for (int i = p * p; i <= max_elem; i += p) {
                        sieve[i] = false;
                        if (divisors[i] == 0) {
                            divisors[i] = p;
                            if (i == max_elem) {
                                cur_idx++;
                                if (cur_idx < n) {
                                    max_elem = nums_copy[cur_idx];
                                }
                            }
                        }
                    }
                }
            }
            int res = 0;
            for (int i = n-2; i >= 0; i--) {
                if (nums[i] > nums[i+1]) {
                    if (divisors[nums[i]] == 0) {
                        return -1;
                    }
                    nums[i] = divisors[nums[i]];
                    if (nums[i] > nums[i+1]) {
                        return -1;
                    }
                    res++;
                }
            }
            return res;
        }
        int res = 0;
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] > nums[i+1]) {
                for (int div = 2; div*div <= nums[i]; div++) {
                    if (nums[i] % div == 0) {
                        nums[i] = div;
                        break;
                    }
                }
                res++;
                if (nums[i] > nums[i+1]) {
                    return -1;
                }
            }
        }
        return res;
    }
};",1427890720
Akuldeep,akuldeepj,487,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        tol = 0
        if k == 1:
            return (n * (n + 1)) // 2
        for i in range(n):
            freq = [0] * 26  
            kc = 0
            for j in range(i, n):
                ind = ord(s[j]) - ord('a')
                freq[ind] += 1
                if freq[ind] == k:
                    kc += 1
                # elif freq[ind] == k + 1:
                #     kc -= 1
                if kc > 0:
                    tol += 1
                    
        return tol",1427840215
Akuldeep,akuldeepj,487,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        curr = """"
        for i in target:
            curr+='a'
            res.append(curr)
            while curr[-1] != i:
                curr = curr[:-1] + chr(((ord(curr[-1]) - ord('a') + 1) % 26) + ord('a'))
                res.append(curr)
        return res",1427826180
Akuldeep,akuldeepj,487,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[parent[i]].append(i)
        for i in range(n):
            g[i].sort()
        a = [False] * n
        m1 = 10**9 + 7
        m2 = 10**9 + 9
        b1 = 131
        b2 = 13331
        pb1 = [1] * (n+2)
        pb2 = [1] * (n+2)
        for i in range(1, n+2):
            pb1[i] = pb1[i-1] * b1 % m1
            pb2[i] = pb2[i-1] * b2 % m2

        l = [0]*n
        lh1 = [0]*n
        rh1 = [0]*n
        lh2 = [0]*n
        rh2 = [0]*n

        def dfs(u):
            h1 = 0
            h1r = 0
            h2 = 0
            h2r = 0
            tl = 0
            for v in g[u]:
                dfs(v)
                lc = l[v]
                h1c = lh1[v]
                h1rc = rh1[v]
                h2c = lh2[v]
                h2rc = rh2[v]
                h1 = (h1 * pb1[lc] + h1c) % m1
                h2 = (h2 * pb2[lc] + h2c) % m2
                tl += lc

            val = ord(s[u]) - ord('a') + 1
            h1 = (h1 * b1 + val) % m1
            h2 = (h2 * b2 + val) % m2
            tl += 1
            l[u] = tl
            lh1[u] = h1
            lh2[u] = h2

            h1r = val
            h2r = val
            for v in reversed(g[u]):
                lc = l[v]
                h1rc = rh1[v]
                h2rc = rh2[v]
                h1r = (h1r * pb1[lc] + h1rc) % m1
                h2r = (h2r * pb2[lc] + h2rc) % m2

            rh1[u] = h1r
            rh2[u] = h2r

            a[u] = (h1 == h1r and h2 == h2r)

        dfs(0)
        return a",1427892702
Akuldeep,akuldeepj,487,3607,java,"class Solution {
    
    public int minOperations(int[] nums) {
        final int MAX_N = 1_000_001;
        int[] spf = new int[MAX_N];
        computeSPF(spf, MAX_N);
        
        int res = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                if (nums[i] <= 1) {
                    return -1;
                }
                if (spf[nums[i]] == nums[i]) {
                    return -1;
                }
                nums[i] = spf[nums[i]];
                res++;
            }
        }
        return res;
    }
    
    private void computeSPF(int[] spf, int maxN) {
        for (int i = 0; i < maxN; i++) {
            spf[i] = i;
        }
        for (int i = 2; i * i < maxN; i++) {
            if (spf[i] == i) {
                for (int j = i * i; j < maxN; j += i) {
                    if (spf[j] == j) {
                        spf[j] = i;
                    }
                }
            }
        }
    }
}",1427943297
Bhavy,BhavyRamani,488,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), ans = 0;
        for(int i = 0; i < n; i++){
            int fr[26] = {0};
            for(int j = i; j < n; j++){
                if(++fr[s[j]-'a'] >= k){
                    ans += n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427829224
Bhavy,BhavyRamani,488,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v;
        for(int i = 0; i < target.size(); i++){
            string l = """";
            if(v.size())
                l = v.back();
            char c = 'a';
            while(c != target[i]){
                string tmp;
                tmp.push_back(c);
                v.push_back(l + tmp);
                c++;
            }
            string tmp;
            tmp.push_back(c);
            v.push_back(l + tmp);
        }
        return v;
    }
};",1427826420
Bhavy,BhavyRamani,488,3603,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
const int BASE = 31;

    void compute_hashes_and_powers(const string &s, vector<long long> &hash_fwd, vector<long long> &hash_bwd, vector<long long> &power) {
    int n = s.size();
    
    power[0] = 1;
    
    for (int i = 0; i < n; ++i) {
        hash_fwd[i + 1] = (hash_fwd[i] * BASE + (s[i] - 'a' + 1)) % MOD;
        hash_bwd[i + 1] = (hash_bwd[i] * BASE + (s[n - i - 1] - 'a' + 1)) % MOD;
        power[i + 1] = (power[i] * BASE) % MOD;
    }
}
long long get_hash(const vector<long long> &hash, const vector<long long> &power, int l, int r) {
    long long result = (hash[r + 1] - (hash[l] * power[r - l + 1]) % MOD + MOD) % MOD;
    return result;
}
bool is_palindrome(int l, int r, const vector<long long> &hash_fwd, const vector<long long> &hash_bwd, const vector<long long> &power, int n) {
    long long hash_f = get_hash(hash_fwd, power, l, r);
    int rev_l = n - r - 1;
    int rev_r = n - l - 1;
    long long hash_b = get_hash(hash_bwd, power, rev_l, rev_r);
    return hash_f == hash_b;
}
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        vector<int> g[n];
        for(int i = 1; i < n; i++)
            g[parent[i]].push_back(i);
        vector<int> sub(n), pos(n);
        string st;
        function<void(int)> dfs = [&](int ver){
            sub[ver] = 1;
            for(auto &ch:g[ver]){
                dfs(ch);
                sub[ver] += sub[ch];
            }
            pos[ver] = st.size();
            st.push_back(s[ver]);
        };
        dfs(0);
        vector<bool> ans(n);
        vector<long long> hash_fwd(n + 1, 0), hash_bwd(n + 1, 0), power(n + 1, 0);
        compute_hashes_and_powers(st, hash_fwd, hash_bwd, power);
        for(int i = 0; i < n; i++)
            ans[i] = is_palindrome(pos[i]-sub[i]+1, pos[i], hash_fwd, hash_bwd, power, n);
        return ans;
    }
};",1427960251
Bhavy,BhavyRamani,488,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int N = 1e6+10;
        int div[N];
        iota(div, div+N, 0);
        for(int i = 2; i*i < N; i++){
            if(div[i] != i)
                continue;
            for(int j = i*i; j < N; j += i)
                div[j] = min(div[j], i);
        }
        int n = nums.size(), ans = 0;
        for(int i = n-2; i >= 0; i--){
            while(nums[i] > nums[i+1]){
                if(div[nums[i]] == nums[i])
                    return -1;
                nums[i] = div[nums[i]];
                ans++;
            }
        }
        return ans;
    }
};",1427888972
yuchanhsiao,yuchanhsiao,491,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        subs:int = 0
        for ind in range(len(s)):
            freq:dict = {}
            ptr_l = ind
            while ptr_l > -1:
                freq[s[ptr_l]] = freq.get(s[ptr_l], 0) + 1
                if freq[s[ptr_l]] == k:
                    break
                ptr_l -= 1
            subs += ptr_l + 1
        return subs",1427844568
yuchanhsiao,yuchanhsiao,491,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result:list[str] = []
        cur:str = """"
        for t in target:
            temp:str = ""a""
            result.append(cur + temp)
            while temp != t:
                temp = chr(ord(temp) +1)
                result.append(cur + temp)
            cur += temp
        return result",1427829232
yuchanhsiao,yuchanhsiao,491,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        mod = 10**9 + 7
        self.child = {node:[] for node in range(n)}
        for c, p in enumerate(parent[1:]):
            self.child[p].append(c+1)
        self.is_palindrome = [False for _ in range(n)]
        self.base = [1]
        for _ in range(n):
            self.base.append((self.base[-1] * 26) % mod)
        self.dfs(0, s)
        return self.is_palindrome

    def dfs(self, cur_node:int, s:str) -> list:
        mod:int = 10**9 + 7
        cur_str:str = """"
        cur_p_hash:int = 0
        cur_n_hash:int = 0
        for c in self.child[cur_node]:
            c_p_roll, n_p_roll, c_str = self.dfs(c, s)
            cur_p_hash = (cur_p_hash * self.base[len(c_str)] + c_p_roll) % mod
            cur_n_hash = (cur_n_hash + n_p_roll * self.base[len(cur_str)]) % mod
            cur_str += c_str
            
        cur_p_hash = (cur_p_hash*26 + ord(s[cur_node]) - 97) % mod
        cur_n_hash = (cur_n_hash + (ord(s[cur_node])-97) * self.base[len(cur_str)]) % mod
        cur_str += s[cur_node]
        
        self.is_palindrome[cur_node] = cur_p_hash == cur_n_hash
        return [cur_p_hash, cur_n_hash, cur_str]",1427962940
yuchanhsiao,yuchanhsiao,491,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n:int = len(nums)
        gpd:dict = {}
        #print(gpd)
        operations:int = 0
        for ind in range(n-2, -1, -1):
            while nums[ind] > nums[ind+1]:
                if nums[ind] not in gpd:
                    gpd[nums[ind]] = nums[ind]
                    for divisor in range(2, nums[ind]-1):
                        if nums[ind] % divisor == 0:
                            gpd[nums[ind]] = divisor
                            break
                if nums[ind] == gpd[nums[ind]]:
                    return -1
                nums[ind] = gpd[nums[ind]]
                operations += 1
        return operations
",1427886319
Myr,vitomyr,493,3502,rust,"impl Solution {
    pub fn number_of_substrings(s: String, k: i32) -> i32 {
        let s = s.as_bytes();
        let n = s.len();
        let mut result = 0;
        let mut count = vec![0; 26];
        let mut left = 0;

        for right in 0..n {
            count[(s[right] - b'a') as usize] += 1;
            
            while left <= right && count.iter().any(|&c| c >= k) {
                result += n - right;
                count[(s[left] - b'a') as usize] -= 1;
                left += 1;
            }
        }

        result as i32
    }
}",1427926747
Myr,vitomyr,493,3566,rust,"impl Solution {
    pub fn string_sequence(target: String) -> Vec<String> {
        let mut result = Vec::new();
        let mut current_string = String::new();
        let target_chars: Vec<char> = target.chars().collect();

        for (i, &target_char) in target_chars.iter().enumerate() {
            if current_string.len() == i {
                // Press Key 1 to append 'a'
                current_string.push('a');
                result.push(current_string.clone());
            }

            let mut current_char = current_string.chars().nth(i).unwrap();
            // Calculate the number of presses needed to match the target character
            let mut presses = (target_char as u8 + 26 - current_char as u8) % 26;

            while presses > 0 {
                // Press Key 2 to change the last character
                current_char = if current_char == 'z' { 'a' } else { ((current_char as u8) + 1) as char };
                // Update the current string with the new character
                let mut chars: Vec<char> = current_string.chars().collect();
                chars[i] = current_char;
                current_string = chars.iter().collect();
                result.push(current_string.clone());
                presses = presses.saturating_sub(1);
            }
        }

        result
    }
}",1427924675
Myr,vitomyr,493,3603,rust,"impl Solution {
    pub fn find_answer(parent: Vec<i32>, s: String) -> Vec<bool> {
        use std::collections::HashMap;

        const MOD1: u64 = 1_000_000_007;
        const BASE1: u64 = 911;
        const MOD2: u64 = 1_000_000_009;
        const BASE2: u64 = 1597;

        let n = parent.len();

        // Map characters 'a'-'z' to numbers 1-26
        let s_chars: Vec<u64> = s.bytes().map(|b| (b - b'a' + 1) as u64).collect();

        // Build the tree as an adjacency list
        let mut tree = vec![Vec::new(); n];
        for (i, &p) in parent.iter().enumerate().skip(1) {
            tree[p as usize].push(i);
        }

        // Precompute powers for hashing
        let max_len = n + 1;
        let mut pow_base1 = vec![1u64; max_len];
        let mut pow_base2 = vec![1u64; max_len];
        for i in 1..max_len {
            pow_base1[i] = (pow_base1[i - 1] * BASE1) % MOD1;
            pow_base2[i] = (pow_base2[i - 1] * BASE2) % MOD2;
        }

        // Result array
        let mut answer = vec![false; n];

        // Recursive DFS function
        fn dfs(
            node: usize,
            tree: &Vec<Vec<usize>>,
            s_chars: &Vec<u64>,
            pow_base1: &Vec<u64>,
            pow_base2: &Vec<u64>,
            answer: &mut Vec<bool>,
        ) -> (u64, u64, u64, u64, usize) {
            const MOD1: u64 = 1_000_000_007;
            const BASE1: u64 = 911;
            const MOD2: u64 = 1_000_000_009;
            const BASE2: u64 = 1597;

            let mut len = 0usize;

            // Initialize hashes
            let mut hash_fwd1 = 0u64;
            let mut hash_rev1 = 0u64;
            let mut hash_fwd2 = 0u64;
            let mut hash_rev2 = 0u64;

            // Process children in increasing order
            let mut children = tree[node].clone();
            children.sort(); // Ensure children are processed in increasing order

            for &child in &children {
                let (child_fwd1, child_rev1, child_fwd2, child_rev2, child_len) = dfs(
                    child,
                    tree,
                    s_chars,
                    pow_base1,
                    pow_base2,
                    answer,
                );

                // Update forward hashes
                hash_fwd1 = (hash_fwd1 * pow_base1[child_len] + child_fwd1) % MOD1;
                hash_fwd2 = (hash_fwd2 * pow_base2[child_len] + child_fwd2) % MOD2;

                // Update reverse hashes
                hash_rev1 = (child_rev1 * pow_base1[len] + hash_rev1) % MOD1;
                hash_rev2 = (child_rev2 * pow_base2[len] + hash_rev2) % MOD2;

                // Update length
                len += child_len;
            }

            // Incorporate the current node's character
            hash_fwd1 = (hash_fwd1 * BASE1 + s_chars[node]) % MOD1;
            hash_rev1 = (s_chars[node] * pow_base1[len] + hash_rev1) % MOD1;

            hash_fwd2 = (hash_fwd2 * BASE2 + s_chars[node]) % MOD2;
            hash_rev2 = (s_chars[node] * pow_base2[len] + hash_rev2) % MOD2;

            len += 1; // Update the length after adding the current node

            // Check for palindrome
            if hash_fwd1 == hash_rev1 && hash_fwd2 == hash_rev2 {
                answer[node] = true;
            }

            // Return the hashes and length for further computation
            (hash_fwd1, hash_rev1, hash_fwd2, hash_rev2, len)
        }

        // Start DFS traversal from the root node (node 0)
        dfs(
            0,
            &tree,
            &s_chars,
            &pow_base1,
            &pow_base2,
            &mut answer,
        );

        answer
    }
}",1427966136
Myr,vitomyr,493,3607,rust,"impl Solution {
    pub fn min_operations(nums: Vec<i32>) -> i32 {
        use std::collections::HashSet;

        let n = nums.len();
        let mut nums = nums;
        let mut total_operations = 0;

        // Precompute small primes up to 1e5
        let max_prime = 100_000;
        let primes = Self::sieve_of_eratosthenes(max_prime);

        for i in (0..n - 1).rev() {
            let mut operations = 0;
            while nums[i] > nums[i + 1] {
                if nums[i] == 1 {
                    // Cannot reduce further
                    return -1;
                }

                let gpd = Self::greatest_proper_divisor(nums[i] as i64, &primes);
                if gpd == 1 {
                    // Cannot reduce further
                    return -1;
                }
                nums[i] = (nums[i] as i64 / gpd) as i32;
                operations += 1;
            }
            total_operations += operations;
        }

        total_operations
    }

    // Sieve of Eratosthenes to generate small primes
    fn sieve_of_eratosthenes(limit: usize) -> Vec<i64> {
        let mut is_prime = vec![true; limit + 1];
        is_prime[0] = false;
        is_prime[1] = false;
        for i in 2..=limit {
            if is_prime[i] {
                let mut multiple = i * 2;
                while multiple <= limit {
                    is_prime[multiple] = false;
                    multiple += i;
                }
            }
        }
        is_prime
            .iter()
            .enumerate()
            .filter(|&(_, &val)| val)
            .map(|(i, _)| i as i64)
            .collect()
    }

    // Compute the greatest proper divisor of n
    fn greatest_proper_divisor(n: i64, primes: &Vec<i64>) -> i64 {
        for &p in primes {
            if p * p > n {
                break;
            }
            if n % p == 0 {
                return n / p;
            }
        }
        // Check if n is prime
        if Self::is_prime(n) {
            1 // Cannot reduce further
        } else {
            // n is composite but has a large prime factor
            // Try dividing by this factor
            let factor = Self::pollards_rho(n);
            if factor == n {
                1 // Cannot reduce further
            } else {
                n / factor
            }
        }
    }

    // Miller-Rabin primality test
    fn is_prime(n: i64) -> bool {
        if n <= 1 {
            return false;
        }
        if n <= 3 {
            return true;
        }
        if n % 2 == 0 {
            return false;
        }

        let d = (n - 1) >> (n - 1).trailing_zeros();
        let bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];

        for &a in bases.iter() {
            if a >= n {
                break;
            }
            if !Self::miller_rabin_test(n, d, a) {
                return false;
            }
        }

        true
    }

    fn miller_rabin_test(n: i64, d: i64, a: i64) -> bool {
        let mut x = Self::modular_pow(a, d, n);
        if x == 1 || x == n - 1 {
            return true;
        }
        let mut d = d;
        while d != n - 1 {
            x = (x * x) % n;
            d <<= 1;
            if x == n - 1 {
                return true;
            }
        }
        false
    }

    fn modular_pow(mut base: i64, mut exponent: i64, modulus: i64) -> i64 {
        let mut result = 1;
        base = base % modulus;
        while exponent > 0 {
            if exponent % 2 == 1 {
                result = result * base % modulus;
            }
            exponent >>= 1;
            base = base * base % modulus;
        }
        result
    }

    // Pollard's Rho algorithm for factorization
    fn pollards_rho(n: i64) -> i64 {
        if n % 2 == 0 {
            return 2;
        }
        let mut x = 2;
        let mut y = 2;
        let mut d = 1;
        let f = |x: i64| (x * x + 1) % n;
        while d == 1 {
            x = f(x);
            y = f(f(y));
            d = Self::gcd((x - y).abs(), n);
        }
        if d == n {
            n
        } else {
            d
        }
    }

    fn gcd(mut a: i64, mut b: i64) -> i64 {
        while b != 0 {
            let t = b;
            b = a % b;
            a = t;
        }
        a.abs()
    }
}",1427935952
Vladislav,timetoai,494,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c = Counter()
        l = ret = 0
        for r in range(len(s)):
            c[s[r]] += 1
            if c[s[r]] == k:
                ret += len(s) - r
                while s[l] != s[r]:
                    c[s[l]] -= 1
                    l += 1
                    ret += len(s) - r
                c[s[l]] -= 1
                l += 1
        return ret",1427830108
Vladislav,timetoai,494,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ret = []
        for i in range(len(target)):
            cur = ret[- 1] if ret else """"
            for ch in range(ord('a'), ord(target[i]) + 1):
                ret.append(cur + chr(ch))
        return ret",1427824604
Vladislav,timetoai,494,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        childs = [[] for _ in range(n)]
        for ch, par in enumerate(parent):
            if par == - 1: continue
            childs[par].append(ch)
        ans = [False] * n
        mod = 10 ** 9 + 7
        base = 31
        
        def go(i):
            if not childs[i]:
                ans[i] = True
                return ord(s[i]) - ord('a') + 1, ord(s[i]) - ord('a') + 1, 1
            cur = []
            tot = 0
            for ch in childs[i]:
                cur.append(go(ch))
                tot += cur[- 1][2]
            cur.append([ord(s[i]) - ord('a') + 1, ord(s[i]) - ord('a') + 1, 1])
            tot += 1
            forw, rev = 0, 0
            for f, _, c in cur:
                forw = (forw * pow(base, c, mod) % mod + f) % mod
            for _, r, c in cur[:: - 1]:
                rev = (rev * pow(base, c, mod) % mod + r) % mod
            ans[i] = forw == rev
            return forw, rev, tot
        
        go(0)
        return ans
        ",1427957635
Vladislav,timetoai,494,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ret = 0
        prv = inf
        for i in range(len(nums) - 1, - 1, - 1):
            if nums[i] > prv:
                div = 2
                sqrt = ceil(nums[i] ** 0.5) + 1
                while div < sqrt and nums[i] % div > 0:
                    div += 1
                if nums[i] % div > 0 or div > prv:
                    return - 1
                ret += 1
                prv = div
            else:
                prv = nums[i]
        return ret
        ",1427862947
Atul,coderchamp07,496,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        
        int ans = (1ll * n * (n + 1)) / 2;
        
        vector<int> f(26, 0);
        int l = 0;
        for(int r = 0; r < n; r++) {
            f[s[r] - 'a']++;
            while(f[s[r] - 'a'] >= k)
                f[s[l++] - 'a']--;
            
            ans -= r - l + 1;
        }
        return ans;
    }
};",1427834119
Atul,coderchamp07,496,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> out;
        string cur = """";
        while(cur != target) {
            if(cur.size() == 0 || cur.back() == target[cur.size() - 1])
                cur.push_back('a');
            else
                cur[cur.size() - 1]++;
            out.push_back(cur);
        }
        return out;
    }
};",1427825552
Atul,coderchamp07,496,3603,python,"class Solution:
    MOD = 10**9 + 7
    P = 31

    def __init__(self):
        self.g = []
        self.POW = []
        self.out = []
        self.dp = []
        self.s = """"

    def dfs(self, node, parent):
        if self.dp[node][0] != -1:
            return self.dp[node]

        forward = 0
        flen = 0
        for child in self.g[node]:
            if child == parent:
                continue
            child_res = self.dfs(child, node)
            forward = (forward + (child_res[1][0] * self.POW[flen]) % self.MOD) % self.MOD
            flen += child_res[0]
        forward = (forward + ((ord(self.s[node]) - ord('a') + 1) * self.POW[flen]) % self.MOD) % self.MOD
        flen += 1

        
        backward = (ord(self.s[node]) - ord('a') + 1) % self.MOD
        blen = 1
        for child in reversed(self.g[node]):
            if child == parent:
                continue
            child_res = self.dfs(child, node)
            backward = (backward + (child_res[1][1] * self.POW[blen]) % self.MOD) % self.MOD
            blen += child_res[0]
        self.out[node] = (forward == backward)

        self.dp[node] = (flen, (forward, backward))
        return self.dp[node]

    def findAnswer(self, parent, S):
        n = len(parent)
        self.s = S

        self.g = [[] for _ in range(n)]
        self.POW = [1] * n
        self.out = [False] * n
        self.dp = [(-1, (-1, -1)) for _ in range(n)]

        for i in range(1, n):
            self.g[i].append(parent[i])
            self.g[parent[i]].append(i)
            self.POW[i] = (self.POW[i - 1] * self.P) % self.MOD

        for i in range(n):
            self.g[i].sort()

        self.dfs(0, -1)
        return self.out
",1427942221
Atul,coderchamp07,496,3607,cpp,"class Solution {
    int largestDivisor(int n) {
        for(int i = 2; i <= sqrt(n); i++) {
            if(n % i == 0)
                return n / i;
        }
        return 1;
    }
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        for(int i = n - 2; i >= 0; i--) {
            while(nums[i] > nums[i + 1]) {
                int div = largestDivisor(nums[i]);
                if(div == 1)
                    return -1;
                nums[i] /= div;
                ans++;
            }
        }
        return ans;
    }
};",1427842545
malcom8689,malcom8689,497,3502,cpp,"
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int totalSubstrings = 0;

        // Sliding window approach
        for (int i = 0; i < n; ++i) {
            unordered_map<char, int> freqMap;
            for (int j = i; j < n; ++j) {
                // Update frequency of the current character
                freqMap[s[j]]++;

                // Check if any character in the current substring appears at least k times
                bool valid = false;
                for (auto &entry : freqMap) {
                    if (entry.second >= k) {
                        valid = true;
                        break;
                    }
                }

                if (valid) {
                    totalSubstrings++;
                }
            }
        }

        return totalSubstrings;
    }
};",1427831182
malcom8689,malcom8689,497,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";

        for (char ch : target) {
            if (current.empty()) {
                current += 'a';
                result.push_back(current);
            }

            // Ensure current matches ch, adding key presses
            while (current.back() != ch) {
                if (current.back() < ch) {
                    current.back()++; // Increment last character using Key 2
                } else {
                    current.back() = 'a'; // Wrap around if necessary
                }
                result.push_back(current);
            }

            // If more characters are needed, use Key 1
            if (current.size() < target.size()) {
                current += 'a';
                result.push_back(current);
            }
        }

        return result;
    }
};
",1427824459
malcom8689,malcom8689,497,3603,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    long long multiply(long long a, long long b, long long mod) {
        long long result = 0;
        a %= mod;
        while (b > 0) {
            if (b % 2 == 1) result = (result + a) % mod;
            a = (a * 2) % mod;
            b /= 2;
        }
        return result;
    }

    vector<bool> findAnswer(vector<int>& parent_tree, string node_string) {
        int n = parent_tree.size();
        vector<vector<int>> children_tree(n);
        for (int i = 1; i < n; i++) children_tree[parent_tree[i]].push_back(i);

        long long base1 = 911382628, mod1 = 1000000000000000007;
        long long base2 = 3571, mod2 = 1000000000000000009;
        int max_len = n + 1;
        vector<long long> pow1(max_len, 1), pow2(max_len, 1);
        for (int i = 1; i < max_len; i++) {
            pow1[i] = multiply(pow1[i - 1], base1, mod1);
            pow2[i] = multiply(pow2[i - 1], base2, mod2);
        }

        vector<long long> f_hash1(n, 0), r_hash1(n, 0), f_hash2(n, 0), r_hash2(n, 0);
        vector<int> subtree_len(n, 1), in_degree(n, 0);
        for (int i = 0; i < n; i++) in_degree[i] = children_tree[i].size();

        queue<int> bfs;
        for (int i = 0; i < n; i++) if (in_degree[i] == 0) bfs.push(i);

        while (!bfs.empty()) {
            int curr = bfs.front(); bfs.pop();

            long long combined1 = 0;
            for (int child : children_tree[curr]) {
                combined1 = (multiply(combined1, pow1[subtree_len[child]], mod1) + f_hash1[child]) % mod1;
            }
            combined1 = (multiply(combined1, base1, mod1) + (node_string[curr] - 'a' + 1)) % mod1;
            f_hash1[curr] = combined1;

            long long combined_r1 = (node_string[curr] - 'a' + 1);
            for (int j = children_tree[curr].size() - 1; j >= 0; j--) {
                int child = children_tree[curr][j];
                combined_r1 = (multiply(combined_r1, pow1[subtree_len[child]], mod1) + r_hash1[child]) % mod1;
            }
            r_hash1[curr] = combined_r1;

            long long combined2 = 0;
            for (int child : children_tree[curr]) {
                combined2 = (multiply(combined2, pow2[subtree_len[child]], mod2) + f_hash2[child]) % mod2;
            }
            combined2 = (multiply(combined2, base2, mod2) + (node_string[curr] - 'a' + 1)) % mod2;
            f_hash2[curr] = combined2;

            long long combined_r2 = (node_string[curr] - 'a' + 1);
            for (int j = children_tree[curr].size() - 1; j >= 0; j--) {
                int child = children_tree[curr][j];
                combined_r2 = (multiply(combined_r2, pow2[subtree_len[child]], mod2) + r_hash2[child]) % mod2;
            }
            r_hash2[curr] = combined_r2;

            int total_len = 1;
            for (int child : children_tree[curr]) total_len += subtree_len[child];
            subtree_len[curr] = total_len;

            if (curr != 0) {
                int parent = parent_tree[curr];
                in_degree[parent]--;
                if (in_degree[parent] == 0) bfs.push(parent);
            }
        }

        vector<bool> result(n);
        for (int i = 0; i < n; i++) {
            result[i] = (f_hash1[i] == r_hash1[i]) && (f_hash2[i] == r_hash2[i]);
        }
        return result;
    }
};
",1427961312
malcom8689,malcom8689,497,3607,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ops = 0;

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                int current = nums[i];

                while (current > nums[i + 1]) {
                    int divisor = findLargestProperDivisor(current);
                    if (divisor == 1) {
                        return -1;
                    }
                    current /= divisor;
                    ops++;
                }
                nums[i] = current;
            }
        }

        return ops;
    }

    int findLargestProperDivisor(int x) {
    for (int i = 2; i <= sqrt(x); ++i) {
        if (x % i == 0) {
            return x / i;
        }
    }
    return 1;
}

};
",1427888784
viking72,viking72,498,3502,cpp,"class Solution {
public:
    void solve(int index,string &s,int k,map<char,int> &m1,int &count){
        if(index==s.length()){
            return ;
        }
        for(int i=index;i<s.length();i++){
            m1[s[i]]++;
            if(m1[s[i]]>=k){
                count++;
            }else{
                solve(i+1,s,k,m1,count);
            } 
            m1[s[i]]--;
            solve(i+1,s,k,m1,count);
        }
    }
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int answer = 0;
        for(int i=0;i<0;i+=100);

    for (int st = 0; st < n; ++st) {
            map<char, int>m;
            if(true){
                int kk=0;
            }
            for (int end = st; end < n; ++end) {
                m[s[end]]++; 
                for (auto entry : m) {
                    if (entry.second >= k) {
                        answer++;
                        if(false){
                            int kk=0;
                        }
                        break;
                    }
                }
            }
        }
        if(true){
            answer--;
        }
        answer++;
        return answer;
    }
};",1427925086
viking72,viking72,498,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string res="""";
        int count=0;
        for(int i=0;i<target.length();i++){
            res=res+'a';
            while(res[res.length()-1]!=target[i] ){
                ans.push_back(res);
                res[res.length()-1]++;count++;
            }
            ans.push_back(res);
            
        }
        return ans;
    }
};",1427832424
viking72,viking72,498,3603,cpp,"#define ll long long
#define vll vector<ll>
#define fr(j, k) for(int i=j; i<k; i++)
#define rf(j, k) for(int i=j; i>=k; i--)
typedef double dd;
class Solution {
public:
    ll pw = 31, mod =1e9;
    vll ddffss(ll node, vector<vll>& adj, vll& power, vector<bool>& ans, string& s){
        vll fwd1, revolt, sz;
        for(int i=0;i<100;i+=100);
        if(true){
            int lambda=0;
        }
        for(auto &it: adj[node]){
            vll val = ddffss(it, adj, power, ans, s);
            if(false){
                int lambda=0;
            }
            revolt.push_back(val[1]);
            fwd1.push_back(val[0]);
            sz.push_back(val[2]);
        }
        revolt.push_back(s[node] +1 - 'a');
        fwd1.push_back(s[node]+ 1 - 'a' );
        if(true){
            sz.push_back(1);
        }
        if(false){
            int viking=100;
        }
        ll fwdHa = 0;
        ll prev = 0;
        ll number = fwd1.size();
        if(true){
            number++;
        }
        number--;
        fr(0, number){
            fwdHa = (fwdHa + (power[prev] * fwd1[i]) % mod) % mod;
            prev += sz[i];
        }
        ll revHa = 0;
        prev = 0;
        rf(number-1, 0){
            revHa = (revHa + ((power[prev]%mod) * (revolt[i])%mod) % mod) % mod;
            if(true)prev += sz[i];
        }
        if(fwdHa == revHa) ans[node] = true;
        return {fwdHa, revHa, prev};
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        ll no = s.size();
        for(int i=0;i<=10;i+=100);
        vector<bool> ans(no, false);
        vll powerrr(no+1, 1);
        vector<vll> adjoint(no);
        if(true){
            bool viking =true;
        }
        fr(1, no+1){
            for(int llll=0;llll<9;llll+=9);
            powerrr[i] = (pw * powerrr[i-1]) % mod;
        }
        fr(0, no){
            if(true){
                if(parent[i] != -1)
                adjoint[parent[i]].push_back(i);
            }
            
        }
        ddffss(0, adjoint, powerrr, ans, s);
        return ans;
    }
};",1427953691
viking72,viking72,498,3607,cpp,"class Solution {
public:
    
    int minOperations(vector<int>& nums) {
        int count=0;
        for(int i=nums.size()-1;i>=1;i--){
            if(nums[i]<nums[i-1]){
                int n=nums[i-1];
                int sqr=sqrt(n);
                
                cout<<i<<"" ""<<n<<"" ""<<sqr<<endl;
                int chk=0;
                for(int j=2;j<=sqr;j++){
                    if(n%j==0){
                        cout<<""divisibel by=""<<j<<endl;
                        nums[i-1]=j;
                        chk++;
                        break;
                    }
                }
                if(chk)count++;
            }
            
        }
        int chk=0;
        // for(int i=0;i<nums.size();i++){
        //     cout<<nums[i]<<"" "";
        // }
        for(int i=1;i<nums.size();i++){
            if(nums[i]<nums[i-1]){
                return -1;
            }
        }
        return count;
    }
};",1427914458
kunzaZa183,kunzaZa183,499,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ct = 0;
        for(int i = 0; i < s.size(); i++) {
            string cur;
            map<char, int> mci;
            int morethan = 0;
            for(int j = i; j < s.size(); j++) {
                cur.push_back(s[j]);
                mci[s[j]]++;
                if(mci[s[j]] == k) {
                    morethan = 1;
                }
                if(morethan == 1) {
                    ct++;
                }
            }
        }
        return ct;
    }
};",1427840686
kunzaZa183,kunzaZa183,499,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = target;
        string cur;
        vector<string> vs;
        for(int i =0; i < s.size();i++) {
            cur.push_back('a');
            vs.push_back(cur);

            while(cur.back() != s[i]) {
                cur.back()++;
                vs.push_back(cur);
            }
        }
        return vs;
    }
};",1427836518
kunzaZa183,kunzaZa183,499,3603,cpp,"class Solution {
public:
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector<vector<int>> adjlist(parent.size(), vector<int>());
        for(int i = 1; i < parent.size(); i++) {
            adjlist[parent[i]].push_back(i);
        }
        
        for(int i = 0 ; i < parent.size(); i++) {
            sort(adjlist[i].begin(), adjlist[i].end());
        }
        
        const long long B = 10073,M = 2e9 + 9;
        
        vector<long long> powlog(parent.size() + 1);
        
        powlog[0] = 1;
        for(int i = 1; i < powlog.size();i++)
            powlog[i] = powlog[i-1] * B % M;
        
        vector<bool> ans(parent.size());
        vector<int> sz;
        
        struct kun {
            int sz;
            long long normal,rev;
        };
        
        function<kun(int, int)> fvii = [&](int cur,int par) {
            kun ret;
            ret.sz = 1;
            ret.normal = 0, ret.rev = 0;
            
            vector<kun> vk;
            
            int curz = 0;
            for(auto a:adjlist[cur]) {
                if(a!=par) {
                    kun tmp = fvii(a,cur);
                    vk.push_back(tmp);
                    
                    ret.normal += tmp.normal * powlog[curz] % M;
                    ret.normal %= M;
                    
                    curz += tmp.sz;
                            
                    ret.sz += tmp.sz;
                }
            }
            ret.normal += (s[cur] - 'a' + 1) * powlog[curz];
            ret.normal %= M;
            
            curz = 1;
            ret.rev = (s[cur] - 'a' + 1);
            reverse(vk.begin(), vk.end());
            for(auto a:vk) {
                ret.rev += a.rev * powlog[curz] % M;
                ret.rev %= M;
                
                curz += a.sz;
            }
            
            ans[cur] = ret.normal == ret.rev;
            
            // if(cur==13) {
            //     for(auto a:vk)
            //         cout<<a.normal<<"" ""<<a.rev<<""\n"";
            //     cout<<ret.normal<<"" ""<<ret.rev<<""\n"";
            // }
            
            return ret;
        };
        
        fvii(0,0);
        
        return ans;
    }
};",1427931179
kunzaZa183,kunzaZa183,499,3607,cpp,"class Solution {

public:
    
    int sieve[1000001];
    bool first = true;
    
    void init() {
        
        memset(sieve, -1, sizeof sieve);
        
        int ops = 0;
        
        for(int i = 2; i <= 1e3; i++) {
            if(sieve[i] == -1) {
                sieve[i] = i;
                for(int j = i*i; j <= 1e6; j+=i) {
                    if(sieve[j] == -1)
                        sieve[j] = i;
                    ops++;
                }
            }
        }
    }
    
    int minOperations(vector<int>& nums) {
        if(first)
        {
            init();
            first = false;
        }
        
        int ct = 0;
        
        for(int i = nums.size() - 1; i >= 1;i--) {
            if(nums[i - 1] > nums[i]) {
                ct++;
                nums[i - 1] = sieve[nums[i - 1]];
                if(nums[i - 1] > nums[i])
                    return -1;
                if(nums[i-1] == -1)
                    return -1;
            }
        }
        
        return ct;
    }
};",1427874953
ptato_god,ptato_god,500,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        d = defaultdict(int)
        l = 0
        out = 0
        for r, x in enumerate(s):
            d[x] += 1
            if d[x] == k:
                while d[x] == k:
                    out += len(s) - r
                    d[s[l]] -= 1
                    l += 1
                
        return out",1427885777
ptato_god,ptato_god,500,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        out = []
        s = """"
        for c in target:
            for x in range(ord(""a""), ord(c) + 1):
                out.append(s + chr(x))
            s += c
        return out
                
            ",1427844583
ptato_god,ptato_god,500,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        children = defaultdict(list)
        basement = [0] * n
        for i, x in enumerate(parent):
            if x > -1:
                children[x].append(i)
                basement[x] += 1
        
        dfs = [""""] * n
        rev = list(s)
        out = [False] * n
        
        stack = []
        for i, x in enumerate(basement):
            if x == 0:
                stack.append(i)
        
        while stack:
            i = stack.pop()
            for child in children[i]:
                dfs[i] += dfs[child]
                dfs[child] = """"
            for child in children[i][::-1]:
                rev[i] += rev[child]
                rev[child] = """"
            dfs[i] += s[i]
            out[i] = dfs[i] == rev[i]
            
            if parent[i] > -1:
                basement[parent[i]] -= 1
                if basement[parent[i]] == 0:
                    stack.append(parent[i])
        
        return out
                ",1427942477
ptato_god,ptato_god,500,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        
        out = 0
        prev = nums[-1]
        for x in nums[::-1][1:]:
            if x > prev:
                found = False
                for z in range(2, min(floor(pow(x, 0.5)) + 1, prev + 1)):
                    if x % z == 0:
                        prev = z
                        out += 1
                        found = True
                        break
                
                if not found:
                    return -1
            else:
                prev = x
        return out
            
                
                
            ",1427899755
sarthak singh,baburaoo_ganpatraoo_apte,501,3502,cpp,"#include <unordered_map>
#include <string>

class Solution {
public:
    int numberOfSubstrings(std::string inputStr, int minFrequency) {
        return logic(inputStr, minFrequency);
    }

    int logic(const std::string& inputStr, int minFrequency) {
        int validSubstringCount = 0;
        int strLength = inputStr.size();

        for (int startIndex = 0; startIndex < strLength; ++startIndex) {
            std::unordered_map<char, int> characterCount;
            int endIndex = startIndex;

            do {
                characterCount[inputStr[endIndex]]++;

                bool meetsCriteria = false;
                for (const auto &charEntry : characterCount) {
                    if (charEntry.second >= minFrequency) {
                        meetsCriteria = true;
                        break;
                    }
                }

                if (meetsCriteria) {
                    validSubstringCount++;
                }

                endIndex++;
            } while (endIndex < strLength);
        }

        return validSubstringCount;
    }
};
",1427859172
sarthak singh,baburaoo_ganpatraoo_apte,501,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        char lastChar = 'a';
        
        for (char c : target) {
            current += lastChar;
            result.push_back(current);
            while (lastChar != c) {
                lastChar = lastChar == 'z' ? 'a' : lastChar + 1;
                current.back() = lastChar;
                result.push_back(current);
            }
            lastChar = 'a';  
        }
        return result;
    }
};
",1427824354
sarthak singh,baburaoo_ganpatraoo_apte,501,3603,cpp,"
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int totalNodes = parent.size();
        vector<bool> output(totalNodes, false);
        
        vector<vector<int>> adjList(totalNodes);
        for (int idx = 1; idx < totalNodes; idx++) {
            adjList[parent[idx]].push_back(idx);
        }

        const long long primeBase = 911;
        const long long modValue = 1000000007;

        vector<long long> primePowers(totalNodes + 2, 1);
        for (int exp = 1; exp <= totalNodes + 1; exp++) {
            primePowers[exp] = (primePowers[exp - 1] * primeBase) % modValue;
        }

        vector<int> traversalOrder;
        vector<bool> visited(totalNodes, false);
        stack<int> traversalStack;
        traversalStack.push(0);

        do {
            if (!traversalStack.empty()) {
                int node = traversalStack.top();
                if (!visited[node]) {
                    visited[node] = true;
                    for (int i = adjList[node].size() - 1; i >= 0; i--) {
                        traversalStack.push(adjList[node][i]);
                    }
                } else {
                    traversalStack.pop();
                    traversalOrder.push_back(node);
                }
            }
        } while (!traversalStack.empty());

        vector<int> nodeLengths(totalNodes, 0);
        vector<long long> hashForward(totalNodes, 0);
        vector<long long> hashBackward(totalNodes, 0);

        for (int node : traversalOrder) {
            nodeLengths[node] = 1;

            long long forwardHash = 0;
            for (int child : adjList[node]) {
                forwardHash = (forwardHash * primePowers[nodeLengths[child]] + hashForward[child]) % modValue;
                nodeLengths[node] += nodeLengths[child];
            }
            forwardHash = (forwardHash * primeBase + (s[node] - 'a' + 1)) % modValue;
            hashForward[node] = forwardHash;

            long long backwardHash = (s[node] - 'a' + 1);
            for (int i = adjList[node].size() - 1; i >= 0; i--) {
                int child = adjList[node][i];
                backwardHash = (backwardHash * primePowers[nodeLengths[child]] + hashBackward[child]) % modValue;
            }
            hashBackward[node] = backwardHash;

            output[node] = (hashForward[node] == hashBackward[node]);
        }

        return output;
    }
};
",1427942689
sarthak singh,baburaoo_ganpatraoo_apte,501,3607,cpp,"#include <vector>
using namespace std;

const int SARTHAK_MAX_N = 1000001;

vector<bool> sarthakSieveIsPrime(SARTHAK_MAX_N, 1);
vector<int> sarthakLP(SARTHAK_MAX_N, 0); 

void sarthakSieveInit(int sarthakLimit) {
    sarthakSieveIsPrime[0] = sarthakSieveIsPrime[1] = 0;
    for (int sarthakI = 2; sarthakI < sarthakLimit; sarthakI++) {
        if(sarthakSieveIsPrime[sarthakI]) {
            sarthakLP[sarthakI] = sarthakI;
            for (int sarthakJ = 2 * sarthakI; sarthakJ < sarthakLimit; sarthakJ += sarthakI) {
                sarthakSieveIsPrime[sarthakJ] = 0;

                if(sarthakLP[sarthakJ] == 0) {
                    sarthakLP[sarthakJ] = sarthakI;
                }
            }
        }
    }
}

class Solution {
public:
    Solution() {
        sarthakAlgoInit();  
    }

    int minOperations(vector<int>& sarthakNums) {
        return sarthakAlgo(sarthakNums);  
    }

    void sarthakAlgoInit() {
        if(sarthakLP[10] == 0) {
            sarthakSieveInit(SARTHAK_MAX_N);
        }
    }

    int sarthakAlgo(vector<int>& sarthakNums) {
        int sarthakRes = 0, sarthakN = sarthakNums.size();
        int sarthakPrev = sarthakNums[sarthakN - 1];

        for (int sarthakI = sarthakN - 2; sarthakI >= 0; sarthakI--) {
            if(sarthakNums[sarthakI] <= sarthakPrev) {
                sarthakPrev = sarthakNums[sarthakI];
                continue;
            }
            while(sarthakLP[sarthakNums[sarthakI]] > 1 && sarthakNums[sarthakI] / sarthakLP[sarthakNums[sarthakI]] > 1 && sarthakNums[sarthakI] > sarthakPrev) {
                sarthakNums[sarthakI] /= (sarthakNums[sarthakI] / sarthakLP[sarthakNums[sarthakI]]);
                sarthakRes++;
            }
            if(sarthakNums[sarthakI] > sarthakPrev) {
                return -1;
            }
            sarthakPrev = sarthakNums[sarthakI];
        }
        return sarthakRes;
    }
};
",1427888271
Kode4Fun,Kode4Fun,502,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        mp = [{} for _ in range(n + 1)]
        for i in range(1, n + 1):
            c = s[i - 1]
            mp[i] = mp[i - 1].copy()
            mp[i][c] = mp[i].get(c, 0) + 1
        
        def check(mid, i):
            flag = False
            for c in mp[i]:
                if mp[i][c] - mp[mid - 1].get(c, 0) >= k:
                    flag = True
                    continue
                
            return flag
        
        ret = 0
        for i in range(1, n + 1):
            l = 0
            r = i
            while l < r:
                mid = (l + r + 1) // 2
                if check(mid, i):
                    l = mid
                else:
                    r = mid - 1
            ret += l
                    
                    
        
        return ret",1427852237
Kode4Fun,Kode4Fun,502,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ret = []
        while True:

            
            if len(ret) == 0:
                ret.append(""a"")
                continue
                
            if ret[-1] == target:
                return ret
            
            if len(ret) >= 1 and ret[-1][-1] == target[len(ret[-1]) - 1]:
                ret.append(ret[-1] + ""a"")
                continue
            if len(ret) >= 1 and ret[-1][-1] != target[len(ret[-1]) - 1]:
                l = len(ret[-1])
                c = chr(ord(ret[-1][-1]) + 1)
                
                ret.append(ret[-1][:l - 1] + c)
        
            
        return []
            ",1427826482
Kode4Fun,Kode4Fun,502,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:

        n = len(parent)
        ret = [False for _ in range(n)]
        P = 911382629
        MOD = 10**18 + 3

        # Precompute powers of P
        power = [1] * (n + 1)
        for i in range(1, n + 1):
            power[i] = (power[i - 1] * P) % MOD

        forward_hash = [0] * n
        reverse_hash = [0] * n
        length = [0] * n
        ret = [False] * n

        def dfs(x):
            nonlocal forward_hash, reverse_hash, length, ret
            current_forward = 0
            current_length = 0
            for child in graph[x]:
                dfs(child)
                current_forward = (current_forward * power[length[child]] + forward_hash[child]) % MOD
                current_length += length[child]
            current_forward = (current_forward * P + ord(s[x])) % MOD
            forward_hash[x] = current_forward
            length[x] = current_length + 1

            current_reverse = ord(s[x])
            current_length_rev = 1
            for child in sorted(graph[x], reverse=True):
                current_reverse = (current_reverse * power[length[child]] + reverse_hash[child]) % MOD
                current_length_rev += length[child]
            reverse_hash[x] = current_reverse

            if forward_hash[x] == reverse_hash[x]:
                ret[x] = True
            else:
                ret[x] = False
        
        
        graph = [[] for _ in range(n)]
        root = -1
        for i in range(n):
            if parent[i] == -1:
                root = i
                continue
            graph[parent[i]].append(i)

        
        
        dfs(root)
        
        return ret
            
        ",1427930408
Kode4Fun,Kode4Fun,502,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0

        N = int(sqrt(max(nums) + 1) + 1)
        primes = []
        st = [False for _ in range(N)]
        for i in range(2, N, 1):
            if not st[i]:
                primes.append(i)
            j = i + i
            while j < N:
                st[j] = True
                j += i

        n = len(nums)
        ret = 0
        for i in range(n - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                for p in primes:
                    if nums[i] % p == 0:
                        nums[i] = p
                        ret += 1
                        break
                    if p * p > nums[i] or p > nums[i + 1]:
                        break
                if nums[i] > nums[i + 1]:
                    return -1
        
        return ret
                ",1427881152
QsYX4ZRmCa,QsYX4ZRmCa,504,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
          int n = s.length(), result = 0;
        for (int i = 0; i < n; i++) {
            unordered_map<char, int> freq;
            for (int j = i; j < n; j++) {
                freq[s[j]]++;
                for (auto& f : freq) {
                    if (f.second >= k) {
                        result++;
                        break;
                    }
                }
            }
        }
        return result;
    }
};",1427829844
QsYX4ZRmCa,QsYX4ZRmCa,504,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        char prev = 'a';

        for (char c : target) {
            current.push_back('a');
            result.push_back(current);

            int presses = (c - 'a' + 26) % 26;

            for (int i = 0; i < presses; i++) {
                current.back() = (current.back() == 'z') ? 'a' : current.back() + 1;
                result.push_back(current);
            }

            prev = c;
        }

        return result;
    }
};",1427832881
QsYX4ZRmCa,QsYX4ZRmCa,504,3603,cpp,"class Solution {
   long long pw = 31, mod = 1e9+7;

    vector<long long> dfs(long long node, vector<vector<long long>>& adj, vector<long long>& power, vector<bool>& ans, string& s) {
        vector<long long> fwd, rev, sz;
        for (auto &it: adj[node]) {
            vector<long long> val = dfs(it, adj, power, ans, s);
            fwd.push_back(val[0]);
            rev.push_back(val[1]);
            sz.push_back(val[2]);
        }
        
        fwd.push_back(s[node] - 'a' + 1);
        rev.push_back(s[node] - 'a' + 1);
        sz.push_back(1);

        long long fwdHash = 0, prev = 0;
        long long n = fwd.size();
        
        for (int i = 0; i < n; i++) {
            fwdHash = (fwdHash + (power[prev] * fwd[i]) % mod) % mod;
            prev += sz[i];
        }

        long long revHash = 0;
        prev = 0;

        for (int i = n - 1; i >= 0; i--) {
            revHash = (revHash + (power[prev] * rev[i]) % mod) % mod;
            prev += sz[i];
        }

        if (fwdHash == revHash) {
            ans[node] = true;
        }

        return {fwdHash, revHash, prev};
    }

public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
         long long n = s.size();
        vector<bool> ans(n, false);
        vector<long long> power(n + 1, 1);
        vector<vector<long long>> adj(n);
        
        for (int i = 1; i <= n; i++) {
            power[i] = (pw * power[i - 1]) % mod;
        }

        for (int i = 0; i < n; i++) {
            if (parent[i] != -1)
                adj[parent[i]].push_back(i);
        }

        dfs(0, adj, power, ans, s);
        return ans;
    }
};",1427950097
QsYX4ZRmCa,QsYX4ZRmCa,504,3607,cpp,"class Solution {
  int greatestDivisor(int x) {
        if (x <= 1) return 0; 
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                return i < x ? i : x / i; 
            }
        }
        return 0; 
    }
public:
    int minOperations(vector<int>& nums) {
    int ops = 0, n = nums.size();

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] <= nums[i + 1]) continue;

            int divisor = greatestDivisor(nums[i]);
            if (divisor <= 1) return -1;

            nums[i] = divisor;
            if (nums[i] > nums[i + 1]) return -1;
            ops++;
        }

        return ops;  
    }
};",1427956537
Arpit,arpitkus,505,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), count = 0;
        vector<int> freq(26, 0);
        for (int i = 0; i < n; ++i) {
            fill(freq.begin(), freq.end(), 0);
            for (int j = i; j < n; ++j) {
                freq[s[j] - 'a']++;
                if (any_of(freq.begin(), freq.end(), [k](int x) { return x >= k; })) {
                    count += n - j;
                    break;
                }
            }
        }
        return count;
    }
};
",1427825323
Arpit,arpitkus,505,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string s = """";
        for (char t : target) {
            s += 'a';
            result.push_back(s);
            while (s.back() != t) {
                s.back() = s.back() == 'z' ? 'a' : s.back() + 1;
                result.push_back(s);
            }
        }
        return result;
    }
};
",1427824342
Arpit,arpitkus,505,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(const vector<int>& parent, const string& s) {
        const int n = parent.size();

        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        constexpr long long P = 911, MOD = 1000000007;
        vector<long long> power(n + 2, 1);
        for (int i = 1; i <= n + 1; ++i) {
            power[i] = (power[i - 1] * P) % MOD;
        }

        vector<int> postorder;

        auto dfs = [&](int root) {
            stack<pair<int, bool>> st({{root, false}});
            while (!st.empty()) {
                auto [node, visited] = st.top(); st.pop();
                if (visited) {
                    postorder.push_back(node);
                } else {
                    st.emplace(node, true);
                    for (auto it = tree[node].rbegin(); it != tree[node].rend(); ++it) {
                        st.emplace(*it, false);
                    }
                }
            }
        };

        dfs(0);

        vector<int> size(n, 1);
        vector<long long> forwardHash(n), backwardHash(n);

        auto computeHash = [&](int node) {
            long long fHash = 0, bHash = s[node] - 'a' + 1;
            for (const int child : tree[node]) {
                fHash = (fHash * power[size[child]] + forwardHash[child]) % MOD;
                size[node] += size[child];
            }
            fHash = (fHash * P + (s[node] - 'a' + 1)) % MOD;
            forwardHash[node] = fHash;

            for (auto it = tree[node].rbegin(); it != tree[node].rend(); ++it) {
                int child = *it;
                bHash = (bHash * power[size[child]] + backwardHash[child]) % MOD;
            }
            backwardHash[node] = bHash;
        };

        for (const int node : postorder) {
            computeHash(node);
        }

        vector<bool> answer(n);
        transform(forwardHash.begin(), forwardHash.end(), backwardHash.begin(), answer.begin(),
                  [](long long fHash, long long bHash) {
                      return fHash == bHash;
                  });

        return answer;
    }
};
",1427949068
Arpit,arpitkus,505,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int operations = 0;
        int next = nums[n-1];
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > next) {
                int curr = nums[i];
                int localOps = 0;
                while (curr > next) {
                    int divisor = findGreatestProperDivisor(curr);
                    if (divisor == 1) return -1;
                    curr /= divisor;
                    localOps++;
                }
                operations += localOps;
                nums[i] = curr;
            }
            next = nums[i];
        }
        
        return operations;
    }
    
private:
    int findGreatestProperDivisor(int num) {
        for (int i = 2; i * i <= num; ++i) {
            if (num % i == 0) return num / i;
        }
        return 1;
    }
};",1427901215
xjc,kaddie,506,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        N = len(s)
        res = 0
        end = 0
        m = Counter()
        freq_ch = ""-""
        for beg in range(N):
            while end < N and m[freq_ch] < k:
                m[s[end]] += 1
                if m[s[end]] > m[freq_ch]:
                    freq_ch = s[end]
                end += 1
            if m[freq_ch] == k:
                res += 1 + N - end
            m[s[beg]] -= 1
            
        return res
",1427845250
xjc,kaddie,506,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        for c in target:
            prev = res[-1] if res else """"
            for i in range(ord(c) - ord('a') + 1):
                res.append(prev + chr(ord('a') + i))
        return res",1427829331
xjc,kaddie,506,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        N = len(parent)
        pal = [True] * N
        
        if len(Counter(s)) == 1:
            return pal

        child = defaultdict(list)
        for i in range(1, N):
            child[parent[i]].append(i)

        def dfs(i):
            res = ''.join(dfs(c) for c in child[i]) + s[i]
            pal[i] = res == res[::-1]
            return res
        dfs(0)

        return pal",1427953729
xjc,kaddie,506,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        res = 0

        # M = 1
        # for i in range(len(nums) - 2, -1, -1):
        #     if nums[i] > nums[i + 1]:
        #         if nums[i + 1] == 1:
        #             return -1
        #         if nums[i + 1] == 2 and nums[i] % 2 != 0:
        #             return -1
        #         if nums[i] % 2 == 0:
        #             res += 1
        #             nums[i] = 2
        #         M = max(M, nums[i])
        # M += 1

        # # M = max((nums[i]
        # #     for i in range(len(nums) - 2, -1, -1) if nums[i] > nums[i + 1]), default = 1) + 1
        # # min factors of each num
        # # M = max(nums) + 1
        # f = [0] * M
        # f[1] = 1
        # for i in range(2, M):
        #     for j in range(i, M, i):
        #         if f[j] == 0:
        #             f[j] = i
        
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                for j in range(2, nums[i + 1] + 1):
                    if nums[i] % j == 0:
                        nums[i] = j
                        res += 1
                if nums[i] > nums[i + 1]:
                    return -1
        return res


",1427963365
sisoj,sisoj,507,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int j = 0;
        vector<int> freq(26);
        const int n = (int)s.length();
        int ans = n*(n+1)/2;
        for (int i = 0; i<n; ++i) {
            freq[s[i]-'a']++;
            while (freq[s[i]-'a'] == k) {
                freq[s[j]-'a']--;
                j++;
            }
            ans -= (i-j+1);
        }
        return ans;
    }
};",1427832145
sisoj,sisoj,507,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string result = """";
        int n =(int)target.length();
        for (int i = 0; i<n; ++i) {
            result += 'a';
            ans.push_back(result);
            while (result.back() != target[i]) {
                result.back()++;
                ans.push_back(result);
            }
        }
        return ans;
    }
};",1427824184
sisoj,sisoj,507,3603,cpp,"using ll = long long;
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string& s) {
        int n = (int)s.length();
        vector<vector<int>> g(n);
        for (int i = 1; i<n; ++i) {
            g[parent[i]].push_back(i);
        }
        const int MOD = 1e9+7;
        vector<int> sz(n);
        // auto getsz = [&](auto self, int v) -> void {
        //     sz[v] = 1;
        //     for (int u: g[v]) {
        //         self(self, u);
                
        //     }
        // };
        // getsz(getsz, 0);

        vector<long long> dp2(100005);
        dp2[0] = 1;
        for (int i = 1; i<=100004; ++i)
            dp2[i] = (dp2[i-1]*27)%MOD;
        vector<int> left(n);

        auto norm = [&](auto self, int v) -> void {
            sz[v] = 1;
            ll x= s[v]-'a'+1;
            int mult = 0;
            ll result = 0;
            for (int& u: g[v]) {
                self(self, u);
                sz[v] += sz[u];
                ll y = left[u];
                result = (result * dp2[sz[u]])%MOD;
                result = (result + y);
                if (result >= MOD) result -= MOD;
            }
            result = (result * 27 + x)%MOD;
            left[v] = result;
        };
        norm(norm, 0);
        vector<bool> result(n);
        auto alt = [&](auto self, int v) -> void {
            ll x= s[v]-'a'+1;
            for (int i = (int)g[v].size()-1; i>=0; --i) {
                int u = g[v][i];
                x = (x*dp2[sz[u]])%MOD;
                self(self, u);
                ll y = left[u];
                x = (x+y);
                if (x >= MOD) x-= MOD;
            }
            if (x == left[v]) result[v] = true;
            left[v] = x;
        };
        alt(alt, 0);
        return result;
    }
};",1427953806
sisoj,sisoj,507,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int N = 1000000;
        bitset<1000001> bt;
        bt[1] = 1;
        for (int i = 2; i*i<=N; ++i) {
            if (bt[i]) continue;
            for (int j = i*i; j<=N; j+=i)
                bt[j] = 1;
        }
        int n = (int)nums.size();
        int ans = 0;
        for (int i = n-2; i>=0; --i) {
            if (nums[i] <= nums[i+1]) continue;
            if (!bt[nums[i]]) return -1;
            bool bad = false;
            while (nums[i] > nums[i+1]) {
                if (!bt[nums[i]]) {
                    bad = true;
                    break;
                }
                for (int j = 2; j*j<=nums[i]; ++j) {
                    if (nums[i]%j == 0) {
                        nums[i] = j;
                        ans++;
                        break;
                    }
                }
            }
            if (bad) return -1;
        }
        return ans;

    }
};",1427842564
prabhudas avanigadda,CodeLikeNone,508,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int count = 0;


        for (int left = 0; left < n; ++left) {
            vector<int> freq(26, 0); 
            

            for (int right = left; right < n; ++right) {
                freq[s[right] - 'a']++;
                

                bool valid = false;
                for (int i = 0; i < 26; ++i) {
                    if (freq[i] >= k) {
                        valid = true;
                        break;
                    }
                }
                

                if (valid) {
                    count++;
                }
            }
        }
        
        return count;
    }
};
",1427846355
prabhudas avanigadda,CodeLikeNone,508,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """"; 
        

        for (char ch : target) {

            current += 'a';
            result.push_back(current); 
            
            while (current.back() != ch) {
                current.back()++;
                result.push_back(current);
            }
        }
        
        return result; 
    }
};
",1427842706
prabhudas avanigadda,CodeLikeNone,508,3603,cpp,"class Solution {
public:
    // Helper function for modular multiplication to prevent overflow
    long long modular_multiply(long long a, long long b, long long mod) {
        long long result = 0;
        a %= mod;
        while (b > 0) {
            if (b % 2 == 1) {
                result = (result + a) % mod;
            }
            a = (a * 2) % mod;
            b /= 2;
        }
        return result;
    }

    vector<bool> findAnswer(vector<int>& parent_tree, string& node_string) {
        int n = parent_tree.size();
        unordered_map<int, vector<int>> children_tree;

        // Build the tree structure from the parent array
        for (int i = 1; i < n; i++) {
            children_tree[parent_tree[i]].push_back(i);
        }

        // Hashing bases and mod values
        const long long base_primary = 911382628;
        const long long mod_primary = 1000000000000000007;
        const long long base_secondary = 3571;
        const long long mod_secondary = 1000000000000000009;

        int max_len = n + 1;
        vector<long long> base_powers_primary(max_len, 1);
        vector<long long> base_powers_secondary(max_len, 1);

        // Precompute powers of base modulo the respective mod values
        for (int i = 1; i < max_len; i++) {
            base_powers_primary[i] = modular_multiply(base_powers_primary[i - 1], base_primary, mod_primary);
            base_powers_secondary[i] = modular_multiply(base_powers_secondary[i - 1], base_secondary, mod_secondary);
        }

        // Initialize hash arrays for forward and reverse hashes
        vector<long long> forward_hash_primary(n, 0);
        vector<long long> reverse_hash_primary(n, 0);
        vector<long long> forward_hash_secondary(n, 0);
        vector<long long> reverse_hash_secondary(n, 0);
        vector<int> subtree_length(n, 1);
        vector<int> in_degree(n, 0);

        for (int i = 0; i < n; i++) {
            in_degree[i] = children_tree[i].size();
        }

        deque<int> bfs_queue;

        for (int i = 0; i < n; i++) {
            if (in_degree[i] == 0) {
                bfs_queue.push_back(i);
            }
        }

        unordered_map<long long, int> subtree_hash_primary;
        unordered_map<long long, int> subtree_hash_secondary;
        int id_primary = 1;
        int id_secondary = 1;

        while (!bfs_queue.empty()) {
            int current_node = bfs_queue.front();
            bfs_queue.pop_front();

            long long combined_hash_primary = 0;
            for (int child_node : children_tree[current_node]) {
                combined_hash_primary = (modular_multiply(combined_hash_primary, base_powers_primary[subtree_length[child_node]], mod_primary) + forward_hash_primary[child_node]) % mod_primary;
            }

            combined_hash_primary = (modular_multiply(combined_hash_primary, base_primary, mod_primary) + node_string[current_node]) % mod_primary;
            forward_hash_primary[current_node] = combined_hash_primary;

            long long combined_reverse_hash_primary = node_string[current_node];
            for (auto it = children_tree[current_node].rbegin(); it != children_tree[current_node].rend(); ++it) {
                combined_reverse_hash_primary = (modular_multiply(combined_reverse_hash_primary, base_powers_primary[subtree_length[*it]], mod_primary) + reverse_hash_primary[*it]) % mod_primary;
            }
            reverse_hash_primary[current_node] = combined_reverse_hash_primary;

            long long combined_hash_secondary = 0;
            for (int child_node : children_tree[current_node]) {
                combined_hash_secondary = (modular_multiply(combined_hash_secondary, base_powers_secondary[subtree_length[child_node]], mod_secondary) + forward_hash_secondary[child_node]) % mod_secondary;
            }

            combined_hash_secondary = (modular_multiply(combined_hash_secondary, base_secondary, mod_secondary) + node_string[current_node]) % mod_secondary;
            forward_hash_secondary[current_node] = combined_hash_secondary;

            long long combined_reverse_hash_secondary = node_string[current_node];
            for (auto it = children_tree[current_node].rbegin(); it != children_tree[current_node].rend(); ++it) {
                combined_reverse_hash_secondary = (modular_multiply(combined_reverse_hash_secondary, base_powers_secondary[subtree_length[*it]], mod_secondary) + reverse_hash_secondary[*it]) % mod_secondary;
            }
            reverse_hash_secondary[current_node] = combined_reverse_hash_secondary;

            int total_subtree_length = 1;
            for (int child_node : children_tree[current_node]) {
                total_subtree_length += subtree_length[child_node];
            }
            subtree_length[current_node] = total_subtree_length;

            if (current_node != 0) {
                int parent_node = parent_tree[current_node];
                in_degree[parent_node]--;
                if (in_degree[parent_node] == 0) {
                    bfs_queue.push_back(parent_node);
                }
            }
        }

        vector<bool> result;

        for (int i = 0; i < n; i++) {
            if (forward_hash_primary[i] == reverse_hash_primary[i] && forward_hash_secondary[i] == reverse_hash_secondary[i]) {
                result.push_back(true);
            } else {
                result.push_back(false);
            }
        }

        return result;
    }
};",1427962146
prabhudas avanigadda,CodeLikeNone,508,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int operations = 0;
        int n = nums.size();
        
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                int divisor = getLargestProperDivisor(nums[i]);
                
                if (divisor == 1) return -1;
                nums[i] /= divisor;
                if(nums[i]>nums[i+1]) return -1;
                operations++;
            }
        }
        
        return operations;
    }
    

    int getLargestProperDivisor(int num) {
        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                return num / i;  
            }
        }
        return 1;  
    }
};
",1427866423
DEMON J,DeEmOnJ,511,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int total_substrings = 0;

        for (int i = 0; i < n; ++i) {
        vector<int> freq(26, 0);
        for (int j = i; j < n; ++j) {
        freq[s[j] - 'a']++;


        if (freq[s[j] - 'a'] >= k) {

        total_substrings += (n - j);
        break;
        }
        }
        }

        return total_substrings;
        }
        };


        
    ",1427837112
DEMON J,DeEmOnJ,511,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {

        vector<string> result;
        string current = """";
        for (int i = 0; i < target.length(); ++i) {

        if (current.length() < i + 1) {
        current += 'a';
        result.push_back(current);
        }

        while (current.back() != target[i]) {
        current.back() = (current.back() - 'a' + 1) % 26 + 'a';
        result.push_back(current);
        }
        }
        return result;
        }
        };

        
",1427828848
DEMON J,DeEmOnJ,511,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {

        int n = parent.size();
        std::vector<std::vector<int>> tree(n);
        std::vector<int> start(n), end(n);
        std::vector<char> pString;

        for (int i = 1; i < n; ++i) {
        tree[parent[i]].push_back(i);
        }

        dfs(0, tree, s, pString, start, end);

        int N = pString.size();
        const int mod1 = 1e9 + 7;
        const int mod2 = 1e9 + 9;
        const int base1 = 131;
        const int base2 = 137;

        std::vector<long long> prefix_hash1(N), prefix_hash2(N);
        std::vector<long long> reverse_prefix_hash1(N), reverse_prefix_hash2(N);
        std::vector<long long> pow_base1(N + 1), pow_base2(N + 1);

        pow_base1[0] = pow_base2[0] = 1;
        for (int i = 1; i <= N; ++i) {
        pow_base1[i] = (pow_base1[i - 1] * base1) % mod1;
        pow_base2[i] = (pow_base2[i - 1] * base2) % mod2;
        }

        prefix_hash1[0] = pString[0];
        prefix_hash2[0] = pString[0];
        for (int i = 1; i < N; ++i) {
        prefix_hash1[i] = (prefix_hash1[i - 1] * base1 + pString[i]) % mod1;
        prefix_hash2[i] = (prefix_hash2[i - 1] * base2 + pString[i]) % mod2;
        }

        std::vector<char> reverse_pString(pString.rbegin(), pString.rend());
        reverse_prefix_hash1[0] = reverse_pString[0];
        reverse_prefix_hash2[0] = reverse_pString[0];
        for (int i = 1; i < N; ++i) {
        reverse_prefix_hash1[i] = (reverse_prefix_hash1[i - 1] * base1 + reverse_pString[i]) % mod1;
        reverse_prefix_hash2[i] = (reverse_prefix_hash2[i - 1] * base2 + reverse_pString[i]) % mod2;
        }

        std::vector<bool> answer(n, false);

        for (int i = 0; i < n; ++i) {
        int l = start[i], r = end[i];
        int rev_l = N - 1 - r, rev_r = N - 1 - l;

        long long hash1 = getHash(prefix_hash1, pow_base1, l, r, mod1);
        long long reverse_hash1 = getHash(reverse_prefix_hash1, pow_base1, rev_l, rev_r, mod1);

        long long hash2 = getHash(prefix_hash2, pow_base2, l, r, mod2);
        long long reverse_hash2 = getHash(reverse_prefix_hash2, pow_base2, rev_l, rev_r, mod2);

        if (hash1 == reverse_hash1 && hash2 == reverse_hash2) {
        answer[i] = true;
        }
        }

        return answer;
        }

        private:
        void dfs(int u, std::vector<std::vector<int>>& tree, std::string& s, std::vector<char>& pString,
        std::vector<int>& start, std::vector<int>& end) {
        start[u] = pString.size();
        std::sort(tree[u].begin(), tree[u].end());
        for (int v : tree[u]) {
        dfs(v, tree, s, pString, start, end);
        }
        pString.push_back(s[u]);
        end[u] = pString.size() - 1;
        }

        long long getHash(std::vector<long long>& prefix_hash, std::vector<long long>& pow_base, int l, int r, int mod) {
        if (l == 0) {
        return prefix_hash[r];
        } else {
        long long hash = (prefix_hash[r] - prefix_hash[l - 1] * pow_base[r - l + 1]) % mod;
        if (hash < 0) hash += mod;
        return hash;
        }
        }
        };


   
    ",1427869992
Inzaghi,InMDev,514,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        if k == 1:
            return len(s) * (len(s) + 1) // 2
        
        out = 0
        n = len(s)

        for start in range(n):
            freq = [0] * 26
            max_f = 0

            for end in range(start,n):
                idx = ord(s[end]) - ord('a')
                freq[idx] += 1

                if freq[idx] > max_f:
                    max_f = freq[idx]
                
                if max_f >= k:
                    out += 1
        
        return out",1427835811
Inzaghi,InMDev,514,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        out = []
        curr = ''

        for i in range(len(target)):
            while len(curr) < i+1:
                curr += 'a'
                out.append(curr)
            
            curr_c = curr[-1]
            target_c = target[i]

            step = (ord(target_c) - ord(curr_c)) % 26

            for i in range(step):
                next_c = chr((ord(curr[-1]) - ord('a') + 1) % 26 + ord('a'))
                curr = curr[:-1] + next_c
                out.append(curr)
        
        return out",1427830326
Inzaghi,InMDev,514,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        root = -1
        for i in range(n):
            if parent[i] == -1:
                root = i
            else:
                tree[parent[i]].append(i)

        # Build dfsStr and record positions
        idx = 0  # Index in dfsStr
        dfsStr = []
        Left = [0] * n   # Leftmost position in dfsStr for subtree of node i
        Right = [0] * n  # Rightmost position in dfsStr for subtree of node i

        def dfs(u):
            nonlocal idx
            Left[u] = float('inf')
            Right[u] = -float('inf')
            for v in sorted(tree[u]):
                dfs(v)
                Left[u] = min(Left[u], Left[v])
                Right[u] = max(Right[u], Right[v])
            # Append the character of node u
            dfsStr.append(s[u])
            # Update positions
            Left[u] = min(Left[u], idx)
            Right[u] = max(Right[u], idx)
            idx += 1

        dfs(root)

        N = len(dfsStr)
        # Build reversed dfsStr
        dfsStr_rev = dfsStr[::-1]

        # Bases and moduli for double hashing
        base1, mod1 = 911, 10 ** 9 + 7
        base2, mod2 = 1597, 10 ** 9 + 9

        # Precompute powers
        powBase1 = [1] * (N + 1)
        powBase2 = [1] * (N + 1)
        for i in range(1, N + 1):
            powBase1[i] = (powBase1[i - 1] * base1) % mod1
            powBase2[i] = (powBase2[i - 1] * base2) % mod2

        # Precompute prefix hashes for dfsStr
        HashF1 = [0] * N
        HashF2 = [0] * N
        for i in range(N):
            ch = ord(dfsStr[i])
            if i == 0:
                HashF1[i] = ch
                HashF2[i] = ch
            else:
                HashF1[i] = (HashF1[i - 1] * base1 + ch) % mod1
                HashF2[i] = (HashF2[i - 1] * base2 + ch) % mod2

        # Precompute prefix hashes for dfsStr_rev
        HashR1 = [0] * N
        HashR2 = [0] * N
        for i in range(N):
            ch = ord(dfsStr_rev[i])
            if i == 0:
                HashR1[i] = ch
                HashR2[i] = ch
            else:
                HashR1[i] = (HashR1[i - 1] * base1 + ch) % mod1
                HashR2[i] = (HashR2[i - 1] * base2 + ch) % mod2

        # Function to get hash of substring [L, R]
        def getHash(HashArray, powBase, L, R, mod):
            if L == 0:
                Hash = HashArray[R]
            else:
                Hash = (HashArray[R] - HashArray[L - 1] * powBase[R - L + 1]) % mod
                if Hash < 0:
                    Hash += mod
            return Hash

        answer = [False] * n
        for u in range(n):
            L = Left[u]
            R = Right[u]
            revL = N - 1 - R
            revR = N - 1 - L
            Hash1_fwd = getHash(HashF1, powBase1, L, R, mod1)
            Hash1_rev = getHash(HashR1, powBase1, revL, revR, mod1)
            Hash2_fwd = getHash(HashF2, powBase2, L, R, mod2)
            Hash2_rev = getHash(HashR2, powBase2, revL, revR, mod2)
            if Hash1_fwd == Hash1_rev and Hash2_fwd == Hash2_rev:
                answer[u] = True
            else:
                answer[u] = False

        return answer",1427878313
Teadose,IanISam,516,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int ans = 0;
        for(int i=0; i<n; i++){
            vector<int> cnt(26);
            bool found = 0;
            for(int j=i; j<n; j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a']>=k)found=1;
                ans+=found;
            }
        }
        return(ans);
    }
};",1427837178
Teadose,IanISam,516,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s = """";
        int j = 0;
        for(char c: target){
            s = s+'a';
            ans.push_back(s);
            while(s[j]!=c){
                s[j]++;
                ans.push_back(s);
            }
            j++;
        }
        return(ans);
    }
};",1427831274
Teadose,IanISam,516,3603,cpp,"class Solution {
public:
    typedef long long ll;
    ll mod = 1e9+9;
    ll binpow(ll x, ll n){
        ll res = 1;
        while(n){
            if(n&1)res=(res*x)%mod;
            x=(x*x)%mod;
            n/=2;
        }
        return(res);
    }
    void dfs(int i, vector<ll>& v1, vector<ll>& v2, vector<bool>& ans, vector<int>& si, vector<vector<int>>& e, string& s){
        ll sum1 = 0, sum2 = 0;
        for(int j: e[i]){
            dfs(j, v1, v2, ans, si, e, s);
            sum1=(sum1+v1[j]*binpow(31, si[i]))%mod;
            sum2=(v2[j]+sum2*binpow(31, si[j]))%mod;
            si[i]+=si[j];
        }
        v1[i]=(sum1+(s[i]-'a')*binpow(31, si[i]))%mod;
        v2[i]=((s[i]-'a')+31ll*sum2)%mod;
        si[i]++;
        ans[i]=v1[i]==v2[i];
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> ans(n); vector<ll> v1(n), v2(n); vector<int> si(n);
        vector<vector<int>> e(n);
        for(int i=1; i<n; i++)e[parent[i]].push_back(i);
        dfs(0, v1, v2, ans, si, e, s);
        return(ans);
    }
};",1427886705
Milind Gupta,milind0110,518,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.length();
        for(int i = 0; i < n; i++){
            vector<int> cnt(26);
            int mx = 0;
            for(int j = i; j < n; j++){
                cnt[s[j] - 'a']++;
                mx = max(mx,cnt[s[j] - 'a']);
                if(mx >= k) ans++;
            }
        }
        return ans;
    }
};",1427825935
Milind Gupta,milind0110,518,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curr;
        for(auto i : target){
            curr += 'a';
            for(int ch = 'a'; ch <= 'z'; ch++){
                ans.push_back(curr);
                if(i == curr.back()) break;
                curr.back()++;
            }
        }
        return ans;
    }
};",1427824582
Milind Gupta,milind0110,518,3603,cpp,"template<int... mods>
struct StringHash{
    StringHash(const string &s){}
    int hashval(int l1,int r2){
        return 0;
    }
    int compare(int l1,int r1,int l2,int r2){
        return true;
    }
};

template<int mod,int... mods>
struct StringHash<mod, mods...>{
    StringHash(){}
    int modpow(int64_t x, int64_t p){
        x %= mod;
        int64_t ans = 1;
        while(p){
            if(p&1) ans*=x, ans%=mod;
            x*=x;
            x%=mod;
            p>>=1;
        }
        return int(ans);
    }

    vector<int> hashvalues;
    vector<int> pows;
    vector<int> invpows;
    StringHash<mods...> ohash;
    const int AL = 26;

    StringHash(const string &s) : ohash(s){
        int n = s.size();
        hashvalues.resize(n+1);
        pows.resize(n+1);
        invpows.resize(n+1);
        pows[0] = 1;
        for(int i=1;i<=n;i++){
            pows[i] = int64_t(AL + 1) * pows[i-1] % mod;
        }
        invpows[n] = modpow(pows[n], mod-2);
        for(int i=n-1;i>=0;--i){
            invpows[i] = int64_t(AL + 1) * invpows[i+1] % mod;
        }
        for(int i=1;i<=n;i++){
            hashvalues[i] = (int64_t(AL + 1) * hashvalues[i-1] + (s[i-1] - 'a' + 1)) % mod;
        }
    }

    int hashval(int l1,int r1){ // 0 indexed
        int64_t ans = hashvalues[r1+1] - int64_t(hashvalues[l1]) * pows[r1-l1+1];
        ans%=mod;
        return ans >= 0 ? ans : ans+mod;
    }

    bool compare(int l1,int r1, int l2,int r2){
        return hashval(l1,r1) == hashval(l2, r2) && ohash.compare(l1,r1,l2,r2);
    }
};
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        const int mod = 1e9 + 7;
        int n = s.length();
        vector<vector<int>> edges(n);
        for(int i = 1; i < n; i++){
            edges[parent[i]].push_back(i);
        }
        string curr;
        vector<int> in(n),out(n);
        int ind = 0;
        auto dfs = [&](auto &dfs,int x) -> void {
            in[x] = ind;
            for(auto y : edges[x]){
                dfs(dfs,y);
            }
            curr.push_back(s[x]);
            out[x] = ind++;
        };
        dfs(dfs,0);
        string r = curr;
        reverse(r.begin(),r.end());
        StringHash<mod> chash(curr);
        StringHash<mod> rhash(r);
        vector<bool> ans(n);
        // cout << curr << ""\n"";
        for(int i = 0; i < n; i++){
            // cout << i << "" "" << in[i] << "" "" << out[i] << ""\n"";
            ans[i] = (chash.hashval(in[i],out[i]) == rhash.hashval(n - out[i] - 1,n - in[i] - 1));
        }
        return ans;

    }
};",1427882134
Rahul Kumar Yadav,user0434y,521,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int result = 0;
        
        // Iterate over all possible start indices of substrings
        for(int i = 0; i < n; ++i){
            // Frequency array for characters 'a' to 'z'
            int freq[26] = {0};
            // Counter for characters that have reached at least k occurrences
            int num_at_least_k = 0;
            
            // Iterate over all possible end indices for substrings starting at i
            for(int j = i; j < n; ++j){
                char current_char = s[j];
                freq[current_char - 'a']++;
                
                // If the current character reaches exactly k occurrences, increment the counter
                if(freq[current_char - 'a'] == k){
                    num_at_least_k++;
                }
                
                // If at least one character has reached k occurrences, increment the result
                if(num_at_least_k > 0){
                    result++;
                }
            }
        }
        
        return result;
    }
};
",1427898288
Rahul Kumar Yadav,user0434y,521,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        
        for(char c : target) {
            // Key 1: append 'a'
            current += 'a';
            result.push_back(current);
            
            // Calculate the number of Key 2 presses needed
            int key2_presses = (c - 'a' + 26) % 26;
            
            for(int i = 0; i < key2_presses; ++i) {
                // Key 2: change last character to next character
                if (current.empty()) continue; // Safety check, though current should never be empty here
                char last_char = current.back();
                last_char = (last_char == 'z') ? 'a' : (last_char + 1);
                current.back() = last_char;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427871169
Rahul Kumar Yadav,user0434y,521,3603,cpp,"typedef long long ll;
class Solution {
public:
    // Constants for hashing
    const int MOD1 = 1000000007;
    const int MOD2 = 1000000009;
    const int BASE1 = 911382629;
    const int BASE2 = 357142857;
    
    // Member variables
    vector<vector<int>> adj;
    vector<int> start_idx;
    vector<int> end_idx;
    string traversal;
    int current_time;
    
    // Power arrays for hashing
    vector<long long> power1_mod1;
    vector<long long> power1_mod2;
    
    // Prefix hashes
    vector<long long> prefix_hash1_mod1;
    vector<long long> prefix_hash2_mod1;
    vector<long long> prefix_hash1_mod2;
    vector<long long> prefix_hash2_mod2;
    
    // Reverse traversal string
    string reverse_traversal;
    // Prefix hashes for reverse traversal
    vector<long long> reverse_prefix_hash1_mod1;
    vector<long long> reverse_prefix_hash2_mod1;
    vector<long long> reverse_prefix_hash1_mod2;
    vector<long long> reverse_prefix_hash2_mod2;
    
    // Initialize member variables and perform post-order traversal
    void buildTree(int n, const vector<int>& parent, const string& s) {
        adj.assign(n, vector<int>());
        for(int i = 1; i < n; ++i){
            adj[parent[i]].push_back(i);
        }
        // Sort children for each node to ensure increasing order
        for(auto &children : adj){
            sort(children.begin(), children.end());
        }
        start_idx.assign(n, 0);
        end_idx.assign(n, 0);
        traversal = """";
        current_time = 0;
        dfs(0, s);
    }
    
    // Post-order DFS for traversal string and recording start and end indices
    void dfs(int node, const string& s){
        start_idx[node] = current_time;
        for(auto &child : adj[node]){
            dfs(child, s);
        }
        traversal += s[node];
        end_idx[node] = current_time;
        current_time++;
    }
    
    // Precomputing power arrays
    void precompute_powers(int n){
        power1_mod1.assign(n + 1, 1);
        power1_mod2.assign(n + 1, 1);
        for(int i = 1; i <= n; ++i){
            power1_mod1[i] = (power1_mod1[i-1] * BASE1) % MOD1;
            power1_mod2[i] = (power1_mod2[i-1] * BASE2) % MOD2;
        }
    }
    
    // Precomputing prefix hashes for a given string
    void compute_prefix_hashes(const string& s){
        int n = s.size();
        prefix_hash1_mod1.assign(n + 1, 0);
        prefix_hash2_mod1.assign(n + 1, 0);
        prefix_hash1_mod2.assign(n + 1, 0);
        prefix_hash2_mod2.assign(n + 1, 0);
        for(int i = 0; i < n; ++i){
            prefix_hash1_mod1[i+1] = (prefix_hash1_mod1[i] * BASE1 + (s[i] - 'a' + 1)) % MOD1;
            prefix_hash2_mod1[i+1] = (prefix_hash2_mod1[i] * BASE1 + (s[i] - 'a' + 1)) % MOD1;
            prefix_hash1_mod2[i+1] = (prefix_hash1_mod2[i] * BASE2 + (s[i] - 'a' + 1)) % MOD2;
            prefix_hash2_mod2[i+1] = (prefix_hash2_mod2[i] * BASE2 + (s[i] - 'a' + 1)) % MOD2;
        }
    }
    
    // get hash of substring [l, r] in original string
    pair<long long, long long> get_hash(int l, int r){
        ll hash1 = (prefix_hash1_mod1[r+1] - (prefix_hash1_mod1[l] * power1_mod1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        ll hash2 = (prefix_hash1_mod2[r+1] - (prefix_hash1_mod2[l] * power1_mod2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        return {hash1, hash2};
    }
    
    // get hash of substring [l, r] in reversed string
    pair<long long, long long> get_reverse_hash(int l, int r){
        ll hash1 = (reverse_prefix_hash1_mod1[r+1] - (reverse_prefix_hash1_mod1[l] * power1_mod1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        ll hash2 = (reverse_prefix_hash1_mod2[r+1] - (reverse_prefix_hash1_mod2[l] * power1_mod2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        return {hash1, hash2};
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        // Build the tree and traversal string
        buildTree(n, parent, s);
        // Precompute powers
        precompute_powers(n);
        // Compute prefix hashes for traversal string
        compute_prefix_hashes(traversal);
        // Create reversed traversal string and compute its prefix hashes
        reverse_traversal = traversal;
        reverse(reverse_traversal.begin(), reverse_traversal.end());
        // Compute prefix hashes for reversed traversal
        prefix_hash1_mod1.assign(n + 1, 0);
        prefix_hash2_mod1.assign(n + 1, 0);
        prefix_hash1_mod2.assign(n + 1, 0);
        prefix_hash2_mod2.assign(n + 1, 0);
        reverse_prefix_hash1_mod1.assign(n + 1, 0);
        reverse_prefix_hash2_mod1.assign(n + 1, 0);
        reverse_prefix_hash1_mod2.assign(n + 1, 0);
        reverse_prefix_hash2_mod2.assign(n + 1, 0);
        for(int i = 0; i < n; ++i){
            // Forward traversal hash
            prefix_hash1_mod1[i+1] = (prefix_hash1_mod1[i] * BASE1 + (traversal[i] - 'a' + 1)) % MOD1;
            prefix_hash1_mod2[i+1] = (prefix_hash1_mod2[i] * BASE2 + (traversal[i] - 'a' + 1)) % MOD2;
            // Reverse traversal hash
            reverse_prefix_hash1_mod1[i+1] = (reverse_prefix_hash1_mod1[i] * BASE1 + (reverse_traversal[i] - 'a' + 1)) % MOD1;
            reverse_prefix_hash1_mod2[i+1] = (reverse_prefix_hash1_mod2[i] * BASE2 + (reverse_traversal[i] - 'a' + 1)) % MOD2;
        }
        // Prepare the answer array
        vector<bool> answer(n, false);
        for(int x = 0; x < n; ++x){
            int l = start_idx[x];
            int r = end_idx[x];
            // Get hash of the substring [l, r] in traversal
            ll hash1 = (prefix_hash1_mod1[r+1] - (prefix_hash1_mod1[l] * power1_mod1[r - l + 1]) % MOD1 + MOD1) % MOD1;
            ll hash2 = (prefix_hash1_mod2[r+1] - (prefix_hash1_mod2[l] * power1_mod2[r - l + 1]) % MOD2 + MOD2) % MOD2;
            // Get hash of the corresponding substring in reversed traversal
            // The reversed substring corresponds to [n - r -1, n - l -1]
            int rev_l = n - r - 1;
            int rev_r = n - l - 1;
            ll rev_hash1 = (reverse_prefix_hash1_mod1[rev_r+1] - (reverse_prefix_hash1_mod1[rev_l] * power1_mod1[rev_r - rev_l + 1]) % MOD1 + MOD1) % MOD1;
            ll rev_hash2 = (reverse_prefix_hash1_mod2[rev_r+1] - (reverse_prefix_hash1_mod2[rev_l] * power1_mod2[rev_r - rev_l + 1]) % MOD2 + MOD2) % MOD2;
            // Compare the hashes
            if(hash1 == rev_hash1 && hash2 == rev_hash2){
                answer[x] = true;
            }
        }
        return answer;
    }
};
",1427889284
Lucky Orb,megurine,522,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        l = ans = 0
        cnt = [0] * 26
        for r, x in enumerate(s):
            cnt[ord(x) - 97] += 1
            while max(cnt) == k:
                cnt[ord(s[l]) - 97] -= 1
                l += 1
            ans += l
        return ans
        ",1427827450
Lucky Orb,megurine,522,3566,python3,"class Solution:
    def stringSequence(self, s: str) -> List[str]:
        ans = []
        for i, x in enumerate(s):
            for j in range(ord(x) - 97 + 1):
                ans.append(s[:i] + chr(j + 97))
        return ans
        ",1427824641
Lucky Orb,megurine,522,3603,python3,"rdx = 131
mod = random.getrandbits(50)
pows = [1]
for i in range(100000):
    pows.append(pows[-1] * rdx % mod)

class Solution:
    def findAnswer(self, fa: List[int], s: str) -> List[bool]:
        n = len(fa)
        g = [[] for _ in range(n)]
        for i, p in enumerate(fa):
            if p >= 0:
                g[p].append(i)
        for it in g:
            it.sort()

        L, R = [0] * n, [0] * n
        cnt = 0
        t = []
        def dfs(u):
            nonlocal cnt
            L[u] = R[u] = cnt
            for v in g[u]:
                dfs(v)
                R[u] = R[v] + 1
            cnt += 1
            t.append(s[u])
            
        dfs(0)
        f1 = [0] * (n + 1)
        f2 = [0] * (n + 1)
        for i in range(n):
            f1[i + 1] = (f1[i] * rdx + ord(t[i])) % mod
            f2[i + 1] = (f2[i] * rdx + ord(t[n - 1 - i])) % mod
        ans = [False] * n
        for i in range(n):
            l, r = L[i], R[i]
            v1 = (f1[r + 1] - f1[l] * pows[r + 1 - l]) % mod
            l, r = n - 1 - r, n - 1 - l
            v2 = (f2[r + 1] - f2[l] * pows[r + 1 - l]) % mod
            ans[i] = v1 == v2
        return ans
 ",1427890565
leetgoat_dot_dev,leetgoat_dot_dev,523,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        res = 0
        for l in range(len(s)):
            c = Counter()
            hasK = False
            for r in range(l, len(s)):
                newChar = s[r]
                c[newChar] += 1
                if c[newChar] == k:
                    hasK = True
                res += hasK
        return res
                
        
        ",1427830252
leetgoat_dot_dev,leetgoat_dot_dev,523,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        def nextC(c):
            if c == 'z':
                return 'a'
            return chr(ord(c) + 1)
        
        currArr = []
        res = []
        for i in range(len(target)):
            currArr.append('a')
            res.append(''.join(currArr))
            while currArr[-1] != target[i]:
                currArr[-1] = nextC(currArr[-1])
                res.append(''.join(currArr))
        return res
                ",1427825104
leetgoat_dot_dev,leetgoat_dot_dev,523,3603,python3,"MOD = 10**9 + 7
BASE = 26

# powBases[i] = 26^x % MOD
powBases = [1] * (10**5 + 1)
for i in range(1, 10**5 + 1):
    powBases[i] = (powBases[i - 1] * BASE) % MOD

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        children = defaultdict(list)
        for i in range(len(parent)):
            par = parent[i]
            child = i
            if par != -1:
                children[par].append(child)
        for key in children:
            children[key].sort()
            
        letters = [] # the string representing our serialization
        start = [0] * len(parent)
        end = [0] * len(parent)
        
        def postorder(node):
            start[node] = len(letters)
            for i in range(len(children[node])):
                postorder(children[node][i])
            letters.append(s[node])
            end[node] = len(letters) - 1
        postorder(0)
        
        # print(f'letters: {letters}')
        lettersStr = ''.join(letters)
        
        hashPrefixes = [0] * (len(lettersStr) + 1)
        for i in range(len(lettersStr)):
            hashPrefixes[i + 1] = (hashPrefixes[i] * BASE + ord(lettersStr[i])) % MOD
            
        reverseHashPrefixes = [0] * (len(lettersStr) + 1)
        for i in range(len(lettersStr) - 1, -1, -1):
            reverseHashPrefixes[len(lettersStr) - i] = (reverseHashPrefixes[len(lettersStr) - i - 1] * BASE + ord(lettersStr[i])) % MOD
            
        res = [False] * len(parent)
        for node in range(len(parent)):
            l = start[node]
            r = end[node]
            hashValue = (hashPrefixes[r + 1] - hashPrefixes[l] * powBases[r - l + 1]) % MOD
            revL = len(lettersStr) - r - 1
            revR = len(lettersStr) - l - 1
            reverseHashValue = (reverseHashPrefixes[revR + 1] - reverseHashPrefixes[revL] * powBases[revR - revL + 1]) % MOD
            if hashValue == reverseHashValue:
                res[node] = True
            else:
                res[node] = False
                
        return res",1427904354
tr1nity,tr1nity,528,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        if k == 1: return n * (n + 1) // 2
        res = 0
        p = [ord(c) - ord('a') for c in s]
        for i in range(n):
            f = [0] * 26
            cnt = 0
            for j in range(i, n):
                f[p[j]] += 1
                if f[p[j]] == k: cnt += 1
                if cnt > 0: res += 1
        return res",1427828502
tr1nity,tr1nity,528,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        s = """"
        for c in target:
            s += 'a'
            res.append(s)
            for _ in range((ord(c) - ord('a')) % 26):
                s = s[:-1] + chr(((ord(s[-1]) - ord('a') + 1) % 26) + ord('a'))
                res.append(s)
        return res",1427831616
tr1nity,tr1nity,528,3603,python3,"from typing import List

class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i in range(1, n): g[parent[i]].append(i)
        for x in g: x.sort()
        p = []
        in_ord, out_ord = [0] * n, [0] * n
        
        def dfs(x):
            in_ord[x] = len(p)
            for y in g[x]: dfs(y)
            p.append(s[x])
            out_ord[x] = len(p) - 1
            
        dfs(0)
        
        B1, B2 = 47, 257
        M1, M2 = 10 ** 9 + 7, 10 ** 9 + 9
        m = len(p)
        
        p1, p2 = [1] * (m + 1), [1] * (m + 1)
        for i in range(1, m + 1):
            p1[i] = (p1[i - 1] * B1) % M1
            p2[i] = (p2[i - 1] * B2) % M2

        h1, h2 = [0] * (m + 1), [0] * (m + 1)
        for i, c in enumerate(p):
            h1[i + 1] = (h1[i] * B1 + ord(c)) % M1
            h2[i + 1] = (h2[i] * B2 + ord(c)) % M2

        rev_h1, rev_h2 = [0] * (m + 1), [0] * (m + 1)
        for i, c in enumerate(p[::-1]):
            rev_h1[i + 1] = (rev_h1[i] * B1 + ord(c)) % M1
            rev_h2[i + 1] = (rev_h2[i] * B2 + ord(c)) % M2

        res = [False] * n
        for i in range(n):
            l, r = in_ord[i], out_ord[i]
            cur_h1 = (h1[r + 1] - h1[l] * p1[r - l + 1]) % M1
            cur_h2 = (h2[r + 1] - h2[l] * p2[r - l + 1]) % M2
            rl, rr = m - 1 - r, m - l
            cur_rev_h1 = (rev_h1[rr] - rev_h1[rl] * p1[rr - rl]) % M1
            cur_rev_h2 = (rev_h2[rr] - rev_h2[rl] * p2[rr - rl]) % M2
            res[i] = cur_h1 == cur_rev_h1 and cur_h2 == cur_rev_h2
        return res",1427908212
whymihere,whymihere,529,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = (int)s.size();
        vector<vector<int64_t>> p(n, vector<int64_t>(26, 0));
        for (int i = 0; i < n; i++) {
            int d = s[i] - 'a';
            p[i][d]++;
            if (i - 1 >= 0) {
                for (int j = 0; j < 26; j++) {
                    p[i][j] += p[i - 1][j];
                }
            }
        }
        auto query = [&](int l, int r, int d) -> int64_t {
            return p[r][d] - (l - 1 >= 0? p[l - 1][d]: 0);
        };
        
        
        auto ok = [&](int l, int r) -> bool {
            for (int i = 0; i < 26; i++) {
                if (query(l, r, i) >= k)
                    return true;
            }
            return false;
        };
        
        int64_t ans = 0;
        for (int i = 0; i < n; i++) {
            int l = i - 1, r = n;
            while (r - l > 1) {
                int m = l + (r - l) / 2;
                if (ok(i, m))
                    r = m;
                else 
                    l = m;
            }
            if (r != n) {
                ans += n - r;
            }
        }
        return ans;
    }
};",1427838923
whymihere,whymihere,529,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> ans;
        string s = """";
        int ptr = 0;
        while (s != t) {
            if (s.empty()) {
                s.push_back('a');
            } else if (s.back() != t[ptr]) {
                s.back() += 1;
            } else if (s.back() == t[ptr]) {
                s.push_back('a');
                ptr++;
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1427828714
whymihere,whymihere,529,3603,cpp,"// long long mod0 = 1000000007, mod1 = 987654347;
// long long p0 = 31, p1 = 37;
long long mod0 = 127657753, mod1 = 987654319;
long long p0 = 137, p1 = 277;
vector<array<long long, 2>> pw;
vector<array<long long, 2>> ipw;

long long h(char c) {
    return c; // return c - 'a' + 1;
}

long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while(b > 0) {
        if(b & 1) res = (res * a) % m;
        a = (a * a) % m;
        b >>= 1;
    }
    return res;
}

long long inv(long long a, long long m) {
    // a is prime and a mod m != 0
    // a ^ m       === a      (mod m) 
    // a ^ (m - 2) === a ^ -1 (mod m)
    return binpow(a, m - 2, m);
}

// Till the limit i.e. [0, limit]
void init(int limit) {
    if(pw.empty()) pw.push_back({1, 1});
    while(pw.size() < limit + 1) {
        pw.push_back({
            (pw.back()[0] * p0) % mod0, 
            (pw.back()[1] * p1) % mod1
        });
    } 
    if(ipw.empty()) {
        ipw.push_back({1, 1});
        ipw.push_back({
            inv(p0, mod0),
            inv(p1, mod1)
        });
    }
    while(ipw.size() < limit + 1) {
        ipw.push_back({
            (ipw.back()[0] * ipw[1][0]) % mod0, 
            (ipw.back()[1] * ipw[1][1]) % mod1
        });
    }
}

class Hashing {
public:
    vector<array<long long, 2>> pre;
    int n; 

    Hashing(string s) {
        init((int)s.size() + 1);
        if(s.size() == 0) return;
        pre.push_back({(h(s[0]) * pw[0][0]) % mod0, (h(s[0]) * pw[0][1]) % mod1});
        for(int i = 1; i < (int)s.size(); i++) {
            pre.push_back({
                (pre[i - 1][0] + h(s[i]) * pw[i][0]) % mod0,
                (pre[i - 1][1] + h(s[i]) * pw[i][1]) % mod1
            });
        }
        n = (int)s.size();
    }

    array<long long, 2> get_hash(int l, int r) {
        assert(0 <= l and l <= r  and r < n);
        array<long long, 2> hs;
        hs[0] = pre[r][0] - (l - 1 >= 0? pre[l - 1][0]: 0) + mod0;
        hs[1] = pre[r][1] - (l - 1 >= 0? pre[l - 1][1]: 0) + mod1;
        hs[0] = (hs[0] * ipw[l][0]) % mod0;
        hs[1] = (hs[1] * ipw[l][1]) % mod1;
        return hs;
    }

    array<long long, 2> get_hash() {
        return get_hash(0, n - 1);
    }
};


class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        const int n = parent.size();
        vector<vector<int>> adj(n);
        for (int u = 0; u < n; u++) {
            int v = parent[u];
            if (v == -1)
                continue;
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        for (int i = 0; i < n; i++)
            sort(adj[i].begin(), adj[i].end());
        
        
        vector<int> s_idx(n, -1), e_idx(n, -1);
        string tot = """";
        function<void(int, int)> dfs = [&](int u, int p) -> void {
            s_idx[u] = tot.size();
            
            for (auto& v: adj[u]) {
                if (v == p)
                    continue;
                dfs(v, u);
            }
            
            e_idx[u] = tot.size();
            tot += s[u];
        };
        dfs(0, -1);
        string rev_tot = tot;
        reverse(rev_tot.begin(), rev_tot.end());
        Hashing fw_hs(tot), bk_hs(rev_tot);
        
        // cout << tot << '\n';
        
        vector<bool> ans(n, false);
        for (int i = 0; i < n; i++) {
            int l = s_idx[i], r = e_idx[i];
            int rl = n - 1 - r, rr = n - 1 - l;
            // cout << ""l = "" << l << "", r = "" << r << '\n';
            // cout << ""rl = "" << rl << "", rr = "" << rr << '\n';
            ans[i] = (fw_hs.get_hash(l, r) == bk_hs.get_hash(rl, rr));
        }
        
        return ans;
    }
};",1427908339
Anshul Pandey,ansh_iet_22,532,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int cnt = 0;
        for(int i = 0 ; i < s.size() ; i++){
            vector<int> fre(26,0);
            for(int j = i ; j < s.size() ; j++){
                fre[s[j] - 'a']++;
                if(fre[s[j] - 'a'] >= k){
                    cnt += (n - j);
                    break;
                }
            }
        }
        return cnt;
    }
};",1427831138
Anshul Pandey,ansh_iet_22,532,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s = """";
        for(int i = 0 ; i < target.size() ; i++){
            s.push_back('a');
            int sz = s.size();
            while(s[sz-1] <= target[sz-1]){
                ans.push_back(s);
                s.back()+=1;                
            }
            s.back() = target[sz-1];
        }
        return ans;
    }
};",1427826262
Anshul Pandey,ansh_iet_22,532,3603,cpp,"
#define ff first
#define ss second
#define all(x) (x).begin(), (x).end()
typedef long long ll;
typedef unsigned long long ull;


typedef pair<ll, ll> pll;

const int MOD = 1e9 + 7;
const pll BASE = {4441, 7817};

pll operator+(const pll& a, const pll& b) {
    return { (a.first + b.first) % MOD, (a.second + b.second) % MOD };
}
pll operator+(const pll& a, const ll& b) {
    return { (a.first + b) % MOD, (a.second + b) % MOD };
}
pll operator-(const pll& a, const pll& b) {
    return { (MOD + a.first - b.first) % MOD, (MOD + a.second - b.second) % MOD };
}
pll operator*(const pll& a, const pll& b) {
    return { (a.first * b.first) % MOD, (a.second * b.second) % MOD };
}
pll operator*(const pll& a, const ll& b) {
    return { (a.first * b) % MOD, (a.second * b) % MOD };
}

pll get_hash(string s) {
    pll h = {0, 0};
    for (int i = 0; i < s.size(); i++) {
        h = BASE * h + s[i];
    }
    return h;
}

struct hsh {
    int N;
    string S;
    vector<pll> pre, pp;

    void init(string S_) {
        S = S_;
        N = S.size();
        pp.resize(N + 1);
        pre.resize(N + 1);
        pp[0] = {1, 1};
        for (int i = 0; i < N; i++) {
            pre[i + 1] = pre[i] * BASE + S[i];
            if (i) { pp[i] = pp[i - 1] * BASE; }
        }
    }

    pll get(int s, int e) {
        return pre[e] - pre[s] * pp[e - s];
    }
};




class Solution{
public:


    void dfs(int node , set<int> tree[] , vector<int> &tra , string &gen , string &s , vector<int> &sub){

        sub[node] += 1;

        for(auto it : tree[node]){
            dfs(it,tree,tra,gen,s,sub);
            sub[node] += sub[it];
        }

        gen.push_back(s[node]);
        tra.push_back(node);

    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {

        int n = parent.size();

        vector<bool> ans(n,false);
        
        set<int> tree[n+1];

        vector<int> tra, sub(n,0);
        string gen;

        for(int i = 0 ; i < n ; i++){
            if(parent[i] == -1) continue;
            tree[parent[i]].insert(i);
        }

        dfs(0,tree,tra,gen,s,sub);  

        // debug(tra);
        // debug(gen);
        // debug(sub);  

        hsh hs;
        hs.init(gen);

        string revGen = gen;

        reverse(all(revGen));


        hsh hsR;
        hsR.init(revGen);


        for(int i = n-1 ; i >= 0 ; i--){

            int sz = sub[tra[i]];
            pll hash1 = hs.get(i-sz+1,i+1);
            int udhar = n - i - 1;
            pll hash2 = hsR.get(udhar,udhar+sz);

            if(hash1 == hash2){
                ans[tra[i]] = true; 
            }
        }


        return ans;
    }
};
",1427912461
Jie Chen,JustJie,533,3502,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.19.2024 22:32:32
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        array<int, 26> freq {};

        const auto check = [&]() {
            int mx = 0;
            for (int a = 0; a < 26; a++) {
                mx = max(mx, freq[a]);
            }
            return mx >= k;
        };

        int ans = 0;
        for (int L = 0, R = 0; L < n; L++) {
            while (R < n && !check()) {
                freq[s[R] - 'a']++;
                R++;
            }
            if (check()) {
                ans += n - R + 1;
            } else {
                break;
            }
            freq[s[L] - 'a']--;
        }

        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1427913534
Jie Chen,JustJie,533,3566,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.19.2024 22:17:16
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string> ans;
        string res;
        for (char t : s) {
            for (char c = 'a'; c <= t; c++) {
                ans.push_back(res + c);
            }
            res += t;
        }
        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1427913826
Jie Chen,JustJie,533,3603,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.19.2024 22:30:12
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

template<const unsigned &MOD>
struct _m_uint {
    unsigned val;

    _m_uint(int64_t v = 0) {
        if (v < 0) v = v % MOD + MOD;
        if (v >= MOD) v %= MOD;
        val = unsigned(v);
    }

    _m_uint(uint64_t v) {
        if (v >= MOD) v %= MOD;
        val = unsigned(v);
    }

    _m_uint(int v) : _m_uint(int64_t(v)) {}
    _m_uint(unsigned v) : _m_uint(uint64_t(v)) {}

    explicit operator unsigned() const { return val; }
    explicit operator int64_t() const { return val; }
    explicit operator uint64_t() const { return val; }
    explicit operator double() const { return val; }
    explicit operator long double() const { return val; }

    _m_uint& operator+=(const _m_uint &other) {
        val = val < MOD - other.val ? val + other.val : val - (MOD - other.val);
        return *this;
    }

    _m_uint& operator-=(const _m_uint &other) {
        val = val < other.val ? val + (MOD - other.val) : val - other.val;
        return *this;
    }

    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {
// #if !defined(_WIN32) || defined(_WIN64)
        return unsigned(x % m);
// #endif
//         // Optimized mod for Codeforces 32-bit machines.
//         // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.
//         unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);
//         unsigned quot, rem;
//         asm(""divl %4\n""
//             : ""=a"" (quot), ""=d"" (rem)
//             : ""d"" (x_high), ""a"" (x_low), ""r"" (m));
//         return rem;
    }

    _m_uint& operator*=(const _m_uint &other) {
        val = fast_mod(uint64_t(val) * other.val);
        return *this;
    }

    _m_uint& operator/=(const _m_uint &other) {
        return *this *= other.inv();
    }

    friend _m_uint operator+(const _m_uint &a, const _m_uint &b) { return _m_uint(a) += b; }
    friend _m_uint operator-(const _m_uint &a, const _m_uint &b) { return _m_uint(a) -= b; }
    friend _m_uint operator*(const _m_uint &a, const _m_uint &b) { return _m_uint(a) *= b; }
    friend _m_uint operator/(const _m_uint &a, const _m_uint &b) { return _m_uint(a) /= b; }

    _m_uint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }

    _m_uint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }

    _m_uint operator++(int) { _m_uint before = *this; ++*this; return before; }
    _m_uint operator--(int) { _m_uint before = *this; --*this; return before; }

    _m_uint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }

    friend bool operator==(const _m_uint &a, const _m_uint &b) { return a.val == b.val; }
    friend bool operator!=(const _m_uint &a, const _m_uint &b) { return a.val != b.val; }
    friend bool operator<(const _m_uint &a, const _m_uint &b) { return a.val < b.val; }
    friend bool operator>(const _m_uint &a, const _m_uint &b) { return a.val > b.val; }
    friend bool operator<=(const _m_uint &a, const _m_uint &b) { return a.val <= b.val; }
    friend bool operator>=(const _m_uint &a, const _m_uint &b) { return a.val >= b.val; }

    static const int SAVE_INV = int(1e6) + 5;
    static _m_uint save_inv[SAVE_INV];

    static void prepare_inv() {
        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.
        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)
            assert(MOD % p != 0);

        save_inv[0] = 0;
        save_inv[1] = 1;

        for (int i = 2; i < SAVE_INV; i++)
            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);
    }

    _m_uint inv() const {
        if (save_inv[1] == 0)
            prepare_inv();

        if (val < SAVE_INV)
            return save_inv[val];

        _m_uint product = 1;
        unsigned v = val;

        do {
            product *= MOD - MOD / v;
            v = MOD % v;
        } while (v >= SAVE_INV);

        return product * save_inv[v];
    }

    _m_uint pow(int64_t p) const {
        if (p < 0)
            return inv().pow(-p);

        _m_uint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            p >>= 1;

            if (p > 0)
                a *= a;
        }

        return result;
    }

    friend ostream& operator<<(ostream &os, const _m_uint &m) {
        return os << m.val;
    }
};

template<const unsigned &MOD> _m_uint<MOD> _m_uint<MOD>::save_inv[_m_uint<MOD>::SAVE_INV];

uint64_t random_address() { char *p = new char; delete p; return uint64_t(p); }
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));

// P = 2^32 - 13337 is a safe prime: both P and (P - 1) / 2 are prime.
const unsigned HASH_P = unsigned(-13337);
using hash_int = _m_uint<HASH_P>;

const uint64_t HASH_P2 = uint64_t(HASH_P) * HASH_P;
const int HASH_COUNT = 2;

// Avoid multiplication bases near 0 or P - 1.
uniform_int_distribution<unsigned> MULT_DIST(unsigned(0.1 * HASH_P), unsigned(0.9 * HASH_P));
const hash_int HASH_MULT[] = {MULT_DIST(rng), MULT_DIST(rng)};
const hash_int HASH_INV[] = {1 / HASH_MULT[0], 1 / HASH_MULT[1]};

vector<hash_int> hash_pow[] = {{1}, {1}};

const int INF = int(1e9) + 5;

template<typename T_string = string>
struct string_hash {
    // TODO: decide whether BUILD_REVERSE = true is needed.
    static const bool BUILD_REVERSE = true;

    static uint64_t hash(const T_string &str) {
        uint64_t result = 0;

        for (int h = 0; h < HASH_COUNT; h++) {
            uint64_t value = 1;

            for (const auto &x : str)
                value = (uint64_t(HASH_MULT[h]) * value + x) % HASH_P;

            result += value << (32 * h);
        }

        return result;
    }

    T_string str;
    vector<hash_int> _prefix[HASH_COUNT];
    vector<hash_int> _inv_prefix[HASH_COUNT];

    string_hash() {
        build({});
    }

    string_hash(const T_string &_str) {
        build(_str);
    }

    int length() const {
        return int(_prefix[0].size()) - 1;
    }

    template<typename T_char>
    void add_char(const T_char &c) {
        str.push_back(c);

        for (int h = 0; h < HASH_COUNT; h++) {
            _prefix[h].push_back(HASH_MULT[h] * _prefix[h].back() + c);

            if (hash_pow[h].size() < _prefix[h].size())
                hash_pow[h].push_back(HASH_MULT[h] * hash_pow[h].back());

            if (BUILD_REVERSE)
                _inv_prefix[h].push_back((_inv_prefix[h].back() + c) * HASH_INV[h]);
        }
    }

    void pop_char() {
        str.pop_back();

        for (int h = 0; h < HASH_COUNT; h++) {
            _prefix[h].pop_back();

            if (BUILD_REVERSE)
                _inv_prefix[h].pop_back();
        }
    }

    void build(const T_string &_str) {
        str = {};
        str.reserve(_str.size());

        for (int h = 0; h < HASH_COUNT; h++) {
            hash_pow[h].reserve(_str.size() + 1);
            _prefix[h] = {0};
            _prefix[h].reserve(_str.size() + 1);

            if (BUILD_REVERSE) {
                _inv_prefix[h] = {0};
                _inv_prefix[h].reserve(_str.size() + 1);
            }
        }

        for (auto &c : _str)
            add_char(c);
    }

    uint64_t _single_hash(int h, int start, int end) const {
        // Convert everything to `uint64_t` for speed. Note: we add hash_pow[length] to fix strings that start with 0.
        uint64_t power = uint64_t(hash_pow[h][end - start]);
        return (power + uint64_t(_prefix[h][end]) + HASH_P2 - uint64_t(_prefix[h][start]) * power) % HASH_P;
    }

    uint64_t substring_hash(int start, int end) const {
        assert(0 <= start && start <= end && end <= length());
        return _single_hash(0, start, end) + (HASH_COUNT > 1 ? _single_hash(1, start, end) << 32 : 0);
    }

    uint64_t complete_hash() const {
        return substring_hash(0, length());
    }

    uint64_t _reverse_single_hash(int h, int start, int end) const {
        assert(BUILD_REVERSE);
        // Convert everything to `uint64_t` for speed. Note: we add hash_pow[length] to fix strings that start with 0.
        uint64_t power = uint64_t(hash_pow[h][end - start]);
        return (power + uint64_t(_inv_prefix[h][end]) * power + HASH_P - uint64_t(_inv_prefix[h][start])) % HASH_P;
    }

    uint64_t reverse_substring_hash(int start, int end) const {
        assert(0 <= start && start <= end && end <= length());
        return _reverse_single_hash(0, start, end) + (HASH_COUNT > 1 ? _reverse_single_hash(1, start, end) << 32 : 0);
    }

    uint64_t reverse_complete_hash() const {
        return reverse_substring_hash(0, length());
    }

    bool equal(int start1, int start2, int length) const {
        return substring_hash(start1, start1 + length) == substring_hash(start2, start2 + length);
    }

    bool is_palindrome(int start, int end) const {
        return substring_hash(start, end) == reverse_substring_hash(start, end);
    }

    int compare(int start1, int start2, int max_length = INF) const;
};

uint64_t concat_hashes(uint64_t hash1, uint64_t hash2, int len2) {
    if (len2 == 0) return hash1;
    uint64_t hash1_low = hash1 & unsigned(-1);
    uint64_t hash2_low = hash2 & unsigned(-1);
    uint64_t power = uint64_t(hash_pow[0][len2]);
    uint64_t combined = (hash1_low * power + hash2_low + HASH_P - power) % HASH_P;

    if (HASH_COUNT > 1) {
        hash1 >>= 32;
        hash2 >>= 32;
        power = uint64_t(hash_pow[1][len2]);
        combined += (hash1 * power + hash2 + HASH_P - power) % HASH_P << 32;
    }

    return combined;
}

// uint64_t concat_hashes(uint64_t hash1, uint64_t hash2, int len2) {
//     if (len2 == 0) return hash1;

//     uint64_t hash1_low = hash1;
//     uint64_t hash2_low = hash2;

//     uint64_t power = uint64_t(hash_pow[0][len2]);
//     uint64_t combined = (hash1_low * power + hash2_low) % HASH_P;

//     if (HASH_COUNT > 1) {
//         hash1 >>= 32;
//         hash2 >>= 32;
//         power = uint64_t(hash_pow[1][len2]);
//         combined = (combined + (hash1 * power + hash2) % HASH_P << 32) % HASH_P;
//     }

//     return combined;
// }

using Info = pair<uint64_t, uint64_t>;

string_hash init(string(100001, 'a'));

class Solution {
public:
    vector<bool> findAnswer(vector<int>& par, string s) {
        int n = s.size();

        vector<vector<int>> adj(n);
        for (int i = 0; i < n; i++) {
            if (par[i] != -1) {
                adj[par[i]].push_back(i);
            }
        }

        vector<bool> ans(n);
        string_hash<string> hash;
        auto emp = hash.complete_hash();
        const auto dfs = [&](auto&& self, int cur) -> pair<Info, int> { // forward hash, rev hash
            Info res = pair(emp, emp);
            int cnt = 0;
            for (int nei : adj[cur]) {
                auto [h, sz] = self(self, nei);
                auto [f, r] = h;
                res.first = concat_hashes(res.first, f, sz);
                res.second = concat_hashes(r, res.second, cnt);
                cnt += sz;
            }
            auto cur_hash = hash.hash(string(1, s[cur]));
            res.first = concat_hashes(res.first, cur_hash, 1);
            res.second = concat_hashes(cur_hash, res.second, cnt);
            dbg(cur, cnt, res.first, res.second);
            cnt++;
            ans[cur] = (res.first == res.second);
            return pair(res, cnt);
        };
        dfs(dfs, 0);

        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::findAnswer); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1427913111
Thien-Phuoc Phung,phungthienphuoc,535,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res=len(s)*(len(s)+1)//2
        left=0
        d=Counter()
        for i,x in enumerate(s):
            d[x]+=1
            while d[x]>=k:
                res-=i-left
                d[s[left]]-=1
                left+=1
        return res-(len(s)-left)*(len(s)-left+1)//2",1427835439
Thien-Phuoc Phung,phungthienphuoc,535,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res=[]
        idx=0
        n=len(target)
        cur=''
        c=0
        while idx<n:
            ch=chr(c+ord('a'))
            res.append(cur+ch)
            if ch==target[idx]:
                idx+=1
                c=0
                cur+=ch
            else:
                c+=1
        return res",1427825483
Thien-Phuoc Phung,phungthienphuoc,535,3603,python3,"mod=10**9+7
ch={chr(ord('a')+i):i+1 for i in range(26)}
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        child=defaultdict(list)
        for i,x in enumerate(parent):
            if i!=0:
                child[x].append(i)
        
        n=len(parent)
        res=[True]*n
        
        def dfs(node):
            size=0
            cur1=cur2=0
            for x in child[node]:
                s1,s2,l=dfs(x)
                cur1=(cur1*pow(27,l,mod)+s1)%mod
                cur2=(cur2+s2*pow(27,size,mod))%mod
                size+=l
            cur1=(cur1*27+ch[s[node]])%mod
            cur2=(cur2+ch[s[node]]*pow(27,size,mod))%mod
            size+=1
            res[node]=(cur1==cur2)
            return cur1,cur2,size
        
        dfs(0)
        return res",1427915229
John Rigby,vanshkunwarji41,539,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int r=0;
        int a[26]={0};
        int i=0,j=0;
        int u=0;
        while(i<s.size()){
            while(j<s.size() && u==0){
                a[s[j]-'a']++;
                if(a[s[j]-'a']==k){
                    u++;
                }
                j++;
            }
            if(u){
                r+=s.size()-j+1;
            }
            a[s[i]-'a']--;
            if(a[s[i]-'a']==k-1){
                u--;
            }
            i++;
            if(i>j){
                i=j;
                memset(a,0,sizeof(a));u=0;
            }
        }
        return r;
    }
};",1427830744
John Rigby,vanshkunwarji41,539,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v={""a""};
        while(v.back()!=target){
            v.push_back(v.back());
            if(target[v.back().size()-1]!=v.back().back()){
                v.back().back()++;
            }
            else{
                v.back().push_back('a');
            }
        }
        return v;
    }
};",1427825274
John Rigby,vanshkunwarji41,539,3603,cpp,"class Solution {
public:
    int binpow(int x, int y, int M){
        int r=1;
        int z=x;
        if(z>=M){
            z-=M;
        }
        while(y){
            if(y&1){
                r=(1LL*r*z)%M;
            }
            z=(1LL*z*z)%M;
            y>>=1;
        }
        return r;
    }
    static const long long p1=999999751,p2=1000000033;
    long long c=69;
    long long p=71;
    void f(int i, vector<int> adj[], vector<pair<int,pair<long long,long long>>> &v,vector<pair<int,pair<long long,long long>>> &v2, vector<bool> &w,string &s){
        int l=1;
        long long z1=(s[i]-'a'+1+c)%p1;
        long long z2=(s[i]-'a'+1+c)%p2;
        for(auto j:adj[i]){
            f(j,adj,v,v2,w,s);
            v[i].second.first+=(1LL*v[j].second.first*binpow(p,v[i].first,p1))%p1;
            v[i].second.first%=p1;
            v[i].second.second+=(1LL*v[j].second.second*binpow(p,v[i].first,p2))%p2;
            v[i].second.second%=p2;
            v[i].first+=v[j].first;
        }
        for(int j=adj[i].size()-1;j>=0;j--){
            z1+=(1LL*v2[adj[i][j]].second.first*binpow(p,l,p1))%p1;
            z1%=p1;
            z2+=(1LL*v2[adj[i][j]].second.second*binpow(p,l,p2))%p2;
            z2%=p2;
            l+=v[adj[i][j]].first;
        }
        v[i].second.first+=(1LL*(s[i]-'a'+1+c)*binpow(p,v[i].first,p1))%p1;
        v[i].second.second+=(1LL*(s[i]-'a'+1+c)*binpow(p,v[i].first,p2))%p2;
        v[i].second.first%=p1;
        v[i].second.second%=p2;
        v[i].first++;
        if(z1==v[i].second.first && z2==v[i].second.second){
            w[i]=1;
        }
        v2[i].second.first =z1;
        v2[i].second.second=z2;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        vector<int> adj[n];
        for(int i=0;i<n;i++){
            if(parent[i]!=-1){
                adj[parent[i]].push_back(i);
            }
        }
        for(int i=0;i<n;i++){
            sort(adj[i].begin(),adj[i].end());
        }
        vector<pair<int,pair<long long,long long>>> v(n,{0,{0,0}});
        vector<pair<int,pair<long long,long long>>> v2(n,{0,{0,0}});
        vector<bool> w(n,0);
        f(0,adj,v,v2,w,s);
        return w;
    }
};",1427919179
Deepanshu Attri,Cipher_07,542,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for(int i = 0; i + k - 1 < s.size(); i++) {
            vector<int> cnt(26);
            // multiset<int> st;
            // for(int j = 0; j < 26; j++)
            //     st.insert(j);
            for(int j = i; j < s.size(); j++) {
                cnt[s[j] - 'a']++;
                if(*max_element(cnt.begin(), cnt.end()) >= k) {
                    while(*max_element(cnt.begin(), cnt.end()) >= k) {
                        cnt[s[i] - 'a']--;
                        i++;
                    }
                    cnt[s[i - 1] - 'a']++;
                    i--;
                    ans += i + 1;
                }
            }
        }

        return ans;
    }
};",1427845602
Deepanshu Attri,Cipher_07,542,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> all;
        string ans = """";
        for(char ch: target) {
            ans += 'a';
            while(ans.back() != ch) {
                all.push_back(ans);
                ans.back() = char(ans.back() + 1);
            }
            all.push_back(ans);
        }

        return all;
    }
};",1427825302
Deepanshu Attri,Cipher_07,542,3603,cpp,"class RabinKarp {
    bool multi_hash;
    vector<long long> pre1, pre2, pow1, pow2;
    static const long long BASE1 = 31, BASE2 = 37;
    static const long long MOD1 = 1e9 + 7, MOD2 = 1e9 + 21;
    int n;

    static long long binpow(long long a, long long b, long long m) {
        a %= m;
        long long res = 1;
        while (b > 0) {
            if (b & 1)
                res = res * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return res;
    }

public:
    RabinKarp(string& s, bool multi = 0) : n(s.size()), multi_hash(multi) {
        pre1.resize(n + 1);
        pow1.resize(n + 1, 1);

        if (multi_hash) {
            pre2.resize(n + 1);
            pow2.resize(n + 1, 1);
        }

        for (int i = 1; i <= n; i++) {
            pre1[i] = (pre1[i - 1] * BASE1 + (s[i - 1] - 'a' + 1)) % MOD1;
            pow1[i] = pow1[i - 1] * BASE1 % MOD1;
            if (multi_hash) {
                pre2[i] = (pre2[i - 1] * BASE2 + (s[i - 1] - 'a' + 1)) % MOD2;
                pow2[i] = pow2[i - 1] * BASE2 % MOD2;
            }
        }
    }

    static long long Hash1(string s) { // highest power on left
        long long h = 0;
        for (char ch : s) {
            h = (h * BASE1 % MOD1 + (ch - 'a' + 1)) % MOD1;
        }
        return h;
    }

    static long long Hash2(string s) { // highest power on left
        long long h = 0;
        for (char ch : s) {
            h = (h * BASE2 % MOD2 + (ch - 'a' + 1)) % MOD2;
        }
        return h;
    }

    long long get1(int i, int j) { // 0 based index
        return (pre1[j + 1] - pre1[i] * pow1[j - i + 1] % MOD1 + MOD1) % MOD1;
    }

    long long get2(int i, int j) { // 0 based index
        assert(multi_hash);
        return (pre2[j + 1] - pre2[i] * pow2[j - i + 1] % MOD2 + MOD2) % MOD2;
    }

    static vector<int> find_all_occ(string& text, string& pattern) {
        int n = text.size(), m = pattern.size();
        auto hp1 = Hash1(pattern);
        auto hp2 = Hash2(pattern);

        long long ht1 = 0, ht2 = 0;
        long long p1 = binpow(BASE1, m - 1, MOD1);
        long long p2 = binpow(BASE2, m - 1, MOD2);

        vector<int> match;

        for (int i = 0; i < n; i++) {
            if (i >= m) {
                ht1 = (ht1 - (text[i - m] - 'a' + 1) * p1 % MOD1 + MOD1) % MOD1;
                ht2 = (ht2 - (text[i - m] - 'a' + 1) * p2 % MOD2 + MOD2) % MOD2;
            }

            ht1 = (ht1 * BASE1 % MOD1 + (text[i] - 'a' + 1)) % MOD1;
            ht2 = (ht2 * BASE2 % MOD2 + (text[i] - 'a' + 1)) % MOD2;

            if (ht1 == hp1 && ht2 == hp2)
                match.push_back(i - m + 2);
        }

        return match;
    }
};

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> adj[n];
        for(int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);

        for(int i = 0; i < n; i++)
            sort(adj[i].begin(), adj[i].end());
        int timer = 0;
        vector<int> in(n), out(n), at(n);
        string order = """";
        function<void(int)> dfs = [&](int u) {
            in[u] = timer++;
            for(int v: adj[u]) {
                dfs(v);
            }
            order += s[u];
            at[order.size() - 1] = timer;
            out[u] = timer++;
        };

        dfs(0);

        RabinKarp rk(order);
        reverse(order.begin(), order.end());
        RabinKarp rk_rev(order);

        auto find_first = [&](int x) {
            int low = 0, high = n - 1, ans = -1;
            while(low <= high) {
                int mid = (low + high) / 2;
                if(at[mid] >= x) {
                    ans = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }

            assert(ans != -1);
            return ans;
        };

        auto find_last = [&](int x) {
            int low = 0, high = n - 1, ans = -1;
            while(low <= high) {
                int mid = (low + high) / 2;
                if(at[mid] <= x) {
                    ans = mid;
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }

            assert(ans != -1);
            return ans;
        };

        vector<bool> ans(n);
        for(int i = 0; i < n; i++) {
            int first = find_first(in[i]);
            int last = find_last(out[i]);
            int len = last - first + 1;
            if(len == 1) {
                ans[i] = 1;
            } else {
                auto h1 = rk.get1(first, first + len / 2 - 1);
                // len / 2 + 1, last
                auto h2 = rk_rev.get1(n - last - 1, n - (first + len / 2 + bool(len & 1)) - 1);
                ans[i] = (h1 == h2);
                // cout << first << "" "" << last << endl;
                // cout << first << "" "" << first + len / 2 - 1 << endl;
                // cout << first + len / 2 + bool(len & 1) << "" "" << last << endl;
            }
        }

        return ans;
    }
};",1427922023
thehunterjames,thehunterjames,543,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int ptr1 = 0, ptr2 = 0;
        int cnt[26];
        for (int i = 0; i < s.size(); i++) {
        memset(cnt, 0, sizeof(cnt));
            for (int j = i; j < s.size(); j++) {
                if (++cnt[s[j]-'a'] == k) {
                    ans += s.size() - j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427826220
thehunterjames,thehunterjames,543,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur = """";
        for (auto x : target) {
            cur += ""a"";
            ans.emplace_back(cur);
            while (cur[cur.size()-1]!=x) {
                cur[cur.size()-1]++;
                ans.emplace_back(cur);
            }
        }
        return ans;
    }
};",1427824003
thehunterjames,thehunterjames,543,3603,cpp,"
#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
class Solution {
public:
    string tot;
    vector<int> start, end;
    void dfs(int node, vector<vector<int>>& child, string &s) {
        start[node] = tot.size();
        for (auto x : child[node]) {
            dfs(x, child, s);
        }
        tot += s[node];
        end[node] = tot.size()-1;
    }

array<vector<int>, 2> manacher(const string& s) {
	int n = sz(s);
	array<vi,2> p = {vi(n+1), vi(n)};
	rep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {
		int t = r-i+!z;
		if (i<r) p[z][i] = min(t, p[z][l+t]);
		int L = i-p[z][i], R = i+p[z][i]-!z;
		while (L>=1 && R+1<n && s[L-1] == s[R+1])
			p[z][i]++, L--, R++;
		if (R>r) l=L, r=R;
	}
	return p;
}
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<bool> ans(n);
        start = vector<int>(n);
        end = vector<int>(n);
        vector<vector<int>> child(n);
        for (int i = 1; i < n; i++) {
            child[parent[i]].emplace_back(i);
        }
        tot = """";
        dfs(0, child, s);
        array<vector<int>, 2> blah = manacher(tot);
        cout<<tot<<endl;
        for (int i = 0; i < n; i++) {
            int l = start[i], r = end[i];
            // cout<<i<<' '<<l<<' '<<r<<endl;
            if ((r-l)%2==1) {
                //even
                if (blah[0][l+(r-l+1)/2] * 2 - 1 + l >= r) ans[i] = 1;
            }
            else {
                if (blah[1][l+(r-l+1)/2] * 2 + l >= r) ans[i] = 1;
            }
        }
        return ans;
    }
};",1427922682
Peter Lin,inversionpeter,544,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int counts = 0, haves[128], maximum, found, left, right, middle;
        for (int i = 0; i != s.size(); ++i) {
            memset(haves, 0, sizeof(haves));
            for (int j = i; j != s.size(); ++j) {
                ++haves[s[j]];
                if (haves[s[j]] >= k) {
                    counts += s.size() - j;
                    break;
                }
            }
            /*found = s.size();
            left = i, right = s.size();
            while (left <= right) {
                maximum = 0;
                memset(haves, 0, sizeof(haves));
                middle = (left + right) >> 1;
                for (int j = i; j < middle; ++j) {
                    ++haves[s[j]];
                    maximum = max(maximum, haves[s[j]]);
                }
                //cout << middle << "" -> "" << maximum << '\n';
                if (maximum < k) {
                    found = min(found, middle);
                    left = middle + 1;
                }
                else {
                    right = middle - 1;
                }
            }
            cout << found << '\n';
            counts += s.size() - found;*/
        }
        return counts;
    }
};",1427872785
Peter Lin,inversionpeter,544,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector <string> sequence;
        string buffer = """";
        for (char c : target) {
            buffer += 'a';
            sequence.push_back(buffer);
            while (buffer.back() != c) {
                ++buffer.back();
                sequence.push_back(buffer);
            }
        }
        return sequence;
    }
};",1427872569
Peter Lin,inversionpeter,544,3603,cpp,"int DP[300000] = { 1 };
vector <vector <int>> adjacencyList;
vector <pair <int, int>> intervals;
string postorder;

void DFS(string &s, int nowAt, int leftBound) {
    intervals[nowAt].first = leftBound;
    for (int neighbor : adjacencyList[nowAt]) {
        DFS(s, neighbor, postorder.size());
    }
    postorder += s[nowAt];
    intervals[nowAt].second = postorder.size() - 1;
}

void Manacher() {
    int bufferLength = (postorder.size() << 1) + 1;
    string buffer = string(bufferLength, '-');
    for (int i = 0; i != postorder.size(); ++i) {
        buffer[(i << 1) + 1] = postorder[i];
    }
    //cout << buffer << '\n';
    int left = 0, right = 0;
	for (int i = 1; i < bufferLength; i++) {
		DP[i] = (right > i) ? min(DP[(left << 1) - i], right - i) : 1;
		while (i - DP[i] >= 0 && i + DP[i] < bufferLength && buffer[i - DP[i]] == buffer[i + DP[i]]) {
			++DP[i];
        }
		if (i + DP[i] > right) {
			left = i;
            right = i + DP[i];
        }
	}
}

bool IsPalindrome(int left, int right) {
    left = (left << 1) + 1;
    right = (right << 1) + 1;
    int middle = (left + right) >> 1;
    return (middle - left + 1) <= DP[middle];
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        vector <bool> answers(s.size());
        intervals.clear(); intervals.resize(s.size());
        adjacencyList.clear(); adjacencyList.resize(s.size());
        for (int i = 1; i != s.size(); ++i) {
            adjacencyList[parent[i]].push_back(i);
        }
        postorder = """";
        DFS(s, 0, 0);
        Manacher();
        /*for (int i = 0; i != (s.size() << 1) + 1; ++i) {
            cout << DP[i];
        }
        cout << '\n';*/
        for (int i = 0; i != s.size(); ++i) {
            //cout << intervals[i].first << ' ' << intervals[i].second << '\n';
            answers[i] = IsPalindrome(intervals[i].first, intervals[i].second);
        }
        return answers;
    }
};",1427922881
krishnanshu19,krishnanshu19,545,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans= 0;
        for(int i=0;i<n;i++)
        {
            int j=i;
            vector<int> ct(26,0);
            for(;j>=0;j--)
            {
                ct[s[j]-'a']++;
                if(ct[s[j]-'a']==k) break;
            }
            ans+=j+1;
        }
        return ans;
    }
};",1427844732
krishnanshu19,krishnanshu19,545,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string temp ="""";
        int sz = 0;
        for(auto x: target)
        {
            int last = 0;
            temp+=char('a'+last);
            ans.push_back(temp);
            while(char('a'+last)!=x)
            {
                last++;
                temp.pop_back();
                temp+=char('a'+last);
                ans.push_back(temp);
            }
        }
        return ans;
    }
};",1427833681
krishnanshu19,krishnanshu19,545,3603,cpp,"class Solution {
public:
    using ll = long long;
    const ll p= 97, MOD = 1e9+7;
    ll power(ll x, ll y, ll m)
    {
        if(y==0) return 1;
        ll q = power(x, y/2,m);
        q=(q*q)%MOD;
        if(y%2!=0) q = (q*x)%MOD;
        return q;
    }
    void dfs(int i, vector<vector<int>>& adj, vector< pair<int,int>>& m, string& s, string& order)
    {
        int j = order.size();
        for(auto x: adj[i]) dfs(x, adj, m,s,order);
        order.push_back(s[i]);
        m[i] = {j, order.size()-1};
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = s.size();
        vector<vector<int>> adj(n, vector<int>());
        for(int i=1;i<n;i++)
        {
            adj[parent[i]].push_back(i);
        }
        for(int i=0;i<n;i++)
        {
            sort(adj[i].begin(), adj[i].end());
        }
        string order="""";
        vector<pair<int,int>> m(n, pair<int,int> ());
        dfs(0,adj,m,s,order);

        vector<pair<ll,ll>> pref(n+1, {0,0}), suf(n+1,{0,0});

        pref[0] = {0,1};
        for(int i=1;i<=n;i++)
        {

            pref[i].second = (pref[i-1].second*p)%MOD;
            pref[i].first = ((pref[i].second*(order[i-1]-'a'+1))%MOD + pref[i-1].first)%MOD;
        }
        suf[n] = {0,1};
        for(int i=n-1;i>=0;i--)
        {
            suf[i].second = (suf[i+1].second*p)%MOD;
            suf[i].first = ((suf[i].second*(order[i]-'a'+1))%MOD + suf[i+1].first)%MOD;
        }

        vector<bool> ans;
        // cout<<order<<endl;
        for(int i=0;i<n;i++)
        {
            // cout<<i<<"" ""<<m[i].first<<"" ""<<m[i].second<<endl;
            ans.push_back(check(pref, suf, m[i].first, m[i].second));
        }
        return ans;        
    }
    
    ll MMI(ll x)
    {
        return power(x, MOD-2, MOD);
    }
    bool check(vector<pair<ll,ll>>& pref, vector<pair<ll,ll>>& suf, int i, int j)
    {
        int n = pref.size()-1;
        ll ha = (((pref[j+1].first-pref[i].first+MOD)%MOD) * MMI(pref[i+1].second))%MOD;
        ll rha = (((suf[i].first - suf[j+1].first+MOD)%MOD) * MMI(suf[j].second))%MOD;
        return ha==rha;
    }

};",1427924117
asrivastava05,asrivastava05,546,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int ans = 0;
        for(int i = 0; i < s.size();i++){
            vector<int> freq(26);
            bool seen = false;
            for(int j = i; j < s.size();j++){
                freq[s[j] - 'a']++;
                if(seen || freq[s[j] - 'a'] >= k){
                    ans++;
                    seen = true;
                }
            }
        }
        return ans;
    }
};",1427828779
asrivastava05,asrivastava05,546,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur;
        vector<string> ans;
        for(int i = 0; i < target.size();i++){
            for(char j = 'a'; j <= 'z';j++){
                cur.push_back(j);
                ans.push_back(cur);
                if(j == target[i]){
                    break;
                }
                cur.pop_back();
            }
        }
        return ans;
    }
};",1427824868
asrivastava05,asrivastava05,546,3603,cpp,"class Solution {
public:
    #define ll long long
    vector<long long> manacher(string& t) {
        string s{'$'};
        for(char& c: t) s += string{'#', c};
        s += string{'#', '^'};
    
        int n = s.size() - 2, l = 1, r = 1;
        vector<long long> p(n + 2);
        for(long long i = 1; i <= n; i++) {
            p[i] = max(0ll, min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]])
                p[i]++;
            if(i + p[i] > r)
                l = i - p[i], r = i + p[i];
            p[i]--;
        }
        return vector<long long>(begin(p) + 2, end(p) - 2);
    }

    bool is_palindrome(vector<long long>& man, int l, int r) {
        return man[l + r] >= r - l + 1;
    }

    void dfs(int i, int p, string &s, string &cur, vector<int> &sub, vector<vector<int>> &adj){
        sub[i] = 1;
        for(int u: adj[i]) if(u != p){
            dfs(u, i, s, cur, sub, adj);
            cur.push_back(s[u]);
            sub[i] += sub[u];
        }
    }

    void dfs2(int i, int p, int l, vector<bool> &ans, vector<int> &sub, vector<long long> &man, vector<vector<int>> &adj){
        int cur = l;
        for(int u: adj[i]) if(u != p){
            ans[u] = is_palindrome(man, cur, cur + sub[u] - 1);
            dfs2(u, i, cur, ans, sub, man, adj);
            cur = cur + sub[u];
        }
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        // by subtree sizes we know what part of the string created by dfs(0)
        int n = s.size();
        vector<vector<int>> adj(n);
        for(int i = 0; i < n;i++){
            if(parent[i] != -1){
                adj[parent[i]].push_back(i);
                adj[i].push_back(parent[i]);
            }
        }
        for(int i = 0; i < n;i++){
            sort(adj[i].begin(), adj[i].end());
        }
        string res = """";
        vector<int> sub(n);
        dfs(0, -1, s, res, sub, adj);
        res.push_back(s[0]);
        vector<long long> man = manacher(res);
        vector<bool> ans(n);
        cout << res << '\n';
        ans[0] = is_palindrome(man, 0, n - 1);
        dfs2(0, -1, 0, ans, sub, man, adj);
        return ans;
    }
};  

/*
    0
   2
  1
 3   
*/
",1427908241
atm314,atm314,547,3502,cpp,"using i8 = int8_t;
using u8 = uint8_t;
using i16 = int16_t;
using u16 = uint16_t;
using i32 = int32_t;
using u32 = uint32_t;
using i64 = int64_t;
using u64 = uint64_t;

using f32 = float;
using f64 = double;

#define all(x) (x).begin(), (x).end()
#define ll long long int
#define VI vector<ll>
#define VVI vector<VI>

#define ISD true
#define debug(x) \
    if (ISD)     \
    cout << #x << "": "" << x << endl
#define DEBUG(x) cout << #x << "": "" << x << endl

template <typename C>
i64 SIZE(const C &c)
{
    return static_cast<i64>(c.size());
}

template <typename T, size_t N>
i64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }

template <typename T, typename U, typename Comp = less<>>
bool chmax(T &xmax, const U &x, Comp comp = {})
{
    if (comp(xmax, x))
    {
        xmax = x;
        return true;
    }
    return false;
}

template <typename T, typename U, typename Comp = less<>>
bool chmin(T &xmin, const U &x, Comp comp = {})
{
    if (comp(x, xmin))
    {
        xmin = x;
        return true;
    }
    return false;
}

#define CPP_STR(x) CPP_STR_I(x)
#define CPP_CAT(x, y) CPP_CAT_I(x, y)
#define CPP_STR_I(args...) #args
#define CPP_CAT_I(x, y) x##y

#define ASSERT(expr...) assert((expr))

// }}}

constexpr i64 INF = 1'010'000'000'000'000'017LL;

constexpr i64 MOD = 998244353LL;

constexpr f64 EPS = 1e-12;

constexpr f64 PI = 3.14159265358979323846;

#define M5 100007
#define M9 1000000000

#define F first
#define S second

// util {{{
#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)
#define REP(i, n) FOR(i, 0, n)

class Solution
{
public:
    int numberOfSubstrings(string s, int k)
    {
        int N = s.size();
        int ans = 0;
        REP(i, N)
        {
            map<char, int> MP;
            bool isOK = false;
            FOR(j, i, N)
            {
                MP[s[j]]++;
                if (MP[s[j]] >= k)
                {
                    isOK = true;
                }
                if (isOK)
                {
                    ans++;
                }
            }
        }
        return ans;
    }
};",1427831423
atm314,atm314,547,3566,cpp,"using i8 = int8_t;
using u8 = uint8_t;
using i16 = int16_t;
using u16 = uint16_t;
using i32 = int32_t;
using u32 = uint32_t;
using i64 = int64_t;
using u64 = uint64_t;

using f32 = float;
using f64 = double;

#define all(x) (x).begin(), (x).end()
#define ll long long int
#define VI vector<ll>
#define VVI vector<VI>

#define ISD true
#define debug(x) \
    if (ISD)     \
    cout << #x << "": "" << x << endl
#define DEBUG(x) cout << #x << "": "" << x << endl

template <typename C>
i64 SIZE(const C &c)
{
    return static_cast<i64>(c.size());
}

template <typename T, size_t N>
i64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }

template <typename T, typename U, typename Comp = less<>>
bool chmax(T &xmax, const U &x, Comp comp = {})
{
    if (comp(xmax, x))
    {
        xmax = x;
        return true;
    }
    return false;
}

template <typename T, typename U, typename Comp = less<>>
bool chmin(T &xmin, const U &x, Comp comp = {})
{
    if (comp(x, xmin))
    {
        xmin = x;
        return true;
    }
    return false;
}

#define CPP_STR(x) CPP_STR_I(x)
#define CPP_CAT(x, y) CPP_CAT_I(x, y)
#define CPP_STR_I(args...) #args
#define CPP_CAT_I(x, y) x##y

#define ASSERT(expr...) assert((expr))

// }}}

constexpr i64 INF = 1'010'000'000'000'000'017LL;

constexpr i64 MOD = 998244353LL;

constexpr f64 EPS = 1e-12;

constexpr f64 PI = 3.14159265358979323846;

#define M5 100007
#define M9 1000000000

#define F first
#define S second

// util {{{
#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)
#define REP(i, n) FOR(i, 0, n)

class Solution
{
public:
    vector<string> stringSequence(string target)
    {
        vector<string> ans;
        string s = """";
        for (auto t : target)
        {
            REP(i, t - 'a' + 1)
            {
                char x = 'a' + i;
                ans.push_back(s + x);
            }
            s += t;
        }
        return ans;
    }
};",1427825472
atm314,atm314,547,3603,cpp,"
using i8 = int8_t;
using u8 = uint8_t;
using i16 = int16_t;
using u16 = uint16_t;
using i32 = int32_t;
using u32 = uint32_t;
using i64 = int64_t;
using u64 = uint64_t;

using f32 = float;
using f64 = double;

#define all(x) (x).begin(), (x).end()
#define ll long long int
#define VI vector<ll>
#define VVI vector<VI>

#define ISD true
#define debug(x) \
    if (ISD)     \
    cout << #x << "": "" << x << endl
#define DEBUG(x) cout << #x << "": "" << x << endl

template <typename C>
i64 SIZE(const C &c)
{
    return static_cast<i64>(c.size());
}

template <typename T, size_t N>
i64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }

template <typename T, typename U, typename Comp = less<>>
bool chmax(T &xmax, const U &x, Comp comp = {})
{
    if (comp(xmax, x))
    {
        xmax = x;
        return true;
    }
    return false;
}

template <typename T, typename U, typename Comp = less<>>
bool chmin(T &xmin, const U &x, Comp comp = {})
{
    if (comp(x, xmin))
    {
        xmin = x;
        return true;
    }
    return false;
}

#define CPP_STR(x) CPP_STR_I(x)
#define CPP_CAT(x, y) CPP_CAT_I(x, y)
#define CPP_STR_I(args...) #args
#define CPP_CAT_I(x, y) x##y

#define ASSERT(expr...) assert((expr))

// }}}

constexpr i64 INF = 1'010'000'000'000'000'017LL;

constexpr i64 MOD = 998244353LL;

constexpr f64 EPS = 1e-12;

constexpr f64 PI = 3.14159265358979323846;

#define M5 100007
#define M9 1000000000

#define F first
#define S second

// util {{{
#define FOR(i, start, end) for (i64 i = (start), CPP_CAT(i, xxxx_end) = (end); i < CPP_CAT(i, xxxx_end); ++i)
#define REP(i, n) FOR(i, 0, n)

class Manacher
{
public:
    Manacher(const std::string &s)
    {
        n = s.size();
        m = 2 * n + 1;
        d.assign(m, '&');
        r.assign(m, 0);

        for (int i = 0; i < n; ++i)
        {
            d[2 * i + 1] = s[i];
        }
        make_r();
    }

    // Check if the substring s[start:end) is a palindrome
    bool judge(int start, int end)
    {
        int center = start + end;
        return (2 * end - 1) < (center + r[center]);
    }

private:
    int n, m;
    std::vector<char> d; // Transformed string with separators
    std::vector<int> r;  // Radius array

    void make_r()
    {
        int i = 0, j = 0;
        while (i < m)
        {
            while (j <= i && i + j < m && d[i - j] == d[i + j])
            {
                ++j;
            }
            r[i] = j;
            int k = 1;
            while (k <= i && i + k < m && k + r[i - k] < j)
            {
                r[i + k] = r[i - k];
                ++k;
            }
            i += k;
            j -= k;
        }
    }
};

class Solution
{
public:
    vector<bool> findAnswer(vector<int> &parent, string s)
    {
        int N = s.size();
        vector<vector<int>> G(N);
        FOR(i, 1, N)
        {
            G[parent[i]].push_back(i);
        }
        string x;
        vector<int> in(N), out(N);
        vector<int> t, p;
        int ind = 0;
        function<void(int)> dfs = [&](int v)
        {
            in[v] = ind;
            t.push_back(v);
            p.push_back(x.size());
            ind++;
            for (auto g : G[v])
            {
                dfs(g);
                t.push_back(v);
                p.push_back(x.size());
                ind++;
            }
            out[v] = ind;
            x.push_back(s[v]);
        };
        dfs(0);
        Manacher M(x);
        /*REP(i, N)
        {
            cout << in[i] << "" "";
        }
        cout << endl;
        REP(i, N)
        {
            cout << out[i] << "" "";
        }
        cout << endl;
        for (auto t0 : t)
        {
            cout << t0 << "" "";
        }
        cout << endl;
        for (auto p0 : p)
        {
            cout << p0 << "" "";
        }
        cout << endl;
        cout << x << endl;*/
        vector<bool> ans(N);
        REP(i, N)
        {
            int l = p[in[i]];
            int r = p[out[i] - 1];
            //            cout << l << "" "" << r << endl;
            ans[i] = M.judge(l, r + 1);
        }
        return ans;
    }
};",1427925542
faith66,faith66,548,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int count=0;
        for(int i=0;i<s.length();i++){
            vector<int>freq(26,0);
            int maxCount=0;
            for(int j=i;j<s.length();j++){
                freq[s[j]-'a']++;
                maxCount=max(maxCount,freq[s[j]-'a']);
                if(maxCount>=k) count++;
            }
        }
        return count;
    }
};",1427854398
faith66,faith66,548,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for (char targetChar : target) {
            s += 'a';
            ans.push_back(s);
            while (s.back() != targetChar) {
                s.back()++;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427833152
faith66,faith66,548,3603,cpp,"class Solution {
public:
// Constants for the polynomial hash
const int BASE1 = 31;
const int MOD1 = 1e9 + 7;
const int BASE2 = 37;
const int MOD2 = 1e9 + 9;

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
    vector<vector<int>> children(n);
    vector<bool> answer(n, false);
    string dfsStr;

    // Build the adjacency list
    for (int i = 1; i < n; ++i) {
        children[parent[i]].push_back(i);
    }

    vector<int> start(n), end(n); // Arrays to store start and end indices for each node
    int idx = 0;

    // Recursive DFS function
    function<void(int)> dfs = [&](int x) {
        start[x] = idx; // Record the start index for node x
        for (int y : children[x]) {
            dfs(y);
        }
        dfsStr.push_back(s[x]);
        end[x] = idx;   // Record the end index for node x
        ++idx;
    };

    // Perform a single DFS from the root node (0)
    dfs(0);

    int m = dfsStr.size();
    vector<long long> prefixHash1(m + 1, 0), suffixHash1(m + 1, 0);
    vector<long long> prefixHash2(m + 1, 0), suffixHash2(m + 1, 0);
    vector<long long> power1(m + 1, 1), power2(m + 1, 1);

    // Precompute powers of the bases
    for (int i = 1; i <= m; ++i) {
        power1[i] = (power1[i - 1] * BASE1) % MOD1;
        power2[i] = (power2[i - 1] * BASE2) % MOD2;
    }

    // Calculate prefix hashes
    for (int i = 0; i < m; ++i) {
        prefixHash1[i + 1] = (prefixHash1[i] * BASE1 + (dfsStr[i] - 'a' + 1)) % MOD1;
        prefixHash2[i + 1] = (prefixHash2[i] * BASE2 + (dfsStr[i] - 'a' + 1)) % MOD2;
    }

    // Calculate suffix hashes
    for (int i = m - 1; i >= 0; --i) {
        suffixHash1[i] = (suffixHash1[i + 1] * BASE1 + (dfsStr[i] - 'a' + 1)) % MOD1;
        suffixHash2[i] = (suffixHash2[i + 1] * BASE2 + (dfsStr[i] - 'a' + 1)) % MOD2;
    }

    // Function to check if a substring [l, r] is a palindrome using hashes
    auto isPalindrome = [&](int l, int r) {
        long long hash1Forward = (prefixHash1[r + 1] - (prefixHash1[l] * power1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        long long hash1Backward = (suffixHash1[l] - (suffixHash1[r + 1] * power1[r - l + 1]) % MOD1 + MOD1) % MOD1;
        long long hash2Forward = (prefixHash2[r + 1] - (prefixHash2[l] * power2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        long long hash2Backward = (suffixHash2[l] - (suffixHash2[r + 1] * power2[r - l + 1]) % MOD2 + MOD2) % MOD2;
        return (hash1Forward == hash1Backward) && (hash2Forward == hash2Backward);
    };

    // Iterate over each node and check if its substring in dfsStr is a palindrome
    for (int i = 0; i < n; ++i) {
        answer[i] = isPalindrome(start[i], end[i]);
    }

    return answer;
    }
};",1427911803
Albert_Zhang,Albert_Zhang,549,3502,python3,"import collections
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        totalCount = 0
        n = len(s)
        for leftIdx in range(n):
            counts = collections.Counter()
            succeeds = False #  [leftIdx, rightIdx]
            for rightIdx in range(leftIdx, n):
                # print(leftIdx, rightIdx)
                if succeeds:
                    totalCount += 1
                    continue
                counts[s[rightIdx]] += 1
                if counts[s[rightIdx]] >= k:
                    # print(""win"", leftIdx, rightIdx)
                    succeeds = True
                    totalCount += 1
                    continue
        return totalCount",1427835047
Albert_Zhang,Albert_Zhang,549,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        strings = []
        for j, char in enumerate(target):
            for i in range(ord(""a""), ord(char) + 1):
                strings.append(target[:j] + chr(i))
        return strings",1427826439
Albert_Zhang,Albert_Zhang,549,3603,python3,""""""" === Method 1. postorder tree traversal and Manacher's algorithm
""""""
import collections
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        adjacencyList = self.getGraph(parent)
        # get the start and end position of each node
        nodeToIdxs = {}
        chars = []
        self.dfsGetChars(0, -1, adjacencyList, s, chars, nodeToIdxs)

        # manachar's algorithm
        string = """".join(chars)
        p, t = manacher(string)
        n = len(parent)
        results = [False] * n
        for node in range(n):
            startIdx, endIdx = nodeToIdxs[node]
            results[node] = is_palindrome_query(p, t, startIdx, endIdx)
        return results



    def getGraph(self, parents):
        n = len(parents)
        adjacencyList = [[] for _ in range(n)]
        for node, parent in enumerate(parents):
            if parent == -1:
                continue
            adjacencyList[node].append(parent)
            adjacencyList[parent].append(node)
        return adjacencyList

    def dfsGetChars(self, node, parent, adjacencyList, s, chars, nodeToIdxs):
        startIdx = len(chars)
        for neighbor in adjacencyList[node]:
            if neighbor == parent:
                continue
            self.dfsGetChars(neighbor, node, adjacencyList, s, chars, nodeToIdxs)
        endIdx = len(chars)
        chars.append(s[node])
        nodeToIdxs[node] = (startIdx, endIdx)


def manacher(s):
    # Preprocess the string to handle even-length palindromes
    t = '#' + '#'.join(s) + '#'
    n = len(t)
    p = [0] * n  # Array to store the radius of the longest palindrome centered at each position
    center = 0
    right = 0

    for i in range(n):
        mirror = 2 * center - i  # Mirror of the current position i with respect to the center

        if i < right:
            p[i] = min(right - i, p[mirror])  # Use previously calculated value if within the right boundary

        # Expand around the center i
        a = i + p[i] + 1
        b = i - p[i] - 1
        while a < n and b >= 0 and t[a] == t[b]:
            p[i] += 1
            a += 1
            b -= 1

        # Update the center and right boundary if the palindrome around i expands beyond the current right boundary
        if i + p[i] > right:
            center = i
            right = i + p[i]

    return p, t

def is_palindrome_query(p, t, l, r):
    # Translate original indices [l, r] to indices in the preprocessed string
    start = 2 * l + 1  # Position of l in the preprocessed string
    end = 2 * r + 1  # Position of r in the preprocessed string

    # Find the center and radius of the palindrome that covers [start, end]
    center = (start + end) // 2
    length = end - start + 1

    # Check if the palindrome centered at 'center' can cover the substring [start, end]
    return p[center] >= length // 2",1427930780
Terry,tttyyy49,550,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int res = 0;
        for (int i = 0; i < s.length(); ++i) {
            int[] f = new int[26];
            for (int j = i; j < s.length(); ++j) {
                int c = s.charAt(j) - 'a';
                ++f[c];
                if (f[c] == k) {
                    res += s.length() - j;
                    break;
                }
            }
        }
        return res;
    }
}",1427830674
Terry,tttyyy49,550,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        String s = """";
        for (char c : target.toCharArray()) {
            for (char x = 'a'; x <= c; ++x) {
                res.add(s + Character.toString(x));
            }
            s += Character.toString(c);
        }
        return res;
    }
}",1427826222
Terry,tttyyy49,550,3603,java,"class Solution {
    private static final long MOD = 911382323;
    private static final int N = 26;
    
    String s;
    
    public boolean[] findAnswer(int[] parent, String s) {
        this.s = s;
        int n = parent.length;
        
        Map<Integer, List<Integer>> g = new HashMap<>();
        for (int i = 0; i < n; ++i) {
            g.put(i, new ArrayList<>());
        }
        for (int i = 1; i < n; ++i) {
            g.get(parent[i]).add(i);
        }
        
        long[] postOrder = new long[n];
        long[] preOrder = new long[n];
        
        postOrder(0, g, postOrder);
        preOrder(0, g, preOrder);
        
        // System.out.println(postOrder[0]);
        // System.out.println(preOrder[0]);
        
        boolean[] res = new boolean[n];
        for (int i = 0; i < n; ++i) {
            res[i] = (postOrder[i] == preOrder[i]);
        }
        return res;
    }
    
//     String postOrder(int cur, Map<Integer, List<Integer>> g, String[] postOrder) {
//         String res = """";
//         for (int next : g.get(cur)) {
//             res += postOrder(next, g, postOrder);
//         }
//         res += Character.toString(s.charAt(cur));
//         postOrder[cur] = res;
//         return res;
//     }
    
//     String preOrder(int cur, Map<Integer, List<Integer>> g, String[] preOrder) {
//         String res = """";
//         res += Character.toString(s.charAt(cur));
//         for (int i = g.get(cur).size() - 1; i >= 0; --i) {
//             res += preOrder(g.get(cur).get(i), g, preOrder);
//         }
//         preOrder[cur] = res;
//         return res;
//     }
    
    Result postOrder(int cur, Map<Integer, List<Integer>> g, long[] postOrder) {
        long hash = 0;
        int cnt = 1;
        
        for (int next : g.get(cur)) {
            Result r = postOrder(next, g, postOrder);
            hash = (hash * modpow(N, r.length)) % MOD;
            hash = (hash + r.hash) % MOD;
            cnt += r.length;
        }
        
        hash = (hash * N + s.charAt(cur) - 'a') % MOD;
        postOrder[cur] = hash;
        return new Result(cnt, hash);
    }
    
    Result preOrder(int cur, Map<Integer, List<Integer>> g, long[] preOrder) {
        long hash = s.charAt(cur) - 'a';
        int cnt = 1;
        
        for (int i = g.get(cur).size() - 1; i >= 0; --i) {
            Result r = preOrder(g.get(cur).get(i), g, preOrder);
            hash = (hash * modpow(N, r.length)) % MOD;
            hash = (hash + r.hash) % MOD;
            cnt += r.length;
        }
        preOrder[cur] = hash;
        return new Result(cnt, hash);
    }
    
    private long modpow(long base, int pow) {
        long result = 1;
        while (pow > 0) {
            if (pow % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            pow = pow / 2;
        }
        return result;
    }
}

class Result {
    int length = 0;
    long hash = 0;
    
    Result(int length, long hash) {
        this.length = length;
        this.hash = hash;
    }
}",1427931119
AndyLead,AndyLead,552,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        map<char, int> counts;
        int result = 0, count_more = 0;
        for(int l = 0, r = 0; l < s.size();) {
            while(r < s.size() and count_more == 0) {
                counts[s[r]]++;
                if(counts[s[r]] == k) count_more++;
                r++;
            }

            if(count_more > 0) result += s.size() - (r - 1);

            if(counts[s[l]] == k) count_more--;
            counts[s[l]]--;
            l++;
        }
        return result;
    }
};",1427838412
AndyLead,AndyLead,552,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string curr;
        vector<string> result;
        for(int i = 0; i < target.size(); i++) {
            curr += 'a';
            result.push_back(curr);
            while(curr[i] != target[i]) {
                curr[i]++;
                result.push_back(curr);
            }
        }
        return result;
    }
};",1427824778
AndyLead,AndyLead,552,3603,cpp,"class Solution {
    vector<vector<int>> children;
    vector<int> sizes, evens, odds;
    string total, s;
    vector<bool> answer;

    void palindromes (string& s)
    {
        auto equal = [&s](int i, int j) { return i >= 0 and j < s.size() and s[i] == s[j]; };

        for (int i = 0, l, r = i, L, R; i < s.size(); i++) {
            if (i < r) odds[i] = min(r - i, odds[l + r - i]);
            for (L = i - odds[i], R = i + odds[i]; equal(L, R); odds[i]++, R++, L--);
            if (R > r) r = R, l = L;
        }

        for (int i = 1, l, r = i, L, R; i < s.size(); i++) {
            if (i < r) evens[i] = min(r - i, evens[l + r - i]);
            for (L = i - evens[i], R = i + evens[i]; equal(L - 1, R); evens[i]++, R++, L--);
            if (R > r) r = R, l = L;
        }
    }

    void dfs(int node) {
        sizes[node] = 1;
        for(auto& c : children[node]) {
            dfs(c);
            sizes[node] += sizes[c];
        }
        total += s[node];
    }

    bool isPalindrome(int start, int finish) {
        bool isEven = (finish - start) % 2 == 1;
        int middle = (start + finish) / 2;
        if(isEven) {
            middle++;
            return middle + evens[middle] > finish and middle - evens[middle] <= start;
        } else {
            return middle + odds[middle] > finish and middle - odds[middle] < start;
        }
    }

    void fillAnswer(int node, int start, int finish) {
        answer[node] = isPalindrome(start, finish);
        for(auto& c : children[node]) {
            int size = sizes[c];
            fillAnswer(c, start, start + size - 1);
            start += size;
        }
    }

public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        this->s = s;
        int n = s.size();
        children.resize(n);
        answer.resize(n);
        sizes.resize(n);
        evens.resize(n), odds.resize(n);

        for(int i = 1; i < parent.size(); i++) children[parent[i]].push_back(i);
        for(auto& c: children) ranges::sort(c);
        dfs(0);
        palindromes(total);
        fillAnswer(0, 0, n - 1);
        return answer;
    }
};",1427931346
kasi nathan,kasinathansj,553,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans = 0;
        for(int i = 0 ; i < s.length() ; i++){
            int fre[] = new int[26];
            boolean flag = false;
            for(int j = i ; j < s.length() ; j++){
                fre[s.charAt(j)-'a']++;
                if(fre[s.charAt(j)-'a']>=k||flag){
                    ans++;
                    flag = true;
                }
            }
        }
        return ans;
    }
}",1427827484
kasi nathan,kasinathansj,553,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        ArrayList<String> al = new ArrayList<>();
        String s = """";
        for(int i = 0 ; i < target.length() ; i++){
            char c = target.charAt(i);
            for(char cc = 'a' ; cc <= c ; cc++){
                al.add(s+""""+cc);
            }
            s+=c;
        }
        return al;
    }
}",1427824715
kasi nathan,kasinathansj,553,3603,java,"class Solution {
    public boolean[] findAnswer(int[] parent, String s) {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for(int i = 0 ; i < s.length() ; i++){
            adj.add(new ArrayList<>());
        }
        for(int i = 0 ; i < parent.length ; i++){
            if(parent[i]!=-1){
                adj.get(parent[i]).add(i);
            }
        }
        ArrayList<int[]> range = new ArrayList<>();
        for(int i = 0 ; i < s.length() ; i++){
            range.add(new int[]{-1,-1});
        }
        boolean ans[] = new boolean[s.length()];
        StringBuilder sb = new StringBuilder();
        rec(0,adj,range,s,sb,0);
        String s1 = sb.toString();
        sb.reverse();
        String s2 = sb.toString();
        RollingHash r1 = new RollingHash(s1);
        RollingHash r2 = new RollingHash(s2);
        int p = 0;
        for(int a[] : range){
            int nf = a[0];
            int ns = a[1];
            int rf = sb.length()-nf-1;
            int rs = sb.length()-ns-1;
            long h1 = r1.getHash(nf,ns);
            long h2 = r2.getHash(rs,rf);
            if(h1==h2){
                ans[p++] = true;
            }else{
                ans[p++] = false;
            }
        }
        return ans;
    }
    private void rec(int node , ArrayList<ArrayList<Integer>> adj ,ArrayList<int[]> range , String s , StringBuilder sb , int st){
        for(int i : adj.get(node)){
            rec(i,adj,range,s,sb,sb.length());
        }
        sb.append(s.charAt(node));
        range.set(node,new int[]{st,sb.length()-1});
    }
}

class RollingHash {
    String s;
    int n;
    long power[];
    long hash[];
    long mod = (long)1e9+7;
    long prime = 31;
    RollingHash(String s){
        this.s = s;
        this.n = s.length();
        this.power = new long[n+1];
        this.hash = new long[n+1];
        power[0] = 1;
        for(int i = 1 ; i <= n ; i++){
            power[i] = (power[i-1]*prime)%mod;
        }
        hash[0] = s.charAt(0);
        for(int i = 1 ; i < n ; i++){
            hash[i] = (hash[i-1]*prime + s.charAt(i))%mod;
        }
    }

    long getHash(int l , int r){
        if(l==0)return hash[r];
        else{
            return (mod + hash[r]-(hash[l-1]*power[r-l+1]+mod)%mod)%mod;
        }
    }
}",1427923257
Daksh,daksh_02,554,3502,java,"class Solution {
    public int numberOfSubstrings(String t, int K) {
        int n = t.length(),res = 0;
        char s[] = t.toCharArray();
        
        int pre[][] = new int[n+1][26];
        
        for(int i = 0; i<n; i++){
            for(int j = 0; j<26; j++){
                pre[i+1][j] = pre[i][j] + (s[i]-'a' == j?1:0);
            }
        }
        
        for(int i = 0; i<n; i++){
            for(int j = 0; j<n; j++){
                boolean flag = false; 
                for(int k = 0; k<26; k++){
                    if(pre[j+1][k]-pre[i][k] >= K){
                        res++; break;
                    }
                }
            }
        }
        
        return res;
    }
}",1427852001
Daksh,daksh_02,554,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> result = new ArrayList<>();
        StringBuilder current = new StringBuilder(); // Stores the current string state
        
        for (char c : target.toCharArray()) {
            // Append 'a' first using Key 1
            current.append('a');
            result.add(current.toString());
            
            // Use Key 2 to modify the last character until it matches the target character
            while (current.charAt(current.length() - 1) != c) {
                char lastChar = current.charAt(current.length() - 1);
                current.setCharAt(current.length() - 1, (char) (lastChar + 1)); // Increment the last character
                result.add(current.toString());
            }
        }
        
        return result;
    }
}",1427842239
Daksh,daksh_02,554,3603,java,"class Solution {
    ArrayList<Integer> list = new ArrayList<>();
    int[] dp;
    private int[] P; 
    ArrayList<ArrayList<Integer>> tree = new ArrayList<>(); 
    
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length; 
        dp = new int[n];
        
        for(int i = 0; i<n; i++){
            tree.add(new ArrayList<Integer>());
        }
        
        for(int i = 1; i<n; i++){
            tree.get(parent[i]).add(i);
        }
        
        for(int i = 0; i<n; i++){
            Collections.sort(tree.get(i));
        }
        
        dfs(0);
        
        boolean res[] = new boolean[n]; 
        
        String man = """"; 
        
        for(int i : list)man += s.charAt(i);
        
        manacher(man); 
        
        for(int i = 0; i<n; i++){
            int node = list.get(i);
            res[node] = isPalindromeQuery(i-dp[node]+1,i);
        }
        
        
        return res; 
    }
    
    public void manacher(String s) {
        int n = s.length();
        StringBuilder sb = new StringBuilder();
        
        // Insert '#' between characters to handle even-length palindromes
        sb.append('#');
        for (char c : s.toCharArray()) {
            sb.append(c);
            sb.append('#');
        }
        
        String t = sb.toString(); // Transformed string
        int m = t.length();
        P = new int[m]; // Array to store the palindrome radii
        int c = 0, r = 0; // Current center and right boundary
        
        for (int i = 0; i < m; i++) {
            int mirror = 2 * c - i; // Mirror index of i with respect to center c
            
            if (i < r) {
                P[i] = Math.min(r - i, P[mirror]);
            }
            
            // Try to expand around i
            while (i + P[i] + 1 < m && i - P[i] - 1 >= 0 && t.charAt(i + P[i] + 1) == t.charAt(i - P[i] - 1)) {
                P[i]++;
            }
            
            // If the palindrome around i expands past r, adjust center and boundary
            if (i + P[i] > r) {
                c = i;
                r = i + P[i];
            }
        }
    }

    // Function to answer the palindrome query in constant time
   public boolean isPalindromeQuery(int l, int r) {
    // Calculate the transformed positions for the preprocessed string
    int lPos = 2 * l + 1; // Position of the start index in transformed string
    int rPos = 2 * r + 1; // Position of the end index in transformed string
    int center = (lPos + rPos) / 2; // Center of the substring

    // Ensure the radius covers the entire substring
    return P[center] >= (rPos - lPos) / 2;
}
    
    
    int dfs(int node){
        int res = 1; 
        
        
        for(int adj : tree.get(node)){
            res += dfs(adj);
        }
        list.add(node);
        return dp[node] =  res;
    }
}",1427932661
CyberPunk,U_U,555,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();

        int start = 0;
        int prefix = 0;
        int64_t res =  0;
        vector<int> cnts(26, 0);
        for (int i = 0; i < n; ++i)
        {
            cnts[ s[i] - 'a' ]++;

            while (true)
            {
                cnts[s[prefix] - 'a']--;
                if (greaterK(cnts, k))
                {
                    ++prefix;
                    continue;
                }
                cnts[s[prefix] - 'a']++;
                break;                
            }
           // cout << i << "","" << prefix << "","" << cnts[0] << endl;
           
            if (greaterK(cnts, k))
            {
                res += prefix - start + 1;
            }
        }

        return res;
    }

    bool greaterK(vector<int>& vec, int k)
    {         
            for (auto& item : vec)
            {
                if (item >= k)
                {
                    return true;
                }
            }
        return false;
    }
};",1427831722
CyberPunk,U_U,555,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> vec;
        string s = """";
        for (int i = 0; i < target.size(); ++i)
        {
            s += 'a';
            vec.push_back(s);
            while (s.back() != target[i]) 
            {
                s.back() = char(int(s.back()) + 1);
                vec.push_back(s);
            }
        }

        return vec;
    }
};",1427824360
CyberPunk,U_U,555,3603,cpp,"class Solution {
public: 
    string palin;
    vector< vector<int> > adj;
    string S;
    int n;
    vector<bool> res;
    vector<pair<int, int>> arrRange;
    vector<bool> findAnswer(vector<int>& parent, string s) {
        n = s.size();
        S = s;
        adj.assign(n, vector<int>());
        res.assign(n, false);
        arrRange.assign(n, {-1, -1});
        for (int i = 0; i < n; ++i)
        {
            if (parent[i] == -1) continue;
            adj[ parent[i] ].push_back(i);
        }

        vector<int> stk(n, 0);
        int len;
        DFS(0, palin, stk, len);
        
        vector<int> p = manacher(palin);
         
        for (int i = 0; i < arrRange.size(); ++i)
        {
           // cout << i << "","" << arrRange[i].first << "","" << arrRange[i].second << endl;
            //res[i] = isPalindrome(palin, evenLen, oddLen, arrRange[i].first, arrRange[i].second);
            res[i] = isPalindrome(palin, p, arrRange[i].first, arrRange[i].second);
        }

        return res;
    }

    void DFS(int u, string& p, vector<int>& stk, int& len)
    {
       
        stk[len++] = u;
        for (auto& v : adj[u])
        {
            DFS(v, p, stk, len);
        }         
        for (int i = 0; i < len; ++i)
        {         
            arrRange[stk[i]].first = p.size();
        }
        len = 0;
        p += S[u];
       // cout << u << "","" << p << endl;
        arrRange[u].second = p.size() - 1;
    }


// Function to preprocess string by inserting special characters
string preprocess(const string& s) {
    string t = ""#"";
    for (char c : s) {
        t += c;
        t += '#';
    }
    return t;
}

// Manacher's Algorithm to find all palindromes in O(n)
vector<int> manacher(const string& s) {
    string t = preprocess(s);  // Preprocess the string
    int n = t.size();
    vector<int> p(n, 0);  // Array to store palindrome radius at each center
    int center = 0, right = 0; // Current center and right boundary of the palindrome
    for (int i = 0; i < n; ++i) {
        int mirror = 2 * center - i; // Mirror position of i around the center
        if (i < right) {
            p[i] = min(right - i, p[mirror]);
        }
        // Attempt to expand the palindrome centered at i
        while (i + p[i] + 1 < n && i - p[i] - 1 >= 0 && t[i + p[i] + 1] == t[i - p[i] - 1]) {
            ++p[i];
        }
        // Update the center and right boundary if we expand beyond the current right boundary
        if (i + p[i] > right) {
            center = i;
            right = i + p[i];
        }
    }
    return p;  // Return the palindrome radius array
}

// Function to check if a substring s[l...r] is a palindrome
bool isPalindrome(const string& s, const vector<int>& p, int l, int r) {
    // Map the original indices to the modified string indices
    int new_l = 2 * l + 1;
    int new_r = 2 * r + 1;
    int center = (new_l + new_r) / 2;
    int radius = (new_r - new_l) / 2;
    return p[center] >= radius;
}


};",1427924642
miya145592,miya145592,556,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        dp = [[0 for _ in range(26)] for _ in range(n+1)]
        for i in range(n):
            c = ord(s[i])-ord('a')
            for j in range(26):
                dp[i+1][j] = dp[i][j] + (1 if j==c else 0)
        i = 0
        j = 0
        ans = 0
        while i<n:
            flag = False
            while j<=n and flag==False:
                for l in range(26):
                    if dp[j][l]-dp[i][l]>=k:
                        flag = True
                        break
                if flag:
                    break
                j+=1
            if flag:
                ans += n-j+1
            i+=1
        return ans
",1427841963
miya145592,miya145592,556,3566,python3,"from typing import List

class Solution:
    def stringSequence(self, target: str) -> List[str]:
        n = len(target)
        ans = []
        tmp = []
        for i in range(n):
            tmp.append(""a"")
            while tmp[i]!=target[i]:
                ans.append("""".join(tmp))
                tmp[i] = chr(ord(tmp[i])+1)
            ans.append("""".join(tmp))
        return ans",1427827247
miya145592,miya145592,556,3603,python3,"import sys
from typing import List
sys.setrecursionlimit(10**6)

# https://tjkendev.github.io/procon-library/python/string/manacher.html
# 偶数長含めた回文の長さを求める
# R[2*i] = L: S[i]を中心とする奇数長の最大回文
# R[2*i+1] = L: S[i:i+2]を中心とする偶数長の最大回文
# ダミー文字を挟むが、各 R[i] は実際の回文の文字列長と一致する
def manacher(S):
    C = []
    for a in S:
        C.append(a)
        C.append(0)
    C.pop()

    L = len(C)

    R = [0]*L

    i = j = 0
    while i < L:
        while j <= i < L-j and C[i-j] == C[i+j]:
            j += 1
        R[i] = j
        k = 1
        while j-R[i-k] > k <= i < L-k:
            R[i+k] = R[i-k]
            k += 1
        i += k; j -= k

    for i in range(L):
        if i & 1 == R[i] & 1:
            R[i] -= 1
    return R


class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        child = [[] for _ in range(n)]
        for i in range(n):
            p = parent[i]
            if p!=-1:
                child[p].append(i)

        dfsStr = []
        def dfs(x):
            pos[x] = len(dfsStr)
            for nx in child[x]:
                dfs(nx)
            dfsStr.append(s[x])
            l[x] = len(dfsStr)-pos[x]
        
        pos = [-1 for _ in range(n)]
        l = [0 for _ in range(n)]

        dfs(0)
        m = manacher(dfsStr)
        #print(dfsStr)
        #print(m)
        #print(pos)
        #print(l)

        ans = [False for _ in range(n)]
        for i in range(n):
            st = pos[i]
            ed = pos[i]+l[i]-1
            mid = (st+ed)
            if m[mid]>=l[i]:
                ans[i] = True
            else:
                ans[i] = False
        return ans",1427927116
尾玉,louisfghbvc,557,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        // goal: find the number of substring such that at least 1 letter k times
        
        // idea:
        // brute force -> O(n^2)
        
        int n = s.size();
        
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> cnt(26);
            bool ok = false;
            for (int j = i; j < n; ++j) {
                cnt[s[j]-'a']++;
                if (cnt[s[j]-'a'] >= k) ok = true;
                ans += ok;
            }
        }
        
        return ans;
    }
};",1427825429
尾玉,louisfghbvc,557,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        // goal: find the sequence of target
        
        // idea:
        // letter by letter
        
        
        vector<string> res;
        string cur;
        for (int i = 0; i < target.size(); ++i) {
            cur += 'a';
            for (int j = 0; j <= target[i]-'a'; ++j) {
                cur.back() = 'a' + j;
                res.push_back(cur);
            }
        }
        
        return res;
    }
};",1427830220
尾玉,louisfghbvc,557,3603,cpp,"class Solution {
public:
    
    template<int B=37>
    vector<bool> calHash1(vector<int>& parent, string s) {
        int n = parent.size();
        
        // init hash
        using hash_t = unsigned long long;
        vector<hash_t> powB(n+1, 1);
        for (int i = 1; i <= n; ++i)
            powB[i] = powB[i-1] * B;
        
        // build tree
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }
        
        vector<hash_t> ori(n), rev(n);
        using T = pair<hash_t, int>; // hash, len
        auto dfs = [&](auto& self, int u, int p=-1) -> T {
            // {aaa} {bb} a
            vector<T> tmp;
            for (int v: tree[u]) if (v != p) {
                tmp.emplace_back(self(self, v, u));
            }
            tmp.emplace_back(s[u]-'a', 1);
            
            int len = tmp.back().second;
            for (int i = tmp.size()-2; i >= 0; --i) {
                tmp[i].first *= powB[len];  
                tmp[i].first += tmp[i+1].first;
                len += tmp[i].second;
            }
            
            tmp[0].second = len;
            ori[u] = tmp[0].first;
            return tmp[0];
        };
        dfs(dfs, 0);
        
        auto dfs2 = [&](auto& self, int u, int p=-1) -> T {
            
            vector<T> tmp;
            //  {aaa} {ba} {a}           
            for (int v: tree[u]) if (v != p) {
                tmp.emplace_back(self(self, v, u));
            }
            tmp.emplace_back(s[u]-'a', 1);
            reverse(tmp.begin(), tmp.end());
            
            int len = tmp.back().second;
            for (int i = tmp.size()-2; i >= 0; --i) {
                tmp[i].first *= powB[len];  
                tmp[i].first += tmp[i+1].first;
                len += tmp[i].second;
            }
            
            tmp[0].second = len;
            rev[u] = tmp[0].first;
            return tmp[0];
        };
        dfs2(dfs2, 0);
        
        // output
        vector<bool> res(n);
        for (int i = 0; i < n; ++i) {
            // cout << ori[i] << ' ' << rev[i] << endl;
            res[i] = (ori[i]==rev[i]);
        }
        return res;
    }
    
    vector<bool> findAnswer(vector<int>& parent, string s) {
        // goal: find if dfs string is palindrome
        
        // idea:
        // build the tree 
        
        // two pass
        // one pass => build suf hash
        // one pass => build pre hash
        
        // dfs(x)
        // str = dfs(a) + dfs(b) + s[x]
        //        ab      cd        e
        //       s[x] + rev(dfs(b)) + rev(dfs(a))
        //         e        dc          ba
        
        // (aba)(ab)a
        
        // ori hash(1) = 37
        // ori hash(2) = 1
        
        // 37   + 1 + 0
        // 37*37^2 +  
        
        // rev hash(1) = 37
        // rev hash(2) = 37
        
        // 0 + 37 + 37
        // 0*37^2
        
        return calHash1<37>(parent, s);
    }
};",1427935605
vijay-07,vijay-07,558,3502,python,"class Solution(object):
    def numberOfSubstrings(self, s, k):
        """"""
        :type s: str
        :type k: int
        :rtype: int
        """"""
        n = len(s)
        total = 0
        
        for left in range(n):
            freq = [0] * 26
            maxFreq = 0
            
            for right in range(left, n):
                char_index = ord(s[right]) - ord('a')
                freq[char_index] += 1
                maxFreq = max(maxFreq, freq[char_index])
                
                if maxFreq >= k:
                    total += (n - right)
                    break
        
        return total
",1427926559
vijay-07,vijay-07,558,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = ""a"";
        result.push_back(current);
        
        for (int i = 0; i < target.size(); ++i) {
            char target_char = target[i];
            
            while (current.size() <= i) {
                current.push_back('a');
                result.push_back(current);
            }
            
            while (current[i] < target_char) {
                current[i] = current[i] + 1;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427924453
vijay-07,vijay-07,558,3603,python3,"class Solution:
    def __init__(self):
        self.pw = 31
        self.mod = 9576890767

    def dfs(self, node, adj, power, ans, s):
        fwd = []
        rev = []
        sz = []
        
        for it in adj[node]:
            val = self.dfs(it, adj, power, ans, s)
            fwd.append(val[0])
            rev.append(val[1])
            sz.append(val[2])
        
        fwd.append(ord(s[node]) - ord('a') + 1)
        rev.append(ord(s[node]) - ord('a') + 1)
        sz.append(1)
        
        fwdHash = 0
        prev = 0
        n = len(fwd)
        
        for i in range(n):
            fwdHash = (fwdHash + (power[prev] * fwd[i]) % self.mod) % self.mod
            prev += sz[i]
        
        revHash = 0
        prev = 0
        
        for i in range(n - 1, -1, -1):
            revHash = (revHash + (power[prev] * rev[i]) % self.mod) % self.mod
            prev += sz[i]
        
        if fwdHash == revHash:
            ans[node] = True
        
        return [fwdHash, revHash, prev]

    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        ans = [False] * n
        power = [1] * (n + 1)
        adj = [[] for _ in range(n)]
        
        for i in range(1, n + 1):
            power[i] = (self.pw * power[i - 1]) % self.mod
        
        for i in range(n):
            if parent[i] != -1:
                adj[parent[i]].append(i)
        
        self.dfs(0, adj, power, ans, s)
        return ans
",1427935899
panshane56,panshane56,560,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.size();
        vector<vector<int>> cnt(26, vector<int>(n));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 26; j++) {
                if (s[i] - 'a' == j) {
                    cnt[j][i] = (i ? cnt[j][i - 1] + 1 : 1);
                } else {
                    cnt[j][i] = (i ? cnt[j][i - 1] : 0);
                }
            }
        }

        for (int r = 0; r < n; r ++) {
            for (int l = 0; l <= r; l++) {
                for (int j = 0; j < 26; j++) {
                    if (cnt[j][r] - (l ? cnt[j][l - 1] : 0) >= k) {
                        ans++;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};",1427936589
panshane56,panshane56,560,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for (int i = 0; i < target.size(); i++) {
            for (char j = 'a'; j <= target[i]; j++) {
                ans.push_back(s + j);
            }
            s.push_back(target[i]);
        }
        return ans;
    }
};",1427930911
panshane56,panshane56,560,3603,cpp,"class Solution {
   public:
    std::vector<bool> findAnswer(std::vector<int>& parent, std::string s) {
        int n = parent.size();
        G.resize(n);
        ans.resize(n, false);
        size.resize(n, 1);
        HASHL.resize(n, 0);
        HASHR.resize(n, 0);
        power.resize(n + 1, 1);
        for (int i = 1; i <= n; i++) {
            power[i] = power[i - 1] * p;
        }
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) G[parent[i]].push_back(i);
        }
        for (int i = 0; i < n; i++) {
            std::sort(G[i].begin(), G[i].end());
        }
        dfs(0, s, p);
        return ans;
    }

   private:
    int p = 131;
    std::vector<std::vector<int>> G;
    std::vector<bool> ans;
    std::vector<int> size;
    std::vector<unsigned long long> HASHL, HASHR;
    std::vector<unsigned long long> power;

    void dfs(int u, const std::string& s, int p) {
        for (auto& v : G[u]) {
            dfs(v, s, p);
            size[u] += size[v];
            HASHL[u] = HASHL[u] * power[size[v]] + HASHL[v];
        }
        HASHL[u] = HASHL[u] * p + s[u];

        HASHR[u] = s[u];
        for (int i = static_cast<int>(G[u].size()) - 1; i >= 0; i--) {
            int v = G[u][i];
            HASHR[u] = HASHR[u] * power[size[v]] + HASHR[v];
        }

        ans[u] = HASHL[u] == HASHR[u];
    }
};",1427925911
skyinde2,skyinde2,561,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        cnt = [[0] * (n + 1) for _ in range(26)]

        for i in range(1, n + 1):
            for j in range(26):
                cnt[j][i] = cnt[j][i - 1]
            cnt[ord(s[i - 1]) - ord('a')][i] += 1

        ret = 0
        for i in range(1, n + 1):
            w = min(bisect.bisect_left(cnt[j], k + cnt[j][i - 1]) for j in range(26))
            ret += n + 1 - w

        return ret",1427848906
skyinde2,skyinde2,561,3566,python3,"
class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ret = []

        current = ''
        for ch in target:
            for i in range(ord('a'), ord(ch) + 1):
                ret.append(current + chr(i))
            current += ch
        
        return ret
",1427825343
skyinde2,skyinde2,561,3603,python3,"
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(s)
        children: [[int]] = [[] for _ in range(n)]
        MOD = 1000_000_007

        p = [1] * (n + 1)
        for i in range(1, n + 1):
            p[i] = p[i - 1] * 256 % MOD

        for i in range(1, n):
            children[parent[i]].append(i)

        ret = [False] * n

        def dfs(i: int) -> (int, int, int):
            tmp = []

            for j in children[i]:
                tmp.append(dfs(j))

            count, h0 = 0, 0

            for t in tmp:
                h0 = (h0 + p[count] * t[1]) % MOD
                count += t[0]
            h0 = (h0 + p[count] * ord(s[i])) % MOD

            count, h1 = 1, ord(s[i])

            for t in reversed(tmp):
                h1 = (h1 + p[count] * t[2]) % MOD
                count += t[0]

            if h0 == h1:
                nonlocal ret
                ret[i] = True

            return count, h0, h1

        dfs(0)
        return ret",1427938448
Pranav,pprranav,562,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        r = 0
        n = len(s)
        for i in range(n):
            c = [0]*26
            found = False
            for j in range(i,n):
                idx = ord(s[j])-97
                c[idx] += 1
                if not found and c[idx] >= k:
                    found = True
                if found:
                    r+=1
        return r",1427827355
Pranav,pprranav,562,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        s=[]
        r=[]
        for i, c in enumerate(target):
            while len(s) < i + 1:
                s.append('a')
                r.append(''.join(s))
            while s[i] != c:
                s[i] = 'a' if s[i] == 'z' else chr(ord(s[i]) + 1)
                r.append(''.join(s))
        return r
",1427824239
Pranav,pprranav,562,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        adj = [[] for _ in range(n)]

        for i in range(n):
            if parent[i] != -1:
                adj[parent[i]].append(i)

        for l in adj:
            l.sort()
   
        mod = 10 ** 9 + 7
        base = 911
        maxl = n + 1
        p = [1] * maxl
        for i in range(1, maxl):
            p[i] = p[i - 1] * base % mod

        length = [0] * n
        fwd_hash = [0] * n
        rev_hash = [0] * n
        ans = [False] * n

        def dfs(x):
            lx = 0
            f_hash = 0
            for y in adj[x]:
                dfs(y)
                ly = length[y]
                lx += ly
                f_hash = (f_hash * p[ly] + fwd_hash[y]) % mod
            h_sx = ord(s[x])
            lx += 1
            f_hash = (f_hash * base + h_sx) % mod
            length[x] = lx
            fwd_hash[x] = f_hash

            r_hash = h_sx
            for y in reversed(adj[x]):
                ly = length[y]
                r_hash = (r_hash * p[ly] + rev_hash[y]) % mod
            rev_hash[x] = r_hash

            ans[x] = fwd_hash[x] == rev_hash[x]

        roots = [i for i in range(n) if parent[i] == -1]
        for root in roots:
            dfs(root)
        return ans
",1427932504
Ayush Kumar Singh,Lallanbhai,563,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int res = 0;

        for (int i = 0; i < n; ++i) {
            unordered_map<char, int> mp;
            for (int j = i; j < n; ++j) {
                mp[s[j]]++;
                bool f = false;
                for (auto& [ch, count] : mp) {
                    if (count >= k) {
                        f = true;
                        break;
                    }
                }
                
                if (f) {
                    res++;
                }
            }
        }

        return res;
    }
};",1427829469
Ayush Kumar Singh,Lallanbhai,563,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";  

        for (char c : target) {
            current += 'a';
            result.push_back(current);

            while (current.back() != c) {
                current.back()++; 
                result.push_back(current);
            }
        }

        return result;
    }
};",1427826597
Ayush Kumar Singh,Lallanbhai,563,3603,cpp,"class Solution {
    vector<bool> res;
    string str;

    long long p = 31;
    long long mod = 1e9+7;

    long long powers[(int)1e5 + 1];
public:
    void precomp(){
        powers[0] = 1;
        for(int i = 1; i < 1e5+1; i++){
            powers[i] = (powers[i-1]*p)%mod;
        }
    }
    pair<int ,pair<int,int>> dfs(int node, vector<int> child[]){
        long long fwdHash = 0;
        long long revHash = 0;

        int size = 0;
        bool f = 0;
        for(auto x : child[node]){
            // if(x > node){
                pair<int ,pair<int,int>> op = dfs(x, child);
                
                int fwd = op.second.first;
                int rev = op.second.second;
                int sz = op.first;
                
                fwdHash = (fwdHash + fwd*powers[size])%mod;
                revHash = (revHash*powers[sz] + rev)%mod;

                size += sz;
            // }
            // else{
            //     dfs(x, child);
            // }
        }
        
        // cout<<node<<"" ""<<fwdHash<<"" ""<<revHash<<endl;
        fwdHash = (fwdHash + (str[node] - 'a' +1)*powers[size])%mod;
        revHash = (revHash*p + (str[node] - 'a' +1))%mod;

        size++;

        // cout<<node<<"" ""<<fwdHash<<"" ""<<revHash<<endl;
        if(fwdHash == revHash){
            res[node] = 1;
        }

        return {size, {fwdHash, revHash}};
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        res.resize(n);
        str = s;
        vector<int> child[n];
        for(int i = 1; i< n; i++){
            child[parent[i]].push_back(i);
        }

        precomp();

        dfs(0, child);

        return res;
    }
};",1427934203
faiazferden04,faiazferden04,564,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res = 0
        for i in range(len(s)):
            count = defaultdict(int)
            for j in range(i, len(s)):
                count[s[j]] += 1
                if count[s[j]] >= k:
                    res += len(s) - j
                    break
        return res

        ",1427848454
faiazferden04,faiazferden04,564,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        i = 0
        str_ = """"
        while str_ != target:
            str_ += 'a'
            res.append(str_)
            while str_[i] != target[i]:
                next_char = chr((ord(str_[i]) - ord('a') + 1)%26 + ord('a'))
                str_ = str_[:i] + next_char
                res.append(str_)
            i += 1
        return res
            


        ",1427837471
faiazferden04,faiazferden04,564,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            p = parent[i]
            tree[p].append(i)

        for children in tree:
            children.sort()

        mod1 = 10**9 + 7
        mod2 = 10**9 + 9
        base1 = 911
        base2 = 3571

        max_length = n + 1
        pow_base1 = [1] * max_length
        pow_base2 = [1] * max_length
        for i in range(1, max_length):
            pow_base1[i] = (pow_base1[i - 1] * base1) % mod1
            pow_base2[i] = (pow_base2[i - 1] * base2) % mod2

        answer = [False] * n

        def dfs(node):
            length = 1  
            hash1 = 0
            hash2 = 0
            rev_hash1 = ord(s[node])
            rev_hash2 = ord(s[node])
            child_data = []

            for child in tree[node]:
                dfs(child)
                child_data.append({
                    'length': lengths[child],
                    'hash1': hashes1[child],
                    'hash2': hashes2[child],
                    'rev_hash1': rev_hashes1[child],
                    'rev_hash2': rev_hashes2[child],
                })
                length += lengths[child]

 
            hash1 = 0
            hash2 = 0
            for data in child_data:
                length_y = data['length']
                hash_y1 = data['hash1']
                hash_y2 = data['hash2']
                hash1 = (hash1 * pow_base1[length_y] + hash_y1) % mod1
                hash2 = (hash2 * pow_base2[length_y] + hash_y2) % mod2

            hash1 = (hash1 * base1 + ord(s[node])) % mod1
            hash2 = (hash2 * base2 + ord(s[node])) % mod2

            rev_hash1 = ord(s[node])
            rev_hash2 = ord(s[node])
            for data in reversed(child_data):
                length_y = data['length']
                rev_hash_y1 = data['rev_hash1']
                rev_hash_y2 = data['rev_hash2']
                rev_hash1 = (rev_hash1 * pow_base1[length_y] + rev_hash_y1) % mod1
                rev_hash2 = (rev_hash2 * pow_base2[length_y] + rev_hash_y2) % mod2

            lengths[node] = length
            hashes1[node] = hash1
            hashes2[node] = hash2
            rev_hashes1[node] = rev_hash1
            rev_hashes2[node] = rev_hash2
         
            if hash1 == rev_hash1 and hash2 == rev_hash2:
                answer[node] = True
            else:
                answer[node] = False

        lengths = [0] * n
        hashes1 = [0] * n
        hashes2 = [0] * n
        rev_hashes1 = [0] * n
        rev_hashes2 = [0] * n

        dfs(0)
        return answer
        ",1427942374
Mridul Pandey,mridul_cr7,565,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int j1=0,j2=0;
        vector<int> frq(26,0);
        int n=s.size();
        while(j2<n)
        {
            frq[s[j2]-97]++;
            int tell=0;
            for(int i=0;i<26;i++)
            {
                if(frq[i]>=k)
                    tell=1;
            }
            while(tell)
            {
                ans=ans+(n-j2);
                tell=0;
                frq[s[j1]-97]--;
                j1++;
                for(int i=0;i<26;i++)
                {
                if(frq[i]>=k)
                    tell=1;
                }
            }
            j2++;
        }
        return ans;
    }
};",1427833823
Mridul Pandey,mridul_cr7,565,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        int idx=0;
        for(auto x:target)
        {
            s.push_back('a');
            ans.push_back(s);
            char l='a';
            while(l!=x)
            {
                l=l+1;
                s[idx]=l;
                ans.push_back(s);
            }
            idx++;
            
        }
        return ans;
    }
};",1427828108
Mridul Pandey,mridul_cr7,565,3603,cpp,"int cc=0;

int gen_base(const int before, const int after)
{
    auto seed = std::chrono::high_resolution_clock::now().time_since_epoch().count();
    std::mt19937 mt_rand(seed);
    int base = std::uniform_int_distribution<int>(before + 1, after)(mt_rand);
    return base % 2 == 0 ? base - 1 : base;
}

struct PolyHash
{
    // -------- Static variables --------
    static const int mod1 = (int)1e9 + 7; // prime mod of polynomial hashing
    static const int mod2 = (int)1e9 + 9; // prime mod of polynomial hashing

    static std::vector<int> pow1; // powers of base modulo mod
    static std::vector<int> pow2; // powers of base modulo
    static int base1;             // base (point of hashing)
    static int base2;             // base (point of hashing)

    // -------------- Variables of class -------------
    std::vector<int> pref1; // Hash on prefix modulo mod
    std::vector<int> pref2; // Hash on prefix modulo 2^64

    // Cunstructor from string:
    PolyHash(const std::string &s)
        : pref1(s.size() + 1, 0), pref2(s.size() + 1, 0)
    {
        assert(base1 < mod1);
        assert(base2 < mod2);

        const int n = s.size(); // Firstly calculated needed power of base:
        while ((int)pow1.size() <= n)
        {
            pow1.push_back(1LL * pow1.back() * base1 % mod1);
            pow2.push_back(1LL * pow2.back() * base2 % mod2);
        }
        for (int i = 0; i < n; ++i)
        { // Fill arrays with polynomial hashes on prefix
            assert(base1 > s[i]);
            assert(base2 > s[i]);

            pref1[i + 1] = (pref1[i] + 1LL * s[i] * pow1[i]) % mod1;
            pref2[i + 1] = (pref2[i] + 1LL * s[i] * pow2[i]) % mod2;
        }
    }

    // Polynomial hash of subsequence [pos, pos+len)
    // If mxPow != 0, value automatically multiply on base in needed power. Finally base ^ mxPow
    inline std::pair<int, int> operator()(const int pos, const int len, const int mxPow = 0) const
    {
        int hash1 = pref1[pos + len] - pref1[pos];
        int hash2 = pref2[pos + len] - pref2[pos];
        if (hash1 < 0)
            hash1 += mod1;
        if (hash2 < 0)
            hash2 += mod2;
        if (mxPow != 0)
        {
            hash1 = 1LL * hash1 * pow1[mxPow - (pos + len - 1)] % mod1;
            hash2 = 1LL * hash2 * pow2[mxPow - (pos + len - 1)] % mod2;
        }
        return std::make_pair(hash1, hash2);
    }
};

// Init static variables of PolyHash class:
int PolyHash::base1((int)1e9 + 7);
int PolyHash::base2((int)1e9 + 9);
std::vector<int> PolyHash::pow1{1};
std::vector<int> PolyHash::pow2{1};




void dfs1(vector<vector<int>> &adj,int curr,int prev,string &s,string &t,vector<int> &sz)
{
    for(auto x:adj[curr])
    {
        if(x!=prev)
        {
            dfs1(adj,x,curr,s,t,sz);
            sz[curr]+=sz[x];
        }
    }
    s.push_back(t[curr]);
}

void dfs2(vector<vector<int>> &adj,int curr,int prev,vector<pair<int,int>> &rng,int l,int r,vector<int>&sz)
{
    int sum=0;
    int st=l;
    for(auto x:adj[curr])
    {
        if(x!=prev)
        {
            rng[x]={st,sz[x]};
            dfs2(adj,x,curr,rng,st,sz[x],sz);
            st=st+sz[x];
        }
    }
}

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string t) {
        const int mxPow = 100000;
        if(cc==0)
        {
            string temp="""";
            for(int i=0;i<mxPow;i++)
            {
                temp.push_back('a');
            }
            
            PolyHash::base1 = gen_base(256, PolyHash::mod1);
            PolyHash::base2 = gen_base(256, PolyHash::mod2);
            PolyHash hash(temp);
            cc++;    
        }
        int n=parent.size();
        vector<vector<int>> adj(n);
        for(int i=0;i<n;i++)
        {
            if(parent[i]!=-1)
            {
                int x=i;
                int y=parent[i];
                adj[x].push_back(y);
                adj[y].push_back(x);
            }
        }
        for(int i=1;i<n;i++)
        {
            sort(adj[i].begin(),adj[i].end());
        }
        string s="""";
        vector<int> sz(n,1);
        dfs1(adj,0,-1,s,t,sz);
        vector<pair<int,int>> rng(n);
        rng[0]={0,n};
        dfs2(adj,0,-1,rng,0,n-1,sz);
        vector<bool> ans(n,false);
        string rev=s;
        reverse(rev.begin(),rev.end());
        PolyHash hash_a(s), hash_b(rev);
       // cout<<s<<""\n""<<rev<<""\n"";
        for(int i=0;i<n;i++)
        {
            int l=rng[i].first;
            int siz=rng[i].second;
            auto gen1=hash_a(l, siz, mxPow);
            int lst=l+siz;
            int l2=n-lst;
                      //  cout<<i<<"" ""<<l2<<"" ""<<siz<<"" ""<<sz[i]<<""\n"";

            auto gen2=hash_b(l2, siz, mxPow);
             if(gen1==gen2)
                 ans[i]=true;
        }
        return ans;
    }
};",1427943248
Akash,akash_y_codes,566,3502,java,"import java.util.HashMap;
import java.util.Map;

class Solution {
    public int numberOfSubstrings(String s, int k) {
        int count = 0;
        int start = 0;
        Map<Character, Integer> freqMap = new HashMap<>();

        for (int end = 0; end < s.length(); end++) {
            char endChar = s.charAt(end);
            freqMap.put(endChar, freqMap.getOrDefault(endChar, 0) + 1);

            while (isValid(freqMap, k)) {
                count += s.length() - end;
                char startChar = s.charAt(start);
                freqMap.put(startChar, freqMap.get(startChar) - 1);
                if (freqMap.get(startChar) == 0) {
                    freqMap.remove(startChar);
                }
                start++;
            }
        }

        return count;
    }

    private boolean isValid(Map<Character, Integer> freqMap, int k) {
        for (int freq : freqMap.values()) {
            if (freq >= k) {
                return true;
            }
        }
        return false;
    }
}
",1427827354
Akash,akash_y_codes,566,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> result = new ArrayList<>();
        StringBuilder currentString = new StringBuilder();
        char lastCharacter = 'a';
        
        for (char targetCharacter : target.toCharArray()) {
            appendInitialCharacter(currentString, result);
            updateToTargetCharacter(currentString, result, targetCharacter);
        }
        
        return result;
    }
    
    private void appendInitialCharacter(StringBuilder currentString, List<String> result) {
        currentString.append('a');
        result.add(currentString.toString());
    }
    
    private void updateToTargetCharacter(StringBuilder currentString, List<String> result, char targetCharacter) {
        char lastCharacter = currentString.charAt(currentString.length() - 1);
        
        while (lastCharacter != targetCharacter) {
            lastCharacter = (lastCharacter == 'z') ? 'a' : (char) (lastCharacter + 1);
            currentString.setCharAt(currentString.length() - 1, lastCharacter);
            result.add(currentString.toString());
        }
    }
}
",1427834469
Akash,akash_y_codes,566,3603,csharp,"using System;
using System.Collections.Generic;

public class Solution {
    public bool[] FindAnswer(int[] parent, string s) {
        int nodeCount = parent.Length;
        List<List<int>> tree = new List<List<int>>(nodeCount);
        
        // Initialize each list in the tree
        for (int i = 0; i < nodeCount; i++) {
            tree.Add(new List<int>());
        }

        for (int i = 1; i < nodeCount; i++) {
            tree[parent[i]].Add(i);
        }

        foreach (var childList in tree) {
            childList.Sort();
        }

        List<char> traversalList = new List<char>();
        int[] startIndices = new int[nodeCount];
        int[] endIndices = new int[nodeCount];

        Traverse(0, tree, s, traversalList, startIndices, endIndices);

        List<char> reverseTraversalList = new List<char>(traversalList);
        reverseTraversalList.Reverse();

        long mod1 = 1000000007L, mod2 = 1000000009L;
        int baseValue = 27;
        long[] power1 = new long[traversalList.Count + 1];
        long[] power2 = new long[traversalList.Count + 1];
        power1[0] = power2[0] = 1;

        for (int i = 1; i <= traversalList.Count; i++) {
            power1[i] = (power1[i - 1] * baseValue) % mod1;
            power2[i] = (power2[i - 1] * baseValue) % mod2;
        }

        long[] hash1 = new long[traversalList.Count + 1];
        long[] hash2 = new long[traversalList.Count + 1];
        for (int i = 0; i < traversalList.Count; i++) {
            hash1[i + 1] = (hash1[i] * baseValue + (traversalList[i] - 'a' + 1)) % mod1;
            hash2[i + 1] = (hash2[i] * baseValue + (traversalList[i] - 'a' + 1)) % mod2;
        }

        long[] reverseHash1 = new long[reverseTraversalList.Count + 1];
        long[] reverseHash2 = new long[reverseTraversalList.Count + 1];
        for (int i = 0; i < reverseTraversalList.Count; i++) {
            reverseHash1[i + 1] = (reverseHash1[i] * baseValue + (reverseTraversalList[i] - 'a' + 1)) % mod1;
            reverseHash2[i + 1] = (reverseHash2[i] * baseValue + (reverseTraversalList[i] - 'a' + 1)) % mod2;
        }

        bool[] results = new bool[nodeCount];
        for (int i = 0; i < nodeCount; i++) {
            int leftIndex = startIndices[i], rightIndex = endIndices[i];
            long forwardHash1 = (hash1[rightIndex + 1] - (hash1[leftIndex] * power1[rightIndex - leftIndex + 1]) % mod1 + mod1) % mod1;
            long forwardHash2 = (hash2[rightIndex + 1] - (hash2[leftIndex] * power2[rightIndex - leftIndex + 1]) % mod2 + mod2) % mod2;
            int revLeftIndex = traversalList.Count - 1 - rightIndex, revRightIndex = traversalList.Count - 1 - leftIndex;
            long reverseHashValue1 = (reverseHash1[revRightIndex + 1] - (reverseHash1[revLeftIndex] * power1[revRightIndex - revLeftIndex + 1]) % mod1 + mod1) % mod1;
            long reverseHashValue2 = (reverseHash2[revRightIndex + 1] - (reverseHash2[revLeftIndex] * power2[revRightIndex - revLeftIndex + 1]) % mod2 + mod2) % mod2;

            if (forwardHash1 == reverseHashValue1 && forwardHash2 == reverseHashValue2) {
                results[i] = true;
            }
        }

        return results;
    }

    private void Traverse(int node, List<List<int>> tree, string s, List<char> traversalList, int[] startIndices, int[] endIndices) {
        startIndices[node] = traversalList.Count;
        foreach (int child in tree[node]) {
            Traverse(child, tree, s, traversalList, startIndices, endIndices);
        }
        traversalList.Add(s[node]);
        endIndices[node] = traversalList.Count - 1;
    }
}
",1427937546
parasthecool123,parasthecool123,567,3502,java,"class Solution {
    public int numberOfSubstrings(String S, int k) {
        char s[] = S.toCharArray();
        int n = s.length;
        int f[][] = new int[n][26];
        for(int i = 0; i < n; i++){
            if (i > 0)
                f[i] = f[i - 1].clone();
            f[i][(int)(s[i] - 'a')]++;
        }
        int ans = 0;
        // for(int x[] : f)
        //     System.out.println(Arrays.toString(x));
        for(int i = 0; i < n - k + 1; i++){
            for(int j = i + k - 1; j < n; j++){
                boolean bool = true;
                for(int z = 0; z < 26 && bool; z++)
                    if(f[j][z] - (i == 0 ? 0 : f[i - 1][z]) >= k)
                        bool = false;
                if(!bool){
                    // System.out.println(i+"" ""+j+"" ""+k);
                    ans++;
                }
                    
            }
        }
        return ans;
    }
}",1427939798
parasthecool123,parasthecool123,567,3566,java,"class Solution {
    public List<String> stringSequence(String S) {
        char s[] = S.toCharArray();
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder("""");
        char cur = 'a';
        for(char c : s){
            sb.append(cur);
            while(cur != c){
                sb.setCharAt(sb.length() - 1, cur);
                ans.add(sb.toString());
                cur++;
            }
            sb.setCharAt(sb.length() - 1, cur);
            ans.add(sb.toString());
            cur = 'a';
        }
        return ans;
    }
}",1427946003
parasthecool123,parasthecool123,567,3603,java,"class Solution {
    public boolean[] findAnswer(int[] par, String s) {
        adj = new ArrayList<>();
        n = par.length;
        for(int i = 0; i < n; i++)
            adj.add(new ArrayList<>());
        for(int i = 1; i < n; i++){
            adj.get(par[i]).add(i);
        }
        
        for(int i = 0; i < n; i++)
            Collections.sort(adj.get(i));
        this.s = s.toCharArray();
        // System.out.println(adj);
        LL head = dfs(0)[0];
        sz = new int[n];
        findSz(0);
        // print(head);
        manS = getNew(head);
        man = getMan(manS);
        ans = new boolean[n];
        findAns(0, 0, n - 1);
        return ans;
        
    }
    void findAns(int node, int low, int high){
        int mid = (low + high) >> 1;
        mid = mid * 2 + 2;
        
        if ((high - low + 1) % 2 == 0)
            mid++;
        // System.out.print(low+"" ""+high+"" ""+mid+"" "");
        // System.out.println(man[mid]);
        if(man[mid] - 1 >= (high - low + 1)){
            ans[node] = true;
        }
        for(int ngr : adj.get(node)){
            findAns(ngr, low, low + sz[ngr] - 1);
            low += sz[ngr];
        }
    }
    String manS;
    int man[];
    boolean ans[];
    int[] getMan(String S){
        int n = S.length();
        
        S = ""$"" + S + ""^"";
        s = S.toCharArray();
        // System.out.println(S);
        int p[] = new int[n + 2];
        int l = 1, r = 1;
        for(int i = 1; i <= n; i++) {
            p[i] = Math.max(0, Math.min(r - i, p[l + (r - i)]));
            while(s[i - p[i]] == s[i + p[i]]) {
                p[i]++;
            }
            if(i + p[i] > r) {
                l = i - p[i]; r = i + p[i];
            }
        }
        // System.out.println(Arrays.toString(p));
        return p;
    }
    int findSz(int node){
        sz[node] = 1;
        for(int ngr : adj.get(node))
            sz[node] += findSz(ngr);
        return sz[node];
    }
    String getNew(LL head){
        StringBuilder s = new StringBuilder(""#"");
        while(head != null){
            s.append(head.c);
            head = head.next;
            s.append('#');
        }
        return s.toString();
    }
    void print(LL head){
        while(head != null){
            System.out.print(head.c);
            head = head.next;
        }
        System.out.println();
    }
    LL[] dfs(int node){
        LL head = null, tail = null;
        for(int ngr : adj.get(node)){
            LL res[] = dfs(ngr);
            if (head == null)
                head = res[0];
            else
                tail.next = res[0];
            tail = res[1];
        }
        if (head == null){
            head = new LL(s[node]);
            tail = head;
        } else{
            tail.next = new LL(s[node]);
            tail = tail.next;
        }
        return new LL[]{head, tail};
    }
    int sz[];
    char s[];
    int n;
    List<List<Integer>> adj;
}
class LL{
    LL next;
    char c;
    LL(char c){
        this.c = c;
    }
}",1427923830
Swayam,swayam_09,568,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int result = 0;
        unordered_map<char, int> freqMap;
        int start = 0;
        
        for (int end = 0; end < n; ++end) {
            freqMap[s[end]]++;
            
            while (isValidSubstring(freqMap, k)) {
                result += n - end;
                freqMap[s[start]]--;
                if (freqMap[s[start]] == 0) {
                    freqMap.erase(s[start]);
                }
                start++;
            }
        }
        
        return result;
    }
    
    bool isValidSubstring(unordered_map<char, int>& freqMap, int k) {
        for (auto& entry : freqMap) {
            if (entry.second >= k) return true;
        }
        return false;
    }
};
",1427836739
Swayam,swayam_09,568,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        
        
        for (char c : target) {
            
            current += 'a';
            result.push_back(current);
            
            
            while (current.back() != c) {
                current.back() = (current.back() == 'z') ? 'a' : current.back() + 1;
                result.push_back(current);
            }
        }
        
        return result;
    }
};
",1427829587
Swayam,swayam_09,568,3603,cpp,"#include <vector>
#include <deque>
#include <unordered_map>

using namespace std;

class Solution {
public:
    

    vector<bool> findAnswer(vector<int>& parentTree, string nodeString) {
        int n = parentTree.size();
        vector<vector<int>> childrenTree(n);
        
        // Build the tree structure from the parent array
        for (int i = 1; i < n; ++i) {
            childrenTree[parentTree[i]].push_back(i);
        }

        // Hashing bases and mod values
        long long basePrimary = 911382628;
        long long modPrimary = 1000000000000000007LL;
        long long baseSecondary = 3571;
        long long modSecondary = 1000000000000000009LL;

        int maxLen = n + 1;
        vector<long long> basePowersPrimary(maxLen, 1);
        vector<long long> basePowersSecondary(maxLen, 1);

        // Precompute powers of base modulo the respective mod values
        for (int i = 1; i < maxLen; ++i) {
            basePowersPrimary[i] = modularMultiply(basePowersPrimary[i - 1], basePrimary, modPrimary);
            basePowersSecondary[i] = modularMultiply(basePowersSecondary[i - 1], baseSecondary, modSecondary);
        }

        // Initialize hash arrays for forward and reverse hashes
        vector<long long> forwardHashPrimary(n, 0);
        vector<long long> reverseHashPrimary(n, 0);
        vector<long long> forwardHashSecondary(n, 0);
        vector<long long> reverseHashSecondary(n, 0);
        vector<int> subtreeLength(n, 1);
        vector<int> inDegree(n, 0);

        for (int i = 0; i < n; ++i) {
            inDegree[i] = childrenTree[i].size();
        }

        deque<int> bfsQueue;
        for (int i = 0; i < n; ++i) {
            if (inDegree[i] == 0) {
                bfsQueue.push_back(i);
            }
        }

        // Maps for subtree hashing to handle unique hashes
        unordered_map<long long, int> subtreeHashPrimary;
        unordered_map<long long, int> subtreeHashSecondary;
        int idPrimary = 1;
        int idSecondary = 1;

        while (!bfsQueue.empty()) {
            int currentNode = bfsQueue.front();
            bfsQueue.pop_front();

            long long combinedHashPrimary = 0;
            for (int childNode : childrenTree[currentNode]) {
                combinedHashPrimary = (modularMultiply(combinedHashPrimary, basePowersPrimary[subtreeLength[childNode]], modPrimary) + forwardHashPrimary[childNode]) % modPrimary;
            }
            combinedHashPrimary = (modularMultiply(combinedHashPrimary, basePrimary, modPrimary) + nodeString[currentNode]) % modPrimary;
            forwardHashPrimary[currentNode] = combinedHashPrimary;

            long long combinedReverseHashPrimary = nodeString[currentNode];
            for (auto it = childrenTree[currentNode].rbegin(); it != childrenTree[currentNode].rend(); ++it) {
                combinedReverseHashPrimary = (modularMultiply(combinedReverseHashPrimary, basePowersPrimary[subtreeLength[*it]], modPrimary) + reverseHashPrimary[*it]) % modPrimary;
            }
            reverseHashPrimary[currentNode] = combinedReverseHashPrimary;

            long long combinedHashSecondary = 0;
            for (int childNode : childrenTree[currentNode]) {
                combinedHashSecondary = (modularMultiply(combinedHashSecondary, basePowersSecondary[subtreeLength[childNode]], modSecondary) + forwardHashSecondary[childNode]) % modSecondary;
            }
            combinedHashSecondary = (modularMultiply(combinedHashSecondary, baseSecondary, modSecondary) + nodeString[currentNode]) % modSecondary;
            forwardHashSecondary[currentNode] = combinedHashSecondary;

            long long combinedReverseHashSecondary = nodeString[currentNode];
            for (auto it = childrenTree[currentNode].rbegin(); it != childrenTree[currentNode].rend(); ++it) {
                combinedReverseHashSecondary = (modularMultiply(combinedReverseHashSecondary, basePowersSecondary[subtreeLength[*it]], modSecondary) + reverseHashSecondary[*it]) % modSecondary;
            }
            reverseHashSecondary[currentNode] = combinedReverseHashSecondary;

            int totalSubtreeLength = 1;
            for (int childNode : childrenTree[currentNode]) {
                totalSubtreeLength += subtreeLength[childNode];
            }
            subtreeLength[currentNode] = totalSubtreeLength;

            if (currentNode != 0) {
                int parentNode = parentTree[currentNode];
                --inDegree[parentNode];
                if (inDegree[parentNode] == 0) {
                    bfsQueue.push_back(parentNode);
                }
            }
        }

        vector<bool> result;
        for (int i = 0; i < n; ++i) {
            if (forwardHashPrimary[i] == reverseHashPrimary[i] && forwardHashSecondary[i] == reverseHashSecondary[i]) {
                result.push_back(true);
            } else {
                result.push_back(false);
            }
        }

        return result;
    }

private:
    // Helper function for modular multiplication to prevent overflow
    long long modularMultiply(long long a, long long b, long long mod) {
        long long result = 0;
        a %= mod;
        while (b > 0) {
            if (b % 2 == 1) {
                result = (result + a) % mod;
            }
            a = (a * 2) % mod;
            b /= 2;
        }
        return result;
    }
};
",1427946679
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,570,3502,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

int vfreq[26];
const int nax = 3000;
int nums[nax];
//7 205 730 8

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = s.size();
        for(int i = 0; i < n; i++)
            nums[i] = s[i] - 'a';

        int ans = 0;
        for(int i = 0; i < n; i++){
            fill(vfreq, vfreq + 26, 0);
            int best = 0;
            for(int j = i; j < n; j++){
                vfreq[nums[j]]++;
                best = max(best, vfreq[nums[j]]);
                ans += best >= k;
            }
        }

        return ans;
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1427931698
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,570,3566,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    vector<string> stringSequence(string target) {

        vector<string> ans;
        string now;
        for(auto& ch : target){
            for(char cur = 'a'; cur <= ch; cur++){
                ans.push_back(now);
                ans.back().push_back(cur);
            }
            now.push_back(ch);
        }

        return ans;
    }
};

// [""a"",""aa"",""ab"",""aba"",""abb"",""abc""]
// [""a"",""b"",""c"",""d"",""e"",""f"",""g"",""h"",""ha"",""hb"",""hc"",""hd"",""he""]

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1427947460
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,570,3603,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

template <uint64_t mod = 1'000'000'007>
struct Mint {
    uint64_t val;
    Mint() : val(0) {}
    Mint(int64_t _val) {
        _val %= mod;
        if (_val < 0) _val += mod;
        val = _val;
    }
    Mint& operator += (const Mint& other){ val += other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator -= (const Mint& other){ val += mod - other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator *= (const Mint& other){ val = (uint64_t)val * other.val % mod; return *this; }
    Mint& operator /= (const Mint& other){ return *this *= other.inv(); }
    Mint operator + (const Mint& other) const { return Mint(*this) += other; }
    Mint operator - (const Mint& other) const { return Mint(*this) -= other; }
    Mint operator * (const Mint& other) const { return Mint(*this) *= other; }
    Mint operator / (const Mint& other) const { return Mint(*this) /= other; }
    Mint pwr(int64_t expo) const {
        Mint res = 1;
        Mint cur = *this;
        while(expo){
            if(expo & 1) res *= cur;
            cur *= cur; expo >>= 1;
        }
        return res;
    }
    Mint inv() const { return pwr(mod - 2); }
    friend ostream& operator << (ostream& os, const Mint& m) { os << m.val; return os; }
    bool operator == (const Mint& other) const { return val == other.val; }
};

constexpr uint64_t MODS[] = {
    1'000'000'007,       // 1e9 + 7
    1'000'000'009,       // 1e9 + 9
    1'000'000'003,       // 1e9 + 3
    1'000'000'019,       // 1e9 + 19
    1'000'000'037,       // 1e9 + 37
    1'000'000'061,       // 1e9 + 61
    1'000'000'077,       // 1e9 + 77
    1'000'000'123,       // 1e9 + 123
    5'330'004'01, 
    7'356'327'91, 
    7'765'314'19,
    7'970'034'13
};

using mint1 = Mint<MODS[0]>;
using mint2 = Mint<MODS[1]>;
const int nax = 1'000'10;
const int BASE = 31;
mint1 power1[nax];
mint2 power2[nax];

int init = []{
    power1[0] = 1;
    power2[0] = 1;
    for(int i = 1; i < nax; i++){
        power1[i] = power1[i - 1] * BASE;
        power2[i] = power2[i - 1] * BASE;
    }

    return 0;
}();

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        const int n = parent.size();
        vector<vector<int>> edges(n);
        for(int cur = 1; cur < n; cur++){
            edges[cur].push_back(parent[cur]);
            edges[parent[cur]].push_back(cur);
        }

        vector<int> nums;
        for(auto& ch : s)
            nums.push_back(ch - 'a' + 1);

        for(auto& kids : edges)  
            sort(all(kids));

        vector<bool> ans(n);
        vector<int> sub_len(n, 1);
        vector<pair<mint1, mint2>> for_hash(n);
        vector<pair<mint1, mint2>> rev_hash(n);

        //state[cur] = [code1, code2, sub_size]
        auto dfs = [&](int cur, int dad, auto&& dfs) -> void {
            for(auto& nei : edges[cur])
                if(nei != dad)
                    dfs(nei, cur, dfs);

            int cur_len = 0;
            for(auto& nei : edges[cur]){
                if(nei == dad) continue;
                auto [first, second] = for_hash[nei];
                for_hash[cur].first += first * power1[cur_len];
                for_hash[cur].second += second * power2[cur_len];
                cur_len += sub_len[nei];
            }

            for_hash[cur].first += power1[cur_len] * nums[cur];
            for_hash[cur].second += power2[cur_len] * nums[cur];

            cur_len = 1;
            rev_hash[cur] = make_pair(nums[cur], nums[cur]);
            for(int i = edges[cur].size() - 1; i >= 0; i--){
                const int nei = edges[cur][i];
                if(nei == dad) continue;
                auto [first, second] = rev_hash[nei];
                rev_hash[cur].first += first * power1[cur_len];
                rev_hash[cur].second += second * power2[cur_len];
                cur_len += sub_len[nei];
            }

            ans[cur] = for_hash[cur] == rev_hash[cur];
            sub_len[cur] = cur_len;
        };
        dfs(0, -1, dfs);

        return ans;
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1427914159
lucasomee006,lucasomee006,571,3502,python3,"from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        l = 0
        d = defaultdict(int)
        for r in range(len(s)):
            d[s[r]] += 1
            while d[s[r]] >= k:
                d[s[l]] -= 1
                ans += len(s)-r 
                l += 1
        return ans",1427826181
lucasomee006,lucasomee006,571,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        cur = """"
        for i in range(len(target)):
            cur = cur + ""a""
            ans.append(cur)
            for j in range(ord(target[i])-ord('a')):
                cur = cur[:-1] + chr(ord(cur[-1]) + 1)
                ans.append(cur)
        return ans
                
",1427824548
lucasomee006,lucasomee006,571,3603,python3,"from collections import defaultdict

class TreeNode:
    def __init__(self, char, children):
        self.char = char
        self.children = children

#so the information we need to know is: where does it start for that node, and how far to the right does it go
class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        def manacher(s):
            
            T = '#'.join(f'^{s}$')
            n = len(T)
            P = [0] * n
            C = R = 0  

            for i in range(1, n - 1):
                mirror = 2 * C - i 

                if R > i:
                    P[i] = min(R - i, P[mirror])

                
                while T[i + P[i] + 1] == T[i - P[i] - 1]:
                    P[i] += 1

                if i + P[i] > R:
                    C, R = i, i + P[i]
            # print(P)
            
            return P[1:-1]
            # max_length = max(P)
            # center_index = P.index(max_length)

            # start = (center_index - max_length) // 2
            # return s[start:start + max_length]


        graph = [0 for i in range(len(parent))]
        childs= [[] for i in range(len(parent))]
        for i in range(len(parent)):
            node = TreeNode(s[i], [])
            graph[i] = node
            if parent[i] != -1:
                childs[parent[i]].append(i)
        for i in range(len(childs)):
            graph[i].children = childs[i]
        root = graph[0]
        mainStr = []
        startsAt = [0 for i in range(len(graph))] 
        endsAt = [0 for i in range(len(graph))]
        #so we want to know what range of the ending array is covered by dfs(n)
        #we can figure out the ending part through that
        #
        def dfs(n):
            graph[n].children.sort()
            startsAt[n] = len(mainStr)
            for child in graph[n].children:
                dfs(child)
            
            endsAt[n] = len(mainStr)
            mainStr.append(graph[n].char)
            return 
        @cache
        def children(n):
            if len(graph[n].children) == 0:
                return 1
            ans = 1
            for i in graph[n].children:
                ans += children(i)
            return ans
        # print(children(0))
        
        dfs(0)
        # print(startsAt)
        # print(endsAt)
        # print(mainStr)
        dp = manacher("""".join(mainStr))
        
        # print(dp)
        ans = []
        for i in range(len(parent)):
            works = False
            start = startsAt[i]
            end = endsAt[i]
            length = end - start + 1
            if length % 2 == 0: #even length palindrome
                m = dp[(start+end)+1]
                if m >= length:
                    works = True
            else:
                m = dp[start + end+1]
                if m >= length:
                    works = True
            ans.append(works)

        
        return ans
        #so go through every child in order and append them, postorder traversal
        #ok, so for a given node. If the children are both palindromes and of the same length obviously it'll
        #be a palindrome
        #for the first node the string generated is ""abaaba""
        #store how many children it has and its starting index? because we've already computed all that

        ",1427939769
bramar2,bramar2,572,3502,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;


class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int freq[26] {}; int ans = 0;
        for(int l = 0, r = 0, n = s.length(); r < n; r++) {
            freq[s[r]-'a']++;
            while(1) {
                bool valid = false;
                for(int b : freq) {
                    if(b >= k) {
                        valid = true; break;
                    }
                }
                if(valid) {
                    ans += n-r;
                    freq[s[l]-'a']--;
                    l++;
                }else break;
            }
        }
        return ans;
    }
};


int main1() {
    return 0;
}",1427834603
bramar2,bramar2,572,3566,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;


class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";
        for(char c : target) {
            for(char ch = 'a'; ch <= c; ch++) {
                res.push_back(curr + ch);
            }
            curr.push_back(c);
        }
        return res;
    }
};


int main1() {
    return 0;
}",1427833357
bramar2,bramar2,572,3603,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; }
template <typename T>
void print2d(T t) { int f = 0; for(const auto& b : t) { cout << (f++ ? ""\n"": """"); print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

vector<int> manacher_odd(string s) {
    int n = s.size();
    s = ""$"" + s + ""^"";
    vector<int> p(n + 2);
    int l = 1, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = max(0, min(r - i, p[l + (r - i)]));
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}
vector<int> manacher(const string& s) {
    string t;
    for(auto c: s) {
        t += string(""#"") + c;
    }
    dbg(t + ""#"");
    return manacher_odd(t + ""#"");
}
class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, const string& s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for(int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        for(auto& v : adj) {
            sort(all(v));
        }
        vector<array<int, 3>> mp_even, mp_odd;
        string dfsStr(n, '0'); int dn = 0;
        #define dbg(...)
        function<void(int)> dfs = [&](int v) {
            int start = dn;

            for(int child : adj[v]) {
                dfs(child);
            }
            dfsStr[dn++] = s[v];

            int end = dn-1;
            int len = end-start+1;
            dbg(v, start, end);
            if((len % 2) == 0) {
                int mid = (start+end)/2;
                dbg(v, mid);
                mp_even.push_back({2*(mid+1), len, v});
            }else {
                mp_odd.push_back({(start+end)/2, (len+1)/2, v});
            }
        };
        dfs(0);
        vector<bool> res(n, false);
        auto v_even = manacher(dfsStr);
        auto v_odd = manacher_odd(dfsStr);
        dbg(dfsStr);
        dbg(v_odd);
        dbg(v_even);
        dbg(""odd"");
        for(auto& arr : mp_odd) {
            dbg(arr);
            if(v_odd[arr[0]] >= arr[1]) {
                res[arr[2]] = true;
                dbg(arr, ""true"");
            }else {
                dbg(arr, ""false"");
            } 
        }
        dbg(""even"");
        for(auto& arr : mp_even) {
            if(v_even[arr[0]] >= arr[1]) {
                res[arr[2]] = true;
                dbg(arr, ""true"");
            }else {
                dbg(arr, ""false"");
            }
        }

        return res;
    }
};


int main1() {
    return 0;
}",1427932073
varous,sourav_suku,574,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int res=0;
        int n=s.size();
        for(int i=0;i<n;++i){
            vector<int> freq(26);
            int cnt=0;
            for(int j=i;j<n;++j){
                ++freq[s[j]-'a'];
                if(freq[s[j]-'a']>=k){
                    res+=(n-j);
                    break;
                }
            }
        }
        return res;
    }
};",1427852204
varous,sourav_suku,574,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s="""";
        int n=target.size();
        for(int i=0;i<n;++i){
            for(char x='a';x<=target[i];++x){
                if(x=='a')s.push_back('a');
                else{
                    s.back()=x;
                }
                res.push_back(s);
            }
        }
        return res;
    }
};",1427842517
varous,sourav_suku,574,3603,cpp,"#define ll long long 
const long long int M=(int)1e9+9;
const int p=31;
class Solution {
public:
    void dfs(int node,int par,string& fin,int& ind,vector<int>& index,vector<int>& siz,vector<int> adj[],string& s){
        for(auto &nei:adj[node]){
            if(nei==par)continue;
            dfs(nei,node,fin,ind,index,siz,adj,s);
            siz[node]+=siz[nei];
        }
        siz[node]++;
        fin.push_back(s[node]); 
        index[node]=ind;
        ++ind;
    }
    ll power(ll a,ll b){
        ll ret=1;
        ll pro=a;
        while(b){
            if(b&1){
                ret*=pro;
                ret%=M;
            }
            b>>=1;
            pro*=pro;   pro%=M;
        }
        return ret;
    }
    void pre(vector<ll>& po,vector<ll>& inv){
        po[0]=inv[0]=1;
        int n=po.size();
        for(int i=1;i<n;++i){
            po[i]=(po[i-1]*p);
            po[i]%=M;
            inv[i]=power(po[i],M-2);
        }
    }
    ll calHash(int l,int r,vector<ll>& pref,vector<ll>& inv){
        ll ret=pref[r];
        if(l){
            ret-=(pref[l-1]);
            ret%=M;
            ret+=M; ret%=M;
        }
        ret*=inv[l];     ret%=M;
        return ret;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n=parent.size();
        vector<int> index(n),siz(n);
        string fin="""";
        int ind=0;
        vector<int> adj[n];
        for(int i=0;i<n;++i){
            if(parent[i]!=-1){
                adj[parent[i]].push_back(i);
                adj[i].push_back(parent[i]);
            }
        }
        dfs(0,-1,fin,ind,index,siz,adj,s);
        // cout<<fin<<endl;
        // for(int i=0;i<n;++i){
        //     cout<<siz[i]<<"" "";
        // }
        string fin2=fin;
        reverse(fin2.begin(),fin2.end());
        // cout<<fin2<<endl;
        vector<ll> po(n),inv(n);
        pre(po,inv);
        vector<ll> pref1(n),pref2(n);
        for(int i=0;i<n;++i){
            pref1[i]=po[i]*(fin[i]-'a'+1);
            pref1[i]%=M;       
            pref2[i]=po[i]*(fin2[i]-'a'+1);
            pref2[i]%=M;
            if(i){
                pref1[i]+=pref1[i-1];
                pref1[i]%=M;
                pref2[i]+=pref2[i-1];
                pref2[i]%=M;
            }
        }
        vector<bool> res;
        for(int i=0;i<n;++i){
            int ind1=index[i];
            int ind2=n-1-ind1;
            int si=siz[i];
            int l1=ind1-si+1,r1=ind1;
            int l2=ind2,r2=ind2+si-1;
            // cout<<i<<"" ""<<l1<<"" ""<<r1<<"" ""<<l2<<"" ""<<r2<<endl;
            if(calHash(l1,r1,pref1,inv)==calHash(l2,r2,pref2,inv)){
                res.push_back(true);
            }else{
                res.push_back(false);
            }
        }
        return res;
    }
};",1427951392
Ajayreddy,Toptodown_Dp,575,3502,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

namespace mitsuha{
template <typename X>
struct Monoid_Add {
    using value_type = X;
    static constexpr X op(const X &x, const X &y) noexcept { return x + y; }
    static constexpr X inverse(const X &x) noexcept { return -x; }
    static constexpr X power(const X &x, long long n) noexcept { return X(n) * x; }
    static constexpr X unit() { return X(0); }
    static constexpr bool commute = true;
};
} // namespace mitsuha

namespace mitsuha{
template <typename Monoid>
struct Static_Range_Product_Group {
    using MX = Monoid;
    using X = typename MX::value_type;
    int n;
    vector<X> dat;
    Static_Range_Product_Group() {}
    template <typename F>
    Static_Range_Product_Group(int m, F f) {
        build(m, f);
    }
    template <typename F>
    void build(int m, F f) {
        n = m;
        dat.assign(n + 1, MX::unit());
        for (int i = 0; i < n; ++i) dat[i + 1] = MX::op(dat[i], f(i));
    }
    void build(vector<X>& A) {
        n = len(A);
        dat.assign(n + 1, MX::unit());
        for (int i = 0; i < n; ++i) dat[i + 1] = MX::op(dat[i], A[i]);
    }
    X prod(int l, int r) { return MX::op(MX::inverse(dat[l]), dat[r]); }
};

template <typename T>
using Prefix_Sum = Static_Range_Product_Group<Monoid_Add<T>>;
} // namespace mitsuha

namespace mitsuha{
template <typename E, int K>
struct Monoid_Add_Array {
    using value_type = array<E, K>;
    using X = value_type;
    static X op(X x, X y) {
        for(int i = 0; i < K; ++i) x[i] += y[i];
        return x;
    }
    static constexpr X unit() { return X{}; }
    static constexpr X inverse(X x) {
        for (auto& v: x) v = -v;
        return x;
    }
    static constexpr X power(X x, long long n) {
        for (auto& v: x) v *= E(n);
        return x;
    }
    static constexpr bool commute = true;
};
} // namespace mitsuha

class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int n = len(s);


        int ret = 0;
        For(x, n){
            vector<int> cnt(26);
            For(y, x, n){
                cnt[s[y] - 'a'] += 1;
                if (cnt[s[y] - 'a'] >= k){
                    ret += n - y;
                    break;
                }
            }
        }
        return ret;
    }
};

",1427894042
Ajayreddy,Toptodown_Dp,575,3566,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

class Solution {
public:
    vector<string> stringSequence(string target) {
        
        int n = len(target);

        vector<str> ret{""a""};

        while (len(ret.back()) != n or ret.back().back() != target.back()){
            if (target[len(ret.back()) - 1] == ret.back().back()){
                ret.push_back(ret.back());
                ret.back() += 'a';
            } else{
                ret.push_back(ret.back());
                if (ret.back().back() == 'z'){
                    ret.back().back() = 'a';
                    continue;
                }
                ret.back().back() += 1;
                
            }
        }
        return ret;
    }
};

",1427887903
Ajayreddy,Toptodown_Dp,575,3603,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

namespace mitsuha{
unsigned long long RNG_64() {
    static uint64_t x_
            = uint64_t(chrono::duration_cast<chrono::nanoseconds>(
                    chrono::high_resolution_clock::now().time_since_epoch())
                               .count())
              * 10150724397891781847ULL;
    x_ ^= x_ << 7;
    return x_ ^= x_ >> 9;
}

unsigned long long RNG(unsigned long long lim) { return RNG_64() % lim; }

long long RNG(long long l, long long r) { return l + RNG_64() % (r - l); }
} // namespace mitsuha

namespace mitsuha{
struct modint61 {
    static constexpr unsigned long long mod = (1ULL << 61) - 1;
    unsigned long long val;
    constexpr modint61() : val(0ULL) {}
    constexpr modint61(unsigned int x) : val(x) {}
    constexpr modint61(unsigned long long x) : val(x % mod) {}
    constexpr modint61(int x) : val((x < 0) ? (x + static_cast<long long>(mod)) : x) {}
    constexpr modint61(long long x) : val(((x %= static_cast<long long>(mod)) < 0) ? (x + static_cast<long long>(mod)): x) {}
    static constexpr unsigned long long get_mod() { return mod; }
    modint61 &operator+=(const modint61 &a) {
        val = ((val += a.val) >= mod) ? (val - mod) : val;
        return *this;
    }
    modint61 &operator-=(const modint61 &a) {
        val = ((val -= a.val) >= mod) ? (val + mod) : val;
        return *this;
    }
    modint61 &operator*=(const modint61 &a) {
        const unsigned __int128 y = static_cast<unsigned __int128>(val) * a.val;
        val = (y >> 61) + (y & mod);
        val = (val >= mod) ? (val - mod) : val;
        return *this;
    }
    modint61 operator-() const { return modint61(val ? mod - val : 0ULL); }
    modint61 &operator/=(const modint61 &a) { return (*this *= a.inverse()); }
    modint61 operator+(const modint61 &p) const { return modint61(*this) += p; }
    modint61 operator-(const modint61 &p) const { return modint61(*this) -= p; }
    modint61 operator*(const modint61 &p) const { return modint61(*this) *= p; }
    modint61 operator/(const modint61 &p) const { return modint61(*this) /= p; }
    bool operator<(const modint61 &other) const { return val < other.val; }
    bool operator==(const modint61 &p) const { return val == p.val; }
    bool operator!=(const modint61 &p) const { return val != p.val; }
    modint61 inverse() const {
        long long a = val, b = mod, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            swap(a -= t * b, b), swap(u -= t * v, v);
        }
        return modint61(u);
    }
    modint61 pow(long long n) const {
        assert(n >= 0);
        modint61 ret(1), mul(val);
        while (n > 0) {
            if (n & 1) ret *= mul;
            mul *= mul, n >>= 1;
        }
        return ret;
    }
};

#ifdef FASTIO
void rd(modint61 &number){
    io::rd(number.val);
}
void wt(const modint61 &number){
    io::wt(number.val);
}
#endif
ostream &operator<<(ostream &out, const modint61 &number){ return out << number.val; }
} // namespace mitsuha

namespace mitsuha{
struct RollingHash {
    using mint = modint61;
    static constexpr unsigned long long mod = mint::get_mod();
    const mint base;
    vector<mint> power;

    static inline mint generate_base() { return RNG(mod); }

    inline void expand(size_t sz) {
        if (power.size() < sz + 1) {
            int pre_sz = (int)power.size();
            power.resize(sz + 1);
            for(int i = pre_sz - 1; i < sz; ++i) power[i + 1] = power[i] * base;
        }
    }

    explicit RollingHash(mint base = generate_base()) : base(base), power{1} {}

    template <typename STRING>
    vector<mint> build(const STRING& s) const {
        int sz = s.size();
        vector<mint> hashed(sz + 1, mint(0));
        for (int i = 0; i < sz; i++) { hashed[i + 1] = hashed[i] * base + s[i]; }
        return hashed;
    }

    template <typename STRING>
    mint eval(STRING& s) {
        mint x = 0;
        for (auto& ch: s) x = base * x + ch;
        return x;
    }

    mint query(const vector<mint>& s, int l, int r) {
        Assert(r < s.size() and l >= 0 and l <= r);
        expand(r - l);
        return (s[r] - s[l] * power[r - l]);
    }

    mint combine(mint h1, mint h2, int h2len) {
        expand(h2len);
        return h1 * power[h2len] + h2;
    }

    mint add_char(mint h, int x) { return h * base + mint(x); }

    int lcp(const vector<mint>& a, int l1, int r1, const vector<mint>& b, int l2, int r2) {
        int len = min(r1 - l1, r2 - l2);
        int low = 0, high = len + 1;
        while (high - low > 1) {
            int mid = (low + high) / 2;
            if (query(a, l1, l1 + mid) == query(b, l2, l2 + mid))
                low = mid;
            else
                high = mid;
        }
        return low;
    }
};
} // namespace mitsuha

namespace mitsuha{
template <typename T>
struct Edge {
    int frm, to;
    T cost;
    int id;
};

template <typename T = int, bool directed = false>
struct Graph {
    static constexpr bool is_directed = directed;
    int N, M;
    using cost_type = T;
    using edge_type = Edge<T>;
    vector<edge_type> edges;
    vector<int> indptr;
    vector<edge_type> csr_edges;
    vector<int> vc_deg, vc_indeg, vc_outdeg;
    bool prepared;

    class OutgoingEdges {
    public:
        OutgoingEdges(const Graph* G, int l, int r) : G(G), l(l), r(r) {}

        const edge_type* begin() const {
            if (l == r) { return 0; }
            return &G->csr_edges[l];
        }

        const edge_type* end() const {
            if (l == r) { return 0; }
            return &G->csr_edges[r];
        }

    private:
        const Graph* G;
        int l, r;
    };

    bool is_prepared() { return prepared; }

    Graph() : N(0), M(0), prepared(0) {}
    Graph(int N) : N(N), M(0), prepared(0) {}

    void build(int n) {
        N = n, M = 0;
        prepared = 0;
        edges.clear();
        indptr.clear();
        csr_edges.clear();
        vc_deg.clear();
        vc_indeg.clear();
        vc_outdeg.clear();
    }

    void add(int frm, int to, T cost = 1, int i = -1) {
        assert(!prepared);
        assert(0 <= frm && 0 <= to && to < N);
        if (i == -1) i = M;
        auto e = edge_type({frm, to, cost, i});
        edges.emplace_back(e);
        ++M;
    }

#ifdef FASTIO
    // wt, off
    void read_tree(bool wt = false, int off = 1) { read_graph(N - 1, wt, off); }

    void read_graph(int M, bool wt = false, int off = 1) {
        for (int m = 0; m < M; ++m) {
            int a, b;
            read(a, b);
            a -= off, b -= off;
            if (!wt) {
                add(a, b);
            } else {
                T c;
                read(c);
                add(a, b, c);
            }
        }
        build();
    }
#endif

    void build() {
        assert(!prepared);
        prepared = true;
        indptr.assign(N + 1, 0);
        for (auto&& e: edges) {
            indptr[e.frm + 1]++;
            if (!directed) indptr[e.to + 1]++;
        }
        for (int v = 0; v < N; ++v) { indptr[v + 1] += indptr[v]; }
        auto counter = indptr;
        csr_edges.resize(indptr.back() + 1);
        for (auto&& e: edges) {
            csr_edges[counter[e.frm]++] = e;
            if (!directed)
                csr_edges[counter[e.to]++] = edge_type({e.to, e.frm, e.cost, e.id});
        }
    }

    OutgoingEdges operator[](int v) const {
        assert(prepared);
        return {this, indptr[v], indptr[v + 1]};
    }

    vector<int> deg_array() {
        if (vc_deg.empty()) calc_deg();
        return vc_deg;
    }

    pair<vector<int>, vector<int>> deg_array_inout() {
        if (vc_indeg.empty()) calc_deg_inout();
        return {vc_indeg, vc_outdeg};
    }

    int deg(int v) {
        if (vc_deg.empty()) calc_deg();
        return vc_deg[v];
    }

    int in_deg(int v) {
        if (vc_indeg.empty()) calc_deg_inout();
        return vc_indeg[v];
    }

    int out_deg(int v) {
        if (vc_outdeg.empty()) calc_deg_inout();
        return vc_outdeg[v];
    }

    vector<int> new_idx;
    vector<bool> used_e;

    // vertex V[i] in G become i in the new graph
    // {G, es}
    // The amount of calculation is sum(deg(v)),
    // Be careful as it may be larger than n+m in the new graph
    Graph<T, directed> rearrange(vector<int> V, bool keep_eid = 0) {
        if (len(new_idx) != N) new_idx.assign(N, -1);
        int n = len(V);
        For(i, n) new_idx[V[i]] = i;
        Graph<T, directed> G(n);
        vector<int> history;
        For(i, n) {
            for (auto&& e: (*this)[V[i]]) {
                if (len(used_e) <= e.id) used_e.resize(e.id + 1);
                if (used_e[e.id]) continue;
                int a = e.frm, b = e.to;
                if (new_idx[a] != -1 && new_idx[b] != -1) {
                    history.emplace_back(e.id);
                    used_e[e.id] = 1;
                    int eid = (keep_eid ? e.id : -1);
                    G.add(new_idx[a], new_idx[b], e.cost, eid);
                }
            }
        }
        For(i, n) new_idx[V[i]] = -1;
        for (auto&& eid: history) used_e[eid] = 0;
        G.build();
        return G;
    }

    Graph<T, true> to_directed_tree(int root = -1, bool directed_away_from_root = true) {
        if (root == -1) root = 0;
        assert(!is_directed && prepared && M == N - 1);
        Graph<T, true> G1(N);
        vector<int> par(N, -1);
        auto dfs = [&](auto& dfs, int v) -> void {
            for (auto& e: (*this)[v]) {
                if (e.to == par[v]) continue;
                par[e.to] = v, dfs(dfs, e.to);
            }
        };
        dfs(dfs, root);
        for (auto& e: edges) {
            int a = e.frm, b = e.to;
            if (par[a] == b) swap(a, b);
            assert(par[b] == a);
            if (directed_away_from_root)
                G1.add(a, b, e.cost);
            else
                G1.add(b, a, e.cost);
        }
        G1.build();
        return G1;
    }

private:
    void calc_deg() {
        assert(vc_deg.empty());
        vc_deg.resize(N);
        for (auto&& e: edges) vc_deg[e.frm]++, vc_deg[e.to]++;
    }

    void calc_deg_inout() {
        assert(vc_indeg.empty());
        vc_indeg.resize(N);
        vc_outdeg.resize(N);
        for (auto&& e: edges) { vc_indeg[e.to]++, vc_outdeg[e.frm]++; }
    }
};

template<typename T, bool directed = false>
std::ostream &operator<<(std::ostream &out, const Graph<T, directed> &_G){
    auto G = _G;
    if (not G.prepared) {
        out << ""frm to cost id"";
        for (auto &&e: G.edges) 
            out << ""\n"" << e.frm << "" "" << e.to << "" "" << e.cost << "" "" << e.id;
    } else {
        out << ""indptr "";
        for(const auto &value : G.indptr) {
            out << value << "" "";
        }
        out << ""\n"";
        out << ""frm to cost id"";
        for(int v = 0; v < G.N; ++v) 
            for (auto &&e: G[v]) 
            out << ""\n"" << e.frm << "" "" << e.to << "" "" << e.cost << "" "" << e.id;
    }
    return out;
}
} // namespace mitsuha

namespace mitsuha{
template<typename GT>
struct Tree {
    using Graph_type = GT;
    GT &G;
    using WT = typename GT::cost_type;
    int N;
    vector<int> LID, RID, head, V, parent, VtoE;
    vector<int> depth;
    vector<WT> depth_weighted;

    Tree(GT &G, int r = 0, bool hld = 1) : G(G) { build(r, hld); }

    void build(int r = 0, bool hld = 1) {
        if (r == -1) return;
        N = G.N;
        LID.assign(N, -1), RID.assign(N, -1), head.assign(N, r);
        V.assign(N, -1), parent.assign(N, -1), VtoE.assign(N, -1);
        depth.assign(N, -1), depth_weighted.assign(N, 0);
        assert(G.is_prepared());
        int t1 = 0;
        dfs_sz(r, -1, hld);
        dfs_hld(r, t1);
    }

    void dfs_sz(int v, int p, bool hld) {
        auto &sz = RID;
        parent[v] = p;
        depth[v] = (p == -1 ? 0 : depth[p] + 1);
        sz[v] = 1;
        int l = G.indptr[v], r = G.indptr[v + 1];
        auto &csr = G.csr_edges;
        for (int i = r - 2; i >= l; --i) {
            if (hld && depth[csr[i + 1].to] == -1) swap(csr[i], csr[i + 1]);
        }
        int hld_sz = 0;
        for (int i = l; i < r; ++i) {
            auto e = csr[i];
            if (depth[e.to] != -1) continue;
            depth_weighted[e.to] = depth_weighted[v] + e.cost;
            VtoE[e.to] = e.id;
            dfs_sz(e.to, v, hld);
            sz[v] += sz[e.to];
            if (hld && chmax(hld_sz, sz[e.to]) && l < i) { swap(csr[l], csr[i]); }
        }
    }

    void dfs_hld(int v, int &times) {
        LID[v] = times++;
        RID[v] += LID[v];
        V[LID[v]] = v;
        bool heavy = true;
        for (auto &&e: G[v]) {
            if (depth[e.to] <= depth[v]) continue;
            head[e.to] = (heavy ? head[v] : e.to);
            heavy = false;
            dfs_hld(e.to, times);
        }
    }

    vector<int> heavy_path_at(int v) {
        vector<int> P = {v};
        while (1) {
            int a = P.back();
            for (auto &&e: G[a]) {
                if (e.to != parent[a] && head[e.to] == v) {
                    P.emplace_back(e.to);
                    break;
                }
            }
            if (P.back() == a) break;
        }
        return P;
    }

    int heavy_child(int v) {
        int k = LID[v] + 1;
        if (k == N) return -1;
        int w = V[k];
        return (parent[w] == v ? w : -1);
    }

    int e_to_v(int eid) {
        auto e = G.edges[eid];
        return (parent[e.frm] == e.to ? e.frm : e.to);
    }

    int v_to_e(int v) { return VtoE[v]; }
    int get_eid(int u, int v) {
        if (parent[u] != v) swap(u, v);
        assert(parent[u] == v);
        return VtoE[u];
    }
    int ELID(int v) { return 2 * LID[v] - depth[v]; }
    int ERID(int v) { return 2 * RID[v] - depth[v] - 1; }

    /* k: 0-indexed */
    int la(int v, int k) {
        assert(k <= depth[v]);
        while (1) {
            int u = head[v];
            if (LID[v] - k >= LID[u]) return V[LID[v] - k];
            k -= LID[v] - LID[u] + 1;
            v = parent[u];
        }
    }

    int lca(int u, int v) {
        for (;; v = parent[head[v]]) {
            if (LID[u] > LID[v]) swap(u, v);
            if (head[u] == head[v]) return u;
        }
    }

    int meet(int a, int b, int c) { return lca(a, b) ^ lca(a, c) ^ lca(b, c); }

    int lca_root(int u, int v, int root) {
        return lca(u, v) ^ lca(u, root) ^ lca(v, root);
    }

    int subtree_size(int v, int root = -1) {
        if (root == -1) return RID[v] - LID[v];
        if (v == root) return N;
        int x = jump(v, root, 1);
        if (in_subtree(v, x)) return RID[v] - LID[v];
        return N - RID[x] + LID[x];
    }

    int dist(int a, int b) {
        int c = lca(a, b);
        return depth[a] + depth[b] - 2 * depth[c];
    }

    WT dist_weighted(int a, int b) {
        int c = lca(a, b);
        return depth_weighted[a] + depth_weighted[b] - WT(2) * depth_weighted[c];
    }

    // a is in b
    bool in_subtree(int a, int b) { return LID[b] <= LID[a] && LID[a] < RID[b]; }

    int jump(int a, int b, long long k) {
        if (k == 1) {
            if (a == b) return -1;
            return (in_subtree(b, a) ? la(b, depth[b] - depth[a] - 1) : parent[a]);
        }
        int c = lca(a, b);
        int d_ac = depth[a] - depth[c];
        int d_bc = depth[b] - depth[c];
        if (k > d_ac + d_bc) return -1;
        if (k <= d_ac) return la(a, k);
        return la(b, d_ac + d_bc - k);
    }

    vector<int> collect_child(int v) {
        vector<int> res;
        for (auto &&e: G[v]) if (e.to != parent[v]) res.emplace_back(e.to);
        ranges::sort(res);
        return res;
    }

    vector<int> collect_light(int v) {
        vector<int> res;
        bool skip = true;
        for (auto &&e: G[v])
            if (e.to != parent[v]) {
                if (!skip) res.emplace_back(e.to);
                skip = false;
            }
        return res;
    }

    vector<pair<int, int>> get_path_decomposition(int u, int v, bool edge) {
        vector<pair<int, int>> up, down;
        while (1) {
            if (head[u] == head[v]) break;
            if (LID[u] < LID[v]) {
                down.emplace_back(LID[head[v]], LID[v]);
                v = parent[head[v]];
            } else {
                up.emplace_back(LID[u], LID[head[u]]);
                u = parent[head[u]];
            }
        }
        if (LID[u] < LID[v]) down.emplace_back(LID[u] + edge, LID[v]);
        else if (LID[v] + edge <= LID[u]) up.emplace_back(LID[u], LID[v] + edge);
        reverse(down.begin(), down.end());
        up.insert(up.end(), down.begin(), down.end());
        return up;
    }

    vector<int> restore_path(int u, int v) {
        vector<int> P;
        for (auto &&[a, b]: get_path_decomposition(u, v, 0)) {
            if (a <= b) for (int i = a; i <= b; i++) P.emplace_back(V[i]);
            else for (int i = a; i >= b; i--) P.emplace_back(V[i]);
        }
        return P;
    }

    // path intersection of [a, b] x [c, d]
    // {-1, -1} if there wasn't any intersection
    // https://codeforces.com/problemset/problem/500/G
    pair<int, int> path_intersection(int a, int b, int c, int d) {
        int ab = lca(a, b), ac = lca(a, c), ad = lca(a, d);
        int bc = lca(b, c), bd = lca(b, d), cd = lca(c, d);
        int x = ab ^ ac ^ bc, y = ab ^ ad ^ bd; // meet(a,b,c), meet(a,b,d)
        if (x != y) return {x, y};
        int z = ac ^ ad ^ cd;
        if (x != z) x = -1;
        return {x, x};
    }
};
} // namespace mitsuha

class Solution {
public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        
        vector<int> ord;
        
        int n = len(parent);
        ord.reserve(n);
        
        vector<vector<int>> adj(n);
        vector<int> sz(n, 1);
        For(x, 1, n) adj[parent[x]].push_back(x);

        auto dfs = [&](auto &&dfs, int v)-> int{
            for (auto &ch: adj[v]){
                sz[v] += dfs(dfs, ch);
            }
            ord.push_back(v);
            return sz[v];
        };

        dfs(dfs, 0);

        str t(n, 'a');

        For(x, n){
            t[x] = s[ord[x]];
        }

        str r = t;
        ranges::reverse(r);

        RollingHash Rh;

        auto Fh = Rh.build(t);
        auto Bh = Rh.build(r);

        vector<bool> ret(n);

        For(x, n){
            int v = ord[x];

            auto F = Rh.query(Fh, x + 1 - sz[v], x + 1);
            auto B = Rh.query(Bh, n - 1 - x, n - 1 - x + sz[v]);
            ret[ord[x]] = F == B;
        }
        return ret;
    }
};

",1427919673
Kashyap Sukshavasi,enkixly,576,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length(), result = 0;
        
        for(int len = 1; len <= n; len++) {
            vector<int> freq(26, 0);
            
            for(int i = 0; i < len; i++) {
                freq[s[i] - 'a']++;
            }
            
            if(hasCharWithFreqK(freq, k)) result++;
            
            for(int i = len; i < n; i++) {
                freq[s[i] - 'a']++;
                freq[s[i-len] - 'a']--;
                if(hasCharWithFreqK(freq, k)) result++;
            }
        }
        return result;
    }
    
private:
    bool hasCharWithFreqK(vector<int>& freq, int k) {
        for(int f : freq) {
            if(f >= k) return true;
        }
        return false;
    }
};",1427826958
Kashyap Sukshavasi,enkixly,576,3566,cpp,"class Solution {
public:
   vector<string> stringSequence(string target) {
       vector<string> result;
       string curr = """"; 
       
       curr += 'a';
       result.push_back(curr);
       
       for(int i = 0; i < target.length(); i++) {
           if(i == 0 && target[i] == 'a') continue;
           
           if(i >= curr.length()) {
               curr += 'a';
               result.push_back(curr);
           }
           
           char lastChar = curr.back();
           while(lastChar != target[i]) {
               lastChar = (lastChar - 'a' + 1) % 26 + 'a';
               curr.back() = lastChar;
               result.push_back(curr);
           }
       }
       
       return result;
   }
};",1427825534
Kashyap Sukshavasi,enkixly,576,3603,cpp,"#include <vector>
#include <deque>
#include <unordered_map>
#include <string>

using namespace std;

class Solution {
public:
    long long modMultiply(long long a, long long b, long long mod) {
        long long result = 0;
        a %= mod;
        while (b > 0) {
            if (b % 2 == 1) {
                result = (result + a) % mod;
            }
            a = (a * 2) % mod;
            b /= 2;
        }
        return result;
    }

    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> children(n);

        for (int i = 1; i < n; ++i) {
            children[parent[i]].push_back(i);
        }

        const long long basePrimary = 911382628;
        const long long modPrimary = 1000000000000000007LL;
        const long long baseSecondary = 3571;
        const long long modSecondary = 1000000000000000009LL;

        int maxLen = n + 1;
        vector<long long> basePowerPrimary(maxLen, 1);
        vector<long long> basePowerSecondary(maxLen, 1);

        for (int i = 1; i < maxLen; ++i) {
            basePowerPrimary[i] = modMultiply(basePowerPrimary[i - 1], basePrimary, modPrimary);
            basePowerSecondary[i] = modMultiply(basePowerSecondary[i - 1], baseSecondary, modSecondary);
        }

        // Initialize hash arrays for forward and reverse hashes
        vector<long long> forwardHashPrimary(n, 0), reverseHashPrimary(n, 0);
        vector<long long> forwardHashSecondary(n, 0), reverseHashSecondary(n, 0);
        vector<int> subtreeLen(n, 1);
        vector<int> inDegree(n, 0);

        for (int i = 0; i < n; ++i) {
            inDegree[i] = children[i].size();
        }

        deque<int> bfsQueue;
        for (int i = 0; i < n; ++i) {
            if (inDegree[i] == 0) {
                bfsQueue.push_back(i);
            }
        }

        unordered_map<long long, int> subtreeHashPrimary;
        unordered_map<long long, int> subtreeHashSecondary;

        while (!bfsQueue.empty()) {
            int current = bfsQueue.front();
            bfsQueue.pop_front();

            long long combinedPrimaryHash = 0;
            for (int child : children[current]) {
                combinedPrimaryHash = (modMultiply(combinedPrimaryHash, basePowerPrimary[subtreeLen[child]], modPrimary) + forwardHashPrimary[child]) % modPrimary;
            }
            combinedPrimaryHash = (modMultiply(combinedPrimaryHash, basePrimary, modPrimary) + s[current]) % modPrimary;
            forwardHashPrimary[current] = combinedPrimaryHash;

            long long reversePrimaryHash = s[current];
            for (int i = children[current].size() - 1; i >= 0; --i) {
                int child = children[current][i];
                reversePrimaryHash = (modMultiply(reversePrimaryHash, basePowerPrimary[subtreeLen[child]], modPrimary) + reverseHashPrimary[child]) % modPrimary;
            }
            reverseHashPrimary[current] = reversePrimaryHash;

            long long combinedSecondaryHash = 0;
            for (int child : children[current]) {
                combinedSecondaryHash = (modMultiply(combinedSecondaryHash, basePowerSecondary[subtreeLen[child]], modSecondary) + forwardHashSecondary[child]) % modSecondary;
            }
            combinedSecondaryHash = (modMultiply(combinedSecondaryHash, baseSecondary, modSecondary) + s[current]) % modSecondary;
            forwardHashSecondary[current] = combinedSecondaryHash;

            long long reverseSecondaryHash = s[current];
            for (int i = children[current].size() - 1; i >= 0; --i) {
                int child = children[current][i];
                reverseSecondaryHash = (modMultiply(reverseSecondaryHash, basePowerSecondary[subtreeLen[child]], modSecondary) + reverseHashSecondary[child]) % modSecondary;
            }
            reverseHashSecondary[current] = reverseSecondaryHash;

            int totalSubtreeLength = 1;
            for (int child : children[current]) {
                totalSubtreeLength += subtreeLen[child];
            }
            subtreeLen[current] = totalSubtreeLength;

            if (current != 0) {
                int parentIdx = parent[current];
                inDegree[parentIdx]--;
                if (inDegree[parentIdx] == 0) {
                    bfsQueue.push_back(parentIdx);
                }
            }
        }

        vector<bool> result(n, false);
        for (int i = 0; i < n; ++i) {
            if (forwardHashPrimary[i] == reverseHashPrimary[i] && forwardHashSecondary[i] == reverseHashSecondary[i]) {
                result[i] = true;
            }
        }

        return result;
    }
};
",1427952248
dinhlockt02,dinhlockt02,577,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        counter = [0] * 26 
        i, j = 0, 0

        result = 0
        while j < len(s):
            index = ord(s[j]) - ord('a')
            counter[index] += 1
            j += 1

            while self.isValid(counter, k):
                result += len(s) - j + 1
                index = ord(s[i]) - ord('a')
                counter[index] -= 1
                i += 1
            
        return result
        

    def isValid(self, counter: List[int], k : int) -> bool:
        for item in counter:
            if item >= k:
                return True

        return False",1427844129
dinhlockt02,dinhlockt02,577,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = []
        a_ord = ord('a')
        for i in range(len(target)):
            c_ord = ord(target[i])
            prev = target[:i]

            for i in range(a_ord, c_ord + 1):
                result.append(prev + chr(i))
        return result",1427826846
dinhlockt02,dinhlockt02,577,3603,python3,"class Solution:
    MOD = 1000000007

    def multiply(self, x: int, y: int) -> int:
        return ((x % Solution.MOD) * (y % Solution.MOD)) % Solution.MOD

    def add(self, x: int, y: int) -> int:
        return ((x % Solution.MOD) + (y % Solution.MOD)) % Solution.MOD

    def char(self, s: str) -> int:
        return ord(s) - ord('a') + 1

    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        dp = [None] * len(parent)

        children = [[] for _ in parent]

        for i in range(1, len(parent)):
            children[parent[i]].append(i)

        def dfs(i: int) -> Tuple[int, int, int]:
            nonlocal dp, children

            if dp[i] is not None:
                return dp[i]

            if len(children[i]) == 0:
                dp[i] =  (self.char(s[i]), self.char(s[i]), 1)
                return dp[i]

            count = 0

            left_to_right = 0
            for j in range(0, len(children[i])):
                child = children[i][j]
                left_to_right_child, _, count_child = dfs(child)
                left_to_right = self.add(
                    self.multiply(
                        left_to_right,
                        pow(29, count_child, Solution.MOD)
                    ),
                    left_to_right_child
                )
                count += count_child

            left_to_right = self.add(
                self.multiply(
                    left_to_right,
                    29
                ),
                self.char(s[i])
            )

            right_to_left = 0
            for j in range(len(children[i]) - 1, -1, -1):
                child = children[i][j]
                _, right_to_left_child , count_child = dfs(child)
                right_to_left = self.add(
                    self.multiply(
                        right_to_left,
                        pow(29, count_child, Solution.MOD)
                    ),
                    right_to_left_child
                )

            right_to_left = self.add(
                self.multiply(
                    self.char(s[i]),
                    pow(29, count, Solution.MOD)
                ),
                right_to_left
            )

            dp[i] = (left_to_right, right_to_left, count + 1)

            return dp[i]

        answers = []
        for i in range(len(parent)):
            left_to_right, right_to_left, _ = dfs(i)
            answers.append(left_to_right == right_to_left)
        return answers",1427952690
Sarthak Tirpude,sarthak_tirpude,578,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int y) {
        int n=s.size();
        int ans=0;
        for(int i =0;i<n;++i){
            vector<int> temp(26);
            for(int j=i;j<n;++j){
                temp[s[j]-'a']++;
                bool p = false;
                for(int k=0;k<26;++k){
                    if(temp[k]>=y) p=true;
                }
                if(p) ++ans;
            }
        }
        return ans;
    }
};",1427828902
Sarthak Tirpude,sarthak_tirpude,578,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string curr;
        vector<string> ans;
        for(char c:target){
            char ch = 'a';
            curr+=ch;
            ans.push_back(curr);
            while(ch!=c){
                curr.pop_back();
                ++ch;
                curr.push_back(ch);
                ans.push_back(curr);
                
            }
        }
        return ans;
    }
};",1427825254
Sarthak Tirpude,sarthak_tirpude,578,3603,cpp,"#define ll long long 
ll int mod = (int)(1e9 + 7);
ll int binary_exponentiation(ll int a,ll int b){
    a%=mod;
    ll int result = 1,base = a, exp = b;
    while (exp > 0) {
        if (exp & 1){
            result = result * base;
            result %= mod;
        }
        base = base * base;
        base %= mod;
        exp >>= 1;
    }
    return result%mod;
}
class Solution {
public:
    vector<int> hashValue, revHashValue;
    vector<int> subtreeSize;
    string s;
    vector<vector<int>> tree;
    int dfs(int root,int par){
        int res = 1;
        for(auto child:tree[root]){
            if(child == par) continue;
            res += dfs(child,root);
        }
        subtreeSize[root] = res;        
        return res;
    }
    int dfs2(int root,int par){
        ll int res = 0;
        for(auto child:tree[root]){
            if(child == par) continue;
            res = (res * binary_exponentiation(31,subtreeSize[child])) % mod;
            res += dfs2(child,root);
            res %= mod;
        }
        res *= 31;
        res += (s[root] - 'a' + 1);
        res %= mod;
        //cout<<""dfs2, ""<<root<<"" val: ""<<res<<endl;
        hashValue[root] = res;
        return res;
    }
    int dfs3(int root,int par){
        ll int res = (s[root] - 'a' + 1);
        int n = tree[root].size();
        for(int i=n-1;i>=0;--i){
            if(tree[root][i] == par) continue;
            res = (res * binary_exponentiation(31,subtreeSize[tree[root][i]])) % mod;
            res += dfs3(tree[root][i],root);
            res %= mod;
        }
        //cout<<""dfs3, ""<<root<<"" val: ""<<res<<endl;
        revHashValue[root] = res;
        return res;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();
        tree.resize(n);
        for(int i=0;i<n;++i){
            if(parent[i]==-1) continue;
            tree[i].push_back(parent[i]);
            tree[parent[i]].push_back(i);
        }
        for(int i=0;i<n;++i){
            sort(tree[i].begin(),tree[i].end());
        }
        
        this->s = s;
        hashValue.resize(n);
        revHashValue.resize(n);
        subtreeSize.resize(n);
        dfs(0,0);
        dfs2(0,0);
        dfs3(0,0);
        vector<bool> ans(n,false);
        for(int i=0;i<n;++i){
            if(hashValue[i] == revHashValue[i]) ans[i] = true;
        }
        return ans;
        
        
        
    }
};",1427953638
Cecilia Chan,cecilia5,579,3502,python,"class Solution(object):
    def numberOfSubstrings(self, s, k):
        log = False
        hist = {}
        start = 0
        end = 0
        count = 0
        last = 0
        while end < len(s):
            c = s[end]
            end += 1
            
            if c not in hist:
                hist[c] = 0
            hist[c] += 1
            if log:
                print(""Processing "", c)
                print(""hist = "", hist)
            if hist[c] == k:
                for di in range(start, end):
                    d = s[di]
                    hist[d] -= 1
                    if d == c:
                        start = di
                        break
                cur_count = (start - last + 1) * (len(s) - end + 1)
                if log:
                    print(start, end, c)
                    print((start - last + 1), (len(s) - end + 1), cur_count)
                last = start + 1
                count += cur_count
                start += 1
        return count",1427849575
Cecilia Chan,cecilia5,579,3566,python,"class Solution(object):
    def stringSequence(self, target):
        l = []
        s = """"
        for ch in target:
            c = ord(ch) - ord('a')
            for i in range(c + 1):
                d = i + ord('a')
                dh = chr(d)
                l.append(s + dh)
            s += dh
        return l",1427826453
Cecilia Chan,cecilia5,579,3603,python3,"
class Solution(object):
    def dfs(self, cur, adj, s, result, ranges):
        start = len(result)
        for neighbor in adj[cur]:
            self.dfs(neighbor, adj, s, result, ranges)
        result.append(s[cur])
        end = len(result)
        ranges[cur] = (start, end)

    def findAnswer(self, parent, s):
        log = False
        adj = [[] for _ in parent]
        for (i, p) in enumerate(parent[1:]):
            adj[p].append(i + 1)
        print(adj)
        result = []
        ranges = [None] * len(parent)
        self.dfs(0, adj, s, result, ranges)

        v = ['^']
        for c in result:
            v.append(c)
            v.append('#')
        v.pop()
        v.append('$')

        current_start = -1
        current_center = -1
        current_end = -1
        n = len(v)
        half_lengths = []
        ans = None
        for i in range(n):
            if i <= current_end:
                mirror = 2 * current_center - i
                r = min(half_lengths[mirror], current_end - i)
            else:
                mirror = -1
                r = 0
            save = r
            p = i - r
            q = i + r
            while p > 0 and q < (n-1) and v[p-1] == v[q+1]:
                p -= 1
                q += 1
            if q > current_end:
                current_start = p
                current_center = i
                current_end = q
            half_lengths.append((q - p) // 2)
            if log:
                print("""".join(v))
                print("" "" * p, end="""")
                print("""".join(v[p:q+1]), end="""")
                print("" "" * (n - q))
                print("" "" * current_start, end="""")
                print(""*"" * (current_end - current_start + 1), end="""")
                print("" "" * (n - current_end))
                if mirror != -1:
                    print("" "" * (mirror - save) + ""+"" * (2 * save + 1))
                print()
        final = []
        for (l, r) in ranges:
            l *= 2
            l += 1
            r *= 2
            length = r - l
            half = length // 2
            mid = l + half
            final.append(half_lengths[mid] >= half)
        return final",1427945818
James Jialun Zhao,frixxxer,580,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ctr = [0]*26
        above = 0
        lo = 0
        ct = 0
        for i, c in enumerate(s):
            c = ord(c) - ord('a')
            ctr[c] += 1
            if ctr[c] >= k:
                above += 1
            while above:
                ct += len(s) - i
                lo_val = ord(s[lo]) - ord('a')
                ctr[lo_val] -= 1
                if ctr[lo_val] == k-1:
                    above -= 1
                lo += 1
        return ct",1427830974
James Jialun Zhao,frixxxer,580,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        out = []
        cur = []
        while len(cur) < len(target) or cur[-1] != target[-1]:
            if cur and cur[len(cur) - 1] != target[len(cur) - 1]:
                cur[-1] = chr(ord(cur[-1]) + 1)
            else:
                cur.append(""a"")
            out.append("""".join(cur))
        return out",1427824886
James Jialun Zhao,frixxxer,580,3603,python3,"class Solution:
    def dfs(self, graph, full_len, forward_hash_store, backward_hash_store, s, i, bases):
        M = 100_000_007
        value = ord(s[i]) - ord('a') + 1
        if len(graph[i]) == 0:
            forward_hash_store[i] = value
            backward_hash_store[i] = value
            return
        for ii in graph[i]:
            self.dfs(graph, full_len, forward_hash_store, backward_hash_store, s, ii, bases)
        forward_hash = 0
        backward_hash = 0
        ctr = 0
        for ii in graph[i]:
            len_ii = full_len[ii]
            forward_hash = (forward_hash * bases[len_ii] + forward_hash_store[ii]) % M
            backward_hash = (backward_hash_store[ii] * bases[ctr] + backward_hash) % M
            ctr += len_ii
        forward_hash = (forward_hash * bases[1] + value) % M
        backward_hash = (backward_hash + value * bases[ctr]) % M
        forward_hash_store[i] = forward_hash
        backward_hash_store[i] = backward_hash
            
    def get_count_lookup(self, graph, count_vector, i):
        if len(graph[i]) == 0:
            count_vector[i] = 1
            return 1
        count_vector[i] = 1 + sum([self.get_count_lookup(graph, count_vector, ii) for ii in graph[i]])
        return count_vector[i]
    def get_k(self, graph, full_len, hash_store, s, i, bases, k, is_forward = True):
        if full_len[i] <= k:
            return hash_store[i], full_len[i]
        value = ord(s[i]) - ord('a') + 1
        cum_hash = 0 if is_forward else value
        consumed = 0 if is_forward else 1
        iterator = graph[i] if is_forward else reversed(graph[i])
        for ii in iterator:
            hash_val, retrieved = self.get_k(graph, full_len, hash_store, s, ii, bases, k - consumed, is_forward)
            consumed += retrieved
            if is_forward:
                cum_hash = (cum_hash * bases[retrieved] + hash_val) % 100_000_007
            else:
                cum_hash = (hash_val * bases[retrieved] + cum_hash) % 100_000_007
            if consumed == k:
                break
        return cum_hash, consumed
    def search(self, graph, solution, full_len, forward_hash_store, backward_hash_store, s, i, bases):
        num_children = full_len[i]

        forw = self.get_k(graph, full_len, forward_hash_store, s, i, bases, num_children // 2, is_forward = True)
        back = self.get_k(graph, full_len, backward_hash_store, s, i, bases, num_children // 2 - 1, is_forward = False)
        print(i, forw[0], back[0])
        solution[i] = forw == back

    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        graph = defaultdict(list)
        solution = [None] * len(s)
        count_vector = [0] * len(s)
        forward_hash_store = [0] * len(s)
        backward_hash_store = [0] * len(s)
        for i, p in enumerate(parent):
            graph[p].append(i)
        base = 29
        M = 100_000_007
        bases = [1] * (len(s) + 1)
        bases[1] = base
        for i in range(2, len(bases)):
            bases[i] = (bases[i-1] * base) % M
        self.get_count_lookup(graph, count_vector, 0)
        full_len = count_vector
        self.dfs(graph, count_vector, forward_hash_store, backward_hash_store, s, 0, bases)
        # print(forward_hash_store)
        # print(backward_hash_store)
        
        for i in range(len(s)):
            solution[i] = forward_hash_store[i] == backward_hash_store[i]
            # self.search(graph, solution, full_len, forward_hash_store, backward_hash_store, s, i, bases)
        return solution
        ",1427946599
Sarthak Jha,SarthakkJha,581,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;

        for (int i = 0; i < n; i++) {
            unordered_map<char, int> freq;

            for (int j = i; j < n; j++) {
                freq[s[j]]++;

                bool f = false;
                for (auto it : freq) {
                    if (it.second >= k) {
                        f = true;
                        break;
                    }
                }

                if (f) {
                    ans++;
                }
            }
        }

        return ans;
    }
};
",1427833941
Sarthak Jha,SarthakkJha,581,3566,cpp,"class Solution {
public:
    void find(string curr, int idx, string &target, vector<string> &result) {
        if (idx == target.size()) {
            return;
        }

        curr.push_back('a');
        result.push_back(curr);

        while (curr.back() != target[idx]) {
            curr.back()++;
            result.push_back(curr);
        }

        find(curr, idx + 1, target, result);
    }

    vector<string> stringSequence(string target) {

        vector<string> result;
        find("""", 0, target, result);
        return result;
    }
};
",1427826959
Sarthak Jha,SarthakkJha,581,3603,cpp,"class Solution {
public:
 void traverse(int node, vector<vector<int>>& adj, string& s, vector<char>& trav, vector<int>& start, vector<int>& end) {
        start[node] = trav.size();
        for(auto it : adj[node]) {
            traverse(it, adj, s, trav, start, end);
        }
        trav.push_back(s[node]);
        end[node] = trav.size() - 1;
    }
    vector<bool> findAnswer(vector<int>& parent, string s) {
        int n = parent.size();

        vector<vector<int>> adj(n);
        
        for(int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        
        vector<char> trav;
        vector<int> start(n), end(n);
        
        for(auto& it : adj) {
            sort(it.begin(), it.end());
        }

        traverse(0, adj, s, trav, start, end);

        vector<char> rev(trav);
        
        reverse(rev.begin(), rev.end());

        long long M1 = 1000000007LL, M2 = 1000000009LL;
        int B = 53;

        vector<long long> hash1(trav.size() + 1, 0), hash2(trav.size() + 1, 0);
        vector<long long> rhash1(rev.size() + 1, 0), rhash2(rev.size() + 1, 0);

        for(int i = 0; i < rev.size(); i++) {
            rhash1[i + 1] = (rhash1[i] * B + (rev[i] - 'a' + 1)) % M1;
            rhash2[i + 1] = (rhash2[i] * B + (rev[i] - 'a' + 1)) % M2;
        }

        for(int i = 0; i < trav.size(); i++) {
            hash1[i + 1] = (hash1[i] * B + (trav[i] - 'a' + 1)) % M1;
            hash2[i + 1] = (hash2[i] * B + (trav[i] - 'a' + 1)) % M2;
        }

        vector<bool> ans(n, false);

        vector<long long> p1(trav.size() + 1, 1), p2(trav.size() + 1, 1);

        for(int i = 1; i <= trav.size(); i++) {
            p1[i] = (p1[i - 1] * B) % M1;
            p2[i] = (p2[i - 1] * B) % M2;
        }

        for(int i = 0; i < n; i++) {
            int l = start[i], r = end[i];
            int rl = trav.size() - 1 - end[i], rr = trav.size() - 1 - start[i];

            bool f = false;

            long long firsthalf1 = (hash1[r + 1] - hash1[l] * p1[r - l + 1] % M1 + M1) % M1;
            long long lasthalf1 = (rhash1[rr + 1] - rhash1[rl] * p1[rr - rl + 1] % M1 + M1) % M1;

            if(firsthalf1 == lasthalf1)
            {
                f = true;
            }

            long long firsthalf2 = (hash2[r + 1] - hash2[l] * p2[r - l + 1] % M2 + M2) % M2;
            long long secondhalf2 = (rhash2[rr + 1] - rhash2[rl] * p2[rr - rl + 1] % M2 + M2) % M2;

            if(f and firsthalf2 == secondhalf2)
            {
                ans[i] = true;
            }
            else
            {
                ans[i] = false;
            }
        }

        return ans;
    }


   
};
",1427954904
Jayesh Batra,jayeshbatra0287,583,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            unordered_map<char,int> mpp;
            for (int j=i;j<n;j++) {
                char ch = s[j];
                mpp[ch]++;  
                bool flag = false;
                for (auto itr : mpp) {
                    int freq = itr.second;
                    if(freq == k){
                        flag = true;
                        break;
                    }
                    if (freq > k) {
                        flag = true;
                        break;
                    }
                }
                int u = 0;
                if(!flag)
                    u++;
                else
                    ans++;
            }
        }
        return ans;
    }
};",1427843362
Jayesh Batra,jayeshbatra0287,583,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
    vector<string> ans;
    string temp = """";  
    for (auto itr : target) {
        temp += 'a';
        ans.push_back(temp); 
        if(temp.back() == itr)  
            continue;
        while (temp.back() != itr) {
            if(temp.back() == 'z')
                temp.back() = 'a';
            else
                temp.back() = temp.back() + 1;
            ans.push_back(temp);  
        }
    }
    return ans;
    }
};",1427840819
Jayesh Batra,jayeshbatra0287,583,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& numo, string s) {
        int n = numo.size();
        const long P = 911;
        const long m = 1000000007;
        vector<bool> res(n, false);
        vector<vector<int>> chn(n);
        for (int i = 1; i < n; i++)
            chn[numo[i]].push_back(i);
        vector<long> temp(n + 2, 1);
        for (int i = 1; i <= n + 1; i++) 
            temp[i] = (temp[i - 1] * P) % m;
        vector<int> numsX;
        vector<int> numsY;
        stack<int> stack;
        vector<bool> check(n, false);
        stack.push(0);
        while (!stack.empty()) {
            int itrX = stack.top();
            if (check[itrX]) {
                stack.pop();
                numsX.push_back(itrX);
            } 
            else {
                int osc = chn[itrX].size()-1;
                for (int i = osc; i >= 0; i--)
                    stack.push(chn[itrX][i]);
                check[itrX] = true;
            }
        }
        numsY = numsX;
        vector<long> fwd(n, 0); 
        vector<long> rev(n, 0); 
        vector<int> len(n, 0);
        for (int itrX : numsY) {
            len[itrX] = 1;
            long c1 = 0;
            for (int itr : chn[itrX]) {
                c1 = (c1 * temp[len[itr]] + fwd[itr]) % m;
                len[itrX] += len[itr];
            }
            c1 = (c1 * P + (s[itrX] - 'a' + 1)) % m;
            fwd[itrX] = c1;
            long c2 = (s[itrX] - 'a' + 1);
            int osc = chn[itrX].size()-1;
            for (int i = osc;i>=0;i--) 
                c2 = (c2 * temp[len[chn[itrX][i]]] + rev[chn[itrX][i]]) % m;
            rev[itrX] = c2;
            if(fwd[itrX] == rev[itrX])
                res[itrX] = true;
            else
                res[itrX] = false;
        }
        return res;
    }
};",1427958468
Kumar Daksh,kumardaksshh,586,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string input, int threshold) {
        int length = getStringLength(input);
        int totalCount = initializeResult();

        for (int start = 0; start < length; start++) {
            vector<int> characterFrequency = initializeFrequency();
            for (int end = start; end < length; end++) {
                updateCharacterFrequency(characterFrequency, input[end]);
                if (isValidSubstring(characterFrequency, threshold)) {
                    incrementCount(totalCount);
                }
            }
        }

        return totalCount;
    }

private:
    
    int getStringLength(const string &input) {
        return input.length();
    }

  
    int initializeResult() {
        return 0;
    }

    
    vector<int> initializeFrequency() {
        return vector<int>(26, 0);  
    }

  
    void updateCharacterFrequency(vector<int> &freq, char character) {
        freq[character - 'a']++;
    }

    
    bool isValidSubstring(const vector<int> &freq, int threshold) {
        for (int count : freq) {
            if (count >= threshold) {
                return true;
            }
        }
        return false;
    }

    
    void incrementCount(int &totalCount) {
        totalCount++;
    }
};
",1427956709
Kumar Daksh,kumardaksshh,586,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> sequence = initializeSequence();
        string build = initializeString();

        for (char character : getTargetCharacters(target)) {
            appendToString(build);
            sequence.push_back(getCurrentString(build));
            
            while (!isMatchingLastCharacter(build, character)) {
                incrementLastCharacter(build);
                sequence.push_back(getCurrentString(build));
            }
        }

        return sequence;
    }

private:
    
    vector<string> initializeSequence() {
        return {};
    }

    
    string initializeString() {
        return """";
    }

    
    vector<char> getTargetCharacters(const string &target) {
        return vector<char>(target.begin(), target.end());
    }

    
    void appendToString(string &currentString) {
        currentString += 'a';
    }

    
    string getCurrentString(const string &currentString) {
        return currentString;
    }

    
    bool isMatchingLastCharacter(const string &currentString, char targetCharacter) {
        return currentString.back() == targetCharacter;
    }

    
    void incrementLastCharacter(string &currentString) {
        currentString.back()++;
    }
};
",1427954346
Kumar Daksh,kumardaksshh,586,3603,cpp,"class Solution {
public:
    vector<bool> findAnswer(vector<int>& ancestors, string characters) {
        int countNodes = getNodeCount(ancestors);
        vector<bool> result = initializeResult(countNodes);
        vector<int> treeStructure = createTreeStructure(ancestors);
        vector<vector<int>> childNodes = buildChildNodes(ancestors);
        long long basePrime = setBasePrime();
        long long modValue = setModulus();
        vector<long long> powerArray = precomputePowers(countNodes, basePrime, modValue);
        vector<int> traversalOrder = generateTraversalOrder(childNodes, countNodes);
        vector<int> lengths = initializeLengths(countNodes);
        vector<long long> forwardHashes = initializeHashes(countNodes);
        vector<long long> reverseHashes = initializeHashes(countNodes);
        processNodes(traversalOrder, lengths, forwardHashes, reverseHashes, childNodes, characters, powerArray, basePrime, modValue, result);
        return result;
    }

private:
    int getNodeCount(const vector<int>& ancestors) {
        return ancestors.size();
    }

    vector<bool> initializeResult(int size) {
        return vector<bool>(size);
    }

    vector<int> createTreeStructure(const vector<int>& ancestors) {
        return ancestors;
    }

    vector<vector<int>> buildChildNodes(const vector<int>& ancestors) {
        int countNodes = getNodeCount(ancestors);
        vector<vector<int>> children(countNodes);
        for (int i = 1; i < countNodes; ++i) {
            children[ancestors[i]].push_back(i);
        }
        return children;
    }

    long long setBasePrime() {
        return 911;
    }

    long long setModulus() {
        return 1000000007;
    }

    vector<long long> precomputePowers(int size, long long basePrime, long long modValue) {
        vector<long long> powerArray(size + 2, 1);
        for (int i = 1; i <= size + 1; ++i) {
            powerArray[i] = (powerArray[i - 1] * basePrime) % modValue;
        }
        return powerArray;
    }

    vector<int> generateTraversalOrder(const vector<vector<int>>& children, int countNodes) {
        vector<int> traversalOrder;
        stack<int> nodeStack;
        vector<bool> visited(countNodes, false);
        nodeStack.push(0);

        while (!nodeStack.empty()) {
            int node = nodeStack.top();
            if (!visited[node]) {
                visited[node] = true;
                for (int i = children[node].size() - 1; i >= 0; --i) {
                    nodeStack.push(children[node][i]);
                }
            } else {
                nodeStack.pop();
                traversalOrder.push_back(node);
            }
        }

        return traversalOrder;
    }

    vector<int> initializeLengths(int size) {
        return vector<int>(size, 1);
    }

    vector<long long> initializeHashes(int size) {
        return vector<long long>(size, 0);
    }

    void processNodes(const vector<int>& traversalOrder, vector<int>& lengths, vector<long long>& forwardHashes, vector<long long>& reverseHashes,
                      const vector<vector<int>>& children, const string& characters, const vector<long long>& powerArray,
                      long long basePrime, long long modValue, vector<bool>& result) {

        for (int node : traversalOrder) {
            long long currentForwardHash = 0;
            for (int child : children[node]) {
                currentForwardHash = (currentForwardHash * powerArray[lengths[child]] + forwardHashes[child]) % modValue;
                lengths[node] += lengths[child];
            }
            currentForwardHash = (currentForwardHash * basePrime + (characters[node] - 'a' + 1)) % modValue;
            forwardHashes[node] = currentForwardHash;

            long long currentReverseHash = (characters[node] - 'a' + 1);
            for (int i = children[node].size() - 1; i >= 0; --i) {
                int child = children[node][i];
                currentReverseHash = (currentReverseHash * powerArray[lengths[child]] + reverseHashes[child]) % modValue;
            }
            reverseHashes[node] = currentReverseHash;

            result[node] = (forwardHashes[node] == reverseHashes[node]);
        }
    }
};
",1427962141
Pranto Das,PRANTO_DAS,587,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string &s, int k) {
        vector<int> f(26, 0);
        const int n = s.size();
        set<pair<int,int>> pq;
        int result = 0;
        for(int i = 0, j = 0; i < n; ) {
            if(pq.empty() || (j < n && (*pq.rbegin()).first < k)) {
                auto c = s[j++] - 'a';
                pq.erase({f[c], c});
                f[c]++;
                pq.insert({f[c], c});
            }
            else {
                auto c = s[i++] - 'a';
                pq.erase({f[c], c});
                f[c]--;
                pq.insert({f[c], c});
            }
            
            if(pq.size() && (*pq.rbegin()).first >= k) {
                result += n - j + 1;
            } 
        }
        return result;
    }
};",1427842532
Pranto Das,PRANTO_DAS,587,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        vector<string> result;
        for(auto c: target) {
            auto r = 'a';
            while(r != c) {
                result.push_back(s + r);
                r++; 
            }
            s += r;
            result.push_back(s);
        }
        return move(result);
    }
};",1427827139
Pranto Das,PRANTO_DAS,587,3603,cpp,"class Solution {
    vector<vector<int>> childs;
    vector<pair<int,int>> ranges;
    vector<bool> result;
    string s;
    string str;
    int n;

    void init(vector<int>& parent, string &_s) {
        s = move(_s);
        n = s.size();

        childs.assign(n, vector<int>());
        result.assign(n, false);
        ranges.assign(n, {});

        for(int i = 0; i < n; i++) {
            if(parent[i] > -1)
                childs[ parent[i]].push_back(i);
        }

        for(int i = 0; i < n; i++) {
            sort(childs[i].begin(), childs[i].end());
        }
    }

    bool isPalindrome(int i, int j) {
        while(i < j && str[i] == str[j]) i++, j--;
        return i >= j;
    }

    void dfs(int curr, int &pos) {
        
        int start = pos;
        string currStr = """";
        for(auto child: childs[curr]) {
            dfs(child, pos);
        }

        str += s[curr];
        pos++;
        ranges[curr] = {start, pos-1};
        //cout << curr << ""# "" << str.substr(start, pos-start) << endl;
    }

    string getTransofrmedString(string s) {
        string t = ""^"";
        for(auto c: s) {
            t.push_back('#');
            t.push_back(c);
        }
        t += ""#$"";
        return move(t);
    }

    void runManacher() {
        auto T = getTransofrmedString(str);
        const int n = T.size();
        cout << T << endl;

        cout << n << endl;
        int currentCenter = 0;
        int currentRight = 0;

        vector<int> pRadius(n, 0); // Palindrome Radius
        for(int i = 1; i < n-2; i++) {
            int mirrorIndex = 2*currentCenter - i; // center = (left + right)/2; so,
            if(i <= currentRight) { // current index is within current palindrome center radiius
                pRadius[i] = min(
                    pRadius[mirrorIndex],
                    currentRight - i // if this is less then pRadius[mirrorIndex], then we max radii is this
                );
            }

            while(T[i - pRadius[i] - 1] == T[i + pRadius[i] + 1]) {
                pRadius[i]++;
            }

            if(pRadius[i] > pRadius[currentCenter]) {
                currentCenter = i;
                currentRight = i + pRadius[i];
            }
        }

        // for(int i = 1; i < n-2; i++) {
        //     cout << i << "" -> "" << T[i] << "" # "" << pRadius[i] << endl;
        // }
        // cout << endl;

        for(int pos = 0; pos < str.size(); pos++) {
            int l = ranges[pos].first*2 + 2;
            int r = ranges[pos].second*2 + 2;
            int posRad = pRadius[(l+r) >> 1];

            //cout << str[pos] << "" # "" << posRad << "" >= "" << ranges[pos].second - ranges[pos].first + 1 << endl;

            result[pos] = posRad >= (ranges[pos].second - ranges[pos].first + 1);
        }
    }

public:
    vector<bool> findAnswer(vector<int>& parent, string &_s) {
        init(parent, _s);
        int pos = 0;
        dfs(0, pos);

        runManacher();

        return move(result);
    }
};",1427963677
Sai Krishna,saikrishna17394,588,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26, 0);
        int len = s.length();
        int ans = 0;

        for (int i = 0; i < len; i++) {
            
            for (int a = 0; a < 26; a++) {
                cnt[a] = 0;
            }

            for (int j = i; j < len; j++) {
                cnt[s[j] - 'a']++;

                if (cnt[s[j] - 'a'] == k) {
                    ans += len - j;
                    break;
                }
            }
        }
        
        return ans;
    }
};",1427828079
Sai Krishna,saikrishna17394,588,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur = """";

        for (const auto& ch : target) {

            for (char a = 'a'; a <= ch; a++) {
                ans.push_back(cur + a);
            }

            cur += ch;
        }

        return ans;
    }
};",1427824833
Sai Krishna,saikrishna17394,588,3603,cpp,"class Solution {
    vector<vector<int>> g;
    vector<int> sz;
    vector<bool> ans;
    vector<long long> v1;
    vector<long long> v2;
    vector<long long> rev1;
    vector<long long> rev2;
    
    int n;
    const long long mod1 = 998244353;
    const long long mod2 = 1e9 + 9;
    long long base = 31;
    string cur;

    int pow(long long num, int k, long long mod) {
        long long ret = 1;

        while (k > 0) {
            if (k & 1) {
                ret = (ret * num) % mod;
            }

            num = (num * num) % mod;

            k /= 2;
        }

        return ret;
    }

    void dfs(int u) {
        long long num = cur[u] - 'a' + 1;

        if (g[u].size() == 0) {
            v1[u] = num;
            v2[u] = num;
            rev1[u] = num;
            rev2[u] = num;
            ans[u] = true;
            return;
        }

        for (const auto& v : g[u]) {
            dfs(v);

            v1[u] *= pow(base, sz[v], mod1);
            v1[u] = (v1[u] + v1[v]) % mod1;

            v2[u] *= pow(base, sz[v], mod2);
            v2[u] = (v2[u] + v2[v]) % mod2;

            sz[u] += sz[v];
        }

        v1[u] *= base;
        v2[u] *= base;
        v1[u] = (v1[u] + num) % mod1;
        v2[u] = (v2[u] + num) % mod2;


        rev1[u] = num;
        rev2[u] = num;

        for (int i = g[u].size() - 1; i >= 0; i--) {
            int v = g[u][i];

            rev1[u] *= pow(base, sz[v], mod1);
            rev1[u] = (rev1[u] + rev1[v]) % mod1;

            rev2[u] *= pow(base, sz[v], mod2);
            rev2[u] = (rev2[u] + rev2[v]) % mod2;
        }

        if (v1[u] == rev1[u] && v2[u] == rev2[u]) {
            ans[u] = true;
        }
    }

public:
    vector<bool> findAnswer(vector<int>& parent, string s) {
        n = parent.size();
        g = vector<vector<int>>(n);
        sz = vector<int>(n, 1);

        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }

        cur = s;
        ans = vector<bool>(n, false);
        v1 = vector<long long>(n, 0);
        v2 = vector<long long>(n, 0);
        rev1 = vector<long long>(n);
        rev2 = vector<long long>(n);

        dfs(0);

        return ans;
    }
};",1427957110
Sission,user6184hf,589,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        c = defaultdict(int)
        l, n = 0, len(s)
        matched = 0
        res = 0

        for r, char in enumerate(s):
            c[char] += 1

            while c[char] == k:
                res += len(s) - r
                c[s[l]] -= 1
                l += 1

        return res


        ",1427844088
Sission,user6184hf,589,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        i, n = 0, len(target)
        matched = ''
        while i < n:
            curr = 'a'
            while curr != target[i]:
                res.append(matched + curr)
                curr = chr(ord(curr) + 1)
            matched += curr
            res.append(matched)
            i += 1
        return res",1427826682
Sission,user6184hf,589,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        # Constants for hashing
        base = 27
        mod = 10**9 + 7
        
        n = len(parent)
        
        children = defaultdict(list)
        for i, p in enumerate(parent):
            children[p].append(i)
        
        for key in children:
            children[key].sort(reverse=True)
        
        # Precompute base powers up to n
        base_pows = [1] * (n + 1)
        for i in range(1, n + 1):
            base_pows[i] = (base_pows[i - 1] * base) % mod
        
        # Initialize memoization lists
        lengths = [0] * n
        forward_hashes = [0] * n
        reverse_hashes = [0] * n
        
        def dfs(curr: int):
            if lengths[curr] != 0:
                return lengths[curr], forward_hashes[curr], reverse_hashes[curr]
            
            char_val = ord(s[curr]) - ord('a') + 1  # 'a' -> 1, 'b' -> 2, ..., 'z' -> 26
            length = 1
            f_hash = char_val
            r_hash = char_val
            
            for child in children[curr]:
                child_length, child_f_hash, child_r_hash = dfs(child)
                
                f_hash = (f_hash * base_pows[child_length] + child_f_hash) % mod
                

                r_hash = (child_r_hash * base_pows[length] + r_hash) % mod
                
                length += child_length
            
            lengths[curr] = length
            forward_hashes[curr] = f_hash
            reverse_hashes[curr] = r_hash
            
            return length, f_hash, r_hash
        
        for i in range(n):
            dfs(i)

        res = [False] * n
        for i in range(n):
            res[i] = forward_hashes[i] == reverse_hashes[i]
        
        return res
        
        # class Solution:
#     def findAnswer(self, parent: List[int], s: str) -> List[bool]:
#         children = defaultdict(list)
#         n = len(parent)
#         for i, p in enumerate(parent):
#             children[p].append(i)

#         for key in children:
#             children[key].sort(reverse=True)

#         res = []
#         self.hashmap = defaultdict(str)

#         def dfs(curr):
#             if curr not in children:
#                 self.hashmap[curr] = s[curr]
#                 return s[curr]
            
#             if curr in self.hashmap:
#                 return self.hashmap[curr]
            
#             string = s[curr]
#             for idx in children[curr]:
#                 string += dfs(idx)
#             self.hashmap[curr] = string
#             return string
        
        
#         for i in range(n):
#             curr_res = dfs(i)
#             res.append(curr_res == curr_res[::-1])
#         return res
        # for i in range(n-1, -1, -1):
        #     n_child = len(children[i])
        #     curr = s[i]
        #     for j in range(n_child - 1, -1, -1):
        #         curr += hashmap[children[i][j]]
        #     hashmap[i] = curr
        #     res.append(curr == curr[::-1])
        # print(hashmap)
        # return res[::-1]





            


",1427933646
Mamunuri_Vishwendra_2004,Mamunuri_Vishwendra_2004,591,3502,cpp,"// class Solution {
// public:
//     int numberOfSubstrings(string s, int k) {
        
//     }
// };
class Solution{
private:
    bool fun(unordered_map<char, int>& f, int b) {
        for (auto &j : f) {
            if (j.second >= b) 
                return true;
         } return false;
    }
public:
    int numberOfSubstrings(string a, int b) {
        int c = 0;int d = a.length();int e = 0;while (e < d) {
    unordered_map<char, int> f;
            int g = e;
        while (g < d) {
                char h = a[g];
                f[h]++;if (fun(f, b)) 
                    c++;
                g++;
            }
            e++;
        }return c;
    }
};",1427880356
Mamunuri_Vishwendra_2004,Mamunuri_Vishwendra_2004,591,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string a) {
        vector<string> b;
        string c = """";for (int d = 0; d < a.length(); d++) {
            char e = a[d];
            fun2(c, b);
            funh(c, e, b);
        } return b;
    }private:
    void fun2(string &f, vector<string> &g) {
        f += 'a';
        g.push_back(f);
    }void funh(string &h, char i, vector<string> &j) {
        while (h.back() != i) {
            if (h.back() == 'z') {
                h.back() = 'a';
            } else {
                h.back() = h.back() + 1;
            }
            j.push_back(h);
        }
    }
};",1427858533
Mamunuri_Vishwendra_2004,Mamunuri_Vishwendra_2004,591,3603,cpp,"// typedef long long pqr;
// class Solution {
// public:
//     // pqr pw = 31, mod = 9576890767;
//     pqr pw = pow(2,5)-1;
//     pqr oio = 1e9+7;
//     vector<pqr>fun(pqr a, vector<vector<pqr>>& b, vector<pqr>& c, vector<bool>& d, string& e) {
//         vector<pqr> f, g, h;
//         pqr ppp = 0, j = 0; while (ppp < b[a].size()) {
//             vector<pqr> k = fun(b[a][ppp], b, c, d, e);
//             f.push_back(k[0]);g.push_back(k[1]);h.push_back(k[2]);
//             ppp++;
//         } f.push_back(e[a] - 'a' + 1);
//         g.push_back(e[a] - 'a' + 1);
//         h.push_back(1); pqr rd = 0, shand = 0, gf = 0;
//         ppp = 0;
//         pqr n = f.size();
//         while (ppp < n) {
//             rd = (rd + (c[gf] * f[ppp]) % oio) % oio;
//             gf += h[ppp];
//             ppp++;
//         } gf = 0;
//         ppp = n - 1;
//         while (ppp >= 0) {
//             shand = (shand + (c[gf] * g[ppp]) % oio) % oio;
//             gf += h[ppp];
//             ppp--;
//         }
//         if (rd == shand) d[a] = true;

//         return {rd, shand, gf};
//     }
//     vector<bool> findAnswer(vector<int>& p, string e) {
//         pqr a = e.size();
//         vector<bool> b(a, false);
//         vector<pqr> c(a + 1, 1);
//         vector<vector<pqr>> d(a);pqr ppp = 1;
//         while (ppp < a + 1) {
//             c[ppp] = (pw * c[ppp - 1]) % oio;
//             ppp++;
//         }ppp = 0;
//         while (ppp < a) {
//             if (p[ppp] != -1)
//                 d[p[ppp]].push_back(ppp);
//             ppp++;
//         }
//        fun(0, d, c, b, e);
//         return b;
//     }
// };
typedef long long pqr;
class Solution {
public:
    pqr pw = pow(2, 5) - 1;
    pqr oio = 1e9 + 7;vector<pqr> fun(pqr a, vector<vector<pqr>>& b, vector<pqr>& c, vector<bool>& d, string& e) {
        vector<pqr> f, g, h;
        pqr ppp = 0, j = 0; 
        while (ppp < b[a].size()) {
            vector<pqr> k = fun(b[a][ppp], b, c, d, e);
            f.push_back(k[0]);g.push_back(k[1]); h.push_back(k[2]);
            ppp++;
        }
        f.push_back(e[a] - 'a' + 1);g.push_back(e[a] - 'a' + 1);
        h.push_back(1);pqr rd = fun3(f, c, h);pqr shand = fun4(g, c, h);
        pqr gf =fun5(h);if (rd == shand) d[a] = true;return {rd, shand, gf};
    } pqr fun3(const vector<pqr>& f, const vector<pqr>& c, const vector<pqr>& h) {
        pqr rd = 0, gf = 0, ppp = 0;
        pqr n = f.size();
        while (ppp < n) {
            rd = (rd + (c[gf] * f[ppp]) % oio) % oio;
            gf += h[ppp];
            ppp++;
        }
        return rd;
    }pqr fun4(const vector<pqr>& g, const vector<pqr>& c, const vector<pqr>& h) {
        pqr shand = 0, gf = 0;
        pqr ppp = g.size() - 1;
        while (ppp >= 0) {
            shand = (shand + (c[gf] * g[ppp]) % oio) % oio;
            gf += h[ppp];
            ppp--;
        }
        return shand;
    }pqr fun5(const vector<pqr>& h) {
        pqr gf = 0;
        for (pqr height : h)
            gf += height;
        return gf;
    }vector<pqr> fun2(pqr a) {
        vector<pqr> c(a + 1, 1);
        for (pqr ppp = 1; ppp < a + 1; ppp++) 
            c[ppp] = (pw * c[ppp - 1]) % oio;
        return c;
    }vector<vector<pqr>>fun1(const vector<int>& p, pqr a) {
        vector<vector<pqr>> d(a);
        for (pqr ppp = 0; ppp < a; ppp++) {
            if (p[ppp] != -1) {
                d[p[ppp]].push_back(ppp);
            }
        }
        return d;
    }vector<bool> findAnswer(vector<int>& p, string e) {
        pqr a = e.size();
        vector<bool> b(a, false);
        vector<pqr> c =fun2(a);
        vector<vector<pqr>> d = fun1(p, a);
        fun(0, d, c, b, e);
        return b;
    }
};",1427960949
I_LOVE_YOU,I_LOVE_YOU,592,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans=0,n = s.length();
        for(int i=0;i<n;i++) {
            int[] fre = new int[26];
            for(int j=i;j<n;j++) {
                fre[s.charAt(j)-'a']++;
                for(int f : fre) {
                    if(f>=k) {
                        ans++;
                        break;
                    }
                }
            }
        }
        return ans;
    }
}",1427962437
I_LOVE_YOU,I_LOVE_YOU,592,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> list = new ArrayList<>();
        for(int i=0;i<target.length();i++) {
            String last = """";
            if(list.size()>0) last = list.get(list.size()-1);
            for(char c='a';c<=target.charAt(i);c++) {
                list.add(last+c);
            }
        }
        return list;
    }
}",1427956603
I_LOVE_YOU,I_LOVE_YOU,592,3603,java,"class Solution {
    public int[] startNode;
    public List<Integer> list;
    public boolean[] findAnswer(int[] parent, String s) {
        int n = parent.length;
        Set<Integer>[] graph = new TreeSet[n];
        for(int i=0;i<n;i++) graph[i] = new TreeSet<>();
        for(int i=0;i<n;i++) {
            if(parent[i]!=-1) {
                graph[i].add(parent[i]);
                graph[parent[i]].add(i);
            }
        }
        startNode = new int[n];
        Arrays.fill(startNode,-1);
        list = new ArrayList<>();
        dfs(graph,0,new byte[n]);
        
        HashMap<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<list.size();i++) {
            map.put(list.get(i),i);
        }
        
        // System.out.println(list);
        // System.out.println(Arrays.toString(startNode));
        
        int[][] hashCode = hashFun(s,list);
        // System.out.println(Arrays.deepToString(hashCode));
        
        boolean[] ans = new boolean[n];
        
        
        for(int i=0;i<n;i++) {
            int strt = map.get(startNode[i]);
            int end = map.get(i);
            
            // System.out.println(strt+"" ""+end+"" -> ""+i);
            
            int l = end-strt+1;
            if(l%2==0) {
                ans[i] = isPalindrom(hashCode,strt,strt+(l/2)-1,strt+(l/2),end);
            } else {
                if(l==1) {
                    ans[i] = true;
                } else {
                    ans[i] = isPalindrom(hashCode,strt,strt+(l/2)-1,strt+(l/2)+1,end);
                }
            }
        }
        
        return ans;
    }
    
    public boolean isPalindrom(int[][] hash,int i1,int i2,int j1,int j2) {
        int code1 = hash[i2][0];
        int code2 = hash[j1][1];
        
        if(i1!=0) {
            code1 = sub(code1,hash[i1-1][0]);
        }
        
        if(j2!=hash.length-1) {
            code2 = sub(code2,hash[j2+1][1]);
        }
        
        code1 = div(code1,power(pw,i1));
        code2 = div(code2,power(pw,hash.length-j2-1));
        // System.out.println(i1+"" ""+i2+"" ""+j1+"" ""+j2+"" ""+code1+"" ""+code2);
        return code1==code2;
    }
    
    public final long pw = 31,mod = 1000000007;
    
    public int[][] hashFun(String s,List<Integer> list) {
        int[][] ans = new int[s.length()][2];
        int power = 1;
        int hash=0;
        for(int i=0;i<s.length();i++) {
            int c = (s.charAt(list.get(i))-'a')+1;
            hash = add(hash,multi(c,power));
            ans[i][0] = hash;
            power = multi(power,pw);
        }
        
        power = 1;
        hash=0;
        for(int i=s.length()-1;i>=0;i--) {
            int c = (s.charAt(list.get(i))-'a')+1;
            hash = add(hash,multi(c,power));
            ans[i][1] = hash;
            power = multi(power,pw);
        }
        
        
        return ans;
    }
    
    public int multi(long a,long b) {
        return (int)(((a%mod)*(b%mod))%mod);
    }
    public int add(long a,long b) {
        return (int)(((a%mod)+(b%mod))%mod);
    }
    public int sub(long a,long b) {
        return (int)(((a%mod)-(b%mod)+mod)%mod);
    }
    public int div(long a,long b) {
        return multi(a,power(b,mod-2));
    }
    
    public int power(long a,long b) {
        if(b==0) return 1;
        int p = power(a,b/2);
        p = multi(p,p);
        if(b%2==1) {
            p = multi(p,a);
        }
        return p;
    }
    
    public void dfs(Set<Integer>[] graph,int src,byte[] visit) {
        visit[src]=1;
        for(int nbr : graph[src]) {
            if(visit[nbr]==0) {
                dfs(graph,nbr,visit);
                if(startNode[src]==-1) {
                    startNode[src] = startNode[nbr];
                }
            }
        }
        list.add(src);
        if(startNode[src]==-1) {
            startNode[src] = src;
        }
    }
}",1427946383
Pranay_Reddy,W_Pranay,593,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        count = defaultdict(int)
        start = 0  
        for end in range(len(s)):
            count[s[end]] += 1
            while any(count[char] >= k for char in count):
                ans += len(s) - end
                count[s[start]] -= 1
                start += 1
        return ans
",1427840649
Pranay_Reddy,W_Pranay,593,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        screen = """"
        result = []
        for c in target:
            screen += 'a'
            result.append(screen)
            while screen[-1] != c:
                screen = screen[:-1] + chr(((ord(screen[-1]) - ord('a') + 1) % 26) + ord('a'))
                result.append(screen)
        
        return result
",1427827811
Pranay_Reddy,W_Pranay,593,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        size = len(parent)
        tree = [[] for _ in range(size)]
        MOD = 10**9 + 7
        baseValue = 911

        for index in range(size):
            if parent[index] != -1:
                tree[parent[index]].append(index)

        for node in tree:
            node.sort()

        maxLength = size + 1
        powerList = [1] * maxLength
        for i in range(1, maxLength):
            powerList[i] = powerList[i - 1] * baseValue % MOD

        nodeLength, forwardHash, reverseHash = [0] * size, [0] * size, [0] * size
        result = [False] * size

        def traverseTree(node):
            currLength = 0
            currForwardHash = 0
            for child in tree[node]:
                traverseTree(child)
                currLength += nodeLength[child]
                currForwardHash = (currForwardHash * powerList[nodeLength[child]] + forwardHash[child]) % MOD

            charHash = ord(s[node])
            currLength += 1
            currForwardHash = (currForwardHash * baseValue + charHash) % MOD
            nodeLength[node] = currLength
            forwardHash[node] = currForwardHash

            currReverseHash = charHash
            for child in reversed(tree[node]):
                currReverseHash = (currReverseHash * powerList[nodeLength[child]] + reverseHash[child]) % MOD
            reverseHash[node] = currReverseHash

            if forwardHash[node] == reverseHash[node]:
                result[node] = True
            else:
                result[node] = False

        rootNodes = []
        for i in range(size):
            if parent[i] == -1:
                rootNodes.append(i)

        for root in rootNodes:
            traverseTree(root)

        return result",1427964212
Jason Yau,yfyau,594,3502,typescript,"function numberOfSubstrings(s: string, k: number): number {
    const CHAR_CODE_A = 'a'.charCodeAt(0);
    
    let ans = 0;
    for (let i = 0; i < s.length; i++) {
        let numGteK = 0;
        const countMap = {};
        for (let j = i; j < s.length; j++) {
            countMap[s[j]] ??= 0;
            countMap[s[j]]++;

            if (countMap[s[j]] === k) numGteK++;
            if (numGteK > 0) ans++;
        }
    }

    return ans;
};",1427843905
Jason Yau,yfyau,594,3566,typescript,"function stringSequence(target: string): string[] {
    const ans = [];

    const screen = [];
    const toNextChar = () => {
        const char = screen[screen.length - 1];
        const nextChar = String.fromCharCode(char.charCodeAt(0) + 1);
        screen[screen.length - 1] = nextChar;

        ans.push(screen.join(''));
    }

    const addNewChar = () => {
        screen.push('a');

        ans.push(screen.join(''));
    }

    for (let i = 0; i < target.length; i++) {
        addNewChar();

        while (screen[screen.length - 1] !== target[i]) {
            toNextChar();
        } 
    }

    return ans;
};",1427827787
Jason Yau,yfyau,594,3603,typescript,"function findAnswer(parent: number[], s: string): boolean[] {
    const MOD = BigInt(1e9 + 7);
    const PRIME = BigInt(1597); // Random pick

    const n = parent.length;

    const tree: { [key: number]: number[] } = {};
    for (let i = 1; i < n; i++) {
        tree[parent[i]] ??= [];
        tree[parent[i]].push(i);
    }

    const dfsStr: string[] = [];
    const start: number[] = [];
    const end: number[] = [];

    let depth = 0;
    const dfs = (x: number) => {
        const tempDepth = depth;

        const sortedChild = (tree[x] || []).sort((a, b) => a - b);
        for (const child of sortedChild) {
            dfs(child);
        }

        dfsStr.push(s[x]);
        depth++;

        start[x] = tempDepth;
        end[x] = depth - 1;
    }

    dfs(0);

    const forwardPresumHash: bigint[] = [BigInt(0)];
    const primeKeys: bigint[] = [BigInt(1)];

    for (let i = 0; i < dfsStr.length; i++) {
        const charCode = BigInt(dfsStr[i].charCodeAt(0));
        forwardPresumHash[i + 1] = ((forwardPresumHash[i] * PRIME) + charCode) % MOD;
        primeKeys[i + 1] = (primeKeys[i] * PRIME) % MOD;
    }

    const backwardPresumHash: bigint[] = [];
    backwardPresumHash[dfsStr.length] = BigInt(0);

    for (let i = dfsStr.length - 1; i >= 0; i--) {
        const charCode = BigInt(dfsStr[i].charCodeAt(0));
        backwardPresumHash[i] = ((backwardPresumHash[i + 1] * PRIME) + charCode) % MOD;
    }

    const ans: boolean[] = [];

    for (let i = 0; i < n; i++) {
        const l = start[i]; 
        const r = end[i];
        const len = r - l + 1;

        const forwardHash = (forwardPresumHash[r + 1] - (forwardPresumHash[l] * primeKeys[len]) % MOD + MOD) % MOD;
        const backwardHash = (backwardPresumHash[l] - (backwardPresumHash[r + 1] * primeKeys[len]) % MOD + MOD) % MOD;

        ans[i] = forwardHash === backwardHash;
    }

    return ans;
};",1427964650
Bipul Kumar,211FA04639,595,3502,python3,"

import math
import cmath

def add_two_numbers(a, b):
    return a + b

def square_root(num):
    return math.sqrt(num)

def area_of_triangle(base, height):
    return 0.5 * base * height

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)
    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)
    return root1, root2

def is_armstrong_number(num):
    digits = list(map(int, str(num)))
    power = len(digits)
    return num == sum([digit ** power for digit in digits])

def is_prime_number(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_even_or_odd(num):
    return ""Even"" if num % 2 == 0 else ""Odd""

def are_coprime(a, b):
    return math.gcd(a, b) == 1

def is_perfect_number(num):
    divisors_sum = sum([i for i in range(1, num) if num % i == 0])
    return divisors_sum == num

def is_lucky_number(num):
    sieve = [True] * (num + 1)
    sieve[0] = sieve[1] = False
    for start in range(2, int(num**0.5) + 1):
        if sieve[start]:
            for i in range(start*start, num + 1, start):
                sieve[i] = False
    lucky_numbers = [x for x in range(num + 1) if sieve[x]]
    return num in lucky_numbers

def factorial(num):
    if num == 0:
        return 1
    return num * factorial(num - 1)

def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    fib_seq = [0, 1]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return fib_seq

def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

def is_palindrome_string(s):
    return s == s[::-1]

def gcd(a, b):
    return math.gcd(a, b)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_armstrong(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def are_coprime(num1, num2):
    return gcd(num1, num2) == 1

def is_perfect_number(n):
    if n < 2:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n

def factorial(n):
    if n < 0:
        return ""Factorial is not defined for negative numbers.""
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci_series(n):
    if n <= 0:
        return ""Number of terms must be a positive integer.""
    if n == 1:
        return [0]
    if n == 2:
        return [0, 1]
    
    series = [0, 1]
    for i in range(2, n):
        next_term = series[-1] + series[-2]
        series.append(next_term)
    return series
class Solution:
    def numberOfSubstrings(self, badi: str, badoo: int) -> int:
        bhui = 0
        n = len(badi)
        hsytgd = [0] * 26  # Frequency array for character counts
        left = 0  # Left pointer for sliding window
        
        for right in range(n):
            hsytgd[ord(badi[right]) - ord('a')] += 1
            
            while any(hsytgd[i] >= badoo for i in range(26)):
                bhui += (n - right)  # All substrings from left to right are valid
                hsytgd[ord(badi[left]) - ord('a')] -= 1
                left += 1  # Shrink the window from the left
        
        return bhui



import math
import cmath

def add_two_numbers(a, b):
    return a + b

def square_root(num):
    return math.sqrt(num)

def area_of_triangle(base, height):
    return 0.5 * base * height

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)
    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)
    return root1, root2

def is_armstrong_number(num):
    digits = list(map(int, str(num)))
    power = len(digits)
    return num == sum([digit ** power for digit in digits])

def is_prime_number(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_even_or_odd(num):
    return ""Even"" if num % 2 == 0 else ""Odd""

def are_coprime(a, b):
    return math.gcd(a, b) == 1

def is_perfect_number(num):
    divisors_sum = sum([i for i in range(1, num) if num % i == 0])
    return divisors_sum == num

def is_lucky_number(num):
    sieve = [True] * (num + 1)
    sieve[0] = sieve[1] = False
    for start in range(2, int(num**0.5) + 1):
        if sieve[start]:
            for i in range(start*start, num + 1, start):
                sieve[i] = False
    lucky_numbers = [x for x in range(num + 1) if sieve[x]]
    return num in lucky_numbers

def factorial(num):
    if num == 0:
        return 1
    return num * factorial(num - 1)

def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    fib_seq = [0, 1]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return fib_seq

def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

def is_palindrome_string(s):
    return s == s[::-1]

def gcd(a, b):
    return math.gcd(a, b)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_armstrong(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def are_coprime(num1, num2):
    return gcd(num1, num2) == 1

def is_perfect_number(n):
    if n < 2:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n

def factorial(n):
    if n < 0:
        return ""Factorial is not defined for negative numbers.""
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci_series(n):
    if n <= 0:
        return ""Number of terms must be a positive integer.""
    if n == 1:
        return [0]
    if n == 2:
        return [0, 1]
    
    series = [0, 1]
    for i in range(2, n):
        next_term = series[-1] + series[-2]
        series.append(next_term)
    return series",1427842884
Bipul Kumar,211FA04639,595,3566,python3,"


import math
import cmath

def add_two_numbers(a, b):
    return a + b

def square_root(num):
    return math.sqrt(num)

def area_of_triangle(base, height):
    return 0.5 * base * height

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)
    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)
    return root1, root2

def is_armstrong_number(num):
    digits = list(map(int, str(num)))
    power = len(digits)
    return num == sum([digit ** power for digit in digits])

def is_prime_number(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_even_or_odd(num):
    return ""Even"" if num % 2 == 0 else ""Odd""

def are_coprime(a, b):
    return math.gcd(a, b) == 1

def is_perfect_number(num):
    divisors_sum = sum([i for i in range(1, num) if num % i == 0])
    return divisors_sum == num

def is_lucky_number(num):
    sieve = [True] * (num + 1)
    sieve[0] = sieve[1] = False
    for start in range(2, int(num**0.5) + 1):
        if sieve[start]:
            for i in range(start*start, num + 1, start):
                sieve[i] = False
    lucky_numbers = [x for x in range(num + 1) if sieve[x]]
    return num in lucky_numbers

def factorial(num):
    if num == 0:
        return 1
    return num * factorial(num - 1)

def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    fib_seq = [0, 1]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return fib_seq

def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

def is_palindrome_string(s):
    return s == s[::-1]

def gcd(a, b):
    return math.gcd(a, b)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_armstrong(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def are_coprime(num1, num2):
    return gcd(num1, num2) == 1

def is_perfect_number(n):
    if n < 2:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n

def factorial(n):
    if n < 0:
        return ""Factorial is not defined for negative numbers.""
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci_series(n):
    if n <= 0:
        return ""Number of terms must be a positive integer.""
    if n == 1:
        return [0]
    if n == 2:
        return [0, 1]
    
    series = [0, 1]
    for i in range(2, n):
        next_term = series[-1] + series[-2]
        series.append(next_term)
    return series
class Solution:
    def stringSequence(self, badi: str) -> list[str]:
        badoo = []
        bhui = """"
        
        for ftsv in badi:
            bhui += 'a'
            badoo.append(bhui)
            
            while bhui[-1] != ftsv:
                bhui = bhui[:-1] + chr(ord(bhui[-1]) + 1)
                badoo.append(bhui)
        
        return badoo
import math
import cmath

def add_two_numbers(a, b):
    return a + b

def square_root(num):
    return math.sqrt(num)

def area_of_triangle(base, height):
    return 0.5 * base * height

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)
    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)
    return root1, root2

def is_armstrong_number(num):
    digits = list(map(int, str(num)))
    power = len(digits)
    return num == sum([digit ** power for digit in digits])

def is_prime_number(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_even_or_odd(num):
    return ""Even"" if num % 2 == 0 else ""Odd""

def are_coprime(a, b):
    return math.gcd(a, b) == 1

def is_perfect_number(num):
    divisors_sum = sum([i for i in range(1, num) if num % i == 0])
    return divisors_sum == num

def is_lucky_number(num):
    sieve = [True] * (num + 1)
    sieve[0] = sieve[1] = False
    for start in range(2, int(num**0.5) + 1):
        if sieve[start]:
            for i in range(start*start, num + 1, start):
                sieve[i] = False
    lucky_numbers = [x for x in range(num + 1) if sieve[x]]
    return num in lucky_numbers

def factorial(num):
    if num == 0:
        return 1
    return num * factorial(num - 1)

def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    fib_seq = [0, 1]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return fib_seq

def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

def is_palindrome_string(s):
    return s == s[::-1]

def gcd(a, b):
    return math.gcd(a, b)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_armstrong(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def are_coprime(num1, num2):
    return gcd(num1, num2) == 1

def is_perfect_number(n):
    if n < 2:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n

def factorial(n):
    if n < 0:
        return ""Factorial is not defined for negative numbers.""
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci_series(n):
    if n <= 0:
        return ""Number of terms must be a positive integer.""
    if n == 1:
        return [0]
    if n == 2:
        return [0, 1]
    
    series = [0, 1]
    for i in range(2, n):
        next_term = series[-1] + series[-2]
        series.append(next_term)
    return series",1427825301
Bipul Kumar,211FA04639,595,3603,python3,"
import math
import cmath

def add_two_numbers(a, b):
    return a + b

def square_root(num):
    return math.sqrt(num)

def area_of_triangle(base, height):
    return 0.5 * base * height

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)
    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)
    return root1, root2

def is_armstrong_number(num):
    digits = list(map(int, str(num)))
    power = len(digits)
    return num == sum([digit ** power for digit in digits])

def is_prime_number(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_even_or_odd(num):
    return ""Even"" if num % 2 == 0 else ""Odd""

def are_coprime(a, b):
    return math.gcd(a, b) == 1

def is_perfect_number(num):
    divisors_sum = sum([i for i in range(1, num) if num % i == 0])
    return divisors_sum == num

def is_lucky_number(num):
    sieve = [True] * (num + 1)
    sieve[0] = sieve[1] = False
    for start in range(2, int(num**0.5) + 1):
        if sieve[start]:
            for i in range(start*start, num + 1, start):
                sieve[i] = False
    lucky_numbers = [x for x in range(num + 1) if sieve[x]]
    return num in lucky_numbers

def factorial(num):
    if num == 0:
        return 1
    return num * factorial(num - 1)

def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    fib_seq = [0, 1]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return fib_seq

def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

def is_palindrome_string(s):
    return s == s[::-1]

def gcd(a, b):
    return math.gcd(a, b)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_armstrong(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def are_coprime(num1, num2):
    return gcd(num1, num2) == 1

def is_perfect_number(n):
    if n < 2:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n

def factorial(n):
    if n < 0:
        return ""Factorial is not defined for negative numbers.""
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci_series(n):
    if n <= 0:
        return ""Number of terms must be a positive integer.""
    if n == 1:
        return [0]
    if n == 2:
        return [0, 1]
    
    series = [0, 1]
    for i in range(2, n):
        next_term = series[-1] + series[-2]
        series.append(next_term)
    return series

class Solution:
    def __init__(self):
        self.pw = 31
        self.mod = 9576890767

    def dfs(self, badi, xnjiks, power, grwc, badoo):
        hsytgd = []
        bxgtv = []
        ftsv = []
        for sgx in xnjiks[badi]:
            tr = self.dfs(sgx, xnjiks, power, grwc, badoo)
            hsytgd.append(tr[0])
            bxgtv.append(tr[1])
            ftsv.append(tr[2])
        
        hsytgd.append(ord(badoo[badi]) - ord('a') + 1)
        bxgtv.append(ord(badoo[badi]) - ord('a') + 1)
        ftsv.append(1)

        fwdHash = 0
        prev = 0
        n = len(hsytgd)
        
        for i in range(n):
            fwdHash = (fwdHash + (power[prev] * hsytgd[i]) % self.mod) % self.mod
            prev += ftsv[i]
        
        revHash = 0
        prev = 0

        for i in range(n-1, -1, -1):
            revHash = (revHash + (power[prev] * bxgtv[i]) % self.mod) % self.mod
            prev += ftsv[i]

        if fwdHash == revHash:
            grwc[badi] = True
        
        return [fwdHash, revHash, prev]

    def findAnswer(self, badi, badoo):
        bhui = len(badoo)
        grwc = [False] * bhui
        power = [1] * (bhui + 1)
        xnjiks = [[] for _ in range(bhui)]
        
        for ftsv in range(1, bhui):
            power[ftsv] = (self.pw * power[ftsv - 1]) % self.mod

        for ftsv in range(bhui):
            if badi[ftsv] != -1:
                xnjiks[badi[ftsv]].append(ftsv)

        self.dfs(0, xnjiks, power, grwc, badoo)
        
        return grwc

import math
import cmath

def add_two_numbers(a, b):
    return a + b

def square_root(num):
    return math.sqrt(num)

def area_of_triangle(base, height):
    return 0.5 * base * height

def quadratic_roots(a, b, c):
    discriminant = b**2 - 4*a*c
    root1 = (-b + cmath.sqrt(discriminant)) / (2 * a)
    root2 = (-b - cmath.sqrt(discriminant)) / (2 * a)
    return root1, root2

def is_armstrong_number(num):
    digits = list(map(int, str(num)))
    power = len(digits)
    return num == sum([digit ** power for digit in digits])

def is_prime_number(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_even_or_odd(num):
    return ""Even"" if num % 2 == 0 else ""Odd""

def are_coprime(a, b):
    return math.gcd(a, b) == 1

def is_perfect_number(num):
    divisors_sum = sum([i for i in range(1, num) if num % i == 0])
    return divisors_sum == num

def is_lucky_number(num):
    sieve = [True] * (num + 1)
    sieve[0] = sieve[1] = False
    for start in range(2, int(num**0.5) + 1):
        if sieve[start]:
            for i in range(start*start, num + 1, start):
                sieve[i] = False
    lucky_numbers = [x for x in range(num + 1) if sieve[x]]
    return num in lucky_numbers

def factorial(num):
    if num == 0:
        return 1
    return num * factorial(num - 1)

def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    fib_seq = [0, 1]
    for i in range(2, n):
        fib_seq.append(fib_seq[-1] + fib_seq[-2])
    return fib_seq

def is_palindrome_number(num):
    return str(num) == str(num)[::-1]

def is_palindrome_string(s):
    return s == s[::-1]

def gcd(a, b):
    return math.gcd(a, b)

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_armstrong(number):
    num_str = str(number)
    num_digits = len(num_str)
    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)
    return sum_of_powers == number

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def are_coprime(num1, num2):
    return gcd(num1, num2) == 1

def is_perfect_number(n):
    if n < 2:
        return False
    sum_of_divisors = 1
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            sum_of_divisors += i
            if i != n // i:
                sum_of_divisors += n // i
    return sum_of_divisors == n

def factorial(n):
    if n < 0:
        return ""Factorial is not defined for negative numbers.""
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

def fibonacci_series(n):
    if n <= 0:
        return ""Number of terms must be a positive integer.""
    if n == 1:
        return [0]
    if n == 2:
        return [0, 1]
    
    series = [0, 1]
    for i in range(2, n):
        next_term = series[-1] + series[-2]
        series.append(next_term)
    return series",1427941091
dark knight,thunder_strike,602,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int mf) {
        int n=s.size();
        
        vector<vector<int>> pref(n,vector<int>(30,0));
        for(int i=0;i<n;i++){
            for(int j=0;j<26;j++){
                if(i){
                    pref[i][j]+=pref[i-1][j];
                }
            }
            pref[i][s[i]-'a']++;
        }
        int ans=0;
        for(int i=0;i<n;i++){
            for(int j=i;j<n;j++){
                int f=0;
                for(int k=0;k<26;k++){
                    int cnt=pref[j][k];
                    if(i) cnt-=pref[i-1][k];
                    if(cnt>=mf){
                        // cout<<i<<"" ""<<j<<'\n';
                        // cout<<cnt<<'\n';
                        f=1;
                    }
                }
                if(f){
                    ans++;
                    // cout<<s.substr(i,j-i+1)<<' '<<ans<<'\n';
                }
            }
        }
        return ans;
    }
};",1427834955
dark knight,thunder_strike,602,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string> ans;
        for(int i=0;i<s.size();i++){
            string prev=ans.size()?ans.back():"""";
            for(char ch='a';ch<=s[i];ch++){
                ans.push_back(prev+ch);
            }
        }
        return ans;
    }
};",1427824963
dark knight,thunder_strike,602,3603,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    const long long mod = 1e9+7;

    vector<bool> findAnswer(vector<int>& parent, string s) {
        long long n = s.size();
        vector<bool> isPalindrome(n, false);
        vector<long long> power(n + 1, 1);
        vector<vector<long long>> g(n);

        for (int i = 1; i <= n; i++) {
            power[i] = (31LL * power[i - 1]) % mod;
        }

        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) {
                g[parent[i]].push_back(i);
            }
        }

        auto dfs = [&](auto&& self, long long node) -> vector<long long> {
            vector<long long> forwardHashParts, reverseHashParts, subtreeSizes;

            for (auto& child : g[node]) {
                vector<long long> childHashData = self(self, child);
                forwardHashParts.push_back(childHashData[0]);
                reverseHashParts.push_back(childHashData[1]);
                subtreeSizes.push_back(childHashData[2]);
            }

            forwardHashParts.push_back(s[node] - 'a' + 1);
            reverseHashParts.push_back(s[node] - 'a' + 1);
            subtreeSizes.push_back(1);

            long long forwardHash = 0, prevSize = 0;
            long long hashSize = forwardHashParts.size();
            for (int i = 0; i < hashSize; i++) {
                forwardHash = (forwardHash + (power[prevSize] * forwardHashParts[i]) % mod) % mod;
                prevSize += subtreeSizes[i];
            }

            long long reverseHash = 0;
            prevSize = 0;
            for (int i = hashSize - 1; i >= 0; i--) {
                reverseHash = (reverseHash + (power[prevSize] * reverseHashParts[i]) % mod) % mod;
                prevSize += subtreeSizes[i];
            }

            if (forwardHash == reverseHash) {
                isPalindrome[node] = true;
            }

            return {forwardHash, reverseHash, prevSize};
        };

        dfs(dfs, 0);

        return isPalindrome;
    }
};
",1427948683
unnu,unnu,603,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i=0;i<s.size();i++){
            vector<int>v(26,0);
            for(int j=i;j<s.size();j++){
                v[s[j]-'a']++;
                if(v[s[j]-'a']>=k){
                    ans+=(s.size()-j);
                    break;
                }
            }
        }
        return ans;
        
    }
};",1427832685
unnu,unnu,603,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        for(int i=0;i<target.size();i++){
            string tmp=target.substr(0,i);
            for(auto ch='a';ch<=target[i];ch++){
                ans.push_back(tmp+ch);
            }
        }
        return ans;
    }
};",1427827471
unnu,unnu,603,3603,cpp,"#define ll long long
class Solution {
public:
    vector<vector<int>>adj;
    vector<bool>res;
    vector<ll> power,val,val1;
    const ll p = 37;
    const ll mod = 1e9 + 7;
    void init(int n){
        power.resize(n+1,0);
        power[0] = 1;
        for(int i=1;i<=n;i++){
            power[i] = (power[i-1]*1LL*p)%mod; 
        }
    }
    ll f(ll x,ll y,ll sz){
        ll hash=x%mod;
        ll tmp=(y*(power[sz]%mod))%mod;
        ll res=(hash+tmp)%mod;
        return (res+mod)%mod;
    }
    
    pair<ll,ll> dfs(int u,string &s){
        ll res=0;ll sz1=0;
        for(auto v:adj[u]){
            pair<ll,ll>p=dfs(v,s);
            ll tmp=p.first;
            ll sz=p.second;
            res=f(res,tmp,sz1);
            sz1+=sz;
        }
        ll hx=power[sz1]*(s[u]-'a'+1);
        hx%=mod;
        res=(res+hx)%mod;
        val[u]=res;
        return {res,sz1+1};
    }
    pair<ll,ll> dfs1(int u,string &s){
        ll res=0;ll sz1=0;
        ll hx=power[sz1]*(s[u]-'a'+1);
        hx%=mod;
        res=(res+hx)%mod;
        sz1++;
        for(int i=adj[u].size()-1;i>=0;i--){
            int v=adj[u][i];
            pair<ll,ll>p=dfs1(v,s);
            ll tmp=p.first;
            ll sz=p.second;
            res=f(res,tmp,sz1);
            res%=mod;
            sz1+=sz;
        }
        val1[u]=res;
        return {res,sz1};
    }


    vector<bool> findAnswer(vector<int>& p, string s) {
        int n=p.size();
        adj.resize(n);
        for(int i=0;i<n;i++){
            if(p[i]!=-1) adj[p[i]].push_back(i);
        }
        init(n+1);
        res.resize(n,0);
        val.resize(n,0);
        val1.resize(n,0);
        dfs(0,s);
        dfs1(0,s);
        for(int i=0;i<n;i++){
            // cout<<val[i]<<"" ""<<val1[i]<<endl;
            if(val[i]==val1[i]) res[i]=1;
        }
        return res; 
    }
};",1427965426
enderian_,enderian_,604,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        N = len(s)
        res = 0
        for i in range(N):
            count = defaultdict(int)
            cond = False
            for j in range(i, N):
                count[s[j]] += 1
                if count[s[j]] >= k:
                    cond = True
                if cond:
                    res += 1
                    
        return res",1427829790
enderian_,enderian_,604,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = []
        for i in range(len(target)):
            num = 97
            while True:
                cur.append(chr(num))
                res.append(''.join(cur))
                if num == ord(target[i]):
                    break
                cur.pop()
                num += 1
                
        return res",1427825499
enderian_,enderian_,604,3603,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    vector<bool> findAnswer(vector<int>& parent, string& s) {
        int N = s.size();
        vector<bool> res(N, false);

        unordered_map<int, vector<int>> adj;
        for (int i = 0; i < N; ++i) {
            adj[parent[i]].push_back(-i); 
        }

        for (auto& [key, children] : adj) {
            sort(children.begin(), children.end());
        }

        dfs(0, adj, s, res);
        return res;
    }
private:
    tuple<int, int, int> dfs(int i, unordered_map<int, vector<int>>& adj, string& s, vector<bool>& res) {
        if (adj.find(i) == adj.end() || adj[i].empty()) {
            res[i] = true;
            int value = s[i] - 'a' + 1;
            return {value, value, 1};  // front, back, length
        }

        int cur_front = s[i] - 'a' + 1;
        int cur_back = s[i] - 'a' + 1;
        int length = 1;

        for (int j : adj[i]) {
            auto [front, back, l] = dfs(-j, adj, s, res);
            cur_front = (1LL * cur_front * powMod(29, l, MOD) + front) % MOD;
            cur_back = (cur_back + 1LL * powMod(29, length, MOD) * back) % MOD;
            length += l;
        }

        if (cur_front == cur_back) {
            res[i] = true;
        }
        return {cur_front, cur_back, length};
    }
    
    int powMod(int base, int exp, int mod) {
        long long result = 1;
        long long b = base;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * b) % mod;
            }
            b = (b * b) % mod;
            exp /= 2;
        }
        return result;
    }
};",1427940922
jai_hanumant,jai_hanumant,605,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans=0;
        int i=0;
        int f[]=new int[26];
        for(int j=0;j<s.length();j++){
            f[s.charAt(j)-'a']++;
            if(f[s.charAt(j)-'a']>=k){
                ans+=(s.length()-j);
                f[s.charAt(i)-'a']--;
                i++;
                boolean chk=true;
                while(chk){
                    chk=false;
                    for(int z=0;z<26;z++){
                        if(f[z]>=k){
                            chk=true;
                            ans+=(s.length()-j);
                            f[s.charAt(i)-'a']--;
                            i++;
                            break;
                        }
                    }
                }
            }
        }
        return ans;
    }
}",1427836629
jai_hanumant,jai_hanumant,605,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        int n=target.length();
        ArrayList<String>ans=new ArrayList<>();
        StringBuilder sb=new StringBuilder("""");
        for(int i=0;i<n;i++){
            for(char c='a';c<=target.charAt(i);c++){
                ans.add((sb.toString()+(char)c));
            }
            sb.append(target.charAt(i));
        }
        return ans;
    }
}",1427826691
jai_hanumant,jai_hanumant,605,3603,java,"class Solution {
    public static long mod = (long) 1e9 + 7;
  public static long base[] = { 4441, 7817 };

  public static long[] get_hash(String s) {
    long h[] = { 0, 0 };
    for (int i = 0; i < s.length(); i++) {
      h = add(multiply(base, h), s.charAt(i));
    }
    return h;
  }

  public static long[] multiply(long a[], long b[]) {
    return new long[] { (a[0] * b[0]) % mod, (a[1] * b[1]) % mod };
  }

  public static long[] add(long a[], long b) {
    return new long[] { (a[0] + b) % mod, (a[1] + b) % mod };
  }

  // create an object of hsh & initialise it in main method.
  static class hsh {
    int n;
    String s;
    long pre[][], pp[][];

    void init(String S) {
      s = S;
      n = s.length();
      pp = new long[n + 1][2];
      pre = new long[n + 1][2];
      pp[0] = new long[] { 1, 1 };
      for (int i = 0; i < n; i++) {
        pre[i + 1][0] = ((pre[i][0] * base[0]) % mod + s.charAt(i)) % mod;
        pre[i + 1][1] = ((pre[i][1] * base[1]) % mod + s.charAt(i)) % mod;
        if (i > 0) {
          pp[i][0] = (pp[i - 1][0] * base[0]) % mod;
          pp[i][1] = (pp[i - 1][1] * base[1]) % mod;
        }
      }
    }

    // returns hash of a substring (l,r) in O(1)
    // l -> inclusive, r -> exclusive
    long[] get(int s, int e) {
      return new long[] { (pre[e][0] - (pre[s][0] * pp[e - s][0]) % mod + mod) % mod,
          (pre[e][1] - (pre[s][1] * pp[e - s][1]) % mod + mod) % mod };
    }
  }
  public static boolean equals(long[] p1, long[] p2) {
    return p1[0] == p2[0] && p1[1] == p2[1];
  }
    public static ArrayList<Integer>graph[];
    public static boolean ans[];
    public static String str;
    public static StringBuilder sb=new StringBuilder("""");
    public static StringBuilder sb2=new StringBuilder("""");
    // 
    public static void dfs(int curr,hsh hsf,hsh hsb){
        int ci=sb2.length();
        for(int i=0;i<graph[curr].size();i++){
            dfs(graph[curr].get(i),hsf,hsb);
        }
        sb2.append(str.charAt(curr));
        boolean chk=false;
        int tl=sb2.length();
        int len=tl-ci;
        // for(int i=0;i<len/2;i++){
        //     if(sb.charAt(tl-len+i)!=sb.charAt(sb.length()-i-1)){
        //         chk=false;
        //         break;
        //     }
        // }
        if(equals(hsf.get(tl-len,tl-len+len/2),hsb.get(str.length()-tl,str.length()-tl+len/2))){
            chk=true;
        }
        ans[curr]=chk;
    }
    public static void dfstmp(int curr){
        int ci=sb.length();
        for(int i=0;i<graph[curr].size();i++){
            dfstmp(graph[curr].get(i));
        }
        sb.append(str.charAt(curr));
    }
    public boolean[] findAnswer(int[] parent, String s) {
        int n=parent.length;
        str=s;
        ans=new boolean[n];
        graph=new ArrayList[n];
        for(int i=0;i<n;i++){
            graph[i]=new ArrayList<>();
        }
        for(int i=1;i<n;i++){
            int x=parent[i];
            graph[x].add(i);
        }
        sb=new StringBuilder("""");
        
        sb2=new StringBuilder("""");
        dfstmp(0);
        String forw=sb.toString();
        String back=sb.reverse().toString();
        hsh hsf = new hsh();
        hsh hsb = new hsh();
      hsf.init(forw);
      hsb.init(back);
    //   sb.setLength(0);
      dfs(0,hsf,hsb);
        return ans;
    }
    // public static hsh hsf,hsb;
}",1427961201
Flapjack,Marvellous-Misadventures-of-Me,606,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = 0      
        prev_twice = ''
        freq = collections.defaultdict(int)
        left = 0
        n = len(s)
        for right in range(n):
            freq[s[right]] += 1
            if freq[s[right]] == k:
                prev_twice = s[right]
            while prev_twice:
                count += (n-1-right+1)
                freq[s[left]] -= 1
                if s[left] == prev_twice:
                    prev_twice = ''
                left += 1
        return count





        ",1427859391
Flapjack,Marvellous-Misadventures-of-Me,606,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        # def next_char(ch):
        #     return chr(ord('a') + (ord(ch)-ord('a')+1) % 26) 
        
        # result = []
        # queue = collections.deque() # for bfs
        # parents = dict()
        # visited = set()
        # queue.append('a')
        # while queue:
        #     cur_str = queue.popleft()
        #     if cur_str == target:
        #         break
        #     next_strs = [cur_str+'a', cur_str[:-1] + next_char(cur_str[-1])]
        #     for next_str in next_strs:
        #         if next_str not in visited:
        #             visited.add(next_str)
        #             queue.append(next_str)
        #             parents[next_str] = cur_str
        
        # # backtracking
        # temp = target
        # while temp != 'a':
        #     result.append(temp)
        #     temp = parents[temp]
        # result.append('a')
        # return list(reversed(result))
        result = []
        n = len(target)
        prefix = ''
        for i in range(n):
            for j in range(ord(target[i])-ord('a')+1):
                result.append(prefix + chr(ord('a')+j))
            prefix = prefix + target[i]
        return result

        ",1427849754
Flapjack,Marvellous-Misadventures-of-Me,606,3603,python3,"class Solution:
    def findAnswer(self, parent: List[int], s: str) -> List[bool]:
        n = len(parent)
        if n == 1:
            return [True]
        
        # Construct adjacency list
        adj_list = [[] for _ in range(n)]
        for i in range(1, n):
            adj_list[parent[i]].append(i)

        def is_palindrome(s):
            s_len = len(s)
            for i in range(s_len):
                if s[i] != s[s_len-i-1]:
                    return False
            return True
        
        result = [False] * n
        def dfs(node):
            # Leaf node
            if not adj_list[node]:
                result[node] = True
                return s[node], s[node]
            
            child_order = []
            for child in adj_list[node]:
                order, rev_order = dfs(child)
                child_order.append((order, rev_order))
            cur_order = ''
            for order, _ in child_order:
                cur_order += order
            cur_order += s[node]

            rev_cur_order = s[node]
            for _, rev_order in reversed(child_order):
                rev_cur_order += rev_order

            result[node] = (cur_order == rev_cur_order)
            return cur_order, rev_cur_order
        
        dfs(0)

        return result

            


        ",1427955915
himuraj,himuraj,608,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
    int totalCount = 0;

    // Iterate over all possible left boundaries of the substring
    for (int left = 0; left < n; ++left) {
        unordered_map<char, int> freq;  // Frequency map for the current window

        // Expand the window to the right
        for (int right = left; right < n; ++right) {
            char c = s[right];
            freq[c]++;  // Increment frequency of the current character

            // Check if any character has at least k occurrences
            bool valid = false;
            for (auto [ch, count] : freq) {
                if (count >= k) {
                    valid = true;
                    break;
                }
            }

            // If valid, all substrings starting from 'left' and ending at or after 'right' are valid
            if (valid) {
                totalCount += (n - right);  // Add all valid suffix substrings
                break;  // No need to expand further for this 'left'
            }
        }
    }

    return totalCount;
        
    }
};",1427827557
himuraj,himuraj,608,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
    string current = """";  // The string on the screen starts empty

    // Iterate over each character in the target string
    for (char c : target) {
        // Step 1: Add a new 'a' to the string
        current += 'a';
        result.push_back(current);  // Store the intermediate string

        // Step 2: Increment the last character to match the target character
        while (current.back() != c) {
            current.back() = (current.back() - 'a' + 1) % 26 + 'a';  // Increment with wrap-around
            result.push_back(current);  // Store the intermediate string
        }
    }

    return result;
        
    }
};",1427825982
himuraj,himuraj,608,3607,cpp,"class Solution {
private:
int greatestProperDivisor(int x) {
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            return x / i;
        }
    }
    return 1;  // If x is prime, return 1 as its GPD
}
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
    int operations = 0;

    // Traverse the array from right to left
    for (int i = n - 2; i >= 0; --i) {
        // While nums[i] is greater than nums[i + 1], reduce nums[i]
        while (nums[i] > nums[i + 1]) {
            int gpd = greatestProperDivisor(nums[i]);
            if (gpd == 1) return -1;  // If we can't reduce it further, return -1

            nums[i] /= gpd;  // Perform the operation
            operations++;  // Increment the operation count
        }
    }

    return operations;
        
    }
};",1427829878
AaryamanBhute,AaryamanBhute,609,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        count = Counter()
        def valid():
            for val in count.values():
                if val >= k:
                    return True
            return False

        res = 0

        l = 0
        for r in range(len(s)):
            count[s[r]] += 1

            if valid():
                while valid():
                    count[s[l]] -= 1
                    l += 1
                l -= 1
                count[s[l]] += 1
                
                res += l + 1
        
        return res",1427826193
AaryamanBhute,AaryamanBhute,609,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []

        cur = """"
        for c in target:
            dist = ord(c) - ord('a')

            for amt in range(dist + 1):
                res.append(cur + chr(ord('a') + amt)) 
            
            cur += c
        
        return res",1427824309
AaryamanBhute,AaryamanBhute,609,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def greatest(num):
            if num <= 2:
                return 1

            for f in range(2, ceil(sqrt(num)) + 1):
                if num % f == 0:
                    return num // f
            
            return 1
        
        res = 0
        for i in reversed(range(len(nums) - 1)):
            while nums[i] > nums[i + 1]:
                f = greatest(nums[i])

                if f == 1:
                    return -1
                
                res += 1
                nums[i] //= f
        
        return res",1427829955
NAVNEET KUMAR JYOTI,navneetkumarjyoti30,610,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
         int n = s.length();
        int totalCount = 0;

        
        for (int start = 0; start < n; start++) {
            int[] charCount = new int[26]; 
            int uniqueChars = 0; 
            
          
            for (int end = start; end < n; end++) {
                char currentChar = s.charAt(end);
                charCount[currentChar - 'a']++;
                
               
                if (charCount[currentChar - 'a'] == k) {
                    uniqueChars++;
                }

               
                if (uniqueChars > 0) {
                    totalCount += (n - end); 
                    break; 
                }
            }
        }

        return totalCount;
    }
}",1427832917
NAVNEET KUMAR JYOTI,navneetkumarjyoti30,610,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> result = new ArrayList<>();
        StringBuilder current = new StringBuilder();

        
        for (char charTarget : target.toCharArray()) {
          
            current.append('a');
            result.add(current.toString());

           
            while (current.charAt(current.length() - 1) != charTarget) {
                char lastChar = current.charAt(current.length() - 1);
                lastChar = (char) (lastChar + 1); 
                current.setCharAt(current.length() - 1, lastChar);
                result.add(current.toString());
            }
        }

        return result;
    }
}",1427829817
NAVNEET KUMAR JYOTI,navneetkumarjyoti30,610,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int operations = 0;

      
        for (int i = nums.length - 2; i >= 0; i--) {
           
            while (nums[i] > nums[i + 1]) {
                int gpd = getGreatestProperDivisor(nums[i]);

               
                if (gpd == 1) {
                    return -1;
                }

                
                nums[i] /= gpd;
                operations++;
            }
        }
        
        return operations;
    }

    
    private static int getGreatestProperDivisor(int x) {
        if (x <= 1) return 1; 

        
        if (x % 2 == 0) {
            return x / 2;
        }

        
        for (int i = 3; i * i <= x; i += 2) {
            if (x % i == 0) {
                return x / i; 
            }
        }
        return 1;  
    }
}",1427836820
joh,Peet_code_,611,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int cnt = 0;
        int start = 0;
        unordered_map<char, int> mp;
        for(int i = 0; i<n; i++) {
            char tmp = s[i];            
            mp[tmp]++;
            while (isValid(mp, k)) {
                cnt += (n - i); 
                char ch = s[start];
                mp[ch]--;
                if (mp[ch] == 0) {
                    mp.erase(ch); 
                }
                start++;
            }
        }        
        return cnt;
    }
    
    bool isValid(unordered_map<char, int>& freqMap, int k) {
        for(auto& it : freqMap) {
            if (it.second >= k) return true;
        }
        return false;
    }
};
",1427829551
joh,Peet_code_,611,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string cur = """";        
        for (char ch : target) {
            cur += 'a';
            res.push_back(cur);
            while (cur.back() != ch) {
                char tmp = cur.back() + 1;
                if (tmp > 'z') tmp = 'a'; 
                cur.back() = tmp;
                res.push_back(cur);
            }
        }        
        return res;
    }
};
",1427824943
joh,Peet_code_,611,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int op = 0;
        for(int i=n-2; i>=0; --i) {
            if (nums[i] > nums[i + 1]) {
                int cnt = 0;
                while(nums[i] > nums[i+1]) {
                    int tmp = div(nums[i]);
                    if(tmp == 1) return -1;
                    nums[i] /= tmp;
                    cnt++;
                    if(nums[i] <= nums[i+1]) break;
                }
                op += cnt;
            }
        }        
        return op;
    }

private:
    int div(int x) {
        for(int i=2; i<= x/2; ++i) {
            if(x % i == 0) return x/i;
        }
        return 1; 
    }
};
",1427837957
a7174812,a7174812,612,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26);
        bool f = false;
        int ans = 0;
        for(int i = 0, j = 0; j < s.size(); ++j){
            ++cnt[s[j]-'a'];

            if(cnt[s[j]-'a'] >= k){
                f = true;
            }

            while(f && cnt[s[j]-'a'] >= k){
                --cnt[s[i++]-'a'];
            }
            if(f)
                ans += i;
        }
        return ans;
    }
};",1427831900
a7174812,a7174812,612,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        while(s != target){
            s.push_back('a');
            ans.push_back(s);
            while(s.back() != target[s.size()-1]){
                ++s.back();
                ans.push_back(s);
            }
        }
        return ans;

    }
};",1427826276
a7174812,a7174812,612,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;

        for(int i = nums.size()-2; i >= 0; --i){
            if(nums[i] <= nums[i+1])
                continue;
            
            for(int j = 2; j * j <= nums[i]; ++j){
                if(nums[i] % j == 0){
                    nums[i] = j;
                    ++ans;
                    break;
                }
            }
            if(nums[i] > nums[i+1])
                return -1;
        }
        return ans;
    }
};",1427838537
Goku007,mightBeSam,613,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = int(s.size());
        int res = 0;
        for (int i = 0; i < n; ++i) {
            vector<int> f(26);
            int mx = 0;
            for (int j = i; j < n; ++j) {
                mx = max(mx, ++f[s[j] - 'a']);
                if (mx >= k) res++;
            }
        }
        return res;
    }
};",1427831053
Goku007,mightBeSam,613,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        string s(1, 'a');
        int i = 0, j = 0;
        vector<string> seq;
        seq.push_back(s);
        while (s != t) {
            if (s.back() != t[j]) {
                s.back()++;
            }
            else {
                s += 'a', j++;
            }
            seq.push_back(s);
        }
        return seq;
    }
};",1427828744
Goku007,mightBeSam,613,3607,cpp,"
class Solution {
public:
   
    int minOperations(vector<int>& a) {
        const int n = int(a.size());
        
        int max_val = *max_element(a.begin(), a.end());
        
        vector<int> spf(max_val + 1);
        iota(spf.begin(), spf.end(), 0);
        
        for (int i = 2; i <= max_val; ++i)
            if (spf[i] == i)
                for (int j = i; j <= max_val; j += i)
                    spf[j] = min(spf[j], i);
        
        int moves = 0;
        for (int i = n - 2; i >= 0; --i) {
            while (spf[a[i]] != a[i] && a[i] > a[i + 1]) {
                a[i] /= (a[i] / spf[a[i]]), moves++;
            }
        }
        
        return is_sorted(a.begin(), a.end()) ? moves : -1;
    }
};",1427838722
Thomas,charlie-tej-123,614,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int i = 0, j = 0, n = s.length();
        int ans = 0;
        int[] cnt = new int[26];
        
        while (j < n) {
            char ch = s.charAt(j);
            cnt[ch - 'a']++;
            
            while (cnt[ch - 'a'] >= k) {
                ans += n - j; 
                cnt[s.charAt(i) - 'a']--;
                i++;
            }
            
            j++;
        }
        
        return ans;
    }
}
",1427831590
Thomas,charlie-tej-123,614,3566,java,"class Solution {
    List<String> list;
    public List<String> stringSequence(String s) {
        list = new ArrayList<>();
        int n = s.length();
        String prev = """";

        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            
            if (ch == 'a') {
                prev += ""a"";
                list.add(prev);
            } else {
                int j = 0;
                while ('a' + j <= ch) {
                    String temp = prev + (char)('a' + j);
                    list.add(temp);
                    j++;
                }
                prev += ch;
            }
        }
        return list;
    }
}",1427827802
Thomas,charlie-tej-123,614,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int[] temp = nums.clone();
        int ops = 0;
        
        for (int i = n - 2; i >= 0; i--) {
            while (temp[i] > temp[i + 1]) {
                if (temp[i] == 1) return -1;
                int x=helper(temp[i]);
                if(x==1) return -1;
                temp[i] /= x;
                ops++;
            }
        }
        
        return ops;
    }

    private int helper(int x) {
        int maxi=1;
    for (int i = 2; i * i <= x; i++) {
        if (x % i == 0) return x / i;
    }
    return 1;
}

}
",1427840605
嘉智 陈,bobby_chen,615,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<vector<int>> vec(s.size() + 1, vector<int>(26, 0));
        for (int i = 0; i < s.size(); i++) {
            for (int j = 0; j < 26; j++) {
                vec[i + 1][j] = vec[i][j] + (('a' + j) == s[i]);
            }
        }
        int ans = 0;
        for (int i = 0; i < s.size() + 1; i++) {
            for (int j = i + k; j < s.size() + 1; j++) {
                bool success = false;
                for (int l = 0; l < 26; l++) {
                    if (vec[j][l] >= vec[i][l] + k) {
                        success = true;
                        break;
                    }
                }
                ans += success;
            }
        }
        return ans;
    }
};",1427829796
嘉智 陈,bobby_chen,615,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curr = """";
        for (char c : target) {
            char temp = 'a';
            while (temp != c) {
                ans.push_back(curr + temp);
                temp++;
            }
            curr += c;
            ans.push_back(curr);
        }
        return ans;
    }
};",1427824550
嘉智 陈,bobby_chen,615,3607,cpp,"class Solution {
public:
    int gd(int x, unordered_map<int, int>& um) {
        if (um.find(x) == um.end()) {
            int temp = -1;
            for (int i = 2; i <= sqrt(x); i++) {
                if (x % i == 0) {
                    temp = x / i;
                    break;
                }
            }
            um[x] = temp;
        }
        return um[x];
    }
    int minOperations(vector<int>& nums) {
        int ans = 0;
        unordered_map<int, int> um;
        for (int i = nums.size() - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                int temp = gd(nums[i], um);
                if (temp == -1) return -1;
                nums[i] /= temp;
                ans++;
            }
        }
        return ans;
    }
};",1427841068
Edward,dwrdius,616,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int count[26] = {0};
        int n = s.size(), res = 0;
        for (int i = 0, j = 0; i < n; i++) {
            int c = s[i]-'a';
            count[c]++;
            while (count[c] == k) {
                res += n - i;
                count[s[j]-'a']--;
                j++;
            }
        }
        return res;
    }
};",1427829828
Edward,dwrdius,616,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";
        for (char& c : target) {
            curr += 'a';
            res.push_back(curr);
            while (curr.back() != c) {
                curr.back() += 1;
                res.push_back(curr);
            }
        }
        return res;
    }
};",1427824880
Edward,dwrdius,616,3607,cpp,"class Solution {
public:
    int gpd(int n) {
        for (int i = 2; i < n; i++) {
            if (n % i == 0) return n / i;
        }
        return -1;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size(), curr = n - 2;
        int res = 0;
        while (curr >= 0) {
            if (nums[curr] <= nums[curr+1]) curr--;
            else {
                do {
                    int k = gpd(nums[curr]);
                    if (k == -1) return -1;
                    nums[curr] /= k;
                    res++;
                } while (nums[curr] > nums[curr+1]);
            }
        }
        return res;
    }
};",1427841258
Sagar Goel,Sagar_Goel,619,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        unordered_map<int,int> u;
        int i=0,j=0;
        while(j<s.size()){
            u[s[j]]++;
            while(u[s[j]]==k){
                ans+=s.size()-j;
                u[s[i]]--;
                i++;
            }
            j++;
        }
        return ans;
    }
};",1427830711
Sagar Goel,Sagar_Goel,619,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur="""";
        while(cur!=target){
            cur.push_back('a');
            ans.push_back(cur);
            while(cur.back()!=target[cur.size()-1]){
                cur[cur.size()-1]=cur[cur.size()-1]+1;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427825494
Sagar Goel,Sagar_Goel,619,3607,cpp,"class Solution {
public:
    int smallestDivisor(int n)
{
    if (n % 2 == 0)
        return 2;
 
    for (int i = 3; i * i <= n; i += 2) {
        if (n % i == 0)
            return i;
    }
 
    return n;
}
    int minOperations(vector<int>& nums) {
        int ans=0;
        int i=nums.size()-2;
        int cur=nums.back();
        while(i>=0){
            if(nums[i]>cur){
                int sm = smallestDivisor(nums[i]);
                if(sm>cur) return -1;
                nums[i]=sm;
                ans++;
            }
            cur = nums[i];
            i--;
        }
        return ans;
    }
};",1427843112
Jiahao,plus2047,620,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26);
        int n = s.size();
        int res = 0;
        for(int left = 0; left < n; left++) {
            fill(cnt.begin(), cnt.end(), 0);
            for(int right = left; right < n; right++) {
                int i = s[right] - 'a';
                cnt[i]++;
                if(cnt[i] >= k) {
                    res += n - right;
                    break;
                }
            }
        }
        return res;
    }
};",1427830834
Jiahao,plus2047,620,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string current;
        for(char c: target) {
            current.push_back('a');
            res.push_back(current);
            while(current.back() != c) {
                current.back()++;
                res.push_back(current);
            }
        }
        return res;
    }
};",1427824625
Jiahao,plus2047,620,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        for(int i = n - 2; i >= 0; i--) {
            while(nums[i] > nums[i + 1]) {
                int d = maxDiv(nums[i]);
                if(d != 1) {
                    res++;
                    nums[i] /= d;
                } else {
                    return -1;
                }
            }
        }
        return res;
    }
    int maxDiv(int x) {
        for(int y = 2; y * y <= x; y++) {
            if(x % y == 0) {
                return x / y;
            }
        }
        return 1;
    }
};",1427843265
Conrad_123,Conrad_123,621,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(std::string s, int k) {
        
        std::vector<int> counts(26, 0);
        long long result = 0;
        int back_idx = 0;

        for(int i = 0; i < s.size(); i++){

            counts[s[i]-'a']++;

            while(counts[s[i]-'a'] >= k){
                result += s.size() - i;
                counts[s[back_idx]-'a']--;
                back_idx++;
            }
        }

        return result;
    }
};",1427827069
Conrad_123,Conrad_123,621,3566,cpp,"class Solution {
public:
    std::vector<std::string> stringSequence(std::string target) {

        std::vector<std::string> result;
        std::string current;

        for(int i = 0; i < target.size(); i++){

            current += ""a"";

            while(current.back() != target[i]){
                result.push_back(current);
                current[i]++;
            }
            result.push_back(current);
        }

        return result;
    }
};",1427824944
Conrad_123,Conrad_123,621,3607,cpp,"class Solution {
public:


    int Divide(int num){

        int idx = 3;

        if(num%2 == 0){
            return 2;
        }
        while(idx * idx <= num){
            if(num%idx == 0){
                return idx;
            }
            idx += 2;
        }

        return -1;
    }

    int minOperations(std::vector<int>& nums) {
        
        int max_element = *std::max_element(nums.begin(), nums.end());
        std::vector<bool> is_prime(max_element+1, true);

        is_prime[0] = false;
        is_prime[1] = false;

        for(long long i = 2; i*i <= max_element; i++){

            if(!is_prime[i]) continue;

            for(long long j = i*i; j <= max_element; j += i){
                is_prime[j] = false;
            }
        }


        int result = 0;
        for(int i = (int)nums.size()-2; i >= 0; i--){

            if(nums[i] <= nums[i+1]) continue;

            while(nums[i] > nums[i+1]){

                if(is_prime[nums[i]]) return -1;

                int next = Divide(nums[i]);
                if(next == -1) return -1;
                result++;
                nums[i] = next;
            }
        }

        return result;
    }
};",1427843604
Shubh Gupta,guptashubh6386,622,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n=s.length();
        for(int i=0;i<n;i++){
            int is = 0;
            map<int,int> mp;
            for(int j=i;j<n;j++){
                mp[s[j]] ++;
                if(mp[s[j]] >= k){
                    is = 1;
                }
                if(is == 1){
                    ans ++;
                }
            }
        }
        return ans;
    }
};",1427829086
Shubh Gupta,guptashubh6386,622,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string str = """";
        int cnt = 0;
        for(auto x : target){
            str += 'a';
            ans.push_back(str);
            for(char i = 'b';i<=x;i++){
                str[cnt] = i;
                ans.push_back(str);
            }
            cnt++;
        }
        return ans;
    }
};",1427825392
Shubh Gupta,guptashubh6386,622,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& vec) {
        int n = vec.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (vec[i + 1] < vec[i]) {
                int fnd = 1;
                for (int j = 2; j * j <= vec[i]; j++) {
                    if (vec[i] % j == 0) {
                        fnd = vec[i] / j;
                        break;
                    }
                }
                if (fnd == 1) return -1;  
                vec[i] /= fnd;  
                ans++;
            }
        }
        return ans;
    }
};
",1427843647
wangdh15,wangdh15,623,3502,cpp,"class Solution {
public:

    int cnt[26];

    int numberOfSubstrings(string s, int k) {
        int ans =0 ;
        const int n = s.size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 26; ++j) cnt[j] = 0;
            int j;
            for (j = i; j < n; ++j) {
                cnt[s[j] - 'a']++;
                if (cnt[s[j] - 'a'] == k) break;
            }
            // cout << i << ' ' << j << endl;
            ans += n - j;
        }
        return ans;
    }
};",1427832238
wangdh15,wangdh15,623,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        const int n = target.size();
        for (int i = 0; i < n; ++i) {
            char c = 'a';
            do {
                ans.push_back(target.substr(0, i) + c);
                ++c;
            } while (c <= target[i]);
        }
        return ans;
    }
};",1427827710
wangdh15,wangdh15,623,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        const int n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i+1]) {
                int t = nums[i];
                bool flag = false;
                for (int j = 2; j * j <= t; ++j) {
                    if (t % j == 0) {
                        nums[i] = j;
                        flag = true;
                        ++ans;
                        break;
                    }
                }
                if (!flag) return -1;
            }
        }
        return ans;
    }
};",1427843928
Peter,peterrockwave,624,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        for i in range(len(s)):
            counts = [0] * 26
            good = False
            for j in range(i,len(s)):
                counts[ord(s[j]) - ord('a')] += 1
                if counts[ord(s[j]) - ord('a')] >= k:
                    good = True
                if good:
                    ans += 1
        return ans",1427827932
Peter,peterrockwave,624,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        alpha = ""abcdefghijklmnopqrstuvwxyz""
        ans = []
        for i in range(len(target)):
            j = 0
            while alpha[j] != target[i]:
                ans.append(target[:i] + alpha[j])
                j+=1
            ans.append(target[:i+1])
        return ans",1427825273
Peter,peterrockwave,624,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        is_prime = [True] * 2000
        is_prime[0] = False
        is_prime[1] = False
        primes = []
        for i in range(len(is_prime)):
            if is_prime[i]:
                primes.append(i)
                for j in range(2*i,len(is_prime),i):
                    is_prime[j] = False

        def find_smallest_prime_divisor(n):
            for p in primes:
                if n%p == 0:
                    return p
            return -1
        
        ans = 0
        for i in range(len(nums)-1, 0, -1):
            if nums[i-1] > nums[i]:
                replacement = find_smallest_prime_divisor(nums[i-1])
                if replacement == -1 or replacement > nums[i]:
                    return -1
                ans += 1
                nums[i-1] = replacement
        return ans
",1427835729
jason7708,jason7708,625,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), l = 0, ans = 0;
        vector<int> cnt(26, 0);
        for(int r=0; r<n; r++) {
            char c = s[r] - 'a';
            cnt[c]++;
            while(cnt[c] >= k) {
                cnt[s[l] - 'a']--;
                l++;
            }
            ans += l;
        }
        return ans;
    }
};",1427830461
jason7708,jason7708,625,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        int n = target.size();
        for(int i=0; i<n; i++) {
            for(char c='a'; c<=target[i]; c++) {
                s += c;
                ans.push_back(s);
                if(c != target[i])
                    s.pop_back();    
            }
        }
        return ans;
    }
};",1427825230
jason7708,jason7708,625,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size(), ans = 0;

        for(int i=n-2; i>=0; i--) {
            if(nums[i] > nums[i+1]) {
                for(int j=2; j*j<=nums[i]; j++) {
                    if(nums[i] % j == 0) {
                        nums[i] = j;
                        ans++;
                        break;
                    }
                }
                if(nums[i] > nums[i+1])
                    return -1;
            }
        }
        return ans;
    }
};",1427844047
SAMUVIN JENISH,Sun_fyre,626,3502,cpp,"class Solution {
public:
    bool check(vector<int>&vis,int k)
    {
        for(int i=0;i<26;i++)
        {
            if(vis[i]>=k)
                return true;
        }
        return false;
    }
    int numberOfSubstrings(string s, int k) 
    {
        int res=0;
        for(int i=0;i<s.size();i++)
        {
            vector<int>vis(26,0);
            for(int j=i;j<s.size();j++)
            {
                vis[s[j]-'a']++;
                if(check(vis,k))
                    res++;
            }
        }
        return res;    
    }
};",1427834063
SAMUVIN JENISH,Sun_fyre,626,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) 
    {
        vector<string>res;
        for(int i=0;i<target.size();i++)
        {
            string str="""";
            if(res.empty())
                str+=""a"";
            else
                str=res.back()+""a"";
            while(str.back()!=target[i])
            {
                res.push_back(str);
                str.back()++;
            }
            res.push_back(str);
        }
        return res;   
    }
};",1427827274
SAMUVIN JENISH,Sun_fyre,626,3607,cpp,"class Solution {
public:
    int fact(int num)
    {
        int end=sqrt(num);
        int maxi=1;
        for(int i=2;i<=end;i++)
        {
            if(num%i==0)
            {
                maxi=max({maxi,i,num/i});
            }
        }
        return maxi;
    }
    int minOperations(vector<int>& nums) 
    {
        int res=0;
        int maxi=0;
        for(int i=nums.size()-2;i>=0;i--)
        {
            while(nums[i]>nums[i+1])
            {
                int divisor=fact(nums[i]);
                if(divisor==1)
                    return -1;
                nums[i]/=divisor;
                res++;
            }
        }
        return res;    
    }
};",1427844126
b7d3HcrGsj,b7d3HcrGsj,627,3502,cpp,"#include <unordered_map>
#include <string>

class Solution {
public:
    int numberOfSubstrings(std::string s, int k) {
        int n = s.size();
        int left = 0, right = 0;
        int count = 0;
        std::unordered_map<char, int> charCount;

        // Expand the window with the right pointer
        for (right = 0; right < n; ++right) {
            // Increase the count of the character at the right pointer
            charCount[s[right]]++;

            // Check if we have a valid substring where at least one character count >= k
            while (charCount[s[right]] >= k) {
                // If valid, count all substrings ending at right with starting point from left to right
                count += (n - right); // All substrings starting from left to right ending at or after right are valid
                charCount[s[left]]--; // Shrink the window from the left
                left++; // Move left pointer to the right
            }
        }

        return count;
    }
};
",1427824649
b7d3HcrGsj,b7d3HcrGsj,627,3566,cpp,"#include <vector>
#include <string>

class Solution {
public:
    std::vector<std::string> stringSequence(std::string target) {
        std::vector<std::string> result;
        std::string currentString = """";

        // Loop through each character in the target string
        for (char targetChar : target) {
            // Append 'a' to the string first
            currentString += 'a';
            result.push_back(currentString);

            // Increment the last character from 'a' to the target character if needed
            while (currentString.back() != targetChar) {
                currentString.back() = currentString.back() + 1; // Move to the next character
                result.push_back(currentString);
            }
        }

        return result;
    }
};
",1427823964
b7d3HcrGsj,b7d3HcrGsj,627,3607,cpp,"#include <vector>
#include <algorithm>

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int op=0;
        for(int i=nums.size()-2;i>=0;i--){
            if(nums[i]<=nums[i+1]) continue;
            for(long long j=2;j*j<=nums[i];j++){
                if(nums[i]%j==0) {
                    nums[i]=j;
                    op++;
                    break;
                }
            }
            if(nums[i]>nums[i+1]) return -1;
        }
        
        return op;
    }
};
",1427844298
Wilsano,Wilsano,628,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int count = 0;
        for(int i = 0; i < n; ++i){
            bool valid = false;
            vector<int> freq(26, 0);
            for(int j = i; j < n; ++j){
                freq[s[j] - 'a'] += 1;
                if(freq[s[j] - 'a'] >= k){
                    valid = true;
                }
                
                if(valid){
                    count += (n - j);
                    break;
                }
            }
        }
        return count;
    }
};",1427833100
Wilsano,Wilsano,628,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string cur = """";
        for(int i = 0; i < target.size(); ++i){
            cur += ""a"";
            res.push_back(cur);
            while(cur.back() != target[i]){
                cur.back() += 1;
                res.push_back(cur);
            }
        }
        return res;
    }
};",1427825243
Wilsano,Wilsano,628,3607,cpp,"class Solution {
public:
    int helper(int num, vector<int>& primes){
        for(const int& prime : primes){
            if(num % prime == 0){
                return prime;
            }
        }
        return num;
    }
    
    int minOperations(vector<int>& nums) {
        vector<int> primes = {2};
        vector<bool> visited(sqrt(1e6), false);
        for(int i = 3; i <= sqrt(1e6); i += 2){
            if(!visited[i]){
                primes.push_back(i);
                for(int j = i * i ; j <= sqrt(1e6); j += 2 * i){
                    visited[j] = true;
                }
            }
        }

        int count = 0;
        int max_val = INT_MAX;
        for(int i = nums.size() - 1; i >= 0; --i){
            if(nums[i] > max_val){
                nums[i] = helper(nums[i], primes);
                count += 1;
            }
            if(nums[i] > max_val){
                return -1;
            }
            max_val = nums[i];
        }
        return count;
    }
};",1427844500
Andrew H. Pometta,apometta,629,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        subs = 0
        chars = {}
        earliest = n

        for i in range(len(s) - 1, -1, -1):
            c = s[i]
            if c not in chars:
                chars[c] = deque([])
            chars[c].appendleft(i)
            if len(chars[c]) > k: chars[c].pop()
            if len(chars[c]) == k: earliest = min(earliest, chars[c][-1])
            
            subs += n - earliest
        
        return subs",1427836955
Andrew H. Pometta,apometta,629,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        if target == ""a"": return [""a""]
        ans = []
        
        for i in range(len(target)):
            base = """" if len(ans) == 0 else ans[-1]
            ans.append(base + 'a')
            curchar = ord('a')

            while ans[-1][-1] != target[i]:
                curchar += 1
                ans.append(base + chr(curchar))
        
        return ans",1427826651
Andrew H. Pometta,apometta,629,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ops = 0
        for i in range(len(nums) - 2, -1, -1):
            while nums[i] > nums[i + 1]:
                prev = nums[i]
                j = 2
                while j * j <= prev:
                    if prev % j == 0:
                        nums[i] = j
                        break
                    j += 1
                
                if nums[i] == prev: return -1 #impossible
                else: ops += 1
        
        return ops",1427844566
Ryan,ryanwong0127,631,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n,res = len(s),0

        for i in range(n):
            cnt = [0] * 26  
            max_freq = 0
            for j in range(i, n):
                index = ord(s[j]) - ord('a')
                cnt[index] += 1
                if cnt[index] > max_freq:
                    max_freq = cnt[index]
                if max_freq >= k:
                    res += 1
        return res",1427828461
Ryan,ryanwong0127,631,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        cur, res = [], []

        for c in target:
            cur.append('a')
            res.append(''.join(cur))
            key2_presses = (ord(c) - ord('a')) % 26
            
            for _ in range(key2_presses):
                last_char = cur[-1]
                next_char = chr(((ord(last_char) - ord('a') + 1) % 26) + ord('a'))
                cur[-1] = next_char
                res.append(''.join(cur))
        
        return res",1427826019
Ryan,ryanwong0127,631,3607,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
constexpr static int N = 1e6 + 5;
int spf[N]; 

// 预处理最小质因数
void compute_spf() {
    rep(i, 0, N){spf[i] = i;}
    for (int i = 2; i * i < N; ++i) {
        if (spf[i] == i) { 
            for (int j = i * i; j < N; j += i) {
                if (spf[j] == j) { spf[j] = i;}
            }
        }
    }
    spf[1] = 1;
}
bool INIT = false;
class Solution {
public:
    int minOperations(vector<int>& a) {
        if (!INIT) {
            INIT = 1;
            compute_spf();
        }
        const int n = a.size();
        int res = 0;
        for (int i = n - 2; i >= 0; --i) {
            while (a[i] > a[i + 1]) {
                if (a[i] == spf[a[i]]) {
                    return -1;
                }
                a[i] = spf[a[i]];
                ++res;
            }
        }
        return res;
    }
};",1427845186
Yash Arya,Yash_Arya2003,632,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.length();
        for(int x=0;x<n;x++){
            vector<int>st(26,0);
            bool gt=false;
            for(int y=x;y<n;y++){
                st[s[y]-'a']++;
                if(st[s[y]-'a']>=k)gt=true;
                if(gt)ans++;
            }
        }
        return ans;
    }
};",1427834282
Yash Arya,Yash_Arya2003,632,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string as="""";
        char a='a';
        while(as!=target){
            as+=a;
            int n=as.length()-1;
            ans.push_back(as);
            while(target[n]!=as[n]){
                a+=1;
                as[n]=a;
                ans.push_back(as);
            }
            a='a';
        }
        return ans;
    }
};",1427826734
Yash Arya,Yash_Arya2003,632,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int op=0;
        bool gt=true;
        int n=nums.size();
        for(int x=n-2;x>=0;x--){
            if(nums[x]>nums[x+1]){
                int nm=nums[x];
                // int mx=1;
                for(int y=2;y<=sqrt(nm);y++){
                    if((nm%y)==0){
                        nm=y;
                        op++;
                        break;
                    }
                }
                nums[x]=nm;
            }
            if(nums[x]>nums[x+1]){
                gt=false;
                break;
            }
        }
        if(!gt)return -1;
        return op;
        
    }
};",1427845506
JosephMother,JosephMother,633,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:

        res = 0
        for i in range(len(s)):
            c = defaultdict(int)
            met = False
            for j in range(i, len(s)):
                c[s[j]] += 1
                if c[s[j]] >= k:
                    met = True
                if met:
                    res += 1
                
            
        
        return res


        ",1427827696
JosephMother,JosephMother,633,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:

        res = []
        s = """"
        for let in target:
            for i in range(ord(let) - ord('a') + 1):
                res.append(s + chr(ord('a') + i))
            
            s += let
        
        return res
        ",1427824181
JosephMother,JosephMother,633,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:

        def find_d(num):
            for i in range(2, int(sqrt(num)) +1):
                if num % i == 0:
                    return num // i
            return -1
        nums = list(nums)
        ops = 0
        for i in range(len(nums) -2, -1, -1):
            num = nums[i]
            # print(num)
            while num > nums[i+1]:
                d = find_d(num)
                if d == -1:
                    return -1
                num /= d
                ops +=1
            nums[i] = num
        
        return ops
        
        ",1427837361
a_k,a0518,634,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        # mp = defaultdict(int)
        n = len(s)
        prefix = [[0 for _ in range(26)] for _ in range(n)]
        
        for i in range(n):
            for j in range(26):
                if i != 0: prefix[i][j] = prefix[i-1][j]
            prefix[i][ord(s[i])-ord('a')]+=1
            
        res = 0
        for i in range(n):
            l = 0
            r = i
            x = -1
            while l <= r:
                mid = (l+r)//2
                mx = 0
                for j in range(26):
                    cur = prefix[i][j]-(prefix[mid-1][j] if mid-1 >= 0 else 0)
                    mx = max(mx, cur)
                if mx >= k: 
                    x = mid
                    l = mid+1
                else: r = mid-1
            res+=x+1
        return res
        # mp = defaultdict(int)
        # l = 0
        # res = 0
        # for i in range(n):
        #     mp[s[i]]+=1
        #     while max(mp.values()) >= k:
        #         mp[s[l]]-=1
        #         res+=l+1
        #         l+=1
        # return res",1427838524
a_k,a0518,634,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = 'a'
        s = ''
        for i in range(len(target)):
            s = s + cur
            while cur != target[i]:
                s = s[:-1] + cur
                res.append(s)
                cur = chr(( (ord(cur)-ord('a')+1)%26 + ord('a') ))
                # if i == 0: print(cur)
                # res.append(s[:-2] + cur)
            # if i == 1: print(s, cur)
            s = s[:-1] + cur
            res.append(s)
            # s = s + cur
            cur = 'a'
        
        return res
            ",1427830314
a_k,a0518,634,3607,python3,"m = 10**6
a = [[] for _ in range(m+1)]

for i in range(2, m+1):
    for j in range(i+i, m+1, i):
        a[j].append(i)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)
        cnt = 0
        for i in range(n-2, -1, -1):
            arr = a[nums[i]]
            idx = len(arr)-1
            while idx >= 0 and nums[i] > nums[i+1]:
                nums[i]//=arr[idx]
                idx-=1
                cnt+=1
            if nums[i] > nums[i+1]: return -1
        return cnt",1427845640
Joker King,NerdyCoder,636,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int n = s.size();
        array<int, 26> cnts{};
        int result = 0;
        int count = 0;
        for (int i = 0, j = 0; j < n; ++j) {
            if (++cnts[s[j] - 'a'] == k) {
                ++count;
            }
            while (count > 0) {
                if (--cnts[s[i] - 'a'] == k - 1) {
                    --count;
                }
                ++i;
            }
            result += i;
        }
        return result;
    }
};",1427833542
Joker King,NerdyCoder,636,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> results;
        string str;
        str.reserve(target.size());
        for (char ch : target) {
            str.push_back('a');
            results.push_back(str);
            while (str.back() != ch) {
                str.back() = (str.back() == 'z' ? 'a' : str.back() + 1);
                results.push_back(str);
            }
        }
        return results;
    }
};",1427825953
Joker King,NerdyCoder,636,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int last = INT_MAX;
        int result = 0;
        unordered_map<int, int> memo;
        const auto get = [&memo](int val) {
           auto it = memo.find(val);
            if (it == memo.end()) {
                int result = -1;
                for (int i = 2; 1LL * i * i <= val; ++i) {
                    if (val % i == 0) {
                        result = val / i;
                        break;
                    }
                }
                it = memo.emplace(val, result).first;
            }
            return it->second;
        };
        for (int i = nums.size() - 1; i >= 0; --i) {
            int num = nums[i];
            while (num > last) {
                int f = get(num);
                if (f < 0) {
                    return -1;
                }
                ++result;
                num /= f;
            }
            last = num;
        }
        return result;
    }
};",1427845908
tzhuan,tzhuan,637,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        const int N = s.size();
        vector<vector<int>> psum(26, vector<int>{0});
        for (int i = 0; i < N; ++i) {
            for (int c = 0; c < 26; ++c) psum[c].push_back(psum[c].back() + (s[i] == 'a' + c ? 1 : 0));
        }
        // for (int c = 0; c < 26; ++c) { for (auto n: psum[c]) cout << n << "" ""; cout << endl; }
        int ans = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = i; j < N; ++j) {
                for (int c = 0; c < 26; ++c) {
                    if (psum[c][j + 1] - psum[c][i] >= k) { ++ans; break; }
                }
            }
        }
        return ans;
    }
}; ",1427837140
tzhuan,tzhuan,637,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        for (auto c: target) {
            auto p = ans.empty() ? """" : ans.back();
            for (char i = 'a'; i <= c; ++i) ans.push_back(p + i);
        }
        return ans;
    }
};",1427826077
tzhuan,tzhuan,637,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int N = nums.size();
        unordered_map<int, int> cache;
        auto gpd = [&](int n) {
            auto p = cache.find(n);
            if (p != cache.end()) return p->second;
            for (int i = 2; i * i <= n; ++i) if (n % i == 0) return cache[n] = max(i, n / i);
            return cache[n] = -1;
        };
        int ans = 0;
        for (int i = N - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                auto d = gpd(nums[i]);
                if (d == -1) return -1;
                nums[i] /= d;
                ++ans;
            }
        }
        return ans;
    }
};",1427846113
Yash,Yash9890,638,3502,java,"class Solution {
   public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int cnt= 0;
        for(int i =0 ; i< n; i++){
            int freq[]= new int[26];
            boolean done = false;
            for(int j = i; j < n; j++){
                freq[s.charAt(j)-'a']++;
                if(freq[s.charAt(j)-'a'] >= k || done){
                    cnt++;
                    done = true;
                }
            }
        }
        
        return cnt;
    }
}",1427831057
Yash,Yash9890,638,3566,java,"class Solution {
     public List<String> stringSequence(String target) {
        List<String> list = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < target.length(); i++){
            
            for(char j = 'a'; j <= target.charAt(i); j++){
                StringBuilder cur = new StringBuilder(sb);
                cur.append(j);
                list.add(cur.toString());
            }
            sb.append(target.charAt(i));
        }
        
        
        return list;
    }
}",1427827303
Yash,Yash9890,638,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        ArrayList<Integer> list= new ArrayList<>();
        for(int i = 0; i < n; i++){
            boolean div = false;
            for(int j = 2; j * j <= nums[i];j++){
                if(nums[i]%j == 0){
                    div = true;
                    list.add(j);
                    break;
                }
            }
            if(!div) list.add(nums[i]);
        }
        int operations = 0;
        boolean valid = true;
        int last = nums[n-1];
        for(int i = n-2;i>=0;i--){
            if(nums[i] <= last){
                last = nums[i];
            }else if(list.get(i) <= last) {
                last = list.get(i);
                operations++;
            }else {
                valid =false;
            }
        }
        
        return valid ? operations : -1;
    }
}",1427846238
Joey Woodson,SaveVMK,639,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int b = -1;
        int[] cts = new int[26];
        int ans = 0;
        for (int a = 0; a < n; ++a) {
            while (true) {
                int mcat = 0;
                for (int x : cts)
                    mcat = Math.max(mcat,x);
                if (mcat>=k)
                    break;
                if (b==n)
                    break;
                ++b;
                if (b==n)
                    break;
                cts[s.charAt(b)-'a']++;
            }
            ans += n-b;
            cts[s.charAt(a)-'a']--;
        }
        return ans;
    }
}",1427834660
Joey Woodson,SaveVMK,639,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        String curr = ""a"";
        ans.add(curr);
        while (!curr.equals(target)) {
            if (curr.charAt(curr.length()-1)!=target.charAt(curr.length()-1)) {
                curr = curr.substring(0,curr.length()-1)+(char)(curr.charAt(curr.length()-1)+1);
            } else {
                curr = curr+'a';
            }
            //System.out.println(curr);
            ans.add(curr);
        }
        return ans;
    }
}",1427825799
Joey Woodson,SaveVMK,639,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        ArrayList<Integer> primes = new ArrayList<>();
        primes.add(2);
        for (int i = 3; i <= 1000; i+=2) {
            boolean add = true;
            for (int p : primes) {
                if (p*p>i)
                    break;
                if (i%p==0) {
                    add = false;
                    break;
                }
            }
            if (add)
                primes.add(i);
        }
        int ans = 0;
        int n = nums.length;
        int curr = nums[n-1];
        for (int i = n-2; i >= 0; --i) {
            int val = nums[i];
            if (val<=curr) {
                curr = val;
                continue;
            }
            ++ans;
            for (int p : primes) {
                if (p*p>val)
                    break;
                if (val%p==0)
                    val = p;
            }
            if (val<=curr) {
                curr = val;
                continue;
            } else {
                return -1;
            }
        }
        return ans;
    }
}",1427846422
Jie Zhu,JZhu0815,640,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] arr = s.toCharArray();
        int n = arr.length;
        int[] cnt = new int[26];
        int j = 0, result = 0;
        for (int i = 0; i < n; i++) {
            cnt[arr[i] - 'a']++;
            while (hasK(cnt, k)) {
                result += n - i;
                cnt[arr[j] - 'a']--;
                j++;
            }
        }
        return result;
        
    }
    private boolean hasK(int[] cnt, int k) {
        for (int ct  : cnt) {
            if (ct >= k) {
                return true;
            }
        }
        return false;
    }
}",1427831795
Jie Zhu,JZhu0815,640,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> result = new ArrayList<>();
        StringBuilder current = new StringBuilder();

        // Start typing the target string
        for (int i = 0; i < target.length(); i++) {
            char targetChar = target.charAt(i);
            if (current.length() == 0) {
                // We begin by typing 'a' since the screen is initially empty
                current.append('a');
                result.add(current.toString());
            } else {
                current.append('a');  // Press Key 1 to append 'a'
                result.add(current.toString());
            }

            // Now adjust the last character using Key 2 until it matches targetChar
            while (current.charAt(current.length() - 1) != targetChar) {
                current.setCharAt(current.length() - 1, getNextChar(current.charAt(current.length() - 1)));
                result.add(current.toString());
            }
        }
        return result;
    }
    private char getNextChar(char c) {
        if (c == 'z') {
            return 'a';  // 'z' wraps around to 'a'
        } else {
            return (char) (c + 1);
        }
    }
}",1427824800
Jie Zhu,JZhu0815,640,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length, result = 0;
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] <= nums[i + 1]) {
                continue;
            }
            int cur = nums[i];
            while (cur > nums[i + 1]) {
                int d = findGreatest(cur);
                if (d == 1) {
                    return -1;
                }
                cur = cur / d;
                result++;
            }
            nums[i] = cur;
        }
        return result;
        
    }
    private int findGreatest(int x) {
        for (int i = 2; i * i < x + 1; i++) {
            if (x % i == 0) {
                return x / i;
            }
        }
        return 1;
    }
}",1427846550
Yatin Kwatra,yatin_kwatra,641,3502,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	int numberOfSubstrings(string s, int k) {
		int n = sz(s);
		int ans = 0;

		fo(i, 0, n - 1) {
			vector<int> f(26, 0);
			int mx = 0;
			rfo(j, i, 0) {
				f[s[j] - 'a']++;
				mx = max(mx, f[s[j] - 'a']);
				if (mx == k) {
					ans += j + 1;
					break;
				}
			}
		}
		return ans;
	}
};
















",1427828940
Yatin Kwatra,yatin_kwatra,641,3566,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	vector<string> stringSequence(string target) {
		vector<string> ans;

		string cur = """";
		int n = sz(target);

		for (auto &ch : target) {
			int need = ch - 'a';
			int have = 0;

			while (have != need) {
				ans.pb(cur + char(have + 'a'));
				have = (have + 1) % 26;
			}
			cur += ch;
			ans.pb(cur);
		}
		return ans;
	}
};


















",1427826354
Yatin Kwatra,yatin_kwatra,641,3607,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

const int N = 1e6 + 5;
int f[N];

void sieve() {
	fo(i, 0, N - 1) f[i] = i;
	f[0] = f[1] = 0;

	fo(i, 2, N - 1) {
		for (int j = 2 * i; j < N; j += i) f[j] = i;
	}
}

class Solution {
public:
	int minOperations(vector<int>& nums) {
		if (!f[2]) {
			sieve();
		}
		reverse(all(nums));

		int n = sz(nums);
		int ans = 0;

		fo(i, 1, n - 1) {
			while (nums[i] > nums[i - 1]) {
				if (f[nums[i]] == nums[i]) break;
				nums[i] /= f[nums[i]];
				ans++;
			}
			if (nums[i] > nums[i - 1]) return -1;
		}
		return ans;
	}
};
















",1427838967
shivambhagat02,shivambhagat02,642,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        n = len(s)
        
        ans = 0
        
        for i in range(n):
            
            c = [0] * 26
            
            mx = 0
            
            for j in range(i, n):
                
                c[ord(s[j]) - 97] += 1
                
                mx = max(mx, c[ord(s[j]) - 97])
                
                if mx >= k:
                    ans += 1
        
        return ans",1427830028
shivambhagat02,shivambhagat02,642,3566,python3,"class Solution:
    def stringSequence(self, t: str) -> List[str]:
        
        ans = []
        
        pre = """"
        
        for v in t:
            
            ch = v
            
            cur = 97
            while chr(cur) != v:
                
                ans.append(pre + chr(cur))
                
                cur += 1
            
            ans.append(pre + chr(cur))
            
            pre = ans[-1]
        
        return ans",1427826144
shivambhagat02,shivambhagat02,642,3607,python3,"MX = 10 ** 6 + 1

G = [1] * MX

for i in range(2, MX):    
    for j in range(i, MX, i):
        if i != j:
            G[j] = i
        
        
class Solution:
    def minOperations(self, a: List[int]) -> int:
        
        ans = 0
        
        for i in range(len(a) - 2, -1, -1):
            
            while a[i] > a[i + 1]:
                
                cur = a[i] // G[a[i]]
                
                if cur == a[i]:
                    return -1
                
                a[i] = cur
                ans += 1
        
        return ans",1427847106
kailam11223,kailam11223,643,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        map<char, int> count;
        int r = 0;
        while(r < n){
            if(++count[s[r++]]==k) break;
        }
        if(r == n && count[s[r-1]] < k) return 0;
        int ret = n-r+1;
        for(int l = 1; l < n; ++l){
            count[s[l-1]]--;
            if(count[s[l-1]]==k-1){
                while(r < n){
                    if(++count[s[r++]]==k) break;
                }
            }
            if(r == n && count[s[r-1]] < k) return ret;
            ret += n-r+1;
        }
        return ret;
    }
};",1427838077
kailam11223,kailam11223,643,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string str = ""a"";
        vector<string> ret{str};
        while(str!=target){
            if(str.back()==target[str.length()-1]){
                str += 'a';
            } else {
                str.back()++;
            }
            ret.push_back(str);
        }
        return ret;
    }
};",1427825045
kailam11223,kailam11223,643,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        if(n==1) return 0;
        int ret = 0;
        for(int i = n - 2; i >= 0; --i){
            if(nums[i] <= nums[i+1]) continue;
            for(int x = 2; x <= nums[i+1]; ++x){
                if(nums[i]%x==0) nums[i] = x;
            }
            if(nums[i] > nums[i+1]) return -1;
            ret++;
        }
        return ret;
    }
};",1427847111
Shaik Mohammad Shareef,shareefbasha1999,645,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int count=0;
        
        vector<int> freq(26,0);
        
        int left=0,right=0;
        
        int n = s.length();
        
        while(right < n)
        {

            freq[s[right]-'a']++;
            
            while(freq[s[right]-'a'] >= k)
            {
                count += (n-right);
                freq[s[left]-'a']--;
                left++;
            }
            
            right++;
        }
        
        
        return count;
        
    }
};",1427831451
Shaik Mohammad Shareef,shareefbasha1999,645,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        
        vector<string> result;
        
        string temp = """";
        string temp2 = """";
        
        for(int i=0;i<target.length();i++)
        {
            for(char x = 'a'; x<= target[i];x++)
            {
                temp2 = temp + x;
                result.push_back(temp2);   
            }
            temp = temp + target[i];
        }
        
        return result;
        
    }
};",1427825956
Shaik Mohammad Shareef,shareefbasha1999,645,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        
        int count=0;
        
        for(int i=nums.size()-2;i>=0;i--)
        {
            if(nums[i] > nums[i+1])
            {
                for(int j=2;j<=sqrt(nums[i]);j++)
                {
                    if(nums[i]%j == 0)
                    {
                        count++;
                        nums[i] = j;
                        break;
                    }
                }
            }
            
            if(nums[i] > nums[i+1])
                return -1;
        }
        
        return count;
    }
};",1427847351
sjkdwe,sjkdwe,646,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res = 0
        for i in range(len(s)):
            c = Counter()
            for j in range(i, len(s)):
                c[s[j]] += 1
                if c[s[j]] >= k:
                    res += len(s) - j
                    break
        return res",1427831676
sjkdwe,sjkdwe,646,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        for i in range(len(target)):
            cur = 'a'
            while True:
                res.append(target[:i] + cur)
                if cur == target[i]: break
                if cur == 'z':
                    cur = 'a'
                else:
                    cur = chr(ord(cur) + 1)
        return res",1427826360
sjkdwe,sjkdwe,646,3607,python3,"divisor = [0] * (10**6 + 1)
for i in range(2, len(divisor)):
    if divisor[i] == 0:
        divisor[i] = 1
        for j in range(i * i, len(divisor), i):
            if divisor[j] == 0:
                divisor[j] = j // i
divisor[0] = divisor[1] = 1

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums) - 2, -1, -1):
            while divisor[nums[i]] > 1 and nums[i] > nums[i+1]:
                nums[i] //= divisor[nums[i]]
                res += 1
            if nums[i] > nums[i+1]:
                res = -1
                break
        return res
        
        # greatest proper div is x / smallest prime, if its 1 then no proper divsor",1427847404
DLon_,DLon_,648,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] c = s.toCharArray();
        int result = 0;
        
        int[] times = new int[26];
        int maxTimes = 0;
        int start = 0;
        for (int end = 0; end < c.length; end++) {
            char x = c[end];
            times[x - 'a']++;
            if (times[x - 'a'] > maxTimes) {
                maxTimes = times[x - 'a'];
            }
            
            while (maxTimes >= k) {
                result += c.length - end;
                times[c[start] - 'a']--;
                start++;
                maxTimes = get(times);
            }
        }
        return result;
    }
    
    public int get(int[] times) {
        int result = 0;
        for (int x: times) {
            result = Math.max(result, x);
        }
        return result;
    }
}",1427834228
DLon_,DLon_,648,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        List<String> result = new ArrayList<>();
        
        char[] c = target.toCharArray();
        for (int i = 0; i < c.length; i++) {
            char x = 'a';
            while (x != c[i]) {
                result.add(sb.toString() + String.valueOf(x));
                x++;
            }
            result.add(sb.toString() + String.valueOf(x));
            sb.append(x);
        }
        return result;
    }
}",1427825506
DLon_,DLon_,648,3607,java,"class Solution {
    
    private HashMap<Integer, Integer> map = new HashMap<>();
    
    public int minOperations(int[] nums) {
        int result = 0;
        int n = nums.length;
        
        A:
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                nums[i] = f(nums[i]);
                if (nums[i] == -1) {
                    result = -1;
                    break A;
                }
                result += 1;
            }
        }
        return result;
    }
    
    private int f(int x) {
        if (map.containsKey(x)) {
            return map.get(x);
        }
        int d = ld(x);
        map.put(x, d);
        return d;
    }
    
    private int ld(int x) {
        for (int i = 2; i <= Math.sqrt(x); i++) {
            if (x % i == 0) {
                return i;
            }
        }
        return -1;
    }
    
}",1427847562
SIDDHARTH,lakh,650,3502,cpp,"int dp[3001][26];
class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.size();
        for(int i=1;i<=n;i++) {
            for(int j=0;j<26;j++) {
                dp[i][j]=dp[i-1][j];
            }
            int cv=s[i-1]-'a';
            dp[i][cv]+=1;
        }
        for(int i=1;i<=n;i++) {
            int lo=i, hi=n, re=-1;
            while(lo<=hi) {
                int mi=(lo+hi)/2;
                int f=0;
                for(int j=0;j<26;j++) {
                    int cc=dp[mi][j]-dp[i-1][j];
                    if(cc>=k) {
                        f=1;
                        break;
                    }
                }
                if(f) re=mi, hi=mi-1;
                else lo=mi+1;
            }
            if(re!=-1) ans += (n-re+1);
        }
        return ans;
    }
};",1427834168
SIDDHARTH,lakh,650,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string>re;
        int n=t.size();
        string tmp="""";
        for(char c: t) {
            char cur='a';
            tmp+=cur;
            if(c==cur) {
                re.push_back(tmp);
            } else {
                while(cur<c) {
                    tmp.pop_back();
                    tmp+=cur;
                    re.push_back(tmp);
                    cur++;
                }
                tmp.pop_back();
                tmp+=cur;
                re.push_back(tmp);
            }
        }
        return re;
    }
};",1427827596
SIDDHARTH,lakh,650,3607,cpp,"int dv[1000001];
class Solution {
public:
    void go() {
        dv[1]=1;
        for(int i=2;i<=1000000;i++) {
            for(int j=i+i;j<=1000000;j+=i) {
                dv[j]=i;
            }
        }
    }
    int minOperations(vector<int>& nums) {
        if(!dv[6]) go();
        reverse(nums.begin(), nums.end());
        int ans=0;
        int n=nums.size();
        for(int i=1;i<n;i++) {
            int cv=nums[i];
            if(cv>nums[i-1]) {
              while(cv>nums[i-1]) {
                  if(dv[cv]==0) return -1;
                  cv /= dv[cv];
                  ans+=1;
              }
                nums[i]=cv;
            } 
        }
        return ans;
    }
};",1427847748
Dhruv Verma,DDHCOdes,651,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i=0;i<s.size();i++){
            unordered_map<char,int>mp;
            bool pos=false;
            for(int j=i;j<s.size();j++){
                mp[s[j]]++;
                if(mp[s[j]]>=k){
                    pos=true;
                }
                if(pos){
                    ans++;
                }
            }

        }

        return ans;
    }
};",1427829452
Dhruv Verma,DDHCOdes,651,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string temp="""";
        for(int i=0;i<target.size();i++){
            char ch='a';
            temp+=ch;
            ans.push_back(temp);
            while(ch!=target[i]){
                temp.pop_back();
                ch++;
                temp+=ch;
                ans.push_back(temp);
            }
        }
        return ans;
    }
};",1427825533
Dhruv Verma,DDHCOdes,651,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int count=0;

        //process
        int n=nums.size();
        for(int i=n-2;i>=0;i--){
            while(nums[i]>nums[i+1]){
                bool ch=false;
                for(int j=2;j*j<=nums[i];j++){
                    if(nums[i]%j==0){
                        int div=nums[i]/j;
                        nums[i]/=div;
                        ch=true;
                        count++;
                        break;
                    }
                }

                if(!ch) return -1;
            }
        }

        return count;
    }
};",1427847787
d11235813,d11235813,652,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int total = 0;
        for(int i = 0; i < s.size(); i++){
            std::unordered_map<char, int> counts;
            bool hit = false;
            for(int j = i; j < s.size(); j++){
                ++counts[s[j]];
                if(hit || counts[s[j]] >= k){
                    hit = true;
                    ++total;
                }
            }
        }
        return total;
    }
};",1427830826
d11235813,d11235813,652,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
       std::vector<std::string> out; 
       std::string ans = """";
       for(int i = 0; i < target.size(); i++){
        char c = target[i];
        char start = 'a';
        ans.push_back(start);
        while(start <= c){
            ans.back() = start;
            out.push_back(ans);
            start++;
        }
       }
       return out;
    }
};",1427824971
d11235813,d11235813,652,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
       // >=
       // divide by greatest proper divisor, highest that's not that number 
       //to iterate through possible divisors -> 10^3 * 10^6 = 10^9 worst + 10^5
       //can start from end and go greedy
       std::unordered_map<int, int> cache;
       int ops = 0;

       for(int i = nums.size() - 2; i >= 0; i--){
        while(nums[i] > nums[i+1]){
            auto div = get_div(nums[i], cache);
            if(div == -1){
                return -1;
            }

            nums[i] = nums[i]/div;
            ++ops;
        }
       }
       return ops;
    }

    int get_div(int num, auto& cache){
        if(num == 2){
            return -1;
        }
        if(num%2 == 0){
            return num/2;
        }
        if(cache.find(num) != cache.end()){
            return cache[num];
        }
        for(int i = 2; i * i <= num; i++){
            if(num%i == 0){
                cache[num] = num/i;
                return num/i;
            }
        }
        cache[num] = -1;
        return -1;
    }
};",1427848382
Ir1descent,Ir1descent,653,3502,java,"public class Solution {
    public int numberOfSubstrings(String s, int k) {
        int totalSubstrings = 0;
        int n = s.length();

        // Iterate over each possible starting point of the substring
        for (int start = 0; start < n; start++) {
            HashMap<Character, Integer> charCount = new HashMap<>();

            // Try each possible ending point for this starting point
            for (int end = start; end < n; end++) {
                char c = s.charAt(end);

                // Update the count of the character at position `end`
                charCount.put(c, charCount.getOrDefault(c, 0) + 1);

                // Check if any character has appeared at least `k` times
                if (charCount.get(c) >= k) {
                    // If yes, then all substrings starting from `start` to any point `end`
                    // up to `n` will be valid, so add them all.
                    totalSubstrings += (n - end);
                    break;  // No need to expand the window further, we already found the valid substrings
                }
            }
        }
        return totalSubstrings;
    }
}",1427834315
Ir1descent,Ir1descent,653,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();
        StringBuffer sb = new StringBuffer();
        for(int i = 0; i < target.length(); i++) {
            char c = target.charAt(i);
            for(char a = 'a'; a <= c; a++) {
                if(a == 'a') {
                    sb.append(a);
                }else{
                    sb.setCharAt(sb.length() - 1, a);
                }
                res.add(sb.toString());
            }
        }
        return res;
    }
}",1427827133
Ir1descent,Ir1descent,653,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int res = 0;
        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] <= nums[i + 1]) {
                continue;
            }
            int f = smallestPrimeFactor(nums[i]);
            if(f == nums[i]) {return -1;}
            if(f > nums[i + 1]) {return -1;}
            nums[i] = f;
            res++;
        }
        return res;
    }

    public int smallestPrimeFactor(int n) {
        if (n <= 1) {
            return 1;
        }

        if (n % 2 == 0) {
            return 2;
        }

        for (int i = 3; i * i <= n; i += 2) {
            if (n % i == 0) {
                return i; 
            }
        }
        return n;
    }
}",1427848388
Sahil Hussain,mdsahil37621,654,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        
        for(int i = 0; i < n; i++){
            map<char, int> mp;
            for(int j = i; j < n; j++){
                mp[s[j]]++;
                if(mp[s[j]] == k){
                    res += n - j;
                    break;
                }
            }
        }
        return res;
    }
};",1427831679
Sahil Hussain,mdsahil37621,654,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string s;
        for(int i = 0; i < target.size(); i++){
            s += 'a';
            res.push_back(s);
            for(char ch = 'b'; ch <= target[i]; ch++){
                s.back() = ch;
                res.push_back(s);
            }
        }
        return res;
    }
};",1427825386
Sahil Hussain,mdsahil37621,654,3607,cpp,"class Solution {
public:
    int getMin(int num){
        for(int i = 2; i*i <= num; i++){
            if(num%i == 0) return i;
        }
        return num;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int prev = 1e9;
        int res = 0;
        
        for(int i = n-1; i >= 0; i--){
            if(nums[i] <= prev){
                prev = nums[i];
                continue;
            }
            
            int curr = getMin(nums[i]);
            res++;
            
            if(curr > prev) return -1;
            
            prev = curr;
        }
        return res;
    }
};",1427848393
MenIn___,MenIn___,655,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
       int cnt=0, n=s.length();
        for(int i=0;i<n;i++){
            int[] f=new int[26];
            int t=0;
            for(int j=i;j<n;j++){
                f[s.charAt(j)-'a']++;
                if(f[s.charAt(j)-'a'] ==k){
                    t++;
                }
                if(t>0){
                    cnt++;
                }
            }
        }
        return cnt; 
    }
}",1427825168
MenIn___,MenIn___,655,3566,java,"class Solution {
    public List<String> stringSequence(String t) {
        List<String> r=new ArrayList<>();
        StringBuilder shi=new StringBuilder();
        for(char c:t.toCharArray()){
            shi.append('a');
            r.add(shi.toString());
            int k=(c - 'a')%26;
            for(int i=0;i<k;i++){
                char last=(char)(((shi.charAt(shi.length()-1)-'a'+1)%26)+'a');
                shi.setCharAt(shi.length()-1, last);
                r.add(shi.toString());
            }
        }
        return r;
    }
}",1427826659
MenIn___,MenIn___,655,3607,java,"class Solution {

    private static final int MAX = 1000001;
    private static int[] gpdArr = new int[MAX];

    static {
        Arrays.fill(gpdArr, -1);
        for (int ik = 2; ik < MAX; ik++) {
            for (int j = 2 * ik; j < MAX; j += ik) {
                gpdArr[j] = ik;
            }
            if (gpdArr[ik] == -1) {
                gpdArr[ik] = 1;
            }
        }
    }

    public int minOperations(int[] nums) {
        int cnt = 0, n = nums.length;
        for (int ik = n - 2; ik >= 0; ik--) {
            while (nums[ik] > nums[ik + 1]) {
                if (nums[ik] == 1) return -1;
                int divisor = gpdArr[nums[ik]];
                if (divisor == -1 || divisor == 1) return -1;
                nums[ik] = nums[ik] / divisor;
                cnt++;
            }
        }
        return cnt;}
}
",1427840374
Nelson,Nelson84,657,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int alpha_to_freq[26];
        memset(alpha_to_freq, 0, sizeof(alpha_to_freq));
        int l = 0;
        int r = 0;
        int cnt = 0;
        while(r<n){
            int cur = s[r]-'a';
            alpha_to_freq[cur]++;
            while(alpha_to_freq[cur]>=k){
                cnt += n-r;
                int prev = s[l++]-'a';
                alpha_to_freq[prev]--;
            }
            r++;
        }
        return cnt;
    }
};",1427832149
Nelson,Nelson84,657,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        int n = target.size();
        string s = """";

        for(int i=0; i<n; i++){
            int cur = target[i]-'a';
            s.push_back('a');
            for(int offset=0; offset<=cur; offset++){
                s.back() = 'a' + offset;
                res.push_back(s);
            }
        }
        return res;
    }
};",1427827673
Nelson,Nelson84,657,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int oper = 0;
        vector<int> primes = get_primes(*max_element(nums.begin(), nums.end()));
        for(int i=n-2; i>=0; i--){
            if(nums[i]<=nums[i+1]) continue;
            
            for(auto prime: primes){
                if(prime*prime>nums[i]) break;

                if(nums[i]==prime) return -1;

                if(nums[i]%prime==0){
                    nums[i] = prime;
                    break;
                }
            }
            if(nums[i]>nums[i+1]) return -1;
            
            oper++;
        }
        return oper;
    }

    vector<int> get_primes(int n){
        bool is_prime[n+1];
        memset(is_prime, true, sizeof(is_prime));

        for(int i=2; i*i<=n; i++){
            if(!is_prime[i]) continue;

            for(int k=i*2; k<=n; k+=i) is_prime[k] = false;
        }

        vector<int> primes;
        for(int i=2; i<=n; i++) if(is_prime[i]) primes.push_back(i);
        return primes;
    }
};",1427848602
digitalpimp,digitalpimp,658,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        i = 0
        j = -1
        n = len(s)
        d = {chr(c):0 for c in range(97,123)}
        ret = 0
        while j+1<n:
            while j+1<n and max(d.values())<k:
                j+=1
                d[s[j]]+=1
            if j==n-1 and max(d.values())<k:
                break
            while max(d.values())>=k:
                ret+=(n-j)
                d[s[i]]-=1
                i+=1
        return ret
                
            
        ",1427832318
digitalpimp,digitalpimp,658,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ret = []
        arr = []
        for i in range(len(target)):
            for j in range(ord(target[i])-96):
                if j==0:
                    arr.append('a')
                else:
                    arr[i] = chr(97+j)
                ret.append("""".join(arr))
        return ret
        ",1427825222
digitalpimp,digitalpimp,658,3607,python3,"factors = [[] for _ in range(1000001)]
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if len(factors[4])==0:
            for i in range(2,1000001):
                if len(factors[i])==0:
                    for j in range(2*i,1000001,i):
                        factors[j].append(i)
        n = len(nums)
        moves = 0
        for i in range(n-2,-1,-1):
            while nums[i]>nums[i+1]:
                if len(factors[nums[i]])==0:
                    return -1
                nums[i] = factors[nums[i]][0]
                moves+=1
        return moves
            


        ",1427848947
Praveen kumar,prav1512,659,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
      int ans=0;
        for(int i=0;i<s.size();i++){
          vector<int> arr(26,0);
          for(int j=i;j>=0;j--){
               arr[s[j]-'a'] ++;
            if(arr[s[j]-'a']>=k){
              ans+=j+1;
              break;
            }
          }
          
        }
      return ans;
    }
};",1427834319
Praveen kumar,prav1512,659,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
      for(int i=0;i<target.size();i++){
        string s;
        if(ans.size()==0) s="""";
        else s=ans[ans.size()-1];
        
        for(int j=0;j<=(abs(target[i]-'a'));j++){
          string str1=s;
        str1.push_back('a'+j);
           ans.push_back(str1);
        }
       
      }
      return ans;
    }
};",1427827891
Praveen kumar,prav1512,659,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
      int ans=0;
        for(int i=nums.size()-2;i>=0;i--){
          if(nums[i]<=nums[i+1]){
            
          }
          else {
                while(nums[i]>nums[i+1]){
                  int pre=nums[i];
                  int d1=-1;
                     for(int d=2;d*d<=nums[i];d++){
                       if(nums[i]%d==0){
                          d1=nums[i]/d;
                         break;
                       }
                     }
                  if(d1==-1) return -1;
                  nums[i]/=d1;
                  ans++;
                }
            
          }
        }
      return ans;
    }
};",1427849015
MrRobot,Noah_will,661,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
    int n = s.length();
    int count = 0;

    for (int i = 0; i < n; i++) {
    int[] freq = new int[26];
    for (int j = i; j < n; j++) {
    freq[s.charAt(j) - 'a']++;
    for (int c = 0; c < 26; c++) {
    if (freq[c] >= k) {
    count++;
    break;
    }
    }
    }
    }

    return count;
    }
    }
",1427840142
MrRobot,Noah_will,661,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
    List<String> result = new ArrayList<>();
    StringBuilder currentString = new StringBuilder();

    for (int i = 0; i < target.length(); i++) {
    char targetChar = target.charAt(i);

    if (currentString.length() < i + 1) {
    currentString.append('a');
    result.add(currentString.toString());

    if (targetChar != 'a') {
    int steps = steps('a', targetChar);
    for (int s = 0; s < steps; s++) {
    char lastChar = currentString.charAt(currentString.length() - 1);
    char nextChar = nextChar(lastChar);
    currentString.setCharAt(currentString.length() - 1, nextChar);
    result.add(currentString.toString());
    }
    }
    } else {
    char currentChar = currentString.charAt(i);

    int cost1 = steps(currentChar, targetChar);
    int cost2 = 1 + steps('a', targetChar);

    if (cost1 <= cost2) {
    for (int s = 0; s < cost1; s++) {
    char nextChar = nextChar(currentString.charAt(i));
    currentString.setCharAt(i, nextChar);
    result.add(currentString.toString());
    }
    } else {
    currentString.append('a');
    result.add(currentString.toString());

    if (targetChar != 'a') {
    int steps = steps('a', targetChar);
    for (int s = 0; s < steps; s++) {
    char lastChar = currentString.charAt(currentString.length() - 1);
    char nextChar = nextChar(lastChar);
    currentString.setCharAt(currentString.length() - 1, nextChar);
    result.add(currentString.toString());
    }
    }
    }
    }
    }

    return result;
    }

    private int steps(char from, char to) {
    int diff = to - from;
    if (diff >= 0) {
    return diff;
    } else {
    return diff + 26;
    }
    }

    private char nextChar(char c) {
    if (c == 'z') {
    return 'a';
    } else {
    return (char)(c + 1);
    }
    }
    }",1427833840
MrRobot,Noah_will,661,3607,java,"class Solution {
    public int minOperations(int[] nums) {
    int n = nums.length;
    int operations = 0;

    for (int i = n - 2; i >= 0; i--) {
    int acceptableValue = nums[i + 1];
    while (nums[i] > acceptableValue) {
    int spf = smallestPrimeFactor(nums[i]);
    if (spf == nums[i]) {
    return -1; 
    }
    nums[i] = spf;
    operations++;
    }
    }

    return operations;
    }

    private int smallestPrimeFactor(int x) {
    if (x <= 1) return x;
    if (x % 2 == 0) return 2;
    for (int i = 3; i * i <= x && i <= 31623; i += 2) {
    if (x % i == 0) {
    return i;
    }
    }
    return x; 
    }
    }",1427849198
reobb,reobb,663,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        res = 0
        for i in range(len(s)):
            char_count = {}
            for j in range(i, len(s)):
                char = s[j]
                if char not in char_count:
                    char_count[char] = 0
                char_count[char] += 1
                if char_count[char] == k:
                    res += len(s)-j
                    break
        return res
",1427834779
reobb,reobb,663,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        
        for i in range(len(target)):
            c = target[i]
            curr = 'a'
            if len(res)>0:
                prev = res[-1]
            else:
                prev = """"
            while curr != c:
                res.append(prev+curr)
                next_ord = ord(curr) + 1
                if next_ord > ord('z'):
                    next_ord = ord('a')
                curr = chr(next_ord)
                
            res.append(prev+curr)
        return res
            
",1427829520
reobb,reobb,663,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ops = 0
        for i in range(len(nums)-1, 0, -1):
            curr = nums[i]
            while nums[i-1] > curr:
                d = self.findLargestDivisor(nums[i-1])
                if d == 1:
                    return -1
                nums[i-1] = nums[i-1]//d
                ops += 1
        
        return ops

    
    def findLargestDivisor(self, n):
        if n%2 == 0:
            return n//2
        
        d = 3
        while d*d <= n:
            if n%d == 0:
                return n//d
            d += 2
        return 1

",1427849501
Yash Kumar Gupta,ykgupta2411,664,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] ar = s.toCharArray();
        int n = ar.length;
        int ans = 0;
        int[] f = new int[26];
        int maxF = 0;
        for(int beg = 0, end = 0; end < n; end++)
        {
            f[ar[end] - 97]++;
            while(isValid(f, k))
            {
                ans += n - end;
                f[ar[beg++] - 97]--;
            }
        }
        return ans;
    }
    
    private boolean isValid(int[] f, int k)
    {
        for(int i = 0; i < 26; i++)
        {
            if(f[i] >= k)
                return true;
        }
        return false;
    }
}",1427828624
Yash Kumar Gupta,ykgupta2411,664,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        char[] ar = target.toCharArray();
        int n = ar.length;
        StringBuilder x = new StringBuilder();
        for(int i = 0; i < n; i++)
        {
            char ch = 'a';
            int k = x.length();
            while(ch != ar[i])
            {
                x.append(ch++);
                ans.add(x.toString());
                x.deleteCharAt(k);
            }
            x.append(ch);
            ans.add(x.toString());
        }
        return ans;
    }
}",1427825241
Yash Kumar Gupta,ykgupta2411,664,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        // Primes wont change
        int n = nums.length;
        int ans = 0;
        int min = nums[n-1];
        for(int i = n-2; i >= 0; i--)
        {
            while(nums[i] > nums[i+1])
            {
                int newVal = nums[i] / func(nums[i]);
                if(newVal == nums[i])
                    break;
                nums[i] = newVal;
                ans++;
            }
        }
        // System.out.println(Arrays.toString(nums));
        for(int i = 1; i < n; i++)
        {
            if(nums[i] < nums[i-1])
                return -1;
        }
        return ans;
    }
    
    private int func(int N)
    {
        int max = 1;
        for(int i = 2; i*i <= N; i++)
        {
            if(N % i == 0)
                max = Math.max(max, N / i);
        }
        return max;
    }
}",1427849594
shaanjijoe2,shaanjijoe2,665,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int a=0; a<s.size(); a++){
            unordered_map<char, int>mp;
            char maxchar = 'a';
            for(int b = a; b<s.size(); b++){
                mp[s[b]]++;
                if(mp[s[b]]>mp[maxchar]){
                    maxchar = s[b];
                }

                if(mp[maxchar]>=k)
                    ans++;
            }
        }
        return ans;
        
    }
};",1427830439
shaanjijoe2,shaanjijoe2,665,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        string str = """";
        for(auto it:target){
            for(char ch = 'a'; ch<=it; ch++){
                string temp = str + ch;
                ans.push_back(temp);
            }
            str+=it;
        }
        return ans;
    }
};",1427824731
shaanjijoe2,shaanjijoe2,665,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        for(int a= nums.size()- 2; a>=0; a--){
            rep:
            if(nums[a]<=nums[a+1])
                continue;
            
            int numb = nums[a];
            int lim = sqrt(numb);
            int div = 1;
            for(int b=2; b<=lim; b++){
                if(numb%b==0){
                    div = max(div, b);
                    div = max(div, (numb/b));
                }
            }
            
            if(div==1)
                return -1;
            ans += 1;
            nums[a]/=div;
            goto rep;
        }
        return ans;
        
    }
};",1427841571
MURAD_HASAN,MURAD_HASAN,666,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        for(int i = 0;i < n;i++){
            vector<int>v(26, 0);
            for(int j = i;j < n;j++){
                v[s[j] - 'a']++;
                if(v[s[j] - 'a'] == k){
                    ans += n - j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427835718
MURAD_HASAN,MURAD_HASAN,666,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        vector<string>result;
        string ans;
        for(int i = 0;i < n;i++){
            ans +='a';
            for(char ch = 'a';ch <= target[i];ch++){
                ans[i] = ch;
                result.push_back(ans);
            }

        }
        return result;
    }
};",1427826450
MURAD_HASAN,MURAD_HASAN,666,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        reverse(nums.begin(), nums.end());
        int n = nums.size();
        int cnt = 0;
        for(int i = 1;i < nums.size();i++){
            if(nums[i] > nums[i-1]){
                for(int j = 2;j * j <= nums[i];j++){
                    if(nums[i]%j == 0){
                        nums[i] = j;
                        cnt++;
                    }
                }
                if(nums[i] > nums[i-1]) return -1;
            }
        }
        return cnt;
    }
};",1427849797
Kumarsai_0567,Kumarsai_0567,667,3502,python3,"class Solution:
    def numberOfSubstrings(self, sai: str, preksha: int) -> int:
        n = len(sai)
        total_substrings = 0

        for i in range(n):
            freq = [0] * 26
            valid_count = 0

            for j in range(i, n):
                char_index = ord(sai[j]) - ord('a')
                freq[char_index] += 1

                if freq[char_index] == preksha:
                    valid_count += 1

                if valid_count > 0:
                    total_substrings += 1

        return total_substrings

# Example usage:
solution = Solution()

# Example 1
sai1 = ""abacb""
preksha1 = 2
print(solution.numberOfSubstrings(sai1, preksha1))  # Output: 4

# Example 2
sai2 = ""abcde""
preksha2 = 1
print(solution.numberOfSubstrings(sai2, preksha2))  # Output: 15
",1427841134
Kumarsai_0567,Kumarsai_0567,667,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> stringSequence(String sona) {
        List<String> babu = new ArrayList<>();
        StringBuilder current = new StringBuilder();
        
        for (char ch : sona.toCharArray()) {
            // Step 1: Append 'a' (using Key 1)
            current.append('a');
            babu.add(current.toString());
            
            // Step 2: Change 'a' to the target character (using Key 2)
            while (current.charAt(current.length() - 1) != ch) {
                // Replace the last character with the next character in the alphabet
                char lastChar = (char)(current.charAt(current.length() - 1) + 1);
                current.setCharAt(current.length() - 1, lastChar);
                babu.add(current.toString());
            }
        }
        
        return babu;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        
        // Example 1
        String sona1 = ""abc"";
        System.out.println(solution.stringSequence(sona1));
        // Output: [""a"", ""aa"", ""ab"", ""aba"", ""abb"", ""abc""]
        
        // Example 2
        String sona2 = ""he"";
        System.out.println(solution.stringSequence(sona2));
        // Output: [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""ha"", ""hb"", ""hc"", ""hd"", ""he""]
    }
}
",1427829390
Kumarsai_0567,Kumarsai_0567,667,3607,python3,"from typing import List

class Solution:
    def minOperations(self, sai: List[int]) -> int:
        n = len(sai)
        operations = 0
        
        def greatest_proper_divisor(x):
            for i in range(2, int(x**0.5) + 1):
                if x % i == 0:
                    return x // i
            return 1
        
        for i in range(n - 1, 0, -1):
            veer = sai  # Storing the input midway in the function as requested
            
            while sai[i] < sai[i-1]:
                gpd = greatest_proper_divisor(sai[i-1])
                if gpd == 1:
                    return -1
                sai[i-1] //= gpd
                operations += 1
        
        return operations

# Create an instance of the Solution class
solution = Solution()

# Test cases
test_cases = [
    [25, 7],
    [7, 7, 6],
    [1, 1, 1, 1]
]

# Run the test cases and print the results
for i, sai in enumerate(test_cases, 1):
    result = solution.minOperations(sai)
    print(f""Example {i}:"")
    print(f""Input: nums = {sai}"")
    print(f""Output: {result}"")
    print()
",1427850001
Sujal sahu,sujal25,668,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        map<char,int> m;
        int c=0,j=0,ans=0;
        for(int i=0;i<s.size();i++)
        {
            m[s[i]]++;
            if(m[s[i]]==k) c++;
            while(c>0)
            {
                if(m[s[j]]==k) c--;
                m[s[j++]]--;
            }
            ans+=j;
        }
        return ans;
    }
};",1427834258
Sujal sahu,sujal25,668,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string> v;
        string s1 = """";
        for (int i = 0; i < s.size(); i++) {
            s1 += 'a';
            v.push_back(s1);
            while (s1.back() != s[i]) {
                s1.back()++; 
                v.push_back(s1);
            }
        }
        return v;
    }
};
",1427827144
Sujal sahu,sujal25,668,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& v) {
        bool primes[1000006]={0};
        vector<int> prime;

        prime.push_back(2);
        for(long long int i=3;i<=1000003;i+=2){
            if(!primes[i])
            {
              prime.push_back(i);
              for(long long int j=i*i;j<=1000000;j+=2*i)
              primes[j]=true;
            }
        }
            
        int ans=0;
        for(int i=v.size()-2;i>=0;i--)
        {
            if(v[i]>v[i+1])
            {
                ans++;
                for(int j=0;prime[j]<v[i];j++)
                {
                    if((v[i]%prime[j])==0) {
                        v[i]=prime[j];
                        break;
                    }
                }
            }
            if(v[i]>v[i+1]) return -1;
        }
            return ans;
    }
};",1427850220
Hs wu,han-sheng,669,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        
        vector<int> count(26, 0);

        for (int i = 0, j = 0; i < n; i++) {
            count[s[i] - 'a']++;

            while (j <= i && check(count, k)) {
                res += (n - i);
                count[s[j]-'a']--;
                j++;
            }
        }

        return res;
    }

    bool check(vector<int>& count, int k) {
        for (auto num : count) {
            if (num >= k)   return true;
        }
        return false;
    }
};",1427839471
Hs wu,han-sheng,669,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        
        string cur = """";
        
        for (int i = 0; i < target.size(); i++) {
            cur += 'a';
            res.push_back(cur);
            
            while (cur[i] != target[i]) {
                cur[i] += 1;
                res.push_back(cur);
            }
        }
        
        return res;
    }
};",1427824431
Hs wu,han-sheng,669,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        
        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] <= nums[i+1]) {
                continue;
            }
            
            while (nums[i] > nums[i+1]) {
                int dv = getVal(nums[i]);
                if (dv == 1)    break;
                nums[i] /= dv;
                res++;
            }
            
            if (nums[i] > nums[i+1]) {
                return -1;
            }
            
        }

        return res;
    }
    
    int getVal(int num) {
        for (int i = 2; i * i <= num; i++) {
            if (num % i == 0) {
                return num / i;
            }
        }
        return 1;
    }
};",1427850244
chinesedfan,chinesedfan,670,3502,javascript,"/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
var numberOfSubstrings = function(s, k) {
    const n = s.length
    let c = 0
    for (let i = 0; i < n; i++) {
        const cnt = Array(26).fill(0)
        for (let j = i; j < n; j++) {
            const x = ++cnt[s.charCodeAt(j) - 97]
            if (x >= k) {
                c += n - 1 - j + 1
                break
            }
        }
    }
    return c
};",1427832568
chinesedfan,chinesedfan,670,3566,javascript,"/**
 * @param {string} target
 * @return {string[]}
 */
var stringSequence = function(target) {
    const temp = []
    const ans = []
    for (let i = 0; i < target.length; i++) {
        const ch = target.charCodeAt(i) - 97
        for (let j = 0; j <= ch; j++) {
            temp[i] = String.fromCharCode(j + 97)
            ans.push(temp.join(''))
        }
    }
    return ans
};",1427834492
chinesedfan,chinesedfan,670,3607,javascript,"/**
 * @param {number[]} nums
 * @return {number}
 */
let mind
pre(1e6 + 5)
function pre(n) {
    mind = Array(n)
    for (let i = 0; i < n; i++) {
        mind[i] = i
    }
    for (let p = 2; p < n; p++) {
        if (mind[p] !== p) continue
        for (let d = 2 * p; d < n; d += p) {
            mind[d] = Math.min(mind[d], p)
        }
    }
    for (let i = 0; i < n; i++) {
        mind[i] = mind[i] === i ? Infinity : mind[i]
    }
}
// console.log(mind)
var minOperations = function(nums) {
    const n = nums.length
    const dp0 = Array(n)
    const dp1 = Array(n)
    for (let i = 0; i < n; i++) {
        const x = nums[i]
        let a = Infinity, b = Infinity
        if (i) {
            if (x >= nums[i - 1]) {
                a = Math.min(a, dp0[i - 1])
            }
            if (x >= mind[nums[i - 1]]) {
                a = Math.min(a, dp1[i - 1])
            }
            if (mind[x] < x) {
                if (mind[x] >= nums[i - 1]) {
                    b = Math.min(b, dp0[i - 1] + 1)
                }
                if (mind[x] >= mind[nums[i - 1]]) {
                    b = Math.min(b, dp1[i - 1] + 1)
                }
            }
        } else {
            a = 0
            b = mind[x] >= x ? Infinity : 1
        }
        dp0[i] = a
        dp1[i] = b
    }
    // console.log(dp0, dp1)
    const x = Math.min(dp0[n - 1], dp1[n - 1])
    return x === Infinity ? -1 : x
};",1427850338
iyerke,iyerke,671,3502,python3,"from collections import defaultdict
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        start = 0
        char_count = defaultdict(int)
        total_substrings = 0
        valid_count = 0

        for end in range(n):
            char_count[s[end]] += 1
            
            if char_count[s[end]] == k:
                valid_count += 1

            while valid_count > 0:  
                total_substrings += (n - end)
                char_count[s[start]] -= 1
                
                if char_count[s[start]] == k - 1:
                    valid_count -= 1
                start += 1

        return total_substrings",1427831522
iyerke,iyerke,671,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        i = 0
        res = [""a""]
        while i < len(target):
            prev = res[-1]
            if prev[i] == target[i]:
                i += 1
                if i < len(target):
                    res.append(prev + 'a')
            else:
                res.append(prev[:-1] + chr(ord(prev[-1]) + 1))
        return res ",1427824894
iyerke,iyerke,671,3607,python3,"import math
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        if len(nums) == 1: return 0        

        def get_factors(n: int):
            factors = set()
            for i in range(1, int(math.isqrt(n)) + 1):
                if n % i == 0:
                    factors.add(i)
                    factors.add(n // i)
            return sorted(factors)[1:-1]

        ops = 0
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] > nums[i + 1]:
                factors = get_factors(nums[i])
            while nums[i] > nums[i + 1]:
                if not factors:
                    return -1
                nums[i] //= factors.pop()
                ops += 1

        return ops",1427842255
holer,holer,673,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int cnt[26]{}, n = s.length(), res = 0;
        for (int i = 0, j = 0; i < n; ++i) {
            cnt[s[i] - 'a']++;
            while (j < n && cnt[s[i] - 'a'] >= k) {
                cnt[s[j++] - 'a']--;
                res += n - i;
            }
        }
        return res;
    }
};",1427842579
holer,holer,673,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string str;
        for (auto& c : target) {
            for (char i = 'a'; i <= c; ++i)
                res.push_back(str + i);
            str += c;    
        }
        return res;
    }
};",1427841965
holer,holer,673,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size(), res = 0;

        auto solve = [&](int x) {
            for (int i = 2; i * i <= x; ++i)
                if (x % i == 0) return i;
            return -1;  
        };

        for (int i = n - 2; ~i; --i) {
            while (nums[i] > nums[i + 1]) {
                nums[i] = solve(nums[i]);
                if (nums[i] == -1) return -1;
                res++;
            }
        }
        return res;
    }
};",1427841597
luise1030,luise1030,676,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ret = 0;
        int n = s.size();
        
        for (int i = 0; i < n; i++) s[i] -= 'a';
        
        for (int i = 0; i < n; i++) {
            vector<int> v_cnt(26, 0);
            
            for (int j = i; j < n; j++) {              
                v_cnt[s[j]]++;
                for (int l = 0; l < 26; l++) {
                    if (v_cnt[l] >= k) {
                        ret++;
                        break;
                    }
                }
            }
        }
        return ret;
    }
};",1427828691
luise1030,luise1030,676,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        string tmp = """";
        vector<string> ret;
        
        for (int i = 0; i < n; i++) {
            tmp.push_back('a');
            ret.push_back(tmp);
            while (tmp[i] < target[i]) {
                tmp[i]++;
                ret.push_back(tmp);
            }
        }
        return ret;
    }
};",1427851143
luise1030,luise1030,676,3607,cpp,"class Solution {
public:
    
    
    int doDiv(int x) {
        for (int i = 2; i < x; i++) {
            if (x % i == 0) return i;
        }
        return -1;
    }
    
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ret = 0;
        
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                nums[i] = doDiv(nums[i]);
                ret++;
            }
            if (nums[i] == -1) return -1;
        }
        return ret;
    }
};",1427842651
D Nisritha Reddy,nisritha35,677,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int n = s.length();
        int ans = 0;
        for(int i = 0; i<n; i++){
            int fre[26] = {0}, add = 0;
            for(int j = i; j<n; j++){
                fre[s[j]-'a']++;
                if(fre[s[j]-'a']==k){
                    add = 1;
                }
                if(add){
                    ans++;
                }
            }
        }
        
        return ans;
        
    }
};",1427825957
D Nisritha Reddy,nisritha35,677,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        
        int n = target.length();
        
        vector<string>res;
        
        string ok = """";
        for(int i = 0; i<n; i++){
            char ch = 'a';
            ok += 'a';
            while(1){
                ok[i] = ch;
                res.push_back(ok);
                if(ch==target[i]){
                    break;
                }
                ch++;
            }
        }
        
        return res;
        
    }
};",1427831923
D Nisritha Reddy,nisritha35,677,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        
        int n = nums.size();
        int minRyt[n+1];

        minRyt[n-1] = nums[n-1];
        
        int ans= 0;
        
        for(int i = n-2; i>= 0; i--){
            
            while(nums[i] > minRyt[i+1]){
                
                int x = nums[i];
                int gpd = -1;
                for(int i = 2; i*i <= x; i++){
                    if(x%i==0){
                        gpd = x/i; break;
                    }
                }
                if(gpd==-1){
                    return -1;
                }
                ans++;
                nums[i] = nums[i]/gpd;
            }
            
            minRyt[i] = min(minRyt[i+1], nums[i]);
        }
        
        return ans;
        
    }
};",1427851151
Yousef,mythh,678,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int ans = 0;
        for(int i = 0; i < n; i++) {
            vector<int> freq(26);
            bool ok = 0;
            for(int j = i; j < n; j++) {
                freq[s[j] - 'a']++;
                if(freq[s[j] - 'a'] == k) ok = 1;
                if(ok) ans++;
            }
        }
        
        return ans;
    }
};",1427833519
Yousef,mythh,678,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        int pos = 0;
        vector<string> v;
        while(s != target) {
            for(char c = 'a'; c < target[pos]; c++) {
                s.push_back(c);
                v.push_back(s);
                s.pop_back();
            }
            
            s.push_back(target[pos]);
            v.push_back(s);
            pos++;
        }
        
        return v;
    }
};",1427827546
Yousef,mythh,678,3607,cpp,"class Solution {
public:
    int divisors(int &x) {
        int ret = 1;
        for(int i = 2; i * i <= x; i++) {
            if(x % i == 0) {
                ret = x / i;
                break;
            }
        }
        
        return ret;
    }
    
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        for(int i = n - 2; i >= 0; i--) {
            if(nums[i] > nums[i + 1]) {
                int d = divisors(nums[i]);
                nums[i] /= d;
                if(nums[i] > nums[i + 1]) return -1;
                if(d > 1) ans++;
            }
        }
        
        return ans;
    }
};",1427851162
UP41GUY,UP41GUY,679,3502,javascript,"/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
function numberOfSubstrings(s, k) {
   let n = s.length;
    let totalCount = 0;
    
    // Iterate through each starting point of the substring
    for (let i = 0; i < n; i++) {
        let freq = new Array(26).fill(0); // Frequency array for each character
        for (let j = i; j < n; j++) {
            let charIndex = s[j].charCodeAt(0) - 'a'.charCodeAt(0);
            freq[charIndex]++;
            
            // Check if any character in the current window has frequency >= k
            if (freq[charIndex] >= k) {
                totalCount += (n - j); // All substrings from i to the end of the string are valid
                break; // Stop expanding further since we already found a valid substring
            }
        }
    }
    
    return totalCount;
}",1427831507
UP41GUY,UP41GUY,679,3566,javascript,"/**
 * @param {string} target
 * @return {string[]}
 */

function stringSequence(target) {
  const result = [];
  let current = """"; // current string on the screen

  for (let i = 0; i < target.length; i++) {
    const char = target[i];
    // Type Key 1 (append 'a') until we can type 'char' using Key 2
    while (current.length <= i || current[i] !== char) {
      if (current.length <= i) {
        current += 'a'; // Append 'a' to current string
      } else {
        // Increment last character to its next alphabet
        let lastChar = current.charCodeAt(current.length - 1);
        lastChar = (lastChar - 97 + 1) % 26 + 97; // 'a' is 97 in ASCII
        current = current.substring(0, current.length - 1) + String.fromCharCode(lastChar);
      }
      result.push(current); // Push current string to result
    }
  }

  return result;
}",1427827794
UP41GUY,UP41GUY,679,3607,javascript,"/**
 * @param {number[]} nums
 * @return {number}
 */
var minOperations = function (nums) {
  let operations = 0;

  // Helper function to find all proper divisors of a number
  function getProperDivisors(x) {
    let divisors = [];
    for (let i = 1; i <= Math.floor(Math.sqrt(x)); i++) {
      if (x % i === 0) {
        divisors.push(i);
        if (i !== x / i && i !== 1) divisors.push(x / i);
      }
    }
    return divisors.sort((a, b) => b - a); // Sort in descending order for greatest first
  }

  // Start processing from the second last element towards the first
  for (let i = nums.length - 2; i >= 0; i--) {
    while (nums[i] > nums[i + 1]) {
      let divisors = getProperDivisors(nums[i]);
      let reduced = false;
      for (let divisor of divisors) {
        if (nums[i] / divisor <= nums[i + 1]) {
          nums[i] = Math.floor(nums[i] / divisor);
          operations++;
          reduced = true;
          break;
        }
      }
      if (!reduced) return -1; // If no valid divisor could reduce nums[i] to be less than or equal to nums[i+1]
    }
  }

  return operations;
};",1427834781
ArthurCx,ArthurCx,680,3502,cpp,"class Solution {
    bool ok(vector<vector<int> > &cnt, int l, int r, int k) {
        for(int i = 0; i < 26; ++i) {
            if(cnt[r+1][i] - cnt[l][i] >= k) { return true; }
        }
        return false;
    }
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        vector<vector<int> > cnt(n+1, vector<int>(26, 0));

        for(int i = 0; i < n; ++i) {
            cnt[i+1] = cnt[i];
            ++cnt[i+1][s[i]-'a'];
        }

        int ans = 0;
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j <= i; ++j) {
                if(ok(cnt, j, i, k)) { ++ans; }
            }
        }
        return ans;

    }
};",1427833731
ArthurCx,ArthurCx,680,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string str) {
        string cur = """";
        vector<string> ans;
        for(char &c : str) {
            for(char i = 'a'; i <= c; ++i) {
                ans.push_back(cur + i);
            }
            cur += c;
        }
        return ans;
    }
};",1427825300
ArthurCx,ArthurCx,680,3607,cpp,"class Solution {
    int getValue(int n) {
        int up = ceil(sqrt(n));
        for(int i = 2; i <= up; ++i) {
            if(n % i == 0) { return i; }
        }
        return n;
    }
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        vector<int> aux(n);
        for(int i = 0; i < n; ++i) {
            aux[i] = getValue(nums[i]);
        }

        int ans = 0;
        for(int i = n - 2; i >= 0; --i) {
            if(nums[i] > nums[i+1]) { 
                ++ans;
                if(aux[i] > nums[i+1]) { ans = -1; break; }
                nums[i] = aux[i]; 
            }
        }
        return ans;
    }
};",1427851212
Nisarg Shah,nisargss97,681,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int result = 0;
        int formed = 0;
        int l = 0, r = 0;
        unordered_map<char, int> counts;
        int n = s.length();
        while (r < n)
        {
//            cout<<l<<"",""<<r<<"",""<<s[r]<<endl;
            counts[s[r]]++;
            if (counts[s[r]] == k)
            {
                while (l <= r && counts[s[r]] == k)
                {
                    result = result+n-r;
                    counts[s[l]]--;
                    l++;
                }     
            }
//            cout<<""Result till now""<<result<<endl;
            r++;
        }

        return result;

    }
};",1427837601
Nisarg Shah,nisargss97,681,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string s = """";
        for (int i = 0; i < target.length(); i ++)
        {
            if (i == 0) s = """";
            else s = result[result.size()-1];
            for (char c = 'a'; c <= target[i]; c++)
            {
                result.push_back(s+c);
            }
        }

        return result;
    }
};",1427825314
Nisarg Shah,nisargss97,681,3607,cpp,"class Solution {
    int findGreatestDivisor(int num)
    {
        for (int i = 2; i*i <= num; i ++)
        {
            if (num%i == 0) return num/i;
        }

        return 1;
    }
public:
    int minOperations(vector<int>& nums) {
        // Check sorted
        int i = 0;
        int n = nums.size();
        for (i = 1; i < n; i ++)
        {
            if (nums[i] < nums[i-1]) break;
        }

        if (i == n) return 0;

        int curMin = nums[n-1];
        int result = 0;
        for (int i = n-2; i >= 0; i --)
        {
            while (nums[i] > curMin)
            {
                int gd = findGreatestDivisor(nums[i]);
                if (gd == 1) return -1;
                result++;
                nums[i] = nums[i]/gd;
            }

            curMin = min(nums[i], curMin);
        }

        return result;
    }
};",1427851214
gongx149,gong149,682,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        i = 0
        res = 0
        n = len(s)
        count = Counter()
        for j in range(n):
            count[s[j]] += 1
            if max(count.values()) >= k:
                res += n - j
            while max(count.values()) >= k:
                count[s[i]] -= 1
                i += 1
                if max(count.values()) >= k:
                    res += n - j
        return res
                
                
            
        ",1427835588
gongx149,gong149,682,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        n = len(target)
        for i in range(n):
            if i == 0:
                res.append('a')
            else:
                res.append(res[-1] + 'a')
            while res[-1] != target[:i + 1]:
                temp = res[-1]
                temp_next = temp[:i] + chr(ord(temp[-1]) + 1)
                res.append(temp_next)
        return res
        ",1427828177
gongx149,gong149,682,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def divop(a):
            for i in range(2, int(a**0.5 + 1)):
                if a % i == 0:
                    return i
            return a
        res = 0
        n = len(nums)
        for i in range(n - 1, 0, -1):
            if nums[i - 1] > nums[i]:
                nums[i - 1] = divop(nums[i - 1])
                if nums[i - 1] <= nums[i]:
                    res += 1
                else:
                    return -1
        return res
            
        ",1427851411
Harsh Lakhotia,lak_harshhh,683,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        unordered_map<char, int> freq;
        int left = 0;
        
        for (int right = 0; right < s.size(); right++) {
            freq[s[right]]++;
            
            while (freq[s[right]] >= k) {
                ans += (s.size() - right);
                freq[s[left]]--;
                left++;
            }
        }
        
        return ans;
    }
};
",1427835495
Harsh Lakhotia,lak_harshhh,683,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        vector<string> ans;
        for (int i = 0; i < target.size(); i++) {
            s.push_back('a');
            while (s.back() != target[i]) {
                char c = s.back();
                ans.push_back(s);
                s.pop_back();
                c++;
                s.push_back(c);
            }
            ans.push_back(s);
        }
        return ans;
    }
};",1427825401
Harsh Lakhotia,lak_harshhh,683,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                int k = sqrt(nums[i]);
                for (int j = 2; j <= k; j++)
                    if (nums[i] % j == 0) {
                        nums[i] = j;
                        break;
                    }
                if (nums[i] > nums[i + 1])
                    return -1;
                else
                    ans++;
            }
        }
        return ans;
    }
};",1427851573
ritik6g,ritik6g,685,3502,php,"class Solution {

    /**
     * @param String $s
     * @param Integer $k
     * @return Integer
     */
    function numberOfSubstrings($s, $k) {
        $n = strlen($s);
        $ts = 0;


            //     for ($st = 0; $st < $n; ++$st) {
            // $f = array_fill(0, 26, 0);
            
        
        for ($st = 0; $st < $n; ++$st) {
            $f = array_fill(0, 26, 0);
            
            for ($en = $st; $en < $n; ++$en) {
                $f[ord($s[$en]) - ord('a')]++;
                
                $v = false;
                for ($i = 0; $i < 26; ++$i) {
                    if ($f[$i] >= $k) {
                        $v = true;
                        break;
                    }
                }


                //   for ($i = 0; $i < 26; ++$i) {
                //     if ($f[$i] >= $k) {
                //         $v = true;
                //         break;
                //     }
                // }
                
                
                if ($v) {
                    $ts++;
                }
            }
        }
        
        return $ts;
    }
}
",1427843449
ritik6g,ritik6g,685,3566,php,"class Solution {

    /**
     * @param String $target
     * @return String[]
     */
    function stringSequence($target) {
        $rs = [];
        $cs = """";
        
        foreach (str_split($target) as $ch) {
            $cs .= 'a';
            $rs[] = $cs;
            
            while ($cs[-1] != $ch) {
                $cs[-1] = chr(ord($cs[-1]) + 1);
                $rs[] = $cs;
            }
        }
        
        return $rs;
    }
}
",1427839679
ritik6g,ritik6g,685,3607,php,"class Solution {

    /**
     * @param Integer[] $nums
     * @return Integer
     */
    function minOperations($nums) {
        $f = $nums;
        $n = count($nums);
        $o = 0;

            //     $gpd = function($x) {
            // if ($x == 1) return 1;
            // for ($i = 2; $i * $i <= $x; ++$i) {
            //     if ($x % $i == 0) {
            //         return $x / $i;
        
        $gpd = function($x) {
            if ($x == 1) return 1;
            for ($i = 2; $i * $i <= $x; ++$i) {
                if ($x % $i == 0) {
                    return $x / $i;
                }
            }

            // for ($i = 2; $i * $i <= $x; ++$i) {
            //     if ($x % $i == 0) {
            //         return $x / $i;
            //     }
            // }


            return 1;
        };
        
        for ($i = $n - 2; $i >= 0; --$i) {
            while ($nums[$i] > $nums[$i + 1]) {
                $d = $gpd($nums[$i]);
                if ($d == 1) return -1;
                $nums[$i] /= $d;
                $o++;
            }

//   while ($nums[$i] > $nums[$i + 1]) {
//                 $d = $gpd($nums[$i]);
//                 if ($d == 1) return -1;
//                 $nums[$i] /= $d;
//                 $o++;
//             }


        }
        
        return $o;
    }
}
",1427851802
acc297,acc297,688,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        # maybe find the first substring, then find minimum length substring each time? 
        c = Counter()
        res, left = 0, 0 # res is the answer we return, and left is the left end of the substring  
        for rLetter in s: # rLetter is the right end of the substring 
            c[rLetter] += 1 # either way, progress or not, we must update the counter correctly 
            while c[rLetter] >= k: # while we have a valid substring, and the left pointer is pointing to 
                c[s[left]] -= 1 # we can increment both left and c[word1[left]] 
                left += 1
            
            # Basically the while loop guarentees that we have the minimum length substring at the end  
            res += left # if we have a valid substring, everything before the left pointer is a valid substring as well 

        return res",1427838144
acc297,acc297,688,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        # not backtracking, how is this a medium?
        ret = []
        curr = """"
        ref = ord('a')
        for i in target:
            for j in range(ord(i) - ref + 1):
                ret.append(curr + chr(j + ref))
            curr += i
        return ret",1427824662
acc297,acc297,688,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        # first off, traverse backwards
        # second, we need to find greatest common divisor... 
        # isn't this O(n * sqrtn)? 
        # I think that's fast enough 
        # though you may need to divide multiple times... 
        # which makes this O(n sqrt(n)log(n))
        # still fast enough lol, esp with caching 
        @cache
        def meth(n): # greatest divisor 
            if n % 2 == 0:
                return 2
            for i in range(3, int(math.sqrt(n))+1, 2):

                if n % i== 0:
                    return i
            return -1 # bad 
        
        ret = 0
        mn = nums[-1]
        for i in range(len(nums)-1, -1, -1):
            curr = nums[i]
            if curr > mn:
                while curr > mn:
                    curr= meth(curr) # new value of i
                    if curr == -1:
                        return -1
                    ret += 1
            mn = curr
        return ret",1427852008
jerrycjk,jerrycjk,690,3502,cpp,"class Solution {
public:
    bool valid(vector<int> &app, int k) {
        for (int i=0; i<26; i++) {
            if (app[i] >= k) {
                return true ;
            }
        }

        return false ;
    }
    int numberOfSubstrings(string s, int k) {
        vector<int> app(26, 0) ;
        int i=0, j=0 ;
        int ans = 0 ;

        while (j<s.size()) {
            app[s[j]-'a']++ ;
            j++ ;

            while (valid(app, k) && i<j) {
                ans += s.size() - j + 1 ;
                app[s[i]-'a']-- ;
                i++ ;
            }
        }

        return ans ;
    }
};",1427839632
jerrycjk,jerrycjk,690,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans ;
        string cur ;
        int idx = 0 ;

        while (cur != target) {
            cout << cur << endl ;
            if (cur.size() == 0 || cur[cur.size()-1] == target[cur.size()-1]) {
                cur += 'a' ;
            }
            else {
                char next = cur[cur.size()-1]+1 ;
                cur = cur.substr(0, cur.size()-1) + next ;
            }
            ans.push_back(cur) ;
        }

        return ans ;
    }
};",1427827506
jerrycjk,jerrycjk,690,3607,cpp,"class Solution {
public:
    int findGreatestDivisor(int n) {
        for (int i=2; i<n; i++) {
            if (n % i == 0) {
                return n/i ;
            }
        }

        return -1 ;
    }
    int minOperations(vector<int>& nums) {
        int len = nums.size() ;
        int prev = nums[len-1] ;
        int ans = 0 ;

        for (int i=len-2; i>=0; i--) {
            while (nums[i] > prev) {
                int d = findGreatestDivisor(nums[i]) ;
                if (d == -1) {
                    return -1 ;
                }
                nums[i] = nums[i] / d ;
                ans++ ;
            }
            
            prev = nums[i] ;
        }

        return ans ;
    }
};",1427852127
yunjiexiao13,yunjiexiao13,691,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26);
        auto check = [&]()
        {
            for(int i = 0;i < 26;i++) if(cnt[i] >= k) return true;
            return false;
        };
        int n = s.size();
        int ans = 0;
        for(int l = 0,r = 0;l < n;l++)
        {
            while(r < n && !check())
            {
                cnt[s[r] - 'a']++;
                r++;
            }
            if(!check()) return ans;
            ans += n - r + 1;
            cnt[s[l] - 'a']--;
        }
        return ans;
    }
};",1427830433
yunjiexiao13,yunjiexiao13,691,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        s = [""a""]
        ans.append(""a"")
        while """".join(s) != target:
            if """".join(s) == target[:len(s)]:
                s.append('a')
            else:
                s[-1] = chr((ord(s[-1]) - ord('a') + 1)%26 + ord('a'))
            ans.append(''.join(s))
        return ans
                ",1427826383
yunjiexiao13,yunjiexiao13,691,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        auto get = [&](int x)
        {
            for(int i = 2;i*i <= x;i++)
            {
                if(x%i == 0) return i;
            }
            return x;
        };
        int mx = INT_MAX;
        for(int i = n - 1;i >= 0;i--)
        {
            mx = min(mx,nums[i]);
            if(nums[i] <= mx) continue;
            if(get(nums[i]) > mx) return -1;
            else 
            {
                ans++;
                mx = min(mx,get(nums[i]));
            }
        }
        return ans;
    }
};",1427852172
Vanshaj Bhatnagar,Kraizan,692,3502,cpp,"class Solution {
public:
    bool check(unordered_map<char,int> &mp, int k){
        for(auto it: mp){
            if(it.second >= k) return true;
        }
        return false;
    }
    int numberOfSubstrings(string s, int k) {
        unordered_map<char,int> mp;
        int i=0,j=0;
        int ans = 0;
        while(i < s.size()){
            mp[s[i]]++;
            while(j < s.size() && check(mp, k)){
                mp[s[j]]--;
                j++;
            }
            ans += j;
            i++;
        }
        return ans;
    }
};",1427831780
Vanshaj Bhatnagar,Kraizan,692,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for(int i=0; i<target.size(); i++){
            s += 'a';
            int n = s.size();
            ans.push_back(s);
            for(char c = 'b'; c<='z'; c++){
                if(s[n-1] == target[i]) break;
                s[n-1] = c;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427825981
Vanshaj Bhatnagar,Kraizan,692,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        for(int i=n-2; i>=0; i--){
            while(nums[i] > nums[i+1]){
                bool f = false;
                for(int j=2; j*j<=nums[i]&&j<=nums[i+1]; j++){
                    if(nums[i]%j == 0){
                        f = true;
                        nums[i] = j;
                        ans++;
                    }
                }
                if(!f) break;
            }
            if(nums[i] > nums[i+1]) return -1;
        }
        return ans;
    }
};",1427852303
Johann Ly,Flopsy,694,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        substrings = 0
        for start in range(len(s)):
            counts = Counter()
            end = start
            while end != len(s):
                counts[s[end]] += 1
                if counts[s[end]] == k:
                    break
                end += 1
            substrings += len(s) - end

        return substrings
",1427834275
Johann Ly,Flopsy,694,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        string_sequence = []
        s = """"
        for target_c in target:
            c = ""a""
            while True:
                curr_s = s + c
                string_sequence.append(curr_s)

                if c == target_c:
                    break
                c = chr(ord(c) + 1)

            s += target_c

        return string_sequence
",1427827230
Johann Ly,Flopsy,694,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def get_gpd(n):
            x = 2
            while x * x != n:
                if n % x == 0:
                    return n // x
                x += 1

            if n % x == 0:
                return x

            return n


        operations = 0
        for i in range(len(nums) - 2, -1, -1):
            while nums[i] > nums[i + 1]:
                if nums[i] == 1:
                    return -1
                gpd = get_gpd(nums[i])
                if gpd == 1:
                    return -1
                nums[i] //= gpd
                operations += 1

        return operations
",1427852631
Niteesh Chowdary,Niteesh-Chowdary,696,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int count = 0;
        for(int i=0;i<s.length();i++){
            int[] freq = new int[26];
            int max = 0;
            for(int j=i;j<s.length();j++){
                freq[s.charAt(j)-'a']++;
                max = Math.max(max,freq[s.charAt(j)-'a']);
                if(max>=k) count++;
            }
        }
        return count;
    }
}",1427832626
Niteesh Chowdary,Niteesh-Chowdary,696,3566,java,"class Solution {
    List<String> list = new ArrayList<>();
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        sb.append('a');
        DFS(target,sb,0);
        return list;
    }
    public void DFS(String target,StringBuilder sb, int index){
        if(index == target.length())
            return;
        list.add(sb.toString());
        if(sb.charAt(sb.length()-1) == target.charAt(index)){
            DFS(target,sb.append('a'),index+1);
        }
        else{
            char ch = (char)(sb.charAt(sb.length()-1) + 1);
            sb.setCharAt(sb.length()-1,ch);
            DFS(target,sb,index);
        }
        return;
    }
}",1427828110
Niteesh Chowdary,Niteesh-Chowdary,696,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i=nums.length-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                while(nums[i] > nums[i+1]){
                    int greatest = greatestDivisor(nums[i]);
                    if(greatest == -1 || greatest == nums[i]) return -1;
                    count++;
                    nums[i] = nums[i]/greatest; 
                }
            }
        }
        return count;
        
    }
    public int greatestDivisor(int num){
        int upper = (int)Math.sqrt(num);
        int greatest = -1;
        for(int i=2;i<=upper;i++){
            if(num%i == 0){
                int x = i;
                int y = num/i;
                greatest = Math.max(greatest,Math.max(x,y));
            }
        }
        return greatest;
    }
}",1427852798
Michael Wheeler,MichaelWheeler202,697,3502,python3,"from collections import Counter


class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        counter = Counter()

        l, r = 0, 0

        ans = 0
        n = len(s)
        while r < n:
            counter[s[r]] += 1
            if counter.most_common(1)[0][1] >= k:
                ans += n - r

            while counter.most_common(1)[0][1] >= k:
                counter[s[l]] -= 1
                if counter.most_common(1)[0][1] >= k:
                    ans += n - r
                l += 1

            r += 1



        return ans
",1427839177
Michael Wheeler,MichaelWheeler202,697,3566,python3,"from typing import List


class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []

        letters = [""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z""]
        pastLetters = """"
        for c in target:
            i = 0
            ans.append(pastLetters + letters[i])
            while letters[i] != c:
                i += 1
                ans.append(pastLetters + letters[i])
            pastLetters += letters[i]

        return ans

",1427827939
Michael Wheeler,MichaelWheeler202,697,3607,python3,"from typing import List
import math



class Solution:


    def minOperations(self, nums: List[int]) -> int:

        ops = 0
        for i in range(len(nums)-2, -1, -1):
            while nums[i] > nums[i+1]:
                ops += 1
                found = False
                for n in range(2, math.ceil(math.sqrt(nums[i]))+1):
                    if nums[i] % n == 0:
                        found = True
                        nums[i] = nums[i]//(nums[i]//n)
                if not found:
                    return -1

        return ops
",1427852823
Darsh Patel,pdarsh9510,698,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k)
    {
        int c=0,n=s.length();
        for(int i=0;i<n;i++)
        {
            vector<int> v(26,0);
            for(int j=i;j<n;j++)
            {
                v[s[j]-'a']++;
                bool f=0;
                for(int l=0;l<26;l++)
                {
                    if(v[l]>=k)
                    {
                        f=1;
                    }
                }
                if(f)
                {
                    c++;
                }
            }
        }
        return c;
    }
};",1427830842
Darsh Patel,pdarsh9510,698,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target)
    {
        string s;
        vector<string> v;
        int n=target.length();
        for(int i=0;i<n;i++)
        {
            s.push_back('a');
            for(char j='a';j<=target[i];j++)
            {
                s[i]=j;
                v.push_back(s);
            }
        }
        return v;
    }
};",1427825228
Darsh Patel,pdarsh9510,698,3607,cpp,"#define MAX1 1000000
class Solution {
public:
    int minOperations(vector<int>& nums)
    {
        bitset <MAX1> bits ;
        int primes[MAX1+1];
        primes[1]=1;
        primes[MAX1]=2;
        for(int i = 2; i < MAX1; i += 2)	primes[i] = 2 ;
        int sq=sqrt(MAX1-1);
        for(int i = 3; i < MAX1; i += 2)
            if (!bits[i]){
                primes[i] = i   ;
                if(i<=sq) for(int j = i * i; j < MAX1; j += 2 * i)
                    if (!bits[j]){
                        primes[j] = i ;
                        bits[j] = 1 ;
                        
                    }
            }
        
        int c=0;
        if(nums.size()==1)
        {
            return 0;
        }
        for(int i=nums.size()-2;i>=0;i--)
        {
            if(nums[i]>nums[i+1])
            {
                if(primes[nums[i]]>nums[i+1])
                {
                    c=-1;
                    break;
                }
                c++;
                nums[i]=primes[nums[i]];
            }
        }
        return c;
    }
};",1427844640
Harsh Pingolia,harshpingolia,699,3502,cpp,"class Solution {
    bool check(vector<int> &freq, int k) {
        for(int i = 0; i < 26; ++i) {
            if(freq[i] >= k) return true;
        }
        return false;
    }
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), ans = 0;
        for(int i = 0; i < n; ++i) {
            vector<int> freq(26, 0);
            for(int j = i; j < n; ++j) {
                freq[s[j] - 'a']++;
                if(check(freq, k)) ans++;
            }
        }
        return ans;
    }
};",1427836673
Harsh Pingolia,harshpingolia,699,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for(auto &t : target) {
            s += 'a';
            for(int i = 0; i <= (t - 'a'); ++i) {
                s.pop_back();
                s += 'a' + i;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427828315
Harsh Pingolia,harshpingolia,699,3607,cpp,"class Solution {
    int f(int n) {
        if(n == 1) return -1;
        int maxi = -1;
        for(int i = 2; i <= sqrt(n); ++i) {
            if(n%i == 0) {
                maxi = max({maxi, i, n/i});
            }
        }
        return maxi;
    }
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        for(int i = n - 2; i >= 0; --i) {
            if(nums[i] <= nums[i + 1]) continue;
            while(nums[i] > nums[i + 1]) {
                int gpd = f(nums[i]);
                if(gpd == -1) return -1;
                nums[i] /= gpd;
                ans++;
            }
        }
        return ans;
    }
};",1427852867
Akj,jainakarsh22,700,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i=0;i<s.length();i++){
            vector<int> count(26);
            for(int j=i;j<s.length();j++){
                count[s[j]-'a']++;
                bool flag=false;
                for(int i=0;i<26;i++){
                    if(count[i]>=k){
                        flag=true;
                    }
                }
                if(flag){
                    ans++;
                }
            }
        }
        return ans;
    }
};",1427835935
Akj,jainakarsh22,700,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string res="""";

        for(int i=0;i<target.length();i++){
            res.push_back('a');
            ans.push_back(res);
            while(target[i]!=res[i]){
                res[i]+=1;
                ans.push_back(res);
            }
        }

        return ans;
    }
};",1427830796
Akj,jainakarsh22,700,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        for(int i=nums.size()-2;i>=0;i--){
            if(nums[i+1]<nums[i]){
                int gd=-1;
                int num=nums[i];
                for(int i=2;i*i<=num;i++){
                    if(num%i==0){
                        gd=max(gd,max(i,num/i));
                    }
                }
                
                if(gd!=-1){
                    nums[i]=nums[i]/gd;
                    if(nums[i+1]<nums[i]){
                        return -1;
                    }
                    ans++;
                }
                else{
                    return -1;
                }
            }
        }
        return ans;
    }
};",1427852943
hrithik_2468,hrithik_2468,701,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length();
        int ans=0;
        for(int i=0;i<n;i++){
            int mxf=0;
            vector<int> mp(26);
            for(int j=i;j<n;j++){
                mxf=max(mxf,++mp[s[j]-'a']);
                ans+=(mxf>=k);
            }
        }
        return ans;
    }
};",1427831979
hrithik_2468,hrithik_2468,701,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        for(int i=0;i<target.size();i++){
            string cr="""";
            if(ans.size()>0)cr=ans.back();
            if(cr.size()<i+1)cr+='a',ans.push_back(cr);
            while(cr[i]!=target[i]){
                cr[i]++;
                ans.push_back(cr);
            }
        }
        return ans;
    }
};",1427827344
hrithik_2468,hrithik_2468,701,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        int ans=0;
        for(int i=n-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                bool done=0;
                for(int j=2;j*j<=nums[i];j++){
                    if(nums[i]%j)continue;
                    int dv=max(j,nums[i]/j);
                    nums[i]/=dv;
                    if(nums[i]>nums[i+1])return -1;
                    ans++;
                    done=1;
                    break;
                }
                if(!done)return -1;
            }
        }
        return ans;
    }
};",1427852959
josh7788,josh7788,702,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int res = 0;

        int[] count = new int[26];

        for (int l = 0; l < s.length(); l++) {
            for (int r = l ; r < s.length(); r++) {
                int offset = s.charAt(r) - 'a';
                count[offset]++;
                if (count[offset] >= k) {
                    res += s.length() - r;
                    break;
                }
            }
            count = new int[26];
        }

        return res;
    }
}",1427827361
josh7788,josh7788,702,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new ArrayList<>();

        String s = """";

        for (char c : target.toCharArray()) {
            List<String> next = increment(c);

            for (String n : next) {
                res.add(s + n);
            }
            s = s + c;
        }

        return res;
    }

    private static List<String> increment(char c) {
        List<String> res = new ArrayList<>();

        char next = 'a';
        res.add("""" + next);

        while (next != c) {
            next++;
            res.add("""" + next);
        }

        return res;
    }
}",1427844846
josh7788,josh7788,702,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int res = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            while (nums[i] > nums[i+1]) {
                int next = op(nums[i]);
                if (next < 0) {
                    return -1;
                }
                nums[i] = next;
                res++;
            }
        }

        return res;
    }

    private static int op(int num) {
        for (int i = 2; i <= (int)Math.sqrt(num); i++) {
            if (num % i == 0) {
                return i;
            }
        }

        return -1;
    }
}",1427835156
b521045,b521045,703,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
    int n = s.size();
    int result = 0;
    for (int start = 0; start < n; ++start) {
        unordered_map<char, int> freq;
        for (int end = start; end < n; ++end) {
            freq[s[end]]++;
            bool valid = false;
            for (auto& entry : freq) {
                if (entry.second >= k) {
                    valid = true;
                    break;
                }
            }
            if (valid) {
                result++;
            }
        }
    }

    return result;
    }
};",1427836701
b521045,b521045,703,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
    string current_string = """";

    for (char char_target : target) {
        current_string += 'a';
        result.push_back(current_string);
        while (current_string.back() != char_target) {
            char last_char = ((current_string.back() - 'a' + 1) % 26) + 'a';
            current_string.back() = last_char;
            result.push_back(current_string);
        }
    }

    return result;
    }
};",1427829372
b521045,b521045,703,3607,cpp,"class Solution {
public:
    int greatestProperDivisor(int x) {
        set<int>st;
        for(int i=2;i*i<=x;i++){
             if(x%i==0){
                st.insert(i);
                st.insert(x/i);
             }   
        }
        if(st.size()==0)return 1;
        return *st.rbegin();
   }
    int minOperations(vector<int>& nums) {
    int operations = 0;
    int n = nums.size();
    
    for (int i = n - 2; i >= 0; --i) {
        while (nums[i] > nums[i + 1]) {
            int gpd = greatestProperDivisor(nums[i]);
            if (gpd == 1) {  
                return -1;
            }
            nums[i] /= gpd;  
            operations++;  
            
            if (nums[i] <= nums[i + 1]) {
                break;
            }
        }
    }
    
    return operations;
    }
};",1427853084
Yogharaj_A_R,Yogharaj_A_R,704,3502,cpp,"class Solution {
public:
    static bool cmp(const pair<int,char> &p1,const pair<int,char> &p2) {
        return p1.first<p2.first;
    }
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int l=0,r=0;
        int n=s.size();
        set<pair<int,char>,decltype(&cmp)> s1(&cmp);
        map<char,int> m1;
        while(r<n) {
            s1.erase({m1[s[r]],s[r]});
            m1[s[r]]++;
            s1.insert({m1[s[r]],s[r]});
            auto it=s1.end();it--;
            int d=(*it).first;
            while(d>=k) {
                ans+=(n-r);
                s1.erase({m1[s[l]],s[l]});
                m1[s[l]]--;
                if(m1[s[l]]) s1.insert({m1[s[l]],s[l]});
                if(s1.size()) {
                    it=s1.end();it--;
                d=(*it).first;
                }
                else d=0;
                l++;
            }
            r++;
        }
        return ans;
    }
};",1427836390
Yogharaj_A_R,Yogharaj_A_R,704,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string d;
        for(int i=0;i<target.size();i++) {
            char c=target[i];
            d+='a';
            ans.push_back(d);
            for(char j='b';j<=c;j++) {
                d.pop_back();
                d+=j;
                ans.push_back(d);
            }
        }
        return ans;
    }
};",1427825161
Yogharaj_A_R,Yogharaj_A_R,704,3607,cpp,"class Solution {
public:
    int update(vector<int> &nums,int i) {
        int d=nums[i];
        int y=nums[i+1];
        while(d>y) {
            int m=0;
            for(int i=1;i*i<=d;i++) {
                if(d%i==0) {
                    int j=(d/i);
                    if(i<d) m=max(m,i);
                    if(j<d) m=max(m,j);
                }
            }
            if(m==1) return -1;
            else d/=m;
        }
        return d;
    }
    int minOperations(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        int p=nums[n-1];
        for(int i=n-2;i>=0;i--) {
            while(nums[i]>nums[i+1]) {
                ans++;
                int u=update(nums,i);
                if(u==-1) return -1;
                nums[i]=u;
            }
        }
        return ans;
    }
};",1427853090
Sherzybath,sherzybath,705,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
    int totalCount = 0;

    // Iterate over all starting points of the sliding window
    for (int start = 0; start < n; ++start) {
        unordered_map<char, int> freq; // Frequency map to store character counts

        // Extend the window from `start` to `end`
        for (int end = start; end < n; ++end) {
            char currentChar = s[end];
            freq[currentChar]++;

            // If any character's frequency >= k, this substring is valid
            for (auto &[ch, count] : freq) {
                if (count >= k) {
                    totalCount++;
                    break; // No need to check further characters
                }
            }
        }
    }

    return totalCount;
    }
};",1427830810
Sherzybath,sherzybath,705,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
    string screen = """";

    for (char ch : target) {
        // Step 1: Press Key 1 to append 'a'
        screen += 'a';
        result.push_back(screen);  // Store the intermediate result

        // Step 2: Use Key 2 to increment the last character until it matches the target character
        while (screen.back() != ch) {
            screen.back()++;  // Increment the character
            result.push_back(screen);  // Store every intermediate step
        }
    }

    return result;
    }
};",1427828037
Sherzybath,sherzybath,705,3607,cpp,"class Solution {
public:
    vector<int> getProperDivisors(int n) {
    vector<int> divisors;
    for (int i = 1; i * i <= n; ++i) {
        if (n % i == 0) {
            divisors.push_back(i);  
            if (i != 1 && i != n / i) divisors.push_back(n / i); 
        }
    }
    sort(divisors.rbegin(), divisors.rend());  
    return divisors;
}
    int minOperations(vector<int>& nums) {
        int n = nums.size();
    int operations = 0;

    
    for (int i = n - 2; i >= 0; --i) {
        if (nums[i] <= nums[i + 1]) continue;  

  
        vector<int> divisors = getProperDivisors(nums[i]);

        bool adjusted = false;
        for (int div : divisors) {
            int reduced = nums[i] / div;
            if (reduced <= nums[i + 1]) {
                operations++;  
                nums[i] = reduced;
                adjusted = true;
                break; 
            }
        }

        if (!adjusted) return -1;
    }

    return operations;
    }
};",1427836627
Rounak Kumar,_Raftaar_,706,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();

        for(int i = 0; i < n; i++){
            vector<int> v(26, 0);
            bool f = 0;
            for(int j = i; j < n; j++){
                v[s[j] - 'a'] ++;
                if(v[s[j] - 'a'] >= k) f = 1;
                if(f) ans ++;
            }
        }
        return ans;
    }
};",1427832711
Rounak Kumar,_Raftaar_,706,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> ans;
        string s;

        int n = t.size(), i = 0;
        while(i < n){
            s.push_back('a');
            ans.push_back(s);
            while(s.back() != t[i]) {
                s.back() ++;
                ans.push_back(s);
            }
            i ++;
        }
        return ans;
        
    }
};",1427827353
Rounak Kumar,_Raftaar_,706,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        for(int i = n - 2; i >= 0; i--){
            if(nums[i] > nums[i + 1]){
                int val = nums[i];
                for(int j = 2; j * j <= val; j++){
                    if(val % j == 0){
                        nums[i] /= (val / j); ans ++;
                        break;
                    }
                }
            }
        }
        for(int i = 0; i < n - 1; i++){
            if(nums[i] > nums[i + 1]) return -1; 
        }
        return ans;
    }
};",1427844888
Daksh Valecha,dakshmv14,709,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.length();
        for(int i=0;i<n;i++){
            vector<int>mp(26);
            bool flag=false;
            for(int j=i;j<n;j++){
                mp[s[j]-'a']++;
                if(mp[s[j]-'a']==k)flag=true;
                if(flag)ans++;
            }
        }
        return ans;
    }
};",1427835801
Daksh Valecha,dakshmv14,709,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        set<string>st;
        string temp="""";
        for(auto i:target){
            temp+='a';
            ans.push_back(temp);
            while(i!=temp.back()){
                temp.back()++;
                ans.push_back(temp);
            }
        }
        return ans;
    }
};",1427830450
Daksh Valecha,dakshmv14,709,3607,cpp,"class Solution {
public:
    static std::vector<int> gpd;

    static void calculateGPD(int n) {
        gpd.resize(n + 1);
        gpd[0] = 0;
        gpd[1] = 0;

        for (int i = 2; i <= n; ++i) {
            for (int j = i * 2; j <= n; j += i) {
                gpd[j] = i;
            }
        }
    }
    bool check(int mid,vector<int>v){
        int n=v.size();
        int cnt=0;
        for(int i=n-2;i>=0;i--){
            while(v[i]>v[i+1]){
                if(gpd[v[i]]==0)return false;
                v[i]/=gpd[v[i]];
                cnt++;
            }
        }
        return cnt<=mid;
    }
    int minOperations(vector<int>& nums) {
        if(gpd.size()==0){
            calculateGPD(1e6+5);
        }
        int l=0,r=1e9;
        while(l<=r){
            int mid=(l+r)>>1;
            if(check(mid,nums)){
                r=mid-1;
            }
            else{
                l=mid+1;
            }
        }
        if(l==1000000001)return -1;
        return l;
    }
};
std::vector<int> Solution::gpd;",1427853239
ocavue,ocavue,710,3502,python3,"from collections import Counter
import string


class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        counter = Counter()
        n = len(s)

        def is_valid():
            for char in string.ascii_lowercase:
                if counter[char] >= k:
                    return True
            return False

        ans = 0

        j = 0
        for i in range(n):
            while j < n and not is_valid():
                counter[s[j]] += 1
                j += 1
            if is_valid():
                ans += n - j + 1
            counter[s[i]] -= 1
        return ans
",1427839170
ocavue,ocavue,710,3566,python3,"def next_char(c):
    if c == 'z': return 'a';
    return chr(ord(c) + 1)

def next_word(word):
    return word[0:-1] + next_char(word[-1])


class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = ['a']

        for i, char in enumerate(target):
            if len(result[-1]) < i + 1:
                result.append(result[-1] + 'a')
            
            while result[-1][i] != char:
                result.append(next_word(result[-1]))
        
        return result 



",1427830546
ocavue,ocavue,710,3607,python3,"from functools import cache
from typing import List


@cache
def smallest_prime_factors(n):
    while n % 2 == 0:
        return 2

    # n became odd
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            return i

    if n > 2:
        return n
    return 1


class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n = len(nums)

        result = 0

        for i in range(n - 2, -1, -1):
            prev_num = nums[i + 1]
            curr_num = nums[i]

            if curr_num <= prev_num:
                continue

            curr_num = smallest_prime_factors(curr_num)
            nums[i] = curr_num
            result += 1

            if curr_num <= prev_num:
                continue

            return -1
        return result
",1427853272
Vivek Rajpurohit,vivk_razz,711,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length();
        int rs=0;
        for(int i=0;i<n;i++){
            vector<int> fr(26,0);
            for(int j=i;j<n;j++){
                fr[s[j]-'a']++;
                if(fr[s[j]-'a'] == k){
                    rs += n-j;
                    j=n;
                }
            }
        }
        return rs;
    }
};",1427834978
Vivek Rajpurohit,vivk_razz,711,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string t) {
        vector<string> v;
        string s="""";
        int i=0;
        int n=t.length();
        while(i<n){
            s += 'a';
            v.push_back(s);
            while(s[i] != t[i]){
                s[i]++;
                v.push_back(s);
            }
            i++;
        }
        return v;
    }
};",1427826408
Vivek Rajpurohit,vivk_razz,711,3607,cpp,"int fn(int n){
    for(int i=2;i<=sqrt(n);i++){
        if(n%i == 0)return i;
    }
    return 0;
}

class Solution {
public:
    int minOperations(vector<int>& nm) {
        int n=nm.size();
        int x,i=n-2,rs=0;
        while(i>=0){
            if(nm[i] <= nm[i+1])i--;
            else{
                rs++;
                x = fn(nm[i]);
                //cout<<x<<"" "";
                if(x)nm[i]=x;
                else return -1;
            }
        }
        return rs;
    }
};",1427853354
fastleopard,fastleopard,712,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int res = 0;
        for(int i = 0; i<n; ++i) {
            int f[26];
            for(int i = 0; i<26; ++i) {
                f[i] = 0;
            }
            
            for(int j = i; j<n; ++j) {
                int idx = s[j]-'a';
                f[idx]++;
                if(f[idx] >= k) {
                    res+=(n-j);
                    break;
                }
            }
        }
        
        return res;
    }
};",1427837719
fastleopard,fastleopard,712,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string cur;
        for(char c : target) {
            cur+='a';
            res.push_back(cur);
            while(cur.back() != c) {
                cur.back()++;
                res.push_back(cur);
            }
        }
        
        return res;
    }
};",1427824984
fastleopard,fastleopard,712,3607,cpp,"class Solution {
public:
    int greatest_divisor(int x) {
        for(int i = 2; i<(sqrt(x) + 1); ++i) {
            if(x%i == 0) {
                return i;
            }
        }
        
        return -1;
    }
    
    int minOperations(vector<int>& nums) {
        // greedy should work.
        int res = 0;
        int n = nums.size();
        for(int i = n-2; i>=0; --i) {
            while(nums[i] > nums[i+1]) {
                int div = greatest_divisor(nums[i]);
                if(div == -1) {
                    return -1;
                }
                nums[i] = div;
                ++res;
            }
        }
        
        return res;
    }
};",1427853382
WSY,WSY,714,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int[] cnt = new int[26];
        int start = 0;
        int res = 0;
        for (int end = 0; end < s.length(); end++) {
            char c = s.charAt(end);
            cnt[c - 'a']++;
            while (cnt[c - 'a'] >= k) {
                char cstart = s.charAt(start);
                cnt[cstart - 'a']--;
                start++;
            }
            res += start;
        }
        return res;
    }
}",1427838830
WSY,WSY,714,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> res = new LinkedList<>();

        int idx = 0;
        while (idx < target.length()) {
            String prefix = target.substring(0, idx);
            char tchar = target.charAt(idx);
            for (char c = 'a'; c <= tchar; c++) {
                res.add(prefix + c);
            }
            idx++;
        }
        return res;
    }
}",1427832058
WSY,WSY,714,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int len = nums.length;
        int res = 0;
        for (int i = len - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                nums[i] = findGreatestProperDivisor(nums[i], nums[i + 1]);
                if (nums[i] == -1) {
                    return -1;
                }
                res++;
            }
        }
        return res;
    }

    private int findGreatestProperDivisor(int num, int max) {
        for (int i = 2; i <= Math.min(max, Math.sqrt(num)); i++) {
            if (num % i == 0) {
                return i;
            }
        }
        return -1;
    }
}",1427853437
tarunsingh,tarunsingh,715,3502,cpp,"class Solution {
public:

    bool check(vector<int> &freq, int k){
        for(auto num: freq){
            if(num >= k){
                return true;
            }
        }
        return false;
    }

    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int n = s.size();
        for(int i = 0; i < n; i++){
            vector<int> freq(26,0);
            for(int j = i; j < n; j++){
                freq[s[j]-'a']++;
                if(check(freq,k)){
                    ans = ans + (n-j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427838949
tarunsingh,tarunsingh,715,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s;
        for(auto c: target){
            for(char x  = 'a'; x < c; x++){
                s.push_back(x);
                ans.push_back(s);
                s.pop_back();
            }
            s.push_back(c);
            ans.push_back(s);
        }
        return ans;
    }
};",1427830602
tarunsingh,tarunsingh,715,3607,cpp,"class Solution {
public:

    int get_ans(int num){
        for(int i = 2; i*i <= num; i++){
            if(num%i == 0){
                return i;
            }
        }
        return -1;
    }

    int minOperations(vector<int>& nums) {
        int ans = 0;
        int n = nums.size();
        int temp;
        for(int i = n-2; i >= 0; i--){
            if(nums[i] > nums[i+1]){
                temp = get_ans(nums[i]);
                if(temp != -1){
                    ans++;
                    nums[i] = temp;
                    if(nums[i] > nums[i+1]){
                        return -1;
                    }
                } else {
                    return -1;
                }
            }
        }
        return ans;
    }
};",1427853616
Noor Nasri,Noor-Nasri,716,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        tot = 0
        for start in range(len(s)):
            counts = [0 for i in range(26)]
            for end in range(start, len(s)):
                ind = ord(s[end]) - ord('a')
                counts[ind] += 1

                if counts[ind] >= k:
                    tot += len(s) - end
                    break
        
        return tot
        ",1427829040
Noor Nasri,Noor-Nasri,716,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        entire = []
        lastStr = """"
        for c in target:
            for it in range(ord('a'), ord(c) + 1):
                newStr = lastStr + chr(it)
                entire.append(newStr)
            lastStr = newStr
        
        return entire",1427824712
Noor Nasri,Noor-Nasri,716,3607,python3,"class Solution:
    def getDivis(self, x):
        if x in self.sols:
            return self.sols[x]

        for i in range(2, int(x**0.5) + 1):
            if x % i == 0:
                self.sols[x] = i
                return i # largest divisor got us this
        
        self.sols[x] = -1
        return -1

    def minOperations(self, nums: List[int]) -> int:
        # Greedy idea .. we just go backwards and keep dividing until true.
        # even numbers will always turn into 2
        # odd numbers are harder .. is the pattern the sqrt?
        self.sols = {}

        tot = 0
        for ind in range(len(nums) - 2, -1, -1):
            while nums[ind] > nums[ind + 1]:
                tot += 1
                nums[ind] = self.getDivis(nums[ind])
                if nums[ind] == -1:
                    return -1

        return tot

        ",1427853689
Dilworth,dilworth,717,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            vector<int> cnt(26, 0);
            bool yes = false;
            for (int j = i; j < s.size(); ++j) {
                cnt[s[j] - 'a']++;
                if (cnt[s[j] - 'a'] == k) yes = true;
                ans += yes;
            }
        }
        return ans;
    }
};",1427826838
Dilworth,dilworth,717,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string cur = """";
        vector<string> ans;
        for (auto c: target) {
            cur += ""a"";
            ans.push_back(cur);
            while (cur.back() != c) {
                cur[cur.size() - 1]++;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824942
Dilworth,dilworth,717,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        const int T = 1000000;
        vector<int> spf(T + 1);
        for (int i = 0; i <= T; ++i) spf[i] = i;
        for (int i = 2; i <= sqrt(T); ++i) {
            if (spf[i] == i) {
                for (int j = 2 * i; j <= T; j += i) {
                    if (spf[j] == j) spf[j] = i; 
                }
            }
        }
        int n = nums.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                if (spf[nums[i]] == nums[i]) return -1;
                nums[i] = spf[nums[i]];
                ++ans;
            }
        }
        return ans;
    }
};",1427845634
eulusoy,eulusoy,718,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> hist(256,0);
        int ans = 0;
        int i=0;
        int j=0;
        for(i=0; i<s.size(); ++i){
            ++hist[s[i]];
            while(hist[s[i]]==k){
                ans += s.size()-i;
                --hist[s[j]];
                ++j;
            }
        }
        return ans;
    }
};",1427832833
eulusoy,eulusoy,718,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string last = """";
        for(int i=0; i<target.size(); ++i){

            for(char a='a'; a<=target[i]; ++a){
                ans.push_back(last+a);
            }
            last = ans.back();
        }
        return ans;
    }
};",1427826165
eulusoy,eulusoy,718,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0;
        for(int i=nums.size()-2; i>=0; --i){
            if(nums[i+1]<nums[i]){
                int j;
                int a = sqrt(nums[i]);
                for(j=2; j<=sqrt(nums[i]); ++j){
                    if((nums[i]%j)==0){
                        nums[i] = j;
                        ++ans;
                        break;
                    }
                }
                if((nums[i]>nums[i+1])||(j>a)){
                    return -1;
                }
            }
        }
        return ans;
    }
};",1427845690
felikeCP,felikeCP,719,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {

        int ans=0;
        for (int i=0; i<s.length(); i++) {
            unordered_map<char, int> hm;
            for (int j=i; j>=0; j--) {
                hm[s[j]]++;
                if (hm[s[j]]>=k) {
                    ans += j+1;
                    break;
                }
                
            }
        }

        return ans;


    }
};",1427835645
felikeCP,felikeCP,719,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string temp="""";
        char c='a';
        for (int i=0; i<target.length(); i++) {
            while (c!=target[i]) {
                ans.push_back(temp + c);
                c++;
            } 

            ans.push_back(temp + c);
            temp += c;
            c = 'a';
            
            
            
        }

        return ans;
    }
};",1427827884
felikeCP,felikeCP,719,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        vector<int> dp(1e6+1);
        for (int i=nums.size()-2; i>=0; i--) {
            while (nums[i]>nums[i+1]) {
                int val=nums[i];
                if (dp[nums[i]]) {
                    val = dp[nums[i]];
                }
                else {
                    for (int j=2; j*j<=nums[i]; j++) {
                        if (nums[i]%j==0) {
                            dp[nums[i]] = j;
                            val = j;
                            break;
                        }
                    }
                }

                if (val==nums[i])
                    return -1;

                ans++;
                nums[i] = val;
            }
        }

        return ans;
    }
};",1427853990
flowing,flowing,720,3502,java,"class Solution {
    private boolean numberOfSubstringsCheck(int[] count, int k) {
        for (int i : count) {
            if (i >= k) {
                return true;
            }
        }
        return false;
    }
    public int numberOfSubstrings(String s, int k) {
        int ans = 0, n = s.length();
        int pl = 0, pr = 0;
        int[] count = new int[26];
        count[s.charAt(0) - 'a']++;
        while (pl < n) {
            while (numberOfSubstringsCheck(count, k)) {
                ans += n - pr;
                count[s.charAt(pl) - 'a']--;
                pl++;
            }
            if (pr >= n) {
                break;
            }
            pr++;
            if (pr < n) {
                count[s.charAt(pr) - 'a']++;
            }
        }
        return ans;
    }
}",1427833539
flowing,flowing,720,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < target.length(); i++) {
            for (int j = 'a'; j <= target.charAt(i); j++) {
                ans.add(stringBuilder.toString() + """" + (char) (j));
            }
            stringBuilder.append(target.charAt(i));
        }
        return ans;
    }
}",1427824643
flowing,flowing,720,3607,java,"class Solution {

    private int minOperationsFindGPD(int num) {
        if (num <= 3) {
            return -1;
        }
        int sqrt = (int) Math.sqrt(num);
        for (int j = 2; j <= sqrt; j++) {
            if (num % j == 0) {
                return num / j;
            }
        }
        return -1;
    }

    public int minOperations(int[] nums) {
        int n = nums.length;
        int ans = 0;
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > nums[i + 1]) {
                int gpd = minOperationsFindGPD(nums[i]);
                if (gpd == -1) {
                    return -1;
                }
                nums[i] /= gpd;
                ans++;
            }
        }
        return ans;
    }
}",1427854059
Avichal Dubey,dubeyavichal999,722,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        // int cnt[26]={0};
        int cc=0;
        // int i=0,j=0;
        int n=s.size();
        // while(j<n){
        //     cnt[s[j]-'a']++;
        //     if(cnt[s[j]-'a']==k) cc++;
        //     while(cc>=1 && )
        // }
        int ans=0;
        for(int i=0;i<n;i++){
            int cnt[26]={0};
            cc=0;
            for(int j=i;j<n;j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a']==k) cc++;
                if(cc){
                    // cout<<j<<endl;
                    ans+=(n-j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427840311
Avichal Dubey,dubeyavichal999,722,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curr="""";
        int i=-1;
        for(char c:target){
            curr+=c;
            i++;
            for(char ch='a';ch<=c;ch++){
                curr[i]=ch;
                ans.push_back(curr);
            }
        }
        return ans;
    }
};",1427825869
Avichal Dubey,dubeyavichal999,722,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int res=0;
        int prev=nums.back();
        for(int j=nums.size()-2;j>=0;j--){
            int ans=0;
            if(nums[j]<=prev){
                prev=nums[j];
                continue;
            }
            for(int i=2;i<nums[j]/2;i++){
                if(nums[j]%i==0){
                    ans=nums[j]/i;
                    break;
                }
            }
            if(!ans) return -1;
            nums[j]/=ans;
            if(nums[j]<=prev){
                prev=nums[j];
                res++;
            }
            else return -1;
        }
        return res;
    }
};",1427854158
Amrita,amrita_786,723,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length();
        int ans=0;
        for(int i=0;i<n;i++){
            vector<int> freq(26,0);
            int mx=0;
            for(int j=i;j<n;j++){
                freq[s[j]-'a']++;
                mx=max(mx,freq[s[j]-'a']);
                if(mx>=k)
                    ans++;
            }
        }
        return ans;
    }
};",1427831695
Amrita,amrita_786,723,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n=target.length();
        vector<string> ans;
        for(int i=n-1;i>=0;i--){
            int j=(int)target[i];
            while(j>=97){
                ans.push_back(target);
                j--;
                target[i]=j;
            }
            target.pop_back();
        }
        sort(ans.begin(),ans.end());
        return ans;
    }
};",1427826893
Amrita,amrita_786,723,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        for(int i=n-2;i>=0;i--){
            while(nums[i+1]<nums[i]){
                int a=div(nums[i]);
                if(a==1)
                    return -1;
                nums[i]/=a;
                ans++;
            }
        }
        return ans;
    }
    int div(int n){
        if ((n & 1) == 0)
        return n / 2;
    int i = 3;
    while (i * i <= n) {
        if (n % i == 0) {
            return n / i;
        }
        i = i + 2;
    }
    return 1;
    }
};",1427854220
sri_ram,Sar2486P,724,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] arr = s.toCharArray() ; 
        int n = s.length() ; 
        int ct = 0 ; 
        int[] freq = new int[26] ; 
        int i=0 , j = 0 ; 
        
        while(j<n){
            // taking j
            int idx = arr[j]-'a' ; 
            if(++freq[idx]>=k){
                ct+= n-j ;
                freq = new int[26] ; 
                i++ ; 
                j = i ; 
            }
            else {
                j++ ; 
            }
        }
        return ct ; 
    }
}",1427838581
sri_ram,Sar2486P,724,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>() ; 
        char[] arr = target.toCharArray() ; 
        String prev = """" ; 
        for(char c: arr){
            int d = c-'a' ; 
            for(int i=0 ; i<=d ; i++){
                char p = (char)(i+'a') ; 
                String s = prev + p ;
                ans.add(s) ; 
            }
            prev += (char)(d+'a') ;
        }
        return ans ; 
    }
}",1427829536
sri_ram,Sar2486P,724,3607,java,"class Solution {
    class A{
        int num ; 
        int ct ; 
        A(int num, int ct){
            this.num = num ; 
            this.ct = ct ; 
        }
    }
    public int minOperations(int[] nums) {
        int n = nums.length ; 
        int ct = 0 ; 
        for(int i=n-2 ; i>=0 ; i--){
            if(nums[i]<=nums[i+1]) continue ; 
            A a = f(nums[i], nums[i+1]) ; 
            if(a.num<= nums[i+1]){
                nums[i] = a.num ; 
                ct += a.ct ; 
            }
            else return -1 ; 
        }
        return ct ; 
    }
    private A f(int a, int b){
        int ct = 0 ; 
        for(int i=2; i*i<=a ; i++){
            if(a%i==0){
                ct++ ; 
                a /= (a/i) ; 
                if(a<=b) break ; 
                else i=2 ; 
            }
        }
        ct = (a<=b)?ct : -1 ; 
        return new A(a, ct) ; 
    }
}",1427854332
jackey,jackeyhua,725,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> cnt(26, 0);
        auto check = [&]() -> bool {
            for (int i = 0; i < 26; ++i) if (cnt[i] >= k) return true;
            return false;
        };

        int left = 0;
        int ans = 0;
        int n = s.size();
        for (int r = 0; r < n; ++r) {
            ++cnt[s[r] - 'a'];
            while (check()) {
                ans += n - r;
                --cnt[s[left++] - 'a'];
            }
        }
        return ans;
    }
};",1427846084
jackey,jackeyhua,725,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        int n = target.size();
        string cur = """";
        for (int i = 0; i < n; ++i) {
            cur += 'a';
            ans.push_back(cur);
            while (cur.back() != target[i]) {
                cur.back()++;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427838126
jackey,jackeyhua,725,3607,cpp,"class Solution {
public:
    int help(int x) {
        for (int i = 2; i <= x / i; i ++) {
            if (x % i == 0) return i;
        }
        return -1;
    }

    int minOperations(vector<int>& nums) {
        int ans = 0;
        int n = nums.size();
        int ub = nums.back();
        for (int i = n - 2; i >= 0; i--) {
            while (nums[i] > ub) {
                int t = help(nums[i]);
                cout << t << "" "";
                if (t == -1) return -1;
                nums[i] = t;
                ++ans;
            }
            cout << nums[i] << ""\n"";
            ub = nums[i];
        }
        return ans; 
    }
};",1427831642
Ye Gao,gaosanyong,726,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0 
        n = len(s)
        for i in range(n): 
            freq = Counter()
            found = False 
            for j in range(i, n): 
                freq[s[j]] += 1
                if freq[s[j]] == k: found = True 
                if found: ans += 1
        return ans ",1427836302
Ye Gao,gaosanyong,726,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        prefix = """"
        for ch in target: 
            for x in ascii_lowercase: 
                if x <= ch: 
                    cand = prefix + x
                    ans.append(cand)
                else: break 
            prefix = prefix + ch 
        return ans ",1427832221
Ye Gao,gaosanyong,726,3607,python3,"m = 1_000_000
sieve = [1]*(m+1)
for x in range(2, m+1): 
    for xx in range(x*2, m+1, x): 
        sieve[xx] = x 

class Solution:
    def minOperations(self, nums: List[int]) -> int:

        n = len(nums)
        ans = 0
        for i in range(n-2, -1, -1): 
            while nums[i] > nums[i+1]: 
                f = sieve[nums[i]]
                if f == 1: return -1 
                nums[i] //= f 
                ans += 1
        return ans ",1427846242
Divyansh Jain,DivyanshJain2003,727,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i=0;i<s.length();i++)
        {
            map<char,int> mp;
            int ma=0; 
            for(int j=i;j<s.length();j++)
            {
                mp[s[j]]++;
                ma=max(ma,mp[s[j]]);
                if(ma>=k)
                {
                    ans+=s.length()-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427833884
Divyansh Jain,DivyanshJain2003,727,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s="""";
        for(int i=0;i<target.size();i++)
        {
            for(char c='a';c<=target[i];c++)
            {
                s.push_back(c);
                ans.push_back(s);
                s.pop_back();
            }
            s.push_back(target[i]);
        } 
        return ans;
    }
};",1427828812
Divyansh Jain,DivyanshJain2003,727,3607,cpp,"class Solution {
public:
    int find(int n) 
{ 
    // Print the number of 2s that divide n 
    if (n % 2 == 0) 
        return 2;
 
    // n must be odd at this point. So we can skip 
    // one element (Note i = i +2) 
    for (int i = 3; i <= sqrt(n); i = i + 2) 
    { 
        // While i divides n, print i and divide n 
        if (n % i == 0) 
            return i;
    } 
    return n;
} 
    int minOperations(vector<int>& nums) {
        vector<int> f;
        for(auto x:nums)
        f.push_back(find(x));
        int ans=0;
        for(int i=nums.size()-2;i>=0;i--)
        {
            if(nums[i]>nums[i+1])
            {
                if(f[i]>nums[i+1])
                return -1;
                ans++;
                nums[i]=f[i];
            }
        }
        return ans;
    }
};",1427854524
Spryzen,Spryzen,729,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        // 26 characters
        // can just brute force this can't I
        vector<vector<int>> prefix_sum(26,vector<int>(1));

        for(char c:s){
            for(int i=0;i<26;i++){
                prefix_sum[i].emplace_back(prefix_sum[i].back()+((c-'a')==i));
            }
        }
        // now have computed the prefix sum
        int ans=0;
        for(int i=1;i<=s.size();i++){
            for(int j=0;j<i;j++){

                bool b=0;

                for(int m=0; m<26 && !b; m++){
                    //cout << prefix_sum[0][5];
                    b|=(prefix_sum[m][i]-prefix_sum[m][j]>=k);
                }
                if(b)
                    ans++;
                else break;

            }
        }
        return ans;
    }
};",1427835090
Spryzen,Spryzen,729,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        // start at a and keep going
        vector<string> ans;
        ans.emplace_back(""a"");
        int i=0;
        for(int c:target){
            while (c!=ans.back()[i]){
                ans.emplace_back(ans.back());
                ans.back()[i]++;
            }
            ans.emplace_back(ans.back()+'a');

            i++;
        }
        ans.resize(ans.size()-1);
        return ans;
    }
};",1427825069
Spryzen,Spryzen,729,3607,cpp,"class Solution {
public:
    int reduce(int num){
        int largest_factor=1;
        for(int i=(int)(sqrt(num));i>1;i--){
            if (num%i==0)
                largest_factor=(num/i);
        }
        return (num/largest_factor);
    }
    int minOperations(vector<int>& nums) {
        // want to find the minimum operations to make it non-decreasing
        // want to go from left to right
        // minimum operations 
        // greatest proper divisor
        // divide

        // want to find the maximal one of the thing 
        // if there is one, then 

        priority_queue<int> pq;
        int ans=0;
        
        for(int i=nums.size()-1;i>=0;i--){
            int j=10;
            while (!pq.empty() && (-pq.top())<nums[i]){
               // cout << nums[i];
                int a=reduce(nums[i]);
                ans++;
                if (a==nums[i])
                    return -1;
                nums[i]=a;
            }
            pq.emplace(-nums[i]);
        }return ans;
    }
    
};",1427854648
nicolaSaporetti,nicolaSaporetti,730,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int ke) {
        int sz = s.size();
        int r = 0;
        for(int i=0;i<sz;i++)
        {
            vector<int> v(26);
            bool exit = false;
            for(int j=i;j<sz && !exit;j++)
            {
                v[s[j]-'a']++;
                for(int k=0;k<26 && !exit;k++)
                    if(v[k]>=ke)
                    {
                        exit = true;
                        r+=sz-j;
                    }
            }
        }
        return r;
    }
};",1427828091
nicolaSaporetti,nicolaSaporetti,730,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> r;
        string t;
        for(auto e : target)
        {
            char c = 'a';
            while(c!=e)
            {
                r.push_back(t+c);
                c=(c+1-'a')%26+'a';
            }
            t+=c;
            r.push_back(t);
        }
        return r;
    }
};",1427836443
nicolaSaporetti,nicolaSaporetti,730,3607,cpp,"class Fact
{
public:
    Fact(int sz) : n(sz)
    {
        init();
    }
    vector<int> factorization(int n)
    {
        vector<int> r;
        while(prev_factor[n].second>1)
        {
            r.push_back(prev_factor[n].second);
            n=prev_factor[n].first;
        }
        return r;
    }
private:
    void init()
    {
        prev_factor.assign(n+1, {0,-1});
        for(int i=2;i<=n;i++) prev_factor[i].second=i;
        prev_factor[0] = {0,0};
        prev_factor[1] = {0,0};
        prev_factor[2] = {0,2};
        for (int j = 4; j <= n; j += 2) prev_factor[j] = {j/2,2};
        for (int i = 3; i * i <= n; i+=2) {
            if (prev_factor[i].first==0) {
                prev_factor[i]={0,i};
                for (int j = i * i; j <= n; j += i) prev_factor[j] = {j/i,i};
            }
        }
    }
    vector<pair<int,int>> prev_factor;
    int n;
};

class Solution {
public:
    int minOperations(vector<int>& nums) {
        Fact fa(*max_element(begin(nums),end(nums))+1);
        int r = 0;
        for(int i=nums.size()-2;i>=0;i--)
        {
            if(nums[i]>nums[i+1])
            {
                vector<int> f=fa.factorization(nums[i]);
                sort(begin(f),end(f));
                nums[i]=f[0];
                if(nums[i]>nums[i+1]) return -1;
                r++;
            }
        }
        return r;
    }
};",1427846404
Ninja Deepak,ninja_deepak,731,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        int ans = 0;

        for(int i = 0; i<n; i++){
            vector<int> cnt(26, 0);
            for(int j = i; j<n; j++){
                cnt[s[j]-'a']++;
                if(cnt[s[j]-'a'] >= k){
                    ans += (n-j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427826317
Ninja Deepak,ninja_deepak,731,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        int n = target.length();

        string temp = """";
        for(int i = 0; i<n; i++){
            char c = 'a';
            temp.push_back('a');
            res.push_back(temp);
            while(temp[i] != target[i]){
                temp[i]++;
                res.push_back(temp);
            }
        }
        return res;
    }
};",1427824441
Ninja Deepak,ninja_deepak,731,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();

        int cnt = 0;
        int prev = nums[n-1];

        for(int i = n-2; i>=0; i--){
            int ele = nums[i];
            if(ele <= prev){
                prev = nums[i];
                continue;
            }
            else{
                while(ele>prev){
                    for(int j = 2; j*j<=ele; j++){
                        if(ele%j == 0){
                            ele = j;
                            break;
                        }
                    }

                    if(ele > prev){
                        return -1;
                    }
                    else{
                        cnt++;
                    }
                }
                
                prev = ele;
            }
        }
        return cnt;
    }
};",1427838387
Manmeet Singh,Manmeet8287,732,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.size();
        for(int i=0;i<n;i++)
        {
            unordered_map<int,int> mp;
            for(int j=i;j<n;j++)
            {
                mp[s[j]]++;
                if(mp[s[j]]==k)
                {
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427826378
Manmeet Singh,Manmeet8287,732,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s="""";
        for(auto &it:target)
        {
            for(char ch='a';ch<='z';ch++)
            {
                if(ch=='a') s.push_back(ch);
                else
                {
                    s.pop_back();
                    s.push_back(ch);
                }
                ans.push_back(s);
                if(ch==it) break;
            }
        }
        return ans;
    }
};",1427824286
Manmeet Singh,Manmeet8287,732,3607,cpp,"#define pb push_back
#define ff first
#define ss second
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define sz(v) (int)v.size()
#define deb(x) cout<<#x<<""=""<<x<<endl;
#define pii pair<int,int>
#define vi vector<int>

class Solution {
public:
    int minOperations(vector<int>& nums) {
    int n=nums.size();   
    int mx=*max_element(all(nums));
    vector<int> sieve(mx+5,1e9);
    for(int i=2;i<sieve.size();i++)
    {
        if(sieve[i]!=1e9) continue;
        for(int j=2LL*i;j<sieve.size();j+=i)
        {
            sieve[j]=min(sieve[j],i);
        }
    }
    int ans=0,prev=nums[n-1];
    for(int i=n-2;i>=0;i--)
    {
        if(nums[i]<=prev) prev=nums[i];
        else
        {
            while(sieve[nums[i]]!=1e9 and nums[i]>prev)
            {
                ans++;
                int den=nums[i]/sieve[nums[i]];
                nums[i]/=den;
            }
            if(nums[i]>prev) return -1;
            prev=nums[i];
        }
    }
    return ans;
}
};",1427846519
sohanpatharla,sohanpatharla,733,3502,java,"import java.util.HashMap;
import java.util.Map;

class Solution {
    public int numberOfSubstrings(String str, int threshold) {
        int length = str.length();
        int totalSubstrings = 0;

        for (int start = 0; start < length; start++) {
            Map<Character, Integer> charCount = new HashMap<>();
            int count = 0;

            for (int end = start; end < length; end++) {
                char ch = str.charAt(end);
                charCount.put(ch, charCount.getOrDefault(ch, 0) + 1);
                
                if (charCount.get(ch) >= threshold) {
                    count++;
                }

                if (count > 0) {
                    totalSubstrings++;
                }
            }
        }

        return totalSubstrings;
    }
}
",1427838233
sohanpatharla,sohanpatharla,733,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> stringSequence(String target) {
        List<String> result = new ArrayList<>();
        StringBuilder screen = new StringBuilder();
        
        screen.append('a');
        result.add(screen.toString());

        for (int i = 0; i < target.length(); i++) {
            char targetChar = target.charAt(i);

            if (i > 0) {
                screen.append('a');
                result.add(screen.toString());
            }

            while (screen.charAt(i) != targetChar) {
                char currentChar = screen.charAt(i);
                char nextChar = currentChar == 'z' ? 'a' : (char) (currentChar + 1);
                screen.setCharAt(i, nextChar);
                result.add(screen.toString());
            }
        }

        return result;
    }
}
",1427830501
sohanpatharla,sohanpatharla,733,3607,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        int n = nums.length;

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                int operations = divideUntilNonDecreasing(nums, i, nums[i + 1]);
                if (operations == -1) {
                    return -1;
                }
                count += operations;
            }
        }
        return count;
    }

    private int divideUntilNonDecreasing(int[] nums, int idx, int nextValue) {
        int ops = 0;

        while (nums[idx] > nextValue) {
            List<Integer> divisors = getProperDivisors(nums[idx]);

            if (divisors.isEmpty()) {
                return -1;
            }

            nums[idx] = divisors.get(divisors.size() - 1); 
            ops++;
            
            if (nums[idx] == 1) {  
                return -1;
            }
        }

        return ops;
    }

    private List<Integer> getProperDivisors(int num) {
        List<Integer> divisors = new ArrayList<>();
        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (num % i == 0) {
                divisors.add(i);
                if (i != num / i) {
                    divisors.add(num / i);
                }
            }
        }
        divisors.sort((a, b) -> b - a);
        return divisors;
    }
}
",1427854767
Rohit Jain,rohitathuffinnn,735,3502,cpp,"class Solution {
public:
    bool test(vector<int>&count,int k){
        for(auto it:count)if(it>=k)return 1;
        return 0;
    }
    int numberOfSubstrings(string s, int k) {
        int i=0,j=0,n=s.size();
        vector<int>count(26,0);
        int res=0;
        while(j<n){
            count[s[j]-'a']++;
            if(count[s[j]-'a']==k)break;
            j++;
        }
        if(j==n)return res;
        while(i<n){
            count[s[i]-'a']--;
            if(!test(count,k)){
                count[s[i]-'a']++;
                break;
            }
            else i++;;
        }
        res+=(i+1);
        j++;
        while(j<n){
            count[s[j]-'a']++;
            while(i<n){
                count[s[i]-'a']--;
                if(!test(count,k)){
                    count[s[i]-'a']++;
                    break;
                }
                else i++;
            }
            j++;
            res+=(i+1);
        }
        return res;
    }
};",1427835806
Rohit Jain,rohitathuffinnn,735,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>res;
        string a="""";
        for(int i=0;i<target.size();i++){
            for(int x='a';x<=target[i];x++){
                a+=(x);
                res.push_back(a);
                a.pop_back();
            }
            a+=target[i];
        }
        return res;
    }
};",1427824682
Rohit Jain,rohitathuffinnn,735,3607,cpp,"static vector<int>store;
static bool val=0;
int helper(int x){
    if(store[x]!=-2)return store[x];
    for(int i=2;i<=sqrt(x);i++){
        if(x%i==0){
            return store[x]=x/i;
        }
    }
    return store[x]=-1;
}
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int res=0;
        if(!val){
            store.resize(1e7,-2);
            val=1;
        }
        for(int i=nums.size()-2;i>=0;i--){
            int ele=nums[i+1],val=nums[i];
            while(val>ele){
                if(store[val]==-1)return -1;
                if(store[val]!=-2)val/=store[val];
                else {
                    int x=helper(val);
                    if(x!=-1)val/=x;
                    else return -1;
                }
                res++;
            }
            nums[i]=val;
        }
        return res;
    }
};",1427854805
Prathamesh khetre,Prathamesh_94,736,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        int ans=0;
        for(int i=0; i<n; i++){
            unordered_map<char,int> mp;
            for(int j=i; j<n; j++){
                mp[s[j]]++;
                if(mp[s[j]]==k){
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427830536
Prathamesh khetre,Prathamesh_94,736,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr="""";
        int n=target.size();
        while(curr.size()!=n){
            int i=curr.size();
            for(char c='a'; c<=target[i]; c++){
                string temp = curr+c;
                res.push_back(temp);
            }
            curr+=target[i];
        }
        return res;
    }
};",1427825341
Prathamesh khetre,Prathamesh_94,736,3607,cpp,"class Solution {
public:
    bool sorted(vector<int> nums){
        for(int i=1; i<nums.size(); i++){
            if(nums[i]<nums[i-1]) return false;
        }
        return true;
    }
    int gpd(int num){
        for(int i=2; i*i<=num; i++){
            if(num%i==0){
                return i;
            }
        }
        return -1;
    }
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        int count=0;
        for(int i=n-2; i>=0; i--){
            while(nums[i]>nums[i+1]){
                int t = gpd(nums[i]);
                if(t==-1) return -1;
                nums[i] = t;
                count++;
            }
        }
        return count;
    }
};",1427846630
Weiyan Zhu,WeiyanZhu,738,3502,kotlin,"class Solution {
    fun numberOfSubstrings(s: String, k: Int): Int {
        val counts = IntArray(26){0}
        var res = 0
        var left = 0
        s.forEach{ c->
            counts[c.toInt()-97] += 1
            if(counts.max() >= k){
                while(counts.max() >= k){
                    counts[s[left].toInt()-97] -= 1
                    left++
                }
                res += left
                left--
                counts[s[left].toInt()-97] += 1
            }
        }
        return res
    }
}",1427842231
Weiyan Zhu,WeiyanZhu,738,3566,kotlin,"class Solution {
    fun stringSequence(target: String): List<String> {
        var current = """"
        val res = mutableListOf<String>()
        target.forEach{ c->
            for(i in 'a'..c){
                res.add(current + i)
            }
            current = current + c
        }
        return res
    }
}",1427831551
Weiyan Zhu,WeiyanZhu,738,3607,kotlin,"class Solution {
    fun minOperations(nums: IntArray): Int {
        var res = 0
        for(i in nums.size-2 downTo 0){
            while(nums[i] > nums[i+1]){
                var changed = false
                for(j in 2..nums[i]-1){
                    if(nums[i] % j == 0){
                        changed = true
                        res += 1
                        nums[i] = j
                        break
                    }
                }
                if(!changed){
                    return -1
                }
            }
        }
        return res
    }
}",1427854910
hgwalani81,hgwalani81,739,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int p) {
        int n = s.length();
        vector<vector<int> > dp(n+1, vector<int>(26, 0));
        for(int i = 1; i<=n; i++) {
            for(int j = 0; j<26; j++) dp[i][j] = dp[i-1][j] + ((s[i-1] - 'a') == j);
        }
        int ans = 0;
        for(int i = 0; i<n; i++) {
            for(int j = i; j<n; j++) {
                bool flag = false;
                for(int k = 0; k<26 and !flag; k++) 
                    if(dp[j+1][k] - dp[i][k] >= p) {
                        ans++;
                        flag = true;
                    }
            }
        }
        return ans;
    }
    
};",1427837514
hgwalani81,hgwalani81,739,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> v;
        string current = """";
        for(char c : target) {
            for(char cc = 'a'; cc < c; cc++) {
                current += cc;
                v.push_back(current);
                current.pop_back();
            }
            current += c;
            v.push_back(current);
        }
        return v;
    }
};",1427843126
hgwalani81,hgwalani81,739,3607,cpp,"class Solution {
public:
    
    int fun(int k) {
        for(int i = 2; (i*i) <= k; i++) {
            if(k%i == 0) return i;
        }
        return k;
    }
    
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int prev = nums.back(), ans = 0;
        for(int i = n-2; i>=0; i--) {
            if(prev < nums[i]) {
                int newNum = fun(nums[i]);
                if(newNum > prev) return -1;
                prev = newNum;
                ans++;
            } else {
                prev = nums[i];
            }
        }
        return ans;
    }
};",1427855080
Ganji Ganesh,Ganesh_Ganji,740,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n=s.length();
        int ans=0;
        char[] c=s.toCharArray();
        for(int i=0;i<n;i++){
            int[] freq=new int[26];
            for(int j=i;j<n;j++){
                freq[c[j]-'a']++;
                if(value(freq,k)){
                    ans++;
                }
            }
        }
        return ans;
    }
    public boolean value(int[] cnt,int k){
        for(int i=0;i<26;i++){
            if(cnt[i]>=k){
                return true;
            }
        }
        return false;
    }
}",1427834496
Ganji Ganesh,Ganesh_Ganji,740,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder str = new StringBuilder();
        List<String> res = new ArrayList<>();
        char[] c=target.toCharArray();
        for (char ch : c) {
            
            str.append('a');
            res.add(str+"""");
            
            while (str.charAt(str.length() - 1) != ch) {
                char lChar = str.charAt(str.length() - 1);
                char nChar = (char)((lChar - 'a' + 1) % 26 + 'a');
                
                str.setCharAt(str.length() - 1, nChar);
                //weifh
                res.add(str+"""");
            }
        }
        
        return res;
    }
}",1427855156
Ganji Ganesh,Ganesh_Ganji,740,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int result=0;
        int len=nums.length;
        int next=nums[len-1];
        for(int itr=len-2;itr>=0;itr--){
            
            while(nums[itr]>next){
                int prefectdivisor=divisors(nums[itr]);
                
                if(prefectdivisor==-123456789){
                    return -1;
                }
                nums[itr]/=prefectdivisor;
                
                result++;
            }
            
            next=nums[itr];
        }
        return result;
    }
    
    public int divisors(int num){
        int maximize=-123456789;
        for(int i=2;i*i<=num;i++)
            if(num%i==0) maximize=Math.max(maximize,Math.max(i,num/i));
        
        return maximize;
    }
}",1427841023
AlexShch,AlexShch,741,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        N = len(s)

        def get_res(right):
            cur = {}
            left = right
            while left >= 0:
                cur[s[left]] = cur.get(s[left], 0) + 1
                if cur[s[left]] == k:
                    return left + 1
                left -= 1
            return 0
        
        res = 0
        for right in range(N):
            res += get_res(right)
        
        return res",1427840549
AlexShch,AlexShch,741,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        cur = []
        for el in target:
            cur.append('a')
            res.append(''.join(cur))
            while cur[-1] != el:
                cur[-1] = chr(ord(cur[-1]) + 1)
                res.append(''.join(cur))
        return res",1427825629
AlexShch,AlexShch,741,3607,python3,"NN = 10 ** 6 + 10
primes = [i for i in range(NN + 1)]

for i in range(2, int(math.sqrt(NN)) + 1):
    if primes[i] == i:
        for j in range(i * i, NN + 1, i):
            primes[j] = min(primes[j], i)

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        N = len(nums)
        res = 0
        if N == 1:
            return 0
        l, r = N - 2, N - 1
        while l >= 0:
            if nums[l] <= nums[r]:
                l -= 1
                r -= 1
                continue
            smallest_divisor = primes[nums[l]]
            if smallest_divisor == nums[l]:
                return -1
            nums[l] = smallest_divisor
            res += 1
            if nums[l] > nums[r]:
                return -1
            l -= 1
            r -= 1
        
        return res",1427855175
Biraj Sanghai,sanghaibiraj,742,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        map<char,int> mp;
        int l=0,r=0;
        while(r<s.length()){
            mp[s[r]]++;
            while(mp[s[r]]==k){
                ans+=(s.length()-r);
                mp[s[l]]--;
                l++;
            }
            r++;
        }
        return ans;
    }
};",1427835845
Biraj Sanghai,sanghaibiraj,742,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s = """";
        char ch = 'a';
        vector<string> ans;
        int i=0;
        while(i<target.size()){
            ans.push_back(s+ch);
            if(target[i]==ch){
                s+=ch;
                ch='a';
                i++;
            }
            else ch++;
        }
        return ans;
    }
};",1427826656
Biraj Sanghai,sanghaibiraj,742,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        // int n= nums.size();
        vector<int> prop(nums.size(),1);
        for(int i=0;i<nums.size();i++){
            for(int j=2;j*j<=nums[i];j++){
                if(nums[i]%j==0){
                    prop[i]=j;
                    break;
                }
            }
            if(prop[i]==1) prop[i]=nums[i];
        }
        int ans=0;
        for(int i=nums.size()-2;i>=0;i--){
            if(nums[i]<=nums[i+1]) continue;
            else if(prop[i]<=nums[i+1]){
                nums[i]=prop[i];
                ans++;
            }
            else return -1;
        }
        return ans;
    }
};",1427855182
AVIJIT_BISWAS,AVIJIT_BISWAS,743,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), count = 0;
        unordered_map<char, int> mp;
        for (int i = 0; i < n; ++i) {
            mp.clear();
            for (int j = i; j < n; ++j) {
                mp[s[j]]++;
                if (mp[s[j]] >= k) {
                    count += n - j;
                    break;
                }
            }
        }
        return count;
    }
};
",1427835228
AVIJIT_BISWAS,AVIJIT_BISWAS,743,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        for (char ch : target) {
          
            if(current.size() < target.size()) {
              current += 'a';
              result.push_back(current);  
            }

            // while (current.size() < target.size() || current.back() < ch) {
            //     current += 'a' + (current.size() > 0 ? current.back() - 'a' + 1 : 0) % 26;
            //     result.push_back(current);
            // }
            while (current.back() < ch) {
                current.back()++;
                result.push_back(current);
            }
            // current += ch;
            // result.push_back(current);
        }
        return result;
    }
};
",1427829262
AVIJIT_BISWAS,AVIJIT_BISWAS,743,3607,cpp,"class Solution {
public:
  
  
    int minOperations(vector<int>& a) {
        int n = a.size();
        int mx = *max_element(a.begin(), a.end());
        vector<int>  sp(mx + 5, 0);
        for(int i = 1; i <= mx; i++){
          sp[i] = i;
        }
        for(int i = 2; i <= mx; i++){
          if(sp[i] != i) continue;
          for(int j = i; j <= mx; j += i){
            sp[j] = min(sp[i], sp[j]);
          }
        }
        
        
        // for(int i = 1; i <= mx; i++){
        //   cout << sp[i] << ' ';
        // }
        
        int ans = 0;
        
        for(int i = n - 2; i >= 0; i--) {
          int d = a[i] / sp[a[i]];
          while(a[i] > a[i + 1]) {
            if(d == 1) return -1;
            a[i] /= d;
            ans++;
            d = a[i] / sp[a[i]];
          }
        }
        
        return ans;
    }
};
",1427855403
duggireddykrishnavamsireddy,duggireddykrishnavamsireddy,744,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        int ans=0;
        for(int i=0;i<n;i++){
            vector<int> freq(26,0);
            for(int j=i;j<n;j++){
                freq[s[j]-'a']++;
                if(freq[s[j]-'a']>=k){
                    ans+=(n-j);
                    //cout<<n-i<<"" "";
                    break;
                }
            }
        }
        return ans;
    }
};",1427834002
duggireddykrishnavamsireddy,duggireddykrishnavamsireddy,744,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string s="""";
        for(auto it:target){
            s+='a';
            ans.push_back(s);
            while(s[s.size()-1]!=it){
                char c=s[s.size()-1];
                c=c+1;
                s[s.size()-1]=c;
                ans.push_back(s);
            }
        }
        return ans;
    }
};",1427826500
duggireddykrishnavamsireddy,duggireddykrishnavamsireddy,744,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        int maxi=*max_element(nums.begin(),nums.end());
        vector<int> div(maxi+1,-1);
        for(int i=0;i<=maxi;i++){
            div[i]=i;
        }
        for (int p = 2; p * p <= maxi; p++) {
        // If isPrime[p] is true, then it is a prime
        if (div[p]==p) {
            // Mark all multiples of p as false
            for (int i = p * p; i <= maxi; i += p)
                if(div[i]==i){
                    div[i]=p;
                }
        }
    }
        // for(int i=2;i<=maxi;i++){
        //     cout<<i<<"" ""<<div[i]<<endl;
        // }
        int op=0,last=1e9;
        for(int i=n-1;i>=0;i--){
            if(nums[i]<=last){
                last=nums[i];
                continue;
            }
            else{
                int num=div[nums[i]];
                if(num<=last){
                    last=num;
                    op++;
                }
                else{
                    return -1;
                }
            }
        }
        return op;
    }
};",1427855567
Sarthak Goel,sarthak97,745,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        unordered_map<char, int> hash;
        int currMax, ans = 0;

        for(int i=0; i<n; i++) {
            hash.clear();
            currMax = 0;

            for(int j=i; j<n; j++) {
                hash[s[j]]++;
                currMax = max(currMax, hash[s[j]]);
                if(currMax >= k)
                    ans++;
            }
        }

        return ans;
    }
};",1427834041
Sarthak Goel,sarthak97,745,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string temp;

        for(int i=0; i<target.size(); i++) {
            char ch = target[i];
            temp += 'a';
            ans.push_back(temp);

            while(temp.back() != target[i]) {
                temp[i] += 1;
                ans.push_back(temp);
            }
        }

        return ans;
    }
};",1427825192
Sarthak Goel,sarthak97,745,3607,cpp,"class Solution {
public:
    bool isPrime(int n) {
        int cnt = 0;

        if (n <= 1)
            return false;

        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0)
                return false;
        }

        return true;
    }

    int getGreatestProperDivisor(int n) {
        if(isPrime(n))
            return -1;
        
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0)
                return n / i;
        }

        return -1;
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int i = n-2, ans = 0;

        int prev = nums[n-1];
        while(i >= 0) {
            if(prev >= nums[i]) {
                prev = nums[i];
                i--;
                continue;
            }

            while(prev < nums[i]) {
                int div = getGreatestProperDivisor(nums[i]);
                if(div == -1)
                    return -1;
                
                ans++;
                nums[i] /= div;
            }
        }


        return ans;
    }
};",1427855624
kumarrarya,kumarrarya,746,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        int n=s.length();
        for(int i=0;i<n;i++){
            vector<int>f(26);
            for(int j=i;j<n;j++){
                f[s[j]-'a']++;
                if(f[s[j]-'a']>=k){
                    ans+=(n-j);
                    break;
                }
            }
        }
        return ans;
    }
};",1427831830
kumarrarya,kumarrarya,746,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>ans;
        int l=0;
        string s=""a"";
        for(int i=0;i<target.size();i++){
            ans.push_back(s);
            while(s.back()!=target[i]){
                int c=s[s.length()-1]-'a';
                s[s.length()-1]=char(c+1+'a');
                ans.push_back(s);
            }
            if(i!=target.length()-1){
                s.push_back('a');
            }
            
        }
        return ans;
    }
};",1427828075
kumarrarya,kumarrarya,746,3607,cpp,"int a[1000000];
bool flag=false;
void helper(bool check){
    if(flag){
        return;
    }
    memset(a,0,sizeof(a));
    a[0]=0;
    a[1]=1;
    a[2]=1;
    for(int i=3;i<1000000;i++){
        for(int j=1;j*j<=i;j++){
            if(i%j==0){
                int v=i/j;
                int v2=j;
                if(v!=i) a[i]=max(a[i],v);
                if(v2!=i) a[i]=max(a[i],v2);
                // break;
            }
        }
    }
    flag=true;
}
class Solution {
public:
    
    int minOperations(vector<int>& nums) {
        helper(false);
        int n=nums.size();
        int mx=nums[n-1];
        int ans=0;
        cout<<a[7]<<endl;
        for(int i=nums.size()-2;i>=0;i--){
            int v=nums[i];
            while(v>mx){
                int d=a[v];
                if(d==1){
                    return -1;
                }
                v=v/d;
                ans++;
            }
            mx=min(mx,v);
        }
        return ans;
    }
};",1427855635
wayjiang,wayjiang,747,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0, n = s.size();
        unordered_map<char, int> cnt;
        auto checkG = [&]() {
            for (auto [ch, c] : cnt)
                if (c >= k) return true;

            return false;
        };
        for (int i = 0, j = 0; j < n; ++j) {
            cnt[s[j]]++;
            while (checkG()) {
                cnt[s[i]]--;
                i++;
            }
            ans += i;
        }
        return ans;
    }
};",1427834954
wayjiang,wayjiang,747,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur;
        for (char c : target) {
            cur += 'a';
            ans.push_back(cur);
            while (cur.back() != c) {
                cur.back() += 1;
                ans.push_back(cur);
            }
        }
        return ans;
    }
};",1427824961
wayjiang,wayjiang,747,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans = 0, n = nums.size();
        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] > nums[i + 1]) {
                int x = findMaxFactor(nums[i]);
                nums[i] /= x;
                if (nums[i] > nums[i + 1]) return -1;
                ans++;
            }
        }
        return ans;
    }
    int findMaxFactor(int n) {
        int maxFactor = 1;
        for (int i = 1; i <= sqrt(n); ++i) {
            if (n % i == 0) {
                if (i != n) {
                    maxFactor = max(maxFactor, i); 
                }
                if ((n / i != n) && (n / i != i)) {
                    maxFactor = max(maxFactor, n / i);
                }
            }
        }
        return maxFactor;
    }
};",1427855655
Coco,Coco_007,748,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        d = defaultdict(int)
        count = 0
        left = 0
        for right in range(len(s)):
            d[s[right]] += 1
            while d[s[right]] == k:
                d[s[left]] -= 1
                left += 1
            count += left
        return count",1427831068
Coco,Coco_007,748,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        curr = ''
        for c in target:
            time = ord(c) - ord('a')
            for i in range(time + 1):
                ans.append(curr + chr(ord('a') + i))
            curr += c
        return ans",1427825119
Coco,Coco_007,748,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        maximum = nums[-1]
        count = 0
        n = len(nums)
        @cache
        def helper(num):
            curr = -1
            for i in range(int(math.sqrt(num)), 1, -1):
                if num % i == 0:
                    curr = i
            return curr
                
        for i in range(n - 2, -1, -1):
            num = nums[i]
            while num > maximum:
                leftover = helper(num)
                if leftover == -1:
                    return -1
                num = leftover
                count += 1
            maximum = num
        
        return count      ",1427847397
smallfatcute,smallfatcute,749,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        unordered_map<char, int> freq;
        int overk = 0;
        int j = 0;
        int ans = 0;

        for (int i = 0; i < s.size(); ++i) {
            freq[s[i]] += 1;

            if (freq[s[i]] == k) overk += 1;

            while (overk > 1) {
                if (freq[s[j]] == k) overk -= 1;
                freq[s[j]] -= 1;
                j += 1;
            }

            while (overk == 1 && freq[s[j]] != k) {
                freq[s[j]] -= 1;
                j += 1;
            }

            if (overk == 1) {
                ans += j + 1;
            }
        }

        return ans;
    }
};",1427845619
smallfatcute,smallfatcute,749,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curr;

        while (curr != target) {
            int idx = curr.size();
            curr += 'a';

            while (curr.back() != target[idx]) {
                ans.push_back(curr);
                curr.back() += 1;
            }

            ans.push_back(curr);
        }

        return ans;
    }
};",1427835420
smallfatcute,smallfatcute,749,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        if (nums.size() < 2) return 0;

        int ans = 0;

        for (int i = nums.size() - 2; i >= 0; --i) {
            while (nums[i] > nums[i + 1]) {
                int d = divide(nums[i]);
    
                if (d == -1) return -1;

                nums[i] = d;
                ans += 1;
            }
        }

        return ans;
    }

    int divide(int n) {
        for (int i = 2; i * i <= n; ++i) {
            if (n % i == 0) return i;
        }

        return -1;
    }
};",1427855725
Lance,fong88718,751,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) 
    {
        long res = 0;
        unordered_map<char, int> mp;
        
        for(int l = 0, r = 0 ; r < s.size() ; r++)
        {
            mp[s[r]]++;
            
            while(l <= r && mp[s[r]] >= k)
            {
                res += s.size() - r;
                --mp[s[l++]];
            }
        }
        return res;
    }
};",1427835049
Lance,fong88718,751,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) 
    {
        vector<string> res;
        string s;
        
        for(char c : target)
        {
            res.push_back(s + ""a"");
            s += ""a"";
            while(s.back() != c)
            {
                s[s.size()-1] = s[s.size()-1] + 1;
                res.push_back(s);
            }
        }
        return res;
    }
};",1427829059
Lance,fong88718,751,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) 
    {
        int res = 0;
        
        for(int i = nums.size()-2 ; i >= 0 ; i--)
        {
            while(nums[i] > nums[i+1])
            {
                if(cal(nums[i]) == false)
                    return -1;
                    
                res++;
            }
        }
        return res;
    }
    bool cal(int &n)
    {
        for(int i = 2 ; i <= pow(n, 0.5)  ; i++)
        {
            if((n % i) == 0)
            {
                n = i;
                return true;
            }
        }
        return false;
    }
};",1427847590
JJZin,JJZin,752,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        
        bottom = 0
        top = 0
        
        counter = [0 for i in range(26)]
        ans = 0
        
        alpha = 'abcdefghijklmnopqrstuvwxyz'
        while (top <= len(s) and bottom < len(s)):
            
            while (top < len(s) and max(counter) < k):
                counter[alpha.index(s[top])] += 1
                top += 1
                
            if (max(counter) >= k):
                ans += 1 + (len(s) - top)
            counter[alpha.index(s[bottom])] -= 1
            bottom += 1
            
        return ans
            
        ",1427832062
JJZin,JJZin,752,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        
        ans = []
        
        alpha = 'abcdefghijklmnopqrstuvwxyz'
        
        basis = ''
        for i in range(len(target)):
            char = target[i]
            
            
            st = 'a'
            
            cnt = 0
            while st != char:
                
                ans.append(basis + st)
                cnt+=1
                st = alpha[cnt]
            basis+= st
            ans.append(basis)
        return ans
                
            
            
                
            
            ",1427826266
JJZin,JJZin,752,3607,python3,"


@cache
def maxD(num):
    
    if num == 2:
        return -1
    
    if (num % 2 == 0):
        return num//2
    
    for i in range(3, num, 2):
        if (num % i) == 0:
            
            return num//i
    return -1
        
    
        

class Solution:
    def minOperations(self, nums: List[int]) -> int:
        
        cnt = 0
        for i in range(len(nums)-2, -1, -1):
            
            while nums[i] > nums[i + 1]:
                the = maxD(nums[i])
                if the == -1:
                    return -1
                nums[i] = nums[i]//the
                cnt+=1
           
        return cnt
            
        
        
        
        
        ",1427847669
K Yu,yu621k,753,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        index = defaultdict(list)
        ans = 0
        for idx, char in enumerate(s):
            index[char].append(idx)
            maxIdx = -1
            for indexList in index.values():
                if len(indexList) >= k:
                    maxIdx = max(indexList[-k], maxIdx)
            ans += maxIdx + 1
        return ans
            
",1427836949
K Yu,yu621k,753,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        cur = ''
        output = []
        for char in target:
            for i in range(ord('a'), ord(char) + 1):
                output.append(cur + chr(i))
            cur += char
        return output",1427825975
K Yu,yu621k,753,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        def getDivisor(num, target):
            for i in range(2, min(int(num ** 0.5), target) + 1):
                if num % i  == 0:
                    return i
            return -1

        n = len(nums)
        ops = 0
        for idx in range(n - 1, -1, -1):
            if idx < n - 1 and nums[idx] > nums[idx + 1]:
                res = getDivisor(nums[idx], nums[idx + 1])
                if res != -1:
                    nums[idx] = res
                    ops += 1
                else:
                    return -1
        return ops
",1427856041
Nikita,reidak18,754,3502,swift,"class Solution {
    func numberOfSubstrings(_ s: String, _ k: Int) -> Int {
        let s = Array(s)
        var left = 0
        var right = 0
        var dict = Dictionary<Character, Int>()
        var res = 0
        while right < s.count {
            dict[s[right], default: 0] += 1
            while dict[s[right], default: 0] >= k {
                res += s.count - right
                dict[s[left], default: 0] -= 1
                left += 1
            }
            right += 1
        }
        return res
    }
}",1427836619
Nikita,reidak18,754,3566,swift,"class Solution {
    func stringSequence(_ target: String) -> [String] {
        let target = Array(target)
        let start = Character(""a"").asciiValue!
        var curStr = """"
        var res = [String]()
        for i in 0..<target.count {
            let cur = target[i].asciiValue!
            for j in start...cur {
                res.append(""\(curStr)\(UnicodeScalar(j))"")
            }
            curStr += String(target[i])
        }
        return res
    }
}",1427828820
Nikita,reidak18,754,3607,swift,"class Solution {
    func minOperations(_ nums: [Int]) -> Int {
        var nums = nums
        var pred = nums[nums.count - 1]
        var count = 0
        for i in stride(from: nums.count - 2, through: 0, by: -1) {
            while nums[i] > pred {
                if nums[i] < 3 {
                    return -1
                }
                var div = true
                for j in 2..<nums[i] {
                    if nums[i] % j == 0 {
                        nums[i] = j
                        count += 1
                        div = false
                        break
                    }
                }
                if div {
                    return -1
                }
            }
            pred = nums[i]
        }
        return count
    }
}",1427856090
Kartik Papney,kartikpapney,756,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int ans = 0;
        int j = 0;
        int[] cnt = new int[26];
        for(int i=0; i<s.length(); i++) {
            char c = s.charAt(i);
            cnt[c-'a']++;
            while(cnt[c-'a'] >= k) {
                ans += s.length()-i;
                cnt[s.charAt(j)-'a']--;
                j++;
            }
        }
        return ans;
    }
}",1427833586
Kartik Papney,kartikpapney,756,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> result = new ArrayList<>();
        for(int i = 0; i<target.length(); i++) {
            char c = target.charAt(i);
            String cstr = result.size() == 0 ? """" : result.get(result.size()-1);
            for(char cc = 'a'; cc<= c; cc++) {
                result.add(cstr + cc);
            }
        }
        return result;
    }
}",1427828235
Kartik Papney,kartikpapney,756,3607,java,"class Solution {
    // method to print the divisors
    static PriorityQueue<Integer> printDivisors(long n)
    {
        PriorityQueue<Integer> ans = new PriorityQueue<>(Collections.reverseOrder());
        // Note that this loop runs till square root
        for (long i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                // If divisors are equal, print only one
                if (n / i == i && i != 1 && i != n)
                    ans.add((int)i);
                else {
                    if(i != 1 && i != n) ans.add((int)i);
                    if(n/i != 1 && n/i != n) ans.add((int)(n/i));
                }
            }
        }
        return ans;
    }
    public int minOperations(int[] nums) {
        List<PriorityQueue<Integer>> arr = new ArrayList<>();
        for(int val : nums) arr.add(printDivisors(val));
        // System.out.println(arr);
        int cnt = 0;

        for(int i=nums.length-2; i>=0; i--) {
            while( nums[i+1] < nums[i] ) {
                if(arr.get(i).size() == 0) return -1;
                int val = arr.get(i).poll();
                nums[i]/=val;
                cnt++;
            }
        }
        return cnt;
    }
}",1427856154
Nisarg Patel,Nisarg_Pat,759,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int count = 0;
        for(int i=0;i<s.length();i++) {
            int[] freq = new int[26];
            for(int j=i;j<s.length();j++) {
                freq[(int)(s.charAt(j)-'a')]++;
                if(leastK(freq, k)) {
                    count++;
                }
            }
        }
        return count;
    }

    private boolean leastK(int[] freq, int k) {
        for(int i=0;i<26;i++) {
            if(freq[i] >= k) {
                return true;
            }
        }
        return false;
    }
}",1427841745
Nisarg Patel,Nisarg_Pat,759,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> ans = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<target.length();i++) {
            int ch = (int)(target.charAt(i)-'a');
            for(int j = 0;j <= ch;j++) {
                ans.add(sb.toString()+String.valueOf((char)('a'+j)));
            }
            sb.append(target.charAt(i));
        }
        return ans;
    }
}",1427830341
Nisarg Patel,Nisarg_Pat,759,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        for(int i=nums.length-2;i>=0;i--) {
            if(nums[i] > nums[i+1]) {
                nums[i] = divide(nums[i]);
                count++;
                if(nums[i] > nums[i+1]) {
                    return -1;
                }
            }
        }
        return count;
    }

    private int divide(int n) {
        for(int i=2;i*i<=n;i++) {
            if(n%i==0) {
                return i;
            }
        }
        return n;
    }
}",1427856281
sundaramanand,sundaramanand,760,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string str, int k) {
        int n=str.length();
        int ans=0;
        for(int i=0;i<n;i++){
            map<char,int>mp;
            for(int j=i;j<n;j++){
            mp[str[j]]++;
            if(mp[str[j]]>=k) {ans+=n-j;break;}
            }
        }
        return ans;
    }
};",1427848994
sundaramanand,sundaramanand,760,3566,cpp,"class Solution {
public:
    vector<string>vec;
    void solve(string& x,int m,string &str){
        int n=x.length();
        if(n>=m) return ;
        for(int i=0;i<str[n]-'a';i++){
            char p='a'+i;
            vec.push_back(x+p);
        }
        x+=str[n];
        vec.push_back(x);
        solve(x,m,str);
    }
    vector<string> stringSequence(string t) {
        int n=t.length();
        string x="""";
        solve(x,n,t);
        return vec;
    }
};",1427843569
sundaramanand,sundaramanand,760,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        for(int i=n-2;i>=0;i--){
            if(nums[i]<=nums[i+1]) continue;
            for(int j=2;j*j<=nums[i];j++){
                if(nums[i]%j==0) {
                    nums[i]=j;break;
                }
            }
            if(nums[i]>nums[i+1]) {ans=-1;break;}
            ans++;
        }
        return ans;
    }
};",1427856282
Siddhapura Om,s1967,761,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length();
        vector<vector<int>>pre(n,vector<int>(26,0));
        for(int i=0;i<n;i++){
            for(int j=0;j<26;j++)pre[i][j]=(i!=0?pre[i-1][j]:0);
            pre[i][s[i]-'a']=1+pre[i][s[i]-'a'];
        }
        int ans=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                bool flag=false;
                for(int l=0;l<26;l++){
                    if(pre[i][l]-pre[j][l]>=k){
                        flag=true;
                        ans++;
                        break;      
                    }
                }
                if(!flag)break;
            }
             for(int l=0;l<26;l++){
                if(pre[i][l]>=k){
                    ans++;
                    break;       
                }
            }
        }
        return ans;
    }
};",1427837327
Siddhapura Om,s1967,761,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int len=target.length();
        vector<string>ans;
        string res;
        for(int i=0;i<len;i++){
            for(int j=0;j<=target[i]-'a';j++){
                char p=j+'a';
                string temp=res;
                temp+=p;
                ans.push_back(temp);
            }
            res+=target[i];
        }
        return ans;
    }
};",1427826112
Siddhapura Om,s1967,761,3607,cpp,"vector<int>prime(1e6+1);
class Solution {
public:
    int minOperations(vector<int>& nums) {
       int n=nums.size();
       int ans=0;
       if(!prime[2]){
            for(int i=2;i<=1e6;i++){
                if(prime[i])continue;
                prime[i]=i;
                for(int j=2*i;j<=1e6;j+=i){
                    if(!prime[j])prime[j]=i;
                }
            }
       }
       for(int i=n-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                if(nums[i]==prime[nums[i]])return -1;
                else {
                    nums[i]=prime[nums[i]];
                    if(nums[i]>nums[i+1])return -1;
                    else ans++;
                }
            }
       }
       return ans;
    }
};",1427856314
Nathen,nathentasty,762,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        ans = 0
        if k == 1:
            return len(s) * (len(s) + 1) // 2
            
        for left in range(len(s)):
            rec = defaultdict(int)
            rec[s[left]] += 1
            right = left + 1
            while right < len(s):
                rec[s[right]] += 1
                if rec[s[right]] == k:
                    ans += len(s) - right
                    break
                right += 1

        return ans",1427833858
Nathen,nathentasty,762,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        curr = """"
        for c in target:
            for i in range(ord('a'), ord(c) + 1):
                ans.append(curr + chr(i))
            curr += c

        return ans",1427824863
Nathen,nathentasty,762,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        r_nums = nums[::-1]
        ans = 0

        for i, num in enumerate(r_nums):
            if i and num > r_nums[i - 1]:
                r_nums[i] = self.getDivisor(num)
                if r_nums[i] > r_nums[i - 1]:
                    return -1
                ans += 1

        return ans


    def getDivisor(self, num):
        for d in range(2, int(sqrt(num)) + 1):
            if num % d == 0:
                return d
        return num",1427856445
Anish Mahale,Anish_28,763,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n  =s.size(),i,j,ans=0;

        for(i=0;i<n;i++){
            int mx = 0;
            unordered_map<char,int> mp;
            for(j=i;j<n;j++){
                mp[s[j]]++;
                if(mp[s[j]]>mx){
                    mx = mp[s[j]];
                }

                if(mx>=k){
                    ans++;
                }
            }
        }

        return ans;
    }
};",1427829784
Anish Mahale,Anish_28,763,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        int n =s.size(),i,j;

        vector<string> ans;
        string cur;

        for(i=0;i<n;i++){

            // if(!cur.size()){
            //     cur+='a';
            //     ans.push_back(cur);
            //     continue;
            // }

            for(char c='a';c<='z';c++){
                cur+=c;
                ans.push_back(cur);
                if(c==s[i]){
                    break;
                }
                cur.pop_back();
            }
        }

        return ans;
    }
};",1427826512
Anish Mahale,Anish_28,763,3607,cpp,"// ref : https://www.geeksforgeeks.org/least-prime-factor-of-numbers-till-n/

bool iscomputed = false;

vector<int> least_prime(1000001, 0);

void op()
{
    least_prime[1] = 1;
 
    for (long long i = 2; i <= 1000000; i++)
    {

        if (least_prime[i] == 0)
        {

            least_prime[i] = i;

            for (long long  j = i*i; j <= 1000000; j += i)
                if (least_prime[j] == 0)
                   least_prime[j] = i;
        }
    }
}

class Solution {
public:
    int minOperations(vector<int>& v) {
        if(!iscomputed){
            iscomputed = true;
            op();
        }

        int n = v.size(),i,ans= 0;

        for(i=n-2;i>=0;i--){
            if(v[i]>v[i+1]){
                ans++;
                if(least_prime[v[i]] == v[i]){
                    return -1;
                }

                if(least_prime[v[i]] > v[i+1]){
                    return -1;
                }

                v[i] = least_prime[v[i]];
            }
        }

        return ans;
    }
};",1427856482
B Rohith Reddy,rohith_bandi,766,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length(), count = 0;

        for (int i = 0; i < n; i++) {
            int[] freq = new int[26];
            for (int j = i; j < n; j++) {
                freq[s.charAt(j) - 'a']++;
                if (isValid(freq, k)) count++;
            }
        }

        return count;
    }

    private boolean isValid(int[] freq, int k) {
        for (int f : freq) {
            if (f >= k) return true;
        }
        return false;
    }
}
",1427832901
B Rohith Reddy,rohith_bandi,766,3566,java,"class Solution {
    public List<String> stringSequence(String t) {
        List<String> r = new ArrayList<>();
        StringBuilder s = new StringBuilder();

        for (char c : t.toCharArray()) {
            s.append('a');
            r.add(s.toString());

            while (s.charAt(s.length() - 1) != c) {
                char x = s.charAt(s.length() - 1);
                char y = (char)((x - 'a' + 1) % 26 + 'a');
                s.setCharAt(s.length() - 1, y);
                r.add(s.toString());
            }
        }

        return r;
    }
}",1427828325
B Rohith Reddy,rohith_bandi,766,3607,java,"class Solution {
    public int minOperations(int[] a) {
        int maxVal = 0;
        for (int num : a) {
            maxVal = Math.max(maxVal, num);
        }
        
        int[] gcd = new int[maxVal + 1];
        for (int i = 2; i <= maxVal; i++) {
            for (int j = 2 * i; j <= maxVal; j += i) {
                gcd[j] = i;
            }
        }

        int ops = 0;
        int n = a.length;

        for (int i = n - 2; i >= 0; i--) {
            while (a[i] > a[i + 1]) {
                int g = gcd[a[i]];
                if (g == 0) {
                    return -1;
                }
                a[i] /= g;
                ops++;
            }
        }
        return ops;
    }
}
",1427848754
Shaurya Malhan,Shaurya_Malhan,767,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int ans = 0;
        for(int i = 0; i < n; i++) {
            int[] freq = new int[26];
            int idx = n;
            for(int j = i; j < n; j++) {
                int l = s.charAt(j) - 'a';
                freq[l]++;
                if(freq[l] == k) {
                    idx = j;
                    break;
                }
            }
            ans += n - idx;            
        }
        return ans;
    }
}",1427833886
Shaurya Malhan,Shaurya_Malhan,767,3566,java,"class Solution {
    public List<String> stringSequence(String tt) {
        StringBuilder sb = new StringBuilder();
        List<String> list = new ArrayList<>();
        for(int i = 0; i < tt.length(); i++) {
            int l = tt.charAt(i) - 'a';
            for(int j = 0; j <= l; j++) {
                StringBuilder temp = new StringBuilder(sb);
                temp.append((char) ('a' + j));
                list.add(temp.toString());
            }
            sb.append(tt.charAt(i));
        }
        return list;
    }
}",1427827464
Shaurya Malhan,Shaurya_Malhan,767,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int ans = 0;
        for(int i = n - 2; i >= 0; i--) {
            int l = nums[i];
            int r = nums[i + 1];
            while(l > r) {
                int div = -1;
                for(int j = 2; j * j <= l; j++) {
                    if(l % j == 0) {
                        l /= (l / j);
                        div = 0;
                    }
                }
                if(div == -1) return -1;
                ans++;
            }
            nums[i] = l;
        }
        return ans;
    }
}",1427848771
Sujal Sahu,cookie_33,768,3502,java,"import java.util.HashMap;
import java.util.Map;

class Solution {

    public int numberOfSubstrings(String fruitString, int fruitK) {
        Map<Character, Integer> fruitMap = new HashMap<>();
        int fruitCounter = 0, fruitStart = 0, fruitAnswer = 0;

        for (int fruitEnd = 0; fruitEnd < fruitString.length(); fruitEnd++) {
            char fruitChar = fruitString.charAt(fruitEnd);

            // Call helper to update fruitMap and fruitCounter
            fruitMap = updateFruitMap(fruitMap, fruitChar);
            fruitCounter = updateFruitCounter(fruitMap, fruitChar, fruitK, fruitCounter);

            // Call helper to adjust window when fruitCounter is positive
            int[] adjustedValues = adjustWindow(fruitMap, fruitString, fruitStart, fruitCounter, fruitK);
            fruitStart = adjustedValues[0];
            fruitCounter = adjustedValues[1];

            fruitAnswer += fruitStart;
        }

        return fruitAnswer;
    }

    // Helper function to update fruitMap
    private Map<Character, Integer> updateFruitMap(Map<Character, Integer> fruitMap, char fruitChar) {
        fruitMap.put(fruitChar, fruitMap.getOrDefault(fruitChar, 0) + 1);
        return fruitMap;
    }

    // Helper function to update fruitCounter
    private int updateFruitCounter(Map<Character, Integer> fruitMap, char fruitChar, int fruitK, int fruitCounter) {
        if (fruitMap.get(fruitChar) == fruitK) {
            fruitCounter++;
        }
        return fruitCounter;
    }

    // Helper function to adjust window when fruitCounter is greater than 0
    private int[] adjustWindow(Map<Character, Integer> fruitMap, String fruitString, int fruitStart, int fruitCounter, int fruitK) {
        while (fruitCounter > 0) {
            char startChar = fruitString.charAt(fruitStart);
            if (fruitMap.get(startChar) == fruitK) {
                fruitCounter--;
            }
            fruitMap.put(startChar, fruitMap.get(startChar) - 1);
            fruitStart++;
        }
        return new int[]{fruitStart, fruitCounter};
    }
}
",1427855243
Sujal Sahu,cookie_33,768,3566,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<String> stringSequence(String s) {
        List<String> result = new ArrayList<>();
        StringBuilder currentString = new StringBuilder();
        
        for (int i = 0; i < s.length(); i++) {
            currentString.append('a');
            addToList(result, currentString.toString());
            
            while (!isMatchingLastChar(currentString, s.charAt(i))) {
                incrementLastChar(currentString);
                addToList(result, currentString.toString());
            }
        }
        return result;
    }

    // Function to check if last character of currentString matches the char at index
    private boolean isMatchingLastChar(StringBuilder currentString, char target) {
        return currentString.charAt(currentString.length() - 1) == target;
    }

    // Function to increment the last character in the currentString
    private void incrementLastChar(StringBuilder currentString) {
        currentString.setCharAt(currentString.length() - 1, (char) (currentString.charAt(currentString.length() - 1) + 1));
    }

    // Function to add current string to the result list
    private void addToList(List<String> list, String str) {
        list.add(str);
    }
}
",1427857176
Sujal Sahu,cookie_33,768,3607,java,"import java.util.*;

class Solution {

    public int minOperations(int[] fruits) {
        boolean[] primeBasket = new boolean[1000006];
        List<Integer> fruitPrime = new ArrayList<>();

        fruitPrime.add(2);
        for (long i = 3; i <= 1000003; i += 2) {
            if (!primeBasket[(int) i]) {
                fruitPrime.add((int) i);
                for (long j = i * i; j <= 1000000; j += 2 * i) {
                    primeBasket[(int) j] = true;
                }
            }
        }

        int appleCount = 0;
        for (int i = fruits.length - 2; i >= 0; i--) {
            if (fruits[i] > fruits[i + 1]) {
                appleCount++;
                for (int j = 0; fruitPrime.get(j) < fruits[i]; j++) {
                    if (fruits[i] % fruitPrime.get(j) == 0) {
                        fruits[i] = fruitPrime.get(j);
                        break;
                    }
                }
            }
            if (fruits[i] > fruits[i + 1]) return -1;
        }
        return appleCount;
    }
}
",1427852110
steve13814,steve13814,769,3502,cpp,"class Solution {
    bool MeetThreshold(vector<int>& count, int k) {
        for (int i = 0; i < 26; i++) {
            if (count[i] >= k) {
                return true;
            }
        }
        return false;
    }
public:
    int numberOfSubstrings(string s, int k) {
        int left = 0;
        int right = k - 2;
        vector<int> count(26);
        for (int i = 0; i < k - 1; i++) {
            count[s[i] - 'a']++;
        }

        int output = 0;
        while (true) {
            right++;
            if (right == s.size()) {
                break;
            }
            count[s[right] - 'a']++;
            while (MeetThreshold(count, k)) {
                output += s.size() - right;
                count[s[left] - 'a']--;
                left++;
            }
        }
        return output;
    }
};",1427844569
steve13814,steve13814,769,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> output;
        string buf;
        for (auto ch : target) {
            buf.append(1, 'a');
            output.push_back(buf);
            while (buf.back() != ch) {
                buf.back() = buf.back() + 1;
                output.push_back(buf);
            }
        }
        return output;
    }
};",1427829184
steve13814,steve13814,769,3607,cpp,"class Solution {
    int GetGreatestProperDivisor(int num) {
        for (int i = 2; i < num; i++) {
            if (num % i == 0) {
                return num / i;
            }
        }
        return -1;
    }
public:
    int minOperations(vector<int>& nums) {
        int output = 0;
        for (int i = nums.size() - 2; i >= 0; i--) {
            if (nums[i] <= nums[i + 1]) {
                continue;
            }
            int divisor = GetGreatestProperDivisor(nums[i]);
            if (divisor == -1) {
                return -1;
            }
            nums[i] /= divisor;
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
            output++;
        }
        return output;
    }
};",1427857186
Nishant Singh,nishant_7366,772,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.length();
        int i=0;
        int j=0;
        vector<int> freq(26,0);
        int sol=0;
        int t=0;

        while(j<n)
        {
            freq[s[j]-'a']++;
            if(freq[s[j]-'a']==k)
            t++;

            if(t>0)
            {
                while(t>0)
                {
                    sol+=(n-j);
                    freq[s[i]-'a']--;
                    if(freq[s[i]-'a']==(k-1))
                    t--;

                    i++;
                }
            }
            j++;
        }
        return sol;
    }
};",1427833763
Nishant Singh,nishant_7366,772,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> sol;
        string s=target;
        int n=s.length();
        string temp="""";
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=(s[i]-'a');j++)
            {
                string temp1=temp;
                temp1+=('a'+j);
                sol.push_back(temp1);
            }
            temp+=s[i];
        }
        return sol;
    }
};",1427827057
Nishant Singh,nishant_7366,772,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int sol=0;
        int n=nums.size();
        for(int i=n-2;i>=0;i--)
        {
            if(nums[i]<=nums[i+1])
            continue;

            int div=1;

            for(int j=2;j<=sqrt(nums[i]);j++)
            {
                if(nums[i]%j==0)
                div=max(div,max(j,nums[i]/j));
            }

            nums[i]=nums[i]/div;
            if(nums[i]>nums[i+1])
            return -1;
            else
            sol++;
        }
        return sol;
    }
};",1427849149
Anurag,Anurag_L,774,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size() , res = 0;
        for(int i=0;i<n;i++){
            map<char,int> m;
            bool b= 0;
            for(int j=i;j<n;j++){
                if(b){
                    res++;
                    continue;
                }
                m[s[j]]++;
                if(m[s[j]]==k){b=1;res++;}
            }
        }
        return res;
    }
};",1427830383
Anurag,Anurag_L,774,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string cur = """";
        while(cur!=target){
            if(cur.size()==0 || cur[cur.size()-1]==target[cur.size()-1])cur.push_back('a');
            else cur[cur.size()-1]+=1;
            res.push_back(cur);
        }
        return res;
    }
};",1427826204
Anurag,Anurag_L,774,3607,cpp,"class Solution {
public:
    
    unordered_map<int,int> m;

    int findGreatestDivisor(int n){
        if(m.find(n)!=m.end())return m[n];
        for(int i=2;i<=sqrt(n);i++){
            if(n%i==0){
                m[n]=n/i;
                return n/i;
            }
        }
        m[n]=1;
        return 1;
    }

    int findOperations(int &toSmall, int target){
        int res=0;
        while(toSmall>target){
            int div = findGreatestDivisor(toSmall);
            if(div==1)return -1;
            toSmall/=div;
            res++;
        }
        return res;
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size(), res = 0;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<=nums[i+1])continue;
            //cout<<nums[i]<<"" "";
            int op = findOperations(nums[i],nums[i+1]);
            //cout<<nums[i]<<"" ""<<op;
            if(op==-1)return -1;
            res+=op;
        }
        return res;
    }
};",1427849194
Krupakar Reddy,Krupakar-Reddy,776,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size(), ans = 0;

        for (int i = 0; i < n; ++i) {
            vector<int> freq(26, 0);

            for (int j = i; j < n; ++j) {
                freq[s[j] - 'a']++;

                for (int c : freq) {
                    if (c >= k) {
                        ans++;
                        break;
                    }
                }
            }
        }

        return ans;
    }
};",1427829166
Krupakar Reddy,Krupakar-Reddy,776,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string cur = """";

        for (int i = 0; i < target.size(); ++i) {
            if (i == 0) {
                cur += 'a';
                ans.push_back(cur);
            }
            else {
                cur += 'a';
                ans.push_back(cur);
            }

            while (cur.back() != target[i]) {
                cur.back() = (cur.back() - 'a' + 1) % 26 + 'a';
                ans.push_back(cur);
            }
        }
        
        return ans;
    }
};",1427827438
Krupakar Reddy,Krupakar-Reddy,776,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size(), count = 0;
        vector<int> arr = nums;
        
        for (int i = n - 2; i >= 0; --i) {
            while (arr[i] > arr[i + 1]) {
                int div = 1;
                
                for (int d = 2; d * d <= arr[i]; ++d) {
                    if (arr[i] % d == 0) {
                        div = max(div, d);
                        if (d * d != arr[i]) {
                            div = max(div, arr[i] / d);
                        }
                    }
                }
                
                if (div == 1) {
                    return -1;
                }
                
                arr[i] = arr[i] / div;
                count++;
                
                if (arr[i] <= arr[i + 1]) {
                    break;
                }
            }
        }
        
        return count;
    }
};",1427849289
Kushlovestocode,Kushlovestocode,777,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans = 0;
        vector<int> cnt(26,0);
        string a = """";
        for(int i = 0; i < n; i++)
        {
            for(int i = 0; i < 26; i++) cnt[i] = 0;
            a = """";
            int flag = 0;
            for(int j = i; j < n; j++)
            {
                cnt[s[j] - 'a']++;
                if(cnt[s[j] - 'a'] >= k) flag = 1;
                if(flag) ans++;
            }
        }
        return ans;
        
    }
};",1427837658
Kushlovestocode,Kushlovestocode,777,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string ans = """";
        vector<string> a;
        for(int i = 0; i < target.size(); i++)
        {
            ans += 'a';
            for(char j = 'a'; j <= target[i]; j++)
            {
                ans[ans.size() - 1] = j;
                a.push_back(ans);
            }
        }
        
        return a;
        
    }
};",1427825800
Kushlovestocode,Kushlovestocode,777,3607,cpp,"class Solution {
public:
    int greatestdiv(int x)
    {
        for(int i= 2; i * i <= x; i++)
        {
            if(x%i == 0) return x/i;
        }
        return 1;
    }
    bool isprime(int n)
    {
        for(int i = 2; i * i <= n; i++)
        {
            if(n%i == 0) return false;
        }
        return true;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        for(int i = n - 1; i > 0; i--)
        {
            if(nums[i - 1] > nums[i] && isprime(nums[i - 1])) 
                return -1;
            while(nums[i - 1] > nums[i])
            {
                nums[i - 1] /= greatestdiv(nums[i - 1]);
                ans++;
                if(nums[i - 1] > nums[i] && isprime(nums[i - 1])) 
                return -1;
            }
        }
        return ans;
        
    }
};",1427857532
vedantgore_2004,vedantgore_2004,778,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        int ans=0;
        for(int i=0;i<n;i++){
            vector<int> fr(26,0);
            for(int j=i;j<n;j++){
               fr[s[j]-'a']++;
               if(fr[s[j]-'a']>=k){
                ans+=(n-j);
                break;
               }
            }
        }
        return ans;
    }
};",1427839745
vedantgore_2004,vedantgore_2004,778,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        string t="""";
        vector<string> ans;
        for(int i=0;i<s.size();i++){
            t+='a';
            ans.push_back(t);
            while(t.back()!=s[i]){
                t.back()++;
                ans.push_back(t);
            }
        }
        return ans;
    }
};",1427829277
vedantgore_2004,vedantgore_2004,778,3607,cpp,"class Solution {
public:
    const int MAXN = 1000005;
    vector<int>& precompute() {
        static vector<int> spf(MAXN + 1, 0);
        static bool is_computed = false;
        if (!is_computed) {
            for (int i = 2; i <= MAXN; i++) {
                if (spf[i] == 0) {
                    for (int j = i; j <= MAXN; j += i) {
                        if (spf[j] == 0) {
                            spf[j] = i;
                        }
                    }
                }
            }
            is_computed = true;
        }
        return spf;
    }
    int minOperations(vector<int>& a) {
        vector<int> &spf=precompute();
        int n=a.size();
        int ans=0;
        for(int i=n-2;i>=0;i--){
            int z=a[i+1];
            while(a[i]>z && spf[a[i]]!=a[i]){
                int zz=a[i]/spf[a[i]];
                a[i]/=zz;
                ans++;
            }
            if(a[i]>z){
                return -1;
            }
        }
        return ans;
    }
};",1427857556
jason_wong1,jason_wong1,780,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            res += helper(s, i, k);
        }
        return res;
    }
    
    public int helper(String s, int start, int k) {
        int[] arr = new int[26];
        for (int i = start; i < s.length(); i++) {
            char c = s.charAt(i);
            int n = (int)(c - 'a');
            arr[n]++;
            if (arr[n] >= k) {
                return s.length() - i;
            }
        }
        return 0;
    }
}

// 0 1 2 3 4 5 6",1427832574
jason_wong1,jason_wong1,780,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        for (int i = 0; i < target.length(); i++) {
            char cur = target.charAt(i);
            for (char c = 'a'; c <= 'z'; c++) {
                sb.append(c);
                res.add(new String(sb));
                sb.deleteCharAt(sb.length() - 1);
                if (cur == c) {
                    sb.append(c);
                    break;
                }
            }
        }
        return res;
    }
}",1427826035
jason_wong1,jason_wong1,780,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int res = 0;
        for (int i = nums.length - 1; i > 0; i--) {
            int pre = nums[i - 1];
            int cur = nums[i];
            while (pre > cur) {
                int fac = largestFactor(pre);
                if (fac == 1) {
                    return -1;
                }
                pre = pre / fac;
                nums[i - 1] = pre;
                res++;
            }
        }
        return res;
    }
    
    public int largestFactor(int n) {
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                return n / i;
            }
        }
        return 1;
    }
}",1427849394
Makrrr,user8059u,781,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int cnt = 0;
        for (int i = 0; i < s.size(); i++) {
            unordered_map<char, int> freq;
            for (int j = i; j < s.size(); j++) {
                freq[s[j]]++;
                if (freq[s[j]] >= k) {
                    cnt += s.size() - j;
                    break;
                }
            }
        }
        return cnt;
    }
};",1427838491
Makrrr,user8059u,781,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> res;
        string curr = """";
        for (char c : target) {
            char tmp = 'a';
            while (tmp != c) {
                res.push_back(curr + tmp);
                tmp++;
                
            }
            res.push_back(curr + tmp);
            curr = curr + tmp;
        }
        return res;
    }
};",1427829501
Makrrr,user8059u,781,3607,cpp,"class Solution {
public:
    int f(int n) {
        for (int i = 2; i < n; i++) {
            if ((n / i) * i == n) return n / i;
        }
        return -1;
    }
    int minOperations(vector<int>& nums) {
        int cnt = 0;
        for (int i = nums.size() - 2; i >= 0; i--) {
            int prev = nums[i + 1];
            while (nums[i] > prev) {
                int gpd = f(nums[i]);
                if (gpd == -1) return -1;
                nums[i] /= gpd;
                // cout << nums[i] << endl;
                cnt++;
            }
        }
        return cnt;
    }
};",1427849400
ABHAY SINGH,AbhayAnilark,782,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
       
        int n=s.size(),ans=0;

        for(int i=0;i<n;i++){
            vector<int>a(26,0);
            int x=0;
            for(int j=i;j<n;j++){
                a[s[j]-'a']++;
                if(a[s[j]-'a']>=k){x=1;}
                if(x==1){ans++;} }
        }


        return ans;

        
    }
};",1427830056
ABHAY SINGH,AbhayAnilark,782,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string x) {
        vector<string>ans;
        string p;
        for(int i=0;i<x.size();i++){
            p+='a';
            ans.push_back(p);
            for(int j=1;j<=x[i]-'a';j++){
                p.back()+=1;
                ans.push_back(p);
            }

        }
        return ans;

        
    }
};",1427824889
ABHAY SINGH,AbhayAnilark,782,3607,cpp,"class Solution {
public:
    int calc(int x){
        int p=-1;
        for(int j=2;j*j<=x;j++){
            if(x%j==0){
                // cout<<j<<"" ""<<x/j<<endl;
                p=max(p,max(j,x/j));}}
        return p; }


    int minOperations(vector<int>& a) {
        int ans=0,n=a.size();
        for(int i=n-2;i>=0;i--){

            while( a[i]>a[i+1] ){
                ans++;
                int x=calc(a[i]);
                // cout<<ans<<"" ""<<x<<endl;
                if(x==-1){return -1;}
                a[i]=a[i]/x; }

        }
        return ans;
        
    }
};",1427849633
Rushil,Rushil10,783,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();

        int[] arr = new int[26];
        int index = 0;
        int left = 0;

        int ans = 0;
        while(index < n) {
            int c = s.charAt(index) - 'a';
            arr[c]++;
            while(left<=index && check(arr, k)) {
                ans += (n - index);
                int ch = s.charAt(left) - 'a';
                left++;
                arr[ch]--;
            }
            index++;
        }

        return ans;
    }

    public boolean check(int[] arr, int k) {
        for(int i=0; i<26; i++) {
            if(arr[i] >= k) {
                return true;
            }
        }
        return false;
    }
}",1427840134
Rushil,Rushil10,783,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        int n = target.length();
        List<String> li = new ArrayList<>();

        if(n==0) return li;

        StringBuilder sb = new StringBuilder();
        sb.append(""a"");
        li.add(sb.toString());

        int index = 0;
        while(index < n) {
            if(sb.charAt(index) != target.charAt(index)) {
                int val = sb.charAt(index) - 'a';
                val++;
                char next = (char) (val + 'a');
                sb.setCharAt(index, next);
                li.add(sb.toString());
            } else {
                index++;
                if(index < n) {
                    sb.append(""a"");
                    li.add(sb.toString());
                }
            }
        }
        return li;
    }
}",1427830415
Rushil,Rushil10,783,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int n = nums.length;
        int ans = 0;
        int[] arr = new int[n];

        for(int i=0; i<n; i++) {
            int d = findGreatestDivisor(nums[i]);
            arr[i] = nums[i] / d;
        }

        for(int i=n-1; i>=1; i--) {
            if(nums[i] >= nums[i-1]) continue;
            else {
                nums[i-1] = arr[i-1];
                if(nums[i-1] > nums[i]) return -1;
                ans++;
            }
        }

        return ans;
    }

    public int findGreatestDivisor(int n) {
        int maxDivisor = 1; // Start with the smallest possible divisor

        for (int i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                // i is a divisor
                if (i != n) {
                    maxDivisor = Math.max(maxDivisor, i);
                }
                // n / i is also a divisor
                int otherDivisor = n / i;
                if (otherDivisor != n) {
                    maxDivisor = Math.max(maxDivisor, otherDivisor);
                }
            }
        }

        return maxDivisor;
    }
}",1427857995
Maharsh Patel,SoulMan,784,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        
        int ans = 0;
        for(int i=0; i<s.size(); i++){
            vector<int> v(26, 0);
            int f = -1;
            for(int j=i; j<s.size(); j++){
                v[s[j]-'a']++;
                for(int x=0; x<26; x++){
                    if(v[x] >= k){
                        f = j;
                        break;
                    }
                }
                if(f != -1) break;
            }
            if(f != -1) ans += (s.size() - f);
        }

        return ans;
    }
};",1427839388
Maharsh Patel,SoulMan,784,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        
        vector<string> ans;
        string s;
        for(int i=0; i<target.size(); i++){
            s += 'a';
            ans.push_back(s);
            while(s[s.size()-1] != target[i]){
                s[s.size()-1]++;
                ans.push_back(s);
            }
        }

        return ans;
    }
};",1427826784
Maharsh Patel,SoulMan,784,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        
        int n = nums.size(), ans = 0;
        for(int i=n-2; i>=0; i--){
            while(nums[i] > nums[i+1]){
                int j = 2;
                for (; j*j<=nums[i]; j++)
                {
                    if (nums[i] % j == 0)
                    {
                        break;
                    }
                }
                if(j*j <= nums[i]){
                    nums[i] = j;
                    ans++;
                }
                else{
                    return -1;
                }
            }
        }

        return ans;
    }
};",1427858216
Lucas,rayms,785,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length(), ans = 0;
        for (int i = 0, valid = 0; i < n; i ++, valid = 0) {
            int[] count = new int[128];
            for (int j = i; j < n; j ++) {
                if (++ count[s.charAt(j)] == k) {
                    valid = 1;
                }
                ans += valid;
            }
        }
        return ans;
    }
}",1427836069
Lucas,rayms,785,3566,java,"class Solution {
    public List<String> stringSequence(String t) {
        int n = t.length();
        StringBuilder sb = new StringBuilder();
        List<String> ans = new ArrayList<>();
        for (int i = 0; i < n; i ++) {
        // for (char c : t.toCharArray()) {
            sb.append('a');
            ans.add(sb.toString());
            while (sb.charAt(i) != t.charAt(i)) {
                sb.setCharAt(i, (char)(sb.charAt(i) + 1));
                ans.add(sb.toString());
            }
        }
        return ans;
    }
}",1427830268
Lucas,rayms,785,3607,java,"class Solution {
    
    static int MX = 1_000_000;
    static int[] gf = new int[MX + 1];
    
    static {
        for (int f = 1; f <= MX; f ++) {
            for (int v = f + f; v <= MX; v += f) {
                gf[v] = f;
            }
        }
    }
    
    public int minOperations(int[] nums) {
        int n = nums.length, ans = 0;
        for (int i = n - 2; i >= 0; i --) {
            while (nums[i] > nums[i + 1]) {
                // System.out.println(i + "" "" + nums[i]);
                int f = gf[nums[i]];
                if (f == 0 || f == 1) {
                    return -1;
                }
                nums[i] /= f;
                ans ++;
            }
            if (nums[i] > nums[i + 1]) {
                return -1;
            }
        }
        return ans;
    }
}",1427858289
thedude7181,thedude7181,786,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res = 0
        cnts = Counter()
        right = -1
        for left in range(len(s)):
            while not any(cnt >= k for cnt in cnts.values()):
                right += 1
                if right == len(s):
                    return res
                cnts[s[right]] += 1
            res += len(s) - right
            cnts[s[left]] -= 1
        return res
            ",1427840314
thedude7181,thedude7181,786,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = [""a""]
        cur = [""a""]
        while len(cur) < len(target) or target[-1] != cur[-1]:
            if cur[-1] == target[len(cur) - 1]:
                cur.append(""a"")
            else:
                prev = cur.pop()
                cur.append(chr(ord(prev) + 1))
            res.append("""".join(cur))
        return res
            ",1427828637
thedude7181,thedude7181,786,3607,python3,"def get_primes(n):
    # get a list of all primes upto (inclusive) n 
    n = n + 1
    primes = [True] * n
    primes[0] = primes[1] = False
    for i in range(3, int(n ** 0.5) + 1):
        if primes[i]:
            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])
    primelist = [2] + [i for i in range(3, n, 2) if primes[i]]
    return primelist

primes = get_primes(1_000_001)
primes_set = set(primes)



class Solution:
    def minOperations(self, nums: List[int]) -> int:
        mx = float(""inf"")
        res = 0
        for num in reversed(nums):
            #print(num, mx)
            if num > mx and num not in primes_set:
                for p in primes:
                    if num % p == 0:
                        num = p
                        res += 1
                        break
            if num > mx:
                print(""e"", num)
                return -1
            mx = num
        return res
            
                    
                ",1427858306
Shubham Varshney,shubhamvarshney2000,787,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
            int n = s.length();
    int result = 0;

    for (int i = 0; i < n; i++) {
        unordered_map<char, int> freq;
        for (int j = i; j < n; j++) {
            freq[s[j]]++;
            bool valid = false;
            for (auto &p : freq) {
                if (p.second >= k) {
                    valid = true;
                    break;
                }
            }
            if (valid) result++;
        }
    }

    return result;

    }
};",1427827412
Shubham Varshney,shubhamvarshney2000,787,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> result;
        string current = """";
        char last = 'a';

        for (char c : target) {
            while (last != c) {
                result.push_back(current + last);
                last = (last == 'z') ? 'a' : last + 1;
            }
            current += c;
            result.push_back(current);
            last = 'a';
        }

        return result; 

    }
};",1427831381
Shubham Varshney,shubhamvarshney2000,787,3607,cpp,"    #include <bits/stdc++.h>

    // #include <ext/pb_ds/assoc_container.hpp>
    // #include <ext/pb_ds/tree_policy.hpp>
    // using namespace __gnu_pbds;
    // typedef tree<int, null_type, greater_equal<int>, rb_tree_tag,
    //              tree_order_statistics_node_update>
    //     oset;
    // https://leetcode.com/problems/time-taken-to-mark-all-nodes/submissions/1382291160/
    using namespace std;

    #define nl endl
    #define ar array
    #define ll long long
    #define ld long double
    #define sza(x) ((int)x.size())
    #define all(a) (a).begin(), (a).end()
    #define printy cout<<""Yes""<<endl;
    #define printn cout<<""No""<<endl;
    const int MAX_N = 1e5 + 5;
    // const ll MOD = 1e9 + 7;
    const int mod = 1e9+7;
    const ll INF = 1e9;
    const ld EPS = 1e-9;
    const int MOD = 1e9 + 7;
    vector<long long> factorial;
    vector<long long> inv_factorial;

    long long pow_m(long long base, long long exp, long long mod) {
        long long result = 1LL;
        base = (base % mod);
            
        while (exp > 0) {
            if ((exp & 1LL) == 1LL) result = (result * base) % mod;
            exp >>= 1LL;
            base = (base * base) % mod;
        }
        return result;

    }
    
    // fenwick tree/binary index tree
    template <typename T>
    class fenwick {
        public:
        vector<T> fenw;
        int n;

        // Constructor for initialization of size 
        fenwick(int _n) : n(_n + 1) {
            fenw.resize(n);
        }

        // to modify , add or replace value at index x
        void modify(int x, T v) {
            while (x <= n) {
            fenw[x] += v;
            x += (x & -x);
            }
        }

        // To get sum of prefix ending at x
        T get(int x) {
            T v{};
            while (x > 0) {
                v += fenw[x];
                x -= (x & -x);
            }
            return v;
        }
    };
    
    // Segment tree
    class SegmentTree{
        public:
        ll n;
        vector<ll> seg,lazy;

        SegmentTree(int _n,vector<int> a){
            n = _n;
            seg.resize(4*n+1);
            lazy.resize(4*n+1,0);
            build(0,0,n-1,a);
        }

        void build(int ind,int low,int high,vector<int> &a){
            if(low == high){
                seg[ind] = a[low];
                return;
            }
            ll mid = (low+high)/2;
            build(2*ind+1,low,mid,a);
            build(2*ind+2,mid+1,high,a);
            seg[ind] = seg[2*ind+1]+seg[2*ind+2];
        }

        void pointupdate(int ind,int low,int high,int i,int val){
            if(lazy[ind]!=0){
                seg[ind] += (high-low+1)*lazy[ind];
                if(low!=high){
                    lazy[2*ind+1] += lazy[ind];
                    lazy[2*ind+2] += lazy[ind];
                }
                lazy[ind] = 0;
            }
            if(low == high){
                seg[ind] = val;
                return ;
            }
            int mid = (low+high)/2;
            if(i<=mid){
                pointupdate(2*ind+1,low,mid,i,val);
            }
            else{
                pointupdate(2*ind+2,mid+1,high,i,val);
            }
            seg[ind] =seg[2*ind+1]+seg[2*ind+2];
        }
        
        void rangeupdate(int ind,int low,int high,int l,int h,int val){
            if(lazy[ind]!=0){
                seg[ind] += (high-low+1)*lazy[ind];
                if(low!=high){
                    lazy[2*ind+1] += lazy[ind];
                    lazy[2*ind+2] += lazy[ind];
                }
                lazy[ind] = 0;
            }
            if(h<low || high<l){
                return;
            }
            if(low>=l && high<=h){
                seg[ind] += (high-low+1)*val;
                if(low!=high){
                    lazy[2*ind+1] += val;
                    lazy[2*ind+2] += val;
                }
                return;
            }
            int mid = (low+high)/2;
            rangeupdate(2*ind+1,low,mid,l,h,val);
            rangeupdate(2*ind+2,mid+1,high,l,h,val);
            seg[ind] = seg[2*ind+1]+seg[2*ind+2];
        }
        
        ll rangequery(int ind,int low,int high,int l,int h){
            if(lazy[ind]!=0){
                seg[ind] += (high-low+1)*lazy[ind];
                if(low!=high){
                    lazy[2*ind+1] += lazy[ind];
                    lazy[2*ind+2] += lazy[ind];
                }
                lazy[ind] = 0;
            }
            if(h<low || high<l){
                return 0;
            }
            if(low>=l && high<=h){
                return seg[ind];
            }
            ll mid = (low+high)/2;
            ll left = rangequery(2*ind+1,low,mid,l,h);
            ll right = rangequery(2*ind+2,mid+1,high,l,h);
            return right+left;
        }

    };
    
    class SegmentTreeLazy{
    public:
    ll n;
    vector<ll> seg,lazy;

    SegmentTreeLazy(int _n,vector<int> a){
        n = _n;
        seg.resize(4*n+1);
        lazy.resize(4*n+1,0);
        build(0,0,n-1,a);
    }

    void build(int ind,int low,int high,vector<int> &a){
        if(low == high){
            seg[ind] = a[low];
            return;
        }
        ll mid = (low+high)/2;
        build(2*ind+1,low,mid,a);
        build(2*ind+2,mid+1,high,a);
        seg[ind] = seg[2*ind+1]+seg[2*ind+2];
    }

    void pointupdate(int ind,int low,int high,int i,int val){
        if(lazy[ind]!=0){
            seg[ind] += (high-low+1)*lazy[ind];
            if(low!=high){
                lazy[2*ind+1] += lazy[ind];
                lazy[2*ind+2] += lazy[ind];
            }
            lazy[ind] = 0;
        }
        if(low == high){
            seg[ind] = val;
            return ;
        }
        int mid = (low+high)/2;
        if(i<=mid){
            pointupdate(2*ind+1,low,mid,i,val);
        }
        else{
            pointupdate(2*ind+2,mid+1,high,i,val);
        }
        seg[ind] =seg[2*ind+1]+seg[2*ind+2];
    }
    
    void rangeupdate(int ind,int low,int high,int l,int h,int val){
        if(lazy[ind]!=0){
            seg[ind] += (high-low+1)*lazy[ind];
            if(low!=high){
                lazy[2*ind+1] += lazy[ind];
                lazy[2*ind+2] += lazy[ind];
            }
            lazy[ind] = 0;
        }
        if(h<low || high<l){
            return;
        }
        if(low>=l && high<=h){
            seg[ind] += (high-low+1)*val;
            if(low!=high){
                lazy[2*ind+1] += val;
                lazy[2*ind+2] += val;
            }
            return;
        }
        int mid = (low+high)/2;
        rangeupdate(2*ind+1,low,mid,l,h,val);
        rangeupdate(2*ind+2,mid+1,high,l,h,val);
        seg[ind] = seg[2*ind+1]+seg[2*ind+2];
    }
    
    ll rangequery(int ind,int low,int high,int l,int h){
        if(lazy[ind]!=0){
            seg[ind] += (high-low+1)*lazy[ind];
            if(low!=high){
                lazy[2*ind+1] += lazy[ind];
                lazy[2*ind+2] += lazy[ind];
            }
            lazy[ind] = 0;
        }
        if(h<low || high<l){
            return 0;
        }
        if(low>=l && high<=h){
            return seg[ind];
        }
        ll mid = (low+high)/2;
        ll left = rangequery(2*ind+1,low,mid,l,h);
        ll right = rangequery(2*ind+2,mid+1,high,l,h);
        return right+left;
    }

};

    // Trie implementation 
    class Node{
        public:
        
        Node* links[26];
        int t[26] = {0};
        bool flag = false;

        bool containskey(char ch){
            return links[ch-'a'] != nullptr;
        }

        Node* get(char ch){
            return links[ch-'a'];
        }

        void put(char ch,Node* node){
            links[ch-'a'] = node;

        }

        void setEnd(){
            flag = true;
        }

        bool isEnd(){
            return flag == true;
        }
    };
    
    class Trie {
    public:
        Node* root;
        Trie() {
            root = new Node();
        }
        
        void insert(string word) {
            Node* node = root;
            for(int i=0;i<word.size();i++){
                if(!node->containskey(word[i])){
                    node->put(word[i],new Node());
                }
                node = node->get(word[i]);
            }
            node->setEnd();
        }
        
        bool search(string word) {
            Node* node = root;
            for(int i=0;i<word.size();i++){
                if(!node->containskey(word[i])){
                    return false;
                }
                node = node->get(word[i]);
            }
            return node->isEnd();
        }
        
        bool startsWith(string prefix) {
            Node* node = root;
            for(int i=0;i<prefix.size();i++){
                if(!node->containskey(prefix[i])){
                    return false;
                }
                node = node->get(prefix[i]);
            }
            return true;
        }
    };

    // DSU 
    class DSU{
    public:
    vector<int> parent,rank,size;
    
    DSU(int n){
        for(int i=0;i<n;i++){
            parent.push_back(i);
            rank.push_back(0);
            size.push_back(1);
        }
    }
    int findpar(int x){
        if(x == parent[x]){
            return x;
        }
        return parent[x] = findpar(parent[x]);
    }
    bool union_(int x,int y){
        int parx = findpar(x);
        int pary = findpar(y);
        if(parx == pary){
            return true;
        }
        if(rank[parx]>rank[pary]){
            parent[pary] = parx;
        }
        else if(rank[parx]<rank[pary]){
            parent[pary] = parx;
        }
        else{
            rank[parx]++;
            parent[pary] = parx;
        }
        return false;
    }
    bool unionbysize(int x,int y){
        int parx = findpar(x);
        int pary = findpar(y);
        if(parx == pary){
            return true;
        }
        if(size[parx]>=size[pary]){
            parent[pary] = parx;
            size[parx] += size[pary];
        }
        else{
            parent[parx] = pary;
            size[pary] += size[parx];
        }
        return false;
    }
};


   class TreeAncestor {
        public:
        vector<vector<int>> vec;
        vector<int> depth;
        int h = 18;
        int n;
        TreeAncestor(int _n, vector<int>& parent) {
            n = _n;
            depth.resize(n,0);
            vec.resize(h,vector<int>(n+1,-1));
            vector<vector<int>> g(n+1);
            for(int i=1;i<n;i++){
                int p = parent[i];
                g[p].push_back(i);
                g[i].push_back(p);
            }
            dfs(0,-1,g);
            for(int i=0;i<n;i++){
                vec[0][i] = parent[i];
            }
            for(int i=1;i<h;i++){
                for(int j=0;j<n;j++){
                    if(vec[i-1][j] != -1)
                        vec[i][j] = vec[i-1][vec[i-1][j]];
                }
            }
        }
        
        int getKthAncestor(int node, int k) {
            for(int i=h-1;i>=0;i--){
                if(k&(1<<i)){
                    node = vec[i][node];
                    if(node == -1){
                        return -1;
                    }
                }
            }
            return node;
        }
        int lca(int a, int b)
        {
            // cout<<depth[a]<<"" ""<<depth[b]<<endl;
            if(depth[a] < depth[b])
                swap(a, b);
            // cout<<depth[a]<<"" ""<<depth[b]<<endl;
            int diff = depth[a] - depth[b];
            for(int i = 17; i >=0; i--)
                if(diff & (1 << i))
                    a = vec[i][a];

            if(a == b)
                return a;
            // cout<<a<<"" ""<<b<<endl;
            // cout<<depth[a]<<"" ""<<depth[b]<<endl;
            for(int i = 15; i >= 0; i--)
            {
                if(vec[i][a] != vec[i][b])
                {
                    a = vec[i][a];
                    b = vec[i][b];
                }
            }

            return vec[0][a];
        }
        void dfs(int src, int paren,vector<vector<int>> &g)
        {
            for(auto x : g[src])
            {
                if(x == paren)
                    continue;
                depth[x] = depth[src] + 1;
                dfs(x, src,g);
            }
        }
    };
  
    ll gcd(ll a,ll b) {
        if(b == 0) return a;
        return gcd(b, a % b);
    }
    
    ll lcm(ll a,ll b) {
        return (a / gcd(a,b)) * b;
    }

    int kmp(string txt, string pat) {
        int n = pat.size();
        vector<int> lps(n,0);
        int len = 0;
        lps[0] = 0;
        int i = 1;
        while(i<n){
            if(pat[i] == pat[len]){
                len++;
                lps[i] = len;
                i++;
            }
            else{
                if(len !=0){
                    len = lps[len-1];
                }
                else{
                    i = i+1;
                }
            }
        }
        int m = txt.size();
        int j=0;
        i = 0;
        while(i<m){
            if(txt[i] == pat[j]){
                i++;
                j++;
            }
            if(j == n){
                j = lps[j-1];
                // return j;
            }
            else if(i<m && txt[i] != pat[j]){
                if(j != 0){
                    j = lps[j-1];
                }
                else{
                    i++;
                }
            }
        }
        return -1;
    }
  
    vector<int> zfunction(string s){
        int n = s.size();
        vector<int> z(n,0);
        int l=0,r=0;
        for(int k=1;k<n;k++){
            if(k>r){
                l = k;
                r = k;
                while(r<n && s[r-l] == s[r]){
                    r++;
                }
                z[k] = r-l;
                r--;
            }
            else {
                int k1 = k-l;
                if(z[k1]<r-k+1){
                    z[k] = z[k1];
                }
                else{
                    l = k;
                    while(r<n && s[r-l] == s[r]){
                        r++;
                    }
                    z[k] = r-l;
                    r--;
                }
            }
        }
        return z;
    }
    bool isPrime(ll n) {
        if(n == 1) return false;
        for(ll i = 2; i <= sqrt(n); i++) {
            if(n % i == 0) return false;
        }
        return true;
    }
    
    ll countSetBits(ll n) {
        ll ans = 0;
        while(n) {
            ans++;
            n = n & (n - 1);
        }
        return ans;
    }
    
    void dfs1(int node,int par,vector<vector<int>> &g,vector<int> &vis,stack<int> &st){
        if(vis[node] == 1){
            return ;
        }
        vis[node] = 1;
        for(auto x:g[node]){
            if(x!=par){
                dfs1(x,node,g,vis,st);
            }
        }
        st.push(node);
    }
    
    void dfs2(int node,int par,vector<vector<int>> &g,vector<int> &vis,vector<int> &st,int cnt){
    if(vis[node] == 1){
        return ;
    }
    vis[node] = 1;
    st.push_back(node);
    for(auto x:g[node]){
        if(x!=par){
            dfs2(x,node,g,vis,st,cnt);
        }
    }
}


    vector<ll> primeFactorization(ll n) {
        vector<ll> factors;
        for(ll i = 2; i * i <= n; i++) {
            ll cnt = 0; 
            while(n % i == 0) {
                cnt++;
                n /= i;
                factors.push_back(i);
            }
        }
        if(n > 1) factors.push_back(n);
        return factors;
    }
    
    bool isPalindrome(string s) {
        ll i = 0;
        ll j = s.size() - 1;
        while(i <= j) {
            if(s[i] != s[j]) return false;
            i++;
            j--;
        }
        return true;
    }
    

    // Function to compute x^y under modulo m
    long long mod_pow(long long x, long long y, long long m) {
        long long result = 1;
        while (y > 0) {
            if (y % 2 == 1) {
                result = (result * x) % m;
            }
            x = (x * x) % m;
            y /= 2;
        }
        return result;
    }
    
    // Function to ensure that factorials and inverse factorials are precomputed up to n
    void ensure_factorials(ll n) {
        if (factorial.size() > n) {
            return;
        }
        int start = factorial.size();
        factorial.resize(n + 1);
        inv_factorial.resize(n + 1);

        factorial[0] = 1;
        for (int i = std::max(1, start); i <= n; ++i) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
        }

        inv_factorial[n] = mod_pow(factorial[n], MOD - 2, MOD);
        for (int i = n - 1; i >= start; --i) {
            inv_factorial[i] = (inv_factorial[i + 1] * (i + 1)) % MOD;
        }
    }
    
    // Function to compute nCr % MOD
    long long nCr(ll n, ll r) {
        if (r > n) {
            return 0;
        }
        
        return (factorial[n] * inv_factorial[r] % MOD * inv_factorial[n - r] % MOD) % MOD;
    }

    void h1(ll node,ll par,vector<vector<ll>> &g,vector<ll> &dp,vector<ll> &dis,ll d){
            int cnt = 0;
            dis[node] = d;
            for(auto x:g[node]){
                if(x!= par){
                    h1(x,node,g,dp,dis,d+1);
                    cnt++;
                }
            }
            if(cnt == 0){
                dp[node] = 0;
                return;
            }
            dp[node] = 0;
            for(auto x:g[node]){
                if(x!=par){
                    dp[node] = max(dp[node],dp[x]);
                }
            }
            dp[node]++;
        }
    
    void h2(ll node,ll par,vector<vector<ll>> &g,vector<ll> &aux,vector<ll> &dp){
            if(par == -1){
                dp[node] = 0;
            }
            vector<pair<int,int>> v;
            for(auto x:g[node]){
                if(x!=par){
                    v.push_back({aux[x],x});
                }
            }
            v.push_back({dp[node],-1});
            sort(v.rbegin(),v.rend());
            for(auto x:g[node]){
                if(x!= par){
                    if(v.size() == 1){
                        dp[x] = 1 + v[0].first;
                    }
                    else{
                        if(v[0].second != x){
                            if(v[0].second == -1){
                                dp[x] = 1 + v[0].first;
                            }
                            else{
                                dp[x] = 2 + v[0].first;
                            }
                        }
                        else{
                            if(v[1].second == -1){
                                dp[x] = 1+v[1].first;
                            }
                            else{
                                dp[x] = 2+v[1].first;
                            }
                        }
                    }
                }
            }
            for(auto x:g[node]){
                if(x!=par){
                    h2(x,node,g,aux,dp);
                }
            }
        }
    

    void solve() {
        ll n,x;
        cin>>n>>x;
        map<int,int> mp;
        ll a[n];
        for(int i=0;i<n;i++){
            cin>>a[i];
        }
        for(int i=0;i<n;i++){
            mp[a[i]]++;
        }
        int cnt = 0;
        for(auto y:mp){
            if(mp[cnt]>0){
                mp[y.first]--;
                cnt++;
                mp[y.first+x] += mp[y.first];
            }
            else{
                cout<<cnt<<endl;
                return;
            }
        }
        cout<<cnt<<endl;
    }
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;

        for (int i = n - 2; i >= 0; i--) {
            if (nums[i] > nums[i + 1]) {
                while (nums[i] > nums[i + 1]) {
                    int divisor = 1;
                    for (int j = 2; j*j <= nums[i]; j++) {
                        if (nums[i] % j == 0) {
                            divisor = max({divisor, nums[i] / j,j});
                        }
                    }
                    if (divisor == 1) return -1;
                    nums[i] = nums[i]/divisor;
                    ans++;
                }
            }
        }
        return ans;
    }
};",1427850192
zanzan,zanzan13531,789,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        char[] chars;
        int num = 0;
        for (int i = 0; i < s.length(); i++) {
            chars = new char[26];
            for (int j = i; j < s.length(); j++) {
                chars[s.charAt(j) - 'a']++;
                for (int x = 0; x < 26; x++) {
                    if (chars[x] >= k) {
                        num++;
                        break;
                    }
                }
            }
        }
        return num;
    }
}",1427858473
zanzan,zanzan13531,789,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        String fin = """";
        ArrayList<String> thing = new ArrayList<String>();
        for (int i = 0; i < target.length(); i++) {
            char c = 'a';
            while (c != target.charAt(i)) {
                String temp = fin + c;
                c++;
                thing.add(temp);
            }
            fin = fin + c;
            thing.add(fin);
        }
        return thing;
    }
}",1427831983
zanzan,zanzan13531,789,3607,java,"class Solution {
    public int minOperations(int[] nums) {
        int max = nums[nums.length - 1];
        int operations = 0;
        for (int i = nums.length - 2; i >= 0; i--) {
            int temp = nums[i];
            if (temp > max) {
                while (temp > max) {
                    int div = divisor(temp);
                    if (div == temp || div == 1) {
                        return -1;
                    }
                    temp = temp / div;
                    operations++;
                }
            }
            max = temp;
        }

        return operations;

    }

    private int divisor(int number) {
        int i;
        for (i = 2; i <= Math.sqrt(number); i++) {
            if (number % i == 0) {
                return number/i;
            }
        }
        return 1;
    }
}",1427852875
Vishal Patil,incognito123,791,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int K) {
        int n=s.size();
        int freq[n][26];
        memset(freq,0,sizeof(freq));
        for(int i=0;i<n;i++){
            for(int j=0;j<26;j++){
                if(i) freq[i][j]=freq[i-1][j];
            }
            freq[i][s[i]-'a']+=1;
        }
        int ans=0;
        for(int i=1;i<=n;i++){
            for(int j=0;j<n;j++){
                if(j+i>n) break;
                bool flag=false;
                for(int k=0;k<26;k++){
                    int fks=freq[j+i-1][k];
                    if(j) fks-=freq[j-1][k];
                    if(fks>=K) flag=true;
                }
                ans+=flag;
            }
        }
        return ans;
    }
};",1427833466
Vishal Patil,incognito123,791,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string s="""";
        vector<string> ans;
        for(auto p:target){
            char fk='a';
            for(int i=0;i<26;i++){
                string s1=s;
                s1+=fk;
                ans.push_back(s1);
                if(fk==p){
                    break;
                }
                fk++;
            }
            s+=p;
        }
        return ans;
    }
};",1427825718
Vishal Patil,incognito123,791,3607,cpp,"
const int N = 1000000;
vector<int> lp(N+1);
vector<int> pr;

class Solution {
public:
    

    void prime(){
        if(!pr.empty()) return;
        for (int i=2; i <= N; ++i) {
            if (lp[i] == 0) {
                lp[i] = i;
                pr.push_back(i);
            }
            for (int j = 0; i * pr[j] <= N; ++j) {
                lp[i * pr[j]] = pr[j];
                if (pr[j] == lp[i]) {
                    break;
                }
            }
        }
    }
    
    int cal(vector<int>& nums){
        int n=nums.size();
        int cntr=0;
        for(int i=n-2;i>=0;i--){
             while(nums[i]>nums[i+1]&&lp[nums[i]]!=nums[i]){
                nums[i]=lp[nums[i]];
                cntr+=1;
            }
            if(nums[i]>nums[i+1]) return -1;
        }
        return cntr;
    }
    
    int minOperations(vector<int>& nums) {
        prime();
        int vk=cal(nums);
        int vk1=cal(nums);
        if(vk==-1||vk1==-1) return -1;
        return vk+vk1;
        
    }
};",1427858693
Claude Yang,chubby3318077,792,3502,csharp,"public class Solution {
    public int NumberOfSubstrings(string s, int k) {
        int n = s.Length;
        int res=0;
        for(int i =0;i<n;i++) 
        {
            var h = new int[26];
            for(int j = i;j < n; j++)
            {
                h[s[j]-'a']++;
                if(h.Max()>=k) res++;
            }
            
        }
        return res;
    }
}",1427833546
Claude Yang,chubby3318077,792,3566,csharp,"public class Solution {
    public IList<string> StringSequence(string target) {
        var res = new List<string>();
        var str = new StringBuilder();
        foreach(char c in target)
        {
            str.Append('a');
            res.Add(str.ToString());
            for(char i = 'b' ; i <= c ;i++)
            {
                str[str.Length-1]=i; 
                res.Add(str.ToString());
            }
        }
        return res;
    }
}",1427828733
Claude Yang,chubby3318077,792,3607,csharp,"public class Solution {
    public int MinOperations(int[] nums) {
        int res = 0;
        for(int i =nums.Length-2;i>=0;i--)
        {
            if(nums[i] <= nums[i+1]) continue;

            nums[i] = MinProper(nums[i]);
            if(nums[i] > nums[i+1]) return -1;
            res++;
        }
        return res;
    }
    private int MinProper(int n)
    {
        int d = 2;
        while( d != n)
        {
            if(n%d == 0) return d;
            d++;
        }

        return n; 
    }
}",1427850605
Chou,a0920732333,793,3502,cpp,"class Solution 
{
public:
    int numberOfSubstrings(string s, int k) 
    {
        vector<int> alpha(26);
        int l = 0, n = s.length(), ans = 0;
        for(int r = 0; r < n; r++)
        {
            alpha[s[r] - 'a']++;
            while((*max_element(alpha.begin(), alpha.end())) >= k)
            {
                ans += n - r;
                alpha[s[l] - 'a']--;
                l++;
            }
        }
        return ans;
    }
};",1427834014
Chou,a0920732333,793,3566,cpp,"class Solution 
{
public:
    vector<string> stringSequence(string target) 
    {
        vector<string> ans;
        ans.push_back(""a"");
        while(ans.back().length() < target.length() || (ans.back().length() == target.length() && ans.back().back() != target.back()))
        {
            if(ans.back().back() == target[ans.back().length() - 1])
            {
                ans.push_back(ans.back() + 'a');
            }
            else
            {
                ans.push_back(ans.back());
                ans.back()[ans.back().length() - 1]++;
            }
        }
        return ans;
    }
};",1427827910
Chou,a0920732333,793,3607,cpp,"class Solution 
{
public:
    int minOperations(vector<int>& nums) 
    {
        const int N = 1001;
        vector<bool> sieve(N);
        vector<int> prime;
        for (int i = 2; i < N; i++)
        {
            if (!sieve[i]) prime.push_back(i);
            for (int p : prime)
            {
                if (i * p >= N) break;
                sieve[i * p] = true;
                if (i % p == 0) break;
            }
        }
        int n = nums.size(), ans = 0;
        for(int i = n - 2; i >= 0; i--)
        {
            while(nums[i] > nums[i + 1])
            {
                int PD = 1;//proper divisor
                for(int j = 0; j < prime.size() && prime[j] <= sqrt(nums[i]); j++)
                {
                    if(nums[i] % prime[j] == 0)
                    {
                        PD = prime[j];
                        break;
                    }
                }
                if(PD == 1)
                {
                    return -1;
                }
                nums[i] = PD;
                ans++;
            }
        }
        return ans;
    }
};",1427850747
sl244,sl244,794,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int>store(26,0);
        int count=0;
        int i=0,j=0;
        while(j<s.size()){
            store[s[j]-'a']++;
            j++;
            
            while(check(store,k)){
                store[s[i]-'a']--;
                i++;
                count+=s.size()-j+1;
            }
            

        }
        return count;

        
    }

    bool check(vector<int>&store,int k){
        for(int e:store){
            if(e>=k)return true;
        }
        return false;
    }
};",1427838207
sl244,sl244,794,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string>result;
        for(char e:target){
            char cur ='a';
            string back="""";
            if(result.size()!=0)back=result[result.size()-1];
            while(cur!=e){
                result.push_back(back+cur);
                cur++;
            }
            result.push_back(back+cur);
        }
        return result;
        
    }
};",1427826725
sl244,sl244,794,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int count=0;
        for(int i=nums.size()-1;i>=1;i--){
            if(nums[i]<nums[i-1]){
                count++;
                int t = process(nums[i-1]);
                if(t>nums[i])return -1;
                nums[i-1]=t;

            }
        }
        return count;
        
    }

    int process(int n){
        for(int i=2;i<n;i++){
            if(n%i==0)return i;
        }
        return n;
    }
};",1427850917
sanvi_singh,sanvi_singh,795,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans=0;
        for(int i=0;i<s.size();i++){
            map<char,int> mp;
            for(int j=i;j<s.size();j++){
                mp[s[j]]++;
                for(auto &value:mp){
                    if(value.second>=k){
                        ans++;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};",1427838175
sanvi_singh,sanvi_singh,795,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string str="""";
        for(int i=0;i<target.size();i++){
            char ch='a';
            while(ch<=target[i]){
                str.push_back(ch);
                ans.push_back(str);
                str.pop_back();
                ch=ch+1;
            }
            str.push_back(target[i]);
        }
        return ans;
    }
};",1427831422
sanvi_singh,sanvi_singh,795,3607,cpp,"class Solution {
public:
    int solve(int num){
        int a=1;
        int maxi=1;
        for(int i=1;i*i<=num;i++){
           
            if(num%i==0){
                int b=i;
                int c=num/i;
                if(b!=num) maxi=max(maxi,b);
                if(c!=num) maxi=max(maxi,c);
            }
        }
        return maxi;
    }
    int minOperations(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        for(int i=n-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                int gd=solve(nums[i]);
                nums[i]=nums[i]/gd;
                ans++;
            }
        }
        bool flag=0;
        for(int i=0;i<n-1;i++){
            if(nums[i]>nums[i+1]) flag=1;
        }
        if(flag) return -1;
        return ans;
    }
};",1427859156
Rajesh S V,rajesh_sv,796,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        d = Counter()
        i = ans = 0
        for j in range(n):
            d[s[j]] += 1
            while True:
                for c, count in d.items():
                    if count >= k:
                        ans += n - j
                        break
                else:
                    break
                d[s[i]] -= 1
                i += 1
        return ans
                    ",1427850990
Rajesh S V,rajesh_sv,796,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = ['']
        for c1 in target:
            c2 = 'a'
            word = ans[-1]
            while c2 <= c1:
                ans.append(word + c2)
                c2 = chr(ord(c2)+1)
        return ans[1:]",1427843154
Rajesh S V,rajesh_sv,796,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        for i in range(len(nums)-2, -1, -1):
            temp = nums[i]
            while temp > nums[i+1]:
                for d in range(2, isqrt(nums[i])+1):
                    if temp % d == 0:
                        temp //= temp // d
                        ans += 1
                        break
                if temp == nums[i]:
                    return -1
                nums[i] = temp
        return ans
        ",1427833846
sdasdsd,sdasdsd,797,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        result = 0
        counter = defaultdict(int)
        kCount = 0
        left = 0
        for right, char in enumerate(s):
            counter[char] += 1
            if counter[char] >= k:
                kCount += 1
            while kCount > 0:
                result += len(s) - right
                if counter[s[left]] == k:
                    kCount -= 1
                counter[s[left]] -= 1
                left += 1
        return result
                
",1427839051
sdasdsd,sdasdsd,797,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        i = 0
        result = []
        curr = []
        while i < len(target):
            curr.append('a')
            result.append(''.join(curr))
            while curr[-1] != target[i]:
                curr[-1] = chr(ord(curr[-1]) + 1) if curr[-1] != 'z' else 'a'
                result.append(''.join(curr))
            i += 1
        return result",1427830559
sdasdsd,sdasdsd,797,3607,python3,"class Solution:
    def getDivisor(self, num):
        for i in range(2, num+1):
            if num % i == 0:
                return num // i
        return 1

    def minOperations(self, nums: List[int]) -> int:
        result = 0
        for i in range(len(nums)-2, -1, -1):
            while nums[i] > nums[i+1]:
                d = self.getDivisor(nums[i])
                if d == 1:
                    return -1
                nums[i] = nums[i] // d
                result += 1
        return result
            ",1427859203
mark93192,mark93192,799,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int left_sliding=0,right_sliding=-1;
        int ans=0;
        int now[26]={0};
        while(1){
            if(left_sliding==s.length()||right_sliding==s.length())
                break;
            int check=0;
            for(int i=0;i<=25;i++){
                if(now[i]>=k){
                    check=1;
                    break;
                }
            }
            if(check==0){
                right_sliding++;
                if(right_sliding<s.length())
                    now[(s[right_sliding]-'a')]++;
            }
            else{
                ans+=s.length()-right_sliding;
                now[(s[left_sliding]-'a')]--;
                left_sliding++;
            }
        }
        return ans;
    }
};",1427837628
mark93192,mark93192,799,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string to_append;
        int index_now=0;
        vector<string> ans;
        while(1){
            if(index_now==target.length())
                break;
            if(to_append.length()==index_now){
                to_append.push_back('a');
                if(target[index_now]=='a')
                    index_now++;
            }
            else{
                to_append[index_now]++;
                if(to_append[index_now]==target[index_now])
                    index_now++;
            }
            ans.push_back(to_append);
        }
        return ans;
    }
};",1427827951
mark93192,mark93192,799,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        for(int i=nums.size()-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                int divisor=2;                
                int largest=sqrt(nums[i])+1;
                for(int j=2;j<largest;j++){
                    divisor=j;
                    if(nums[i]%divisor==0){                        
                        break;
                    }                                   
                }
                
                if(nums[i]==divisor||nums[i]%divisor!=0){
                    ans=-1;
                    break;
                }
                else{
                    nums[i]=divisor;
                    ans++;
                    if(nums[i]>nums[i+1]){
                        ans=-1;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};",1427859396
Himang Garg,himanggarg,800,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int ans=0;
        for(int i=0;i<n;i++){
            unordered_map<char,int> freq;
            int mx=0;
            for(int j=i;j<n;j++){
                freq[s[j]]++;
                mx=max(mx,freq[s[j]]);
                if(mx>=k){
                    ans+=n-j;
                    break;
                }
            }
        }
        return ans;
    }
};",1427844794
Himang Garg,himanggarg,800,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.size();
        vector<char> letter={'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
                             'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
                             'u', 'v', 'w', 'x', 'y', 'z'};
        vector<string> ans;
        string cur="""";
        for(int i=0;i<n;i++){
            cur+='a';
            ans.push_back(cur);
            int temp=1;
            while(cur.back()<target[i]){
                cur[i]=letter[temp];
                ans.push_back(cur);
                temp++;
            }
        }
        return ans;
    }
};",1427829645
Himang Garg,himanggarg,800,3607,cpp,"class Solution {
public:
    int helper(int n){
        for(int i=2;i< 1+pow(n,0.5);i++){
            if(n%i==0){
                return i;
            }
        }
        return -1;
    }
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int ans=0;
        for(int i=n-2;i>=0;i--){
            while (nums[i]>nums[i+1]){
                int temp= helper(nums[i]);
                if(temp==-1){return -1;}
                else{nums[i]=temp;}
                ans++;
            }
        }
        return ans;
    }
};",1427859453
Aadarsh Kumar Agnihotri,addusirmac,803,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int req) {
        int n= s.size();
        vector<vector<int>>pre(n, vector<int>(26, 0));
        for(int i=0; i<n; i++){
            if(i>0)pre[i]= pre[i-1];
            pre[i][s[i]-'a']++;
        }
        int ans=0;
        for(int i=0; i<n; i++){
          for(int j=i; j<n; j++){
              bool ok=0;
             for(int k=0; k<26; k++){
                 int ct= pre[j][k]- (i>0?pre[i-1][k]:0);
                 if(ct>=req){
                   ok=1;
                 }
             }
              if(ok)ans++;
          }
        }
        // cout<<ans<<endl;
        // cout<<endl;
        return ans;
    }
};",1427835849
Aadarsh Kumar Agnihotri,addusirmac,803,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        vector<string>res;
        int n= s.size();
        string curr="""";
        for(auto &ch: s){
           
           for(char ch1= 'a'; ch1<=ch; ch1++){
               string ncurr= curr;
               ncurr.push_back(ch1);
               res.push_back(ncurr);
           }
            curr.push_back(ch);
        }
        return res;
    }
};",1427827572
Aadarsh Kumar Agnihotri,addusirmac,803,3607,cpp,"const int N= 1e6+1;
vector<int>divx(N, -1);
void precompute(){
    if(divx[4]!=-1)return;
   for(int i=2; i<N; i++){
       for(int j=2*i; j<N; j+=i){
         divx[j]= i;
       }
   } 
    return;
}

class Solution {
public:
    int minOperations(vector<int>& arr) {
        precompute();
        int n= arr.size();
        int prev= arr[n-1];
    
        int ans=0;
        for(int i=n-2; i>=0; i--){
           if(arr[i]<=prev){
               prev= arr[i];
               continue;
           }
           else{
               int x= arr[i];
               while(divx[x]!=-1 && x>prev){
                  x/=divx[x];
                  ans++;
               }
               if(x>prev)return -1;
               prev= x;
           }
        }
        return ans;
    }
};",1427859546
Prince_keshari,Prince_keshari,806,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
    int n = s.length();
    int result = 0;

    // Sliding window
    for (int start = 0; start < n; ++start) {
        unordered_map<char, int> freqMap;

        // Expand the window
        for (int end = start; end < n; ++end) {
            char ch = s[end];
            freqMap[ch]++;  // Increment frequency of the current character

            // Check if any character in the current window has a frequency >= k
            for (auto &entry : freqMap) {
                if (entry.second >= k) {
                    result++;  // Valid substring found
                    break;  // No need to check further for this window
                }
            }
        }
    }

    return result;
    }
};",1427835751
Prince_keshari,Prince_keshari,806,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
    int n = target.length();
    vector<string> result;
    string current = """";

    char screenChar = 'a';  // Start with 'a' on the screen

    for (int i = 0; i < n; ++i) {
        char targetChar = target[i];
        
        // Append 'a' first using Key 1
        current += screenChar;
        result.push_back(current);
        
        // Now change current character on screen to match targetChar using Key 2
        while (screenChar != targetChar) {
            // Increment the character
            screenChar = (screenChar == 'z') ? 'a' : screenChar + 1;
            
            // Update last character in current string
            current.back() = screenChar;
            result.push_back(current);  // Push the updated string to result
        }
        screenChar = 'a';
    }
    
    return result;
}
};",1427825827
Prince_keshari,Prince_keshari,806,3607,cpp,"class Solution {
public:
    vector<int> getDivisors(int x) {
    vector<int> divisors;
    for (int i = 2; i <= sqrt(x); ++i) {
        if (x % i == 0) {
            divisors.push_back(i);
            if (i != x / i) divisors.push_back(x / i);
        }
    }
    return divisors;
}

int minOperations(vector<int>& nums) {
    int n = nums.size();
    int operations = 0;

    // Traverse the array from the second last element to the first
    for (int i = n - 2; i >= 0; --i) {
        if (nums[i] <= nums[i + 1]) {
            // No need to change anything if the order is already correct
            continue;
        }

        bool possible = false;
        // Get all divisors of nums[i]
        vector<int> divisors = getDivisors(nums[i]);
        
        // Try each divisor to see if it can make nums[i] <= nums[i + 1]
        for (int div : divisors) {
            if (div < nums[i] && div <= nums[i + 1]) {
                // If we can reduce it to a valid state
                nums[i] = div;
                operations++;
                possible = true;
                break;
            }
        }

        // If no valid divisor was found, return -1
        if (!possible) {
            return -1;
        }
    }

    return operations;
}
};",1427859599
Marmaduke,Marmaduke,807,3502,cpp,"class Solution {
public:
    void update(vector<int>& c, int x, int change, int& tot, int k)
    {
        int old = c[x];
        c[x] += change;
        if(old < k && c[x] >= k)
        {
            tot++;
        }
        if(old >= k && c[x] < k)
        {
            tot--;
        }
    }
    int numberOfSubstrings(string s, int k) {
        int n = s.length();
        vector<int> c(26,0);
        int tot = 0;
        int j = 0;
        int ans = 0;
        for(int i = 0; i < n; i++)
        {
            while(j < n && tot == 0)
            {
                int x = s[j] - 'a';
                update(c, x, 1, tot, k);
                j++;
            }
            if(tot > 0)
            {
                ans += (n+1-j);
            }
            int y = s[i] - 'a';
            update(c, y, -1, tot, k);
        }
        
        return ans;
    }
};",1427841003
Marmaduke,Marmaduke,807,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        int n = target.length();
        string curr = """";
        vector<string> ans;
        for(auto &u : target)
        {
            curr.push_back('a');
            ans.push_back(curr);
            while(curr.back() != u)
            {
                curr.back()++;
                ans.push_back(curr);
            }
            
        }
        return ans;
    }
};",1427825043
Marmaduke,Marmaduke,807,3607,cpp,"const int M = 1e6+7;
vector<int> GD;
class Solution {
public:
    int minOperations(vector<int>& nums) {
        if(GD.empty())
        {
            GD = vector<int>(M,1);
            for(int k = 2; k < M; k++)
            {
                for(int m = k+k; m < M; m += k)
                {
                    GD[m] = k;
                }
            }
        }
        const int big = 1e9+7;
        map<int,int> dp[2];
        dp[1][1] = 0;
        int n = nums.size();
        for(int i = 0; i < n; i++)
        {
            int now = i % 2;
            int prev = (i+1) % 2;
            dp[now].clear();
            int t = 0;
            int x = nums[i];
            while(1)
            {
                dp[now][x] = big;
                for(auto &u : dp[prev])
                {
                    if(u.first <= x)
                    {
                        dp[now][x] = min(dp[now][x], u.second + t);
                    }
                }
                if(GD[x] == 1)
                {
                    break;
                }
                else
                {
                    x /= GD[x];
                    t++;
                }
            }
            
        }
        int ans = big;
        for(auto &u : dp[(n+1)%2])
        {
            ans = min(ans, u.second);
        }
        if(ans == big)
        {
            ans = -1;
        }
        return ans;
    }
};",1427859620
xianglaniunan,xianglaniunan,808,3502,java,"class Solution {
    public int numberOfSubstrings(String s, int k) {
        int n = s.length();
        int[][] f = new int[n + 1][26];
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < 26; j++)
            {
                f[i + 1][j] = f[i][j];
            }
            int p = s.charAt(i) - 'a';
            f[i + 1][p]++;
        }
        int re = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = i; j < n; j++)
            {
                int[] diff = new int[26];
                boolean found = false;
                for(int t = 0; t < 26; t++)
                {
                    diff[t] = f[j + 1][t] - f[i][t];
                    if(diff[t] >= k) found = true;
                }
                if(found) re++;
            }
        }
        return re;
    }
}",1427836508
xianglaniunan,xianglaniunan,808,3566,java,"class Solution {
    public List<String> stringSequence(String target) {
        List<String> list = new ArrayList<>();
        String next = null;
        for(char c : target.toCharArray())
        {
            next = list.size() > 0 ? list.get(list.size() - 1) : """";
            next = append(next);
            list.add(next);
            while(next.charAt(next.length() - 1) != c)
            {
                next = modifyLast(next);
                list.add(next);
            }
        }
        return list;
    }
    
    String modifyLast(String str)
    {
        char[] c = str.toCharArray();
        char last = c[c.length - 1];
        c[c.length - 1] = (char)(last + 1);
        return String.valueOf(c);
    }
    
    String append(String str)
    {
        return str + ""a"";
    }
}",1427827421
xianglaniunan,xianglaniunan,808,3607,java,"class Solution {
    public int minOperations(int[] nums) {

        int re = 0;
        int n = nums.length;
        for(int i = n - 2; i >= 0; i--)
        {
            int cur = nums[i], next = nums[i + 1];
            if(cur <= next)
            {
                //
            }
            else
            {
                // operate on cur
                while(cur > next)
                {
                    int gpd = getGpd(cur);
                    if(gpd < 0) return -1;
                    cur /= gpd;
                    re++;
                }
                nums[i] = cur;
            }
        }
        // System.out.println(Arrays.toString(nums));
        return re;
    }
    
    int getGpd(int k)
    {
        for(int i = 2; i <= k / 2; i++)
        {
            if(k % i == 0)
            {
                return k / i;
            }
        }
        return -1;
    }
}",1427859675
Ruhan Das,Ruhan00123,809,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n = s.size();
        int cnt = 0;
        for(int i = 0; i < n; i++) {
            vector<int> hsh(26, 0);
            bool flag = 0;
            for(int j = i; j < n; j++) {
                hsh[s[j] - 'a']++;
                if(hsh[s[j] - 'a'] == k) flag = 1;
                if(flag) cnt++;
            }
        }
        
        return cnt;
    }
};",1427828212
Ruhan Das,Ruhan00123,809,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        
        vector<string> ans;
        string s;
        int n = target.size();
        for(int i = 0; i < n; i++) {
            int val = target[i] - 'a';
            s.push_back('a');
            for(int j = 0; j <= val; j++) {
                s[s.size() - 1] = char('a' + j);
                ans.push_back(s);
            }
        }
        
        return ans;
    }
};",1427825535
Ruhan Das,Ruhan00123,809,3607,cpp,"int ct = 0;
const int N = 1e6 + 1;
vector<int> val(N, 1);

void func() {

    for(long long i = 2; i < N; i++) {
        for(long long j = 2 * i; j < N; j += i) val[j] = i;
    }
}

class Solution {
public:
    int minOperations(vector<int>& v) {
        
        if(ct == 0) {
            func();
            ct = 1;
        }
        
        int cnt = 0;
        int n = v.size();
        for(int i = n - 1; i > 0; i--) {
            if(v[i - 1] > v[i]) {
                while(v[i - 1] > 1 && v[i - 1] > v[i] && val[v[i - 1]] > 1) {
                    v[i - 1] = v[i - 1] / val[v[i - 1]];
                    cnt++;
                }
            }
            
            if(v[i - 1] > v[i]) return -1;
        }
        return cnt;
    }
};",1427851594
Mintu Jupally,mintujupally,811,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        vector<int> fq(26, 0);
        int r=0;
        int n=s.size();
        int ans=0;
        for(int i=0; i<n; i++)
        {
            while(r<n)
            {
                int mx=*max_element(fq.begin(), fq.end());
                if(mx>=k) break;
                fq[s[r]-'a']++;
                ++r;
            }
            int mx=*max_element(fq.begin(), fq.end());
            if(mx<k) break;
            ans+=n-r+1;
            fq[s[i]-'a']--;
        }
        return ans;
    }
};",1427847207
Mintu Jupally,mintujupally,811,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curr=""a"";
        ans.push_back(curr);
        for(auto &ch:target)
        {
            int x=curr.size();
            while(curr[x-1]!=target[x-1])
            {
                curr[x-1]=(curr[x-1]-'a'+1)%26+'a';
                ans.push_back(curr);
            }
            if(x==target.size()) break;
            curr+='a';
            ans.push_back(curr);
        }
        return ans;        
    }
};",1427825752
Mintu Jupally,mintujupally,811,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        int ans=0;
        for(int i=n-2; i>=0; i--)
        {
            while(nums[i]>nums[i+1]){
                bool flag=false;
                for(int j=2; j*j<=nums[i]; j++)
                {
                    if(nums[i]%j==0)
                    {
                        nums[i]=j;
                        flag=true;
                        break;
                    }
                }
                if(!flag) break;
                ++ans;
            }
            if(nums[i]<=nums[i+1]) continue;
            return -1;
        }
        return ans;
    }
};",1427859813
davindx88,davindx88,812,3502,golang,"func numberOfSubstrings(s string, k int) int {
    var mem [26]int

    left := 0
    right := 0
    acc := 0
    for right < len(s) {
        mem[s[right]-'a']++
        if mem[s[right]-'a'] >= k {
            for mem[s[right]-'a'] >= k && left <= right {
                acc += len(s) - right
                mem[s[left]-'a']--
                left++
            }
        }
        right++
    }
    return acc
}",1427845485
davindx88,davindx88,812,3566,golang,"func stringSequence(target string) []string {
    retArr := []string{}
    i := 0
    currChars := []byte{ 'a' }
    for i < len(target) {
        retArr = append(retArr, string(currChars))
        if currChars[i] != target[i] {
            currChars[i]++
        } else {
            currChars = append(currChars, 'a')
            i++
        }
    }
    return retArr
}",1427828296
davindx88,davindx88,812,3607,golang,"import (
    ""math""
)

func minOperations(nums []int) int {
    mem := make(map[int]int)

    ops := 0
    for i:=len(nums)-2;i>=0;i--{
        if nums[i] <= nums[i+1] { continue }
        // try perform operation
        divisor := getGreatestProperDivisor(nums[i], mem)
        if divisor == -1 { return -1 }
        if nums[i] / divisor > nums[i+1] { return -1 }
        nums[i] /= divisor
        ops++
    }
    return ops
}

func getGreatestProperDivisor(n int, mem map[int]int) int {
    if n <= 3 { return -1 }
    if n%2 == 0 { return n/2 }
    if val, ok := mem[n]; ok { return val }

    mem[n] = -1
    for i:=3;i<=int(math.Sqrt(float64(n)));i+=2{
        if n % i == 0 { 
            mem[n] = n/i
            break
        }
    }
    return mem[n]
}",1427859816
Abhishek Ghosh,abhishek10ghosh,813,3502,cpp,"class Solution {
public:
    bool check(vector<int>& f,int k){
        for(int i=0;i<26;i++){
            if(f[i]>=k) return 1;
        }
        return 0;
    }
    int numberOfSubstrings(string s, int k) {
        


        int n=s.size();

        int i=0,j=0;
        int ans=0;
        vector<int> f(26,0);
        while(j<n){
            f[s[j]-'a']++;

            if(check(f,k)){
                while(check(f,k)){
                    ans+=(n-j);
                    f[s[i]-'a']--;
                    i++;
                }
            }
            j++;
        }
        return ans;
    }
};",1427847666
Abhishek Ghosh,abhishek10ghosh,813,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string s) {
        


        vector<string> ans;
        string curr;
        int n=s.size();
        int i=0,j=0;
        bool f=1;
        while(j<n && curr.size()<n){
            curr+='a';
            ans.push_back(curr);
            if(curr.back()==s[j]){
                j++;
                i++;
            }
            else{
                while(curr.back()!=s[j]){
                    // ans.push_back(curr);
                    char c = curr.back();
                    curr.pop_back();
                    c++;
                    curr+=c;
                    ans.push_back(curr);
                }
                j++;
                // ans.push_back(curr);
                
                // if(curr.back()==s[j]) j++;
            }
            
        }
        return ans;

    }
};",1427843507
Abhishek Ghosh,abhishek10ghosh,813,3607,cpp,"class Solution {
public:
    int solve(int x){
        int maxi=-1;
        for(int i=1;i<=sqrt(x);i++){
            if(x%i==0){
                maxi=max(maxi,i);
                int y = x/i;
                if(y!=x) maxi=max(maxi,y);
            }
        }
        return maxi;
    }
    int minOperations(vector<int>& nums) {
        

        int n=nums.size();

        int prev = nums[n-1];
        int ans=0;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<=prev){
                prev=nums[i];
                continue;
            }
            else{
                int x = solve(nums[i]);
                if(x==-1) return -1;
                else{
                    ans++;
                    if(nums[i]/x > prev) return -1;
                    prev = nums[i]/x;
                }
            }
        }
        return ans;
    }
};",1427859820
humbl_pi,humbl_pi,814,3502,python3,"from heapq import *

class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        cts = collections.defaultdict(int) ## store changes since accessing
        hp = [] ## (-counts, char)

        iL = 0
        ans = 0
        n = len(s)

        for iR, c in enumerate(s):
            cts[c] += 1

            while max(cts.values()) >= k:
                rem = s[iL]
                cts[rem] -= 1
                iL += 1

            ans += iL
        
        return ans",1427837690
humbl_pi,humbl_pi,814,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        ans = []
        val = []

        # ord_a = ord('a')
        def incr(c):
            return chr(ord(c)+1)
        
        for i,t in enumerate(target):
            # if i == len(val):
            val.append('a')
            ans.append(''.join(val[:]))
            while val[-1] != t:
                val[-1] = incr(val[-1])
                ans.append(''.join(val[:]))
        
        return ans
",1427825462
humbl_pi,humbl_pi,814,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        primes = [
            2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,
            103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,
            199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,
            313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,
            433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,
            563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,
            673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,
            811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,
            941,947,953,967,971,977,983,991,997,
        ]
        setp = set(primes)

        def getdiv(num):
            if num in setp: return -1 ## in list of primes
            for p in primes:
                if num%p==0: return p
            return -1 ## must be prime
        
        ans = 0
        n = len(nums)
        for i in range(n-2,-1,-1):
            while nums[i] > nums[i+1]: ## BAD
                newnum = getdiv(nums[i])
                if newnum == -1: return -1 ## can't change
                else: 
                    # print(i, nums[i], newnum)
                    nums[i] = newnum
                    ans += 1
        
        return ans
        ",1427851887
Jaysukh Makvana,jaysukh_409,815,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) 
    {
        int n = s.size();
        int notSatisfy = 0;
        for (int i = 0; i < n; i++)
        {
            int freq[26] = {0};
            for (int j = i; j < n; j++)
            {
                freq[s[j] - 'a']++;
                if (freq[s[j] - 'a'] >= k) break;
                notSatisfy++;
            }
        }    
        long long total = 1ll * n * (n + 1);
        total /= 2;
        return (total - notSatisfy);
    }
};",1427831884
Jaysukh Makvana,jaysukh_409,815,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) 
    {
        vector<string> ans;
        string temp = """";
        for (auto i : target)
        {
            char c = 'a';
            while (c <= i)
            {
                temp += c;
                ans.push_back(temp);
                temp.pop_back();
                c++;
            }
            temp += i;
        }    
        return ans;
    }
};",1427825576
Jaysukh Makvana,jaysukh_409,815,3607,cpp,"vector<bool> sieve(1e6 + 5, 1);
vector<int> prime;
void preCalculate()
{
    sieve[0] = sieve[1] = 0;
    for (int i = 2; i * i <= 1e6 + 5; i++)
    {
        if (!sieve[i]) continue;
        for (int j = i * i; j < 1e6 + 5; j += i)
        {
            sieve[j] = 0;
        }
    }
    for (int i = 2; i < 1e6 + 5; i++)
    {
        if (sieve[i]) prime.push_back(i);
    }
}

class Solution {
public:
    int minOperations(vector<int>& nums) 
    {
        if (prime.size() == 0) preCalculate();
        int x = prime.size();
        int n = nums.size();
        int ans = 0;
        for (int i = n - 2; i >= 0; i--)
        {
            if (nums[i] > nums[i + 1])
            {
                int j = 0;
                for (j = 0; j < x; j++)
                {
                    if (nums[i] % prime[j] == 0) break;
                }
                if (nums[i] == prime[j]) return -1;
                else 
                {
                    ans++;
                    nums[i] = prime[j];
                }
            }
        }
        for (int i = 0; i < n - 1; i++)
        {
            if (nums[i] > nums[i + 1]) return -1;
        }
        return ans;
    }
};",1427852045
Akash Tiwari,akash_tiwari_12,816,3502,cpp,"class Solution
{
public:
    int numberOfSubstrings(string s, int k)
    {
        int ans = 0;
        for (int i = 0; i < s.size(); i++)
        {
            vector<int> cnt(26, 0);
            for (int j = i; j < s.size(); j++)
            {
                cnt[s[j] - 'a']++;
                for (int x : cnt)
                    if (x >= k)
                    {
                        ans++;
                        break;
                    }
            }
        }
        return ans;
    }
};",1427833256
Akash Tiwari,akash_tiwari_12,816,3566,cpp,"class Solution
{
public:
    vector<string> stringSequence(string target)
    {
        string s = """";
        vector<string> res;
        for (int i = 0; i < target.size(); i++)
        {
            string s = target.substr(0, i);
            for (char ch = 'a'; ch <= target[i]; ch++)
                res.push_back(s + ch);
        }
        return res;
    }
};",1427827922
Akash Tiwari,akash_tiwari_12,816,3607,cpp,"const int N = 1e6 + 5;

vector<int> spf(N, 0);

void SPF()
{
    spf[1] = 1;
    for (long i = 2; i < N; i++)
    {
        if (spf[i] == 0)
        {
            spf[i] = i;
            for (long j = i * i; j < N; j += i)
                if (spf[j] == 0)
                    spf[j] = i;
        }
    }
}

class Solution
{
public:
    int minOperations(vector<int> &nums)
    {
        SPF();
        int ans = 0;
        int n = nums.size();
        for (int i = n - 2; i >= 0; i--)
        {
            if (nums[i] > nums[i + 1])
            {
                int spf1 = spf[nums[i]];
                if (spf1 == nums[i])
                    return -1;
                nums[i] = spf1;
                ans++;
                i++;
            }
        }
        return ans;
    }
};",1427843865
s_j_01,s_j_01,817,3502,cpp,"class Solution {
public:

    bool check(int* v, int k){
        for(int i=0;i<26;i++){
            if(v[i]>=k) return true;
        }
        return false;
    }

    int numberOfSubstrings(string s, int k) {

        int l=0,ans=0;
        int v[26] = {0};

        for(int i=0;i<s.size();i++){
            v[s[i]-'a']++;
            while(check(v,k)){
                v[s[l]-'a']--;
                l++;
            }
            ans += l;
        }
        return ans;
    }
};",1427840557
s_j_01,s_j_01,817,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string tar) {
        
        vector<string>res;
        string s = """";
        
        for(int i=0;i<tar.size();i++){
            char c = 'a';
            while(c!=tar[i]){
                res.push_back(s+c);
                c++;
            }
            s+=c;
            res.push_back(s);
        }

        return res;
    }
};",1427830876
s_j_01,s_j_01,817,3607,cpp,"class Solution {
public:
    int findDivisor(int num){
        for(int i=2;i*i<=num;i++){
            if(num%i == 0) return i;
        }
        return num;
    }

    int minOperations(vector<int>& nums) {
        
        int idx=-1,n = nums.size();

        for(int i=n-2;i>=0;i--){
            if(nums[i]>nums[i+1]){
                idx = i; break;
            }
        }

        int ans = 0;
        while(idx>=0){
            if(nums[idx]>nums[idx+1]){
                nums[idx] = findDivisor(nums[idx]);
                ans++;
            }
            if(nums[idx]>nums[idx+1]) return -1;
            idx--;
        }

        return ans;
    }
};",1427860131
Prathamesh,SouLPegasuS,818,3502,cpp,"class Solution {
public:
    
    int k;
    
    bool check(unordered_map<char, int> &m){
        for(auto &i : m){
            if(i.second >= k)return true;
        }
        return false;
    }
    
    int numberOfSubstrings(string a, int K) {
        k = K;
        int n = a.size();
        int i=0, j=0;
        int ans = 0;
        unordered_map<char, int> m;
        while(i<n && j<n && i<=j){
            m[a[j]]++;
            while(check(m)){
                ans += n-j;
                m[a[i]]--;
                i++;
            }
            j++;
        }
        return ans;
    }
};",1427842913
Prathamesh,SouLPegasuS,818,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string a) {
        vector<string> ans;
        int n = a.size();
        string res = """";
        for(int i=0; i<n; i++){
            for(char c='a'; c<=a[i]; c++){
                string temp = res+c;
                ans.push_back(temp);
            }
            res.push_back(a[i]);
        }
        return ans;
    }
};",1427832411
Prathamesh,SouLPegasuS,818,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& a) {
        int n = a.size(), ans=0;
        for(int i=n-2; i>=0; i--){
            while(a[i]>a[i+1]){
                int temp = a[i];
                for(int j=2; j*j<=a[i]; j++){
                    if(a[i]%j!=0)continue;
                    a[i] = j;
                    ans++;
                    break;
                }
                if(temp==a[i])return -1;
            }
            if(a[i]>a[i+1]){
                return -1;
            }
        }
        return ans;
    }
};",1427860248
Vikas kumar sharma,vikasss,819,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int kk) {
        int n=s.size(),ans=0;
        
        vector<vector<int>> prefix(n,vector<int>(26,0));
        prefix[0][s[0]-'a']=1;
        for(int i=1;i<n;i++){
            prefix[i][s[i]-'a']=1;
            for(int j=0;j<26;j++){
                prefix[i][j]+=prefix[i-1][j];
            }
        }
        auto func=[&](int i,int j){
           for(int k=0;k<26;k++){
               int freq=prefix[j][k];
               if(i-1>=0) freq-=prefix[i-1][k];
               if(freq>=kk) return true;
           } 
            return false;
        };
        
        for(int i=0;i<n;i++){
           for(int j=i;j<n;j++){
               ans+=func(i,j);
           } 
        }
        // cout<<func(0,1)<<endl;
        return ans;
    }
};",1427835285
Vikas kumar sharma,vikasss,819,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string str;
        for(int i=0;i<target.size();i++){
            // i+1 length  only
            string str;
            for(int j=0;j<i;j++) str.push_back(target[j]);
            for(char ch='a';ch<=target[i];ch++){
                str.push_back(ch);
                ans.push_back(str);
                str.pop_back();
            }
        }
        return ans;
    }
};",1427827343
Vikas kumar sharma,vikasss,819,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n=nums.size();
        
        auto func=[&](int ele){
          int gr8D=1;
          for(int j=2;j*j<=ele;j++){
              if(ele%j==0){
                  int a=j,b=ele/j;
                  gr8D=max({gr8D,a,b});
              }
          }  
          return gr8D;
        };
        
        int ans=0;
        
        for(int i=n-2;i>=0;i--){
            while(true){
                if(nums[i]<=nums[i+1]){
                    break;
                }
                int temp=func(nums[i]);
                if(temp==1) break;
                nums[i]=nums[i]/temp;
                ans++;
            }
            if(nums[i]<=nums[i+1]) continue;
            else return -1;
        }
        return ans;
    }
};",1427860278
tlh65,tlh65,820,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        appearance = [0] * 26
        left = 0
        right = -1
        
        result = 0
        
        while left < len(s):
            while max(appearance) < k:
                right += 1
                if right == len(s):
                    return result
                appearance[ord(s[right]) - ord(""a"")] += 1
            
            result += len(s) - right
            
            appearance[ord(s[left]) - ord(""a"")] -= 1
            left += 1
                
        return result",1427835674
tlh65,tlh65,820,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        result = [""a""]
        
        while result[-1] != target:
            screen = result[-1]
            
            if screen[-1] != target[len(screen)-1]:
                screen = screen[:-1] + chr(ord(screen[-1]) + 1)
            else:
                screen = screen + ""a""
                
            result.append(screen)
        
        return result",1427826919
tlh65,tlh65,820,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        result = 0
        
        for pos in range (len(nums)-2, -1,-1):
            if nums[pos] > nums[pos + 1]:
                num = nums[pos]
                # divide a number by its greatest proper divisor => smallest divisor greater than 1
                sd = -1
                for i in range (2, min(1000, num)):
                    if num % i == 0:
                        sd = i
                        break
                if sd == -1 or sd > nums[pos + 1]:
                    return -1
                else:
                    nums[pos] = sd
                    result += 1
                    
        return result
                    
                
        ",1427852298
Dhairya,PhoenixDD,821,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        array<int,26> count;
        int result=0;
        for(int i=0;i<s.length();i++) {
            count.fill(0);
            for(int j=i;j<s.length();j++) {
                count[s[j]-'a']++;
                if(count[s[j]-'a']==k) {
                    result+=s.length()-j;
                    break;
                }
            }
        }
        return result;
    }
};",1427833097
Dhairya,PhoenixDD,821,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        string curr="""";
        vector<string> result;
        for(char &c:target) {
            curr+='a';
            result.push_back(curr);
            while(curr.back()!=c) {
                curr.back()=((curr.back()-'a'+1)%26)+'a';
                result.push_back(curr);
            }
        }
        return result;
    }
};",1427825737
Dhairya,PhoenixDD,821,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        vector<int> right(nums.size());
        right.back()=nums.back();
        for(int i=right.size()-2;i>=0;i--)
            right[i]=min(nums[i],right[i+1]);
        int result=0;
        for(int i=nums.size()-2;i>=0;i--) {
            right[i]=min(right[i],right[i+1]);
            if(nums[i]>right[i]) {
                for(int j=2;j*j<=nums[i];j+=1+(j&1)) {
                    if(nums[i]%j==0) {
                        nums[i]/=(nums[i]/j);
                        right[i]=min(right[i],nums[i]);
                        result++;
                        break;
                    }
                }
                if(nums[i]>right[i])
                    return -1;
            }
        }
        // for(int &i:nums)
        //     cout<<i<<"", "";
        // cout<<endl;
        return result;
    }
};",1427852592
yashbhattad,yashbhattad,822,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int n=s.size();
        int count=0;
        
        for (int i=0;i<n;i++){
            unordered_map<char,int> m;
            for(int j=i;j<n;j++){
                m[s[j]]++;
                bool f=false;
                for(auto& pair:m){
                    if (pair.second >=k){
                        f=true;
                        break;
                    }
                }
                if(f){
                    count++;
                }
            }
        }
        return count;
    }
};",1427833550
yashbhattad,yashbhattad,822,3566,cpp,"#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curr="""";
        for(int i=0;i<target.size();i++){
            curr+='a';
            ans.push_back(curr);
            while(curr[i]<target[i]){
                curr[i]++;
                ans.push_back(curr);
            }
        }
        return ans;
    }
};
",1427826947
yashbhattad,yashbhattad,822,3607,cpp,"class Solution {
public:
    int f(int x) {
        for (int i = x / 2; i >= 2; --i) {
            if (x % i == 0) return i;
        }
        return 1;
    }

    int minOperations(vector<int>& nums) {
        int n = nums.size();
        int op = 0;
        unordered_map<int, int> memo;
        
        for (int i = n - 1; i > 0; --i) {
            while (nums[i] < nums[i - 1]) {
                if (memo.find(nums[i - 1]) != memo.end()) {
                    nums[i - 1] = memo[nums[i - 1]];
                    op++;
                    continue;
                }
                
                int divisor = f(nums[i - 1]);
                if (divisor == 1) return -1;
                
                int newVal = nums[i - 1] / divisor;
                memo[nums[i - 1]] = newVal;
                
                nums[i - 1] = newVal;
                op++;
            }
        }
        return op;
    }
};
",1427852605
Josh Wu,joshthwu,823,3502,python3,"class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        res = 0
        for start in range(len(s)):
            count = defaultdict(int)
            for i in range(start, len(s)):
                count[s[i]] += 1
                if count[s[i]] == k:
                    res += (len(s) - i)
                    break
        return res",1427838420
Josh Wu,joshthwu,823,3566,python3,"class Solution:
    def stringSequence(self, target: str) -> List[str]:
        res = []
        for c in target:
            if not res:
                res.append('a')
            else:
                res.append(res[-1] + 'a')
            for i in range(ord('a') + 1, ord(c) + 1):
                res.append(res[-1][:-1] + chr(i))
        return res",1427827967
Josh Wu,joshthwu,823,3607,python3,"class Solution:
    def minOperations(self, nums: List[int]) -> int:
        res = 0
        for i in range(len(nums) - 2, -1, -1):
            # print(nums)
            # print(nums[i])
            while nums[i] > nums[i + 1]:
                prev = nums[i]
                for divisor in range(2, ceil(sqrt(nums[i]))+1):
                    # print(divisor)
                    if nums[i] % divisor == 0:
                        nums[i] = nums[i] // (nums[i] // divisor)
                        res += 1
                        # print(""new nums"", nums)
                        break
                if nums[i] == prev:
                    return -1
        return res
                    ",1427860668
Jimmy,yangjingmin928,824,3502,cpp,"class Solution {
public:
    int numberOfSubstrings(string s, int k) {
        int ans = 0;
        int strlen = s.length();
        for(int l = k; l<=strlen; l++){
            vector<int> cnt(26, 0);
            int over = 0;
            for(int i=0; i<l;i++){
                int curidx = s[i] - 'a';
                cnt[curidx]++;
                if(cnt[curidx] == k) over++;
            }
            if(over > 0) ans++;
            for(int st = 0; st<strlen-l; st++){
                int curidx = s[st]-'a';
                if(cnt[curidx]-- == k) over--;
                curidx = s[st+l] - 'a';
                if(++cnt[curidx] == k) over++;
                
                if(over > 0) ans++;
            }
        }
        return ans;
    }
};",1427845554
Jimmy,yangjingmin928,824,3566,cpp,"class Solution {
public:
    vector<string> stringSequence(string target) {
        vector<string> ans;
        string curstr = """";
        char curchr = 'a';
        for(char elm : target){
            while(curchr != elm){
                ans.push_back(curstr + curchr);
                curchr = ((curchr-'a'+1)%26) + 'a';
            }
            curstr += curchr;
            ans.push_back(curstr);
            curchr = 'a';
        }
        return ans;
    }
};",1427830319
Jimmy,yangjingmin928,824,3607,cpp,"class Solution {
public:
    int minOperations(vector<int>& nums) {
        int ans=0;
        for(int i=nums.size()-2; i>=0 ; i--){
            while(nums[i] > nums[i+1]){
                int fac=2;
                while(nums[i]%fac != 0) fac++;
                if(fac == nums[i]) return -1;
                nums[i] = fac;
                ans++;
            }
        }
        return ans;
    }
};",1427852778
soimportant,soimportant,825,3502,cpp,"class Solution {
public:
  int numberOfSubstrings(string s, int k) {
    int n = (int) s.size();
    vector<int> cnt(26);
    auto ok = [&]() {
      return *max_element(cnt.begin(), cnt.end()) >= k;
    };  

    int ans = 0;
    for (int l = 0, r = 0; r < n; r++) {
      cnt[s[r] - 'a']++;
      while (l <= r && ok()) {
        ans += (n - r);
        cnt[s[l] - 'a']--;
        l++;
      }
    }
    return ans;
  }
};",1427830973
soimportant,soimportant,825,3566,cpp,"class Solution {
public:
  vector<string> stringSequence(string t) {
    vector<string> res;
    string s = """";
    while (s != t) {
      if (t.substr(0, s.size()) != s) {
        s.back() += 1;
      } else {
        s += 'a';
      }
      res.push_back(s);
    }
    return res;
  }
};",1427825001
soimportant,soimportant,825,3607,cpp,"class Solution {
public:
  int minOperations(vector<int>& v) {
    int n = (int) v.size();
    int ans = 0;
    for (int i = n - 2; i >= 0; i--) {
      if (v[i] < v[i + 1]) {
        continue;
      }
      while (v[i] > v[i + 1]) {
        bool find = false;
        for (int x = 2; x * x <= v[i]; x++) {
          if (v[i] % x == 0) {
            v[i] = x;
            ans++;
            find = true;
            break;
          }
        }
        if (!find) {
          return -1;
        }
      }
    }
    
    return ans;
  }
};",1427852963
