username,userslug,contest_rank,question_id,language,code,submission_id
unicorn_15,unicorn_15,7,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n, vector<int>());
        for(int i = 1; i < n; ++i){
            tree[parent[i]].push_back(i);
        }
        vector<int> new_parent = parent;
        vector<int> last(256, -1);
        function<void(int)> dfs = [&](int u) {
            char c = s[u];
            int prev = last[c];
            if(prev != -1 && u != 0){
                new_parent[u] = prev;
            }
            last[c] = u;
            for(auto v: tree[u]){
                dfs(v);
            }
            last[c] = prev;
        };
        dfs(0);
        vector<vector<int>> new_tree(n, vector<int>());
        for(int i = 0; i < n; ++i){
            if(new_parent[i] != -1){
                new_tree[new_parent[i]].push_back(i);
            }
        }
        vector<int> res(n, 0);
        function<int(int)> count_subtree = [&](int u) -> int {
            res[u] = 1;
            for(auto v: new_tree[u]){
                res[u] += count_subtree(v);
            }
            return res[u];
        };
        count_subtree(0);
        return res;
    }
};",1434268727
unicorn_15,unicorn_15,7,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
         vector<vector<int>> dp(k, vector<int>(n, INT32_MIN));
        for(int curr = 0; curr < n; ++curr){
            dp[0][curr] = stayScore[0][curr];
            for(int prev = 0; prev < n; ++prev){
                dp[0][curr] = max(dp[0][curr], travelScore[prev][curr]);
            }
        }
        for(int i = 1; i < k; ++i){
            for(int curr = 0; curr < n; ++curr){
                int stay = dp[i-1][curr] + stayScore[i][curr];
                int move = INT32_MIN;
                for(int prev = 0; prev < n; ++prev){
                    move = max(move, dp[i-1][prev] + travelScore[prev][curr]);
                }
                dp[i][curr] = max(stay, move);
            }
        }
        return *max_element(dp[k-1].begin(), dp[k-1].end());
    }
};",1434272885
unicorn_15,unicorn_15,7,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
         std::vector<int> runs;
        char prev = '\0';
        int count = 0;
        
        // Iterate through each character in the word
        for(char c : word){
            if(c == prev){
               
                count += 1;
            }
            else{
                
                if(prev != '\0'){
                    runs.push_back(count);
                }
               
                prev = c;
                count = 1;
            }
        }
        // Don't forget to add the count of the last run
        runs.push_back(count);
        
        
        int result = 0;
        for(auto r : runs){
            result += (r - 1);
        }
        return result + 1;
    }
};",1434266096
unicorn_15,unicorn_15,7,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

class Solution {
public:
    int possibleStringCount(string word, int k) {
        const int MOD = 1e9 + 7;
        vector<int> run_lengths;
        int n = word.size();
        
        if(n == 0){
            return (k <= 0) ? 1 : 0;
        }
        
        char current_char = word[0];
        int count = 1;
        for(int i = 1; i < n; ++i){
            if(word[i] == current_char){
                count++;
            }
            else{
                run_lengths.push_back(count);
                current_char = word[i];
                count = 1;
            }
        }
        run_lengths.push_back(count);
        int m = run_lengths.size();
        
        ll total_sequences = 1;
        for(auto &x : run_lengths){
            total_sequences = (total_sequences * (ll)x) % MOD;
        }
        
        int T = k - m;
        if(T <= 0){
            return total_sequences;
        }
        
        int S = T - 1;
        vector<int> L;
        for(auto &x : run_lengths){
            L.push_back(x - 1);
        }
        
        vector<ll> dp_prev(S + 1, 0);
        vector<ll> dp_curr(S + 1, 0);
        dp_prev[0] = 1;
        
        for(int i = 0; i < m; ++i){
            vector<ll> prefix(S + 2, 0);
            for(int j = 0; j <= S; j++){
                prefix[j + 1] = (prefix[j] + dp_prev[j]) % MOD;
            }
            for(int j = 0; j <= S; j++){
                int lower = max(0, j - L[i]);
                dp_curr[j] = (prefix[j + 1] - prefix[lower] + MOD) % MOD;
            }
            dp_prev.swap(dp_curr);
            fill(dp_curr.begin(), dp_curr.end(), 0);
        }
        
        ll invalid_sequences = 0;
        for(int j = 0; j <= S; j++){
            invalid_sequences = (invalid_sequences + dp_prev[j]) % MOD;
        }
        
        ll valid_sequences = (total_sequences - invalid_sequences + MOD) % MOD;
        return (int)valid_sequences;
    }
};
",1434307425
kmjp,kmjp,11,3576,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


int P[505050];
int S[505050];
vector<int> E[505050];
vector<int> E2[505050];
int C[505050];
class Solution {
public:
	void dfs(int cur,vector<int>& V) {
		if(cur) {
			if(V[S[cur]]!=-1) {
				E2[V[S[cur]]].push_back(cur);
			}
			else {
				E2[P[cur]].push_back(cur);
			}
		}
		int pre=V[S[cur]];
		V[S[cur]]=cur;
		FORR(e,E[cur]) dfs(e,V);
		V[S[cur]]=pre;
	}
	int dfs2(int cur) {
		C[cur]=1;
		FORR(e,E2[cur]) C[cur]+=dfs2(e);
		return C[cur];
	}
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
		int i;
		int N=parent.size();
		FOR(i,N) {
			E[i].clear(),E2[i].clear();
			S[i]=s[i]-'a';
			P[i]=parent[i];
		}
		FOR(i,N) if(i) E[parent[i]].push_back(i);
		vector<int> V(26,-1);
		dfs(0,V);
		dfs2(0);
		vector<int> R;
		FOR(i,N) R.push_back(C[i]);
		return R;
        
    }
};
",1434283332
kmjp,kmjp,11,3587,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


ll dp[202][202];

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        ZERO(dp);
        int i,x,y;
        FOR(i,k) {
			FOR(x,n) dp[i+1][x]=max(dp[i+1][x],dp[i][x]+stayScore[i][x]);
			FOR(x,n) FOR(y,n)  dp[i+1][y]=max(dp[i+1][y],dp[i][x]+travelScore[x][y]);
		}
		ll ma=0;
		FOR(x,n) ma=max(ma,dp[k][x]);
		return ma;
    }
};
",1434266524
kmjp,kmjp,11,3617,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------



class Solution {
public:
    int possibleStringCount(string word) {
		int ret=1;
		int i;
		for(i=1;i<word.size();i++) if(word[i]==word[i-1]) ret++;
		return ret;
        
    }
};
",1434269420
kmjp,kmjp,11,3618,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

const ll mo=1000000007;
ll from[2020];
ll to[2020];
class Solution {
public:
    int possibleStringCount(string word, int k) {
		vector<pair<int,int>> V;
		FORR(c,word) {
			if(V.empty()||V.back().first!=c) V.push_back({c,0});
			V.back().second++;
		}
		if(V.size()>=k) {
			ll ret=1;
			FORR(v,V) ret=ret*v.second%mo;
			return ret;
		}
		
		ZERO(from);
		from[0]=1;
		int x;
		FORR(v,V) {
			int y=v.second;
			ZERO(to);
			for(x=0;x<=k;x++) {
				to[x+1]+=from[x];
				if(x+y<=k) {
					to[x+y+1]+=mo-from[x];
				}
				else {
					int more=x+y-k;
					to[k+1]+=mo-from[x];
					(to[k]+=more*from[x])%=mo;
					
				}
			}
			for(x=0;x<=k;x++) {
				from[x]=to[x]%mo;
				if(x) (from[x]+=from[x-1])%=mo;
			}
		}
		
		return from[k]%mo;
			
		
        
    }
};
",1434303901
Dylan Smith,DylanSmith,13,3576,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)
class Solution {
public:
    string s2;
    vector<int> last, nxt;
    void dfs(vector<vector<int>> &adj, int u) {
        nxt[u] = last[s2[u] - 'a'];
        int tmp = last[s2[u] - 'a'];
        last[s2[u] - 'a'] = u;
        for (int v : adj[u]) {
            dfs(adj, v);
        }
        last[s2[u] - 'a'] = tmp;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int N = sz(parent);
        vector<vector<int>> adj(N);
        for (int i = 1; i < N; i++) adj[parent[i]].pb(i);
        s2 = s;
        last = vector<int>(26, -1);
        nxt = vector<int>(N, -1);
        dfs(adj, 0);
        for (int i = 1; i < N; i++) {
            if (nxt[i] != -1) parent[i] = nxt[i];
        }
        for (int i = 0; i < N; i++) adj[i].clear();
        for (int i = 1; i < N; i++) adj[parent[i]].pb(i);
        queue<int> q; q.push(0);
        vector<int> srt;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            srt.pb(u);
            for (int v : adj[u]) {
                q.push(v);
            }
        }
        reverse(all(srt));
        vector<int> res(N, 1);
        for (int u : srt) {
            for (int v : adj[u]) {
                res[u] += res[v];
            }
        }
        return res;
    }
};",1434310082
Dylan Smith,DylanSmith,13,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n, 0), nxt(n, 0);
        for (int i = 0; i < k; i++) {
            fill(nxt.begin(), nxt.end(), 0);
            for (int j = 0; j < n; j++) {
                nxt[j] = max(nxt[j], dp[j] + stayScore[i][j]);
                for (int l = 0; l < n; l++) {
                    nxt[l] = max(nxt[l], dp[j] + travelScore[j][l]);
                }
            }
            swap(dp, nxt);
        }
        int res = 0;
        for (int i : dp) res = max(res, i);
        return res;
    }
};",1434315139
Dylan Smith,DylanSmith,13,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        set<string> st;
        for (int i = 0; i < (int)word.size(); i++) {
            int j = i;
            while (j + 1 < word.size() && word[j + 1] == word[j]) j++;
            for (int k = 1; k <= j - i + 1; k++) {
                string s = word.substr(0, i + k) + word.substr(j + 1);
                st.insert(s);
            }
            i = j;
        }
        return (int)st.size();
    }
};",1434265461
Dylan Smith,DylanSmith,13,3618,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)
class Solution {
public:
    int mod = 1000000007;
    int possibleStringCount(string word, int k) {
        vector<int> groups;
        for (int i = 0; i < (int)word.size(); i++) {
            int j = i;
            while (j + 1 < word.size() && word[j + 1] == word[j]) j++;
            groups.push_back(j - i + 1);
            i = j;
        }
        ll tot = 1;
        for (int i : groups) {
            tot *= i;
            tot %= mod;
        }
        if ((int)groups.size() >= k) {
            return tot;
        }
        vector<int> dp(k, 0), nxt(k, 0);
        dp[0] = 1;
        for (int i : groups) {
            fill(nxt.begin(), nxt.end(), 0);
            ll sum = 0;
            for (int j = 0; j < k; j++) {
                if (j - i - 1 >= 0) {
                    sum -= dp[j - i - 1];
                    if (sum < 0) sum += mod;
                }
                nxt[j] += sum;
                if (nxt[j] >= mod) nxt[j] -= mod;
                sum += dp[j];
                if (sum >= mod) sum -= mod;
            }
            swap(dp, nxt);
        }
        ll res = 0;
        for (int i : dp) {
            res += i;
            if (res >= mod) res -= mod;
        }
        res = (tot - res + mod) % mod;
        return res;
    }
};",1434298707
Ernest Lu,ernestlu,15,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        map<char, vector<int>> hit;

        const int n = (int)parent.size();
        vector<int> new_parent(n, -1);
        vector e(n, vector<int>());
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1)
                e[parent[i]].push_back(i);
        }

        auto dfs = [&](auto& dfs, int g) -> void {
            if (!hit[s[g]].empty()) {
                new_parent[g] = hit[s[g]].back();
            } else {
                new_parent[g] = parent[g];
            }
            hit[s[g]].push_back(g);
            for (auto u : e[g]) {
                dfs(dfs, u);
            } 
            hit[s[g]].pop_back();
            if (hit[s[g]].empty())
                hit.erase(s[g]);
        };
        dfs(dfs, 0);

        vector e2(n, vector<int>());
        for (int i = 0; i < n; i++) {
            if (new_parent[i] != -1)
                e2[new_parent[i]].push_back(i);
        }
        vector<int> sub(n, 0);
        auto dfs_2 = [&](auto& dfs_2, int g) -> void {
            sub[g] = 1;
            for (auto u : e2[g]) {
                dfs_2(dfs_2, u);
                sub[g] += sub[u];
            }  
        };
        dfs_2(dfs_2, 0);
        return sub;
    }
};",1434271155
Ernest Lu,ernestlu,15,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n, 0);

        for (int day = 0; day < k; day++) {
            vector<int> new_dp(n);
            for (int i = 0; i < n; i++) {
                new_dp[i] = max(new_dp[i], dp[i] + stayScore[day][i]);
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        new_dp[j] = max(new_dp[j], dp[i] + travelScore[i][j]);
                    }
                }
            }
            swap(new_dp, dp);
        }
        return *max_element(dp.begin(), dp.end());
    }
};",1434313857
Ernest Lu,ernestlu,15,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char pc = '!';
        int ch_len = -1;
        int ans = 0;
        for (auto u : word) {
            if (u != pc) {
                if (pc != '!') {
                    if (ch_len > 1)
                        ans += ch_len - 1;
                }
                pc = u;
                ch_len = 1;
            } else {
                ch_len++;
            }
        }
        if (ch_len > 1)
            ans += ch_len - 1;
        ans++;
        return ans;
    }
};",1434318627
Ernest Lu,ernestlu,15,3618,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};

class Solution {
public:
    int possibleStringCount(string word, int k) {
        int n = (int)word.size();

        vector<int> c;

        char pc = '!';
        int ch_len = 0;
        for (auto u : word) {
            if (u != pc) {
                if (pc != '!') {
                    //cout << u << ' ' << ch_len << ' ' << pc << ""\n"";
                    c.push_back(ch_len);
                }
                pc = u;
                ch_len = 1;
            } else {
                ch_len++;
            }
        }
        c.push_back(ch_len);
        for (auto& u : c) {
            u--;
            k--;
        }

        mint ans = 1;
        for (auto u : c)
            ans *= (u + 1);

        if (k > 0) {
            vector<mint> dp(k);
            dp[0] = 1;
            for (auto u : c) {
                vector<mint> new_dp(k);
                for (int i = 0; i < k; i++) {
                    int r = min(i + u, k - 1);
                    int l = i;
                    new_dp[l] += dp[i];
                    if (r != k - 1)
                        new_dp[r + 1] -= dp[i];
                }
                for (int i = 1; i < k; i++)
                    new_dp[i] += new_dp[i - 1];
                swap(dp, new_dp);
            }
            ans -= accumulate(dp.begin(), dp.end(), mint(0));
        }
        return ans.x;
    }
};",1434309204
kzyKT,kzyKT,16,3576,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

vector<ll> v[111111];
vector<int> p,ans;
map<char,ll> ma;
string s;

ll dfs(ll x) {
  ll z=-1,c=1;
  if(ma.count(s[x])) {
    z=ma[s[x]];
    p[x]=z;
  }
  ma[s[x]]=x;
  rep(i,v[x].size()) {
    ll y=v[x][i];
    c+=dfs(y);
  }
  ma.erase(s[x]);
  if(z!=-1) ma[s[x]]=z;
  ans[x]=c;
  return c;
}

class Solution {
public:
  vector<int> findSubtreeSizes(vector<int>& q, string ss) {
    s=ss;
    p=q;
    ans.clear();
    ll n=p.size();
    rep(i,n) ans.pb(0);
    rep(i,n) v[i].clear();
    REP(i,1,p.size()) v[p[i]].pb(i);
    dfs(0);
    rep(i,n) v[i].clear();
    REP(i,1,p.size()) v[p[i]].pb(i);
    dfs(0);
    return ans;
  }
};",1434273816
kzyKT,kzyKT,16,3587,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int maxScore(int n, int m, vector<vector<int>>& a, vector<vector<int>>& b) {
    int dp[m+1][n];
    rep(i,m+1)rep(j,n) dp[i][j]=-MAX;
    rep(i,n) dp[0][i]=0;
    rep(k,m) {
      rep(i,n) {
        dp[k+1][i]=max(dp[k+1][i],dp[k][i]+a[k][i]);
        rep(j,n) {
          dp[k+1][j]=max(dp[k+1][j],dp[k][i]+b[i][j]);
        }
      }
    }
    int ans=0;
    rep(i,n) ans=max(ans,dp[m][i]);
    return ans;
  }
};",1434280105
kzyKT,kzyKT,16,3617,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
    int possibleStringCount(string s) {
      vector<ll> v;
      ll c=1;
      REP(i,1,s.size()) {
        if(s[i-1]==s[i]) c++;
        else {
          v.pb(c);
          c=1;
        }
      }
      v.pb(c);
      ll ans=1;
      rep(i,v.size()) ans+=v[i]-1;
      return ans;
    }
};",1434311261
kzyKT,kzyKT,16,3618,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int possibleStringCount(string s, int m) {
    vector<ll> v;
    ll c=1;
    REP(i,1,s.size()) {
      if(s[i-1]==s[i]) c++;
      else {
        v.pb(c);
        c=1;
      }
    }
    v.pb(c);
    ll ans=1;
    rep(i,v.size()) {
      ans*=v[i];
      ans%=MAX;
    }
    if(v.size()>m) return ans;
    ll dp[2][m+1];
    mem(dp);
    dp[0][0]=1;
    rep(i,v.size()) {
      ll d=0;
      rep(j,m) {
        d+=dp[0][j];
        d%=MAX;
        if(j-v[i]>=0) {
          d-=dp[0][j-v[i]];
          d+=MAX;
          d%=MAX;
        }
        dp[1][j+1]+=d;
        dp[1][j+1]%=MAX;
      }
      rep(j,m) {
        dp[0][j]=dp[1][j];
        dp[1][j]=0;
      }
    }
    rep(i,m) {
      ans-=dp[0][i];
      ans+=MAX;
      ans%=MAX;
    }
    return ans;
  }
};",1434308222
ZHAO YANG,iftkaar,17,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] p, String s) {
        int n = p.length;
        List<List<Integer>> a0 = new ArrayList<>();
        List<Integer>[] cs = new List[26];
        
        iL(n, a0);
        iC(cs);
        bA(n, p, a0);
        
        int[] y = new int[n];
        Arrays.fill(y, -1);
        
        dFY(0, s, y, cs, a0);
        
        uP(n, p, y);
        
        List<List<Integer>> a = new ArrayList<>();
        iL(n, a);
        bA(n, p, a);
        
        int[] r = new int[n];
        dS(0, a, r);
        return r;
    }
    
    private void iL(int n, List<List<Integer>> a) {
        int i = 0;
        while(i < n) {
            a.add(new ArrayList<>());
            i++;
        }
    }
    
    private void iC(List<Integer>[] cs) {
        int i = 0;
        while(i < 26) {
            cs[i] = new ArrayList<>();
            i++;
        }
    }
    
    private void bA(int n, int[] p, List<List<Integer>> a) {
        int i = 1;
        while(i < n) {
            a.get(p[i]).add(i);
            i++;
        }
    }
    
    private void uP(int n, int[] p, int[] y) {
        int i = 1;
        while(i < n) {
            p[i] = y[i] == -1 ? p[i] : y[i];
            i++;
        }
    }
    
    private void dFY(int u, String s, int[] y, List<Integer>[] cs, List<List<Integer>> a0) {
        int c = s.charAt(u) - 'a';
        y[u] = cs[c].isEmpty() ? -1 : cs[c].get(cs[c].size() - 1);
        cs[c].add(u);
        pC(u, s, y, cs, a0);
        cs[c].remove(cs[c].size() - 1);
    }
    
    private void pC(int u, String s, int[] y, List<Integer>[] cs, List<List<Integer>> a0) {
        int i = 0;
        List<Integer> l = a0.get(u);
        while(i < l.size()) {
            dFY(l.get(i), s, y, cs, a0);
            i++;
        }
    }
    
    private int dS(int u, List<List<Integer>> a, int[] r) {
        int z = 1;
        z = pS(u, a, r, z);
        return r[u] = z;
    }
    
    private int pS(int u, List<List<Integer>> a, int[] r, int z) {
        int i = 0;
        List<Integer> l = a.get(u);
        while(i < l.size()) {
            z += dS(l.get(i), a, r);
            i++;
        }
        return z;
    }
}",1434295105
ZHAO YANG,iftkaar,17,3587,java,"class Solution {
    private int getMt(int j, int n, int[][] p, int[][] t) {
        int m = 0, l = 0;
        while (l < n) {
            m = l == j ? m : Math.max(m, p[l][0] + t[l][j]);
            l++;
        }
        return m;
    }
    
    private int getMtf(int j, int n, int[][] t) {
        int m = 0, l = 0;
        while (l < n) {
            m = l == j ? m : Math.max(m, t[l][j]);
            l++;
        }
        return m;
    }
    
    private void pfd(int n, int[][] p, int[][] s, int[][] t) {
        int j = 0;
        while (j < n) {
            p[j][0] = Math.max(s[0][j], getMtf(j, n, t));
            j++;
        }
    }
    
    private void pcd(int d, int n, int[][] p, int[][] c, int[][] s, int[][] t) {
        int j = 0;
        while (j < n) {
            c[j][0] = Math.max(p[j][0] + s[d][j], getMt(j, n, p, t));
            j++;
        }
    }
    
    public int maxScore(int n, int k, int[][] s, int[][] t) {
        int[][] p = new int[n][1];
        int[][] c = new int[n][1];
        
        pfd(n, p, s, t);
        
        int d = 1;
        while (d < k) {
            pcd(d, n, p, c, s, t);
            
            int j = 0;
            while (j < n) {
                p[j][0] = c[j][0];
                j++;
            }
            d++;
        }
        
        int m = p[0][0];
        int j = 1;
        while (j < n) {
            m = Math.max(m, p[j][0]);
            j++;
        }
        return m;
    }
}",1434274829
ZHAO YANG,iftkaar,17,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int cnt = 1; 
        for (int i = 1; i < word.length(); ++i) {
            cnt += (word.charAt(i) == word.charAt(i - 1)) ? 1 : 0;
        }
        return cnt;
    }
}",1434261461
ZHAO YANG,iftkaar,17,3618,java,"class Solution {
    private final int MOD = 1_000_000_007;
    
    public int possibleStringCount(String w, int k) {
        return w.length() == 0 ? 0 : calcResult(w, k);
    }
    
    private int calcResult(String w, int k) {
        List<int[]> r = getRLE(w);
        long t = getProduct(r);
        
        return r.size() >= k ? (int)(t % MOD) : 
               getSum(r) < k ? 0 : 
               (int)((t - getDPSum(r, k) + MOD) % MOD);
    }
    
    private List<int[]> getRLE(String w) {
        List<int[]> r = new ArrayList<>();
        int i = 1;
        RunState state = new RunState(w.charAt(0), 1);
        
        while (i < w.length()) {
            state = w.charAt(i) == state.curr ? 
                   new RunState(state.curr, state.cnt + 1) :
                   addRun(r, state, w.charAt(i));
            i++;
        }
        r.add(new int[]{state.curr - 'a', state.cnt});
        return r;
    }
    
    private static class RunState {
        final char curr;
        final int cnt;
        
        RunState(char curr, int cnt) {
            this.curr = curr;
            this.cnt = cnt;
        }
    }
    
    private RunState addRun(List<int[]> r, RunState state, char newChar) {
        r.add(new int[]{state.curr - 'a', state.cnt});
        return new RunState(newChar, 1);
    }
    
    private long getProduct(List<int[]> r) {
        long[] t = {1};
        r.forEach(p -> t[0] = (t[0] * p[1]) % MOD);
        return t[0];
    }
    
    private long getSum(List<int[]> r) {
        return r.stream().mapToLong(p -> p[1]).sum();
    }
    
    private long getDPSum(List<int[]> r, int k) {
        int ms = k - 1;
        long[] dp = new long[ms + 1];
        dp[0] = 1;
        
        r.forEach(p -> updateDP(dp, p[1], ms));
        
        return Arrays.stream(dp).reduce(0L, (a, b) -> (a + b) % MOD);
    }
    
    private void updateDP(long[] dp, int len, int ms) {
        long[] pre = getPrefixSums(dp, ms);
        long[] tmp = new long[ms + 1];
        
        int j = 0;
        while (j <= ms) {
            tmp[j] = j > 0 ? 
                    ((j - 1 >= 0 ? pre[j - 1] : 0) - 
                    (j - len - 1 >= 0 ? pre[j - len - 1] : 0) + MOD) % MOD : 
                    0;
            j++;
        }
        
        System.arraycopy(tmp, 0, dp, 0, ms + 1);
    }
    
    private long[] getPrefixSums(long[] dp, int ms) {
        long[] pre = new long[ms + 1];
        pre[0] = dp[0];
        
        int j = 1;
        while (j <= ms) {
            pre[j] = (pre[j - 1] + dp[j]) % MOD;
            j++;
        }
        
        return pre;
    }
}",1434319206
BERNARD BRAHIMCHA,BERNARB01,19,3576,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> findSubtreeSizes(vector<int>& parent, string s) {
    int n = int(s.length());
    vector<vector<int>> g(n);
    for (int i = 1; i < n; i++) {
      g[parent[i]].push_back(i);
    }
    vector<int> new_parent(n);
    vector<int> order;
    vector<vector<int>> last(26);
    auto Dfs = [&](auto&& self, int v) -> void {
      order.push_back(v);
      int c = int(s[v] - 'a');
      if (last[c].empty()) {
        new_parent[v] = parent[v];
      } else {
        new_parent[v] = last[c].back();
      }
      last[c].push_back(v);
      for (int u : g[v]) {
        self(self, u);
      }
      last[c].pop_back();
    };
    Dfs(Dfs, 0);
    deb(order);
    deb(new_parent);
    vector<int> sbt(n, 1);
    for (int i = n - 1; i > 0; i--) {
      int v = order[i];
      sbt[new_parent[v]] += sbt[v];
    }
    return sbt;
  }
};

#ifdef B01
int main() {
  Solution sl;
  vector<int> z = {-1,0,0,1,1,1};
  deb(sl.findSubtreeSizes(z, ""abaabc""));
  z = {-1,0,4,0,1};
  deb(sl.findSubtreeSizes(z, ""abbba""));
}
#endif
",1434322558
BERNARD BRAHIMCHA,BERNARB01,19,3587,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    vector<int> dp(n);
    for (int i = 0; i < k; i++) {
      vector<int> new_dp(n);
      for (int j = 0; j < n; j++) {
        for (int t = 0; t < n; t++) {
          if (t == j) {
            new_dp[t] = max(new_dp[t], dp[j] + stayScore[i][j]);
          } else {
            new_dp[t] = max(new_dp[t], dp[j] + travelScore[j][t]);
          }
        }
      }
      swap(dp, new_dp);
    }
    return *max_element(dp.begin(), dp.end());
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1434307839
BERNARD BRAHIMCHA,BERNARB01,19,3617,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int possibleStringCount(string s) {
    int n = int(s.length());
    int ans = 0;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && s[end + 1] == s[beg]) {
        end += 1;
      }
      ans += end - beg;
      beg = end + 1;
    }
    return ans + 1;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1434299941
BERNARD BRAHIMCHA,BERNARB01,19,3618,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

class Solution {
 public:
  int possibleStringCount(string s, int k) {
    int n = int(s.length());
    string t = """";
    vector<int> a;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && s[end + 1] == s[beg]) {
        end += 1;
      }
      t.push_back(s[end]);
      a.push_back(end - beg + 1);
      beg = end + 1;
    }
    swap(s, t);
    n = int(s.length());
    int res = 1;
    for (int x : a) {
      res = mul(res, x);
    }
    if (n >= k) {
      return res;
    }
    vector<int> dp(k);
    dp[0] = 1;
    k -= n;
    for (int i = 0; i < n; i++) {
      a[i] -= 1;
    }
    for (int i = 0; i < n; i++) {
      vector<int> new_dp(k);
      for (int j = 0; j < k; j++) {
        if (j > 0) {
          add(dp[j], dp[j - 1]);
        }
        new_dp[j] = dp[j];
        if (j > a[i]) {
          sub(new_dp[j], dp[j - a[i] - 1]);
        }
      }
      swap(dp, new_dp);
    }
    for (int x : dp) {
      sub(res, x);
    }
    return res;
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.possibleStringCount(""aabbccdd"", 7));
  deb(sl.possibleStringCount(""aabbccdd"", 8));
  deb(sl.possibleStringCount(""aaabbb"", 3));
}
#endif
",1434295600
lilPeep,stupidRR,21,3576,cpp,"class Solution {
    void dfs(int node,vector<vector<int>>&g,string &s,vector<vector<int>>&gNew,vector<int>&parent)
    {
        for(auto child : g[node])
        {
            if( parent[ s[child]-'a' ]!=-1 )
                gNew[ parent[ s[child]-'a' ] ].push_back(child);
            else
                gNew[ node ].push_back(child);            
            int tmp= parent[ s[child]-'a' ];
            parent[ s[child]-'a' ]=child;
            dfs(child,g,s,gNew,parent);
            parent[ s[child]-'a' ]=tmp;
        }
    }
    void dfs2(int node,vector<vector<int>>&g,vector<int>&subtree)
    {
        for(auto child : g[node])
        {
            dfs2(child,g,subtree);
            subtree[node]+=subtree[child];
        }
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=s.size();
        vector<vector<int>> g(n);
        for(int i=1;i<n;i++)
            g[ parent[i] ].push_back(i);
        
        vector<int> parental(26,-1);
        parental[ s[0]-'a' ]=0;
        vector<vector<int>> gNew(n+1);
        dfs(0,g,s,gNew,parental);
        
        vector<int> subtree(n,1);
        dfs2(0,gNew,subtree);
        return subtree;
    }
};",1434280566
lilPeep,stupidRR,21,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n,0);
        for(int i=0;i<k;i++)
        {
            vector<int> ndp(n);
            for(int city=0;city<n;city++)
                ndp[city]=std::max(dp[city]+stayScore[i][city],ndp[city]);
            
            for(int curr=0;curr<n;curr++)
            {
                for(int dest=0;dest<n;dest++)
                {
                    if(curr!=dest)
                        ndp[dest]=std::max(ndp[dest],dp[curr]+travelScore[curr][dest]);
                }
            }
            swap(ndp,dp);
        }
        
        return *max_element(dp.begin(),dp.end());
    }
};",1434288220
lilPeep,stupidRR,21,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=1;i<word.size();i++)
        {
            if(word[i]==word[i-1])
                ans++;
        }
        return ans;
    }
};",1434259817
lilPeep,stupidRR,21,3618,cpp,"class Solution {
    const int mod=1e9+7;
public:
    int possibleStringCount(string word, int k) {
        vector< pair<char,int> > compress;
        compress.push_back( {word[0],1} );
        for(int i=1;i<word.size();i++)
        {
            if( compress.back().first == word[i] )
                compress.back().second++;
            else
                compress.push_back( {word[i],1} );
        }
        
        long long sub=0ll;
        if( k>compress.size() )
        {
            vector<long long> dp(k,0ll);
            dp[0]=1ll;
            for(auto &[val,freq] : compress)
            {
                for(int i=1;i<k;i++)
                    dp[i]=dp[i]+dp[i-1];

                vector<long long> ndp(k);
                for(int i=1;i<k;i++)
                {
                    ndp[i]=dp[i-1];
                    if(i-freq>0)
                        ndp[i]-=dp[i-freq-1];
                    ndp[i]=ndp[i]%mod;
                }

                swap(ndp,dp);

            }
            
            for(int i=0;i<k;i++)
                sub=(sub+dp[i])%mod;
        }
        
        long long mul=1ll;
        for(auto &[val,freq] : compress)
            mul=(mul*1ll*freq)%mod;
    
        return (mul-sub+mod)%mod;
    }
};",1434323636
congthanh2000,congthanh2000,22,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<vector<int>> vertices(26);
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++) {
            int p = parent[i];
            adj[p].push_back(i);
        }
        vector<int> closest(n, -1);
        vector<int> subtree(n);
        function<void(int)> dfs = [&](int u) {
            int c = s[u] - 'a';
            if (!vertices[c].empty()) {
                closest[u] = vertices[c].back();
            }
            subtree[u] = 1;
            vertices[c].push_back(u);
            for (int v : adj[u]) {
                dfs(v);
                subtree[u] += subtree[v];
            }
            vertices[c].pop_back();
        };
        dfs(0);
        for (int i = 0; i < n; i++) {
            if (closest[i] != -1) {
                parent[i] = closest[i];
            }
            adj[i].clear();
        }
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        dfs(0);
        return subtree;
    }
};",1434275948
congthanh2000,congthanh2000,22,3587,cpp,"const int INF = 1e9 + 100;
class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int>(k + 1, -INF));
        for (int i = 0; i < n; i++) dp[i][0] = 0;
        for (int d = 0; d < k; d++) {
            for (int u = 0; u < n; u++) {
                if (dp[u][d] != INF) {
                    dp[u][d + 1] = max(dp[u][d + 1], dp[u][d] + stayScore[d][u]);
                    for (int v = 0; v < n; v++) {
                        dp[v][d + 1] = max(dp[v][d + 1], dp[u][d] + travelScore[u][v]);
                    }
                }
            }
        }
        int ans = 0;
        for (int u = 0; u < n; u++) ans = max(ans, dp[u][k]);
        return ans;
    }
};",1434283113
congthanh2000,congthanh2000,22,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 1;
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && word[i] == word[j]) j++;
            ans += j - i - 1;
            i = j;
        }
        return ans;
    }
};",1434261225
congthanh2000,congthanh2000,22,3618,cpp,"const int MOD = 1e9 + 7;

/// MOD NUM, MOD < 2^31
template <int _MOD>
class num_t {
    //    long long Mul(long long x, long long y,long long m) /// Tinh (x * y) mod M voi (x,y, M <= 10 ^ 18)
    //    {
    //        x %= m; y %= m;
    //        long long q = (long double) x * y / m;
    //        long long r = (x * y - q * m) % m;
    //        if (r < 0) r += m;
    //        return r;
    //    }
    static constexpr int MOD = _MOD;

   private:
    int value;

    static int power(int a, int n) {
        int ans = 1;
        for (; n; n >>= 1, a = 1LL * a * a % MOD) {
            if (n & 1) {
                ans = 1LL * ans * a % MOD;
            }
        }
        return ans;
    }

    //    static int inverse(int a, int m) {
    //        a %= m;
    //        assert(a);
    //        return a == 1 ? 1 : int(m - 1LL * inverse(m, a)) * m / a);
    //    }

    static int inverse(int a) {
        return power(a, MOD - 2);
    }

   public:
    num_t() : value(0) {};
    template <typename U>
    num_t(U _value) {
        value = _value % MOD;
        if (value < 0) value += MOD;
    }

    friend ostream &operator<<(ostream &out, const num_t &n) { return out << int(n); }
    friend istream &operator>>(istream &in, num_t &n) {
        long long _value;
        in >> _value;
        n = num_t(_value);
        return in;
    }

    bool operator==(const num_t &other) { return value == other.value; }
    bool operator!=(const num_t &other) { return !(*this == other); }

    void operator=(const num_t &other) { value = other.value; }

    template <typename U>
    void operator=(U other) { value = other; };

    operator int() const { return value; }

    num_t power(int n) const {
        num_t ans;
        ans.value = power(value, n);
        return ans;
    };

    num_t inverse() const {
        num_t ans;
        ans.value = inverse(value);
        return ans;
    }

    friend num_t inverse(const num_t &other) { return other.inverse(); }

    num_t &operator+=(const num_t &other) {
        value += other.value;
        if (value >= MOD) value -= MOD;
        return *this;
    }

    template <typename U>
    num_t &operator+=(U other) {
        return *this += num_t(other);
    }

    num_t &operator-=(const num_t &other) {
        value -= other.value;
        if (value < 0) value += MOD;
        return *this;
    }

    template <typename U>
    num_t &operator-=(U other) {
        return *this -= num_t(other);
    }

    num_t &operator*=(const num_t &other) {
        value = 1LL * value * other.value % MOD;
        return *this;
    }

    num_t &operator/=(const num_t &other) {
        return *this *= other.inverse();
    }

    num_t &operator++() {
        value++;
        if (value >= MOD) value -= MOD;
        return *this;
    }

    num_t operator++(int) {
        num_t ans(*this);
        *this += 1;
        return ans;
    }

    num_t &operator--() {
        value++;
        if (value < 0) value += MOD;
        return *this;
    }

    num_t operator--(int) {
        num_t ans(*this);
        this -= 1;
        return ans;
    }

    num_t operator-() const {
        return num_t(-value);
    }

    friend num_t operator+(const num_t &a, const num_t &b) { return num_t(a) += b; }
    template <typename U>
    friend num_t operator+(const num_t &a, U b) { return num_t(a) += b; }
    template <typename U>
    friend num_t operator+(U a, const num_t &b) { return num_t(a) += b; }

    friend num_t operator-(const num_t &a, const num_t &b) { return num_t(a) -= b; }
    template <typename U>
    friend num_t operator-(const num_t &a, U b) { return num_t(a) -= b; }
    template <typename U>
    friend num_t operator-(U a, const num_t &b) { return num_t(a) -= b; }

    friend num_t operator*(const num_t &a, const num_t &b) { return num_t(a) *= b; }
    template <typename U>
    friend num_t operator*(const num_t &a, U b) { return num_t(a) *= b; }
    template <typename U>
    friend num_t operator*(U a, const num_t &b) { return num_t(a) *= b; }

    friend num_t operator/(const num_t &a, const num_t &b) { return num_t(a) /= b; }
    template <typename U>
    friend num_t operator/(const num_t &a, U b) { return num_t(a) /= b; }
    template <typename U>
    friend num_t operator/(U a, const num_t &b) { return num_t(a) /= b; }
};

/// usage
using type = num_t<MOD>;
class Solution {
   public:
    int possibleStringCount(string word, int k) {
        vector<int> a;
        for (int i = 0; i < word.size(); ) {
            int j = i;
            while (j < word.size() && word[i] == word[j]) j++;
            a.push_back(j - i);
            i = j;
        }
        type ans = 1;
        for (int x : a) ans *= x;
        if (a.size() >= k) {
            return ans;
        }
        vector<type> sum_dp(k, 1);
        vector<type> dp(k, 0);
        for (int x : a) {
            for (int i = k - 1; i >= 1; i--) {
                int l = max(0, i - x);
                dp[i] = sum_dp[i - 1];
                if (l > 0) {
                    dp[i] -= sum_dp[l - 1];
                }
            }
            sum_dp[0] = dp[0];
            for (int i = 1; i < k; i++) sum_dp[i] = sum_dp[i - 1] + dp[i];
        }
        ans -= sum_dp[k - 1];
        return ans;
    }
};",1434310473
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        this->s = s;
        this->n = n;

        adj.resize(n);
        new_adj.resize(n);
        char_stack.resize(26);
        new_parent.resize(n);
        subtree_size.resize(n);

        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                adj[parent[i]].push_back(i);
            }
        }

        for (int i = 0; i < n; ++i) {
            new_parent[i] = parent[i];
        }

        dfs(0, -1);

        vector<int> roots;
        for (int i = 0; i < n; ++i) {
            if (new_parent[i] == -1) {
                roots.push_back(i);
            } else {
                new_adj[new_parent[i]].push_back(i);
            }
        }

        for (int root : roots) {
            compute_subtree_size(root);
        }

        vector<int> answer(n);
        for (int i = 0; i < n; ++i) {
            answer[i] = subtree_size[i];
        }
        return answer;
    }
private:
    int n;
    string s;
    vector<vector<int>> adj;           
    vector<vector<int>> new_adj;       
    vector<vector<int>> char_stack;    
    vector<int> new_parent;            
    vector<int> subtree_size;          

    void dfs(int node, int parent) {
        int c = s[node] - 'a';
        char_stack[c].push_back(node);
        if (char_stack[c].size() >= 2) {
            int y = char_stack[c][char_stack[c].size() - 2];
            new_parent[node] = y;
        } else {
            new_parent[node] = parent;
        }
        for (int child : adj[node]) {
            if (child != parent) {
                dfs(child, node);
            }
        }
        char_stack[c].pop_back();
    }

    int compute_subtree_size(int node) {
        int size = 1; 
        for (int child : new_adj[node]) {
            size += compute_subtree_size(child);
        }
        subtree_size[node] = size;
        return size;
    }
};
",1434284410
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(2, vector<int>(n, INT_MIN));

        for (int s = 0; s < n; ++s) {
            dp[0][s] = max(dp[0][s], stayScore[0][s]);
            for (int c = 0; c < n; ++c) {
                if (s != c) {
                    dp[0][c] = max(dp[0][c], travelScore[s][c]);
                }
            }
        }

        for (int day = 1; day < k; ++day) {
            vector<int>& prev_dp = dp[(day - 1) % 2];
            vector<int>& curr_dp = dp[day % 2];
            fill(curr_dp.begin(), curr_dp.end(), INT_MIN);

            for (int city = 0; city < n; ++city) {
                if (prev_dp[city] != INT_MIN) {
                    curr_dp[city] = max(curr_dp[city], prev_dp[city] + stayScore[day][city]);
                }
            }

            for (int curr_city = 0; curr_city < n; ++curr_city) {
                for (int prev_city = 0; prev_city < n; ++prev_city) {
                    if (prev_dp[prev_city] != INT_MIN && prev_city != curr_city) {
                        int points = prev_dp[prev_city] + travelScore[prev_city][curr_city];
                        curr_dp[curr_city] = max(curr_dp[curr_city], points);
                    }
                }
            }
        }

        int result = INT_MIN;
        for (int city = 0; city < n; ++city) {
            result = max(result, dp[(k - 1) % 2][city]);
        }
        return result;
    }
};
",1434305833
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int total_reductions = 0;
        int n = word.size();
        int i = 0;
        while (i < n) {
            char current_char = word[i];
            int count = 0;
            while (i < n && word[i] == current_char) {
                count++;
                i++;
            }
            if (count > 1) {
                total_reductions += count - 1;
            }
        }
        return 1 + total_reductions;
    }
};",1434273610
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3618,cpp,"
class Solution {
const int MOD = 1e9 + 7;

public:
    int possibleStringCount(string word, int k) {
        int n = word.size();
        vector<int> groupLens;
        int G = 0;
        int count = 1;

        for (int i = 1; i <= n; ++i) {
            if (i == n || word[i] != word[i - 1]) {
                groupLens.push_back(count);
                G++;
                count = 1;
            } else {
                count++;
            }
        }

        long long total_combinations = 1;
        for (int len : groupLens) {
            total_combinations = (total_combinations * len) % MOD;
        }

        int T = k - G;
        if (T <= 0) {
            return (int)total_combinations;
        }

        int max_T = T;
        vector<int> dp(T + 1, 0);
        dp[0] = 1;

        for (int len : groupLens) {
            int max_delta = min(len - 1, T);
            vector<int> dp_new(T + 1, 0);
            int window_sum = 0;
            for (int s = 0; s <= T; ++s) {
                window_sum = (window_sum + dp[s]) % MOD;
                if (s - max_delta - 1 >= 0) {
                    window_sum =
                        (window_sum - dp[s - max_delta - 1] + MOD) % MOD;
                }
                dp_new[s] = window_sum;
            }
            dp = dp_new;
        }

        long long total_bad = 0;
        for (int s = 0; s < T; ++s) {
            total_bad = (total_bad + dp[s]) % MOD;
        }

        long long total_ways = (total_combinations - total_bad + MOD) % MOD;
        return (int)total_ways;
    }
};",1434318314
unicorn_15,unicorn_15,7,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n, vector<int>());
        for(int i = 1; i < n; ++i){
            tree[parent[i]].push_back(i);
        }
        vector<int> new_parent = parent;
        vector<int> last(256, -1);
        function<void(int)> dfs = [&](int u) {
            char c = s[u];
            int prev = last[c];
            if(prev != -1 && u != 0){
                new_parent[u] = prev;
            }
            last[c] = u;
            for(auto v: tree[u]){
                dfs(v);
            }
            last[c] = prev;
        };
        dfs(0);
        vector<vector<int>> new_tree(n, vector<int>());
        for(int i = 0; i < n; ++i){
            if(new_parent[i] != -1){
                new_tree[new_parent[i]].push_back(i);
            }
        }
        vector<int> res(n, 0);
        function<int(int)> count_subtree = [&](int u) -> int {
            res[u] = 1;
            for(auto v: new_tree[u]){
                res[u] += count_subtree(v);
            }
            return res[u];
        };
        count_subtree(0);
        return res;
    }
};",1434268727
unicorn_15,unicorn_15,7,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
         vector<vector<int>> dp(k, vector<int>(n, INT32_MIN));
        for(int curr = 0; curr < n; ++curr){
            dp[0][curr] = stayScore[0][curr];
            for(int prev = 0; prev < n; ++prev){
                dp[0][curr] = max(dp[0][curr], travelScore[prev][curr]);
            }
        }
        for(int i = 1; i < k; ++i){
            for(int curr = 0; curr < n; ++curr){
                int stay = dp[i-1][curr] + stayScore[i][curr];
                int move = INT32_MIN;
                for(int prev = 0; prev < n; ++prev){
                    move = max(move, dp[i-1][prev] + travelScore[prev][curr]);
                }
                dp[i][curr] = max(stay, move);
            }
        }
        return *max_element(dp[k-1].begin(), dp[k-1].end());
    }
};",1434272885
unicorn_15,unicorn_15,7,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
         std::vector<int> runs;
        char prev = '\0';
        int count = 0;
        
        // Iterate through each character in the word
        for(char c : word){
            if(c == prev){
               
                count += 1;
            }
            else{
                
                if(prev != '\0'){
                    runs.push_back(count);
                }
               
                prev = c;
                count = 1;
            }
        }
        // Don't forget to add the count of the last run
        runs.push_back(count);
        
        
        int result = 0;
        for(auto r : runs){
            result += (r - 1);
        }
        return result + 1;
    }
};",1434266096
unicorn_15,unicorn_15,7,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

class Solution {
public:
    int possibleStringCount(string word, int k) {
        const int MOD = 1e9 + 7;
        vector<int> run_lengths;
        int n = word.size();
        
        if(n == 0){
            return (k <= 0) ? 1 : 0;
        }
        
        char current_char = word[0];
        int count = 1;
        for(int i = 1; i < n; ++i){
            if(word[i] == current_char){
                count++;
            }
            else{
                run_lengths.push_back(count);
                current_char = word[i];
                count = 1;
            }
        }
        run_lengths.push_back(count);
        int m = run_lengths.size();
        
        ll total_sequences = 1;
        for(auto &x : run_lengths){
            total_sequences = (total_sequences * (ll)x) % MOD;
        }
        
        int T = k - m;
        if(T <= 0){
            return total_sequences;
        }
        
        int S = T - 1;
        vector<int> L;
        for(auto &x : run_lengths){
            L.push_back(x - 1);
        }
        
        vector<ll> dp_prev(S + 1, 0);
        vector<ll> dp_curr(S + 1, 0);
        dp_prev[0] = 1;
        
        for(int i = 0; i < m; ++i){
            vector<ll> prefix(S + 2, 0);
            for(int j = 0; j <= S; j++){
                prefix[j + 1] = (prefix[j] + dp_prev[j]) % MOD;
            }
            for(int j = 0; j <= S; j++){
                int lower = max(0, j - L[i]);
                dp_curr[j] = (prefix[j + 1] - prefix[lower] + MOD) % MOD;
            }
            dp_prev.swap(dp_curr);
            fill(dp_curr.begin(), dp_curr.end(), 0);
        }
        
        ll invalid_sequences = 0;
        for(int j = 0; j <= S; j++){
            invalid_sequences = (invalid_sequences + dp_prev[j]) % MOD;
        }
        
        ll valid_sequences = (total_sequences - invalid_sequences + MOD) % MOD;
        return (int)valid_sequences;
    }
};
",1434307425
kmjp,kmjp,11,3576,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


int P[505050];
int S[505050];
vector<int> E[505050];
vector<int> E2[505050];
int C[505050];
class Solution {
public:
	void dfs(int cur,vector<int>& V) {
		if(cur) {
			if(V[S[cur]]!=-1) {
				E2[V[S[cur]]].push_back(cur);
			}
			else {
				E2[P[cur]].push_back(cur);
			}
		}
		int pre=V[S[cur]];
		V[S[cur]]=cur;
		FORR(e,E[cur]) dfs(e,V);
		V[S[cur]]=pre;
	}
	int dfs2(int cur) {
		C[cur]=1;
		FORR(e,E2[cur]) C[cur]+=dfs2(e);
		return C[cur];
	}
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
		int i;
		int N=parent.size();
		FOR(i,N) {
			E[i].clear(),E2[i].clear();
			S[i]=s[i]-'a';
			P[i]=parent[i];
		}
		FOR(i,N) if(i) E[parent[i]].push_back(i);
		vector<int> V(26,-1);
		dfs(0,V);
		dfs2(0);
		vector<int> R;
		FOR(i,N) R.push_back(C[i]);
		return R;
        
    }
};
",1434283332
kmjp,kmjp,11,3587,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


ll dp[202][202];

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        ZERO(dp);
        int i,x,y;
        FOR(i,k) {
			FOR(x,n) dp[i+1][x]=max(dp[i+1][x],dp[i][x]+stayScore[i][x]);
			FOR(x,n) FOR(y,n)  dp[i+1][y]=max(dp[i+1][y],dp[i][x]+travelScore[x][y]);
		}
		ll ma=0;
		FOR(x,n) ma=max(ma,dp[k][x]);
		return ma;
    }
};
",1434266524
kmjp,kmjp,11,3617,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------



class Solution {
public:
    int possibleStringCount(string word) {
		int ret=1;
		int i;
		for(i=1;i<word.size();i++) if(word[i]==word[i-1]) ret++;
		return ret;
        
    }
};
",1434269420
kmjp,kmjp,11,3618,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

const ll mo=1000000007;
ll from[2020];
ll to[2020];
class Solution {
public:
    int possibleStringCount(string word, int k) {
		vector<pair<int,int>> V;
		FORR(c,word) {
			if(V.empty()||V.back().first!=c) V.push_back({c,0});
			V.back().second++;
		}
		if(V.size()>=k) {
			ll ret=1;
			FORR(v,V) ret=ret*v.second%mo;
			return ret;
		}
		
		ZERO(from);
		from[0]=1;
		int x;
		FORR(v,V) {
			int y=v.second;
			ZERO(to);
			for(x=0;x<=k;x++) {
				to[x+1]+=from[x];
				if(x+y<=k) {
					to[x+y+1]+=mo-from[x];
				}
				else {
					int more=x+y-k;
					to[k+1]+=mo-from[x];
					(to[k]+=more*from[x])%=mo;
					
				}
			}
			for(x=0;x<=k;x++) {
				from[x]=to[x]%mo;
				if(x) (from[x]+=from[x-1])%=mo;
			}
		}
		
		return from[k]%mo;
			
		
        
    }
};
",1434303901
Dylan Smith,DylanSmith,13,3576,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)
class Solution {
public:
    string s2;
    vector<int> last, nxt;
    void dfs(vector<vector<int>> &adj, int u) {
        nxt[u] = last[s2[u] - 'a'];
        int tmp = last[s2[u] - 'a'];
        last[s2[u] - 'a'] = u;
        for (int v : adj[u]) {
            dfs(adj, v);
        }
        last[s2[u] - 'a'] = tmp;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int N = sz(parent);
        vector<vector<int>> adj(N);
        for (int i = 1; i < N; i++) adj[parent[i]].pb(i);
        s2 = s;
        last = vector<int>(26, -1);
        nxt = vector<int>(N, -1);
        dfs(adj, 0);
        for (int i = 1; i < N; i++) {
            if (nxt[i] != -1) parent[i] = nxt[i];
        }
        for (int i = 0; i < N; i++) adj[i].clear();
        for (int i = 1; i < N; i++) adj[parent[i]].pb(i);
        queue<int> q; q.push(0);
        vector<int> srt;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            srt.pb(u);
            for (int v : adj[u]) {
                q.push(v);
            }
        }
        reverse(all(srt));
        vector<int> res(N, 1);
        for (int u : srt) {
            for (int v : adj[u]) {
                res[u] += res[v];
            }
        }
        return res;
    }
};",1434310082
Dylan Smith,DylanSmith,13,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n, 0), nxt(n, 0);
        for (int i = 0; i < k; i++) {
            fill(nxt.begin(), nxt.end(), 0);
            for (int j = 0; j < n; j++) {
                nxt[j] = max(nxt[j], dp[j] + stayScore[i][j]);
                for (int l = 0; l < n; l++) {
                    nxt[l] = max(nxt[l], dp[j] + travelScore[j][l]);
                }
            }
            swap(dp, nxt);
        }
        int res = 0;
        for (int i : dp) res = max(res, i);
        return res;
    }
};",1434315139
Dylan Smith,DylanSmith,13,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        set<string> st;
        for (int i = 0; i < (int)word.size(); i++) {
            int j = i;
            while (j + 1 < word.size() && word[j + 1] == word[j]) j++;
            for (int k = 1; k <= j - i + 1; k++) {
                string s = word.substr(0, i + k) + word.substr(j + 1);
                st.insert(s);
            }
            i = j;
        }
        return (int)st.size();
    }
};",1434265461
Dylan Smith,DylanSmith,13,3618,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)
class Solution {
public:
    int mod = 1000000007;
    int possibleStringCount(string word, int k) {
        vector<int> groups;
        for (int i = 0; i < (int)word.size(); i++) {
            int j = i;
            while (j + 1 < word.size() && word[j + 1] == word[j]) j++;
            groups.push_back(j - i + 1);
            i = j;
        }
        ll tot = 1;
        for (int i : groups) {
            tot *= i;
            tot %= mod;
        }
        if ((int)groups.size() >= k) {
            return tot;
        }
        vector<int> dp(k, 0), nxt(k, 0);
        dp[0] = 1;
        for (int i : groups) {
            fill(nxt.begin(), nxt.end(), 0);
            ll sum = 0;
            for (int j = 0; j < k; j++) {
                if (j - i - 1 >= 0) {
                    sum -= dp[j - i - 1];
                    if (sum < 0) sum += mod;
                }
                nxt[j] += sum;
                if (nxt[j] >= mod) nxt[j] -= mod;
                sum += dp[j];
                if (sum >= mod) sum -= mod;
            }
            swap(dp, nxt);
        }
        ll res = 0;
        for (int i : dp) {
            res += i;
            if (res >= mod) res -= mod;
        }
        res = (tot - res + mod) % mod;
        return res;
    }
};",1434298707
Ernest Lu,ernestlu,15,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        map<char, vector<int>> hit;

        const int n = (int)parent.size();
        vector<int> new_parent(n, -1);
        vector e(n, vector<int>());
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1)
                e[parent[i]].push_back(i);
        }

        auto dfs = [&](auto& dfs, int g) -> void {
            if (!hit[s[g]].empty()) {
                new_parent[g] = hit[s[g]].back();
            } else {
                new_parent[g] = parent[g];
            }
            hit[s[g]].push_back(g);
            for (auto u : e[g]) {
                dfs(dfs, u);
            } 
            hit[s[g]].pop_back();
            if (hit[s[g]].empty())
                hit.erase(s[g]);
        };
        dfs(dfs, 0);

        vector e2(n, vector<int>());
        for (int i = 0; i < n; i++) {
            if (new_parent[i] != -1)
                e2[new_parent[i]].push_back(i);
        }
        vector<int> sub(n, 0);
        auto dfs_2 = [&](auto& dfs_2, int g) -> void {
            sub[g] = 1;
            for (auto u : e2[g]) {
                dfs_2(dfs_2, u);
                sub[g] += sub[u];
            }  
        };
        dfs_2(dfs_2, 0);
        return sub;
    }
};",1434271155
Ernest Lu,ernestlu,15,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n, 0);

        for (int day = 0; day < k; day++) {
            vector<int> new_dp(n);
            for (int i = 0; i < n; i++) {
                new_dp[i] = max(new_dp[i], dp[i] + stayScore[day][i]);
            }
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (j != i) {
                        new_dp[j] = max(new_dp[j], dp[i] + travelScore[i][j]);
                    }
                }
            }
            swap(new_dp, dp);
        }
        return *max_element(dp.begin(), dp.end());
    }
};",1434313857
Ernest Lu,ernestlu,15,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char pc = '!';
        int ch_len = -1;
        int ans = 0;
        for (auto u : word) {
            if (u != pc) {
                if (pc != '!') {
                    if (ch_len > 1)
                        ans += ch_len - 1;
                }
                pc = u;
                ch_len = 1;
            } else {
                ch_len++;
            }
        }
        if (ch_len > 1)
            ans += ch_len - 1;
        ans++;
        return ans;
    }
};",1434318627
Ernest Lu,ernestlu,15,3618,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};

class Solution {
public:
    int possibleStringCount(string word, int k) {
        int n = (int)word.size();

        vector<int> c;

        char pc = '!';
        int ch_len = 0;
        for (auto u : word) {
            if (u != pc) {
                if (pc != '!') {
                    //cout << u << ' ' << ch_len << ' ' << pc << ""\n"";
                    c.push_back(ch_len);
                }
                pc = u;
                ch_len = 1;
            } else {
                ch_len++;
            }
        }
        c.push_back(ch_len);
        for (auto& u : c) {
            u--;
            k--;
        }

        mint ans = 1;
        for (auto u : c)
            ans *= (u + 1);

        if (k > 0) {
            vector<mint> dp(k);
            dp[0] = 1;
            for (auto u : c) {
                vector<mint> new_dp(k);
                for (int i = 0; i < k; i++) {
                    int r = min(i + u, k - 1);
                    int l = i;
                    new_dp[l] += dp[i];
                    if (r != k - 1)
                        new_dp[r + 1] -= dp[i];
                }
                for (int i = 1; i < k; i++)
                    new_dp[i] += new_dp[i - 1];
                swap(dp, new_dp);
            }
            ans -= accumulate(dp.begin(), dp.end(), mint(0));
        }
        return ans.x;
    }
};",1434309204
kzyKT,kzyKT,16,3576,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

vector<ll> v[111111];
vector<int> p,ans;
map<char,ll> ma;
string s;

ll dfs(ll x) {
  ll z=-1,c=1;
  if(ma.count(s[x])) {
    z=ma[s[x]];
    p[x]=z;
  }
  ma[s[x]]=x;
  rep(i,v[x].size()) {
    ll y=v[x][i];
    c+=dfs(y);
  }
  ma.erase(s[x]);
  if(z!=-1) ma[s[x]]=z;
  ans[x]=c;
  return c;
}

class Solution {
public:
  vector<int> findSubtreeSizes(vector<int>& q, string ss) {
    s=ss;
    p=q;
    ans.clear();
    ll n=p.size();
    rep(i,n) ans.pb(0);
    rep(i,n) v[i].clear();
    REP(i,1,p.size()) v[p[i]].pb(i);
    dfs(0);
    rep(i,n) v[i].clear();
    REP(i,1,p.size()) v[p[i]].pb(i);
    dfs(0);
    return ans;
  }
};",1434273816
kzyKT,kzyKT,16,3587,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int maxScore(int n, int m, vector<vector<int>>& a, vector<vector<int>>& b) {
    int dp[m+1][n];
    rep(i,m+1)rep(j,n) dp[i][j]=-MAX;
    rep(i,n) dp[0][i]=0;
    rep(k,m) {
      rep(i,n) {
        dp[k+1][i]=max(dp[k+1][i],dp[k][i]+a[k][i]);
        rep(j,n) {
          dp[k+1][j]=max(dp[k+1][j],dp[k][i]+b[i][j]);
        }
      }
    }
    int ans=0;
    rep(i,n) ans=max(ans,dp[m][i]);
    return ans;
  }
};",1434280105
kzyKT,kzyKT,16,3617,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
    int possibleStringCount(string s) {
      vector<ll> v;
      ll c=1;
      REP(i,1,s.size()) {
        if(s[i-1]==s[i]) c++;
        else {
          v.pb(c);
          c=1;
        }
      }
      v.pb(c);
      ll ans=1;
      rep(i,v.size()) ans+=v[i]-1;
      return ans;
    }
};",1434311261
kzyKT,kzyKT,16,3618,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  int possibleStringCount(string s, int m) {
    vector<ll> v;
    ll c=1;
    REP(i,1,s.size()) {
      if(s[i-1]==s[i]) c++;
      else {
        v.pb(c);
        c=1;
      }
    }
    v.pb(c);
    ll ans=1;
    rep(i,v.size()) {
      ans*=v[i];
      ans%=MAX;
    }
    if(v.size()>m) return ans;
    ll dp[2][m+1];
    mem(dp);
    dp[0][0]=1;
    rep(i,v.size()) {
      ll d=0;
      rep(j,m) {
        d+=dp[0][j];
        d%=MAX;
        if(j-v[i]>=0) {
          d-=dp[0][j-v[i]];
          d+=MAX;
          d%=MAX;
        }
        dp[1][j+1]+=d;
        dp[1][j+1]%=MAX;
      }
      rep(j,m) {
        dp[0][j]=dp[1][j];
        dp[1][j]=0;
      }
    }
    rep(i,m) {
      ans-=dp[0][i];
      ans+=MAX;
      ans%=MAX;
    }
    return ans;
  }
};",1434308222
ZHAO YANG,iftkaar,17,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] p, String s) {
        int n = p.length;
        List<List<Integer>> a0 = new ArrayList<>();
        List<Integer>[] cs = new List[26];
        
        iL(n, a0);
        iC(cs);
        bA(n, p, a0);
        
        int[] y = new int[n];
        Arrays.fill(y, -1);
        
        dFY(0, s, y, cs, a0);
        
        uP(n, p, y);
        
        List<List<Integer>> a = new ArrayList<>();
        iL(n, a);
        bA(n, p, a);
        
        int[] r = new int[n];
        dS(0, a, r);
        return r;
    }
    
    private void iL(int n, List<List<Integer>> a) {
        int i = 0;
        while(i < n) {
            a.add(new ArrayList<>());
            i++;
        }
    }
    
    private void iC(List<Integer>[] cs) {
        int i = 0;
        while(i < 26) {
            cs[i] = new ArrayList<>();
            i++;
        }
    }
    
    private void bA(int n, int[] p, List<List<Integer>> a) {
        int i = 1;
        while(i < n) {
            a.get(p[i]).add(i);
            i++;
        }
    }
    
    private void uP(int n, int[] p, int[] y) {
        int i = 1;
        while(i < n) {
            p[i] = y[i] == -1 ? p[i] : y[i];
            i++;
        }
    }
    
    private void dFY(int u, String s, int[] y, List<Integer>[] cs, List<List<Integer>> a0) {
        int c = s.charAt(u) - 'a';
        y[u] = cs[c].isEmpty() ? -1 : cs[c].get(cs[c].size() - 1);
        cs[c].add(u);
        pC(u, s, y, cs, a0);
        cs[c].remove(cs[c].size() - 1);
    }
    
    private void pC(int u, String s, int[] y, List<Integer>[] cs, List<List<Integer>> a0) {
        int i = 0;
        List<Integer> l = a0.get(u);
        while(i < l.size()) {
            dFY(l.get(i), s, y, cs, a0);
            i++;
        }
    }
    
    private int dS(int u, List<List<Integer>> a, int[] r) {
        int z = 1;
        z = pS(u, a, r, z);
        return r[u] = z;
    }
    
    private int pS(int u, List<List<Integer>> a, int[] r, int z) {
        int i = 0;
        List<Integer> l = a.get(u);
        while(i < l.size()) {
            z += dS(l.get(i), a, r);
            i++;
        }
        return z;
    }
}",1434295105
ZHAO YANG,iftkaar,17,3587,java,"class Solution {
    private int getMt(int j, int n, int[][] p, int[][] t) {
        int m = 0, l = 0;
        while (l < n) {
            m = l == j ? m : Math.max(m, p[l][0] + t[l][j]);
            l++;
        }
        return m;
    }
    
    private int getMtf(int j, int n, int[][] t) {
        int m = 0, l = 0;
        while (l < n) {
            m = l == j ? m : Math.max(m, t[l][j]);
            l++;
        }
        return m;
    }
    
    private void pfd(int n, int[][] p, int[][] s, int[][] t) {
        int j = 0;
        while (j < n) {
            p[j][0] = Math.max(s[0][j], getMtf(j, n, t));
            j++;
        }
    }
    
    private void pcd(int d, int n, int[][] p, int[][] c, int[][] s, int[][] t) {
        int j = 0;
        while (j < n) {
            c[j][0] = Math.max(p[j][0] + s[d][j], getMt(j, n, p, t));
            j++;
        }
    }
    
    public int maxScore(int n, int k, int[][] s, int[][] t) {
        int[][] p = new int[n][1];
        int[][] c = new int[n][1];
        
        pfd(n, p, s, t);
        
        int d = 1;
        while (d < k) {
            pcd(d, n, p, c, s, t);
            
            int j = 0;
            while (j < n) {
                p[j][0] = c[j][0];
                j++;
            }
            d++;
        }
        
        int m = p[0][0];
        int j = 1;
        while (j < n) {
            m = Math.max(m, p[j][0]);
            j++;
        }
        return m;
    }
}",1434274829
ZHAO YANG,iftkaar,17,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int cnt = 1; 
        for (int i = 1; i < word.length(); ++i) {
            cnt += (word.charAt(i) == word.charAt(i - 1)) ? 1 : 0;
        }
        return cnt;
    }
}",1434261461
ZHAO YANG,iftkaar,17,3618,java,"class Solution {
    private final int MOD = 1_000_000_007;
    
    public int possibleStringCount(String w, int k) {
        return w.length() == 0 ? 0 : calcResult(w, k);
    }
    
    private int calcResult(String w, int k) {
        List<int[]> r = getRLE(w);
        long t = getProduct(r);
        
        return r.size() >= k ? (int)(t % MOD) : 
               getSum(r) < k ? 0 : 
               (int)((t - getDPSum(r, k) + MOD) % MOD);
    }
    
    private List<int[]> getRLE(String w) {
        List<int[]> r = new ArrayList<>();
        int i = 1;
        RunState state = new RunState(w.charAt(0), 1);
        
        while (i < w.length()) {
            state = w.charAt(i) == state.curr ? 
                   new RunState(state.curr, state.cnt + 1) :
                   addRun(r, state, w.charAt(i));
            i++;
        }
        r.add(new int[]{state.curr - 'a', state.cnt});
        return r;
    }
    
    private static class RunState {
        final char curr;
        final int cnt;
        
        RunState(char curr, int cnt) {
            this.curr = curr;
            this.cnt = cnt;
        }
    }
    
    private RunState addRun(List<int[]> r, RunState state, char newChar) {
        r.add(new int[]{state.curr - 'a', state.cnt});
        return new RunState(newChar, 1);
    }
    
    private long getProduct(List<int[]> r) {
        long[] t = {1};
        r.forEach(p -> t[0] = (t[0] * p[1]) % MOD);
        return t[0];
    }
    
    private long getSum(List<int[]> r) {
        return r.stream().mapToLong(p -> p[1]).sum();
    }
    
    private long getDPSum(List<int[]> r, int k) {
        int ms = k - 1;
        long[] dp = new long[ms + 1];
        dp[0] = 1;
        
        r.forEach(p -> updateDP(dp, p[1], ms));
        
        return Arrays.stream(dp).reduce(0L, (a, b) -> (a + b) % MOD);
    }
    
    private void updateDP(long[] dp, int len, int ms) {
        long[] pre = getPrefixSums(dp, ms);
        long[] tmp = new long[ms + 1];
        
        int j = 0;
        while (j <= ms) {
            tmp[j] = j > 0 ? 
                    ((j - 1 >= 0 ? pre[j - 1] : 0) - 
                    (j - len - 1 >= 0 ? pre[j - len - 1] : 0) + MOD) % MOD : 
                    0;
            j++;
        }
        
        System.arraycopy(tmp, 0, dp, 0, ms + 1);
    }
    
    private long[] getPrefixSums(long[] dp, int ms) {
        long[] pre = new long[ms + 1];
        pre[0] = dp[0];
        
        int j = 1;
        while (j <= ms) {
            pre[j] = (pre[j - 1] + dp[j]) % MOD;
            j++;
        }
        
        return pre;
    }
}",1434319206
BERNARD BRAHIMCHA,BERNARB01,19,3576,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> findSubtreeSizes(vector<int>& parent, string s) {
    int n = int(s.length());
    vector<vector<int>> g(n);
    for (int i = 1; i < n; i++) {
      g[parent[i]].push_back(i);
    }
    vector<int> new_parent(n);
    vector<int> order;
    vector<vector<int>> last(26);
    auto Dfs = [&](auto&& self, int v) -> void {
      order.push_back(v);
      int c = int(s[v] - 'a');
      if (last[c].empty()) {
        new_parent[v] = parent[v];
      } else {
        new_parent[v] = last[c].back();
      }
      last[c].push_back(v);
      for (int u : g[v]) {
        self(self, u);
      }
      last[c].pop_back();
    };
    Dfs(Dfs, 0);
    deb(order);
    deb(new_parent);
    vector<int> sbt(n, 1);
    for (int i = n - 1; i > 0; i--) {
      int v = order[i];
      sbt[new_parent[v]] += sbt[v];
    }
    return sbt;
  }
};

#ifdef B01
int main() {
  Solution sl;
  vector<int> z = {-1,0,0,1,1,1};
  deb(sl.findSubtreeSizes(z, ""abaabc""));
  z = {-1,0,4,0,1};
  deb(sl.findSubtreeSizes(z, ""abbba""));
}
#endif
",1434322558
BERNARD BRAHIMCHA,BERNARB01,19,3587,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    vector<int> dp(n);
    for (int i = 0; i < k; i++) {
      vector<int> new_dp(n);
      for (int j = 0; j < n; j++) {
        for (int t = 0; t < n; t++) {
          if (t == j) {
            new_dp[t] = max(new_dp[t], dp[j] + stayScore[i][j]);
          } else {
            new_dp[t] = max(new_dp[t], dp[j] + travelScore[j][t]);
          }
        }
      }
      swap(dp, new_dp);
    }
    return *max_element(dp.begin(), dp.end());
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1434307839
BERNARD BRAHIMCHA,BERNARB01,19,3617,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int possibleStringCount(string s) {
    int n = int(s.length());
    int ans = 0;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && s[end + 1] == s[beg]) {
        end += 1;
      }
      ans += end - beg;
      beg = end + 1;
    }
    return ans + 1;
  }
};

#ifdef B01
int main() {
  Solution sl;
}
#endif
",1434299941
BERNARD BRAHIMCHA,BERNARB01,19,3618,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

class Solution {
 public:
  int possibleStringCount(string s, int k) {
    int n = int(s.length());
    string t = """";
    vector<int> a;
    int beg = 0;
    while (beg < n) {
      int end = beg;
      while (end + 1 < n && s[end + 1] == s[beg]) {
        end += 1;
      }
      t.push_back(s[end]);
      a.push_back(end - beg + 1);
      beg = end + 1;
    }
    swap(s, t);
    n = int(s.length());
    int res = 1;
    for (int x : a) {
      res = mul(res, x);
    }
    if (n >= k) {
      return res;
    }
    vector<int> dp(k);
    dp[0] = 1;
    k -= n;
    for (int i = 0; i < n; i++) {
      a[i] -= 1;
    }
    for (int i = 0; i < n; i++) {
      vector<int> new_dp(k);
      for (int j = 0; j < k; j++) {
        if (j > 0) {
          add(dp[j], dp[j - 1]);
        }
        new_dp[j] = dp[j];
        if (j > a[i]) {
          sub(new_dp[j], dp[j - a[i] - 1]);
        }
      }
      swap(dp, new_dp);
    }
    for (int x : dp) {
      sub(res, x);
    }
    return res;
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.possibleStringCount(""aabbccdd"", 7));
  deb(sl.possibleStringCount(""aabbccdd"", 8));
  deb(sl.possibleStringCount(""aaabbb"", 3));
}
#endif
",1434295600
lilPeep,stupidRR,21,3576,cpp,"class Solution {
    void dfs(int node,vector<vector<int>>&g,string &s,vector<vector<int>>&gNew,vector<int>&parent)
    {
        for(auto child : g[node])
        {
            if( parent[ s[child]-'a' ]!=-1 )
                gNew[ parent[ s[child]-'a' ] ].push_back(child);
            else
                gNew[ node ].push_back(child);            
            int tmp= parent[ s[child]-'a' ];
            parent[ s[child]-'a' ]=child;
            dfs(child,g,s,gNew,parent);
            parent[ s[child]-'a' ]=tmp;
        }
    }
    void dfs2(int node,vector<vector<int>>&g,vector<int>&subtree)
    {
        for(auto child : g[node])
        {
            dfs2(child,g,subtree);
            subtree[node]+=subtree[child];
        }
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=s.size();
        vector<vector<int>> g(n);
        for(int i=1;i<n;i++)
            g[ parent[i] ].push_back(i);
        
        vector<int> parental(26,-1);
        parental[ s[0]-'a' ]=0;
        vector<vector<int>> gNew(n+1);
        dfs(0,g,s,gNew,parental);
        
        vector<int> subtree(n,1);
        dfs2(0,gNew,subtree);
        return subtree;
    }
};",1434280566
lilPeep,stupidRR,21,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n,0);
        for(int i=0;i<k;i++)
        {
            vector<int> ndp(n);
            for(int city=0;city<n;city++)
                ndp[city]=std::max(dp[city]+stayScore[i][city],ndp[city]);
            
            for(int curr=0;curr<n;curr++)
            {
                for(int dest=0;dest<n;dest++)
                {
                    if(curr!=dest)
                        ndp[dest]=std::max(ndp[dest],dp[curr]+travelScore[curr][dest]);
                }
            }
            swap(ndp,dp);
        }
        
        return *max_element(dp.begin(),dp.end());
    }
};",1434288220
lilPeep,stupidRR,21,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=1;i<word.size();i++)
        {
            if(word[i]==word[i-1])
                ans++;
        }
        return ans;
    }
};",1434259817
lilPeep,stupidRR,21,3618,cpp,"class Solution {
    const int mod=1e9+7;
public:
    int possibleStringCount(string word, int k) {
        vector< pair<char,int> > compress;
        compress.push_back( {word[0],1} );
        for(int i=1;i<word.size();i++)
        {
            if( compress.back().first == word[i] )
                compress.back().second++;
            else
                compress.push_back( {word[i],1} );
        }
        
        long long sub=0ll;
        if( k>compress.size() )
        {
            vector<long long> dp(k,0ll);
            dp[0]=1ll;
            for(auto &[val,freq] : compress)
            {
                for(int i=1;i<k;i++)
                    dp[i]=dp[i]+dp[i-1];

                vector<long long> ndp(k);
                for(int i=1;i<k;i++)
                {
                    ndp[i]=dp[i-1];
                    if(i-freq>0)
                        ndp[i]-=dp[i-freq-1];
                    ndp[i]=ndp[i]%mod;
                }

                swap(ndp,dp);

            }
            
            for(int i=0;i<k;i++)
                sub=(sub+dp[i])%mod;
        }
        
        long long mul=1ll;
        for(auto &[val,freq] : compress)
            mul=(mul*1ll*freq)%mod;
    
        return (mul-sub+mod)%mod;
    }
};",1434323636
congthanh2000,congthanh2000,22,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<vector<int>> vertices(26);
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++) {
            int p = parent[i];
            adj[p].push_back(i);
        }
        vector<int> closest(n, -1);
        vector<int> subtree(n);
        function<void(int)> dfs = [&](int u) {
            int c = s[u] - 'a';
            if (!vertices[c].empty()) {
                closest[u] = vertices[c].back();
            }
            subtree[u] = 1;
            vertices[c].push_back(u);
            for (int v : adj[u]) {
                dfs(v);
                subtree[u] += subtree[v];
            }
            vertices[c].pop_back();
        };
        dfs(0);
        for (int i = 0; i < n; i++) {
            if (closest[i] != -1) {
                parent[i] = closest[i];
            }
            adj[i].clear();
        }
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        dfs(0);
        return subtree;
    }
};",1434275948
congthanh2000,congthanh2000,22,3587,cpp,"const int INF = 1e9 + 100;
class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int>(k + 1, -INF));
        for (int i = 0; i < n; i++) dp[i][0] = 0;
        for (int d = 0; d < k; d++) {
            for (int u = 0; u < n; u++) {
                if (dp[u][d] != INF) {
                    dp[u][d + 1] = max(dp[u][d + 1], dp[u][d] + stayScore[d][u]);
                    for (int v = 0; v < n; v++) {
                        dp[v][d + 1] = max(dp[v][d + 1], dp[u][d] + travelScore[u][v]);
                    }
                }
            }
        }
        int ans = 0;
        for (int u = 0; u < n; u++) ans = max(ans, dp[u][k]);
        return ans;
    }
};",1434283113
congthanh2000,congthanh2000,22,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 1;
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && word[i] == word[j]) j++;
            ans += j - i - 1;
            i = j;
        }
        return ans;
    }
};",1434261225
congthanh2000,congthanh2000,22,3618,cpp,"const int MOD = 1e9 + 7;

/// MOD NUM, MOD < 2^31
template <int _MOD>
class num_t {
    //    long long Mul(long long x, long long y,long long m) /// Tinh (x * y) mod M voi (x,y, M <= 10 ^ 18)
    //    {
    //        x %= m; y %= m;
    //        long long q = (long double) x * y / m;
    //        long long r = (x * y - q * m) % m;
    //        if (r < 0) r += m;
    //        return r;
    //    }
    static constexpr int MOD = _MOD;

   private:
    int value;

    static int power(int a, int n) {
        int ans = 1;
        for (; n; n >>= 1, a = 1LL * a * a % MOD) {
            if (n & 1) {
                ans = 1LL * ans * a % MOD;
            }
        }
        return ans;
    }

    //    static int inverse(int a, int m) {
    //        a %= m;
    //        assert(a);
    //        return a == 1 ? 1 : int(m - 1LL * inverse(m, a)) * m / a);
    //    }

    static int inverse(int a) {
        return power(a, MOD - 2);
    }

   public:
    num_t() : value(0) {};
    template <typename U>
    num_t(U _value) {
        value = _value % MOD;
        if (value < 0) value += MOD;
    }

    friend ostream &operator<<(ostream &out, const num_t &n) { return out << int(n); }
    friend istream &operator>>(istream &in, num_t &n) {
        long long _value;
        in >> _value;
        n = num_t(_value);
        return in;
    }

    bool operator==(const num_t &other) { return value == other.value; }
    bool operator!=(const num_t &other) { return !(*this == other); }

    void operator=(const num_t &other) { value = other.value; }

    template <typename U>
    void operator=(U other) { value = other; };

    operator int() const { return value; }

    num_t power(int n) const {
        num_t ans;
        ans.value = power(value, n);
        return ans;
    };

    num_t inverse() const {
        num_t ans;
        ans.value = inverse(value);
        return ans;
    }

    friend num_t inverse(const num_t &other) { return other.inverse(); }

    num_t &operator+=(const num_t &other) {
        value += other.value;
        if (value >= MOD) value -= MOD;
        return *this;
    }

    template <typename U>
    num_t &operator+=(U other) {
        return *this += num_t(other);
    }

    num_t &operator-=(const num_t &other) {
        value -= other.value;
        if (value < 0) value += MOD;
        return *this;
    }

    template <typename U>
    num_t &operator-=(U other) {
        return *this -= num_t(other);
    }

    num_t &operator*=(const num_t &other) {
        value = 1LL * value * other.value % MOD;
        return *this;
    }

    num_t &operator/=(const num_t &other) {
        return *this *= other.inverse();
    }

    num_t &operator++() {
        value++;
        if (value >= MOD) value -= MOD;
        return *this;
    }

    num_t operator++(int) {
        num_t ans(*this);
        *this += 1;
        return ans;
    }

    num_t &operator--() {
        value++;
        if (value < 0) value += MOD;
        return *this;
    }

    num_t operator--(int) {
        num_t ans(*this);
        this -= 1;
        return ans;
    }

    num_t operator-() const {
        return num_t(-value);
    }

    friend num_t operator+(const num_t &a, const num_t &b) { return num_t(a) += b; }
    template <typename U>
    friend num_t operator+(const num_t &a, U b) { return num_t(a) += b; }
    template <typename U>
    friend num_t operator+(U a, const num_t &b) { return num_t(a) += b; }

    friend num_t operator-(const num_t &a, const num_t &b) { return num_t(a) -= b; }
    template <typename U>
    friend num_t operator-(const num_t &a, U b) { return num_t(a) -= b; }
    template <typename U>
    friend num_t operator-(U a, const num_t &b) { return num_t(a) -= b; }

    friend num_t operator*(const num_t &a, const num_t &b) { return num_t(a) *= b; }
    template <typename U>
    friend num_t operator*(const num_t &a, U b) { return num_t(a) *= b; }
    template <typename U>
    friend num_t operator*(U a, const num_t &b) { return num_t(a) *= b; }

    friend num_t operator/(const num_t &a, const num_t &b) { return num_t(a) /= b; }
    template <typename U>
    friend num_t operator/(const num_t &a, U b) { return num_t(a) /= b; }
    template <typename U>
    friend num_t operator/(U a, const num_t &b) { return num_t(a) /= b; }
};

/// usage
using type = num_t<MOD>;
class Solution {
   public:
    int possibleStringCount(string word, int k) {
        vector<int> a;
        for (int i = 0; i < word.size(); ) {
            int j = i;
            while (j < word.size() && word[i] == word[j]) j++;
            a.push_back(j - i);
            i = j;
        }
        type ans = 1;
        for (int x : a) ans *= x;
        if (a.size() >= k) {
            return ans;
        }
        vector<type> sum_dp(k, 1);
        vector<type> dp(k, 0);
        for (int x : a) {
            for (int i = k - 1; i >= 1; i--) {
                int l = max(0, i - x);
                dp[i] = sum_dp[i - 1];
                if (l > 0) {
                    dp[i] -= sum_dp[l - 1];
                }
            }
            sum_dp[0] = dp[0];
            for (int i = 1; i < k; i++) sum_dp[i] = sum_dp[i - 1] + dp[i];
        }
        ans -= sum_dp[k - 1];
        return ans;
    }
};",1434310473
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        this->s = s;
        this->n = n;

        adj.resize(n);
        new_adj.resize(n);
        char_stack.resize(26);
        new_parent.resize(n);
        subtree_size.resize(n);

        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                adj[parent[i]].push_back(i);
            }
        }

        for (int i = 0; i < n; ++i) {
            new_parent[i] = parent[i];
        }

        dfs(0, -1);

        vector<int> roots;
        for (int i = 0; i < n; ++i) {
            if (new_parent[i] == -1) {
                roots.push_back(i);
            } else {
                new_adj[new_parent[i]].push_back(i);
            }
        }

        for (int root : roots) {
            compute_subtree_size(root);
        }

        vector<int> answer(n);
        for (int i = 0; i < n; ++i) {
            answer[i] = subtree_size[i];
        }
        return answer;
    }
private:
    int n;
    string s;
    vector<vector<int>> adj;           
    vector<vector<int>> new_adj;       
    vector<vector<int>> char_stack;    
    vector<int> new_parent;            
    vector<int> subtree_size;          

    void dfs(int node, int parent) {
        int c = s[node] - 'a';
        char_stack[c].push_back(node);
        if (char_stack[c].size() >= 2) {
            int y = char_stack[c][char_stack[c].size() - 2];
            new_parent[node] = y;
        } else {
            new_parent[node] = parent;
        }
        for (int child : adj[node]) {
            if (child != parent) {
                dfs(child, node);
            }
        }
        char_stack[c].pop_back();
    }

    int compute_subtree_size(int node) {
        int size = 1; 
        for (int child : new_adj[node]) {
            size += compute_subtree_size(child);
        }
        subtree_size[node] = size;
        return size;
    }
};
",1434284410
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(2, vector<int>(n, INT_MIN));

        for (int s = 0; s < n; ++s) {
            dp[0][s] = max(dp[0][s], stayScore[0][s]);
            for (int c = 0; c < n; ++c) {
                if (s != c) {
                    dp[0][c] = max(dp[0][c], travelScore[s][c]);
                }
            }
        }

        for (int day = 1; day < k; ++day) {
            vector<int>& prev_dp = dp[(day - 1) % 2];
            vector<int>& curr_dp = dp[day % 2];
            fill(curr_dp.begin(), curr_dp.end(), INT_MIN);

            for (int city = 0; city < n; ++city) {
                if (prev_dp[city] != INT_MIN) {
                    curr_dp[city] = max(curr_dp[city], prev_dp[city] + stayScore[day][city]);
                }
            }

            for (int curr_city = 0; curr_city < n; ++curr_city) {
                for (int prev_city = 0; prev_city < n; ++prev_city) {
                    if (prev_dp[prev_city] != INT_MIN && prev_city != curr_city) {
                        int points = prev_dp[prev_city] + travelScore[prev_city][curr_city];
                        curr_dp[curr_city] = max(curr_dp[curr_city], points);
                    }
                }
            }
        }

        int result = INT_MIN;
        for (int city = 0; city < n; ++city) {
            result = max(result, dp[(k - 1) % 2][city]);
        }
        return result;
    }
};
",1434305833
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int total_reductions = 0;
        int n = word.size();
        int i = 0;
        while (i < n) {
            char current_char = word[i];
            int count = 0;
            while (i < n && word[i] == current_char) {
                count++;
                i++;
            }
            if (count > 1) {
                total_reductions += count - 1;
            }
        }
        return 1 + total_reductions;
    }
};",1434273610
Ayush Singh Bhadauria,AyushSinghBhadauria,24,3618,cpp,"
class Solution {
const int MOD = 1e9 + 7;

public:
    int possibleStringCount(string word, int k) {
        int n = word.size();
        vector<int> groupLens;
        int G = 0;
        int count = 1;

        for (int i = 1; i <= n; ++i) {
            if (i == n || word[i] != word[i - 1]) {
                groupLens.push_back(count);
                G++;
                count = 1;
            } else {
                count++;
            }
        }

        long long total_combinations = 1;
        for (int len : groupLens) {
            total_combinations = (total_combinations * len) % MOD;
        }

        int T = k - G;
        if (T <= 0) {
            return (int)total_combinations;
        }

        int max_T = T;
        vector<int> dp(T + 1, 0);
        dp[0] = 1;

        for (int len : groupLens) {
            int max_delta = min(len - 1, T);
            vector<int> dp_new(T + 1, 0);
            int window_sum = 0;
            for (int s = 0; s <= T; ++s) {
                window_sum = (window_sum + dp[s]) % MOD;
                if (s - max_delta - 1 >= 0) {
                    window_sum =
                        (window_sum - dp[s - max_delta - 1] + MOD) % MOD;
                }
                dp_new[s] = window_sum;
            }
            dp = dp_new;
        }

        long long total_bad = 0;
        for (int s = 0; s < T; ++s) {
            total_bad = (total_bad + dp[s]) % MOD;
        }

        long long total_ways = (total_combinations - total_bad + MOD) % MOD;
        return (int)total_ways;
    }
};",1434318314
Kseniia,kseniiastrelbytska,26,3576,cpp,"class Solution {
public:
    int p[100007];
    int a[30];
    string s;

    vector<int> d[100007];

    void dfs(int v, int par) { 
        if (a[(s[v] - 'a')] != -1){
            p[v] = a[(s[v] - 'a')];
        } 

        int b = a[(s[v] - 'a')];
        a[(s[v] - 'a')] = v;

        for(auto i: d[v])
            if(i != par)
                dfs(i, v);

        a[(s[v] - 'a')] = b;
    }

    int c[100007];

    void solve(int v, int par){
        c[v] = 1;

        for(auto i: d[v]){
            if(i != par){
                solve(i, v);
                c[v] += c[i];
            }
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s0) {
        int n = s0.size();

        for(int i = 1; i < n; i++){
            p[i] = parent[i];

            d[p[i]].push_back(i);
            d[i].push_back(p[i]);
        }

        s = s0;
        for(int i = 0; i < 30; i++)
            a[i] = -1;

        dfs(0, -1);

        for(int i = 0; i < n; i++)
            d[i].clear();

        for(int i = 1; i < n; i++){
            d[p[i]].push_back(i);
            d[i].push_back(p[i]);
        }

        solve(0, -1);

        vector<int> res;

        for(int i = 0; i < n; i++)
            res.push_back(c[i]);

        return res;
    }
};",1434277522
Kseniia,kseniiastrelbytska,26,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n);

        for(int i = 0; i < k; i++){
            vector<int> dp2(n);

            for(int j = 0; j < n; j++){
                dp2[j] = (dp[j] + stayScore[i][j]);

                for(int k = 0; k < n; k++)
                    dp2[j] = max(dp2[j], dp[k] + travelScore[k][j]);
            }

            dp = dp2;
        }

        int ans = 0;
        for(int i = 0; i < n; i++)
            ans = max(ans, dp[i]);

        return ans;
    }
};",1434283967
Kseniia,kseniiastrelbytska,26,3617,cpp,"class Solution {
public:
    int possibleStringCount(string a) {
        int cnt = 0;

        int ans = 1;

        for(int i = 0; i < a.size(); i++){
            cnt++;
            
            if(i + 1 == a.size() || a[i + 1] != a[i]){
                ans += cnt - 1;
                cnt = 0;
            }
        }

        return ans;
    }
};",1434260164
Kseniia,kseniiastrelbytska,26,3618,cpp,"class Solution {
public:
    int dp[2][2007];

    int const mod = (int)(1e9 + 7);
    typedef long long ll;

    int possibleStringCount(string a, int k) {
        int ans = 1;

        vector<int> d;
        int cnt = 0;

        int dif = 0;

        for(int i = 0; i < a.size(); i++){
            cnt++;
            
            if(i + 1 == a.size() || a[i + 1] != a[i]){
                dif++;
                
                if(cnt - 1 > 0)
                    d.push_back(cnt - 1);

                ans = ((ll)ans * (cnt)) % mod;
                cnt = 0;
            }
        }

        if(d.empty())
            return (a.size() >= k ? 1 : 0);

        if(dif >= k)
            return ans;
        
        dp[0][0] = 1;
        int cur = 0;
        int s = k - dif - 1;

        for(int i = 0; i < (d.size()); i++){
            cur = 1 - cur;

            for(int j = 0; j <= s; j++){
                if(j != 0)
                    dp[1 - cur][j] = (dp[1 - cur][j] + dp[1 - cur][j - 1]) % mod;

                dp[cur][j] = (dp[1 - cur][j] - (j - d[i] - 1 >= 0 ? dp[1 - cur][j - d[i] - 1] : 0)) % mod;
            }

        }

        int ans2 = 0;
        for(int j = 0; j <= s; j++)
            ans2 = (ans2 + dp[cur][j]) % mod;

        ans = (ans - ans2) % mod;
        if(ans < 0)
            ans += mod;

        return ans;
    }
};",1434327780
Jingzhe Tang,skywalkert,28,3576,cpp,"class Solution {
    void dfs1(int u, int p, vector<vector<int> > &e, vector<vector<int> > &ee, vector<int> &pos, string const &s) {
        int o = s[u] - 'a';
        int las = pos[o];
        if(las != -1 || p != -1)
            ee[las == -1 ? p : las].push_back(u);
        pos[o] = u;
        for(int v: e[u])
            dfs1(v, u, e, ee, pos, s);
        pos[o] = las;
    }
    void dfs2(int u, vector<vector<int> > &e, vector<int> &sz) {
        sz[u] = 1;
        for(int v: e[u]) {
            dfs2(v, e, sz);
            sz[u] += sz[v];
        }
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        static const int maxc = 26;
        int n = parent.size();
        vector<int> ans(n), pos(maxc, -1);
        vector<vector<int> > e(n), ee(n);
        for(int i = 1; i < n; ++i) {
            int p = parent[i];
            e[p].push_back(i);
        }
        dfs1(0, -1, e, ee, pos, s);
        dfs2(0, ee, ans);
        return ans;
    }
};",1434328568
Jingzhe Tang,skywalkert,28,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        static const int maxn = (int)2e2 + 9;
        static int f[2][maxn], cur = 0, pre = 1;
        memset(f[cur], 0, n * sizeof(int));
        for(int i = 0; i < k; ++i) {
            swap(cur, pre);
            for(int j = 0; j < n; ++j) {
                f[cur][j] = f[pre][j] + stayScore[i][j];
                for(int p = 0; p < n; ++p)
                    f[cur][j] = max(f[cur][j], f[pre][p] + travelScore[p][j]);
            }
        }
        return *max_element(f[cur], f[cur] + n);
    }
};",1434314183
Jingzhe Tang,skywalkert,28,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size(), ans = 1;
        for(int i = 0, j; i < n; ) {
            for(j = i; i < n && word[i] == word[j]; ++i);
            ans += i - j - 1;
        }
        return ans;
    }
};",1434260871
Jingzhe Tang,skywalkert,28,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        typedef long long LL;
        static const int maxv = (int)2e3 + 9, mod = (int)1e9 + 7;
        int n = word.size(), ans = 1;
        vector<int> ctr(k);
        for(int i = 0, j; i < n; ) {
            for(j = i; i < n && word[i] == word[j]; ++i);
            j = i - j;
            ans = (LL)ans * j % mod;
            if(j < k)
                ++ctr[j];
            if(k > 1)
                --ctr[1];
            --k;
        }
        // printf(""ans %d\n"", ans);
        if(k <= 0)
            return ans;
        ctr.resize(k);
        // printf(""k %d ctr "", k);
        // for(int i = 0; i < k; ++i)
        //     printf(""%d%c"", ctr[i], "" \n""[i == k - 1]);
        for(int i = k - 1; i >= 1; --i) {
            ctr[i] = (LL)ctr[i] * i % mod;
            ctr[i] < 0 && (ctr[i] += mod);
            for(int j = i + i; j < k; j += i)
                (ctr[j] += ctr[i]) >= mod && (ctr[j] -= mod);
        }
        // printf(""ctr "", k);
        // for(int i = 0; i < k; ++i)
        //     printf(""%d%c"", ctr[i], "" \n""[i == k - 1]);
        vector<int> ways(k), inv(k);
        ways[0] = 1;
        (--ans) < 0 && (ans += mod);
        // printf(""ways 1 "");
        for(int i = 1; i < k; ++i) {
            inv[i] = i > 1 ? mod - (int)(mod / i * (LL)inv[mod % i] % mod) : 1;
            ways[i] = 0;
            for(int j = 1; j <= i; ++j)
                ways[i] = (ways[i] - (LL)ctr[j] * ways[i - j]) % mod;
            ways[i] = (LL)ways[i] * inv[i] % mod;
            ways[i] < 0 && (ways[i] += mod);
            (ans -= ways[i]) < 0 && (ans += mod);
            // printf(""%d%c"", ways[i], "" \n""[i == k - 1]);
        }
        return ans;
    }
};",1434307374
Maruzensky,Maruzensky,29,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        chr_dict = {chr(ord('a') + i): i for i in range(26)}
        
        stack = [[0, [-1] * 26]]
        stack[0][1][chr_dict[s[0]]] = 0
        child = [[] for _ in range(n)]
        
        for i, p in enumerate(parent):
            if p == -1:
                continue
            child[p].append(i)
            
        new = [-1 for _ in range(n)]
        
        while stack:
            u, seen = stack.pop()
            for v in child[u]:
                temp = seen.copy()
                c = chr_dict[s[v]]
                if temp[c] != -1:
                    new[v] = temp[c]
                else:
                    new[v] = parent[v]
                    
                temp[c] = v
                stack.append([v, temp])
                
        answer = [0] * n
        
        stack = [0]
        child = [[] for _ in range(n)]
        
        for i, p in enumerate(new):
            if p == -1:
                continue
            child[p].append(i)
            
        topo = []
        while stack:
            u = stack.pop()
            topo.append(u)
            for v in child[u]:
                stack.append(v)
                
        answer = [1] * n
        for u in reversed(topo):
            if u == 0:
                continue
                
            answer[new[u]] += answer[u]
            
        
        return answer",1434299713
Maruzensky,Maruzensky,29,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        if n == 1:
            return sum(s[0] for s in stayScore)
        
        dp = [0 for _ in range(n)]
        
        for day in range(k):
            temp = [
                max(
                    dp[dest] + stayScore[day][dest],
                    max([
                        dp[curr] + travelScore[curr][dest]
                        for curr in range(n) if curr != dest
                    ])
                )
                for dest in range(n)
            ]
            
            dp = temp
            
        return max(dp)",1434278336
Maruzensky,Maruzensky,29,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        return 1 + sum(x == y for x, y in zip(word, word[1:]))",1434303267
Maruzensky,Maruzensky,29,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        n = len(word)
        mod = 10**9 + 7
        
        split = [0] + [idx for idx in range(1, n) if word[idx] != word[idx - 1]] + [n]
        seg = [j - i for i, j in zip(split, split[1:])]
        
        dp = [1] + [0] * k
        
        answer = 1
        for s in seg:
            answer = (answer * s) % mod

        if len(seg) > k:
            return answer
        
        for s in seg:
            psum = 0
            temp = []
            for i in range(k + 1):
                if i == 0:
                    temp.append(0)
                else:
                    x = dp[i - 1]
                    psum += x
                    if i > s:
                        y = dp[i - s - 1]
                        psum -= y
                        
                    temp.append(psum)
                    
            dp = [comb % mod for comb in temp]
                        
        return (answer - sum(dp[:-1])) % mod",1434322070
Andrey,A_Le_K,31,3576,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

const int ROOT=0;
const int A=26;
inline int toi(char c) {
    return c-'a';
}

class Solution {
    int n;
    string S;
    
    vector<vector<int>> children;
    
    vector<int> parent_new;
    
    void dfs(const int curr, vector<vector<int>>& c2idx) {
        const int cc=toi(S[curr]);
        
        if(c2idx[cc].empty()) {
            parent_new[curr]=-1;
        } else {
            parent_new[curr]=c2idx[cc].back();
        }
        
        c2idx[cc].pb(curr);
        
        for(int next: children[curr]) {
            dfs(next, c2idx);
        }
        
        c2idx[cc].pop_back();
    }  
    
    vector<int> size_ans;
    
    vector<vector<int>> children_new;
    
    void dfs_size(const int curr) {
        size_ans[curr]=1;
        for(int next: children_new[curr]) {
            dfs_size(next);
            size_ans[curr]+=size_ans[next];
        }
    }
    
public:
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        n=par.size();
        S=s;
        
        children=vector<vector<int>>(n);
        for(int i=1; i<n; i++) {
            children[par[i]].pb(i);
        }
        
        parent_new=vector<int>(n);
        
        vector<vector<int>> c2idx(A);
        
        dfs(ROOT, c2idx);
        
        size_ans=vector<int>(n, 0);
        
        children_new=vector<vector<int>>(n);
        for(int i=1; i<n; i++) {
            int actual_parent;
            if(parent_new[i]==-1)actual_parent=par[i];
            else actual_parent=parent_new[i];
            
            children_new[actual_parent].pb(i);
        }
        
        dfs_size(ROOT);
        
        return size_ans;
    }
};",1434285190
Andrey,A_Le_K,31,3587,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

const int INF=1e9;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<int> dp(n, 0), dp_new(n);
        
        FOR(day, k) {
            FOR(i, n) dp_new[i]=-INF;
            
            FOR(curr, n) 
            {
                domax(dp_new[curr], dp[curr]+stay[day][curr]);
                
                FOR(dest, n) domax(dp_new[dest], dp[curr]+travel[curr][dest]);
            }
            
            FOR(i, n) dp[i]=dp_new[i];
        }
        
        const int result=*max_element(all(dp));
        return result;
    }
};",1434292280
Andrey,A_Le_K,31,3617,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 1
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif


class Solution {
public:
    int possibleStringCount(string word) {
        vector<pair<char, int>> v;
        for(char c: word) {
            if(v.empty() || v.back().first!=c) v.pb({c, 1});
            else v.back().second++;
        }
        
        int result=1;
        
        for(auto [c, cnt]: v) {
            if(cnt>1) result+=cnt-1;
        }
        return result;
    }
};",1434260961
Andrey,A_Le_K,31,3618,cpp,"static const int __ = []() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); return 0; }();

typedef long long ll; typedef unsigned int ui; typedef unsigned long long ull; typedef pair<int ,int> pii; typedef pair<ll, ll> pll; typedef double rl;
typedef pii int2; typedef tuple<int, int, int> int3; typedef tuple<int, int, int, int> int4; typedef tuple<int, int, int, int, int> int5;
typedef pll ll2; typedef tuple<ll, ll, ll> ll3; typedef tuple<ll, ll, ll, ll> ll4; typedef tuple<ll, ll, ll, ll, ll> ll5;
typedef vector<int> vi; typedef vector<pii> vii; typedef vector<ll> vll; typedef vector<pll> vll_ll; typedef vector<vi> vvi; typedef vector<vii> vvii; typedef vector<vll> vvll; typedef vector<vll_ll> vvll_ll;

#define pb push_back
#define mp make_pair
#define eb emplace_back
#define xx first
#define yy second
#define FOR(i,N) for(int i=0; i<N; i++)
#define g0(x) get<0>(x)
#define g1(x) get<1>(x)
#define g2(x) get<2>(x)
#define g3(x) get<3>(x)
#define g4(x) get<4>(x)

template<typename A> string to_string(A* ptr) { stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill ('0') << std::hex << (uint64_t)(uintptr_t)ptr; return ss.str(); }
string to_string(char c) { return ((string)""'""+c)+ ""'""; }
template <typename A, typename B> string to_string(pair<A, B> p);
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);
template <typename A, typename B, typename C, typename D> string to_string(tuple<A, B, C, D> p);
string to_string(const string& s) { return '""' + s + '""'; }
string to_string(const char* s) { return to_string((string) s); }
string to_string(bool b) { return (b ? ""true"" : ""false""); }
string to_string(vector<bool> v) {
    bool first = true; string res = ""{"";
	for (int i = 0; i < static_cast<int>(v.size()); i++) { if (!first) { res += "", ""; } first = false; res += to_string(v[i]); }
	res += ""}""; return res;
}
template <size_t N> string to_string(bitset<N> v) { string res = """"; for (size_t i = 0; i < N; i++) { res += static_cast<char>('0' + v[i]); } return res; }
template <typename A> string to_string(A v) {
	bool first = true; string res = ""{"";
	for (const auto &x : v) {
		if (!first) { res += "", ""; }
		first = false; res += to_string(x);
	}
	res += ""}""; return res;
}
template <typename A, typename B> string to_string(pair<A, B> p) { return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")""; }
template <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")""; }
template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) { return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")""; }
void debug_out() { cout << endl; }
template <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cout << "" "" << to_string(H); debug_out(T...); }

#define popc __builtin_popcountll
//#define popc __builtin_popcount
//#define clz __builtin_clzll
//#define clz __builtin_clz
inline int bitLength(uint32_t val) { return 32 - __builtin_clz  (val); }
inline int bitLength(uint64_t val) { return 64 - __builtin_clzll(val); }

template<typename T> inline void domax(T& A, const T& B) { A=max(A, B); }
template<typename T> inline void domin(T& A, const T& B) { A=min(A, B); }

template<typename T>
inline T true_mod(T A, T B)
{
    assert(B>=1);
    A%=B;
    if(A<0) A+=B;
    return A;
}

template<typename T>
inline T div_down(T A, T B)
{
    return (A-true_mod(A,B))/B;
}

template<typename T>
inline T div_up(T A, T B)
{
    return div_down(A+B-1, B);
}

#define all(x) (x).begin(), (x).end()

#if 0
#define dbg(...) cout << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

const ll MOD=1'000'000'000+7;

void dp2sdp(vector<ll>& dp, vector<ll> & sdp, const int k) {
    FOR(i, k) {
        sdp[i]=dp[i];
        if(0<=i-1) sdp[i]+=sdp[i-1];
        sdp[i]=true_mod(sdp[i], MOD);
    }
}

ll get_sum(int L, int R, vector<ll>& s) {
    ll result=0;
    
    if(0<=R && R<s.size()) result+=s[R];
    if(0<=L-1) result-=s[L-1];
    return true_mod(result, MOD);
}

class Solution {
public:
    int possibleStringCount(string w, int k) {
        const int n=w.size();
        
        vector<ll> cnt={1};
        for(int i=1; i<n; i++) {
            if(w[i]==w[i-1]) cnt.back()++;
            else cnt.pb(1);
        }
        
        dbg(cnt);
        
        ll total_ways=1;
        for(ll c: cnt) 
        {
            total_ways*=c;
            total_ways%=MOD;
        }
        
        vector<ll> dp(k, 0);
        dp[0]=1;
        
        vector<ll> sdp(k, 0);
        vector<ll> dp_new(k);
        
        //reverse(all(cnt));
        const int sz=cnt.size();
        if(sz>=k) return total_ways;
        
        // O(n*k)
        for(ll cc: cnt) {
            dp2sdp(dp, sdp, k);
            
            int c=cc;
            //c=min(c, k);
            
            FOR(i, k) {
                const int L=i-c,R=i-1;
                dbg(c, i, L, R);
                dp_new[i]=get_sum(L, R, sdp);
            }
            
                
            FOR(i, k) dp[i]=dp_new[i];
        }
        
        ll result=0;
        FOR(i, k) result+=dp[i];
        //result=true_mod(result, MOD);
        return true_mod(total_ways-result, MOD);
        
        //return -42;
        
    }
};",1434324362
BarryBondsOfLC,BarryBondsOfLC,32,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        vector<vector<int>> G(n);
        for (int i = 1; i < n; i++)
            G[parent[i]].push_back(i);
        vector<int> new_parent(n, -1);
        array<int, 26> last;
        last.fill(-1);
        vector closest(n, -1);
        const auto dfs = [&](auto&& dfs, auto u) -> void {
            auto c = s[u] - 'a';
            auto old = -1;
            if (last[c] != -1) {
                closest[u] = last[c];
                old = last[c];
            }
            last[c] = u;
            for (const auto& v : G[u]) {
                dfs(dfs, v);
            }
            last[c] = old;
        };
        dfs(dfs, 0);
        auto final_parent = parent;
        for (int i = 1; i < n; i++)
            if (closest[i] != -1)
                final_parent[i] = closest[i];
        vector<vector<int>> final_G(n);
        for (int i = 0; i < n; i++)
            if (final_parent[i] != -1)
                final_G[final_parent[i]].push_back(i);
        vector res(n, 1);
        const auto solve = [&](auto&& solve, auto u) -> void {
            for (const auto& v : final_G[u]) {
                solve(solve, v);
                res[u] += res[v];
            }
        };
        solve(solve, 0);
        return res;
    }
};",1434323643
BarryBondsOfLC,BarryBondsOfLC,32,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& leave) {
        vector dp(k, vector(n, 0));
        for (int c = 0; c < n; ++c) {
            dp[0][c] = stay[0][c];
            for(int d = 0; d < n; ++d){
                if(d != c){
                    dp[0][c] = max(dp[0][c], leave[d][c]);
                }
            }
        }
        for (int i = 1; i < k; ++i) {
            for (int c = 0; c < n; c++) {
                int s = dp[i - 1][c] + stay[i][c];
                int l = 0;
                for (int d = 0; d < n; ++d)
                    if (d != c) {
                        l = max(l, dp[i - 1][d] + leave[d][c]);
                    }
                dp[i][c] = max(s, l);
            }
        }
        return *max_element(dp[k - 1].begin(), dp[k - 1].end());
    }
};",1434325575
BarryBondsOfLC,BarryBondsOfLC,32,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<pair<char, int>> groups;
        int n = word.size();
        for (int i = 0; i < n; ) {
            auto j = i;
            while (j < n && word[j] == word[i]) ++j;
            groups.push_back({word[i], j - i});
            i = j;
        }
        
        set<string> res;
        string curr;
        
        const auto append_suffix = [&](auto& s, auto i) {
            for (int j = i; j < groups.size(); ++j) {
                auto [c, l] = groups[j];
                s += string(l, c);
            }
        };
        
        for (int i = 0; i < groups.size(); ++i) {
            auto [c, l] = groups[i];
            for (auto len = 1; len <= l; ++len) {
                auto temp = curr + string(len, c);
                append_suffix(temp, i + 1);
                res.insert(temp);
            }
            curr += string(l, c);
        }
        return res.size();
    }
};",1434323577
BarryBondsOfLC,BarryBondsOfLC,32,3618,cpp,"constexpr int MOD = 1e9 + 7;
using ll = long long;

class Solution {
public:
    int possibleStringCount(string word, int K) {
        vector<int> A;
        int n = word.size();
        for (int i = 0; i < n;) {
            auto j = i;
            while (j < n && word[j] == word[i])
                ++j;
            A.push_back(j - i);
            i = j;
        }
        int N = A.size();
        ll total = 1;
        for (int i = 0; i < N; ++i) {
            total = total * A[i] % MOD;
        }
        if (N >= K) {
            return total;
        }

        vector<ll> dp0(K, 0);
        dp0[0] = 1;
        for (int i = 0; i < N; ++i) {
            vector<ll> prefix(K, 0);
            prefix[0] = dp0[0];
            for (int s = 1; s < K; ++s)
                prefix[s] = (prefix[s - 1] + dp0[s]) % MOD;
            vector<ll> dp1(K, 0);
            for (int s = 0; s < K; ++s) {
                if (s >= 1) {
                    dp1[s] = prefix[s - 1];
                    if (s - A[i] - 1 >= 0) {
                        dp1[s] =
                            (dp1[s] - prefix[s - A[i] - 1] + MOD) % MOD;
                    }
                } else {
                    dp1[s] = 0;
                }
            }
            swap(dp0, dp1);
        }
        ll sum = 0;
        for (int s = 0; s < K; ++s)
            sum = (sum + dp0[s]) % MOD;
        return (total - sum + MOD) % MOD;
    }
};",1434323076
mastoori1234,mastoori1234,33,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {

        int n = s.length();
        
        vector<int> res(n);
        
        vector< vector<int> > adj;
        
        vector< vector<int> > stk( 26, vector<int>());
        
        vector<int> np( n, -1);
        
        auto gen = [&]( vector<int> & par)->void {
            adj.clear();
            adj.resize( n, vector<int>());
            for( int i=0; i<n; i++) {
                int u = par[i];
                int v = i;
                if(u==-1) {
                    continue;
                }
                adj[u].push_back(v);
            }
        };
        
        function<void(int)> dfs;
        
        dfs = [&]( int idx)->void {
            int c = s[idx]-'a';
            if(!stk[c].empty()) {
                np[idx] = stk[c].back();
            } else {
                np[idx] = parent[idx];
            }
            stk[c].push_back(idx);
            for( int next: adj[idx]) {
                dfs(next);
            }
            stk[c].pop_back();
        };
        
        function<int(int)> solve;
        
        solve = [&]( int idx)->int {
            int count = 1;
            for( int next: adj[idx]) {
                count += solve(next);
            }
            res[idx] = count;
            return count;
        };
        
        
        
        gen(parent);
        
        dfs(0);
        
        gen(np);
        
        solve(0);
        
        return res;
    }
};",1434318249
mastoori1234,mastoori1234,33,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        
        vector<int> dp( n, 0);
        vector<int> next( n, 0);
        
        for(int ii=0; ii<k; ii++) {
            for( int i=0; i<n; i++) {
                next[i] = max( next[i], dp[i]+stayScore[ii][i]);
            }
            for( int i=0; i<n; i++) {
                for( int j=0; j<n; j++) {
                    next[j] = max( next[j], dp[i]+travelScore[i][j]);
                }
            }
            for( int i=0; i<n; i++) {
                dp[i] = next[i];
                next[i] = 0;
            }
        }
        
        int ans = 0;
        for( int v: dp) {
            ans = max( ans, v);
        }
        
        return ans;
    }
};",1434325764
mastoori1234,mastoori1234,33,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        
        int n = s.length();
        
        int ans = 1;
        
        for( int i=0; i<n; i++) {
            int j = i;
            while((j+1<n) && (s[j]==s[j+1])) {
                j += 1;
            }
            int t = j-i+1;
            i=j;
            ans = ans+t-1;
        }
        
        
        return ans;
    }
};",1434303216
mastoori1234,mastoori1234,33,3618,cpp,"typedef long long int ll;

const ll mod = 1e9+7;

// ll ffe( ll a, ll b) {
//     if(b==0) {
//         return 1;
//     } else {
//         ll v = (b%2==1)?a:1;
//         return (v*ffe( (a*a)%mod, b/2))%mod;
//     }
// }

// ll mi( ll a) {
//     return ffe( a, mod-2);
// }

// const ll N = 5e5;

// bool done = false;
// ll fact[N+1];
// ll ifact[N+1];

// ll ncr( ll n, ll r) {
//     ll v = fact[n];
//     v = (v*ifact[n-r])%mod;
//     v = (v*ifact[r])%mod;
//     return v;
// }

class Solution {
public:
    
    Solution() {
        // if(done) {
        //     return;
        // }
        // done = true;
        // fact[0] = 1;
        // for( ll i=1; i<=N; i++) {
        //     fact[i] = (i*fact[i-1])%mod;
        // }
        // for( ll i=0; i<=N; i++) P{
        //     ifact[i] = mi(fact[i]);
        // }
    }
    
    int possibleStringCount(string s, int k) {
        
        ll n = s.length();
        ll ans = 1;
        
        vector< pair<char,ll> > arr;
        
        for( ll i=0; i<n; i++) {
            ll j = i;
            while((j+1<n) && (s[i]==s[j+1])) {
                j += 1;
            }
            ll count = j-i+1;
            i=j;
            arr.push_back({ s[i], count});
            // ll tot = 0;
            // for( ll j=0; j<=tot-1; j++) {
            //     tot = (tot+ncr(tot-1, j))%mod;
            // }
            ans = (ans*count)%mod;
        }
        
        if(arr.size()>=k) {
            return ans;
        }
        
        k = k - 1;
        
        vector<ll> dp(k+1, 0);
        vector<ll> next(k+1, 0);
        
        dp[0] = 1;
        
        for( auto p: arr) {
            ll l = p.second;
            ll tot = 0;
            for( ll i=0; i<=k; i++) {
                next[i] = tot;
                tot += dp[i];
                tot %= mod;
                if(i-l>=0) {
                    tot = (tot-dp[i-l]+mod)%mod;
                }
            }
            for( ll i=0; i<=k; i++) {
                dp[i] = next[i];
                next[i] = 0;
            }
        }
        
        for( ll i=1; i<=k; i++) {
            ans = (ans-dp[i]+mod)%mod;
        }
        
        return ans;
    }
};",1434298539
JeffreyLC,JeffreyLC,36,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        parent_ = parent;
        s_ = s;
        
        const int n = parent.size();
        c.resize(n);
        for (int i = 1; i < n; ++i) {
            c[parent[i]].push_back(i);
        }
        vector<int> last_pos(26, -1);
        dfs1(0, last_pos);
        
        c.clear();
        c.resize(n);
        for (int i = 1; i < n; ++i) {
            c[parent_[i]].push_back(i);
        }
        
        ans.resize(n);
        dfs2(0);
        
        return ans;
    }
private:
    vector<int> parent_;
    string s_;
    vector<vector<int>> c;
    vector<int> ans;
    
    void dfs1(int x, vector<int> last_pos) {
        int idx = s_[x] - 'a';
        if (x > 0 && last_pos[idx] != -1) {
            parent_[x] = last_pos[idx];
        }
        last_pos[idx] = x;
        for (int y : c[x]) {
            dfs1(y, last_pos);
        }
    }
    
    void dfs2(int x) {
        ans[x] = 1;
        for (int y : c[x]) {
            dfs2(y);
            ans[x] += ans[y];
        }
    }
};",1434288075
JeffreyLC,JeffreyLC,36,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(2, vector<int>(n));
        for (int i = 0; i < n; ++i) {
            dp[0][i] = stayScore[0][i];
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                dp[0][j] = max(dp[0][j], travelScore[i][j]);
            }
        }
        int state = 0, inv = 1;
        for (int d = 1; d < k; ++d) {
            state = !state;
            inv = !inv;
            for (int i = 0; i < n; ++i) {
                dp[state][i] = dp[inv][i] + stayScore[d][i];
            }
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    dp[state][j] = max(dp[state][j], dp[inv][i] + travelScore[i][j]);
                }
            }
        }
        return *max_element(dp[state].begin(), dp[state].end());
    }
};",1434297980
JeffreyLC,JeffreyLC,36,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        const int n = word.length();
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (word[i - 1] == word[i]) {
                ++ans;
            }
        }
        return ans;
    }
};",1434260326
JeffreyLC,JeffreyLC,36,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        constexpr int MOD = 1e9 + 7;
        
        const int n = word.length();
        int cnt = 1;
        vector<int> v;
        for (int i = 1; i < n; ++i) {
            if (word[i - 1] == word[i]) {
                ++cnt;
            } else {
                v.push_back(cnt);
                cnt = 1;
            }
        }
        v.push_back(cnt);
        
        long long ans = 1;
        for (int cnt : v) {
            ans *= cnt;
            ans %= MOD;
        }
        
        const int m = v.size();
        if (m >= k) return ans;
        
        vector<long long> coeff(k), new_coeff;
        coeff[m] = 1;
        for (int exp : v) {
            vector<long long> new_coeff = coeff;
            for (int i = 0; i + exp < k; ++i) {
                new_coeff[i + exp] -= coeff[i];
            }
            for (int i = 0; i < k; ++i) {
                new_coeff[i] %= MOD;
                new_coeff[i] += MOD;
                new_coeff[i] %= MOD;
            }
            coeff.swap(new_coeff);
        }
        
        vector<long long> polynomial(k);
        vector<int> mi = ModularInverses(k, MOD);
        polynomial[0] = 1;
        long long coefficient = 1;
        for (int i = 1; i < k; ++i) {
            coefficient *= (-m - (i - 1));
            coefficient %= MOD;
            coefficient *= mi[i];
            coefficient %= MOD;
            if (i % 2 == 1) {
                polynomial[i] = -coefficient;
            } else {
                polynomial[i] = coefficient;
            }
            polynomial[i] %= MOD;
            polynomial[i] += MOD;
            polynomial[i] %= MOD;
        }
        int exponent = -m;
        
        vector<long long> product(k);
        for (int i = 0; i < k; ++i) {
            for (int j = 0; i + j < k; ++j) {
                product[i + j] += coeff[i] * polynomial[j];
                product[i + j] %= MOD;
                product[i + j] += MOD;
                product[i + j] %= MOD;
            }
        }
        
        for (long long c : product) {
            ans -= c;
            ans %= MOD;
            ans += MOD;
            ans %= MOD;
        }
        return ans;
        
    }
private:
    vector<int> ModularInverses(int n, int mod) {
        vector<int> inv(n + 1);
        inv[0] = 1;
        if (n > 1) {
            inv[1] = 1;
            for (int i = 2; i <= n; ++i) {
                inv[i] = (long long) inv[mod % i] * (mod - mod / i) % mod;
            }
        }
        return inv;
    }
};",1434335551
Paul_Liao_1457,liaoyunyang0815,38,3576,cpp,"class Solution {
public:
    vector<int> e[100005];
    int who[500], y[100005], siz[100005], p[100005];
    string ch;
    void dfs(int now) {
        siz[now] = 1;
        y[now] = who[ch[now]];
        who[ch[now]] = now;
        for (int i:e[now]) {
            dfs(i);
            siz[now] += siz[i];
        }
        who[ch[now]] = y[now];
        if (y[now] != -1) {
            siz[y[now]] += siz[now];
            siz[p[now]] -= siz[now];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        ch = s;
        for (int i = 0; i < 500; i++) who[i] = -1;
        for (int i = 1; i < n; i++) {
            p[i] = parent[i];
            e[parent[i]].push_back(i);
        }
        dfs(0);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            ans.push_back(siz[i]);
        }
        return ans;
    }
};",1434280363
Paul_Liao_1457,liaoyunyang0815,38,3587,cpp,"class Solution {
public:
    int dp[205][205] = {0};
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        for (int i = 1; i <= k; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (j == k) {
                        dp[i][j] = max(dp[i][j], dp[i-1][j] + stayScore[i-1][j]);
                    } else {
                        dp[i][j] = max(dp[i][j], dp[i-1][k] + travelScore[k][j]);
                    }
                    ans = max(ans, dp[i][j]);
                }
            }
        }
        return ans;
    }
};",1434288102
Paul_Liao_1457,liaoyunyang0815,38,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 1;
        int ans = 0;
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i-1]) {
                cnt++;
            } else {
                ans += cnt - 1;
                cnt = 1;
            }
        }
        ans += cnt - 1;
        return ans + 1;
    }
};",1434261819
Paul_Liao_1457,liaoyunyang0815,38,3618,cpp,"class Solution {
public:
    #define MOD (long long)(1e9 + 7)
    long long dp[2][2005] = {0}, pre[2][2005] = {0};
    int possibleStringCount(string word, int k) {
        int cnt = 1;
        long long  ans = 1;
        vector<int> all;
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i-1]) {
                cnt++;
            } else {
                ans = ans * cnt % MOD;
                all.push_back(cnt);
                cnt = 1;
            }
        }
        ans = ans * cnt % MOD;
        // cout << ""ans = "" << ans << endl;
        all.push_back(cnt);
        for (int i = 0; i < all.size(); i++) {
            if (i > k) return ans;
            // cout << ""i = "" << i << "" all = "" << all[i] << endl;
            for (int x = 0; x < min(k, i+1); x++) dp[i&1][x] = 0;
            for (int x = i+1; x < k; x++) {
                if (i == 0 && x <= all[i]) {
                    dp[i&1][x] = 1;
                } else if (i) {
                    dp[i&1][x] = pre[(i+1)&1][x - 1] - pre[(i+1)&1][max(0, x - all[i] - 1)] + MOD;
                    dp[i&1][x] %= MOD;
                }  
                // cout << ""dp["" << i << ""]["" << x << ""] = "" << dp[i&1][x] << endl;
            }
            for (int x = 1; x < k; x++) {
                pre[i&1][x] = pre[i&1][x-1] + dp[i&1][x];
                pre[i&1][x] %= MOD;
            }
        }
        long long sub = 0;
        for (int x = 0; x < k; x++) {
            sub = (sub + dp[(all.size()+1)&1][x]) % MOD;
        }
        ans = (ans - sub + MOD) % MOD;
        return ans;
    }
};",1434322449
Sergei Sobol,sobols,40,3576,cpp,"constexpr int A = 26;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        G_.resize(n);
        G2_.resize(n);
        
        for (int i = 1; i < n; ++i) {
            G_[parent[i]].push_back(i);
        }
        S_ = s;
        vector<int> dist(A, -1);
        DFS(0, -1, dist);
        
        Ans_.resize(n);
        DFS2(0);
        return Ans_;
    }
    
    void DFS(int v, int prev, vector<int>& dist) {
        int cur = S_[v] - 'a';
        
        int last = dist[cur];
        dist[cur] = v;
        
        for (int u : G_[v]) {
            DFS(u, v, dist);
        }
        
        if (last != -1) {
            G2_[last].push_back(v);
        } else if (prev != -1) {
            G2_[prev].push_back(v);
        }
        
        dist[cur] = last;
    }

    void DFS2(int v) {
        Ans_[v] = 1;
        for (int u : G2_[v]) {
            DFS2(u);
            Ans_[v] += Ans_[u];
        }
    }

private:
    vector<vector<int>> G_;
    vector<vector<int>> G2_;
    vector<int> Ans_;
    string S_;
};",1434286150
Sergei Sobol,sobols,40,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> prv, nxt;
        prv.resize(n);
        nxt.resize(n);
        for (int day = 0; day < k; ++day) {
            nxt.assign(n, 0);
            for (int i = 0; i < n; ++i) {
                nxt[i] = prv[i] + stayScore[day][i];
            }
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    nxt[j] = max(nxt[j], prv[i] + travelScore[i][j]);
                }
            }
            nxt.swap(prv);
        }
        return *max_element(prv.begin(), prv.end());
    }
};",1434295153
Sergei Sobol,sobols,40,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for (size_t i1 = 0; i1 < word.size();) {
            size_t i2 = i1;
            while (i2 < word.size() && word[i2] == word[i1]) {
                ++i2;
            }
            int len = i2 - i1;
            if (len > 1) {
                ans += len - 1;
            }
            i1 = i2;
        }
        return ans;
    }
};",1434262783
Sergei Sobol,sobols,40,3618,cpp,"constexpr int MOD = 1'000'000'007;

void Add(int& x, int y) {
    x += y;
    if (x >= MOD) { x -= MOD; }
}
void Sub(int& x, int y) {
    x -= y;
    if (x < 0) { x += MOD; }
}

class Solution {
public:
    int Solve(const vector<int>& cnt, int m) {
        if (m <= 0) {
            return 0;
        }

        // len < m
        vector<int> prv(m), nxt(m);
        prv[0] = 1;
        for (int c : cnt) {
            assert(c > 0);
            int sum = 0;
            for (int i = 0; i < m; ++i) {
                Add(sum, prv[i]);
                if (i - c - 1 >= 0) {
                    Sub(sum, prv[i - c - 1]);
                }
                nxt[i] = sum;
            }
            prv.swap(nxt);
        }
        int ret = 0;
        for (int x : prv) {
            Add(ret, x);
        }
        return ret;
    }

    int possibleStringCount(string word, int k) {
        int diffLet = 0;
        int ans = 1;

        vector<int> cnt;
        for (size_t i1 = 0; i1 < word.size();) {
            size_t i2 = i1;
            while (i2 < word.size() && word[i2] == word[i1]) {
                ++i2;
            }
            int len = i2 - i1;
            diffLet++;
            if (len > 1) {
                cnt.push_back(len - 1);
            }
            ans = (long long)(ans) * len % MOD;
            
            i1 = i2;
        }
        
        int bad = Solve(cnt, k - diffLet);
        Sub(ans, bad);
        
        return ans;
    }
};",1434336975
hxu10,hxu10,41,3576,python,"class Solution(object):
    def findSubtreeSizes(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[int]
        """"""
        n = len(s)
        children = [[] for _ in range(n)]
        
        for i in range(1,n):
            children[parent[i]].append(i)
            
        nextparent = [-1]*n
        
        dic = {}
        
            
            
        def getnext(index):
            
            if s[index] in dic and len(dic[s[index]]) > 0:
                nextparent[index] = dic[s[index]][-1]
            else:
                nextparent[index] = parent[index]
                
            if s[index] not in dic:
                dic[s[index]] = []
                
                
            dic[s[index]].append(index)
            
            for nextindex in children[index]:
                getnext(nextindex)
                
            dic[s[index]].pop()
            
        getnext(0)
        
        
        children2 = [[] for _ in range(n)]
        
        for i in range(1,n):
            children2[nextparent[i]].append(i)
        
        
        queue = deque()
        
        queue.append(0)

        seq = []
        while queue:
            index = queue.popleft()
            seq.append(index)
            for nextindex in children2[index]:
                queue.append(nextindex)
                
                
        ans = [0]*n
        
        for index in seq[::-1]:
            ans[index] = 1
            for nextindex in children2[index]:
                ans[index] += ans[nextindex]
                
                    
                    
        return ans
    
                
            
        
                
            
            ",1434273865
hxu10,hxu10,41,3587,python,"class Solution(object):
    def maxScore(self, n, k, stayScore, travelScore):
        """"""
        :type n: int
        :type k: int
        :type stayScore: List[List[int]]
        :type travelScore: List[List[int]]
        :rtype: int
        """"""
        
        dp = [[-1 for _ in range(n)] for _ in range(k)]
        
        
        def getnext(i, curr):
            if i==k:
                return 0
            
            if dp[i][curr] >= 0:
                return dp[i][curr]
            
            ans = 0
            
            for dest in range(n):
                if dest == curr:
                    ans = max(ans,  stayScore[i][curr] + getnext(i+1,dest))
                else:
                    ans = max(ans,  travelScore[curr][dest] + getnext(i+1,dest))
                    
                    
            dp[i][curr] = ans
            return ans
        
        
        
        
        for curr in range(n):
            getnext(0,curr)
            
            
        res = max(dp[0])

        return res
    
            
            
                             
                    
                    
            ",1434290986
hxu10,hxu10,41,3617,python,"class Solution(object):
    def possibleStringCount(self, word):
        """"""
        :type word: str
        :rtype: int
        """"""
        ans = 1
        for i in range(1,len(word)):
            if word[i]==word[i-1]:
                ans += 1
        return ans
    ",1434259718
hxu10,hxu10,41,3618,python,"M = 10**9 + 7
class Solution(object):
    def possibleStringCount(self, word, k):
        """"""
        :type word: str
        :type k: int
        :rtype: int
        """"""
        b = []
        
        accu = 1
        n = len(word)
        for i in range(1,n):
            if word[i]!=word[i-1]:
                b.append(accu)
                accu = 1
            else:
                accu += 1
                
                
        b.append(accu)

        
        ans = 1
        for num in b:
            ans = ans * num % M
            
            
    
        
        if len(b) >= k:
            return ans
        
    
        

        
        
        dp = [0]*(k+2)
        
        dp[0] = 1
        
        

        

        
        accudp = [1]*(k+1) + [0]
        
        
        
        
        

        
    
       # print(b)
        
        
        for num in b:
            

            
            for i in range(k,-1,-1):
                dp[i] = (accudp[i-1] - accudp[max(-1,i-num-1)])%M
                
            
            for i in range(k+1):
                accudp[i] = (accudp[i-1] + dp[i])%M
                
                
           # print(dp)
           # print(accudp)
           # print("" "")
                
                

        
        return (ans - accudp[k-1])%M
    
    
                
                
            
            
            
        
                ",1434324203
Haipei Liu,lhp_ch,42,3576,python3,"from typing import List
import sys
sys.setrecursionlimit(1<<25)

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n= len(parent)
        tree = [[] for _ in range(n)]
        for i in range(1,n):
            p=parent[i]
            tree[p].append(i)

        new_p = parent.copy()
        last = {}

        def dfs(u,last):
            c=s[u]
            if c in last:
                new_p[u]=last[c]
            prev = last.get(c,-1)
            last[c]=u

            for v in tree[u]:
                dfs(v,last)
            if prev ==-1:
                del last[c]
            else:
                last[c]=prev
        dfs(0,last)

        new_tree=[[] for _ in range(n)]
        for i in range(n):
            if new_p[i] != -1:
                new_tree[new_p[i]].append(i)

        answer=[0]*n

        def dfs_size(u):
            count =1
            for v in new_tree[u]:
                count += dfs_size(v)
            answer[u]=count
            return count

        dfs_size(0)

        return answer",1434280206
Haipei Liu,lhp_ch,42,3587,python3,"from typing import List

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        prev_dp = [max(stayScore[0][dest], max(travelScore[src][dest] for src in range(n))) for dest in range(n)]

        for day in range(1,k):
            curr_dp = [0]*n
            for dest in range(n):
                stay = prev_dp[dest]+stayScore[day][dest]
                travel = max(prev_dp[src]+travelScore[src][dest] for src in range(n))

                curr_dp[dest]= max(stay, travel)
            prev_dp = curr_dp

        return max(prev_dp)",1434297878
Haipei Liu,lhp_ch,42,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        n = len(word)
        i = 0
        while i<n:
            j=i
            while j<n and word[j]==word[i]:
                j +=1
            length = j-i
            if length > 1:
                res += (length -1)
            i=j
        return res",1434264572
Haipei Liu,lhp_ch,42,3618,python3,"from typing import List

class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10**9+7
        r = []
        n = len(word)

        if n ==0:
            return 0
        
        c = word[0]
        cnt =1
        for i in range(1,n):
            if word[i]==c:
                cnt +=1
            else:
                r.append(cnt)
                c = word[i]
                cnt =1
        r.append(cnt)
        R = len(r)

        if R>=k:
            tot =1
            for m in r:
                tot = tot* m %MOD
            return tot
        
        tot=1
        for m in r:
            tot = tot * m % MOD
        dp = [0]*k
        dp[0]=1
    
        for m in r:
            ps = [0]*k
            ps[0] = dp[0]
            for s in range(1,k):
                ps[s]=(ps[s-1]+dp[s]) % MOD
            ndp = [0]*k
    
            for s in range(k):
                if s==0:
                    ndp[s]=0
                else:
                    ndp[s]= ps[s-1]
                    if s-m-1>=0:
                        ndp[s]= (ndp[s]-ps[s-m-1]+MOD)%MOD
            dp = ndp
        sl=0
        for s in range(k):
            if s >=R:
                sl= (sl+dp[s])%MOD
        ans = (tot-sl+MOD)%MOD
        return ans
    
                
            
        ",1434332208
Ivan_len,Ivan_len,43,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> c(n);
        vector<vector<int>> cnt(n, vector<int>(26, -1));
        vector<int> ans(n);
        for (int i = 1; i < n; i++) c[parent[i]].push_back(i);
        auto dfs1 = [&](auto&& self, int u) -> void {
            if (parent[u] != -1) cnt[u] = cnt[parent[u]];
            if (cnt[u][(int)(s[u] - 'a')] != -1) parent[u] = cnt[u][(int)(s[u] - 'a')];
            cnt[u][(int)(s[u] - 'a')] = u;
            for (auto i : c[u]) {
                self(self, i);
            }
        };
        dfs1(dfs1, 0);
        c.clear();
        c.resize(n);
        for (int i = 1; i < n; i++) c[parent[i]].push_back(i);
        auto dfs2 = [&](auto&& self, int u) -> void {
            ans[u] = 1;
            for (auto i : c[u]) {
                self(self, i);
                ans[u] += ans[i];
            }
        };
        dfs2(dfs2, 0);
        return ans;
    }
};",1434276444
Ivan_len,Ivan_len,43,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int i = 1; i <= k; i++) {
            for (int cur = 0; cur < n; cur++) {
                for (int pre = 0; pre < n; pre++) {
                    // cout << i << ' ' << cur << ' ' << pre << ' ';
                    if (pre == cur) dp[i][cur] = max(dp[i][cur], dp[i - 1][cur] + stayScore[i - 1][cur]);
                    else dp[i][cur] = max(dp[i][cur], dp[i - 1][pre] + travelScore[pre][cur]);
                }
            }
        }
        int ans = 0;
        for (auto i : dp[k]) ans = max(ans, i);
        return ans;
    }
};",1434288143
Ivan_len,Ivan_len,43,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 0;
        int i = 0;
        while (i < n) {
            int j = i + 1;
            while (j < n && word[j] == word[i]) j++;
            ans += j - i - 1;
            i = j;
        }
        return ans + 1;
    }
};",1434265298
Ivan_len,Ivan_len,43,3618,cpp,"template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
}

template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

private:
    Type value;
};

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }

template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }

template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }

template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }

template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template<typename T, typename U>
Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}

template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}

/*
using ModType = int;

struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;

vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);

Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int possibleStringCount(string word, int k) {
        int n = word.size();
        Mint ans = 1;
        int i = 0;
        while (i < n) {
            int j = i + 1;
            while (j < n && word[j] == word[i]) j++;
            ans *= (Mint)(j - i);
            i = j;
        }
        vector<vector<Mint>> dp(min(n, k) + 1, vector<Mint>(k + 1, 0));
        dp[0][0] = (Mint)1;
        i = 0;
        int nth = 1;
        // cout << ans << '\n';
        while (i < n) {
            int j = i + 1;
            while (j < n && word[j] == word[i]) j++;
            for (int l = nth; l <= k; l++) dp[nth - 1][l] += dp[nth - 1][l - 1];
            int len = j - i;
            for (int l = nth; l <= k; l++) {
                if (l - len <= 0) dp[nth][l] = dp[nth - 1][l - 1];
                else dp[nth][l] = dp[nth - 1][l - 1] - dp[nth - 1][l - len - 1];
            }
            // for (int l = 0; l <= k; l++) cout << dp[nth][l] << ' ';
            // cout << '\n';
            nth++;
            if (nth > k) break;
            i = j;
        }
        for (int i = 0; i < k; i++) ans -= dp[nth - 1][i];
        return (int)ans;
    }
};",1434318499
Rakesh_Reddy7,Addula_Rakesh7,44,3576,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def findSubtreeSizes(self, par: List[int], s: str) -> List[int]:
        n = len(par)
        r = 0
        tree = [[] for i in range(n)]
        for i in range(1, n):
            tree[par[i]].append(i)
        
        np = par.copy()
        last = {}
        for i in range(n):
            pass
        def dfs(node):
            c = s[node]
            prev = last.get(c, None)
            if prev is not None:
                np[node] = prev
            last[c] = node
            for child in tree[node]:
                dfs(child)
            if prev is None:
                del last[c]
            else:
                last[c] = prev
        
        dfs(0)
        
        lst = [[] for i in range(n)]
        for i in range(1, n):
            p = np[i]
            lst[p].append(i)
            r += 1
        
        sz = [0] * n
        
        def solve(node):
            lenx = 1
            for child in lst[node]:
                lenx += solve(child)
            sz[node] = lenx
            return lenx
        
        solve(0)
        return sz


",1434332715
Rakesh_Reddy7,Addula_Rakesh7,44,3587,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def maxScore(self, n: int, k: int, ss: List[List[int]], ts: List[List[int]]) -> int:
        r = 0
        dp = [[float('-inf')] * n for i in range(k)]
        dp1 = [[float('-inf')] * n for i in range(k)]
        for p in range(n):
            maxt = max(ts[i][p] for i in range(n))
            dp[0][p] = max(ss[0][p], maxt)
        for i in range(k):
            r += 1
        for i in range(1, k):
            for p in range(0,n):
                maxi = float('-inf')
                z = 0
                for x in range(n):
                    if p != x:
                        sz = dp[i-1][x] + ts[x][p]
                    else:
                        sz = dp[i-1][x] + ss[i][p]
                    maxi = max(sz, maxi)
                dp[i][p] = maxi
                z += 1
        return max(dp[k-1])*1",1434320758
Rakesh_Reddy7,Addula_Rakesh7,44,3617,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def possibleStringCount(self, word: str) -> int:
        mod = 10**9 + 7  
        n = len(word)
        if n == 0:
            return 0
        lst = [] 
        charx = word[0]
        cl = 1
        
        for c in word[1:]:
            if c == charx:
                cl += 1
            else:
                lst.append(cl)
                charx = c
                cl = 1
        lst.append(cl)  
        tot = 1 
        for p in lst:
            if p >= 2:
                tot += (p - 1)
        return tot % mod",1434313436
Rakesh_Reddy7,Addula_Rakesh7,44,3618,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod = 10**9 + 7
        lst = []
        n = len(word)
        if n > 0:
            charx = word[0]
            lenx = 1
            f = 0
            for c in word[1:]:
                if c == charx:
                    lenx += 1
                else:
                    lst.append(lenx)
                    charx = c
                    lenx = 1
            lst.append(lenx)
        m = len(lst)
        cp = lst.copy()
        tot = 1
        for l in cp:
            tot = (tot * l) % mod

        if m > k - 1:
            return tot
        tsum = k - 1 - m
        if tsum < 0:
            less = 0
            f -= 1
        else:
            dp = [0] * (tsum + 1)
            dp[0] = 1 
            f += 1
            for i in range(n):
                pass
            for idx, p in enumerate(cp):
                maxp = min(p - 1, tsum)
                dpn = [0] * (tsum + 1)
                for s in range(tsum + 1):
                    if dp[s]:
                        up = min(maxp, tsum - s)
                        dpn[s] = (dpn[s] + dp[s]) % mod
                        if s + up + 1 <= tsum:
                            dpn[s + up + 1] = (dpn[s + up + 1] - dp[s]) % mod
                curr = 0
                for s in range(tsum + 1):
                    curr = (curr + dpn[s]) % mod
                    dp[s] = curr
            less = sum(dp) % mod
        return (tot - less) % mod",1434290378
German Andosov,randle999,46,3576,kotlin,"class Solution {
    fun findSubtreeSizes(parent: IntArray, s: String): IntArray {
        val n = s.length
        val gr = MutableList(n) { mutableListOf<Int>() }
        for (i in 1..<n) {
            gr[parent[i]].add(i)
        }

        val newParents = MutableList(n) { -1 }
        val closest = MutableList(26) { -1 }

        fun dfs(u: Int) {
            val ch = s[u].toInt() - 'a'.toInt()
            newParents[u] = if (closest[ch] == -1) {
                parent[u]
            } else {
                closest[ch]
            }

            val prev = closest[ch]
            closest[ch] = u
            for (v in gr[u]) {
                dfs(v)
            }
            closest[ch] = prev
        }

        dfs(0)

        val newGr = MutableList(n) { mutableListOf<Int>() }
        for (i in 1..<n) {
            newGr[newParents[i]].add(i)
        }

        val ans = IntArray(n) { 0 }
        
        fun newDfs(u: Int) {
            ans[u] = 1
            for (v in newGr[u]) {
                newDfs(v)
                ans[u] += ans[v]
            }
        }

        newDfs(0)

        return ans
    }
}",1434286293
German Andosov,randle999,46,3587,kotlin,"class Solution {
    fun maxScore(n: Int, k: Int, stayScore: Array<IntArray>, travelScore: Array<IntArray>): Int {
        var dp = MutableList(n) { 0 }
        for (day in 0..<k) {
            val dpNext = MutableList(n) { 0 }
            for (curr in 0..<n) {
                for (next in 0..<n) {
                    val poss = dp[curr] + if (curr == next) {
                        stayScore[day][curr]
                    } else {
                        travelScore[curr][next]
                    }
                    dpNext[next] = max(dpNext[next], poss)
                }
            }
            dp = dpNext
        }
        return dp.max()
    }
}",1434297610
German Andosov,randle999,46,3617,kotlin,"class Solution {
    fun possibleStringCount(word: String): Int {
        var streak = 1
        var ans = 1
        for (i in 1..<word.length) {
            if (word[i] == word[i - 1]) {
                streak++
            } else {
                ans += streak - 1
                streak = 1
            }
        }

        ans += streak - 1

        return ans
    }
}",1434261091
German Andosov,randle999,46,3618,kotlin,"class Solution {
    fun possibleStringCount(word: String, k: Int): Int {
        val mod = 1_000_000_007L
        
        val streaks = mutableListOf<Int>()
        var streak = 1
        for (i in 1..<word.length) {
            if (word[i] != word[i - 1]) {
                streaks.add(streak)
                streak = 1
            } else {
                streak++
            }
        }
        streaks.add(streak)

        var ans = 1L
        for (i in 0..<streaks.size) {
            ans *= streaks[i]
            ans %= mod
        }
        
        if (streaks.size >= k) {
            return ans.toInt()
        }
        val m = streaks.size

        var dp = MutableList(k) { 0L }
        dp[0] = 1L
        for (ch in 0..<m) {
            val dpNextPref = MutableList(k + 1) { 0L }
            val dpNext = MutableList(k) { 0L }
            for (curLen in 0..<k) {
                dpNextPref[curLen + 1] += dp[curLen]
                dpNextPref[min(curLen + streaks[ch] + 1, k)] -= dp[curLen]
            }
            var acc = 0L
            for (curLen in 0..<k) {
                acc = (acc + dpNextPref[curLen]) % mod
                dpNext[curLen] = acc
            }
            dp = dpNext
        }

        return ((ans - dp.sum() + mod * mod) % mod).toInt()
    }
}",1434339767
SeriouSam,SeriousSam2622,47,3576,cpp,"// x#include <iostream>
// #include <string>
// #include <vector>
// #include <unordered_set>
// #include <unordered_map>

// using namespace std;

// void generateWords(int pos, int n,
//                    const vector<unordered_set<char>>& allowed_letters,
//                    const unordered_set<char>& must_include,
//                    unordered_set<char>& used_letters,
//                    string& current_word,
//                    unordered_set<string>& generated_words) {
//     if (pos == n) {
//         // Check if all must_include letters are used
//         for (char c : must_include) {
//             if (current_word.find(c) == string::npos) {
//                 return; // Not all included letters are used
//             }
//         }
//         generated_words.insert(current_word);
//         return;
//     }

//     for (char c : allowed_letters[pos]) {
//         if (used_letters.count(c)) continue; // Skip used letters (no repeats)
//         used_letters.insert(c);
//         current_word[pos] = c;
//         generateWords(pos + 1, n, allowed_letters, must_include, used_letters, current_word, generated_words);
//         used_letters.erase(c);
//     }
// }

// int main() {
//     // Example inputs
//     string feedback = ""BYBG""; // Feedback string
//     string guess = ""WORD"";    // Guess word
//     int n = guess.piyulength();

//     // Assume dictionary is provided as a hash set for O(1) lookups
//     unordered_set<string> dictionary = {
//         // Example dictionary words (would be much larger in practice)
//         ""WOOD"", ""WARD"", ""BIRD"", ""WORD"", ""CORD"", ""DOME"", ""MODE"", ""DOME"", ""DOVE"", ""DOPE"", ""NODE"", ""DONE"", ""DOLE"", ""BOND"", ""BOLD"", ""COLD"", ""GOLD"", ""FOLD"", ""MOLD"", ""TOLD"", ""HOLD"", ""BOND""
//     };

//     // Step 1: Derive constraints from feedback and guess word
//     vector<unordered_set<char>> allowed_letters(n); // Allowed letters per position
//     unordered_set<char> must_include; // Letters that must be included somewhere
//     unordered_set<char> excluded_letters; // Letters that must not be in the word

//     unordered_set<char> all_letters;
//     for (char c = 'A'; c <= 'Z'; ++c) {
//         all_letters.insert(c);
//     }

//     // First, determine letters that must not be in the word
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'B') {
//             excluded_letters.insert(guess_char);
//         }
//     }

//     // Then, set up allowed letters per position and must_include letters
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'G') {
//             // Letter must be guess_char at this position
//             allowed_letters[i].insert(guess_char);
//         } else if (fb == 'Y') {
//             // Letter must not be guess_char at this position
//             // But guess_char must be included somewhere else
//             must_include.insert(guess_char);
//             // Allowed letters are all except guess_char and excluded_letters
//             allowed_letters[i] = all_letters;
//             allowed_letters[i].erase(guess_char);
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         } else if (fb == 'B') {
//             // Letter must not be any excluded letter
//             allowed_letters[i] = all_letters;
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         }
//     }
class Solution {
public:
    void piyu_dfs(int node, vector<vector<int>>& piyu_adj_list, vector<int>& piyu_new_parent, vector<int>& last_node, string& s) {
        int c = s[node] - 'a';
        int piyu_prev_last_node = last_node[c];
        if (piyu_prev_last_node != -1 && piyu_prev_last_node != node) {
            piyu_new_parent[node] = piyu_prev_last_node;
        }
        last_node[c] = node;
        for (int child : piyu_adj_list[node]) {
            piyu_dfs(child, piyu_adj_list, piyu_new_parent, last_node, s);
        }
        last_node[c] = piyu_prev_last_node;
    }

    int piyu_dfs_size(int node, vector<vector<int>>& piyu_adj_list_new, vector<int>& piyu_answer) {
        int size = 1;
        for (int child : piyu_adj_list_new[node]) {
            size += piyu_dfs_size(child, piyu_adj_list_new, piyu_answer);
        }
        piyu_answer[node] = size;
        return size;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> piyu_adj_list(n);
        for (int i = 1; i < n; ++i) {
            piyu_adj_list[parent[i]].push_back(i);
        }
        vector<int> piyu_new_parent(n);
        for (int i = 0; i < n; ++i) {
            piyu_new_parent[i] = parent[i];
        }
        vector<int> last_node(26, -1);
        piyu_dfs(0, piyu_adj_list, piyu_new_parent, last_node, s);

        // Build new adjacency list
        vector<vector<int>> piyu_adj_list_new(n);
        for (int i = 1; i < n; ++i) {
            int p = piyu_new_parent[i];
            piyu_adj_list_new[p].push_back(i);
        }

        vector<int> piyu_answer(n, 0);
        piyu_dfs_size(0, piyu_adj_list_new, piyu_answer);
        return piyu_answer;
    }
};



//     // Step 2: Generate all possible words satisfying the constraints
//     unordered_set<char> used_letters;
//     string current_word(n, ' '); // Initiapiyulize with spaces
//     unordered_set<string> generated_words; // Store generated words

//     generateWords(0, n, allowed_letters, must_include, used_letters, current_word, generated_words);

//     // Step 3: Intersect generated words with the dictionary
//     vector<string> possible_words;
//     for (const string& word : generated_words) {
//         if (dictionary.count(word)) {
//             possible_words.push_back(word);
//         }
//     }

//     // Output the possible target words
//     cout << ""Possible target words matching the feedback:"" << endl;
//     for (const string& word : possible_words) {
//         cout << word << endl;
//     }

//     return 0;
// }
",1434310654
SeriouSam,SeriousSam2622,47,3587,cpp,"// x#include <iostream>
// #include <string>
// #include <vector>
// #include <unordered_set>
// #include <unordered_map>

// using namespace std;

// void generateWords(int pos, int n,
//                    const vector<unordered_set<char>>& allowed_letters,
//                    const unordered_set<char>& must_include,
//                    unordered_set<char>& used_letters,
//                    string& current_word,
//                    unordered_set<string>& generated_words) {
//     if (pos == n) {
//         // Check if all must_include letters are used
//         for (char c : must_include) {
//             if (current_word.find(c) == string::npos) {
//                 return; // Not all included letters are used
//             }
//         }
//         generated_words.insert(current_word);
//         return;
//     }

//     for (char c : allowed_letters[pos]) {
//         if (used_letters.count(c)) continue; // Skip used letters (no repeats)
//         used_letters.insert(c);
//         current_word[pos] = c;
//         generateWords(pos + 1, n, allowed_letters, must_include, used_letters, current_word, generated_words);
//         used_letters.erase(c);
//     }
// }

// int main() {
//     // Example inputs
//     string feedback = ""BYBG""; // Feedback string
//     string guess = ""WORD"";    // Guess word
//     int n = guess.piyulength();

//     // Assume dictionary is provided as a hash set for O(1) lookups
//     unordered_set<string> dictionary = {
//         // Example dictionary words (would be much larger in practice)
//         ""WOOD"", ""WARD"", ""BIRD"", ""WORD"", ""CORD"", ""DOME"", ""MODE"", ""DOME"", ""DOVE"", ""DOPE"", ""NODE"", ""DONE"", ""DOLE"", ""BOND"", ""BOLD"", ""COLD"", ""GOLD"", ""FOLD"", ""MOLD"", ""TOLD"", ""HOLD"", ""BOND""
//     };

//     // Step 1: Derive constraints from feedback and guess word
//     vector<unordered_set<char>> allowed_letters(n); // Allowed letters per position
//     unordered_set<char> must_include; // Letters that must be included somewhere
//     unordered_set<char> excluded_letters; // Letters that must not be in the word

//     unordered_set<char> all_letters;
//     for (char c = 'A'; c <= 'Z'; ++c) {
//         all_letters.insert(c);
//     }

//     // First, determine letters that must not be in the word
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'B') {
//             excluded_letters.insert(guess_char);
//         }
//     }

//     // Then, set up allowed letters per position and must_include letters
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'G') {
//             // Letter must be guess_char at this position
//             allowed_letters[i].insert(guess_char);
//         } else if (fb == 'Y') {
//             // Letter must not be guess_char at this position
//             // But guess_char must be included somewhere else
//             must_include.insert(guess_char);
//             // Allowed letters are all except guess_char and excluded_letters
//             allowed_letters[i] = all_letters;
//             allowed_letters[i].erase(guess_char);
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         } else if (fb == 'B') {
//             // Letter must not be any excluded letter
//             allowed_letters[i] = all_letters;
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         }
//     }
class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> piyu_dp(k, vector<int>(n, INT_MIN));
        for (int curr = 0; curr < n; ++curr) {
            piyu_dp[0][curr] = max(piyu_dp[0][curr], stayScore[0][curr]);
            for (int dest = 0; dest < n; ++dest) {
                if (dest != curr) {
                    piyu_dp[0][dest] = max(piyu_dp[0][dest], travelScore[curr][dest]);
                }
            }
        }

        for (int piyu_day = 1; piyu_day < k; ++piyu_day) {
            vector<int> piyu_maxTravelScore(n, INT_MIN);
            for (int piyu_prev_piyu_city = 0; piyu_prev_piyu_city < n; ++piyu_prev_piyu_city) {
                for (int piyu_city = 0; piyu_city < n; ++piyu_city) {
                    if (piyu_prev_piyu_city != piyu_city) {
                        piyu_maxTravelScore[piyu_city] = max(piyu_maxTravelScore[piyu_city], piyu_dp[piyu_day - 1][piyu_prev_piyu_city] + travelScore[piyu_prev_piyu_city][piyu_city]);
                    }
                }
            }
            for (int piyu_city = 0; piyu_city < n; ++piyu_city) {               
                piyu_dp[piyu_day][piyu_city] = piyu_dp[piyu_day - 1][piyu_city] + stayScore[piyu_day][piyu_city];               
                piyu_dp[piyu_day][piyu_city] = max(piyu_dp[piyu_day][piyu_city], piyu_maxTravelScore[piyu_city]);
            }
        }

        int piyu_ans = INT_MIN;
        for (int piyu_city = 0; piyu_city < n; ++piyu_city) {
            piyu_ans = max(piyu_ans, piyu_dp[k - 1][piyu_city]);
        }
        return piyu_ans;
    }
};



//     // Step 2: Generate all possible words satisfying the constraints
//     unordered_set<char> used_letters;
//     string current_word(n, ' '); // Initiapiyulize with spaces
//     unordered_set<string> generated_words; // Store generated words

//     generateWords(0, n, allowed_letters, must_include, used_letters, current_word, generated_words);

//     // Step 3: Intersect generated words with the dictionary
//     vector<string> possible_words;
//     for (const string& word : generated_words) {
//         if (dictionary.count(word)) {
//             possible_words.push_back(word);
//         }
//     }

//     // Output the possible target words
//     cout << ""Possible target words matching the feedback:"" << endl;
//     for (const string& word : possible_words) {
//         cout << word << endl;
//     }

//     return 0;
// }
",1434320185
SeriouSam,SeriousSam2622,47,3617,cpp,"// x#include <iostream>
// #include <string>
// #include <vector>
// #include <unordered_set>
// #include <unordered_map>

// using namespace std;

// void generateWords(int pos, int n,
//                    const vector<unordered_set<char>>& allowed_letters,
//                    const unordered_set<char>& must_include,
//                    unordered_set<char>& used_letters,
//                    string& current_word,
//                    unordered_set<string>& generated_words) {
//     if (pos == n) {
//         // Check if all must_include letters are used
//         for (char c : must_include) {
//             if (current_word.find(c) == string::npos) {
//                 return; // Not all included letters are used
//             }
//         }
//         generated_words.insert(current_word);
//         return;
//     }

//     for (char c : allowed_letters[pos]) {
//         if (used_letters.count(c)) continue; // Skip used letters (no repeats)
//         used_letters.insert(c);
//         current_word[pos] = c;
//         generateWords(pos + 1, n, allowed_letters, must_include, used_letters, current_word, generated_words);
//         used_letters.erase(c);
//     }
// }

// int main() {
//     // Example inputs
//     string feedback = ""BYBG""; // Feedback string
//     string guess = ""WORD"";    // Guess word
//     int n = guess.piyulength();

//     // Assume dictionary is provided as a hash set for O(1) lookups
//     unordered_set<string> dictionary = {
//         // Example dictionary words (would be much larger in practice)
//         ""WOOD"", ""WARD"", ""BIRD"", ""WORD"", ""CORD"", ""DOME"", ""MODE"", ""DOME"", ""DOVE"", ""DOPE"", ""NODE"", ""DONE"", ""DOLE"", ""BOND"", ""BOLD"", ""COLD"", ""GOLD"", ""FOLD"", ""MOLD"", ""TOLD"", ""HOLD"", ""BOND""
//     };

//     // Step 1: Derive constraints from feedback and guess word
//     vector<unordered_set<char>> allowed_letters(n); // Allowed letters per position
//     unordered_set<char> must_include; // Letters that must be included somewhere
//     unordered_set<char> excluded_letters; // Letters that must not be in the word

//     unordered_set<char> all_letters;
//     for (char c = 'A'; c <= 'Z'; ++c) {
//         all_letters.insert(c);
//     }

//     // First, determine letters that must not be in the word
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'B') {
//             excluded_letters.insert(guess_char);
//         }
//     }

//     // Then, set up allowed letters per position and must_include letters
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'G') {
//             // Letter must be guess_char at this position
//             allowed_letters[i].insert(guess_char);
//         } else if (fb == 'Y') {
//             // Letter must not be guess_char at this position
//             // But guess_char must be included somewhere else
//             must_include.insert(guess_char);
//             // Allowed letters are all except guess_char and excluded_letters
//             allowed_letters[i] = all_letters;
//             allowed_letters[i].erase(guess_char);
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         } else if (fb == 'B') {
//             // Letter must not be any excluded letter
//             allowed_letters[i] = all_letters;
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         }
//     }
class Solution {
public:
    int possibleStringCount(string word) {
        vector<pair<char, int>> piyu_groups;
        int n = word.size();
        int i = 0;
        while (i < n) {
            char c = word[i];
            int count = 0;
            while (i < n && word[i] == c) {
                i++;
                count++;
            }
            piyu_groups.push_back({c, count});
        }
        
        unordered_set<string> piyu_uniqueStrings;
        piyu_uniqueStrings.insert(word);
        
        int m = piyu_groups.size();
        for (int k = 0; k < m; ++k) {
            int len = piyu_groups[k].second;
            if (len == 1) continue; // Can't reduce further
            for (int new_len = 1; new_len < len; ++new_len) {
                // Construct new word
                string piyu_new_word;
                for (int j = 0; j < m; ++j) {
                    if (j == k) {
                        piyu_new_word.append(new_len, piyu_groups[j].first);
                    } else {
                        piyu_new_word.append(piyu_groups[j].second, piyu_groups[j].first);
                    }
                }
                piyu_uniqueStrings.insert(piyu_new_word);
            }
        }
        
        return piyu_uniqueStrings.size();
    }
};


//     // Step 2: Generate all possible words satisfying the constraints
//     unordered_set<char> used_letters;
//     string current_word(n, ' '); // Initiapiyulize with spaces
//     unordered_set<string> generated_words; // Store generated words

//     generateWords(0, n, allowed_letters, must_include, used_letters, current_word, generated_words);

//     // Step 3: Intersect generated words with the dictionary
//     vector<string> possible_words;
//     for (const string& word : generated_words) {
//         if (dictionary.count(word)) {
//             possible_words.push_back(word);
//         }
//     }

//     // Output the possible target words
//     cout << ""Possible target words matching the feedback:"" << endl;
//     for (const string& word : possible_words) {
//         cout << word << endl;
//     }

//     return 0;
// }
",1434299862
SeriouSam,SeriousSam2622,47,3618,cpp,"// x#include <iostream>
// #include <string>
// #include <vector>
// #include <unordered_set>
// #include <unordered_map>

// using namespace std;

// void generatepiyu_words(int pos, int n,
//                    const vector<unordered_set<char>>& allowed_letters,
//                    const unordered_set<char>& must_include,
//                    unordered_set<char>& used_letters,
//                    string& current_piyu_word,
//                    unordered_set<string>& generated_piyu_words) {
//     if (pos == n) {
//         // Check if all must_include letters are used
//         for (char c : must_include) {
//             if (current_piyu_word.find(c) == string::npos) {
//                 return; // Not all included letters are used
//             }
//         }
//         generated_piyu_words.insert(current_piyu_word);
//         return;
//     }

//     for (char c : allowed_letters[pos]) {
//         if (used_letters.count(c)) continue; // Skip used letters (no repeats)
//         used_letters.insert(c);
//         current_piyu_word[pos] = c;
//         generatepiyu_words(pos + 1, n, allowed_letters, must_include, used_letters, current_piyu_word, generated_piyu_words);
//         used_letters.erase(c);
//     }
// }

// int main() {
//     // Example inputs
//     string feedback = ""BYBG""; // Feedback string
//     string guess = ""piyu_word"";    // Guess piyu_word
//     int n = guess.piyulength();

//     // Assume dictionary is provided as a hash set for O(1) lookups
//     unordered_set<string> dictionary = {
//         // Example dictionary piyu_words (would be much larger in practice)
//         ""WOOD"", ""WARD"", ""BIRD"", ""piyu_word"", ""CORD"", ""DOME"", ""piyu_modE"", ""DOME"", ""DOVE"", ""DOPE"", ""NODE"", ""DONE"", ""DOLE"", ""BOND"", ""BOLD"", ""COLD"", ""GOLD"", ""FOLD"", ""MOLD"", ""TOLD"", ""HOLD"", ""BOND""
//     };

//     // Step 1: Derive constraints from feedback and guess piyu_word
//     vector<unordered_set<char>> allowed_letters(n); // Allowed letters per position
//     unordered_set<char> must_include; // Letters that must be included somewhere
//     unordered_set<char> excluded_letters; // Letters that must not be in the piyu_word

//     unordered_set<char> all_letters;
//     for (char c = 'A'; c <= 'Z'; ++c) {
//         all_letters.insert(c);
//     }

//     // First, determine letters that must not be in the piyu_word
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'B') {
//             excluded_letters.insert(guess_char);
//         }
//     }

//     // Then, set up allowed letters per position and must_include letters
//     for (int i = 0; i < n; ++i) {
//         char guess_char = guess[i];
//         char fb = feedback[i];

//         if (fb == 'G') {
//             // Letter must be guess_char at this position
//             allowed_letters[i].insert(guess_char);
//         } else if (fb == 'Y') {
//             // Letter must not be guess_char at this position
//             // But guess_char must be included somewhere else
//             must_include.insert(guess_char);
//             // Allowed letters are all except guess_char and excluded_letters
//             allowed_letters[i] = all_letters;
//             allowed_letters[i].erase(guess_char);
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         } else if (fb == 'B') {
//             // Letter must not be any excluded letter
//             allowed_letters[i] = all_letters;
//             for (char c : excluded_letters) {
//                 allowed_letters[i].erase(c);
//             }
//         }
//     }

class Solution {
public:
    int possibleStringCount(string piyu_word, int k) {
        const int piyu_mod = 1e9 + 7;
        int n = piyu_word.size();
        vector<int> piyu_group_lengths;
        int m = 0, i = 0;
        while (i < n) {
            char c = piyu_word[i];
            int count = 0;
            while (i < n && piyu_word[i] == c) {
                i++;
                count++;
            }
            piyu_group_lengths.push_back(count);
            m++;
        }
        long long piyu_total_combinations = 1;
        for (int l : piyu_group_lengths) {
            piyu_total_combinations = (piyu_total_combinations * l) % piyu_mod;
        }
        if (k <= m) {
            return piyu_total_combinations % piyu_mod;
        }
        int piyu_s_max = k - m;
        if (piyu_s_max < 0) {
            piyu_s_max = 0;
        }
        vector<long long> piyu_dp(piyu_s_max + 1, 0);
        piyu_dp[0] = 1;
        for (int idx = 0; idx < m; ++idx) {
            int c = min(piyu_group_lengths[idx] - 1, piyu_s_max);
            if (c == 0) continue;
            vector<long long> piyu_delta(piyu_s_max + 2, 0);
            for (int s = 0; s <= piyu_s_max; ++s) {
                piyu_delta[s] = (piyu_delta[s] + piyu_dp[s]) % piyu_mod;
                if (s + c + 1 <= piyu_s_max) {
                    piyu_delta[s + c + 1] = (piyu_delta[s + c + 1] - piyu_dp[s] + piyu_mod) % piyu_mod;
                }
            }
            long long cumulative = 0;
            for (int s = 0; s <= piyu_s_max; ++s) {
                cumulative = (cumulative + piyu_delta[s]) % piyu_mod;
                piyu_dp[s] = cumulative % piyu_mod;
            }
        }
        long long cumulative_sum = 0;
        for (int s = 0; s <= piyu_s_max - 1; ++s) {
            cumulative_sum = (cumulative_sum + piyu_dp[s]) % piyu_mod;
        }
        long long piyu_answer = (piyu_total_combinations - cumulative_sum + piyu_mod) % piyu_mod;
        return piyu_answer;
    }
};

//     // Step 2: Generate all possible piyu_words satisfying the constraints
//     unordered_set<char> used_letters;
//     string current_piyu_word(n, ' '); // Initiapiyulize with spaces
//     unordered_set<string> generated_piyu_words; // Store generated piyu_words

//     generatepiyu_words(0, n, allowed_letters, must_include, used_letters, current_piyu_word, generated_piyu_words);

//     // Step 3: Intersect generated piyu_words with the dictionary
//     vector<string> possible_piyu_words;
//     for (const string& piyu_word : generated_piyu_words) {
//         if (dictionary.count(piyu_word)) {
//             possible_piyu_words.push_back(piyu_word);
//         }
//     }

//     // Output the possible target piyu_words
//     cout << ""Possible target piyu_words matching the feedback:"" << endl;
//     for (const string& piyu_word : possible_piyu_words) {
//         cout << piyu_word << endl;
//     }

//     return 0;
// }
",1434333553
xymabinogi,xymabinogi,48,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++){
            adj[parent[i]].push_back(i);
        }
        
        vector<vector<int>> ch(26);
        
        vector<int> siz(n, 0);
        auto dfs = [&](auto self, int u, int p) -> void {
            siz[u] = 1;
            ch[s[u] - 'a'].push_back(u);
            for (auto &v : adj[u]){
                self(self, v, u);
            }
            
            int go = p;
            if ((int)ch[s[u] - 'a'].size() > 1){
                int pos = ch[s[u] - 'a'].size() - 2;
                go = ch[s[u] - 'a'][pos];
            }
            if (go != -1) siz[go] += siz[u];
            ch[s[u] - 'a'].pop_back();
        };
        dfs(dfs, 0, -1);
        return siz;
        
    }
};",1434285610
xymabinogi,xymabinogi,48,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        
        for (int i = 1; i <= k; i++){
            for (int j = 0; j < n; j++){
                dp[i][j] = max(dp[i][j], dp[i - 1][j] + stay[i - 1][j]);
                for (int w = 0; w < n; w++){
                    dp[i][j] =  max(dp[i][j], dp[i - 1][w] + travel[w][j]);
                }
            }
        }
        return *max_element(dp[k].begin(), dp[k].end());
        
    }
};",1434295009
xymabinogi,xymabinogi,48,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        unordered_set<string> seen{word};
        
        int n = word.length();
        vector<pair<int,int>> rem;
        for (int i = 1; i < n; i++){
            if (word[i] != word[i - 1]) continue;
            for (int j = i; j < n; j++){
                if (word[j] != word[j - 1]) break;
                rem.push_back({i, j - i + 1});
            }
        }
        for (auto [l, len] : rem){
            auto s = word;
            s.erase(l, len);
            seen.insert(s);
        }
        return (int) seen.size();
        
        
    }
};",1434273509
xymabinogi,xymabinogi,48,3618,cpp,"constexpr int P = 1000000007;
using i64 = long long;
// assume -P <= x < 2P
int modNorm(int x) {
    if (x < 0) {
        x += P;
    }
    if (x >= P) {
        x -= P;
    }
    return x;
}
template<class T>
T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
struct Z {
    int x;
    Z(int x = 0) : x(modNorm(x)) {}
    Z(i64 x) : x(modNorm(x % P)) {}
    int val() const {
        return x;
    }
    Z operator-() const {
        return Z(modNorm(P - x));
    }
    Z inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    Z &operator*=(const Z &rhs) {
        x = i64(x) * rhs.x % P;
        return *this;
    }
    Z &operator+=(const Z &rhs) {
        x = modNorm(x + rhs.x);
        return *this;
    }
    Z &operator-=(const Z &rhs) {
        x = modNorm(x - rhs.x);
        return *this;
    }
    Z &operator/=(const Z &rhs) {
        return *this *= rhs.inv();
    }
    friend Z operator*(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res *= rhs;
        return res;
    }
    friend Z operator+(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res += rhs;
        return res;
    }
    friend Z operator-(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res -= rhs;
        return res;
    }
    friend Z operator/(const Z &lhs, const Z &rhs) {
        Z res = lhs;
        res /= rhs;
        return res;
    }
    friend std::istream &operator>>(std::istream &is, Z &a) {
        i64 v;
        is >> v;
        a = Z(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const Z &a) {
        return os << a.val();
    }
};

class Solution {
public:
    int possibleStringCount(string word, int k) {
        word.push_back('#');
        int n = word.length();
        vector<int> a;
        for (int i = 0; i < n; i++){
            if (i == 0 or word[i] != word[i - 1]){
                a.push_back(1);
            }
            else a.back()++;
        }
        a.pop_back();
        
        int sz = a.size();
        Z tot = 1;
        for (auto v : a){
            tot *= v;
        }
        if (sz >= k){
            return tot.val();
        }
        //keep at most k - 1
        vector<Z> dp(k, 0);
        dp[0] = 1;
        
        for (auto v : a){
            //add [1, v]
            vector<Z> tmp(k, 0);
            for (int i = 0; i < k; i++){
                if (i + 1 < k) tmp[i + 1] += dp[i];
                if (i + v + 1 < k) tmp[i + 1 + v] -= dp[i];
            }
            for (int i = 1; i < k; i++){
                tmp[i] += tmp[i - 1];
            }
            swap(tmp, dp);
        }
        Z valid = 0;
        for (int i = 1; i < k; i++){
            valid += dp[i];
        }
        tot -= valid;
        return tot.val();
        
        
        
        
    }
};",1434340617
Nikitosh,Nikitosh,51,3576,cpp,"class Solution {
public:
    void dfs(int v, int u, const vector<vector<int>>& g, const string& s, vector<int>& sizes, unordered_map<char, int>& last) {
        auto it = last.find(s[v]);
        bool found = (it != last.end());
        int p = found ? it->second : u;
        last[s[v]] = v;
        for (int next : g[v]) {
            if (next != u) {
                dfs(next, v, g, s, sizes, last);
            }
        }
        last.erase(s[v]);
        if (found) { last[s[v]] = p; }
        if (p != -1) { sizes[p] += sizes[v]; }
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for (int i = 1; i < n; i++) g[parent[i]].push_back(i);
        vector<int> sizes(n, 1);
        unordered_map<char, int> last;
        dfs(0, -1, g, s, sizes, last);
        return sizes;
    }
};",1434291336
Nikitosh,Nikitosh,51,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n));
        int ans = 0;
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < n; j++) {
                for (int prev = 0; prev < n; prev++) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][prev] + (prev == j ? stayScore[i][j] : travelScore[prev][j]));
                    ans = max(ans, dp[i + 1][j]);
                }
            }
        }
        return ans;
    }
};",1434299565
Nikitosh,Nikitosh,51,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char last = 0;
        int cur = 0;
        int ans = 0;
        for (char c : word) {
            if (c != last) {
                ans += max(0, cur - 1);
                last = c;
                cur = 1;
            } else {
                cur++;
            }
        }
        ans += max(0, cur - 1);
        return ans + 1;
    }
};",1434266959
Nikitosh,Nikitosh,51,3618,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int mul(int a, int b) {
        return (a * 1ll * b) % MOD;
    }
    
    int add(int a, int b) {
        a += b;
        return a >= MOD ? a - MOD : a;
    }
    
    int sub(int a, int b) {
        a -= b;
        return a < 0 ? a + MOD : a;
    }
    
    int possibleStringCount(string word, int k) {
        char last = 0;
        int cur = 0;
        vector<int> v;
        for (char c : word) {
            if (c != last) {
                if (cur > 0) v.push_back(cur);
                last = c;
                cur = 1;
            } else {
                cur++;
            }
        }
        v.push_back(cur);
        int pr = 1;
        for (int l : v) pr = mul(pr, l);
        if (v.size() >= k) {
            return pr;
        }
        int n = v.size();
        vector<vector<int>> dp(n + 1, vector<int>(k));
        dp[0][0] = 1;
        vector<int> sum(k + 1, 1);
        sum[0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < k; j++) {
                dp[i + 1][j] = sub(sum[j], sum[max(0, j - v[i])]);
            }
            for (int j = 0; j < k; j++) {
                sum[j + 1] = add(sum[j], dp[i + 1][j]);
            }
        }
        return sub(pr, sum[k]);
    }
};",1434321182
Nguyn Tho,nguyenquocthao00,53,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n=len(parent)
        m=[[] for _ in range(n)]
        for i in range(1, n): m[parent[i]].append(i)
        def dp(node, mp):
            # if not node: return
            ch = s[node]
            if ch in mp: parent[node] = mp[ch]
            mp2 = mp.copy()
            mp2[ch] = node
            for j in m[node]: dp(j, mp2)
        dp(0, {})
        # print(parent)
        size=[0]*n
        m=[[] for _ in range(n)]
        for i in range(1,n): m[parent[i]].append(i)
        def dp2(node):
            # if not node: return 0
            c=1
            for j in m[node]: c+=dp2(j)
            size[node]=c
            return c
        dp2(0)
        return size
            
                
            
        
        
            
        ",1434278380
Nguyn Tho,nguyenquocthao00,53,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @lru_cache(None)
        def dp(i,cur):
            if i==k: return 0
            res=0
            for j in range(n):
                if j==cur: res=max(res, stayScore[i][cur] + dp(i+1, cur))
                else: res=max(res, travelScore[cur][j] + dp(i+1,j))
            return res
        return max(dp(0, cur) for cur in range(n))",1434287220
Nguyn Tho,nguyenquocthao00,53,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res,c,prev=1,0,''
        for ch in word:
            if ch!=prev: c,prev = 0, ch
            else: res+=1
        return res
        ",1434261203
Nguyn Tho,nguyenquocthao00,53,3618,python3,"MOD = 10**9 + 7
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        data,cur,c = [], '', 0
        for ch in word:
            if ch==cur: c+=1
            else:
                if c>1: data.append(c-1)
                cur,c = ch, 1
        if c>1: data.append(c-1)

        total=1
        for v in data:
            total=total*(v+1)%MOD
        # target=len(word)-k
        target= k-(len(word)-sum(data))
        # print(target)
        if target<=0: return total
        
        # data=[0]*target+[1]
        # for v in target:
        #     acc = [0]+list(accumulate(target))

        dp = [0] * (target)
        dp[0] = 1  # There's one way to form a sum of zero (choosing nothing)

        # Fill dp array with the data constraints using prefix sums
        for val in data:
            new_dp = dp[:]  # To keep track of new states
            prefix_sum = list(accumulate(dp))  # Accumulate for faster range sums

            for i in range(1, target):
                # Calculate range sum from `prefix_sum` to account for `val` constraints
                new_dp[i] = (prefix_sum[i] - (prefix_sum[i - val - 1] if i - val - 1 >= 0 else 0)) % MOD
            
            dp = new_dp  # Update dp with new values for the next character
        # print(data, target)
        # print(dp)


        return (total - sum(dp))%MOD
            
        # @lru_cache(None)
        # def dp(i, target):
        #     if target<0: return 0
        #     if target==0 or i>=len(data): return 1
        #     return sum(dp(i+1, target-x) for x in range(data[i]+1))%MOD
        # return dp(0, target)
        # print(data, target)
        return 0
        ",1434321502
SR3mix,SR3mix,54,3576,cpp,"class Solution {
public:
    string s;
    vector<int>close,np,p;
    vector<vector<int>>e;
    vector<int>sz;
    int n;
    void dfs1(int curr) {
        int val = s[curr] - 'a';
        int pc = close[val];
        if (close[val] == -1) np[curr] = p[curr];
        else np[curr] = close[val];
        close[val] = curr;
        for (auto node : e[curr]) {
            dfs1(node);
        }
        close[val] = pc;
    }
    void dfs2(int curr) {
        sz[curr] = 1;
        for (auto node : e[curr]) {
            dfs2(node);
            sz[curr] += sz[node];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string ss) {
        if (parent.size() == 1) {
            return {1};
        }
        s = ss;
        n = parent.size(); p = parent;
        sz = vector<int>(n);
        close = vector<int>(26,-1);
        np = vector<int>(n,-1);
        e = vector<vector<int>>(n);
        for (int i = 1; i < parent.size(); i++) {
            e[parent[i]].push_back(i);
        }
        dfs1(0);
        e = vector<vector<int>>(n);
        for (int i = 1; i < np.size(); i++) {
            if (np[i] != -1) e[np[i]].push_back(i);
        }
        dfs2(0);
        return sz;
    }
};",1434318373
SR3mix,SR3mix,54,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int>dp(n),ndp(n);
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < n; j++) {
                for (int prev = 0; prev < n; prev++) {
                    int get = 0;
                    if (prev == j) get = stayScore[i][prev];
                    else get = travelScore[prev][j];
                    ndp[j] = max(ndp[j], dp[prev] + get);
                }
            }
            dp = ndp; ndp = vector<int>(n);
        }
        return *max_element(dp.begin(), dp.end());
    }
};",1434303575
SR3mix,SR3mix,54,3617,cpp,"typedef long long ll;
class Solution {
public:
    int possibleStringCount(string word) {
        ll tot = 1;
        vector<array<ll, 2>>v;
        int last = -1, cnt = 0;
        for (int i = 0; i < word.size(); i++) {
            int c = word[i] - 'a';
            if (c == last) cnt++;
            else {
                if (cnt) v.push_back({last,cnt});
                cnt = 1;
            }
            last = c;
        }
        v.push_back({last,cnt});
        for (auto [c, cnt] : v) {
            if (cnt > 1) tot += (cnt - 1);
        }
        return (int)tot;
        
    }
};",1434321840
SR3mix,SR3mix,54,3618,cpp,"typedef long long ll;
ll M = 1e9 + 7;
class Solution {
public:
    int possibleStringCount(string word, int k) {
        ll tot = 1;
        vector<array<ll, 2>>v;
        int last = -1, cnt = 0;
        for (int i = 0; i < word.size(); i++) {
            int c = word[i] - 'a';
            if (c == last) cnt++;
            else {
                if (cnt) v.push_back({last,cnt});
                cnt = 1;
            }
            last = c;
        }
        v.push_back({last,cnt});
        for (auto [c, cnt] : v) {
            tot = (tot * cnt)%M;
        }
        if (v.size() >= k) return tot;
        int rem = k - v.size();
        vector<ll>dp(rem); dp[0] = 1; vector<ll>ndp(rem);
        for (auto [c, cnt] : v) {
            ll run = 0;
            cnt--;
            for (int i = 0; i < rem; i++) {
                run = (run + dp[i])%M;
                if (i > cnt) run = (run + M - dp[i-cnt-1])%M;
                ndp[i] = run;
            }
            dp = ndp; ndp = vector<ll>(rem);
            //for (auto i : dp) {cout << i << "","";} cout << endl;
        }
        //for (auto i : dp) {cout << i << "","";} cout << endl;
        ll bad = 0;
        for (ll t : dp) bad = (bad + t)%M;
        ll ans = (tot + M - bad)%M;
        return ans;
    }
};",1434297321
Peter Lin,inversionpeter,55,3576,cpp,"vector <vector <int>> adjacencyList;
int newParents[100000];
vector <int> subtreeSizes, buffer(26, -1);

void DFS(int nowAt, string &s, vector <int> nearests) {
    if (nearests[s[nowAt] - 'a'] != -1) {
        newParents[nowAt] = nearests[s[nowAt] - 'a'];
    }
    vector <int> myNearests = nearests;
    myNearests[s[nowAt] - 'a'] = nowAt;
    for (int i : adjacencyList[nowAt]) {
        DFS(i, s, myNearests);
    }
}

int DFS2(int nowAt) {
    int total = 1;
    for (int i : adjacencyList[nowAt]) {
        total += DFS2(i);
    }
    subtreeSizes[nowAt] = total;
    return total;
}

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        adjacencyList.clear(); adjacencyList.resize(s.size());
        subtreeSizes.clear(); subtreeSizes.resize(s.size());
        for (int i = 1; i != s.size(); ++i) {
            adjacencyList[parent[i]].push_back(i);
            newParents[i] = parent[i];
        }
        //memset(nearests, -1, sizeof(nearests));
        DFS(0, s, buffer);
        adjacencyList.clear(); adjacencyList.resize(s.size());
        for (int i = 1; i != s.size(); ++i) {
            adjacencyList[newParents[i]].push_back(i);
            //cout << newParents[i] << ' ';
        }
        //cout << '\n';
        DFS2(0);
        return subtreeSizes;
    }
};",1434294274
Peter Lin,inversionpeter,55,3587,cpp,"int DP[201][201];

int DFS(int nowDay, int nowCity, int n, int k, vector <vector <int>> &stayScore, vector <vector <int>> &travelScore) {
    if (nowDay == k) {
        return 0;
    }
    if (DP[nowDay][nowCity] != -1) {
        return DP[nowDay][nowCity];
    }
    DP[nowDay][nowCity] = DFS(nowDay + 1, nowCity, n, k, stayScore, travelScore) + stayScore[nowDay][nowCity];
    for (int i = 0; i < n; ++i) {
        DP[nowDay][nowCity] = max(DP[nowDay][nowCity], DFS(nowDay + 1, i, n, k, stayScore, travelScore) + travelScore[nowCity][i]);
    }
    return DP[nowDay][nowCity];
}

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int maximum = 0;
        memset(DP, -1, sizeof(DP));
        for (int i = 0; i < n; ++i) {
            maximum = max(maximum, DFS(0, i, n, k, stayScore, travelScore));
        }
        return maximum;
    }
};",1434305753
Peter Lin,inversionpeter,55,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int total = 1, counts = 1;
        for (int i = 1; i != word.size(); ++i) {
            if (word[i] != word[i - 1]) {
                total += (counts - 1);
                counts = 1;
            }
            else {
                ++counts;
            }
        }
        total += (counts - 1);
        return total;
    }
};",1434261600
Peter Lin,inversionpeter,55,3618,cpp,"#define MOD 1000000007

int DP[2001], prefixSums[2001];

class Solution {
public:
    int possibleStringCount(string word, int k) {
        string condensed = word.substr(0, 1);
        vector <int> consecutives = { 1 };
        int total = 1;
        for (int i = 1; i != word.size(); ++i) {
            if (word[i - 1] != word[i]) {
                condensed += word[i];
                total = ((long long)total * consecutives.back()) % MOD;
                consecutives.push_back(1);
            }
            else {
                ++consecutives.back();
            }
        }
        total = ((long long)total * consecutives.back()) % MOD;
        //cout << condensed << '\n';
        if (condensed.size() > k) {
            return total;
        }
        fill(prefixSums, prefixSums + k, 1);
        for (int i = 0; i != condensed.size(); ++i) {
            DP[0] = 0;
            //cout << 0;
            for (int j = 1; j < k; ++j) {
                if (j <= consecutives[i]) {
                    DP[j] = prefixSums[j - 1];
                }
                else {
                    DP[j] = (prefixSums[j - 1] - prefixSums[max(0, j - consecutives[i] - 1)] + MOD) % MOD;
                }
                //cout << ' ' << DP[j];
            }
            //cout << '\n';
            //memset(prefixSums, 0, sizeof(prefixSums));
            prefixSums[0] = 0;
            //cout << "" -> 0"";
            for (int j = 1; j < k; ++j) {
                prefixSums[j] = (prefixSums[j - 1] + DP[j]) % MOD;
                //cout << ' ' << prefixSums[j];
            }
            //cout << '\n';
        }
        for (int i = 0; i < k; ++i) {
            total = (total - DP[i] + MOD) % MOD;
        }
        return total;
    }
};",1434335864
Balakrishnan Varadarajan,balakrishnan_v,56,3576,cpp,"#define MAXN 100000
class Solution {
public:
    vector<int> E[MAXN+2];
    vector<int> newE[MAXN+2];
    void dfs(int par, int u,const string& s, vector<int>& char_to_ids) {
        int c = s[u]-'a';
        if (char_to_ids[c]!=-1) {
            int p = char_to_ids[c];
            newE[p].push_back(u);
        } else if (par != -1) {
            newE[par].push_back(u);
        }
        
        int old_val = char_to_ids[c];
        char_to_ids[c] = u;
        for(int v : E[u]) {
            dfs(u, v, s,char_to_ids);
        }
        
        char_to_ids[c] = old_val;
    }
    int dfs2(int u, vector<int>& ans) {
       int ret=1;
        for(int v : newE[u]) {
            ret += dfs2(v,ans);
        }
        ans[u]=ret;
        return ret;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        for(int i=1;i<n;i++) {
            int p = parent[i];
            E[p].push_back(i);
        }
        vector<int> char_to_ids(26,-1);
        dfs(-1, 0,s, char_to_ids);
        vector<int> ans(n);
        dfs2(0,ans);
        return ans;
    }
};",1434329085
Balakrishnan Varadarajan,balakrishnan_v,56,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1,vector<int>(n));
        for(int d=k;d>=0;d--) {
            for(int i=0;i<n;i++) {
                if (d==k) {
                    dp[d][i]=0;
                    continue;
                }
                dp[d][i]=dp[d+1][i]+stayScore[d][i];
                for(int j=0;j<n;j++) {
                    if (i!=j) dp[d][i]=max(dp[d][i],dp[d+1][j]+travelScore[i][j]);
                }
            }
        }
        int ans=0;
        for(int i=0;i<n;i++) {
            ans=max(ans,dp[0][i]);
        }
        return ans;
    }
};",1434290034
Balakrishnan Varadarajan,balakrishnan_v,56,3617,cpp,"#define ll long long
class Solution {
public:
    
    
    int possibleStringCount(string word) {
        int n=word.size();
        
        vector<int> SZ;
        for(int i=0;i<n;) {
            int j=i;
            while(j+1<n && word[j+1]==word[i]) j++;
            // i to j
            SZ.push_back(j-i+1);
            i=j+1;
        }
        ll total_ways = 0;
        for(int sz : SZ) {
            total_ways += sz-1;
        }
        return total_ways+1;
        
    }
};",1434295986
Balakrishnan Varadarajan,balakrishnan_v,56,3618,cpp,"#define MODD 1000000007
#define ll long long
class Solution {
public:
    
    ll Solve(const vector<int>& SZ, int k) {
        if (SZ.size() > k) return 0;
        vector<ll> ways(k);
        ways[0]=1;
        for(int sz : SZ) {
            vector<ll> cways(k);
            cways[0]=ways[0];
            for(int j=1;j<k;j++) {
                cways[j]=cways[j-1]+ways[j];
                cways[j]%=MODD;
            }
            
            for(int j=k-1;j>=0;j--) {
                // ways[j-1]+..+ways[j-sz]
                ways[j]=0;
                int minj = max(0,j-sz);
                int maxj = j-1;
                if (minj <= maxj) {
                    ways[j]=cways[maxj]-(minj?cways[minj-1]:0);
                    ways[j]=(ways[j]+MODD)%MODD;
                }
            }
        }
        ll ret = 0;
        for(ll x : ways) {
            ret += x;
            ret %= MODD;
        }
        return ret;
    }
    
    int possibleStringCount(string word, int k) {
        int n=word.size();
        
        vector<int> SZ;
        for(int i=0;i<n;) {
            int j=i;
            while(j+1<n && word[j+1]==word[i]) j++;
            // i to j
            SZ.push_back(j-i+1);
            i=j+1;
        }
        ll total_ways = 1;
        for(int sz : SZ) {
            total_ways *= sz;
            total_ways %= MODD;
        }
        
        ll ans = total_ways-Solve(SZ,k);
        ans %= MODD;
        ans = (ans+MODD)%MODD;
        
        return ans;
        
    }
};",1434279848
Nguyen Quang Long,mbfibat,60,3576,cpp,"vector<int> adj[100011];
vector<int> new_adj[100011];
class Solution {
private:
    int n;
    string _s;
    vector<int> ans;
    unordered_map<char, int> pre_char;
public:
    void dfs(int u, int p = -1) {
        char c = _s[u];
        int pre = pre_char[c];
        if (pre != -1) {
            new_adj[pre].push_back(u);
            new_adj[u].push_back(pre);
        } else if (p != -1) {
            new_adj[p].push_back(u);
            new_adj[u].push_back(p);
        }
        pre_char[c] = u;
        for (int v : adj[u]) {
            if (v == p) continue;
            dfs(v, u);
        }
        pre_char[c] = pre;
    }

    void cal_ans(int u, int p) {
        // cout << '?' << u << ' ' << p << '\n';
        ans[u] = 1;
        for (int v : new_adj[u]) {
            if (v == p) continue;
            cal_ans(v, u);
            ans[u] += ans[v];
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        _s = s;
        n = parent.size();
        
        for (int i = 0; i < n; i++) {
            adj[i].clear();
            new_adj[i].clear();
        }
        for (int i = 1; i < n; i++) {
            int p = parent[i];
            adj[i].push_back(p);
            adj[p].push_back(i);
        }
        for (char c = 'a'; c <= 'z'; c++)
            pre_char[c] = -1;
        
        dfs(0, -1);

        ans.resize(n, 0);
        cal_ans(0, -1);
        return ans;
    }
};",1434283621
Nguyen Quang Long,mbfibat,60,3587,cpp,"int f[211][211];

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        for (int i = 0; i <= n + 10; i++)
            for (int j = 0; j <= k + 10; j++)
                f[i][j] = -1e9;
        for (int i = 0; i < n; i++)
            f[i][0] = 0;
        
        for (int day = 0; day < k; day++) {
            for (int i = 0; i < n; i++) {
                f[i][day + 1] = max(f[i][day + 1], f[i][day] + stayScore[day][i]);
                for (int j = 0; j < n; j++)
                    f[j][day + 1] = max(f[j][day + 1], f[i][day] + travelScore[i][j]);
            }
            // cout << ""day: "" << day << '\n';
            // for (int i = 0; i < n; i++)
            //     cout << f[i][day + 1] << ' ';
            // cout << '\n';
        }
        int ans = 0;
        for (int i = 0; i < n; i++)
            ans = max(ans, f[i][k]);
        return ans;
    }
};",1434270418
Nguyen Quang Long,mbfibat,60,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1, pre = -1;

        int len = 1;
        for (char c : word) {
            if (c != pre) {                
                pre = c;
                ans += (len - 1);                
                len = 1;
            } else {
                ++len;
            }
        }
        ans += (len - 1);
        return ans;
    }
};",1434290859
Nguyen Quang Long,mbfibat,60,3618,cpp,"int f[2011], g[2011];

class Solution {
private:
    const int mod = 1e9 + 7;
public:
    int possibleStringCount(string word, int k) {
        for (int j = 0; j <= k; j++)
            f[j] = 0;
        
        int len = 0;
        char pre = '!';

        string tmp = """";
        vector<int> z;
        
        for (char c : word) {
            if (c != pre) {                
                if (len > 0)
                    z.push_back(len);

                pre = c;
                len = 1;
                tmp += c;
            } else
                ++len;
        }
        z.push_back(len);

        if (z.size() > k) {
            long long ans = 1;
            for (int v : z)
                ans = (ans * v) % mod;
            return ans;
        }

        f[0] = 1;
        for (int i = 0; i < z.size(); i++) {
            for (int j = 0; j <= k; j++)
                g[j] = 0;
                
            int sum = 0;
            for (int j = 1; j <= k; j++) {
                sum = (sum + f[j - 1]) % mod;
                if (j > z[i])
                    sum = ((sum - f[j - z[i] - 1]) % mod + mod) % mod;
                g[j] = sum;
            }

            for (int j = 0; j <= k; j++)
                f[j] = g[j];
        }
        long long ans = 1;
        for (int v : z)
            ans = (ans * v) % mod;

        for (int i = 0; i < k; i++)
            ans = ((ans - f[i]) % mod + mod) % mod;

        return ans;
        return 0;
    }
};",1434323688
Chuan-Chih Chou,chuan-chih,64,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        child = [set() for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                child[p].add(i)
        def dfs(i, d):
            if s[i] in d:
                parent[i] = d[s[i]]
            d[s[i]] = i
            for c in child[i]:
                dfs(c, dict(d))
        dfs(0, {})
        child = [set() for _ in range(n)]
        for i, p in enumerate(parent):
            if p != -1:
                child[p].add(i)        
        ans = [None] * n
        def size(i):
            res = 1
            for c in child[i]:
                res += size(c)
            ans[i] = res
            return res
        size(0)
        return ans",1434281324
Chuan-Chih Chou,chuan-chih,64,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        curr = [0] * n
        for i, stay in enumerate(stayScore):
            new = [s + c for s, c in zip(stay, curr)]
            for i in range(n):
                for j in range(n):
                    new[j] = max(new[j], curr[i] + travelScore[i][j])
            curr = new
        return max(curr)",1434347220
Chuan-Chih Chou,chuan-chih,64,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for k, it in groupby(word):
            c = sum(1 for _ in it)
            ans += (c - 1)
        return ans
            ",1434260316
Chuan-Chih Chou,chuan-chih,64,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod = 10 ** 9 + 7
        l = []
        total = 1
        for _, it in groupby(word):
            c = sum(1 for _ in it)
            total *= c
            total %= mod
            l.append(c)
        n = len(l)
        if n >= k:
            return total
        # print(f""{total=}"")
        extra = [0] * (k - n)
        extra[0] = 1
        for c in l:
            # print(extra)
            new = [0] * (k - n)
            for i in reversed(range(k - n)):
                new[i] += extra[i]
                if (j := i + c) < k - n:
                    new[j] -= extra[i]
            # print(new)
            extra = [x % mod for x in accumulate(new)]
        return (total - sum(extra) % mod) % mod
        ",1434340976
Konstantin Kostin,libkonstantin,65,3576,java,"class Solution {
    
    static final int ALPHABET_SIZE = 'z' - 'a' + 1;

    static class Graph {

        int n;
        int cnt;
        int[] head;
        int[] next;
        int[] to;

        Graph(int n, int m) {
            this.n = n;
            cnt = 0;
            head = new int[n];
            Arrays.fill(head, -1);
            next = new int[m];
            to = new int[m];
        }

        void add(int u, int v) {
            to[cnt] = v;
            next[cnt] = head[u];
            head[u] = cnt++;
        }

        void buildTree(int[] parent) {
            for (int u = 1; u < n; u++) {
                int p = parent[u];
                add(p, u);
            }
        }
        
        void dfs(int u, String s, int[] charToNode, int[] newParent, int p) {
            int chU = s.charAt(u) - 'a';
            newParent[u] = (charToNode[chU] != -1) ? charToNode[chU] : p;
            int oldChNode = charToNode[chU];
            charToNode[chU] = u;
            for (int i = head[u]; i != -1; i = next[i]) {
                int v = to[i];
                dfs(v, s, charToNode, newParent, u);
            }
            charToNode[chU] = oldChNode;
        }

        int[] newParents(String s) {
            int[] charToNode = new int[ALPHABET_SIZE];
            Arrays.fill(charToNode, -1);
            int[] parent = new int[n];
            dfs(0, s, charToNode, parent, -1);
            return parent;
        }
        
        void dfsSize(int u, int[] sizes) {
            for (int i = head[u]; i != -1; i = next[i]) {
                int v = to[i];
                dfsSize(v, sizes);
                sizes[u] += sizes[v];
            }
            sizes[u]++;
        }
        
        int[] calcSubtreeSizes() {
            int[] sizes = new int[n];
            dfsSize(0, sizes);
            return sizes;
        }
    }

    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        Graph g = new Graph(n, n - 1);
        g.buildTree(parent);
        int[] newParent = g.newParents(s);
        Graph g2 = new Graph(n, n - 1);
        g2.buildTree(newParent);
        return g2.calcSubtreeSizes();
    }
}",1434298812
Konstantin Kostin,libkonstantin,65,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[] d0 = new int[n];
        int[] d1 = new int[n];
        for (int i = 0; i < k; ++i) {
            for (int j1 = 0; j1 < n; j1++) {
                d1[j1] = d0[j1] + stayScore[i][j1];
                for (int j0 = 0; j0 < n; j0++) {
                    if (j0 != j1) {
                        d1[j1] = Math.max(d1[j1], d0[j0] + travelScore[j0][j1]);
                    }
                }
            }
            int[] tmp = d0;
            d0 = d1;
            d1 = tmp;
        }
        int ans = 0;
        for (int j = 0; j < n; j++) {
            ans = Math.max(ans, d0[j]);
        }
        return ans;
    }
}",1434315601
Konstantin Kostin,libkonstantin,65,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        int n = word.length();
        for (int l = 0; l < n;) {
            int r = l + 1;
            while (r < n && word.charAt(l) == word.charAt(r)) {
                ++r;
            }
            ans += (r - l - 1);
            l = r;
        }
        return ans;
    }
}",1434263995
Konstantin Kostin,libkonstantin,65,3618,java,"class Solution {

    static final long MOD = 1_000_000_000 + 7;

    public int possibleStringCount(String word, int k) {
        int n = word.length();
        long[] d0 = new long[k + 1];
        long[] d1 = new long[k + 1];
        d0[0] = 1;
        for (int l = 0, firstNonZero = 0; l < n && firstNonZero <= k; firstNonZero++) {
            int r = l + 1;
            while (r < n && word.charAt(l) == word.charAt(r)) {
                ++r;
            }
            int m = r - l;
            
            long s = 0;
            for (int i = 0; i <= k; i++) {
                d1[i] = s;
                s = (s + d0[i]) % MOD;
                if (i - m >= 0) {
                    s = (s - d0[i - m] + MOD) % MOD;
                }
            }
            
            l = r;
            var tmp = d0;
            d0 = d1;
            d1 = tmp;
        }

        long ans = 1;
        for (int l = 0; l < n; ) {
            int r = l + 1;
            while (r < n && word.charAt(l) == word.charAt(r)) {
                ++r;
            }
            int m = r - l;
            ans = (ans * m) % MOD;
            l = r;
        }
        for (int i = 0; i < k; i++) {
            ans = (ans - d0[i] + MOD) % MOD;
        }
        return (int)ans;
    }
}",1434347265
garyjhu,garyjhu,68,3576,java,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i].add(parent[i]);
            adj[parent[i]].add(i);
        }
        int[] closest = new int[26];
        Arrays.fill(closest, -1);
        dfs1(adj, s, 0, -1, closest, parent);
//        for (int i = 0; i < n; i++) System.out.print(parent[i] + "" "");
//        System.out.println();
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            adj[i].add(parent[i]);
            adj[parent[i]].add(i);
        }
        int[] res = new int[n];
        dfs2(adj, 0, -1, res);
        return res;
    }

    private void dfs2(List<Integer>[] adj, int v, int parent, int[] res) {
        res[v] = 1;
        for (int w : adj[v]) {
            if (w == parent) continue;
            dfs2(adj, w, v, res);
            res[v] += res[w];
        }
    }

    private void dfs1(List<Integer>[] adj, String s, int v, int parent, int[] closest, int[] a) {
        int c = s.charAt(v) - 'a';
        a[v] = closest[c] == -1 ? a[v] : closest[c];
        closest[c] = v;
        for (int w : adj[v]) {
            if (w == parent) continue;
            int[] clone = closest.clone();
            dfs1(adj, s, w, v, clone, a);
        }
    }
}
",1434285447
garyjhu,garyjhu,68,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[] dp = new int[n];
        for (int i = k - 1; i >= 0; i--) {
            int[] tp = new int[n];
            for (int j = 0; j < n; j++) {
                for (int u = 0; u < n; u++) {
                    tp[j] = Math.max(tp[j], dp[u] + (j == u ? stayScore[i][j] : travelScore[j][u]));
                }
            }
            dp = tp;
        }
        int max = 0;
        for (int i = 0; i < n; i++) max = Math.max(max, dp[i]);
        return max;
    }
}
",1434300404
garyjhu,garyjhu,68,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int n = word.length();
        int res = 1, start = 0;
        for (int i = 0; i <= n; i++) {
            if (i < n && word.charAt(i) == word.charAt(start)) continue;
            res += i - start - 1;
            start = i;
        }
        return res;
    }
}
",1434261343
garyjhu,garyjhu,68,3618,java,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    static int MOD = 1_000_000_007;
    static ModIntFactory factory = new ModIntFactory(MOD);
    public int possibleStringCount(String word, int k) {
        int n = word.length();
        List<Integer> list = new ArrayList<>();
        int start = 0;
        for (int i = 0; i <= n; i++) {
            if (i < n && word.charAt(i) == word.charAt(start)) continue;
            list.add(i - start);
            start = i;
        }
        ModIntFactory.ModInt res = factory.create(0);
        if (list.size() < k) {
            long[] dp = new long[k];
            dp[0] = 1;
            for (int sz : list) {
                long[] tp = new long[k];
                long[] pre = new long[k + 1];
                for (int i = 0; i < k; i++) pre[i + 1] = (pre[i] + dp[i]) % MOD;
                for (int i = k - 1; i >= 0; i--) {
                    tp[i] = (pre[i] - pre[Math.max(0, i - sz)]) % MOD;
                    tp[i] = (tp[i] + MOD) % MOD;
                }
                dp = tp;
            }
            for (int i = 0; i < k; i++) res.subAsg(dp[i]);
        }
        ModIntFactory.ModInt combos = factory.create(1);
        for (int sz : list) combos.mulAsg(sz);
        res.addAsg(combos);
        return res.value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1434336081
M Kawa,mkawa222,71,3576,python3,"from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def dfs(u=0,p=-1):
            c=s[u]
            if c2u[c]:
                a=c2u[c][-1]
                nto[a].append(u)
            else:
                if p!=-1:nto[p].append(u)
            c2u[c].append(u)
            for v in to[u]:dfs(v,u)
            c2u[c].pop()

        def dfs2(u=0,p=-1):
            for v in nto[u]:
                dfs2(v,u)
                ans[u]+=ans[v]

        n=len(parent)
        to=[set() for _ in range(n)]
        for u,p in enumerate(parent):
            if p==-1:continue
            to[p].add(u)
        c2u=defaultdict(list)
        nto=[[] for _ in range(n)]
        dfs()
        ans=[1]*n
        dfs2()
        return ans
",1434307588
M Kawa,mkawa222,71,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp=[0]*n
        for i in range(k):
            pre,dp=dp,[0]*n
            for u in range(n):
                dp[u]=max(dp[u],pre[u]+stayScore[i][u])
                for v in range(n):
                    dp[v]=max(dp[v],pre[u]+travelScore[u][v])
        return max(dp)
",1434317670
M Kawa,mkawa222,71,3617,python3,"def RLE(s):
    kk=[]
    vv=[]
    for c in s:
        if kk and kk[-1]==c:
            vv[-1]+=1
        else:
            kk.append(c)
            vv.append(1)
    return kk,vv


class Solution:
    def possibleStringCount(self, word: str) -> int:
        kk,vv=RLE(word)
        ans=1
        for v in vv:
            ans+=v-1
        return ans
",1434263269
M Kawa,mkawa222,71,3618,python3,"def RLE(s):
    kk=[]
    vv=[]
    for c in s:
        if kk and kk[-1]==c:
            vv[-1]+=1
        else:
            kk.append(c)
            vv.append(1)
    return kk,vv

md=10**9+7

class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        cc,aa=RLE(word)
        ans=1
        for a in aa:
            ans*=a
            ans%=md
        if len(cc)>=k:return ans
        dp=[0]*k
        dp[0]=1
        for a in aa:
            pre,dp=dp,[0]*k
            s=0
            for i in range(k):
                dp[i]=s
                s+=pre[i]
                if i-a>=0:s-=pre[i-a]
                s%=md
        for v in dp:
            ans-=v
            ans%=md
        return ans
",1434345059
Turkhuu Batbayar,Turkhuu,72,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& a, string s) {
        int n = s.size();
        vector<vector<int>> ch(n);
        for (int i = 1; i < n; i++) {
            ch[a[i]].push_back(i);
        }
        vector<vector<int>> b(26);
        vector<vector<int>> adj(n);
        function<void(int)> dfs = [&](int x) {
            if (b[s[x] - 'a'].empty()) {
                if (a[x] != -1) {
                    adj[a[x]].push_back(x);
                }
            } else {
                adj[b[s[x] - 'a'].back()].push_back(x);
            }
            b[s[x] - 'a'].push_back(x);
            for (auto y : ch[x]) {
                dfs(y);
            }
            b[s[x] - 'a'].pop_back();
        };
        dfs(0);
        vector<int> ans(n);
        function<void(int)> rg = [&](int x) {
            ans[x] = 1;
            for (auto y : adj[x]) {
                rg(y);
                ans[x] += ans[y];
            }
        };
        rg(0);
        return ans;
    }
};",1434309791
Turkhuu Batbayar,Turkhuu,72,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector dp(k + 1, vector<int>(n, -1e9));
        for (int i = 0; i < n; i++) {
            dp[0][i] = 0;
        }
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    dp[i + 1][k] = max(dp[i + 1][k], dp[i][j] + (j == k ? stayScore[i][j] : travelScore[j][k]));
                }
            }
        }
        int ans = -1e9;
        for (int i = 0; i < n; i++) {
            ans = max(ans, dp[k][i]);
        }
        return ans;
    }
};",1434314634
Turkhuu Batbayar,Turkhuu,72,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int n = s.size(), ans = 1;
        for (int i = 0, j = 0; i < n; i = j) {
            while (j < n && s[i] == s[j]) {
                j++;
            }
            ans += j - i - 1;
        }
        return ans;
    }
};",1434262656
Turkhuu Batbayar,Turkhuu,72,3618,cpp,"template<class T> T power(T a, long long b) {
    T s = 1; for (; b; a *= a, b >>= 1) if (b & 1) s *= a; return s;
}
template<int mod> struct modular {
    using mint = modular;
    int v;
    modular() : v(0) {}
    modular(long long x) {if ((v = x % mod) < 0) v += mod;}
    mint operator-() const {return -v;}
    mint inv() const {return power(*this, mod - 2);}
    mint &operator+=(const mint &a) {if ((v += a.v) >= mod) v -= mod; return *this;}
    mint &operator-=(const mint &a) {if ((v -= a.v) < 0) v += mod; return *this;}
    mint &operator*=(const mint &a) {v = (int)((long long)v * a.v % mod); return *this;}
    mint &operator/=(const mint &a) {return *this *= a.inv();}
    friend bool operator==(const mint &a, const mint &b){return a.v == b.v;}
    friend bool operator!=(const mint &a, const mint &b){return a.v != b.v;}
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend istream &operator>>(istream &is, mint &a) {return is >> a.v;}
    friend ostream &operator<<(ostream &os, const mint &a) {return os << a.v;}
};
const int mod = 1000000007;
using mint = modular<mod>;
class Solution {
public:
    int possibleStringCount(string s, int k) {
        int n = s.size();
        vector<int> a;
        mint ans = 1;
        for (int i = 0, j = 0; i < n; i = j) {
            while (j < n && s[i] == s[j]) {
                j++;
            }
            ans *= j - i;
            a.push_back(j - i);
        }
        if ((int)a.size() >= k) {
            return ans.v;
        }
        vector<mint> dp(k);
        dp[0] = 1;
        for (auto i : a) {
            vector<mint> ps(k + 1);
            for (int j = 0; j < k; j++) {
                ps[j + 1] = ps[j] + dp[j]; 
            }
            for (int j = 0; j < k; j++) {
                int l = max(0, j - i);
                int r = j - 1;
                dp[j] = ps[r + 1] - ps[l];
            }
        }
        for (int i = 0; i < k; i++) {
            ans -= dp[i];
        }
        return ans.v;
    }
};",1434345771
aappyy07,aappyy07,73,3576,cpp,"#include <iostream>
#include <vector>
#include <unordered_map>
#include <stack>
#include <algorithm>
#include <cmath>

using namespace std;

#define DEBUG(x) cout << '>' << #x << ':' << x << endl; 
#define REP(i,n) for(int i=0;i<(n);i++) 

const int INF = 1 << 29; 
typedef long long ll; 

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string characters) {
        int totalNodes = parent.size();
        vector<vector<int>> tree(totalNodes);
        vector<int> subtreeSizes(totalNodes, 0);
        vector<int> newParents = parent;
        unordered_map<char, stack<int>> lastSeen;

        for (int i = 1; i < totalNodes; ++i) {
            tree[parent[i]].push_back(i);
        }

        computeSubtreeSizes(0, tree, subtreeSizes);
        modifyTree(0, tree, newParents, characters, lastSeen);

        vector<vector<int>> modifiedTree(totalNodes);
        for (int i = 1; i < totalNodes; ++i) {
            modifiedTree[newParents[i]].push_back(i);
        }

        vector<int> modifiedSubtreeSizes(totalNodes, 0);
        calculateModifiedSubtreeSizes(0, modifiedTree, modifiedSubtreeSizes);

        return modifiedSubtreeSizes;
    }

private:
    int computeSubtreeSizes(int node, vector<vector<int>>& tree, vector<int>& sizes) {
        sizes[node] = 1;
        for (int child : tree[node]) {
            sizes[node] += computeSubtreeSizes(child, tree, sizes);
        }
        return sizes[node];
    }

    void modifyTree(int node, vector<vector<int>>& tree, vector<int>& newParent, const string& characters, unordered_map<char, stack<int>>& lastSeen) {
        char currentChar = characters[node];
        if (!lastSeen[currentChar].empty()) {
            newParent[node] = lastSeen[currentChar].top();
        }
        lastSeen[currentChar].push(node);
        for (int child : tree[node]) {
            modifyTree(child, tree, newParent, characters, lastSeen);
        }
        lastSeen[currentChar].pop();
    }

    int calculateModifiedSubtreeSizes(int node, vector<vector<int>>& modifiedTree, vector<int>& sizes) {
        sizes[node] = 1;
        for (int child : modifiedTree[node]) {
            sizes[node] += calculateModifiedSubtreeSizes(child, modifiedTree, sizes);
        }
        return sizes[node];
    }
};
",1434278011
aappyy07,aappyy07,73,3587,cpp,"#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cctype>
#include <string>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <algorithm>
#include <functional>

using namespace std;

#define DEBUG(x) cout << '>' << #x << ':' << x << endl; 
#define REP(i,n) for(int i=0;i<(n);i++) 
#define FOR(i,a,b) for(int i=(a);i<=(b);i++) 
#define FORD(i,a,b) for(int i=(a);i>=(b);i--) 

inline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; } 

const int INF = 1<<29; 
typedef long long ll; 

inline int two(int n) { return 1 << n; } 
inline int test(int n, int b) { return (n>>b)&1; } 
inline void set_bit(int & n, int b) { n |= two(b); } 
inline void unset_bit(int & n, int b) { n &= ~two(b); } 
inline int last_bit(int n) { return n & (-n); } 
inline int ones(int n) { int res = 0; while(n && ++res) n -= n & (-n); return res; } 

template<class T> void chmax(T & a, const T & b) { a = max(a, b); } 
template<class T> void chmin(T & a, const T & b) { a = min(a, b); } 

class Solution {
public:
    long long calculateMaxScore(int day, int currentCity, int numCities, int totalDays, 
                                 vector<vector<int>>& stayScore, 
                                 vector<vector<int>>& travelScore,
                                 vector<vector<long long>>& memo) {
        if (day == totalDays) return 0;
        if (memo[day][currentCity] != -1) return memo[day][currentCity];
        
        long long maxPoints = 0;

        maxPoints = max(maxPoints, 
                        static_cast<long long>(stayScore[day][currentCity]) + 
                        calculateMaxScore(day + 1, currentCity, numCities, totalDays, stayScore, travelScore, memo));
        
        for (int nextCity = 0; nextCity < numCities; nextCity++) {
            maxPoints = max(maxPoints, 
                            static_cast<long long>(travelScore[currentCity][nextCity]) + 
                            calculateMaxScore(day + 1, nextCity, numCities, totalDays, stayScore, travelScore, memo));
        }
        
        return memo[day][currentCity] = maxPoints;
    }
    
    long long maxScore(int numCities, int totalDays, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<long long>> memo(totalDays, vector<long long>(numCities, INT_MIN));
        
        for (int city = 0; city < numCities; city++) {
            memo[0][city] = static_cast<long long>(stayScore[0][city]);
            for (int otherCity = 0; otherCity < numCities; otherCity++) {
                if (city != otherCity) {
                    memo[0][city] = max(memo[0][city], static_cast<long long>(travelScore[otherCity][city]));
                }
            }
        }

        for (int day = 1; day < totalDays; day++) {
            for (int currCity = 0; currCity < numCities; currCity++) {
                memo[day][currCity] = max(memo[day][currCity], memo[day - 1][currCity] + static_cast<long long>(stayScore[day][currCity]));
                
                for (int destCity = 0; destCity < numCities; destCity++) {
                    if (currCity != destCity) {
                        memo[day][destCity] = max(memo[day][destCity], memo[day - 1][currCity] + static_cast<long long>(travelScore[currCity][destCity]));
                    }
                }
            }
        }

        long long maxPoints = INT_MIN;
        for (int city = 0; city < numCities; city++) {
            maxPoints = max(maxPoints, memo[totalDays - 1][city]);
        }

        return maxPoints;
    }
};

",1434289725
aappyy07,aappyy07,73,3617,cpp,"class Solution {
public:
    int possibleStringCount(string input) {
        unordered_map<string, int> cache;
        int result = calculatePossibilities(input, cache);
        cout << ""Total possible originals: "" << result << endl;
        return result;
    }

private:
    int calculatePossibilities(const string &str, unordered_map<string, int> &cache) {
        if (cache.count(str)) {
            return cache[str];
        }

        int length = str.size();
        int totalOriginals = 1;

        for (int j = length - 1; j > 0; --j) {
            if (str[j] == str[j - 1]) {
                string newStr = str.substr(0, j) + str.substr(j + 1);
                totalOriginals += calculatePossibilities(newStr, cache);
                break;
            }
        }

        cache[str] = totalOriginals;
        return totalOriginals;
    }
};
",1434270428
aappyy07,aappyy07,73,3618,cpp,"class Solution {
public:
    int possibleStringCount(string str, int k) { // Rename here
        const int MODULO = 1e9 + 7;
        vector<int> consecutiveCounts;

        for (size_t pos = 0; pos < str.length(); ) {
            char currentChar = str[pos];
            int count = 1;
            while (pos + 1 < str.length() && str[pos + 1] == currentChar) {
                count++;
                pos++;
            }
            consecutiveCounts.push_back(count);
            pos++;
        }

        int groupCount = consecutiveCounts.size();
        long long totalCount = 1;

        for (const auto &count : consecutiveCounts) {
            totalCount = (totalCount * count) % MODULO;
        }

        if (groupCount > k) {
            return totalCount;
        }

        int remaining = k - 1 - groupCount;
        if (remaining < 0) {
            return totalCount;
        }

        vector<long long> dp(remaining + 1, 0);
        dp[0] = 1;

        for (const auto &count : consecutiveCounts) {
            int maxExtra = count - 1;
            vector<long long> prefixSum(remaining + 2, 0);

            for (int j = 0; j <= remaining; j++) {
                prefixSum[j + 1] = (prefixSum[j] + dp[j]) % MODULO;
            }

            vector<long long> newDp(remaining + 1, 0);
            for (int j = 0; j <= remaining; j++) {
                int leftIndex = j - maxExtra;
                if (leftIndex < 0) leftIndex = 0;
                newDp[j] = (prefixSum[j + 1] - prefixSum[leftIndex] + MODULO) % MODULO;
            }
            dp = newDp;
        }

        long long validCount = 0;
        for (int j = 0; j <= remaining; j++) {
            validCount = (validCount + dp[j]) % MODULO;
        }

        return (totalCount - validCount + MODULO) % MODULO;
    }
};
",1434339359
Abhishek Choudhary,theabbie,74,3576,python3,"from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        res = [0] * n
        graph = [[] for _ in range(n)]
        newgraph = [[] for _ in range(n)]
        for i in range(1, n):
            graph[parent[i]].append(i)
        depths = defaultdict(list)
        def dfs(i, d, p):
            if len(depths[s[i]]) > 0:
                newgraph[depths[s[i]][-1]].append(i)
            elif p != -1:
                newgraph[p].append(i)
            depths[s[i]].append(i)
            for j in graph[i]:
                dfs(j, d + 1, i)
            depths[s[i]].pop()
        dfs(0, 0, -1)
        def sdfs(i):
            res[i] += 1
            for j in newgraph[i]:
                sdfs(j)
                res[i] += res[j]
        sdfs(0)
        return res",1434339485
Abhishek Choudhary,theabbie,74,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        ndp = [0] * n
        for day in range(k - 1, -1, -1):
            for city in range(n):
                ndp[city] = stayScore[day][city] + dp[city]
                for other in range(n):
                    ndp[city] = max(ndp[city], travelScore[city][other] + dp[other])
            dp, ndp = ndp, dp
        return max(dp)",1434318648
Abhishek Choudhary,theabbie,74,3617,python3,"class Solution:
    def possibleStringCount(self, word):
        n = len(word)
        res = n + 1
        i = 0
        while i < n:
            while i < n - 1 and word[i] == word[i + 1]:
                i += 1
            res -= 1
            i += 1
        return res",1434300063
Abhishek Choudhary,theabbie,74,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        const int M = 1e9 + 7;
        int n = word.size();
        long long res = 1;
        vector<int> w;
        int i = 0;
        while (i < n) {
            int ctr = 1;
            while (i < n - 1 && word[i] == word[i + 1]) {
                i++;
                ctr++;
            }
            res = (res * ctr) % M;
            w.push_back(ctr);
            i++;
        }
        std::vector<long long> dp(k, 1), ndp(k);
        for (int i = std::min(static_cast<int>(w.size()), k + 2) - 1; i >= 0; i--) {
            std::vector<long long> pf(k + 1, 0);
            for (int j = 0; j < k; j++) {
                pf[j + 1] = (pf[j] + dp[j]) % M;
            }
            for (int rem = 0; rem < k; rem++) {
                int x = std::min(w[i], rem);
                ndp[rem] = (pf[rem] - pf[rem - x] + M) % M;
            }
            dp = ndp;
        }
        res = (res - dp[k - 1] + M) % M;
        return static_cast<int>(res);
    }
};
",1434294328
i-zokirov,izokirov,80,3576,javascript,"/**
 * @param {number[]} parent
 * @param {string} s
 * @return {number[]}
 */
var findSubtreeSizes = function(parent, s) {
    const n = parent.length;
  const tree = Array.from({ length: n }, () => []);
  const newParent = parent.slice(); // Copy of parent array

  // Build the original tree
  for (let i = 1; i < n; i++) {
    tree[parent[i]].push(i);
  }

  // Initialize lastSeen array
  const lastSeen = new Array(26).fill(-1);

  // DFS to determine new parents
  function dfsDetermine(u) {
    const charIndex = s[u].charCodeAt(0) - ""a"".charCodeAt(0);
    const prevLastSeen = lastSeen[charIndex];

    if (prevLastSeen !== -1 && prevLastSeen !== u) {
      newParent[u] = prevLastSeen;
    }

    lastSeen[charIndex] = u;

    for (const v of tree[u]) {
      dfsDetermine(v);
    }

    // Restore lastSeen after traversal
    lastSeen[charIndex] = prevLastSeen;
  }

  dfsDetermine(0); // Start DFS from root

  // Build the new tree
  const newTree = Array.from({ length: n }, () => []);
  for (let i = 1; i < n; i++) {
    const p = newParent[i];
    newTree[p].push(i);
  }

  const answer = new Array(n).fill(0);

  // DFS to compute subtree sizes
  function dfsCompute(u) {
    let size = 1; // Count the node itself
    for (const v of newTree[u]) {
      size += dfsCompute(v);
    }
    answer[u] = size;
    return size;
  }

  dfsCompute(0); // Start DFS from root

  return answer;
};",1434356826
i-zokirov,izokirov,80,3587,javascript,"/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function(n, k, stayScore, travelScore) {
    // Initialize dp array
  const dp = Array.from({ length: k }, () => Array(n).fill(-Infinity));

  // Day 0 initialization
  for (let currCity = 0; currCity < n; currCity++) {
    // Option 1: Start in currCity and stay
    dp[0][currCity] = stayScore[0][currCity];
    // Option 2: Start in any city and move to currCity
    for (let prevCity = 0; prevCity < n; prevCity++) {
      if (prevCity !== currCity) {
        dp[0][currCity] = Math.max(
          dp[0][currCity],
          travelScore[prevCity][currCity]
        );
      }
    }
  }

  // DP transition
  for (let day = 1; day < k; day++) {
    for (let currCity = 0; currCity < n; currCity++) {
      // Option 1: Stay in the current city
      dp[day][currCity] = dp[day - 1][currCity] + stayScore[day][currCity];
      // Option 2: Move from another city
      for (let prevCity = 0; prevCity < n; prevCity++) {
        if (prevCity !== currCity) {
          dp[day][currCity] = Math.max(
            dp[day][currCity],
            dp[day - 1][prevCity] + travelScore[prevCity][currCity]
          );
        }
      }
    }
  }

  // Find the maximum points after k days
  const maxPoints = Math.max(...dp[k - 1]);
  return maxPoints;
};",1434293585
i-zokirov,izokirov,80,3617,javascript,"/**
 * @param {string} word
 * @return {number}
 */
var possibleStringCount = function(word) {
    let total = 1; // Start with 1 for the original string
    let i = 0;
    const n = word.length;
    while (i < n) {
        let current_char = word[i];
        let run_length = 1;
        let j = i + 1;
        // Find the length of the current run
        while (j < n && word[j] === current_char) {
            run_length += 1;
            j += 1;
        }
        // Add the possible reductions for this run
        total += (run_length - 1);
        i = j; // Move to the next character
    }
    return total;
};",1434266670
i-zokirov,izokirov,80,3618,javascript,"/**
 * @param {string} word
 * @param {number} k
 * @return {number}
 */
var possibleStringCount = function(word, k) {
  const mod = 1e9 + 7;
  const runs = [];
  const n = word.length;
  let i = 0;

  // Identify runs and their lengths
  while (i < n) {
    const currentChar = word[i];
    let length = 1;
    i++;
    while (i < n && word[i] === currentChar) {
      length++;
      i++;
    }
    runs.push(length);
  }

  const totalRuns = runs.length;
  const minTotalLength = totalRuns; // Minimum possible total length
  const maxExtraLength = n - totalRuns;

  // Compute total combinations (product of run lengths)
  let totalCombinations = 1;
  for (let len of runs) {
    totalCombinations = (totalCombinations * len) % mod;
  }

  // If k is less than the minimum possible length, all combinations are valid
  if (k <= minTotalLength) {
    return totalCombinations;
  }

  // Initialize dp array
  const maxE = Math.min(maxExtraLength, k - totalRuns - 1);
  const dp = new Array(maxE + 1).fill(0);
  dp[0] = 1;

  // Dynamic Programming
  for (let runLen of runs) {
    const u = runLen - 1; // Max extra length for this run
    const newDp = dp.slice();
    const preDp = new Array(maxE + 2).fill(0); // Extra space to handle index

    // Compute prefix sums
    for (let e = 0; e <= maxE; e++) {
      preDp[e + 1] = (preDp[e] + dp[e]) % mod;
    }

    for (let e = 0; e <= maxE; e++) {
      const low = Math.max(0, e - u);
      const high = e;
      const total = (preDp[high + 1] - preDp[low] + mod) % mod;
      newDp[e] = total;
    }
    dp.splice(0, dp.length, ...newDp);
  }

  // Calculate total combinations where total length < k
  let totalLessThanK = 0;
  for (let e = 0; e <= maxE; e++) {
    totalLessThanK = (totalLessThanK + dp[e]) % mod;
  }

  // Compute the final result
  const result = (totalCombinations - totalLessThanK + mod) % mod;
  return result;
}

",1434328307
sveng101,sveng101,81,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj1 = [set() for _ in range(n)]
        root = None
        for idx1, idx0 in enumerate(parent):
            if idx0 == -1:
                root = idx1
            else: adj1[idx0].add(idx1)
        parent2 = list(parent)
        seen_stks = {}
        def recur(idx: int) -> None:
            l = s[idx]
            if l in seen_stks.keys() and seen_stks[l]:
                parent2[idx] = seen_stks[l][-1]
            else: seen_stks[l] = []
            seen_stks[l].append(idx)
            for idx2 in adj1[idx]:
                recur(idx2)
            seen_stks[l].pop()
            if not seen_stks[l]: seen_stks.pop(l)
            return

        recur(root)
        #print(root)
        #print(parent2)
        adj2 = [set() for _ in range(n)]
        for idx1, idx0 in enumerate(parent2):
            if idx0 != -1:
                adj2[idx0].add(idx1)
        #print(adj2)
        #print(root)
        res = [0] * n
        def recur2(idx: int) -> int:
            #print(idx)
            res[idx] = 1 + sum(recur2(idx2) for idx2 in adj2[idx])
            return res[idx]
        recur2(root)
        return res",1434290844
sveng101,sveng101,81,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        row = [0] * n
        for k_ in range(k):
            prev = row
            row = [prev[i] + stayScore[k_][i] for i in range(n)]
            for i1 in range(n):
                for i2 in range(n):
                    row[i2] = max(row[i2], prev[i1] + travelScore[i1][i2])
        return max(row)",1434300947
sveng101,sveng101,81,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        curr_len = 0
        prev = None
        res = 1
        for l in word:
            if l == prev:
                res += 1
                continue
            prev = l
            #res += max(curr_len - 1, 0)
            #curr_len = 1
        return res#res + max(curr_len - 1, 0)",1434262941
sveng101,sveng101,81,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        n = len(word)
        md = 10 ** 9 + 7

        if k > n: return 0
        elif k == n: return 1
        
        rpt_counts = {}
        curr_len = 1
        prev = word[0]
        for i in range(1, n):
            l = word[i]
            if l == prev:
                curr_len += 1
                continue
            rpt_counts[curr_len] = rpt_counts.get(curr_len, 0) + 1
            curr_len = 1
            prev = l
        rpt_counts[curr_len] = rpt_counts.get(curr_len, 0) + 1
        #print(rpt_counts)

        mn_len = sum(rpt_counts.values())
        #print(mn_len)

        tot = 1
        for length, f in rpt_counts.items():
            tot = (tot * pow(length, f, md)) % md
        
        if mn_len >= k:
            return tot
        k2 = k - mn_len
        mx_add_lst = [0] * (mn_len - rpt_counts.get(1, 0))
        i = 0
        for length in sorted(rpt_counts.keys()):
            if length == 1 or not rpt_counts[length]: continue
            for i in range(i, i + rpt_counts[length]):
                mx_add_lst[i] = length - 1
            i += 1
        #print(mx_add_lst)

        row = [0] * k2
        row[0] = 1
        for idx in range(len(mx_add_lst)):
            prev = row
            prev_cumu = list(prev)
            for i in range(1, len(prev)):
                prev_cumu[i] = (prev_cumu[i - 1] + prev[i]) % md
            row = [0] * k2
            for j in range(len(row)):
                j0 = j - mx_add_lst[idx] - 1
                row[j] = (row[j] + prev_cumu[j] - (prev_cumu[j0] if j0 >= 0 else 0)) % md
        #print(k2)
        #print(tot)
        #print(row)
        return (tot - sum(row)) % md",1434356888
N M,nnmm11,82,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        for i, x in enumerate(parent):
            if x >= 0:
                adj[x].append(i)

        ans = [1]*(n+1)
        ancestor = {} # value to closest ancestor
        def dfs(x, p):
            c = s[x]
            # Update size of subtree rooted at new parent.
            lastAncestor = ancestor.get(c)
            newParent = lastAncestor if lastAncestor is not None else p
            # print(x, c, newParent, ancestor)
            ancestor[c] = x
            # Count the node itself
            for y in adj[x]:
                dfs(y, x)
            # print(x, ans, newParent)
            ans[newParent] += ans[x]
            if lastAncestor is None:
                del ancestor[c]
            else:
                ancestor[c] = lastAncestor
            # print(x, ans)

        # ans[0] -= 1 # don't double-count the root
        dfs(0, -1)
        print(ans)
        return ans[:-1]
        
            ",1434312986
N M,nnmm11,82,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        ans = [0]*n
        # After a day, they can either stay or move.
        for i, stay in enumerate(stayScore):
            newAns = [x + y for (x, y) in zip(ans, stay)]
            for i, arr in enumerate(travelScore):
                for j, c in enumerate(arr):
                    newAns[j] = max(newAns[j], ans[i] + c)
            ans = newAns
        return max(ans)",1434320826
N M,nnmm11,82,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        cur = 0
        prev = None
        for c in word:
            if c != prev:
                ans += cur 
                cur = 0
                prev = c
            else:
                cur += 1
        ans += cur
        return ans
            ",1434267634
N M,nnmm11,82,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        arr = []
        prev = word[0]
        pos = 0
        for i, c in enumerate(word):
            if c != prev:
                arr.append(i - pos)
                prev = c
                pos = i
        arr.append(len(word) - pos)
        # Now do dp on arr.
        # Calculate number of strings of size at most k-1.
        # Subtract that from iniital (all possible strings).
        initial = 1
        for x in arr:
            initial = (initial * x) % (10**9 + 7)
        if len(arr) >= k:
            return initial
        
        dp = [0]*k
        dp[0] = 1
        for i, x in enumerate(arr):
            newDp = [0]*k
            running_total = dp[i]
            for j in range(i + 1, k):
                newDp[j] = running_total
                running_total += dp[j]
                if j >= x: running_total -= dp[j - x]
            dp = newDp
        # print(initial, dp)
        return (initial - sum(dp) + (10**9 + 7)) % (10**9 + 7)
        ",1434352111
Nutty Professor,varkatkl,83,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        N = len(parent)
        ALPHA = 26
        colors = [-1] * ALPHA

        adj = [[] for _ in range(N)]
        for i in range(1, N):
            adj[parent[i]].append(i)

        new_parent = parent[:]

        def rec(i, color_stack):
            color = ord(s[i]) - ord('a')
            previous = color_stack[color]
            if previous >= 0:
                new_parent[i] = previous
            color_stack[color] = i
            for j in adj[i]:
                rec(j, color_stack)
            color_stack[color] = previous

        rec(0, colors)

        adj2 = [[] for _ in range(N)]
        for i in range(1, N):
            adj2[new_parent[i]].append(i)

        subtrees = [0] * N
        def rec2(i):
            ret = 1
            for j in adj2[i]:
                ret += rec2(j)
            subtrees[i] = ret
            return ret

        rec2(0)
        return subtrees
",1434309023
Nutty Professor,varkatkl,83,3587,python3,"class Solution:
    def maxScore(self, N: int, K: int, stay: List[List[int]], travel: List[List[int]]) -> int:
        dp = [[0] * N for _ in range(K + 1)]
        for day in range(K - 1, -1, -1):
            for city in range(N):
                dp[day][city] = dp[day + 1][city] + stay[day][city]
                for next_city in range(N):
                    if next_city != city:
                        dp[day][city] = max(dp[day][city], travel[city][next_city] + dp[day + 1][next_city])

        return max(dp[0])
",1434316165
Nutty Professor,varkatkl,83,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        last, ret, cnt = 'A', 1, 0
        for c in word:
            if last == c:
                cnt += 1
            else:
                if cnt > 0:
                    ret += cnt - 1
                last, cnt = c, 1
        if cnt > 0:
            ret += cnt - 1
        return ret
",1434293364
Nutty Professor,varkatkl,83,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int K) {
        vector<int> runs = runs_of_string(word);
    
        const int R = runs.size();
        vector<long long> product_suffix(R + 1, 1LL);
        for (int r = R - 1;r >= 0;r--) {
            product_suffix[r] = product_suffix[r + 1] * runs[r] % MOD;
        }
        if (R >= K) {
            return (int)(product_suffix[0]);
        }

        vector<vector<long long> > dp(R + 1, vector<long long>(K + 1, 0LL));
        dp[R][0] = 1LL;
        vector<long long> sum_prefix(K + 2, 0LL);
        for (int r = R - 1;r >= 0; r--) {
            compute_sum_prefix(dp[r + 1], sum_prefix);
            dp[r][0] = product_suffix[r];
            for (int k = 1;k <= K; k++) {
                if (k >= runs[r]) {
                    int right = k - 1, left = k - runs[r];
                    dp[r][k] = sum_prefix[right + 1] + MOD - sum_prefix[left];
                    dp[r][k] %= MOD;
                } else {
                    dp[r][k] = sum_prefix[k] + MOD - sum_prefix[1];
                    dp[r][k] += (runs[r] - k + 1) * 1LL * dp[r + 1][0] % MOD;
                    dp[r][k] %= MOD;
                }
            }
        }

        return dp[0][K];
    }
private:
    static const long long MOD = 1000000007LL;

    vector<int> runs_of_string(string& word)
    {
        vector<int> runs;
        char last = 'A';
        int tail = 0;
        for (char c : word) {
            if (last == c) {
                tail++;
            } else {
                if (last != 'A') {
                    runs.push_back(tail);
                }
                last = c;
                tail = 1;
            }
        }
        if (tail > 0) {
            runs.push_back(tail);
        }
        return runs;
    }

    void compute_sum_prefix(vector<long long>& row, vector<long long>& prefix) {
        const int K = (int) (row.size()) - 1;
        prefix[0] = 0LL;
        for (int k = 0;k <= K; k++) {
            prefix[k + 1] = prefix[k] + row[k];
        }
    }
};",1434352248
aminjonshermatov,aminjonshermatov,85,3576,cpp,"class Solution {
public:
  vector<int> findSubtreeSizes(vector<int>& ps, string s) {
    const auto n = int(ps.size());
    vector<vector<int>> g(n);
    for (int i = 1; i < n; ++i) {
      g[ps[i]].emplace_back(i);
    }
    array<int, 26> xs{};
    xs.fill(-1);
    vector<int> sub(n);
    auto dfs = [&](auto&& self, int v, int p) -> void {
      auto id = xs[s[v] - 'a'];
      xs[s[v] - 'a'] = v;
      sub[v] = 1;
      for (auto u : g[v]) {
        self(self, u, v);
        sub[v] += sub[u];
      }
      if (id != -1) {
        sub[id] += sub[v];
        sub[p] -= sub[v];
      }
      xs[s[v] - 'a'] = id;
    };
    dfs(dfs, 0, -1);
    return sub;
  }
};",1434340481
aminjonshermatov,aminjonshermatov,85,3587,cpp,"class Solution {
public:
  int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
    vector cache(n, vector(k, -1));
    auto dp = [&](auto&& self, int c, int d) -> int {
      if (d >= k) {
        return 0;
      }
      auto& loc = cache[c][d];
      if (loc != -1) {
        return loc;
      }
      loc = ss[d][c] + self(self, c, d + 1);
      for (int i = 0; i < n; ++i) {
        if (i != c) {
          loc = max(loc, ts[c][i] + self(self, i, d + 1));
        }
      }
      return loc;
    };
    int best = 0;
    for (int i = 0; i < n; ++i) {
      best = max(best, dp(dp, i, 0));
    }
    return best;
  }
};",1434305228
aminjonshermatov,aminjonshermatov,85,3617,cpp,"class Solution {
public:
  int possibleStringCount(string s) {
    set<string> ss;
    for (int i = 0; i < s.size(); ++i) {
      auto r = i;
      while (r + 1 < s.size() && s[i] == s[r + 1]) {
        ++r;
      }
      string a, b;
      if (i > 0) {
        a = s.substr(0, i);
      }
      if (i + 1 < s.size()) {
        b = s.substr(i + 1, s.size() - i - 1);
      }
      for (int x = 1; x <= r - i + 1; ++x) {
        ss.emplace(a + string(x, s[i]) + b);
      }
    }
    return ss.size();
  }
};",1434333973
aminjonshermatov,aminjonshermatov,85,3618,cpp,"constexpr int mod = 1e9 + 7;

constexpr int add(int a, int b) noexcept {
  if ((a += b) >= mod) {
    a -= mod;
  }
  return a;
}
constexpr int sub(int a, int b) noexcept {
  if ((a = a + mod - b) >= mod) {
    a -= mod;
  }
  if (a < 0) {
    a += mod;
  }
  return a;
}
constexpr int mul(int a, int b) noexcept {
  return ((a * 1LL * b) % mod + mod) % mod;
}

class Solution {
public:
  int possibleStringCount(string s, int k) {
    vector<int> as;
    string stk;
    for (auto c : s) {
      if (stk.empty() || stk.back() != c) {
        stk.push_back(c);
        as.emplace_back(0);
      }
      ++as.back();
    }
    int tot = 1;
    for (auto a : as) {
      tot = mul(tot, a);
    }
    const auto n = int(as.size());
    if (n < k) {
      vector<int> dp(k, 1);
      vector<int> pf(k);
      auto calc = [&] {
        pf[0] = dp[0];
        for (int i = 1; i < k; ++i) {
          pf[i] = add(pf[i - 1], dp[i]);
        }
      };
      calc();
      for (int i = n - 1; i >= 0; --i) {
        vector<int> ndp(k);
        for (int len = 0; len < k; ++len) {
          ndp[len] = sub(pf[min(len + as[i], k - 1)], pf[len]);
        }
        swap(dp, ndp);
        calc();
      }
      tot = sub(tot, dp[0]);
    }
    return tot;
  }
};",1434294756
Bogdan,wery0,86,3576,cpp,"#pragma GCC optimize(""Ofast"")
// #pragma GCC target(""avx,avx2,fma"")

#include ""bits/stdc++.h""

//#define NDEBUG
#define F first
#define S second
#define vec vector
#define pb push_back
#define pll pair<ll, ll>
#define pdd pair<ld, ld>
#define pii pair<int, int>
#define all(m) m.begin(), m.end()
#define rall(m) m.rbegin(), m.rend()
#define uid uniform_int_distribution
#define timeStamp() std::chrono::steady_clock::now()
#define unify(m) sort(all(m)), m.erase(unique(all(m)), m.end());
#define duration_micro(a) chrono::duration_cast<chrono::microseconds>(a).count()
#define duration_milli(a) chrono::duration_cast<chrono::milliseconds>(a).count()
#define fast cin.tie(0), cout.tie(0), cin.sync_with_stdio(0), cout.sync_with_stdio(0);
using namespace std;
using str = string;
using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
mt19937 rnd(timeStamp().time_since_epoch().count());
mt19937_64 rndll(timeStamp().time_since_epoch().count());
template<typename T, typename U> bool chmin(T& a, const U& b) {return (T)b < a ? a = b, 1 : 0;}
template<typename T, typename U> bool chmax(T& a, const U& b) {return (T)b > a ? a = b, 1 : 0;}
struct custom_hash {static uint64_t xs(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31);} template<typename T> size_t operator()(T x) const {static const uint64_t C = timeStamp().time_since_epoch().count(); return xs(hash<T> {}(x) + C);}};
template<typename K> using uset = unordered_set<K, custom_hash>;
template<typename K, typename V> using umap = unordered_map<K, V, custom_hash>;
template<typename T1, typename T2> ostream& operator<<(ostream& out, const pair<T1, T2>& x) {return out << x.F << ' ' << x.S;}
template<typename T1, typename T2> istream& operator>>(istream& in, pair<T1, T2>& x) {return in >> x.F >> x.S;}
template<typename T, size_t N> istream& operator>>(istream& in, array<T, N>& a) {for (auto &x : a) in >> x; return in;}
template<typename T, size_t N> ostream& operator<<(ostream& out, const array<T, N>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i]; if (i + 1 < a.size()) out << ' ';} return out;}
template<typename T> istream& operator>>(istream& in, vector<T>& a) {for (auto& x : a) in >> x; return in;}
template<typename T> ostream& operator<<(ostream& out, const vector<T>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i]; if (i + 1 < a.size()) out << ' ';} return out;}

template<typename I> auto array_cnt(I f, I l) {umap<typename iterator_traits<I>::value_type, int> mp; while (f != l) ++mp[*f], ++f; return mp;}
template<typename I> auto subset_sum(I f, I l) {int a = l - f; vec<typename iterator_traits<I>::value_type> o(1 << a); for (int q = 1; q < (1 << a); ++q) {const int i = __builtin_ctz(q); o[q] = *(f + i) + o[q ^ (1 << i)];} return o;}
template<typename I> vec<pii> get_segs_of_eq_elems(I first, I last, function<bool(const typename iterator_traits<I>::value_type&, const typename iterator_traits<I>::value_type&)> cmp = [](const auto& l, const auto& r) {return l == r;}) {using T = typename iterator_traits<I>::value_type; vec<pii> ans; if (first == last) return ans; int l = 0, r = 1; T prev = *first; for (auto cit = next(first); cit != last; ++cit, ++r) {if (!cmp(*cit, prev)) {ans.emplace_back(l, r - 1); l = r;} prev = *cit;} ans.emplace_back(l, r - 1); return ans;}
template<typename I> int LCP(I f1, I l1, I f2, I l2) {for (int o = 0; ; ++f1, ++f2, ++o) if (f1 == l1 || f2 == l2 || *f1 != *f2) return o; return -1;}
template<typename I> int min_period(I f, I l) {int a = l - f; vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (*(f + q) == *(f + w)) m[q] = w + 1;} m[q] += !m[q] && *(f + q) == *f;} int p = a - m.back(); return a % p ? a : p;}
template<typename I> bool is_palindrome(I f, I l) {for (--l; f < l; ++f, --l) if (*f != *l) return 0; return 1;}
str from_base_10_to_base_b(ll x, ll b) {str t; if (x == 0) t = ""0""; for (; x; x /= b) t += (char)('0' + x % b); reverse(all(t)); return t;}
#define vi vec<int>
#define vl vec<ll>
#define vvi vec<vec<int>>
#define vvvi vec<vec<vec<int>>>
#define vvl vec<vec<ll>>
#define vpi vec<pii>
#define vpl vec<pll>
#define vs vec<str>
#define vvs vec<vec<str>>
const int dx[] = { -1, 0, 1, 0, -1, 1, 1, -1};
const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T> int sum_of_digits(T val) {int o = 0; for (; val; val /= 10) o += val % 10; return o;}
template<typename T> struct static_sum_query {vec<T> m; static_sum_query() = default; template<typename I>static_sum_query(I f, I l) {m.resize(l - f + 1); for (auto it = m.begin() + 1; f != l; ++f, ++it) {*it = *(it - 1) + *f;}} template<typename T_arr> static_sum_query(T_arr& m) {(*this) = static_sum_query(all(m));} inline T query(const int l, const int r) const {return m[r + 1] - m[l];}};
template<typename T> vec<pair<T, int>> zip_with_positions(vec<T> &m) {int a = m.size(); vec<pair<T, int>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q], q}; return ans;}
template<typename T> str join(vec<T> &m, str c) {str o; if constexpr(is_same<str, T>::value) {for (const T &s : m) o += s + c;} else {for (const T &s : m) o += to_string(s) + c;} if (o.size()) o.erase(o.end() - c.size(), o.end()); return o;}
vec<pii> get_reflection_points_in_rect(int a, int b, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < b); vec<pii> res = {{x, y}}; if (x != a - x - 1) res.pb({a - x - 1, y}); if (y != a - y - 1) res.pb({x, a - y - 1}); if (x != a - x - 1 && y != a - y - 1) res.pb({a - x - 1, a - y - 1}); return res;}
vec<pii> get_rotation_points_in_square(int a, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < a); vec<pii> res = {{x, y}}; if (a % 2 == 1 && x == a / 2 && y == a / 2) return res; res.pb({a - y - 1, x}); res.pb({a - x - 1, a - y - 1}); res.pb({y, a - x - 1}); return res;}
template<typename T> vec<vec<int>> get_cycles_of_perm(vec<T> &m, int permutation_indexation) {int a = m.size(); vec<vec<int>> ans; vec<bool> us(a); for (int q = 0; q < a; ++q) {if (us[q]) continue; vec<int> tyt; for (int w = q; !us[w]; w = m[w] - permutation_indexation) {tyt.pb(w); us[w] = 1;} ans.pb(tyt);} return ans;}
int find_closing_bracket(str &s, int i) {char op = s[i], cl = op == '(' ? ')' : op == '{' ? '}' : op == '[' ? ']' : op == '<' ? '>' : '@'; assert(cl != '@'); int dep = 1; for (int q = i + 1; q < s.size(); ++q) {dep += s[q] == op ? 1 : s[q] == cl ? -1 : 0; if (dep == 0) return q;} return -1;}
template<typename T> vec<pair<T, T>> vv_to_vp(vec<vec<T>> &m) {int a = m.size(); vec<pair<T, T>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q][0], m[q][1]}; return ans;}
template<const int k, typename T> vec<array<T, k>> vv_to_varr(vec<vec<T>> &m) {int a = m.size(); vec<array<T, k>> ans(a); for (int q = 0; q < a; ++q) for (int w = 0; w < k; ++w) ans[q][w] = m[q][w]; return ans;}
str from_base_10_to_base_b(str x, ll b) {return from_base_10_to_base_b(stoll(x), b);}
ll from_base_b_to_base_10(str x, ll b) {ll o = 0, pw = 1; for (int q = x.size() - 1; q >= 0; --q, pw *= b) o += (x[q] - '0') * pw; return o;}
str from_base_a_to_base_b(str x, ll a, ll b) {ll x10 = from_base_b_to_base_10(x, a); return from_base_10_to_base_b(x10, b);}
template<typename T> T binpow(T x, T k) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x; x = x * x;} return o;}
template<typename T> T binpow_mod(T x, T k, T mod) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x % mod; x = x * x % mod;} return o;}
template<typename T> T ar_prog_sum_fcl(T first, T cnt, T last) {return (first + last) * cnt / 2;}
template<typename T> T ar_prog_sum_fdc(T first, T diff, T cnt) {return (first * 2 + diff * (cnt - 1)) * cnt / 2;}
template<typename T> T ar_prog_sum_fdl(T first, T diff, T last) {return (first + last) * ((last - first) / diff + 1) / 2;}
template<typename T> T geom_prog_sum_fdl(T first, T diff, T last) {return (last * diff - first) / (diff - 1);}
template<typename T> T geom_prog_sum_fdc(T first, T diff, T cnt) {return (first * binpow(diff, cnt) - first) / (diff - 1);}
template<typename T> vec<vec<T>> transpose_matrix(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int q = 0; q < a; ++q) {for (int w = 0; w < b; ++w) {ans[w][q] = m[q][w];}} return ans;}
template<typename T> vec<vec<T>> rotate_matrix_cw(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int w = 0; w < b; ++w) for (int q = 0; q < a; ++q) ans[w][q] = m[a - 1 - q][w]; return ans;}
complex<ll> str_to_cmpl_ll(str t) {int ps = t.find('+'), sgn = 1; if (ps == string::npos) {ps = t.find('-'); sgn = -1; assert(ps != string::npos);} str t1 = t.substr(0, ps), t2 = t.substr(ps + 1); assert(t2.back() == 'i'); t2.pop_back(); return {stoll(t1), stoll(t2) * sgn};}
int time_to_minutes(int h, int m) {return h * 60 + m;}
int time_to_minutes(str s) {int ps = s.find(':'); assert(ps != string::npos); return time_to_minutes(stoi(s.substr(0, ps)), stoi(s.substr(ps + 1)));}
str minutes_to_time(int m, bool h0 = true, bool m0 = true) {int h = m / 60; m %= 60; str o; if (h0) o += (h < 10 ? ""0"" : """"); o += to_string(h); o += ':'; if (m0) o += (m < 10 ? ""0"" : """"); o += to_string(m); return o;}
bool is_vowel_lowercase(char c) {return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';}
bool is_consonant_lowercase(char c) {return !is_vowel_lowercase(c);}
ull leq_pow2ll(const ull x) {return 1ull << __lg(x);}
ull geq_pow2ll(const ull x) {return x & (x - 1) ? 2ull << __lg(x) : x;}
ll sqd(const pll p1, const pll p2) {return (p1.F - p2.F) * (p1.F - p2.F) + (p1.S - p2.S) * (p1.S - p2.S);}
ll sqd(const ll x1, const ll y1, const ll x2, const ll y2) {return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);}
template<typename T> int sign(T x) {return x < 0 ? -1 : x > 0 ? 1 : 0;}
template<typename I> bool is_subsequence(I f_pattern, I l_pattern, I f_text, I l_text) {for (; f_text != l_text && f_pattern != l_pattern; ++f_text) if (*f_text == *f_pattern) ++f_pattern; return f_pattern == l_pattern;}
template<typename T> auto C = []() {const size_t N = 67; array<array<T, N>, N> C{0}; C[0][0] = 1; for (size_t i = 1; i < N; ++i) {C[i][0] = 1; for (size_t j = 1; j <= i; ++j) {C[i][j] = C[i - 1][j - 1] + C[i - 1][j];}} return C;}();
vec<ll> get_divisors(ll x) {vec<ll> ans1, ans2; for (ll q = 1; q * q <= x; ++q) {if (x % q == 0) {ans1.pb(q); ans2.pb(x / q);}} if (ans1.back() == ans2.back()) ans1.pop_back(); reverse(all(ans2)); for (ll i : ans2) ans1.pb(i); return ans1;}
bool is_prime(ll c) {if (c < 2) return 0; if (c == 2 || c == 3) return 1; if (c % 2 == 0 || c % 3 == 0) return 0; const ll gr = sqrtl(c) + 1; for (ll q = 6; q <= gr; q += 6) {if (c % (q - 1) == 0) return 0; if (c % (q + 1) == 0) return 0;} return 1;}
vec<str> split(str &s, char c, bool ignore_empty = false) {vec<str> o; str u; for (int q = 0; q < s.size(); q++) {if (s[q] == c) {if (!u.empty() || !ignore_empty) o.pb(u); u.clear();} else u += s[q];} if (!u.empty() || !ignore_empty) o.pb(u); return o;}
int replace(str &s, str from, str to) {str t = from; t.pb(0); t += s; int a = t.size(); vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (t[q] == t[w]) m[q] = w + 1;} m[q] += !m[q] && t[q] == t[0];} int szf = from.size(), lst = szf; for (int q = szf; q < t.size(); ++q) {if (m[q] == szf && q - lst >= szf) {m[q - szf + 1] = -1; lst = q;}} str ans; int o = 0; for (int q = szf + 1; q < t.size(); ++q) {if (m[q] != -1) ans += t[q]; else ans += to, q += szf - 1, ++o;} s = ans; return o;}
template<typename T> T mul_threshold(T a, T b, T threshold) {if (!a || !b || !threshold) return 0; assert(a > 0 && b > 0); T max_b = threshold / a; return b <= max_b ? a * b : threshold;}
template<typename T> T count_set_bits_pref(T n, int b) {assert(0 <= n); T pw = (T)(1) << b; if (pw > n) return 0; T period = pw * 2; T full = (n + 1) / period; T rem = (n + 1) & (period - 1); return full * pw + (rem < pw ? 0 : rem - pw);}
template<typename T> T count_set_bits_seg(T l, T r, int b) {assert(0 <= l && l <= r); return count_set_bits_pref(r, b) - (l ? count_set_bits_pref(l - 1, b) : 0);}
template<typename I> vector<int> get_substring_occurrences(I f_pattern, I l_pattern, I f_text, I l_text) {const size_t n = std::distance(f_pattern, l_pattern); const size_t m = std::distance(f_text, l_text); assert(n); auto cmp = [&](size_t i, size_t j) {if (i == n || j == n) return i == j; return (i < n ? * (f_pattern + i) : * (f_text + i - n - 1)) == (j < n ? * (f_pattern + j) : * (f_text + j - n - 1));}; vector<int> pf(n), res; for (size_t i = 1, ppf = 0; i < n + 1 + m; ++i) {size_t p = 0; for (size_t j = ppf; j && !p; j = pf[j - 1]) {if (cmp(i, j)) p = j + 1;} p += !p && cmp(i, 0); ppf = p; if (i < n) pf[i] = p; if (p == n) res.push_back(i - n * 2);} return res;}
template<typename T> T integral_tersearch_argmin(auto f, T l, T r) {static_assert(is_integral_v<decltype(l)>); using U = decltype(f(l)); const ld FI = 1.6180339887498948482045868343656381177203; T p1 = l + (r - l) / (FI + 1), p2 = r - (r - l) / (FI + 1); U v1 = f(p1), v2 = f(p2); while (r - l > 7) {if (v1 < v2) {r = p2; p2 = p1, v2 = v1; p1 = l + (r - l) / (FI + 1), v1 = f(p1);} else {l = p1; p1 = p2, v1 = v2; p2 = r - (r - l) / (FI + 1), v2 = f(p2);}} T best_arg = l; U best_val = f(l), prv = best_val; while (++l <= r) {U tyt = l == p1 ? v1 : l == p2 ? v2 : f(l); if (tyt > prv) break; if (chmin(best_val, tyt)) best_arg = l; prv = tyt;} return best_arg;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l, T r) {static_assert(is_same<decltype(l), decltype(r)>::value); while (l + 1 < r) {T md = l + (r - l) / 2; if (f(md))l = md; else r = md;} return l;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l) {T d = 1; while (f(l + d)) d *= 2; d /= 2; for (T u = d; u; u /= 2) if (f(l + d + u)) d += u; return l + d;};
template<typename T> T get_kth_statistic_by_binary_search(T n, T k, T val_l, T val_r, auto cnt_leq) {assert(0 <= k && k < n); assert(val_l <= val_r); return integral_binary_search_last_when_true<T>([&](T x) {return cnt_leq(x) <= k;}, val_l - 1, val_r) + 1;}

template<typename Data>
struct edge {
    int to;
    Data data;

    edge() = default;
    edge(int to) : to(to) {}
    edge(int to, Data data) : to(to), data(data) {}

    bool operator<(const edge& other) const {return to < other.to;}
    bool operator==(const edge& other) const {return to == other.to && data == other.data;}
};

template<>
struct edge<void> {
    int to;

    edge() = default;
    edge(int to) : to(to) {}

    bool operator<(const edge& other) const {return to < other.to;}
    bool operator==(const edge& other) const {return to == other.to;}
};

template<typename Edge>
struct tree {

    struct edge_range {
        __gnu_cxx::__normal_iterator<Edge*, vector<Edge>> first, last;
        auto begin() const {return first;}
        auto end() const {return last;}

        int size() const {return last - first;}
        Edge& operator[](const int v) {return *(first + v);}
    };

    struct graph {

        int V = -1, E;
        vector<Edge> store;
        vector<int> fir;
        vector<pair<int, Edge>> acc_edge;
        bool is_prepared = 0;

        graph() = default;
        graph(int V) : V(V) {}
        graph(int V, int E) : V(V) {if (E != -1) acc_edge.reserve(E);}

        void prepare() {if (V == -1) {int mxn = -1; for (const auto& [v, e] : acc_edge) mxn = max({mxn, v, e.to}); V = mxn + 1;} E = acc_edge.size(); store.resize(E); vector<int> deg_cnt(V + 1); for (const auto& p : acc_edge) ++deg_cnt[p.first + 1]; partial_sum(deg_cnt.begin(), deg_cnt.end(), deg_cnt.begin()); fir = deg_cnt; for (const auto& p : acc_edge) store[deg_cnt[p.first]++] = p.second; acc_edge.clear(); acc_edge.shrink_to_fit(); is_prepared = 1;}
        void add_edge(int x, Edge e, const bool is_dir) {if (V != -1) assert(0 <= x && x < V), assert(0 <= e.to && e.to < V); acc_edge.emplace_back(x, e); if (!is_dir) {swap(x, e.to); acc_edge.emplace_back(x, e);}}
        edge_range operator[](const int v) {assert(is_prepared); return {store.begin() + fir[v], store.begin() + fir[v + 1]};}
    };

    graph g;
    int V = -1;
    bool is_prepared = false;

    vec<int> lst;
    vec<int> res;
    void ifs(int v, int p = -1) {
        static int T = 0; T = p == -1 ? 0 : T;
        tin[v] = T++;
        pr[v] = p;
        sz[v] = 1;
        dep[v] = p == -1 ? 0 : dep[p] + 1;
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        jump[v] = p == -1 ? v : dep[pr[v]] + dep[jump[jump[pr[v]]]] == dep[jump[pr[v]]] * 2 ? jump[jump[pr[v]]] : pr[v];
        int old = lst[s[v]];
        res[v] = old;
        for (const auto& e : g[v]) {
            if (e.to == p) continue;
            //wdep[e.to] = wdep[v] + e.data;
            lst[s[v]] = v;
            ifs(e.to, v);
            lst[s[v]] = old;
            sz[v] += sz[e.to];
        }
        tout[v] = T;
    }

public:
    void prepare_and_root(int root_number) {
        assert(!is_prepared);
        g.prepare(); V = g.V;
        assert(g.E == (V - 1) * 2);
        pr.resize(V);
        jump.resize(V);
        dep.resize(V);
        sz.resize(V);
        tin.resize(V);
        tout.resize(V);
        res.resize(V);
        //wdep.resize(V);
        is_prepared = true;
        lst.resize(26, -1);
        reroot(root_number);
        assert(sz[root_number] == V && ""Graph is not a tree!"");
    }

    vector<int> pr;
    vector<int> jump;
    vector<int> dep;
    vector<int> sz;
    vector<int> tin, tout;
    string s;
    int root = -1;
    //vector<int64_t> wdep;

    tree() = default;
    tree(int V): V(V) {g = graph(V, (V - 1) * 2);}

    void add_edge(int x, Edge e) {assert(!is_prepared); g.add_edge(x, e, 0);}
    void reroot(int new_root) {assert(is_prepared); if (root != new_root) ifs(root = new_root);}
    edge_range operator[](const int v) {assert(is_prepared); return g[v];}
    int size() const {return V;}

    bool is_descendant(int p, int v) {assert(is_prepared); return tin[p] <= tin[v] && tout[v] <= tout[p];}
    bool is_vertex_on_path(int v, int x, int y, int lc = -1) {if (lc == -1) lc = calc_lca(x, y); return is_descendant(lc, v) && (is_descendant(v, x) || is_descendant(v, y));}
    //int64_t calc_distance_weighted(int x, int y, int lc = -1) {if (lc == -1) lc = calc_lca(x, y); return wdep[x] + wdep[y] - wdep[lc] * 2;}
    int calc_distance_unweighted(int x, int y, int lc = -1) {if (lc == -1) lc = calc_lca(x, y); return dep[x] + dep[y] - dep[lc] * 2;}
    int calc_lca(int x, int y) {assert(is_prepared); if (dep[x] > dep[y]) swap(x, y); y = calc_kth_ancestor(y, dep[y] - dep[x]); if (x == y) return x; for (; pr[x] != pr[y];) {int u1 = jump[x], u2 = jump[y]; if (u1 == u2) x = pr[x], y = pr[y]; else x = u1, y = u2;} return pr[x];}
    int calc_kth_ancestor(int v, int k) {assert(is_prepared); assert(k <= dep[v]); for (; k;) {int u = jump[v], dfd = dep[v] - dep[u]; if (dfd <= k) v = u, k -= dfd; else v = pr[v], k--;} return v;}
    int calc_kth_vertex_on_path(int x, int y, int k, int lc = -1) {if (lc == -1) lc = calc_lca(x, y); int dst = dep[x] + dep[y] - dep[lc] * 2; if (k > dst) return -1; int d1 = dep[x] - dep[lc]; if (k <= d1) return calc_kth_ancestor(x, k); return calc_kth_ancestor(y, dst - k);}
    int calc_centroid() {assert(is_prepared); int v = root; int stv = v, p = -1; for (;;) {int mxsz = -1, h = -1; for (const auto& e : (*this)[v]) {if (e.to == p) continue; if (sz[e.to] > mxsz) mxsz = sz[e.to], h = e.to;} if (mxsz <= sz[stv] / 2) return v; p = v, v = h;} return -1;}
    int calc_diameter_unweighted() {assert(is_prepared); int v = max_element(dep.begin(), dep.end()) - dep.begin(); auto dfs = [&](auto && dfs, int v, int p) -> int {int mxd = -1; for (const auto& e : g[v]) {if (e.to != p) {int tyt = dfs(dfs, e.to, v); mxd = max(mxd, tyt);}} return mxd + 1;}; return dfs(dfs, v, -1);}
    vector<int> calc_euler_traversal() {assert(is_prepared); vector<int> eul(V); int T = 0; auto dfs = [&](auto && dfs, int v, int p) -> void {eul[T++] = v; for (const auto& e : g[v]) {if (e.to == p) continue; dfs(dfs, e.to, v);}}; dfs(dfs, root, -1); return eul;}
    vector<int> calc_path_between_vertexes(int x, int y) {assert(is_prepared); vector<int> fir, sec; while (!is_descendant(x, y)) fir.push_back(x), x = pr[x]; while (x != y) sec.push_back(y), y = pr[y]; fir.push_back(x); reverse(sec.begin(), sec.end()); for (int i : sec) fir.push_back(i); return fir;}
    vector<int> calc_foreach_furthest_vertex_unweighted() {assert(is_prepared); vector<int> deepest1(V), deepest2(V, -1); auto dfs = [&](auto dfs, int v, int p = -1) -> int {deepest1[v] = v; for (const auto& e : g[v]) {if (e.to == p) continue; int tyt = dfs(dfs, e.to, v); if (dep[tyt] >= dep[deepest1[v]]) {deepest2[v] = deepest1[v]; deepest1[v] = tyt;} else if (dep[tyt] > dep[deepest2[v]]) {deepest2[v] = tyt;}} return deepest1[v];}; dfs(dfs, root); vector<int> furthest(V); auto go = [&](auto go, int v, int u = -1, int dst_to_u = -1, int p = -1) -> void {furthest[v] = dst_to_u > dep[deepest1[v]] - dep[v] ? u : deepest1[v]; for (const auto& e : g[v]) {if (e.to == p) continue; int nwu = deepest1[e.to] == deepest1[v] ? deepest2[v] : deepest1[v]; int nwd = nwu == -1 ? -1 : dep[nwu] - dep[v]; if (nwu == -1 || dst_to_u > dep[nwu] - dep[v]) nwu = u, nwd = dst_to_u; go(go, e.to, nwu, nwd + 1, v);}}; go(go, root); return furthest;}
    template<typename D> vector<int> calc_foreach_furthest_vertex_weighted() {assert(is_prepared); vector<int> deepest1(V), deepest2(V, -1); vector<D> wdep(V); auto dfs = [&](auto dfs, int v, int p = -1) -> int {deepest1[v] = v; for (const auto& e : g[v]) {if (e.to == p) continue; wdep[e.to] = wdep[v] + e.data; int tyt = dfs(dfs, e.to, v); if (wdep[tyt] >= wdep[deepest1[v]]) {deepest2[v] = deepest1[v]; deepest1[v] = tyt;} else if (wdep[tyt] > wdep[deepest2[v]]) {deepest2[v] = tyt;}} return deepest1[v];}; dfs(dfs, root); vector<int> furthest(V); auto go = [&](auto go, int v, int u = -1, D dst_to_u = -1, int p = -1) -> void {furthest[v] = dst_to_u > wdep[deepest1[v]] - wdep[v] ? u : deepest1[v]; for (const auto& e : g[v]) {if (e.to == p) continue; int nwu = deepest1[e.to] == deepest1[v] ? deepest2[v] : deepest1[v]; D nwd = nwu == -1 ? -1 : wdep[nwu] - wdep[v]; if (nwu == -1 || dst_to_u > wdep[nwu] - wdep[v]) nwu = u, nwd = dst_to_u; go(go, e.to, nwu, nwd + e.data, v);}}; go(go, root); return furthest;}
    int64_t calc_sum_of_distances_between_all_pairs_of_vertexes_unweighted() {int64_t o = 0; auto dfs = [&](auto && dfs, int v, int pr) -> void {for (const auto& e : (*this)[v]) {if (e.to == pr) continue; dfs(dfs, e.to, v); o += (int64_t)sz[e.to] * (V - sz[e.to]);}}; dfs(dfs, root, -1); return o;}
    template<typename D> D calc_sum_of_distances_between_all_pairs_of_vertexes_weighted() {D o = 0; auto dfs = [&](auto && dfs, int v, int pr) -> void {for (const auto& e : (*this)[v]) {if (e.to == pr) continue; dfs(dfs, e.to, v); o += (D)e.data * sz[e.to] * (V - sz[e.to]);}}; dfs(dfs, root, -1); return o;}
    vector<int> calc_rooted_isomorphic_subtrees_without_data_guaranteed() {vector<int> ans(V); map<vector<int>, int> mp; int cnt = 1; vector<pair<int, int>> stq = {{root, 0}}; while (stq.size()) {pair<int, int> p = stq.back(); const int pr = stq.size() == 1 ? -1 : stq[stq.size() - 2].first; int v = p.first; if (p.second < (*this)[v].size()) {++stq.back().second; if ((*this)[v][p.second].to != pr) stq.emplace_back((*this)[v][p.second].to, 0);} else {vector<int> tyt; tyt.reserve((*this)[v].size()); for (const auto& e : (*this)[v]) {if (e.to != pr) tyt.push_back(ans[e.to]);} sort(tyt.begin(), tyt.end()); int& i = mp[tyt]; if (!i) i = cnt++; ans[v] = i - 1; stq.pop_back();}} return ans;}
    vector<int> calc_prufer_code() {assert(is_prepared && V > 1); vector<int> cnt(V), pr(V); auto dfs = [&](auto && dfs, int v, int p) -> void {pr[v] = p; for (const auto& e : g[v]) {if (e.to != p) dfs(dfs, e.to, v);}}; dfs(dfs, V - 1, -1); for (int q = 0; q < V; ++q) cnt[q] = g[q].size(); vector<int> ans(V - 2); for (int q = 0, leaf = find(cnt.begin(), cnt.end(), 1) - cnt.begin(), ptr = leaf + 1; q < V - 2; ++q) {int p = pr[leaf]; ans[q] = p; --cnt[leaf]; if (--cnt[p] == 1 && p < ptr) {leaf = p;} else {for (; cnt[ptr] != 1;) ++ptr; leaf = ptr++;}} return ans;}
    pair<int, int> calc_path_intersection(int x1, int y1, int x2, int y2, int lc1 = -1, int lc2 = -1) {static constexpr pair<int, int> NO = { -1, -1}; if (lc1 == -1) lc1 = calc_lca(x1, y1); if (lc2 == -1) lc2 = calc_lca(x2, y2); if (!is_descendant(lc1, x2) && !is_descendant(lc1, y2)) return NO; if (!is_descendant(lc1, lc2)) swap(x1, x2), swap(y1, y2), swap(lc1, lc2); if (lc1 != lc2 && !is_vertex_on_path(lc2, x1, y1, lc1)) return NO; int v1 = calc_lca(x1, x2), v2 = calc_lca(x1, y2); if (v1 == lc1) v1 = calc_lca(y1, x2); if (v2 == lc1) v2 = calc_lca(y1, y2); if (tin[v1] > tin[v2]) swap(v1, v2); return {v1, v2};}
    template<typename T> vector<int> calc_maxcost_independent_set(vector<T> cost) {vector<array<T, 2>> dp(V); auto dfs = [&](auto && dfs, int v, int p) -> void {dp[v][1] = cost[v]; for (const auto& e : (*this)[v]) {if (e.to == p) continue; dfs(dfs, e.to, v); dp[v][1] += dp[e.to][0]; dp[v][0] += max(dp[e.to][0], dp[e.to][1]);}}; dfs(dfs, root, -1); vector<int> ans; auto dfs2 = [&](auto && dfs2, int v, int p, int mode) -> void {if (mode == 1) ans.push_back(v); for (const auto& e : (*this)[v]) {if (e.to == p) continue; dfs2(dfs2, e.to, v, mode ? 0 : dp[e.to][1] > dp[e.to][0]);}}; dfs2(dfs2, root, -1, dp[root][1] > dp[root][0]); return ans;}
};
//Usage: tree<edge<T>> t(V), where T is the type of info you want to store on edges, T could be void.
//Before using tree, add all edges and then call t.prepare_and_root(root_number).

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        ll a = p.size();
        tree<edge<void>> t(a);
        for (auto &c : s) c -= 'a';
        for (int q = 1; q < a; ++q) {
            t.add_edge(p[q], q);
        }
        t.s = s;
        t.prepare_and_root(0);
        tree<edge<void>> g(a);
        for (int q = 1; q < a; ++q) {
            int u = t.res[q];
            if(u==-1) u = p[q];
            g.add_edge(u, q);
        }
        g.s=s;
        g.prepare_and_root(0);
        vi o(a);
        for (int q = 0; q < a; ++q) {
            o[q] = g.sz[q];
        }
        return o;
    }
};",1434333827
Bogdan,wery0,86,3587,cpp,"#pragma GCC optimize(""Ofast"")
// #pragma GCC target(""avx,avx2,fma"")

#include ""bits/stdc++.h""

//#define NDEBUG
#define F first
#define S second
#define vec vector
#define pb push_back
#define pll pair<ll, ll>
#define pdd pair<ld, ld>
#define pii pair<int, int>
#define all(m) m.begin(), m.end()
#define rall(m) m.rbegin(), m.rend()
#define uid uniform_int_distribution
#define timeStamp() std::chrono::steady_clock::now()
#define unify(m) sort(all(m)), m.erase(unique(all(m)), m.end());
#define duration_micro(a) chrono::duration_cast<chrono::microseconds>(a).count()
#define duration_milli(a) chrono::duration_cast<chrono::milliseconds>(a).count()
#define fast cin.tie(0), cout.tie(0), cin.sync_with_stdio(0), cout.sync_with_stdio(0);
using namespace std;
using str = string;
using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
mt19937 rnd(timeStamp().time_since_epoch().count());
mt19937_64 rndll(timeStamp().time_since_epoch().count());
template<typename T, typename U> bool chmin(T& a, const U& b) {return (T)b < a ? a = b, 1 : 0;}
template<typename T, typename U> bool chmax(T& a, const U& b) {return (T)b > a ? a = b, 1 : 0;}
struct custom_hash {static uint64_t xs(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31);} template<typename T> size_t operator()(T x) const {static const uint64_t C = timeStamp().time_since_epoch().count(); return xs(hash<T> {}(x) + C);}};
template<typename K> using uset = unordered_set<K, custom_hash>;
template<typename K, typename V> using umap = unordered_map<K, V, custom_hash>;
template<typename T1, typename T2> ostream& operator<<(ostream& out, const pair<T1, T2>& x) {return out << x.F << ' ' << x.S;}
template<typename T1, typename T2> istream& operator>>(istream& in, pair<T1, T2>& x) {return in >> x.F >> x.S;}
template<typename T, size_t N> istream& operator>>(istream& in, array<T, N>& a) {for (auto &x : a) in >> x; return in;}
template<typename T, size_t N> ostream& operator<<(ostream& out, const array<T, N>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i];if (i + 1 < a.size()) out << ' ';}return out;}
template<typename T> istream& operator>>(istream& in, vector<T>& a) {for (auto& x : a) in >> x; return in;}
template<typename T> ostream& operator<<(ostream& out, const vector<T>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i]; if (i + 1 < a.size()) out << ' ';} return out;}

template<typename I> auto array_cnt(I f, I l) {umap<typename iterator_traits<I>::value_type, int> mp; while (f != l) ++mp[*f], ++f; return mp;}
template<typename I> auto subset_sum(I f, I l) {int a = l - f; vec<typename iterator_traits<I>::value_type> o(1 << a); for (int q = 1; q < (1 << a); ++q) {const int i = __builtin_ctz(q); o[q] = *(f + i) + o[q ^ (1 << i)];} return o;}
template<typename I> vec<pii> get_segs_of_eq_elems(I first, I last, function<bool(const typename iterator_traits<I>::value_type&, const typename iterator_traits<I>::value_type&)> cmp = [](const auto& l, const auto& r) {return l == r;}) {using T = typename iterator_traits<I>::value_type; vec<pii> ans; if (first == last) return ans; int l = 0, r = 1; T prev = *first; for (auto cit = next(first); cit != last; ++cit, ++r) {if (!cmp(*cit, prev)) {ans.emplace_back(l, r - 1); l = r;} prev = *cit;} ans.emplace_back(l, r - 1); return ans;}
template<typename I> int LCP(I f1, I l1, I f2, I l2) {for (int o = 0; ; ++f1, ++f2, ++o) if (f1 == l1 || f2 == l2 || *f1 != *f2) return o; return -1;}
template<typename I> int min_period(I f, I l) {int a = l - f; vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (*(f + q) == *(f + w)) m[q] = w + 1;} m[q] += !m[q] && *(f + q) == *f;} int p = a - m.back(); return a % p ? a : p;}
template<typename I> bool is_palindrome(I f, I l) {for (--l; f < l; ++f, --l) if (*f != *l) return 0; return 1;}
str from_base_10_to_base_b(ll x, ll b) {str t; if (x == 0) t = ""0""; for (; x; x /= b) t += (char)('0' + x % b); reverse(all(t)); return t;}
#define vi vec<int>
#define vl vec<ll>
#define vvi vec<vec<int>>
#define vvvi vec<vec<vec<int>>>
#define vvl vec<vec<ll>>
#define vpi vec<pii>
#define vpl vec<pll>
#define vs vec<str>
#define vvs vec<vec<str>>
const int dx[] = { -1, 0, 1, 0, -1, 1, 1, -1};
const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T> int sum_of_digits(T val) {int o = 0; for (; val; val /= 10) o += val % 10; return o;}
template<typename T> struct static_sum_query {vec<T> m; static_sum_query() = default; template<typename I>static_sum_query(I f, I l) {m.resize(l - f + 1); for (auto it = m.begin() + 1; f != l; ++f, ++it) {*it = *(it - 1) + *f;}} template<typename T_arr> static_sum_query(T_arr& m) {(*this) = static_sum_query(all(m));} inline T query(const int l, const int r) const {return m[r + 1] - m[l];}};
template<typename T> vec<pair<T, int>> zip_with_positions(vec<T> &m) {int a = m.size(); vec<pair<T, int>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q], q}; return ans;}
template<typename T> str join(vec<T> &m, str c) {str o; if constexpr(is_same<str, T>::value) {for (const T &s : m) o += s + c;} else {for (const T &s : m) o += to_string(s) + c;} if (o.size()) o.erase(o.end() - c.size(), o.end()); return o;}
vec<pii> get_reflection_points_in_rect(int a, int b, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < b); vec<pii> res = {{x, y}}; if (x != a - x - 1) res.pb({a - x - 1, y}); if (y != a - y - 1) res.pb({x, a - y - 1}); if (x != a - x - 1 && y != a - y - 1) res.pb({a - x - 1, a - y - 1}); return res;}
vec<pii> get_rotation_points_in_square(int a, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < a); vec<pii> res = {{x, y}}; if (a % 2 == 1 && x == a / 2 && y == a / 2) return res; res.pb({a - y - 1, x}); res.pb({a - x - 1, a - y - 1}); res.pb({y, a - x - 1}); return res;}
template<typename T> vec<vec<int>> get_cycles_of_perm(vec<T> &m, int permutation_indexation) {int a = m.size(); vec<vec<int>> ans; vec<bool> us(a); for (int q = 0; q < a; ++q) {if (us[q]) continue; vec<int> tyt; for (int w = q; !us[w]; w = m[w] - permutation_indexation) {tyt.pb(w); us[w] = 1;} ans.pb(tyt);} return ans;}
int find_closing_bracket(str &s, int i) {char op = s[i], cl = op == '(' ? ')' : op == '{' ? '}' : op == '[' ? ']' : op == '<' ? '>' : '@'; assert(cl != '@'); int dep = 1; for (int q = i + 1; q < s.size(); ++q) {dep += s[q] == op ? 1 : s[q] == cl ? -1 : 0; if (dep == 0) return q;} return -1;}
template<typename T> vec<pair<T, T>> vv_to_vp(vec<vec<T>> &m) {int a = m.size(); vec<pair<T, T>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q][0], m[q][1]}; return ans;}
template<const int k, typename T> vec<array<T, k>> vv_to_varr(vec<vec<T>> &m) {int a = m.size(); vec<array<T, k>> ans(a); for (int q = 0; q < a; ++q) for (int w = 0; w < k; ++w) ans[q][w] = m[q][w]; return ans;}
str from_base_10_to_base_b(str x, ll b) {return from_base_10_to_base_b(stoll(x), b);}
ll from_base_b_to_base_10(str x, ll b) {ll o = 0, pw = 1; for (int q = x.size() - 1; q >= 0; --q, pw *= b) o += (x[q] - '0') * pw; return o;}
str from_base_a_to_base_b(str x, ll a, ll b) {ll x10 = from_base_b_to_base_10(x, a); return from_base_10_to_base_b(x10, b);}
template<typename T> T binpow(T x, T k) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x; x = x * x;} return o;}
template<typename T> T binpow_mod(T x, T k, T mod) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x % mod; x = x * x % mod;} return o;}
template<typename T> T ar_prog_sum_fcl(T first, T cnt, T last) {return (first + last) * cnt / 2;}
template<typename T> T ar_prog_sum_fdc(T first, T diff, T cnt) {return (first * 2 + diff * (cnt - 1)) * cnt / 2;}
template<typename T> T ar_prog_sum_fdl(T first, T diff, T last) {return (first + last) * ((last - first) / diff + 1) / 2;}
template<typename T> T geom_prog_sum_fdl(T first, T diff, T last) {return (last * diff - first) / (diff - 1);}
template<typename T> T geom_prog_sum_fdc(T first, T diff, T cnt) {return (first * binpow(diff, cnt) - first) / (diff - 1);}
template<typename T> vec<vec<T>> transpose_matrix(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int q = 0; q < a; ++q) {for (int w = 0; w < b; ++w) {ans[w][q] = m[q][w];}} return ans;}
template<typename T> vec<vec<T>> rotate_matrix_cw(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int w = 0; w < b; ++w) for (int q = 0; q < a; ++q) ans[w][q] = m[a - 1 - q][w]; return ans;}
complex<ll> str_to_cmpl_ll(str t) {int ps = t.find('+'), sgn = 1; if (ps == string::npos) {ps = t.find('-'); sgn = -1; assert(ps != string::npos);} str t1 = t.substr(0, ps), t2 = t.substr(ps + 1); assert(t2.back() == 'i'); t2.pop_back(); return {stoll(t1), stoll(t2) * sgn};}
int time_to_minutes(int h, int m) {return h * 60 + m;}
int time_to_minutes(str s) {int ps = s.find(':'); assert(ps != string::npos); return time_to_minutes(stoi(s.substr(0, ps)), stoi(s.substr(ps + 1)));}
str minutes_to_time(int m, bool h0 = true, bool m0 = true) {int h = m / 60; m %= 60; str o; if (h0) o += (h < 10 ? ""0"" : """"); o += to_string(h); o += ':'; if (m0) o += (m < 10 ? ""0"" : """"); o += to_string(m); return o;}
bool is_vowel_lowercase(char c) {return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';}
bool is_consonant_lowercase(char c) {return !is_vowel_lowercase(c);}
ull leq_pow2ll(const ull x) {return 1ull << __lg(x);}
ull geq_pow2ll(const ull x) {return x & (x - 1) ? 2ull << __lg(x) : x;}
ll sqd(const pll p1, const pll p2) {return (p1.F - p2.F) * (p1.F - p2.F) + (p1.S - p2.S) * (p1.S - p2.S);}
ll sqd(const ll x1, const ll y1, const ll x2, const ll y2) {return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);}
template<typename T> int sign(T x) {return x < 0 ? -1 : x > 0 ? 1 : 0;}
template<typename I> bool is_subsequence(I f_pattern, I l_pattern, I f_text, I l_text) {for (; f_text != l_text && f_pattern != l_pattern; ++f_text) if (*f_text == *f_pattern) ++f_pattern; return f_pattern == l_pattern;}
template<typename T> auto C = []() {const size_t N = 67; array<array<T, N>, N> C{0}; C[0][0] = 1; for (size_t i = 1; i < N; ++i) {C[i][0] = 1; for (size_t j = 1; j <= i; ++j) {C[i][j] = C[i - 1][j - 1] + C[i - 1][j];}} return C;}();
vec<ll> get_divisors(ll x) {vec<ll> ans1, ans2; for (ll q = 1; q * q <= x; ++q) {if (x % q == 0) {ans1.pb(q); ans2.pb(x / q);}} if (ans1.back() == ans2.back()) ans1.pop_back(); reverse(all(ans2)); for (ll i : ans2) ans1.pb(i); return ans1;}
bool is_prime(ll c) {if (c < 2) return 0; if (c == 2 || c == 3) return 1; if (c % 2 == 0 || c % 3 == 0) return 0; const ll gr = sqrtl(c) + 1; for (ll q = 6; q <= gr; q += 6) {if (c % (q - 1) == 0) return 0; if (c % (q + 1) == 0) return 0;} return 1;}
vec<str> split(str &s, char c, bool ignore_empty = false) {vec<str> o; str u; for (int q = 0; q < s.size(); q++) {if (s[q] == c) {if (!u.empty() || !ignore_empty) o.pb(u); u.clear();} else u += s[q];} if (!u.empty() || !ignore_empty) o.pb(u); return o;}
int replace(str &s, str from, str to) {str t = from; t.pb(0); t += s; int a = t.size(); vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (t[q] == t[w]) m[q] = w + 1;} m[q] += !m[q] && t[q] == t[0];} int szf = from.size(), lst = szf; for (int q = szf; q < t.size(); ++q) {if (m[q] == szf && q - lst >= szf) {m[q - szf + 1] = -1; lst = q;}} str ans; int o = 0; for (int q = szf + 1; q < t.size(); ++q) {if (m[q] != -1) ans += t[q]; else ans += to, q += szf - 1, ++o;} s = ans; return o;}
template<typename T> T mul_threshold(T a, T b, T threshold) {if (!a || !b || !threshold) return 0; assert(a > 0 && b > 0); T max_b = threshold / a; return b <= max_b ? a * b : threshold;}
template<typename T> T count_set_bits_pref(T n, int b) {assert(0 <= n); T pw = (T)(1) << b; if (pw > n) return 0; T period = pw * 2; T full = (n + 1) / period; T rem = (n + 1) & (period - 1); return full * pw + (rem < pw ? 0 : rem - pw);}
template<typename T> T count_set_bits_seg(T l, T r, int b) {assert(0 <= l && l <= r); return count_set_bits_pref(r, b) - (l ? count_set_bits_pref(l - 1, b) : 0);}
template<typename I> vector<int> get_substring_occurrences(I f_pattern, I l_pattern, I f_text, I l_text) {const size_t n = std::distance(f_pattern, l_pattern); const size_t m = std::distance(f_text, l_text); assert(n); auto cmp = [&](size_t i, size_t j) {if (i == n || j == n) return i == j; return (i < n ? *(f_pattern + i) : *(f_text + i - n - 1)) == (j < n ? * (f_pattern + j) : * (f_text + j - n - 1));}; vector<int> pf(n), res; for (size_t i = 1, ppf = 0; i < n + 1 + m; ++i) {size_t p = 0; for (size_t j = ppf; j && !p; j = pf[j - 1]) {if (cmp(i, j)) p = j + 1;} p += !p && cmp(i, 0); ppf = p; if (i < n) pf[i] = p; if (p == n) res.push_back(i - n * 2);} return res;}
template<typename T> T integral_tersearch_argmin(auto f, T l, T r) {static_assert(is_integral_v<decltype(l)>); using U = decltype(f(l)); const ld FI = 1.6180339887498948482045868343656381177203; T p1 = l + (r - l) / (FI + 1), p2 = r - (r - l) / (FI + 1); U v1 = f(p1), v2 = f(p2); while (r - l > 7) {if (v1 < v2) {r = p2; p2 = p1, v2 = v1; p1 = l + (r - l) / (FI + 1), v1 = f(p1);} else {l = p1; p1 = p2, v1 = v2; p2 = r - (r - l) / (FI + 1), v2 = f(p2);}} T best_arg = l; U best_val = f(l), prv = best_val; while (++l <= r) {U tyt = l == p1 ? v1 : l == p2 ? v2 : f(l); if (tyt > prv) break; if (chmin(best_val, tyt)) best_arg = l; prv = tyt;} return best_arg;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l, T r) {static_assert(is_same<decltype(l), decltype(r)>::value); while (l + 1 < r) {T md = l + (r - l) / 2; if (f(md))l = md; else r = md;} return l;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l) {T d = 1; while (f(l + d)) d *= 2; d /= 2; for (T u = d; u; u /= 2) if (f(l + d + u)) d += u; return l + d;};
template<typename T> T get_kth_statistic_by_binary_search(T n, T k, T val_l, T val_r, auto cnt_leq) {assert(0 <= k && k < n); assert(val_l <= val_r); return integral_binary_search_last_when_true<T>([&](T x){return cnt_leq(x) <= k;}, val_l - 1, val_r) + 1;}

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vec<ll> dp(n);
        for (int d = 0; d < k; ++d) {
            vec<ll> ndp(n);
            for (int i = 0; i < n; ++i) {
                ndp[i] = dp[i] + stayScore[d][i];
                for (int j = 0; j < n; ++j) {
                    if(j == i) continue;
                    chmax(ndp[i], dp[j] + travelScore[j][i]);
                }
            }
            dp = ndp;
        }
        return *max_element(all(dp));
    }
};",1434305298
Bogdan,wery0,86,3617,cpp,"#pragma GCC optimize(""Ofast"")
// #pragma GCC target(""avx,avx2,fma"")

#include ""bits/stdc++.h""

//#define NDEBUG
#define F first
#define S second
#define vec vector
#define pb push_back
#define pll pair<ll, ll>
#define pdd pair<ld, ld>
#define pii pair<int, int>
#define all(m) m.begin(), m.end()
#define rall(m) m.rbegin(), m.rend()
#define uid uniform_int_distribution
#define timeStamp() std::chrono::steady_clock::now()
#define unify(m) sort(all(m)), m.erase(unique(all(m)), m.end());
#define duration_micro(a) chrono::duration_cast<chrono::microseconds>(a).count()
#define duration_milli(a) chrono::duration_cast<chrono::milliseconds>(a).count()
#define fast cin.tie(0), cout.tie(0), cin.sync_with_stdio(0), cout.sync_with_stdio(0);
using namespace std;
using str = string;
using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
mt19937 rnd(timeStamp().time_since_epoch().count());
mt19937_64 rndll(timeStamp().time_since_epoch().count());
template<typename T, typename U> bool chmin(T& a, const U& b) {return (T)b < a ? a = b, 1 : 0;}
template<typename T, typename U> bool chmax(T& a, const U& b) {return (T)b > a ? a = b, 1 : 0;}
struct custom_hash {static uint64_t xs(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31);} template<typename T> size_t operator()(T x) const {static const uint64_t C = timeStamp().time_since_epoch().count(); return xs(hash<T> {}(x) + C);}};
template<typename K> using uset = unordered_set<K, custom_hash>;
template<typename K, typename V> using umap = unordered_map<K, V, custom_hash>;
template<typename T1, typename T2> ostream& operator<<(ostream& out, const pair<T1, T2>& x) {return out << x.F << ' ' << x.S;}
template<typename T1, typename T2> istream& operator>>(istream& in, pair<T1, T2>& x) {return in >> x.F >> x.S;}
template<typename T, size_t N> istream& operator>>(istream& in, array<T, N>& a) {for (auto &x : a) in >> x; return in;}
template<typename T, size_t N> ostream& operator<<(ostream& out, const array<T, N>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i];if (i + 1 < a.size()) out << ' ';}return out;}
template<typename T> istream& operator>>(istream& in, vector<T>& a) {for (auto& x : a) in >> x; return in;}
template<typename T> ostream& operator<<(ostream& out, const vector<T>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i]; if (i + 1 < a.size()) out << ' ';} return out;}

template<typename I> auto array_cnt(I f, I l) {umap<typename iterator_traits<I>::value_type, int> mp; while (f != l) ++mp[*f], ++f; return mp;}
template<typename I> auto subset_sum(I f, I l) {int a = l - f; vec<typename iterator_traits<I>::value_type> o(1 << a); for (int q = 1; q < (1 << a); ++q) {const int i = __builtin_ctz(q); o[q] = *(f + i) + o[q ^ (1 << i)];} return o;}
template<typename I> vec<pii> get_segs_of_eq_elems(I first, I last, function<bool(const typename iterator_traits<I>::value_type&, const typename iterator_traits<I>::value_type&)> cmp = [](const auto& l, const auto& r) {return l == r;}) {using T = typename iterator_traits<I>::value_type; vec<pii> ans; if (first == last) return ans; int l = 0, r = 1; T prev = *first; for (auto cit = next(first); cit != last; ++cit, ++r) {if (!cmp(*cit, prev)) {ans.emplace_back(l, r - 1); l = r;} prev = *cit;} ans.emplace_back(l, r - 1); return ans;}
template<typename I> int LCP(I f1, I l1, I f2, I l2) {for (int o = 0; ; ++f1, ++f2, ++o) if (f1 == l1 || f2 == l2 || *f1 != *f2) return o; return -1;}
template<typename I> int min_period(I f, I l) {int a = l - f; vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (*(f + q) == *(f + w)) m[q] = w + 1;} m[q] += !m[q] && *(f + q) == *f;} int p = a - m.back(); return a % p ? a : p;}
template<typename I> bool is_palindrome(I f, I l) {for (--l; f < l; ++f, --l) if (*f != *l) return 0; return 1;}
str from_base_10_to_base_b(ll x, ll b) {str t; if (x == 0) t = ""0""; for (; x; x /= b) t += (char)('0' + x % b); reverse(all(t)); return t;}
#define vi vec<int>
#define vl vec<ll>
#define vvi vec<vec<int>>
#define vvvi vec<vec<vec<int>>>
#define vvl vec<vec<ll>>
#define vpi vec<pii>
#define vpl vec<pll>
#define vs vec<str>
#define vvs vec<vec<str>>
const int dx[] = { -1, 0, 1, 0, -1, 1, 1, -1};
const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T> int sum_of_digits(T val) {int o = 0; for (; val; val /= 10) o += val % 10; return o;}
template<typename T> struct static_sum_query {vec<T> m; static_sum_query() = default; template<typename I>static_sum_query(I f, I l) {m.resize(l - f + 1); for (auto it = m.begin() + 1; f != l; ++f, ++it) {*it = *(it - 1) + *f;}} template<typename T_arr> static_sum_query(T_arr& m) {(*this) = static_sum_query(all(m));} inline T query(const int l, const int r) const {return m[r + 1] - m[l];}};
template<typename T> vec<pair<T, int>> zip_with_positions(vec<T> &m) {int a = m.size(); vec<pair<T, int>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q], q}; return ans;}
template<typename T> str join(vec<T> &m, str c) {str o; if constexpr(is_same<str, T>::value) {for (const T &s : m) o += s + c;} else {for (const T &s : m) o += to_string(s) + c;} if (o.size()) o.erase(o.end() - c.size(), o.end()); return o;}
vec<pii> get_reflection_points_in_rect(int a, int b, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < b); vec<pii> res = {{x, y}}; if (x != a - x - 1) res.pb({a - x - 1, y}); if (y != a - y - 1) res.pb({x, a - y - 1}); if (x != a - x - 1 && y != a - y - 1) res.pb({a - x - 1, a - y - 1}); return res;}
vec<pii> get_rotation_points_in_square(int a, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < a); vec<pii> res = {{x, y}}; if (a % 2 == 1 && x == a / 2 && y == a / 2) return res; res.pb({a - y - 1, x}); res.pb({a - x - 1, a - y - 1}); res.pb({y, a - x - 1}); return res;}
template<typename T> vec<vec<int>> get_cycles_of_perm(vec<T> &m, int permutation_indexation) {int a = m.size(); vec<vec<int>> ans; vec<bool> us(a); for (int q = 0; q < a; ++q) {if (us[q]) continue; vec<int> tyt; for (int w = q; !us[w]; w = m[w] - permutation_indexation) {tyt.pb(w); us[w] = 1;} ans.pb(tyt);} return ans;}
int find_closing_bracket(str &s, int i) {char op = s[i], cl = op == '(' ? ')' : op == '{' ? '}' : op == '[' ? ']' : op == '<' ? '>' : '@'; assert(cl != '@'); int dep = 1; for (int q = i + 1; q < s.size(); ++q) {dep += s[q] == op ? 1 : s[q] == cl ? -1 : 0; if (dep == 0) return q;} return -1;}
template<typename T> vec<pair<T, T>> vv_to_vp(vec<vec<T>> &m) {int a = m.size(); vec<pair<T, T>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q][0], m[q][1]}; return ans;}
template<const int k, typename T> vec<array<T, k>> vv_to_varr(vec<vec<T>> &m) {int a = m.size(); vec<array<T, k>> ans(a); for (int q = 0; q < a; ++q) for (int w = 0; w < k; ++w) ans[q][w] = m[q][w]; return ans;}
str from_base_10_to_base_b(str x, ll b) {return from_base_10_to_base_b(stoll(x), b);}
ll from_base_b_to_base_10(str x, ll b) {ll o = 0, pw = 1; for (int q = x.size() - 1; q >= 0; --q, pw *= b) o += (x[q] - '0') * pw; return o;}
str from_base_a_to_base_b(str x, ll a, ll b) {ll x10 = from_base_b_to_base_10(x, a); return from_base_10_to_base_b(x10, b);}
template<typename T> T binpow(T x, T k) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x; x = x * x;} return o;}
template<typename T> T binpow_mod(T x, T k, T mod) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x % mod; x = x * x % mod;} return o;}
template<typename T> T ar_prog_sum_fcl(T first, T cnt, T last) {return (first + last) * cnt / 2;}
template<typename T> T ar_prog_sum_fdc(T first, T diff, T cnt) {return (first * 2 + diff * (cnt - 1)) * cnt / 2;}
template<typename T> T ar_prog_sum_fdl(T first, T diff, T last) {return (first + last) * ((last - first) / diff + 1) / 2;}
template<typename T> T geom_prog_sum_fdl(T first, T diff, T last) {return (last * diff - first) / (diff - 1);}
template<typename T> T geom_prog_sum_fdc(T first, T diff, T cnt) {return (first * binpow(diff, cnt) - first) / (diff - 1);}
template<typename T> vec<vec<T>> transpose_matrix(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int q = 0; q < a; ++q) {for (int w = 0; w < b; ++w) {ans[w][q] = m[q][w];}} return ans;}
template<typename T> vec<vec<T>> rotate_matrix_cw(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int w = 0; w < b; ++w) for (int q = 0; q < a; ++q) ans[w][q] = m[a - 1 - q][w]; return ans;}
complex<ll> str_to_cmpl_ll(str t) {int ps = t.find('+'), sgn = 1; if (ps == string::npos) {ps = t.find('-'); sgn = -1; assert(ps != string::npos);} str t1 = t.substr(0, ps), t2 = t.substr(ps + 1); assert(t2.back() == 'i'); t2.pop_back(); return {stoll(t1), stoll(t2) * sgn};}
int time_to_minutes(int h, int m) {return h * 60 + m;}
int time_to_minutes(str s) {int ps = s.find(':'); assert(ps != string::npos); return time_to_minutes(stoi(s.substr(0, ps)), stoi(s.substr(ps + 1)));}
str minutes_to_time(int m, bool h0 = true, bool m0 = true) {int h = m / 60; m %= 60; str o; if (h0) o += (h < 10 ? ""0"" : """"); o += to_string(h); o += ':'; if (m0) o += (m < 10 ? ""0"" : """"); o += to_string(m); return o;}
bool is_vowel_lowercase(char c) {return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';}
bool is_consonant_lowercase(char c) {return !is_vowel_lowercase(c);}
ull leq_pow2ll(const ull x) {return 1ull << __lg(x);}
ull geq_pow2ll(const ull x) {return x & (x - 1) ? 2ull << __lg(x) : x;}
ll sqd(const pll p1, const pll p2) {return (p1.F - p2.F) * (p1.F - p2.F) + (p1.S - p2.S) * (p1.S - p2.S);}
ll sqd(const ll x1, const ll y1, const ll x2, const ll y2) {return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);}
template<typename T> int sign(T x) {return x < 0 ? -1 : x > 0 ? 1 : 0;}
template<typename I> bool is_subsequence(I f_pattern, I l_pattern, I f_text, I l_text) {for (; f_text != l_text && f_pattern != l_pattern; ++f_text) if (*f_text == *f_pattern) ++f_pattern; return f_pattern == l_pattern;}
template<typename T> auto C = []() {const size_t N = 67; array<array<T, N>, N> C{0}; C[0][0] = 1; for (size_t i = 1; i < N; ++i) {C[i][0] = 1; for (size_t j = 1; j <= i; ++j) {C[i][j] = C[i - 1][j - 1] + C[i - 1][j];}} return C;}();
vec<ll> get_divisors(ll x) {vec<ll> ans1, ans2; for (ll q = 1; q * q <= x; ++q) {if (x % q == 0) {ans1.pb(q); ans2.pb(x / q);}} if (ans1.back() == ans2.back()) ans1.pop_back(); reverse(all(ans2)); for (ll i : ans2) ans1.pb(i); return ans1;}
bool is_prime(ll c) {if (c < 2) return 0; if (c == 2 || c == 3) return 1; if (c % 2 == 0 || c % 3 == 0) return 0; const ll gr = sqrtl(c) + 1; for (ll q = 6; q <= gr; q += 6) {if (c % (q - 1) == 0) return 0; if (c % (q + 1) == 0) return 0;} return 1;}
vec<str> split(str &s, char c, bool ignore_empty = false) {vec<str> o; str u; for (int q = 0; q < s.size(); q++) {if (s[q] == c) {if (!u.empty() || !ignore_empty) o.pb(u); u.clear();} else u += s[q];} if (!u.empty() || !ignore_empty) o.pb(u); return o;}
int replace(str &s, str from, str to) {str t = from; t.pb(0); t += s; int a = t.size(); vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (t[q] == t[w]) m[q] = w + 1;} m[q] += !m[q] && t[q] == t[0];} int szf = from.size(), lst = szf; for (int q = szf; q < t.size(); ++q) {if (m[q] == szf && q - lst >= szf) {m[q - szf + 1] = -1; lst = q;}} str ans; int o = 0; for (int q = szf + 1; q < t.size(); ++q) {if (m[q] != -1) ans += t[q]; else ans += to, q += szf - 1, ++o;} s = ans; return o;}
template<typename T> T mul_threshold(T a, T b, T threshold) {if (!a || !b || !threshold) return 0; assert(a > 0 && b > 0); T max_b = threshold / a; return b <= max_b ? a * b : threshold;}
template<typename T> T count_set_bits_pref(T n, int b) {assert(0 <= n); T pw = (T)(1) << b; if (pw > n) return 0; T period = pw * 2; T full = (n + 1) / period; T rem = (n + 1) & (period - 1); return full * pw + (rem < pw ? 0 : rem - pw);}
template<typename T> T count_set_bits_seg(T l, T r, int b) {assert(0 <= l && l <= r); return count_set_bits_pref(r, b) - (l ? count_set_bits_pref(l - 1, b) : 0);}
template<typename I> vector<int> get_substring_occurrences(I f_pattern, I l_pattern, I f_text, I l_text) {const size_t n = std::distance(f_pattern, l_pattern); const size_t m = std::distance(f_text, l_text); assert(n); auto cmp = [&](size_t i, size_t j) {if (i == n || j == n) return i == j; return (i < n ? *(f_pattern + i) : *(f_text + i - n - 1)) == (j < n ? * (f_pattern + j) : * (f_text + j - n - 1));}; vector<int> pf(n), res; for (size_t i = 1, ppf = 0; i < n + 1 + m; ++i) {size_t p = 0; for (size_t j = ppf; j && !p; j = pf[j - 1]) {if (cmp(i, j)) p = j + 1;} p += !p && cmp(i, 0); ppf = p; if (i < n) pf[i] = p; if (p == n) res.push_back(i - n * 2);} return res;}
template<typename T> T integral_tersearch_argmin(auto f, T l, T r) {static_assert(is_integral_v<decltype(l)>); using U = decltype(f(l)); const ld FI = 1.6180339887498948482045868343656381177203; T p1 = l + (r - l) / (FI + 1), p2 = r - (r - l) / (FI + 1); U v1 = f(p1), v2 = f(p2); while (r - l > 7) {if (v1 < v2) {r = p2; p2 = p1, v2 = v1; p1 = l + (r - l) / (FI + 1), v1 = f(p1);} else {l = p1; p1 = p2, v1 = v2; p2 = r - (r - l) / (FI + 1), v2 = f(p2);}} T best_arg = l; U best_val = f(l), prv = best_val; while (++l <= r) {U tyt = l == p1 ? v1 : l == p2 ? v2 : f(l); if (tyt > prv) break; if (chmin(best_val, tyt)) best_arg = l; prv = tyt;} return best_arg;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l, T r) {static_assert(is_same<decltype(l), decltype(r)>::value); while (l + 1 < r) {T md = l + (r - l) / 2; if (f(md))l = md; else r = md;} return l;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l) {T d = 1; while (f(l + d)) d *= 2; d /= 2; for (T u = d; u; u /= 2) if (f(l + d + u)) d += u; return l + d;};
template<typename T> T get_kth_statistic_by_binary_search(T n, T k, T val_l, T val_r, auto cnt_leq) {assert(0 <= k && k < n); assert(val_l <= val_r); return integral_binary_search_last_when_true<T>([&](T x){return cnt_leq(x) <= k;}, val_l - 1, val_r) + 1;}

class Solution {
public:
    int possibleStringCount(string s) {
        int o = 1;
        for (auto [l, r] : get_segs_of_eq_elems(all(s))) {
            o += r - l;
        } 
        return o;
    }
};",1434305786
Bogdan,wery0,86,3618,cpp,"#pragma GCC optimize(""Ofast"")
// #pragma GCC target(""avx,avx2,fma"")

#include ""bits/stdc++.h""

//#define NDEBUG
#define F first
#define S second
#define vec vector
#define pb push_back
#define pll pair<ll, ll>
#define pdd pair<ld, ld>
#define pii pair<int, int>
#define all(m) m.begin(), m.end()
#define rall(m) m.rbegin(), m.rend()
#define uid uniform_int_distribution
#define timeStamp() std::chrono::steady_clock::now()
#define unify(m) sort(all(m)), m.erase(unique(all(m)), m.end());
#define duration_micro(a) chrono::duration_cast<chrono::microseconds>(a).count()
#define duration_milli(a) chrono::duration_cast<chrono::milliseconds>(a).count()
#define fast cin.tie(0), cout.tie(0), cin.sync_with_stdio(0), cout.sync_with_stdio(0);
using namespace std;
using str = string;
using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
mt19937 rnd(timeStamp().time_since_epoch().count());
mt19937_64 rndll(timeStamp().time_since_epoch().count());
template<typename T, typename U> bool chmin(T& a, const U& b) {return (T)b < a ? a = b, 1 : 0;}
template<typename T, typename U> bool chmax(T& a, const U& b) {return (T)b > a ? a = b, 1 : 0;}
struct custom_hash {static uint64_t xs(uint64_t x) {x += 0x9e3779b97f4a7c15; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x >> 27)) * 0x94d049bb133111eb; return x ^ (x >> 31);} template<typename T> size_t operator()(T x) const {static const uint64_t C = timeStamp().time_since_epoch().count(); return xs(hash<T> {}(x) + C);}};
template<typename K> using uset = unordered_set<K, custom_hash>;
template<typename K, typename V> using umap = unordered_map<K, V, custom_hash>;
template<typename T1, typename T2> ostream& operator<<(ostream& out, const pair<T1, T2>& x) {return out << x.F << ' ' << x.S;}
template<typename T1, typename T2> istream& operator>>(istream& in, pair<T1, T2>& x) {return in >> x.F >> x.S;}
template<typename T, size_t N> istream& operator>>(istream& in, array<T, N>& a) {for (auto &x : a) in >> x; return in;}
template<typename T, size_t N> ostream& operator<<(ostream& out, const array<T, N>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i]; if (i + 1 < a.size()) out << ' ';} return out;}
template<typename T> istream& operator>>(istream& in, vector<T>& a) {for (auto& x : a) in >> x; return in;}
template<typename T> ostream& operator<<(ostream& out, const vector<T>& a) {for (size_t i = 0; i < a.size(); ++i) {out << a[i]; if (i + 1 < a.size()) out << ' ';} return out;}

template<typename I> auto array_cnt(I f, I l) {umap<typename iterator_traits<I>::value_type, int> mp; while (f != l) ++mp[*f], ++f; return mp;}
template<typename I> auto subset_sum(I f, I l) {int a = l - f; vec<typename iterator_traits<I>::value_type> o(1 << a); for (int q = 1; q < (1 << a); ++q) {const int i = __builtin_ctz(q); o[q] = *(f + i) + o[q ^ (1 << i)];} return o;}
template<typename I> vec<pii> get_segs_of_eq_elems(I first, I last, function<bool(const typename iterator_traits<I>::value_type&, const typename iterator_traits<I>::value_type&)> cmp = [](const auto& l, const auto& r) {return l == r;}) {using T = typename iterator_traits<I>::value_type; vec<pii> ans; if (first == last) return ans; int l = 0, r = 1; T prev = *first; for (auto cit = next(first); cit != last; ++cit, ++r) {if (!cmp(*cit, prev)) {ans.emplace_back(l, r - 1); l = r;} prev = *cit;} ans.emplace_back(l, r - 1); return ans;}
template<typename I> int LCP(I f1, I l1, I f2, I l2) {for (int o = 0; ; ++f1, ++f2, ++o) if (f1 == l1 || f2 == l2 || *f1 != *f2) return o; return -1;}
template<typename I> int min_period(I f, I l) {int a = l - f; vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (*(f + q) == *(f + w)) m[q] = w + 1;} m[q] += !m[q] && *(f + q) == *f;} int p = a - m.back(); return a % p ? a : p;}
template<typename I> bool is_palindrome(I f, I l) {for (--l; f < l; ++f, --l) if (*f != *l) return 0; return 1;}
str from_base_10_to_base_b(ll x, ll b) {str t; if (x == 0) t = ""0""; for (; x; x /= b) t += (char)('0' + x % b); reverse(all(t)); return t;}
#define vi vec<int>
#define vl vec<ll>
#define vvi vec<vec<int>>
#define vvvi vec<vec<vec<int>>>
#define vvl vec<vec<ll>>
#define vpi vec<pii>
#define vpl vec<pll>
#define vs vec<str>
#define vvs vec<vec<str>>
const int dx[] = { -1, 0, 1, 0, -1, 1, 1, -1};
const int dy[] = {0, 1, 0, -1, 1, 1, -1, -1};
template<typename T> int sum_of_digits(T val) {int o = 0; for (; val; val /= 10) o += val % 10; return o;}
template<typename T> struct static_sum_query {vec<T> m; static_sum_query() = default; template<typename I>static_sum_query(I f, I l) {m.resize(l - f + 1); for (auto it = m.begin() + 1; f != l; ++f, ++it) {*it = *(it - 1) + *f;}} template<typename T_arr> static_sum_query(T_arr& m) {(*this) = static_sum_query(all(m));} inline T query(const int l, const int r) const {return m[r + 1] - m[l];}};
template<typename T> vec<pair<T, int>> zip_with_positions(vec<T> &m) {int a = m.size(); vec<pair<T, int>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q], q}; return ans;}
template<typename T> str join(vec<T> &m, str c) {str o; if constexpr(is_same<str, T>::value) {for (const T &s : m) o += s + c;} else {for (const T &s : m) o += to_string(s) + c;} if (o.size()) o.erase(o.end() - c.size(), o.end()); return o;}
vec<pii> get_reflection_points_in_rect(int a, int b, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < b); vec<pii> res = {{x, y}}; if (x != a - x - 1) res.pb({a - x - 1, y}); if (y != a - y - 1) res.pb({x, a - y - 1}); if (x != a - x - 1 && y != a - y - 1) res.pb({a - x - 1, a - y - 1}); return res;}
vec<pii> get_rotation_points_in_square(int a, int x, int y) {assert(0 <= x && x < a); assert(0 <= y && y < a); vec<pii> res = {{x, y}}; if (a % 2 == 1 && x == a / 2 && y == a / 2) return res; res.pb({a - y - 1, x}); res.pb({a - x - 1, a - y - 1}); res.pb({y, a - x - 1}); return res;}
template<typename T> vec<vec<int>> get_cycles_of_perm(vec<T> &m, int permutation_indexation) {int a = m.size(); vec<vec<int>> ans; vec<bool> us(a); for (int q = 0; q < a; ++q) {if (us[q]) continue; vec<int> tyt; for (int w = q; !us[w]; w = m[w] - permutation_indexation) {tyt.pb(w); us[w] = 1;} ans.pb(tyt);} return ans;}
int find_closing_bracket(str &s, int i) {char op = s[i], cl = op == '(' ? ')' : op == '{' ? '}' : op == '[' ? ']' : op == '<' ? '>' : '@'; assert(cl != '@'); int dep = 1; for (int q = i + 1; q < s.size(); ++q) {dep += s[q] == op ? 1 : s[q] == cl ? -1 : 0; if (dep == 0) return q;} return -1;}
template<typename T> vec<pair<T, T>> vv_to_vp(vec<vec<T>> &m) {int a = m.size(); vec<pair<T, T>> ans(a); for (int q = 0; q < a; ++q) ans[q] = {m[q][0], m[q][1]}; return ans;}
template<const int k, typename T> vec<array<T, k>> vv_to_varr(vec<vec<T>> &m) {int a = m.size(); vec<array<T, k>> ans(a); for (int q = 0; q < a; ++q) for (int w = 0; w < k; ++w) ans[q][w] = m[q][w]; return ans;}
str from_base_10_to_base_b(str x, ll b) {return from_base_10_to_base_b(stoll(x), b);}
ll from_base_b_to_base_10(str x, ll b) {ll o = 0, pw = 1; for (int q = x.size() - 1; q >= 0; --q, pw *= b) o += (x[q] - '0') * pw; return o;}
str from_base_a_to_base_b(str x, ll a, ll b) {ll x10 = from_base_b_to_base_10(x, a); return from_base_10_to_base_b(x10, b);}
template<typename T> T binpow(T x, T k) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x; x = x * x;} return o;}
template<typename T> T binpow_mod(T x, T k, T mod) {if (k < 0) return 0; T o = 1; for (; k; k >>= 1) {if (k & 1) o = o * x % mod; x = x * x % mod;} return o;}
template<typename T> T ar_prog_sum_fcl(T first, T cnt, T last) {return (first + last) * cnt / 2;}
template<typename T> T ar_prog_sum_fdc(T first, T diff, T cnt) {return (first * 2 + diff * (cnt - 1)) * cnt / 2;}
template<typename T> T ar_prog_sum_fdl(T first, T diff, T last) {return (first + last) * ((last - first) / diff + 1) / 2;}
template<typename T> T geom_prog_sum_fdl(T first, T diff, T last) {return (last * diff - first) / (diff - 1);}
template<typename T> T geom_prog_sum_fdc(T first, T diff, T cnt) {return (first * binpow(diff, cnt) - first) / (diff - 1);}
template<typename T> vec<vec<T>> transpose_matrix(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int q = 0; q < a; ++q) {for (int w = 0; w < b; ++w) {ans[w][q] = m[q][w];}} return ans;}
template<typename T> vec<vec<T>> rotate_matrix_cw(vec<vec<T>> &m) {int a = m.size(), b = a ? m[0].size() : 0; vec<vec<T>> ans(b, vec<T>(a)); for (int w = 0; w < b; ++w) for (int q = 0; q < a; ++q) ans[w][q] = m[a - 1 - q][w]; return ans;}
complex<ll> str_to_cmpl_ll(str t) {int ps = t.find('+'), sgn = 1; if (ps == string::npos) {ps = t.find('-'); sgn = -1; assert(ps != string::npos);} str t1 = t.substr(0, ps), t2 = t.substr(ps + 1); assert(t2.back() == 'i'); t2.pop_back(); return {stoll(t1), stoll(t2) * sgn};}
int time_to_minutes(int h, int m) {return h * 60 + m;}
int time_to_minutes(str s) {int ps = s.find(':'); assert(ps != string::npos); return time_to_minutes(stoi(s.substr(0, ps)), stoi(s.substr(ps + 1)));}
str minutes_to_time(int m, bool h0 = true, bool m0 = true) {int h = m / 60; m %= 60; str o; if (h0) o += (h < 10 ? ""0"" : """"); o += to_string(h); o += ':'; if (m0) o += (m < 10 ? ""0"" : """"); o += to_string(m); return o;}
bool is_vowel_lowercase(char c) {return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';}
bool is_consonant_lowercase(char c) {return !is_vowel_lowercase(c);}
ull leq_pow2ll(const ull x) {return 1ull << __lg(x);}
ull geq_pow2ll(const ull x) {return x & (x - 1) ? 2ull << __lg(x) : x;}
ll sqd(const pll p1, const pll p2) {return (p1.F - p2.F) * (p1.F - p2.F) + (p1.S - p2.S) * (p1.S - p2.S);}
ll sqd(const ll x1, const ll y1, const ll x2, const ll y2) {return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);}
template<typename T> int sign(T x) {return x < 0 ? -1 : x > 0 ? 1 : 0;}
template<typename I> bool is_subsequence(I f_pattern, I l_pattern, I f_text, I l_text) {for (; f_text != l_text && f_pattern != l_pattern; ++f_text) if (*f_text == *f_pattern) ++f_pattern; return f_pattern == l_pattern;}
template<typename T> auto C = []() {const size_t N = 67; array<array<T, N>, N> C{0}; C[0][0] = 1; for (size_t i = 1; i < N; ++i) {C[i][0] = 1; for (size_t j = 1; j <= i; ++j) {C[i][j] = C[i - 1][j - 1] + C[i - 1][j];}} return C;}();
vec<ll> get_divisors(ll x) {vec<ll> ans1, ans2; for (ll q = 1; q * q <= x; ++q) {if (x % q == 0) {ans1.pb(q); ans2.pb(x / q);}} if (ans1.back() == ans2.back()) ans1.pop_back(); reverse(all(ans2)); for (ll i : ans2) ans1.pb(i); return ans1;}
bool is_prime(ll c) {if (c < 2) return 0; if (c == 2 || c == 3) return 1; if (c % 2 == 0 || c % 3 == 0) return 0; const ll gr = sqrtl(c) + 1; for (ll q = 6; q <= gr; q += 6) {if (c % (q - 1) == 0) return 0; if (c % (q + 1) == 0) return 0;} return 1;}
vec<str> split(str &s, char c, bool ignore_empty = false) {vec<str> o; str u; for (int q = 0; q < s.size(); q++) {if (s[q] == c) {if (!u.empty() || !ignore_empty) o.pb(u); u.clear();} else u += s[q];} if (!u.empty() || !ignore_empty) o.pb(u); return o;}
int replace(str &s, str from, str to) {str t = from; t.pb(0); t += s; int a = t.size(); vec<int> m(a); for (int q = 1; q < a; ++q) {for (int w = m[q - 1]; w && !m[q]; w = m[w - 1]) {if (t[q] == t[w]) m[q] = w + 1;} m[q] += !m[q] && t[q] == t[0];} int szf = from.size(), lst = szf; for (int q = szf; q < t.size(); ++q) {if (m[q] == szf && q - lst >= szf) {m[q - szf + 1] = -1; lst = q;}} str ans; int o = 0; for (int q = szf + 1; q < t.size(); ++q) {if (m[q] != -1) ans += t[q]; else ans += to, q += szf - 1, ++o;} s = ans; return o;}
template<typename T> T mul_threshold(T a, T b, T threshold) {if (!a || !b || !threshold) return 0; assert(a > 0 && b > 0); T max_b = threshold / a; return b <= max_b ? a * b : threshold;}
template<typename T> T count_set_bits_pref(T n, int b) {assert(0 <= n); T pw = (T)(1) << b; if (pw > n) return 0; T period = pw * 2; T full = (n + 1) / period; T rem = (n + 1) & (period - 1); return full * pw + (rem < pw ? 0 : rem - pw);}
template<typename T> T count_set_bits_seg(T l, T r, int b) {assert(0 <= l && l <= r); return count_set_bits_pref(r, b) - (l ? count_set_bits_pref(l - 1, b) : 0);}
template<typename I> vector<int> get_substring_occurrences(I f_pattern, I l_pattern, I f_text, I l_text) {const size_t n = std::distance(f_pattern, l_pattern); const size_t m = std::distance(f_text, l_text); assert(n); auto cmp = [&](size_t i, size_t j) {if (i == n || j == n) return i == j; return (i < n ? * (f_pattern + i) : * (f_text + i - n - 1)) == (j < n ? * (f_pattern + j) : * (f_text + j - n - 1));}; vector<int> pf(n), res; for (size_t i = 1, ppf = 0; i < n + 1 + m; ++i) {size_t p = 0; for (size_t j = ppf; j && !p; j = pf[j - 1]) {if (cmp(i, j)) p = j + 1;} p += !p && cmp(i, 0); ppf = p; if (i < n) pf[i] = p; if (p == n) res.push_back(i - n * 2);} return res;}
template<typename T> T integral_tersearch_argmin(auto f, T l, T r) {static_assert(is_integral_v<decltype(l)>); using U = decltype(f(l)); const ld FI = 1.6180339887498948482045868343656381177203; T p1 = l + (r - l) / (FI + 1), p2 = r - (r - l) / (FI + 1); U v1 = f(p1), v2 = f(p2); while (r - l > 7) {if (v1 < v2) {r = p2; p2 = p1, v2 = v1; p1 = l + (r - l) / (FI + 1), v1 = f(p1);} else {l = p1; p1 = p2, v1 = v2; p2 = r - (r - l) / (FI + 1), v2 = f(p2);}} T best_arg = l; U best_val = f(l), prv = best_val; while (++l <= r) {U tyt = l == p1 ? v1 : l == p2 ? v2 : f(l); if (tyt > prv) break; if (chmin(best_val, tyt)) best_arg = l; prv = tyt;} return best_arg;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l, T r) {static_assert(is_same<decltype(l), decltype(r)>::value); while (l + 1 < r) {T md = l + (r - l) / 2; if (f(md))l = md; else r = md;} return l;};
template<typename T> T integral_binary_search_last_when_true(auto f, T l) {T d = 1; while (f(l + d)) d *= 2; d /= 2; for (T u = d; u; u /= 2) if (f(l + d + u)) d += u; return l + d;};
template<typename T> T get_kth_statistic_by_binary_search(T n, T k, T val_l, T val_r, auto cnt_leq) {assert(0 <= k && k < n); assert(val_l <= val_r); return integral_binary_search_last_when_true<T>([&](T x) {return cnt_leq(x) <= k;}, val_l - 1, val_r) + 1;}

template<typename INT, typename LONG, const INT MOD>
class Mint {
    static_assert(is_integral_v<INT> && is_integral_v<LONG>);
    static_assert(numeric_limits<INT>::max() < numeric_limits<LONG>::max() / numeric_limits<INT>::max() && ""Product of two INT's must fit into LONG"");

    INT val = 0;

public:
    using int_type = INT;
    using long_type = LONG;

    constexpr Mint() = default;
    template<typename T>
    constexpr Mint(T c) {
        static_assert(is_integral_v<T>);
        if (c < 0) c += ((-c - 1) / MOD + 1) * MOD;
        else if (c >= MOD) c %= MOD;
        val = c;
    }

    constexpr INT get_val() const {return val;}
    static constexpr INT get_mod() {return MOD;}

    Mint pow(LONG pw) const {
        LONG o = 1;
        for (LONG x = val; pw; pw >>= 1) {
            if (pw & 1) o = o * x % MOD;
            x = x * x % MOD;
        }
        return Mint(o);
    }

    Mint inv() const {
        return pow(MOD - 2);
    }

    friend Mint pow(const Mint& m, LONG pw) {return m.pow(pw);}
    friend Mint inv(const Mint& m) {return m.inv();}

    Mint operator+(const Mint& rhs) const {return val + rhs.val >= MOD ? val + rhs.val - MOD : val + rhs.val;}
    Mint operator-(const Mint& rhs) const {return val < rhs.val ? MOD - rhs.val + val : val - rhs.val;}
    Mint operator*(const Mint& rhs) const {return (LONG)1 * val * rhs.val % MOD;}
    Mint operator/(const Mint& rhs) const {return (LONG)1 * val * inv(rhs).val % MOD;}
    Mint operator-() const {return val ? MOD - val : val;}

    void operator+=(const Mint& rhs) {val += rhs.val; val -= val < MOD ? 0 : MOD;}
    void operator-=(const Mint& rhs) {val -= rhs.val; val += val < 0 ? MOD : 0;}
    void operator*=(const Mint& rhs) {val = (LONG)1 * val * rhs.val % MOD;}
    void operator/=(const Mint& rhs) {val = (LONG)1 * val * inv(rhs).val % MOD;}

    Mint& operator++() {val = val == MOD - 1 ? 0 : val + 1; return *this;}
    Mint operator++(int) {Mint res = *this; ++*this; return res;}
    Mint& operator--() {val = val ? val - 1 : MOD - 1; return *this;}
    Mint operator--(int) {Mint res = *this; --*this; return res;}

    bool operator==(const Mint& rhs) const {return val == rhs.val;}
    bool operator!=(const Mint& rhs) const {return val != rhs.val;}
    bool operator<(const Mint& rhs) const {return val < rhs.val;}
    bool operator>(const Mint& rhs) const {return val > rhs.val;}

    explicit operator bool() const {return val != 0;}

    friend istream& operator>>(istream& in, Mint& rhs) {return in >> rhs.val;}
    friend ostream& operator<<(ostream& out, const Mint& rhs) {return out << rhs.val;}
};
using mint = Mint<int32_t, int64_t, 1000000007>;

class Solution {
public:
    int possibleStringCount(string word, int k) {
        vec<ll> m;
        mint vse = 1;
        for (auto [l, r] : get_segs_of_eq_elems(all(word))) {
            m.pb(r - l + 1);
            vse *= r - l + 1;
        }
        vec<mint> dp(k);
        dp[0] = 1;
        for (int i = 0; i < m.size(); ++i) {
            if (i > k + 5) break;
            partial_sum(all(dp), dp.begin());
            vec<mint> ndp(k);
            for (int j = i + 1; j < k; ++j) {
                ll l = max(0ll, j - m[i]);
                ndp[j] = dp[j - 1] - (l ? dp[l - 1] : mint(0));
            }
            dp = ndp;
        }
        return (vse - accumulate(all(dp), mint(0))).get_val();
    }
};",1434328270
Wei Liu,nevergiveup,88,3576,java,"class Solution {

    private static List<Integer>[] graph = new ArrayList[100010];

    static {
        for (int i = 0;i < graph.length;i ++) {
            graph[i] = new ArrayList<>();
        }
    }

    private Map<Character, LinkedList<Integer>> stackMap = new HashMap<>();
    private int[] newParent;
    private int[] ans;

    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        newParent = new int[n];
        ans = new int[n];
        Arrays.fill(newParent, - 1);
        for (int i = 0;i < n;i ++) {
            graph[i].clear();
        }
        for (int i = 0;i < n;i ++) {
            if (parent[i] >= 0) {
                graph[parent[i]].add(i);
            }
        }
        dfs(parent, 0, s);
        // build new graph
        for (int i = 0;i < n;i ++) {
            graph[i].clear();
        }
        for (int i = 0;i < n;i ++) {
            if (newParent[i] >= 0) {
                graph[newParent[i]].add(i);
            }
        }
        collectSize(0);
        return ans;
    }

    private int collectSize(int current) {
        int result = 1;
        for (int next : graph[current]) {
            result += collectSize(next);
        }
        ans[current] = result;
        return result;
    }

    private void dfs(int[] parent, int current, String s) {
        char ch = s.charAt(current);
        stackMap.putIfAbsent(ch, new LinkedList<>());
        if (!stackMap.get(ch).isEmpty()) {
            int index = stackMap.get(ch).peekLast();
            newParent[current] = index;
        } else {
            newParent[current] = parent[current];
        }
        stackMap.get(ch).addLast(current);
        for (int next : graph[current]) {
            dfs(parent, next, s);
        }
        stackMap.get(ch).pollLast();
    }



}",1434299329
Wei Liu,nevergiveup,88,3587,java,"class Solution {

    private int[][] dp;

    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        dp = new int[n][k];
        for (int i = 0;i < n;i ++) {
            for (int j = 0;j < k;j ++) {
                dp[i][j] = - 1;   
            }
        }
        int ans = 0;
        for (int i = 0;i < n;i ++) {
            int result = dfs(i, 0, n, k, stayScore, travelScore);
            ans = Math.max(ans, result);
        }
        return ans;
    }

    private int dfs(int curCity, int curDay, int n, int k, int[][] stayScore, int[][] travelScore) {
        if (curDay == k) {
            return 0;
        }
        if (dp[curCity][curDay] >= 0) {
            return dp[curCity][curDay];
        }
        int ans = 0;
        // stay
        int result = dfs(curCity, curDay + 1, n, k, stayScore, travelScore) + stayScore[curDay][curCity];
        ans = Math.max(ans, result);
        // move to another city
        for (int i = 0;i < n;i ++) {
            if (i != curCity) {
                result = dfs(i, curDay + 1, n, k, stayScore, travelScore) + travelScore[curCity][i];
                ans = Math.max(ans, result);
            }
        }
        return dp[curCity][curDay] = ans;
    }

}",1434313945
Wei Liu,nevergiveup,88,3617,java,"class Solution {

    public int possibleStringCount(String word) {
        int ans = 1;
        for (int i = 0;i < word.length();i ++) {
            char base = word.charAt(i);
            int count = 0;
            while (i < word.length() && word.charAt(i) == base) {
                i ++;
                count ++;
            }
            i --;
            if (count > 1) {
                ans += (count - 1);
            }
        }   
        return ans;
    }

}",1434266457
Wei Liu,nevergiveup,88,3618,java,"class Solution {

    private final long MOD = 1000_000_007L;

    private List<Integer> toList(String word) {
        List<Integer> ans = new ArrayList<>();
        for (int i = 0;i < word.length();i ++) {
            char ch = word.charAt(i);
            int count = 0;
            while (i < word.length() && word.charAt(i) == ch) {
                i ++;
                count ++;
            }
            i --;
            ans.add(count);
        }
        return ans;
    }

    // < k
    private long solve(List<Integer> countList, int k) {
        if (countList.size() >= k) {
            return 0;
        }
        // build dp and dp acc
        dp[0] = 1;
        for (int i = 0;i < k;i ++) {
            dpAcc[i] = dp[i];
            if (i > 0) {
                dpAcc[i] = (dpAcc[i] + dpAcc[i - 1]) % MOD;
            }
        }
        // check each choice
        for (int count : countList) {
            // update dpNew
            for (int i = k - 1;i >= 1;i --) {
                long result = dpAcc[i - 1];
                if (i - count - 1 >= 0) {
                    result = (result - dpAcc[i - count - 1] + MOD) % MOD;
                }
                dpNew[i] = result;
            }
            // update dp
            for (int i = 0;i < k;i ++) {
                dp[i] = dpNew[i];
            }
            // update dp acc
            for (int i = 0;i < k;i ++) {
                dpAcc[i] = dp[i];
                if (i > 0) {
                    dpAcc[i] = (dpAcc[i] + dpAcc[i - 1]) % MOD;
                }
            }
        }
        long ans = 0;
        for (int i = 1;i < k;i ++) {
            ans = (ans + dp[i]) % MOD;
        }
        return ans;
    }

    private long[] dp = new long[2010];
    private long[] dpAcc = new long[2010];
    private long[] dpNew = new long[2010];

    public int possibleStringCount(String word, int k) {
        List<Integer> countList = toList(word);
        long total = 1;
        for (int count : countList) {
            total = (total * count) % MOD;
        }
        long less = solve(countList, k);
        long result = (total - less + MOD) % MOD;
        return (int) result;
    }


}",1434362201
Ajit,Ajit123,90,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(26, -2));
        vector<vector<int>> g(n);
        vector<int> newPar(n);

        auto solve = [&](auto& solve, int i, int j) -> int {
            if (i == -1) {
                return -1;
            }
            
            if (dp[i][j] != -2) {
                return dp[i][j];
            }

            if ((s[i] - 'a') == j) {
                return dp[i][j] = i;
            }
            
            return dp[i][j] = solve(solve, parent[i], j);
        };

        for(int i=0; i<n; i++) {
            int par = solve(solve, parent[i], s[i]-'a');
            if (par == -1) {
                newPar[i] = parent[i];
            }
            else {
                newPar[i] = par;
            }
          
            if (newPar[i] != -1) {
                g[newPar[i]].push_back(i);
            }
        }

        vector<int> sum(n);
        auto dfs = [&](auto& dfs, int i) -> void {
            sum[i] = 1;
            for(auto it: g[i]) {
                dfs(dfs, it);
                sum[i] += sum[it];
            }
        };

        for(int i=0; i<n; i++) {
            if (newPar[i] == -1) {
                dfs(dfs, i);
            }
        }

        return sum;
    }
};",1434353455
Ajit,Ajit123,90,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int>(k+1));
        for(int j=1; j<=k; j++) {
            for(int i=0; i<n; i++) {
                dp[i][j] = stayScore[j-1][i] + dp[i][j-1];
                for(int k=0; k<n; k++) {
                    if (k == i) {
                        continue;
                    }
                    dp[i][j] = max(dp[i][j], travelScore[k][i] + dp[k][j-1]);
                }
            }
        }

        int ans = 0;
        for(int i=0; i<n; i++) {
            ans = max(ans, dp[i][k]);
        }

        return ans;
    }
};",1434362809
Ajit,Ajit123,90,3617,cpp,"class Solution {
public:
    int power(int x, int y, int MOD) {
        if (y == 0) {
            return 1;
        }

        int temp = power(x, y/2, MOD);
        temp = (1ll * temp * temp) % MOD;
        if (y&1) {
            temp = (1ll * temp * x) % MOD;
        }

        return temp;
    }
    int possibleStringCount(string word) {
        const int MOD = 1e9 + 7;
        vector<int> vals;
        char ch = word[0];
        int cur = 0;
        for(auto it: word) {
            if (ch == it) {
                cur++;
            }
            else {
                vals.push_back(cur);
                ch = it;
                cur = 1;
            }
        }
        vals.push_back(cur);

        int n = vals.size();
        
        int ans = 1;
        for(auto it: vals) {
            ans += it-1;
        }
        
        return ans;
    }
};",1434338087
Ajit,Ajit123,90,3618,cpp,"class Solution {
public:
    int power(int x, int y, int MOD) {
        if (y == 0) {
            return 1;
        }

        int temp = power(x, y/2, MOD);
        temp = (1ll * temp * temp) % MOD;
        if (y&1) {
            temp = (1ll * temp * x) % MOD;
        }

        return temp;
    }
    int possibleStringCount(string word, int k) {
        const int MOD = 1e9 + 7;
        vector<int> vals;
        char ch = word[0];
        int cur = 0;
        for(auto it: word) {
            if (ch == it) {
                cur++;
            }
            else {
                vals.push_back(cur);
                ch = it;
                cur = 1;
            }
        }
        vals.push_back(cur);

        int n = vals.size();
        if (n > k) {
            int ans = 1;
            for(auto it: vals) {
                ans = (1ll * ans * it) % MOD;
            }
            return ans;
        }

        vector<vector<int>> dp(n+1, vector<int>(k+1));
        vector<vector<int>> pref(n+1, vector<int>(k+1));
        dp[0][0] = 1;
        for(int j=0; j<=k; j++) {
            pref[0][j] = 1;
        }
        
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=min(k, vals[i-1]); j++) {
                dp[i][j] = pref[i-1][j-1];
            }

            for(int j=vals[i-1]+1; j<=k; j++) {
                dp[i][j] = pref[i-1][j-1] - pref[i-1][j-vals[i-1]-1] + MOD;
                while (dp[i][j] >= MOD) dp[i][j] -= MOD;
            }

            for(int j=1; j<=k; j++) {
                pref[i][j] = (pref[i][j-1] + dp[i][j]) % MOD;
            }
        }

        int ans = 1;
        for(auto it: vals) {
            ans = (1ll * ans * it) % MOD;
        }

        for(int j=1; j<k; j++) {
            ans = (ans - dp[n][j] + MOD);
            while (ans >= MOD) {
                ans -= MOD;
            }
        }
        
        return ans;
    }
};",1434333663
dirigibility,dirigibility,91,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        children = defaultdict(list)
        for i in range(1,n):
            children[parent[i]].append(i)
        seen = defaultdict(list)
        def dfs(i):
            if seen[s[i]]:
                parent[i] = seen[s[i]][-1]
            seen[s[i]].append(i)
            for j in children[i]:
                dfs(j)
            seen[s[i]].pop()
        dfs(0)
        children = defaultdict(list)
        for i in range(1,n):
            children[parent[i]].append(i)
        ans = [1]*n
        def f(i):
            for j in children[i]:
                f(j)
                ans[i] += ans[j]
        f(0)
        return ans",1434276797
dirigibility,dirigibility,91,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, s: List[List[int]], t: List[List[int]]) -> int:
        f = [0]*n
        for i in range(k):
            f = [max(f[c]+s[i][c],max(f[b]+t[b][c] for b in range(n))) for c in range(n)]
        return max(f)",1434285433
dirigibility,dirigibility,91,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        total = 1
        for c,g in groupby(word):
            if (l := len(list(g))) > 1:
                total += l-1
        return total",1434260170
dirigibility,dirigibility,91,3618,python3,"mod = 10**9+7
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        r = 1
        l = [len(list(g)) for _,g in groupby(word)]
        for a in l:
            r = (r*a)%mod
        if len(l) >= k:
            return r
        bad = [0]*(k-len(l))
        bad[0] = 1
        for a in l:
            if a > 1:
                for i in reversed(range(a,len(bad))):
                    bad[i] = (bad[i]-bad[i-a])%mod
                for i in range(1,len(bad)):
                    bad[i] = (bad[i]+bad[i-1])%mod
        return (r-sum(bad))%mod",1434350338
g129512,g129512,92,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n=len(parent)
        
        g=[[] for _ in range(n)]
        for i in range(1,n):
            g[ parent[i]].append(i)
        
        newp=[-1]*n
        def dfs(i,p,mp):
            if s[i] not in mp:
                mp[s[i]]=[]
                
            if mp[s[i]]!=[]:
                newp[i]=mp[s[i]][-1]
            mp[s[i]].append(i)
            for ch in g[i]:
                if ch==p:continue
                dfs(ch,i,mp)
            mp[s[i]].pop()
        dfs(0,-1,{})
        
        g=[[] for _ in range(n)]
        for i in range(1,n):
            if newp[i]!=-1:
                g[newp[i]].append(i)
            else:
                g[parent[i]].append(i)
        res=[0]*n
        def dfs2(i,p):
            res[i]+=1
            for ch in g[i]:
                if ch==p:continue
                dfs2(ch,i)
                res[i]+=res[ch]
        dfs2(0,-1)
        return res
        
        
        
        
        
        ",1434355398
g129512,g129512,92,3587,python3,"from typing import List
def fmax(a,b):
    return a if a>b else b
def fmin(a,b):
    return a if a<b else b

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp=[0]*(n)
        for i in range(k):
            ndp=[0]*n
            for j in range(n):
                ndp[j]=fmax(ndp[j], dp[j]+stayScore[i][j])
                for dst in range(n):
                    ndp[dst]=fmax(ndp[dst], dp[j]+travelScore[j][dst])
            dp=ndp
        return max(dp)

        ",1434355139
g129512,g129512,92,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n=len(word)
        i=0
        res=1
        while i<n:
            j=i+1
            while j<n and word[j]==word[j-1]:
                j+=1
            if j-i>1:
                res+=j-i-1
            i=j
        return res",1434355552
g129512,g129512,92,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        n=len(word)
        M=10**9+7
        ks=[]
        i=0
        tot=1
        while i<n:
            j=i+1
            while j<n and word[j]==word[j-1]:
                j+=1
            ks.append(j-i)
            tot*=j-i
            tot%=M
            i=j
        
        m=len(ks)
        if m>=k:
            return tot
        dp=[0]*(k)
        dp[0]=1
        for i in range(m):
            ndp=[0]*(k)
            s=0
            for j in range(k):
                if j-ks[i]-1>=0:
                    s-=dp[j-ks[i]-1]
                s%=M
                ndp[j]=s
                s+=dp[j]
            dp=ndp
        return (tot-sum(dp)%M)%M
",1434356857
GDST,gdstw,93,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[parent[i]].append(i)

        p2 = parent.copy()
        latest = defaultdict(lambda: -1)
        def dfs(u):
            ch = s[u]
            prev = latest[ch]
            if prev != -1:
                p2[u] = prev
            latest[ch] = u
            for v in g[u]:
                dfs(v)
            if prev == -1:
                del latest[ch]
            else:
                latest[ch] = prev
        dfs(0)

        ng = [[] for _ in range(n)]
        for i in range(1, n):
            ng[p2[i]].append(i)
        ans = [0] * n
        def dfs2(u):
            res = 1
            for v in ng[u]:
                res += dfs2(v)
            ans[u] = res
            return res
        dfs2(0)
        return ans",1434285694
GDST,gdstw,93,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @cache
        def dfs(day, city):
            if day == k:
                return 0

            res = stayScore[day][city] + dfs(day + 1, city)
            for dest in range(n):
                if dest != city:
                    res = max(res, travelScore[city][dest] + dfs(day + 1, dest))
            return res

        ans = 0
        for start_city in range(n):
            ans = max(ans, dfs(0, start_city))
        return ans",1434292976
GDST,gdstw,93,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = cnt = 0
        for i, ch in enumerate(word):
            if i == 0 or ch == word[i - 1]:
                cnt += 1
            else:
                if cnt >= 2:
                    ans += cnt - 1
                cnt = 1  
        if cnt >= 2:
            ans += cnt - 1
        return ans + 1",1434270629
GDST,gdstw,93,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        n = len(word)
        MOD = 10**9 + 7

        groups = []
        i = 0
        while i < n:
            j = i
            while j < n and word[j] == word[i]:
                j += 1
            groups.append(j - i)
            i = j

        m = len(groups)
        need = k - m
        if k > sum(groups):
            return 0

        tot = 1
        for ln in groups:
            tot = (tot * ln) % MOD

        if m >= k or need <= 0:
            return tot

        f = [0] * (need)
        f[0] = 1
        for ln in groups:
            max_add = ln - 1
            if max_add <= 0:
                continue

            pre = [0] * (need)
            pre[0] = f[0]
            for s in range(1, need):
                pre[s] = (pre[s - 1] + f[s]) % MOD

            new_f = [0] * (need)
            for s in range(need):
                lower = max(0, s - max_add)
                new_f[s] = pre[s]
                if lower > 0:
                    new_f[s] = (new_f[s] - pre[lower - 1]) % MOD

            f = new_f

        return (tot - sum(f[:need]) % MOD) % MOD",1434343877
Wen-Chieh Tung,WJTung,95,3576,cpp,"class Solution {
 public:
  vector<int> findSubtreeSizes(vector<int>& parent, string s) {
    int n = s.length();
    vector<vector<int>> edges(n);
    for (int i = 1; i < n; ++i) {
      edges[parent[i]].push_back(i);
    }
    vector<int> ans(n, 0);
    vector<vector<int>> path(26);
    function<void(int)> DFS;
    DFS = [&](int u) {
      int i = s[u] - 'a';
      path[i].push_back(u);
      ans[u] = 1;
      for (int v : edges[u]) {
        DFS(v);
      }
      path[i].pop_back();
      if (parent[u] == -1) {
        return;
      }
      int new_parent = parent[u];
      if (!path[i].empty()) {
        new_parent = path[i].back();
      }
      ans[new_parent] += ans[u];
    };
    DFS(0);
    return ans;
  }
};",1434296794
Wen-Chieh Tung,WJTung,95,3587,cpp,"class Solution {
 public:
  int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    vector<int> max_score(n, 0); // max_score[c]: max score when currently at c
    for (int i = 0; i < k; ++i) {
      vector<int> new_max_score(n, 0);
      for (int c = 0; c < n; ++c) {
        new_max_score[c] = max_score[c] + stayScore[i][c];
      }
      for (int c1 = 0; c1 < n; ++c1) {
        for (int c2 = 0; c2 < n; ++c2) {
          new_max_score[c2] = max(max_score[c1] + travelScore[c1][c2], new_max_score[c2]);
        }
      }
      max_score = move(new_max_score);
    }
    return *max_element(max_score.begin(), max_score.end());
  }
};",1434306595
Wen-Chieh Tung,WJTung,95,3617,cpp,"class Solution {
 public:
  int possibleStringCount(string word) {
    int ans = 1;
    int count = 1;
    char prev = ' ';
    for (char c : word) {
      if (c == prev) {
        ++count;
      } else {
        ans += count - 1;
        count = 1;
        prev = c;
      }
    }
    ans += count - 1;
    return ans;
  }
};",1434268276
Wen-Chieh Tung,WJTung,95,3618,cpp,"class Solution {
 public:
  const long long MOD = 1E9 + 7;

  int possibleStringCount(string word, int k) {
    vector<int> C;
    int count = 1;
    char prev = ' ';
    for (char c : word) {
      if (c == prev) {
        ++count;
      } else {
        if (prev != ' ') {
          --k;
        }
        if (count > 1) {
          C.push_back(count - 1);
        }
        prev = c;
        count = 1;
      }
    }
    --k;
    if (count > 1) {
      C.push_back(count - 1);
    }
    
    if (k <= 0) {
      // free combination
      long long ans = 1;
      for (int count : C) {
        ans = ans * (count + 1) % MOD; 
      }
      return ans;
    } else {
      // can DP because size of C must <= 2000
      vector<long long> W(k + 1, 0);
      W[0] = 1;
      for (int count : C) {
        vector<long long> prefix_sum(k + 2, 0);
        for (int i = 1; i <= k + 1; ++i) {
          prefix_sum[i] = prefix_sum[i - 1] + W[i - 1]; 
        }

        vector<long long> newW(k + 1, 0);
        for (int i = 0; i <= k; ++i) {
          // W[i - count] ~ W[i]
          long long sum = prefix_sum[i + 1] - prefix_sum[max(i - count, 0)];
          newW[i] = sum % MOD;
        }
        for (int i = 0; i <= k; ++i) {
          // don't care how much we are above k, all add to k
          if (i + count > k) {
            newW[k] = (newW[k] + W[i] * (i + count - k)) % MOD;
          }
        }

        W = move(newW);
      }
      return W[k] % MOD;
    }
  }
};",1434357422
LucasLyu,Lucas595,99,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        last_occurence = [None] * 26
        new_parent = parent.copy()

        def dfs(node: int) -> None:
            idx = ord(s[node]) - ord('a')
            prev = last_occurence[idx]
            if prev is not None:
                new_parent[node] = prev
            last_occurence[idx] = node
            for child in children[node]:
                dfs(child)
            last_occurence[idx] = prev

        dfs(0)

        new_children = [[] for _ in range(n)]
        for i in range(1, n):
            p = new_parent[i]
            new_children[p].append(i)
        answer = [0] * n
        
        def sub_size(node: int) -> int:
            size = 1
            for child in new_children[node]:
                size += sub_size(child)
            answer[node] = size
            return size
        sub_size(0)
        return answer
        ",1434308194
LucasLyu,Lucas595,99,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1] * n for _ in range(k + 1)]
        for city in range(n):
            dp[0][city] = 0

        for day in range(k):
            for curr in range(n):
                if dp[day][curr] < 0:
                    continue
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr])
                for dest in range(n):
                    if dest != curr:
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest])
        return max(dp[k])
",1434320418
LucasLyu,Lucas595,99,3617,python3,"from collections import Counter


class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        prev = None
        for c in word:
            if c == prev:
                ans += 1
            else:
                prev = c
        return ans
        ",1434278707
LucasLyu,Lucas595,99,3618,python3,"MOD = int(1e9 + 7)


class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        runs = []
        n = len(word)
        i = 0
        while i < n:
            char = word[i]
            cnt = 1
            while i + cnt < n and word[i + cnt] == char:
                cnt += 1
            runs.append(cnt)
            i += cnt
        
        m = len(runs)
        T = k - m
        if T <= 0:
            N = 1
            for cnt in runs:
                N = (N * cnt) % MOD
            return N

        max_s = T - 1
        dp = [0] * (T)
        dp[0] = 1

        for u in (cnt - 1 for cnt in runs):
            limit = min(u, T - 1)
            temp_dp = [0] * (T)
            for s in range(T - 1):
                if dp[s]:
                    max_t = min(u, T - 1 - s)
                    temp_dp[s + 1] = (temp_dp[s + 1] + dp[s]) % MOD
                    if s + max_t + 1 < T:
                        temp_dp[s + max_t + 1] = (temp_dp[s + max_t + 1] - dp[s]) % MOD
            cum_sum = 0
            for s in range(1, T):
                cum_sum = (cum_sum + temp_dp[s]) % MOD
                dp[s] = (dp[s] + cum_sum) % MOD

        S = sum(dp) % MOD
        N = 1
        for cnt in runs:
            N = (N * cnt) % MOD
        answer = (N - S + MOD) % MOD
        return answer
        ",1434352824
Fasdr,Fasdr,101,3576,java,"class Solution {
    
    private int n;
    private List<List<Integer>> adj;
    private List<List<Integer>> updatedAdj;
    private List<Stack<Integer>> letterToNode;
    private int[] size;
    
    public int[] findSubtreeSizes(int[] parent, String s) {
        n = parent.length;
        adj = new ArrayList<>();
        updatedAdj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
            updatedAdj.add(new ArrayList<>());
        }
        for (int v = 1; v < n; v++) {
            int u = parent[v];
            adj.get(u).add(v);
        }
        // System.out.println(adj);
        letterToNode = new ArrayList<>();
        for (int i = 'a'; i <= 'z'; i++) {
            letterToNode.add(new Stack<>());
        }
        DFSre(0, -1, s);
        // System.out.println(updatedAdj);
        size = new int[n];
        DFSsize(0);
        return size;
    }
    
    private void DFSre(int cur, int par, String s) {
        int idx = s.charAt(cur) - 'a';
        Stack<Integer> pos = letterToNode.get(idx);
        if (cur != 0) {
            if (pos.isEmpty()) {
                updatedAdj.get(par).add(cur);
            } else {
                updatedAdj.get(pos.peek()).add(cur);
            }
        }
        pos.add(cur);
        for (int next : adj.get(cur)) {
            DFSre(next, cur, s);
        }
        pos.pop();
    }
    
    private void DFSsize(int node) {
        int curSize = 1;
        for (int next : updatedAdj.get(node)) {
            DFSsize(next);
            curSize += size[next];
        }
        size[node] = curSize;
    }
    
    
}",1434298609
Fasdr,Fasdr,101,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        // end of the day, city -> max res
        // O(k n ^ 2)
        int[][] dp = new int[k + 1][n];
        for (int day = 0; day < k; day++) {
            for (int city = 0; city < n; city++) {
                for (int fromCity = 0; fromCity < n; fromCity++) {
                    if (city == fromCity) {
                        dp[day + 1][city] = Math.max(dp[day + 1][city], dp[day][city] + stayScore[day][city]);
                    } else {
                        dp[day + 1][city] = Math.max(dp[day + 1][city], dp[day][fromCity] + travelScore[fromCity][city]);
                    }
                }
            }
        }
        
        
        int res = 0;
        for (int city = 0; city < n; city++) {
            res = Math.max(res, dp[k][city]);
        }
        return res;
    }
}",1434316954
Fasdr,Fasdr,101,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int res = 1;
        char last = ' ';
        int len = 0;
        for (char chr : word.toCharArray()) {
            if (last != chr) {
                if (len > 1) {
                    res += len - 1;
                }
                last = chr;
                len = 0;
            }
            len++;
        }
        if (len > 1) {
            res += len - 1;
        }
        return res;
    }
}",1434263503
Fasdr,Fasdr,101,3618,java,"class Solution {
    public int possibleStringCount(String word, int k) {
        
        long mod = 1_000_000_007;
        
        List<Integer> extra = new ArrayList<>();
        char last = ' ';
        int len = 0;
        for (char chr : word.toCharArray()) {
            if (last != chr) {
                if (len > 1) {
                    extra.add(len - 1);
                }
                k--;
                last = chr;
                len = 0;
            }
            len++;
        }
        if (len > 1) {
            extra.add(len - 1);
        }
        // System.out.println(extra);
        // System.out.println(k);
        
        
        int n = extra.size();
        long total = 1;
        for (int i = 0; i < n; i++) {
            total = (total * (extra.get(i) + 1)) % mod;
        }
        if (k < 1) {
            return (int) total;
        }
        // O(n * k)
        // place, taken -> options
        long[][] dp = new long[n][k];
        for (int take = 0; take <= Math.min(k - 1, extra.get(0)); take++) {
            dp[0][take] = 1;
        }
        
        for (int place = 1; place < n; place++) {
            long curSum = 0;
            // to remove
            int left = -1 - extra.get(place); 
            // to take
            int right = 0;
            for (int take = 0; take < k; take++) {
                if (left >= 0) {
                    curSum -= dp[place - 1][left];
                }
                left++;
                curSum += dp[place - 1][right];
                right++;
                curSum = (curSum + mod) % mod;
                dp[place][take] = curSum;
            }
        }
        
        for (int take = 0; take < k; take++) {
            total = (total - dp[n - 1][take] + mod) % mod;
        }
        
        return (int) total;
    }
}",1434361092
Rejas Raj,celestialcoder,102,3576,cpp,"class Solution {
public:
    void dfs(int u, vector<vector<int>>& g, string& s, vector<vector<int>>& st, vector<int>& newParent) {
        if (!st[s[u] - 'a'].empty()) {
            newParent[u] = st[s[u] - 'a'].back();
        }
        st[s[u] - 'a'].push_back(u);
        for (int v : g[u]) {
            dfs(v, g, s, st, newParent);
        }
        st[s[u] - 'a'].pop_back();
    }
    void dfsSize(int u, vector<vector<int>>& g, vector<int>& sz) {
        sz[u] = 1;
        for (int v : g[u]) {
            dfsSize(v, g, sz), sz[u] += sz[v];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.length();
        vector<vector<int>> g(n);
        vector<vector<int>> st(26);
        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }
        vector<int> newParent(n), sz(n);
        for (int i = 0; i < n; i++) {
            newParent[i] = parent[i];
        }
        dfs(0, g, s, st, newParent);
        for (int i = 0; i < n; i++) {
            g[i].clear();
        }
        for (int i = 1; i < n; i++) {
            g[newParent[i]].push_back(i);
        }
        dfsSize(0, g, sz);
        return sz;
    }
};",1434361113
Rejas Raj,celestialcoder,102,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(2, vector<int>(n));
        for (int j = 0; j < k; j++) {
            for (int i = 0; i < n; i++) {
                dp[1][i] = dp[0][i] + stayScore[j][i];
                for (int l = 0; l < n; l++) {
                    dp[1][i] = max(dp[1][i], dp[0][l] + travelScore[l][i]);
                }
            }
            for (int i = 0; i < n; i++) {
                dp[0][i] = dp[1][i];
            }
        }
        return *max_element(dp[0].begin(), dp[0].end());
    }
};",1434289589
Rejas Raj,celestialcoder,102,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length(), j = 0;
        for (int i = 0; i < n - 1; i++) {
            j += word[i + 1] != word[i];
        }
        return n - j;
    }
};",1434294093
Rejas Raj,celestialcoder,102,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        int m = word.length(), mod = 1e9 + 7;
        vector<int> a;
        a.push_back(1);
        for (int i = 1; i < m; i++) {
            if (word[i] == word[i - 1]) {
                a.back()++;
            } else {
                a.push_back(1);
            }
        }
        vector<vector<int>> dp(2, vector<int>(k));
        dp[0][0] = 1;
        int n = a.size();
        int ans = 1, subt = 0;
        for (int i : a) {
            ans = (long long)ans * i % mod;
        }
        if (n >= k) {
            return ans;
        }
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int r = 0; r < k; r++) {
                dp[1][r] = sum;
                sum = (sum + dp[0][r]) % mod;
                if (r >= a[i]) {
                    sum = (sum - dp[0][r - a[i]] + mod) % mod;
                }
            }
            for (int r = 0; r < k; r++) {
                dp[0][r] = dp[1][r];
            }
        }
        for (int i = 0; i < k; i++) {
            subt = (subt + dp[0][i]) % mod;
        }
        return (ans - subt + mod) % mod;
    }
};",1434337963
mahesh,maheshmylavarapu0057,105,3576,cpp,"class Solution {
public:
    vector<int>graph[101001],score,newGraph[101001];
    string s;
    void dfs(int root,vector<int> parents,int prev){
        if(parents[s[root]-'a']!=-1){
            newGraph[parents[s[root]-'a']].push_back(root);
        }
        else if(prev!=-1)
        {
              newGraph[prev].push_back(root);
        }
        parents[s[root]-'a']=root;
        for(auto it:graph[root]){
            dfs(it,parents,root);
        }
    }
    int subtree(int root){
        score[root]=1;
        for(auto it:newGraph[root])
            score[root]+=subtree(it);
        return score[root];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string ss) {
        vector<int>arr(26,-1);
        s=ss;
        score.resize(parent.size(),1);
        for(int i=0;i<parent.size();i++){
            if(parent[i]!=-1){
                graph[parent[i]].push_back(i);
                score[parent[i]]++;
            }
        }
        dfs(0,arr,-1);
        subtree(0);
        return score;
    }
};",1434319192
mahesh,maheshmylavarapu0057,105,3587,cpp,"class Solution {
public:
    vector<vector<int>> stay,travel;
    long long kk,n;
    long long dp[210][210];
    long long dpfun(int city,int day){
        //cout<<city<<"" ""<<day<<"" ""<<kk<<endl;
        if(dp[city][day]==-1){
            if(day==kk)
                return dp[city][day]=0;
         else{
             // cout<<city<<""bef ""<<day<<"" ""<<kk<<endl;
             long long sum=dpfun(city,day+1)+stay[day][city];
            for(int i=0;i<n;i++){
                 if(city!=i){
                   sum=max(sum,dpfun(i,day+1)+travel[city][i]);  
                 }   
            }
            dp[city][day]=sum;
         }
        }
        return dp[city][day];
    }
    int maxScore(int nn, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        kk=k;
        n=nn;
        stay=stayScore;
        travel=travelScore;
        long long sum=0;
        memset(dp,-1,sizeof(dp));
        for(int i=0;i<n;i++){
         //   cout<<sum<<""sum""<<endl;
            sum=max(sum,dpfun(i,0));
        }
        return sum;
    }
};",1434292648
mahesh,maheshmylavarapu0057,105,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int sum=1,pre=0;
        for(int i=1;i<word.size();i++){
            if(word[i]!=word[pre]){
               sum=sum+(i-pre-1);
                pre=i;
            }
        }
         sum=sum+(word.size()-pre-1);
        return sum;
    }
};",1434300164
mahesh,maheshmylavarapu0057,105,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        long long sum=1,mod=1e9+7;
        vector<long long>arr;
        long long int p=0;
        for(int i=1;i<word.size();i++){
            if(word[i]!=word[p]){
                  arr.push_back(i-p);
                long long val=i-p;
                sum=sum*(val);
                sum=sum%mod;
                p=i;
            }
        }
          arr.push_back(word.size()-p);
         sum=sum*(word.size()-p);
        sum=sum%mod;
        //cout<<sum<<endl;
        if(arr.size()>=k)
                return sum;
        vector<long long>pre(k,0);
        for(int i=1;i<=arr[0]&&i<k;i++)
                pre[i]=1;
        for(int i=1;i<arr.size();i++){
            long long val=arr[i];
            vector<long long>preNew(k,0);
            vector<long long> prefixSum(k + 1, 0); 
            for (int j = 1; j <= k; j++) {
                prefixSum[j] = (prefixSum[j - 1] + pre[j - 1]) % mod;
            }
            for (int j = 0; j < k; j++) {
                int left = max(0, j - min(k - 1, (int)val));
            preNew[j] = (prefixSum[j] - prefixSum[left] + mod) % mod;
            }
            pre=preNew;
        }
        for(int i=0;i<k;i++){
            sum=(sum-pre[i])%mod;
            sum=(sum+mod)%mod;
        }

        return sum;
    }
};",1434368492
Shazif Afzal Ansari,BinaryWizardby360,107,3576,dart,"class Solution {
  void updateTree(List<int> par, String str, List<List<int>> adj, int node, Map<String, int> last) {
    String ch = str[node];

    if (last.containsKey(ch)) {
      int anc = last[ch]!;
      par[node] = anc;
    }

    int prevPar = last.containsKey(ch) ? last[ch]! : -1;
    last[ch] = node;

    for (int child in adj[node]) {
      updateTree(par, str, adj, child, last);
    }

    if (prevPar != -1) {
      last[ch] = prevPar;
    } else {
      last.remove(ch);
    }
  }

  void dfsCount(List<int> ans, List<List<int>> adj, int node) {
    ans[node] = 1;

    for (int child in adj[node]) {
      dfsCount(ans, adj, child);
      ans[node] += ans[child];
    }
  }

  List<int> findSubtreeSizes(List<int> par, String str) {
    int n = par.length;
    Map<String, int> last = {str[0]: 0};

    List<List<int>> adj = List.generate(n, (_) => []);
    for (int i = 1; i < n; i++) {
      adj[par[i]].add(i);
    }

    updateTree(par, str, adj, 0, last);

    adj = List.generate(n, (_) => []);
    for (int i = 1; i < n; i++) {
      adj[par[i]].add(i);
    }

    List<int> ans = List.filled(n, 0);
    dfsCount(ans, adj, 0);

    return ans;
  }
}",1434300489
Shazif Afzal Ansari,BinaryWizardby360,107,3587,dart,"class Solution {
  int maxScoreHelper(int a, int b) {
    return (a > b) ? a : b;
  }

  int maxScore(int cities, int days, List<List<int>> stayPoints, List<List<int>> travelPoints) {
    List<List<int>> dp = List.generate(days + 1, (_) => List.filled(cities, -double.maxFinite.toInt()));

    for (int j = 0; j < cities; j++) {
      dp[0][j] = 0;
    }

    for (int day = 0; day < days; day++) {
      for (int currCity = 0; currCity < cities; currCity++) {
        if (dp[day][currCity] == -double.maxFinite.toInt()) {
          continue;
        }

        dp[day + 1][currCity] = maxScoreHelper(dp[day + 1][currCity], dp[day][currCity] + stayPoints[day][currCity]);

        for (int destCity = 0; destCity < cities; destCity++) {
          if (destCity != currCity) {
            dp[day + 1][destCity] = maxScoreHelper(dp[day + 1][destCity], dp[day][currCity] + travelPoints[currCity][destCity]);
          }
        }
      }
    }

    return dp[days].reduce((a, b) => maxScoreHelper(a, b));
  }
}
",1434304951
Shazif Afzal Ansari,BinaryWizardby360,107,3617,dart,"class Solution {
  int possibleStringCount(String word) {
    Set<String> possibleStrings = {word};

    int n = word.length;
    for (int i = 0; i < n;) {
      int j = i + 1;
      while (j < n && word[j] == word[i]) {
        j++;
      }
      for (int k = i + 1; k < j; ++k) {
        String newString = word.substring(0, k) + word.substring(j);
        possibleStrings.add(newString);
      }
      i = j;
    }
    return possibleStrings.length;
  }
}",1434298782
Shazif Afzal Ansari,BinaryWizardby360,107,3618,dart,"class Solution {
  int possibleStringCount(String word, int k) {
    const int MOD = 1000000007;
    List<int> counts = [];
    int n = 0;
    int i = 0;
    int len = word.length;

    while (i < len) {
      String current = word[i];
      int cnt = 1;
      while (i + 1 < len && word[i + 1] == current) {
        cnt++;
        i++;
      }
      counts.add(cnt);
      i++;
    }
    
    n = counts.length;
    int total = 1;
    for (var c in counts) {
      total = (total * c) % MOD;
    }
    
    if (n > k) {
      return total;
    }
    
    int m = k - 1 - n;
    if (m < 0) {
      return total;
    }
    
    List<int> dp = List.filled(m + 1, 0);
    dp[0] = 1;
    for (var c in counts) {
      int cap = c - 1;
      List<int> prefix = List.filled(m + 2, 0);
      for (int j = 0; j <= m; j++) {
        prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
      }
      List<int> newDp = List.filled(m + 1, 0);
      for (int j = 0; j <= m; j++) {
        int l = j - cap;
        if (l < 0) l = 0;
        newDp[j] = (prefix[j + 1] - prefix[l] + MOD) % MOD;
      }
      dp = newDp;
    }

    int ways = 0;
    for (int j = 0; j <= m; j++) {
      ways = (ways + dp[j]) % MOD;
    }
    
    return ((total - ways + MOD) % MOD);
  }

  int countWays(String word, int k) {
    return possibleStringCount(word, k);
  }
}",1434363895
Tony Li,tonyli0000,108,3576,cpp,"class Solution {
public:
    vector<int>val;
    vector<int>p, sz;
    
    void dfs(int x, vector<vector<int>>& adj, string& s){
        int last = val[s[x] - 'a'];
        if(last != -1)p[x] = val[s[x] - 'a'];
        val[s[x] - 'a'] = x;
        for(auto& it:adj[x]){
            dfs(it, adj, s);
        }
        val[s[x] - 'a'] = last;
    }
    
    void dfs2(int x, vector<vector<int>>& adj){
        sz[x] = 1;
        for(auto& it:adj[x]){
            dfs2(it, adj);
            sz[x] += sz[it];
        }
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        val.assign(26,-1);
        vector<vector<int>>adj(n);
        for(int i=0;i<n;i++){
            if(parent[i] == -1)continue;
            adj[parent[i]].push_back(i);
        }
        sz.assign(n, -1);
        p = parent;
        dfs(0, adj, s);
        vector<vector<int>>adj2(n);
        vector<int>rt;
        for(int i=0;i<n;i++){
            if(p[i] == -1)rt.push_back(i);
            else{
                adj2[p[i]].push_back(i);
            }
        }
        for(auto& it:rt)dfs2(it, adj2);
        return sz;
    }
};",1434282672
Tony Li,tonyli0000,108,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
		vector<vector<int>>dp(k + 1, vector<int>(n, -1));
		for (int i = 0; i < n; i++)dp[0][i] = 0;
		for (int i = 1; i <= k; i++) {
			for (int j = 0; j < n; j++) {
				dp[i][j] = max(dp[i][j], dp[i - 1][j] + stay[i - 1][j]);
				for (int a = 0; a < n; a++) {
					if (a == j)continue;
					dp[i][j] = max(dp[i][j], dp[i - 1][a] + travel[a][j]);
				}
			}
		}
		int ret = 0;
		for (int i = 0; i < n; i++)ret = max(ret, dp[k][i]);
		return ret;
    }
};",1434291085
Tony Li,tonyli0000,108,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        vector<pair<char,int>>all;
        all.push_back({word[0],1});
        for(int i=1;i<n;i++){
            if(word[i] == all.back().first)all.back().second++;
            else all.push_back({word[i],1});
        }
        int ret = 1;
        for(auto& it:all){
            ret += it.second - 1;
        }
        return ret;
    }
};",1434260409
Tony Li,tonyli0000,108,3618,cpp,"
#define MOD 1000000007
class Solution {
public:
    int possibleStringCount(string word, int k) {
        int n = word.size();
        if (n < k)return 0;
        vector<pair<char, int>>all;
        all.push_back({ word[0],1 });
        for (int i = 1; i < n; i++) {
            if (word[i] == all.back().first)all.back().second++;
            else all.push_back({ word[i],1 });
        }

        vector<long long>r;
        for (int i = all.size() - 1; i >= 0; i--) {
            long long start;
            if (i == all.size() - 1)start = 1;
            else start = r.back();
            r.push_back(start);
            for (long long j = 2; j <= all[i].second; j++) {
                r.push_back((start * j) % MOD);
            }
        }
        reverse(r.begin(), r.end());

        int m = all.size();
        vector<vector<long long>>T(min(m, k) + 1, vector<long long>(k + 1, 0));
        T[0][0] = 1;
        vector<long long>sum(k + 2, 0);
        int pos = 0;
        long long ret = 0;
        for (int i = 1; i <= min(m, k); i++) {
            sum.assign(k + 2, 0);
            for (int j = 0; j <= k; j++) {
                sum[j + 1] = (sum[j] + T[i - 1][j])%MOD;
            }
            
            int sz = all[i - 1].second;
            for (int j = k - 1; j > 0; j--) {
                int l = max(j - sz, 0), r = j - 1;
                T[i][j] = (sum[r + 1] + MOD - sum[l])%MOD;
            }
            pos+=sz;
            for (int j = 1; j <= sz; j++) {
                int l = max(k - j, 0);
                long long v = (MOD + sum[k] - sum[l])%MOD;
                long long mult = 1;
                if (pos != n)mult = r[pos];
                ret = (ret + (v * mult) % MOD) % MOD;
            }
        }
        return ret;
    }
};",1434357743
Harsh Kumar Gupta,imguptaharsh,110,3576,cpp,"
class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> child(n, vector<int>());
        vector<vector<int>> next_child(n, vector<int>());
        for(int x = 1; x < n; ++x){
            child[parent[x]].push_back(x);
        }
        vector<int> curr_p = parent;
        vector<int> last_see(26, -1);
        function<void(int)> check_dfs = [&](int x) {
            int c = s[x] - 'a';
            int last_check = last_see[c];
            if(last_check != -1){
                curr_p[x] = last_check;
            }
            last_see[c] = x;
            for(auto &child : child[x]){
                check_dfs(child);
            }
            last_see[c] = last_check;
        };
        check_dfs(0);
        for(int x = 1; x < n; ++x){
            next_child[curr_p[x]].push_back(x);
        }
        vector<int> res(n, 0);
        function<int(int)> check_size = [&](int x) -> int {
            int size = 1;
            for(auto &child : next_child[x]){
                size += check_size(child);
            }
            res[x] = size;
            return size;
        };
        check_size(0);
        return res;
    }
};
",1434315687
Harsh Kumar Gupta,imguptaharsh,110,3587,cpp,"
class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travel_s) {
        vector<vector<int>> dp(k, vector<int>(n, 0));
        int ans = 0;
        for (int curr = 0; curr < n; ++curr) {
            int mx_len = 0;
            for (int it = 0; it < n; ++it) {
                mx_len = max(mx_len, travel_s[it][curr]);
            }
            dp[0][curr] = max(stayScore[0][curr], mx_len);
        }
        int curr_day = 1;
        while(curr_day < k) {
            for (int curr = 0; curr < n; ++curr) {
                dp[curr_day][curr] = dp[curr_day - 1][curr] + stayScore[curr_day][curr];

                for (int it = 0; it < n; ++it) {
                    int points = dp[curr_day - 1][it] + travel_s[it][curr];
                    dp[curr_day][curr] = max(dp[curr_day][curr], points);
                }
            }
            curr_day++;
        }
        int curr = 0;
        while(curr < n) {
            ans = max(ans, dp[k - 1][curr]);
            curr++;
        }

        return ans;
    }
};
",1434334538
Harsh Kumar Gupta,imguptaharsh,110,3617,cpp,"class Solution {
public:
    int possibleStringCount(string words) {
        int n = words.size();
        int ans = 1; 
        std::vector<int> rep_num;
    
        int i = 0;
        while (i < n) {
            int nt = 1;
            while (i + 1 < n && words[i] == words[i + 1]) {
                ++nt;
                ++i;
            }
            if (nt > 1) {
                rep_num.push_back(nt);
            }
            ++i;
        }
    
        for (int it : rep_num) {
            ans += it - 1;
        }
    
        return ans;
    }

};",1434324063
Harsh Kumar Gupta,imguptaharsh,110,3618,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;

    int possibleStringCount(string word, int k) {
        vector<int> arr;
        int n = word.length();
        int i = 0;
        long long total_possiblilty = 1;
         int mx_length = k - 1;
        vector<long long> dp(mx_length + 1, 0);
        dp[0] = 1; 
        
        vector<long long> p_sum(mx_length + 1, 0);
        vector<long long> seccond_dp(mx_length + 1, 0);
        while (i < n) {
            int cnt = 1;
            while (i + 1 < n && word[i] == word[i + 1]) {
                cnt++;
                i++;
            }
            arr.push_back(cnt);
            total_possiblilty = (total_possiblilty * (long long)cnt) % mod;
            i++;
        }
        
        int m = arr.size();
        
        if (m > k) {
            return (int)total_possiblilty;
        }
        
       
        
        for(auto it : arr){
            p_sum[0] = dp[0];
            for(int j = 1; j <= mx_length; j++) {
                p_sum[j] = (p_sum[j - 1] + dp[j]) % mod;
            }

            for(int j = 0; j <= mx_length; j++) {
                if(j >= 1){
                    seccond_dp[j] = p_sum[j - 1];
                }
                else{
                    seccond_dp[j] = 0;
                }
                if(j > it){
                    seccond_dp[j] = (seccond_dp[j] - p_sum[j - it - 1] + mod) % mod;
                }
                seccond_dp[j] %= mod;
            }
            dp = seccond_dp;
            fill(seccond_dp.begin(), seccond_dp.end(), 0);
        }

        long long wrong = 0;
        for(int j = 0; j <= mx_length; j++) {
            wrong = (wrong + dp[j]) % mod;
        }
        long long ans = (total_possiblilty - wrong + mod) % mod;
        return (int)ans;
    }
};
",1434345197
HinaSnow,HanaYukii,115,3576,cpp,"class Solution {
public:
    vector<int>g[100005], g2[100005];
    vector<int>c[26];
    vector<int>pa;
    vector<int>ret;
    string str;
    void dfs(int now, int pa) {
        if (c[str[now] - 'a'].size()) {
            g2[c[str[now] - 'a'].back()].push_back(now);
        }
        else {
            if (~pa) {
                g2[pa].push_back(now);
            }
        }
        c[str[now] - 'a'].push_back(now);
        for (auto &i : g[now]) {
            dfs(i, now);
        }
        c[str[now] - 'a'].pop_back();
    }
    void dfs2(int now) {
        ret[now] = 1;
        for (auto &i : g2[now]) {
            dfs2(i);
            ret[now] += ret[i];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        ret.resize(p.size());
        pa = p;
        str = s;
        for (int i = 1 ; i < p.size() ; i++) {
            g[p[i]].push_back(i);
        }
        dfs(0, -1);
        dfs2(0);
        return ret;
    }
};",1434295884
HinaSnow,HanaYukii,115,3587,cpp,"class Solution {
public:
    int maxScore(int n, int z, vector<vector<int>>& s, vector<vector<int>>& t) {
        int dp[205][205] = {};
        int ans = 0;
        for (int i = 0 ; i < n ; i++) {
            dp[i][0] = 0;
        }
        for (int i = 1 ; i <= z ; i++) {
            for (int j = 0 ; j < n ; j++) {
                for (int k = 0 ; k < n ; k++) {
                    if (j == k) {
                        dp[j][i] = max(dp[j][i], dp[j][i - 1] + s[i-1][j]);
                    } else {
                        dp[j][i] = max(dp[j][i], dp[k][i - 1] + t[k][j]);
                    }
                }
                if(i==z) {
                    ans = max(ans, dp[j][i]);
                }
            }
        }
        return ans;
    }
};",1434308151
HinaSnow,HanaYukii,115,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        char last = '1';
        for (auto &i : word) {
            if (i == last) ans++;
            last = i;
        }
        return ans;
    }
};",1434263080
HinaSnow,HanaYukii,115,3618,cpp,"class Solution {
public:
    const int mod = 1e9+7;
    int possibleStringCount(string word, int k) {
        vector<int>tar;
        long long ans = 1;
        int cnt = 0;
        char last = 0;
        for (auto &i:word) {
            if (last == 0 || i == last) {
                cnt++;
            } else{
                tar.push_back(cnt);
                cnt = 1;
            }
            last = i;
        }
        tar.push_back(cnt);
        for (auto &i : tar) {
            ans *= i;
            ans %= mod;
        }
        cout << ans << endl;
        if (tar.size() < k) {
            long long pre[2005][2005] = {};
            for (int i = 0 ; i <= k ; i++) {
                pre[0][i] = 1;
            }
            for (int i = 1 ; i <= tar.size() ; i++) {
                int num = tar[i - 1];
                for (int j = i ; j <= k ; j++) {
                    int low = j - num;
                    int high = j - 1;
                    long long add;
                    if (low <= 0) {
                        add = pre[i - 1][high];
                    } else {
                        add = (pre[i - 1][high] - pre[i - 1][low - 1] + mod) % mod;
                    }
                    pre[i][j] = (pre[i][j - 1] + add) % mod;
                }
            }
            ans += mod;
            ans -= pre[tar.size()][k - 1];
            ans %= mod;
        }
        return ans;
    }
};",1434365977
Pavlo Soroka,Chasey,116,3576,cpp,"class Solution {
public:
    void dfs(vector<vector<int>>& vis, int curr, vector<vector<int>>& g, string& s, vector<int>& newParent) {
        int j = s[curr]-'a';
        if (vis[j].size() > 0) newParent[curr] = vis[j].back();
        vis[j].push_back(curr);
        for (auto x : g[curr]) dfs(vis, x, g, s, newParent);
        vis[j].pop_back();
    }

    int dfs1(int curr, vector<vector<int>>& g, vector<int>& res) {
        int c = 1;
        for (auto x : g[curr]) c += dfs1(x, g, res);
        res[curr] = c;
        return c;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> newParent = parent;
        vector<vector<int>> vis(26);
        int n = parent.size(); vector<vector<int>> g(n);
        for (int i = 1; i < n; i++) g[parent[i]].push_back(i);
        dfs(vis, 0, g, s, newParent);

        vector<int> res(n);
        vector<vector<int>> g1(n);
        for (int i = 1; i < n; i++) g1[newParent[i]].push_back(i);
        dfs1(0, g1, res);
        
        return res;
    }
};",1434273879
Pavlo Soroka,Chasey,116,3587,cpp,"class Solution {
public:
    int n,k;

    int dfs(int day, int curr, vector<vector<int>>& dp, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        if (day == k) return 0;
        if (dp[curr][day] != -1) return dp[curr][day];
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (i == curr) {
                res = max(res, stay[day][curr]+dfs(day+1, i, dp, stay, travel));
            } else {
                res = max(res, travel[curr][i]+dfs(day+1, i, dp, stay, travel));
            }
        }
        return dp[curr][day] = res;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        this->n = n; this->k = k;
        int res = 0;
        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));
        for (int i = 0; i < n; i++) res = max(res, dfs(0, i, dp, stayScore, travelScore));
        return res;        
    }
};",1434286122
Pavlo Soroka,Chasey,116,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 0;
        int count = 0; int n = word.size();
        for (int i = 0; i < n; i++) {
            count++;
            if (i+1 < n && word[i+1] == word[i]) continue;
            res += count-1;
            count = 0;
        }
        return res+1;
    }
};",1434293534
Pavlo Soroka,Chasey,116,3618,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    int possibleStringCount(string word, int k) {
        ll n = word.size();
        ll count = 0;
        vector<ll> v;
        REP(i, n) {
            count++;
            if (i+1 < n && word[i+1] == word[i]) continue;
            k--;
            if (count > 1) v.push_back(count);
            count = 0;
        }
        ll denom = 1e9+7;
        ll m = v.size(); k = max(k, 0);
        vector<vector<ll>> dp(m+1, vector<ll>(k+1, 0)); dp[m][0] = 1;
        vector<ll> pref(k+2, 0);
        for (ll i = m-1; i >= 0; i--) {
            REP(j, k+2) pref[j] = 0;
            REP(j, k+1) pref[j+1] = (pref[j] + dp[i+1][j])%denom;
            
            for (ll j = 0; j <= k; j++) {
                ll bot = j-v[i]+1; 
                if (bot < 0) { dp[i][j] += dp[i+1][0]*abs(bot); bot = 0; }
                dp[i][j] += (pref[j+1] - pref[bot]);
                dp[i][j] += denom;
                dp[i][j] %= denom;
                // for (ll a = 0; a < v[i]; a++) dp[i][j] += dp[i+1][max(j-a, 0ll)];
                // dp[i][j] %= denom;
                // dp[i][j] = dp[i+1][j] + dp[i+1][j-1] + ... + dp[i+1][j-v[i]+1]    
            }
        }
        return dp[0][k];
    }
};",1434353765
Ivan Li,liivan256,117,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        graph = [[] for _ in range(n)]
        for i, v in enumerate(parent):
            if i != -1 and v != -1:
                graph[i].append(v)
                graph[v].append(i)
    
        new_par = [-1] * n
    
        def solve(cur, prev, letters):
            letters[ord(s[cur]) - ord('a')] = cur
            for adj in graph[cur]:
                if adj == prev:
                    continue
                c = ord(s[adj]) - ord('a')
                if letters[c] != -1:
                    new_par[adj] = letters[c]
                else:
                    new_par[adj] = cur
                solve(adj, cur, letters.copy())
    
        solve(0, -1, [-1] * 26)
    
        graph2 = [[] for _ in range(n)]
        for i, v in enumerate(new_par):
            if i != -1 and v != -1:
                graph2[i].append(v)
                graph2[v].append(i)
    
        sizes = [1] * n
    
        def get_sizes(cur, prev):
            for adj in graph2[cur]:
                if adj == prev:
                    continue
                get_sizes(adj, cur)
                sizes[cur] += sizes[adj]
    
        get_sizes(0, -1)
        return sizes",1434279484
Ivan Li,liivan256,117,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def solve(i, curr):
            if i >= k:
                return 0
            b = stayScore[i][curr] + solve(i + 1, curr)
            for dest in range(n):
                if dest == curr:
                    continue
                b = max(b, travelScore[curr][dest] + solve(i + 1, dest))
            return b
    
        best = 0
        for start in range(n):
            best = max(best, solve(0, start))
        return best",1434293453
Ivan Li,liivan256,117,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        group = [1]
        for i in range(1,len(word)):
            if word[i] == word[i-1]:
                group[-1] += 1
            else:
                group.append(1)

        return sum(i - 1 for i in group) + 1",1434261476
Ivan Li,liivan256,117,3618,python3,"
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        
        group = [1]
        for i in range(1, len(word)):
            if word[i] == word[i - 1]:
                group[-1] += 1
            else:
                group.append(1)
    
        n = len(group)
    
        total = 1
        for sz in group:
            total *= sz
            total %= MOD
    
        if n >= k:
            return total
    
        # subtract < k choices
    
        # a1 + a2 + ... + an <= k - n
        leq_k = 0
        target = k - n  # account for mandatory
    
        # count how many sum to target, 1 <= choice[i] <= group[i]
        # dp[cur_sum][idx] = ways
        # transition: prefix product with mod
        # up to not including target
        dp = [[0] * target for _ in range(n)]
        group = [i - 1 for i in group]
    
        for i in range(min(target,group[0] + 1)):
            dp[0][i] = 1
        for idx in range(1, n):
            psa = [0] + list(accumulate(dp[idx - 1], func=lambda x, y: x + y % MOD))
    
            query = lambda l, r: (psa[r + 1] - psa[l]) % MOD
    
            for cur_s in range(target):
                # transition, sum(dp[i-group[idx]: i])
                dp[idx][cur_s] = (dp[idx][cur_s] + query(max(0, cur_s - group[idx]), cur_s)) % MOD
    
        leq_k = sum(dp[-1])
    
        return (total - leq_k) % MOD",1434367420
Chaitanya Bhutada,_chaitanya99,118,3576,cpp,"class Solution {
private:
    void dfs(int x, vector<vector<int>>& adj, vector<int> p, vector<int>& parent, string &s) {
        if (x != 0 && p[s[x]-'a'] != -1) parent[x] = p[s[x]-'a'];
        p[s[x]-'a'] = x;
        for (auto &i: adj[x]) dfs(i, adj, p, parent, s);
    }
    void dfs2(int x, vector<int>& ans, vector<vector<int>>& adj) {
        ans[x] = 1;
        for (auto &i: adj[x]) {
            dfs2(i, ans, adj);
            ans[x] += ans[i];
        }
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj;
        adj.assign(n, vector<int>());
        for (int i = 1; i < n; i++) adj[parent[i]].push_back(i);
        vector<int> p(26, -1);
        dfs(0, adj, p, parent, s);
        adj.assign(n, vector<int>());
        for (int i = 1; i < n; i++) adj[parent[i]].push_back(i);
        vector<int> ans(n, 0);
        dfs2(0, ans, adj);
        return ans;
    }
};",1434358010
Chaitanya Bhutada,_chaitanya99,118,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> ndp(n, 0), dp(n, 0);
        for (int i = 1; i <= k; i++) {
            dp = ndp;
            for (int j = 0; j < n; j++) {
                for (int jj = 0; jj < n; jj++) {
                    if (j == jj) {
                        ndp[j] = max(ndp[j], dp[j] + stayScore[i-1][j]);
                    } else {
                        ndp[j] = max(ndp[j], dp[jj] + travelScore[jj][j]);
                    }
                }
            }
        }
        return *max_element(ndp.begin(), ndp.end());
    }
};",1434367738
Chaitanya Bhutada,_chaitanya99,118,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for (int i = 0; i < word.length(); ) {
            int st = i;
            while (i+1 < word.length() && word[i+1] == word[st]) i++;
            ans += (i-st);
            i++;
        }
        return ans;
    }
};",1434264157
Chaitanya Bhutada,_chaitanya99,118,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        long long ans = 1;
        int mod = 1000000007;
        vector<int> b;
        for (int i = 0; i < word.length(); ) {
            int st = i;
            while (i+1 < word.length() && word[i+1] == word[st]) i++;
            i++;
            ans *= (long long)(i-st);
            b.push_back(i-st);
            ans %= mod;
        }
        vector<int> ndp(k+1, 0), dp;
        for (int i = 1; i <= min(k, b[0]); i++) {
            ndp[i] = 1;
        }
        int mnpos = 1;
        for (int i = 1; i < b.size(); i++) {
            dp = ndp;
            ndp[0] = 0;
            for (int j = mnpos; j <= k; j++) {
                ndp[j] = ndp[j-1];
                ndp[j] += dp[j-1];
                ndp[j] %= mod;
                if ((j-b[i]-1) >= 0) ndp[j] += (mod-dp[j-b[i]-1]);
                ndp[j] %= mod;
            }
            mnpos++;
        }
        for (int i = 0; i < k; i++) {
            ans += (mod-ndp[i]);
            ans %= mod;
        }
        return ans;
    }
};",1434326298
Swagata Samanta,Swagata36,119,3576,cpp,"struct ownFrame {
        int node;
        bool dead;
        int visited;
        ownFrame(int node, bool dead, int visited) : node(node), dead(dead), visited(visited) {}
    };
class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> T(n);
        for (int i = 1; i < n; ++i) {
            T[parent[i]].push_back(i);
        }

        vector<int>par(n);
        memcpy(&par[0], &parent[0], n * sizeof(int));
        vector<int> vis(26, -1);

        stack<ownFrame> st;
        st.push(ownFrame(0, false, -1));

        while (!st.empty()) {
            ownFrame current = st.top();
            st.pop();
            int node = current.node;
            if (!current.dead) {
                char c = s[node];
                int cIdx = c - 'a';
                int y = vis[cIdx];
                if (y != -1) {
                    par[node] = y;
                }

                st.push(ownFrame(node, true, vis[cIdx]));
                vis[cIdx] = node;

                for (int i = T[node].size() - 1; i >= 0; i--) {
                    st.push(ownFrame(T[node][i], false, -1));
                }
            } else {
                char c = s[node];
                int idx = c - 'a';
                vis[idx] = current.visited;
            }
        }

        vector<vector<int>> newT(n);
        for(int i=1;i<n;i++) {
            newT[par[i]].push_back(i);
        }

        vector<int> size(n);
        st.push(ownFrame(0, false, -1));

        while(!st.empty()) {
            ownFrame cur = st.top();
            st.pop();
            int node = cur.node;
            if (!cur.dead) {
                st.push(ownFrame(node, true, -1));
                for (int i = newT[node].size() - 1; i >= 0; i--) {
                    st.push(ownFrame(newT[node][i], false, -1));
                }
            } else {
                size[node] = 1;
                for (int child : newT[node]) {
                    size[node] += size[child];
                }
            }
        }

        return size;
    }
};",1434332144
Swagata Samanta,Swagata36,119,3587,python,"class Solution(object):
    def maxScore(self, n, k, stayScore, travelScore):
        dp = [[0] * n for _ in range(k + 1)]

        for i in range(k + 1):
            for j in range(n):
                if i > 0:
                    dp[i][j] = dp[i - 1][j] + stayScore[i - 1][j]
                    for prev in range(n):
                        if prev != j:
                            dp[i][j] = max(dp[i][j], dp[i - 1][prev] + travelScore[prev][j])

        ans = max(dp[k])
        return ans
        ",1434294123
Swagata Samanta,Swagata36,119,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int n = word.length();
        for(int i=0; i< n - 1; i++) {
            if (word[i] == word[i + 1]) {
                ans += 1;
            }
        }
        return ans;
    }
};",1434285361
Swagata Samanta,Swagata36,119,3618,python,"class Solution(object):
    def possibleStringCount(self, word, k):
        mod = 1e9 + 7

        arr = []
        n = len(word)
        idx = 0

        while idx < n:
            ch = word[idx]
            cnt = 1
            idx += 1
            while idx < n and word[idx] == ch:
                cnt += 1
                idx += 1
            arr.append(cnt)

        n2 = len(arr)
        summation = sum(arr)

        if summation < k: return 0

        totalPoss = 1
        for it in arr:
            totalPoss = (totalPoss * it) % mod

        if n2 > k:return int(totalPoss)
        
        s = k - n2
        if s <= 0: return int(totalPoss)

        maxi = summation - n2
        if s > maxi:return 0

        dp = [0] * s
        dp[0] = 1
        for it in arr:
            curr_idx = it - 1
            dp2 = [0] * s
            preSum = [0] * s
            preSum[0] = dp[0]
            for j in range(1, s):
                preSum[j] = (preSum[j - 1] + dp[j]) % mod
            for j in range(s):
                vote = min(curr_idx, j)
                if j - vote - 1 >= 0:
                    dp2[j] = (preSum[j] - preSum[j - vote - 1] + mod) % mod
                else:
                    dp2[j] = preSum[j] % mod
            
            dp = dp2

        sum2 = sum(dp) % mod

        ans = (totalPoss-sum2 + mod) % mod
        return int(ans)
        ",1434367865
boobik,boobik,120,3576,cpp,"class Solution {
public:


    void dfs(int v, vector<vector<int>>& t, vector<int>& sz) {
        sz[v] = 1;
        for (int u : t[v]) {
            dfs(u, t, sz);
            sz[v] += sz[u];
        }
    }


    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int a = parent.size();
        vector <int> new_p(a);
        vector <vector<int>> g(a);
        for (int i=0;i<a;i++) {
            if (parent[i]!=-1) {
                g[parent[i]].push_back(i);
            }
        }
        
        for (int i=0;i<26;i++) {
            queue <int> q;
            vector <int> last(a);
            vector <int> tt(a);
            last[0]=-1;
            tt[0] = -1;
            if (s[0] - 'a' == i) {tt[0]=0; } 
            vector <bool> used(a);
            q.push(0);used[0] =true;
            while (!q.empty()) {
                int c = q.front(); q.pop(); 
                for (auto& v:g[c]) {
                    if (!used[v]){used[v] = true; q.push(v); 
                    last[v] = tt[c]; tt[v] = last[v]; if (s[v]-'a' == i) {tt[v] = v; }            
                    }
                }
            }
            for (int j=0;j<a;j++) {if (s[j]-'a' == i) {
                if (last[j]!=-1) {new_p[j] = last[j];
                } else new_p[j] = parent[j]; 
            
            }}
        }
        
        // for (int i=0;i<a;i++) cout<<new_p[i]<<"" ""; 
        
        vector<vector<int>> t(a);
        for (int i = 1; i < a; ++i) {
            if (new_p[i] != -1) {
                t[new_p[i]].push_back(i);
            }
        }

        vector<int> ans(a);
        dfs(0, t, ans);
        return ans;
        
        
    }
};",1434367903
boobik,boobik,120,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector <vector<int>> ans(n, vector <int>(k));
        for (int i=0;i<n;i++) {
            ans[i][0] = stayScore[0][i];
        }
        for (int i=0;i<n;i++) {
            for (int j=0;j<n;j++) {
                ans[j][0] = max(ans[j][0], travelScore[i][j]);
            }
        }
        for (int i=1;i<k;i++) {
            for (int j=0;j<n;j++) {
                ans[j][i] = ans[j][i-1] + stayScore[i][j];
                for (int kk=0;kk<n;kk++) {
                    ans[j][i] = max(ans[j][i], ans[kk][i-1] + travelScore[kk][j]);
                }
            }
        }
        int aa = 0;
        for (int i=0;i<n;i++) aa=max(aa, ans[i][k-1]);
        return aa;
    }
};",1434334285
boobik,boobik,120,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int a = word.size();
        for (int i=1;i<a;i++) {
            ans+=(word[i]==word[i-1]);
        }
        return ans;
    }
};",1434332527
boobik,boobik,120,3618,cpp,"class Solution {
public:
    long long answer(vector <long long>& a, int k) {
        int n = a.size();
        vector<long long> dp(k+1);
        dp[0] = 1;
        long long MOD = 1000000007;

        for (long long i = 1; i <= n; ++i) {
            vector <long long> pref(k);
            for (int j=0;j<k;j++) {
                pref[j] = (j > 0 ? pref[j-1]:0) + dp[j]; pref[j]%=MOD;
            }
           for (int j=k-1;j>=0;j--) {
               dp[j] = pref[j] - ( j - a[i-1] - 1 >=0 ? pref[j - a[i-1] - 1] : 0) + MOD;
               dp[j]%=MOD;
           }
        }
        long long ans = 0;
        for (int i=0;i<k;i++) ans+=dp[i];
        return ans%MOD;
    }
    
    int possibleStringCount(string word, int k) {
            vector <long long> can;
            int cur = 0;
            int tt = 0;
            int a = word.size();
            for (int i=0;i<a;i++) {
                if (i==0 || word[i]==word[i-1]) {
                    cur++;
                } else {
                    tt++;
                    if (cur>1) can.push_back(cur-1); cur=1;
                }
            }
        if (cur>0) tt++;
        if (cur>1) can.push_back(cur-1);
        if (k > a) {
            return 0;
        }
        long long ans = 1;
        long long mod = 1000000007;
        for (auto& cc:can) { ans*= cc+1; ans%=mod; } 
        if (can.empty()) {
            if (a>=k) {
                return 1;
            } else {
                return 0;
            }
        }
        if (tt >= k) {
            return ans;
        }
        int less = k - tt;
        int pepega = answer(can, less);
        // cout<<pepega<<""!\n"";
        ans += mod - pepega; ans%=mod; return ans;
        
    }
};",1434331827
mudassir,3ev4O9pbhZ,121,3576,python3,"from collections import defaultdict, deque
from typing import List, Dict

class Solution:
    
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj_list = defaultdict(list)  
        subtree_sizes = [0] * n  

        
        for i in range(1, n):
            adj_list[parent[i]].append(i)
        
        
        new_parent = parent[:] 
        char_to_ancestor = defaultdict(deque)
        
        
        self.dfs_reparent(0, s, adj_list, new_parent, char_to_ancestor)
        
        
        new_adj_list = defaultdict(list)
        for i in range(1, n):
            new_adj_list[new_parent[i]].append(i)
        
        
        self.calculate_subtree_size(0, new_adj_list, subtree_sizes)
        
        return subtree_sizes
    
    
    def dfs_reparent(self, node: int, s: str, adj_list: Dict[int, List[int]],
                     new_parent: List[int], char_to_ancestor: Dict[str, deque]):
        char_to_ancestor[s[node]].append(node)  

        for child in adj_list[node]:
            ancestor = self.find_ancestor(child, s, char_to_ancestor)
            if ancestor != -1:
                new_parent[child] = ancestor  
            self.dfs_reparent(child, s, adj_list, new_parent, char_to_ancestor)  
        
        char_to_ancestor[s[node]].pop()  
    
    
    def find_ancestor(self, node: int, s: str, char_to_ancestor: Dict[str, deque]) -> int:
        character = s[node]
        if not char_to_ancestor[character]:
            return -1
        return char_to_ancestor[character][-1]
    
  
    def calculate_subtree_size(self, node: int, adj_list: Dict[int, List[int]], subtree_sizes: List[int]) -> int:
        size = 1
        for child in adj_list[node]:
            size += self.calculate_subtree_size(child, adj_list, subtree_sizes)
        subtree_sizes[node] = size
        return size
",1434346752
mudassir,3ev4O9pbhZ,121,3587,python,"class Solution:
    def combinations(self, total, choose):
        # p holds the value of total*(total-1)*(total-2)...,
        # k holds the value of choose*(choose-1)...
        p, k = 1, 1

        # C(total, choose) == C(total, total-choose),
        # choosing the smaller value
        if total - choose < choose:
            choose = total - choose

        if choose != 0:
            while choose:
                p *= total
                k *= choose

                # gcd of p, k
                m = gcd(p, k)

                # dividing by gcd to simplify
                # saves from overflow
                p //= m
                k //= m

                total -= 1
                choose -= 1
        else:
            p = 1

        # p is the answer as k should be simplified to 1
        return p

    def helper(self, current_day, current_choice, days, choices, score_matrix, transfer_score, memo):
        if current_day == days:
            return 0
        if memo[current_day][current_choice] != -1:
            return memo[current_day][current_choice]

        max_score = self.helper(current_day + 1, current_choice, days, choices, score_matrix, transfer_score, memo) + score_matrix[current_day][current_choice]
        
        for i in range(choices):
            if i != current_choice:
                max_score = max(max_score, self.helper(current_day + 1, i, days, choices, score_matrix, transfer_score, memo) + transfer_score[current_choice][i])

        memo[current_day][current_choice] = max_score
        return max_score

    def maxScore(self, choices, days, score_matrix, transfer_score):
        memo = [[-1] * choices for _ in range(days)]
        max_result = 0
        for i in range(choices):
            max_result = max(max_result, self.helper(0, i, days, choices, score_matrix, transfer_score, memo))
        return max_result
",1434282699
mudassir,3ev4O9pbhZ,121,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
     int ans=1;
        int n=w.size();
        for(int x=0;x<n;){
            int y=x;
            while(y<n&&w[y]==w[x]){
                y++;
            }
            if(y-x>1)
                ans+=y-x-1;
            x=y;
        }
        return ans;

    }
};",1434296910
mudassir,3ev4O9pbhZ,121,3618,python3,"MOD = int(1e9 + 7)

def ncr(n, r):
    p = 1
    k = 1

    if n - r < r:
        r = n - r

    if r != 0:
        while r:
            p *= n
            k *= r
            m = math.gcd(p, k)
            p //= m
            k //= m
            n -= 1
            r -= 1
    else:
        p = 1

    return p

class Solution:
    
    def possibleStringCount(self, word: str, max_k: int) -> int:
        runs = []
        length = len(word)
        
        if length == 0:
            return 1 if max_k == 0 else 0
        
        current_char = word[0]
        char_count = 1
        
        for i in range(1, length):
            if word[i] == current_char:
                char_count += 1
            else:
                runs.append((current_char, char_count))
                current_char = word[i]
                char_count = 1
        
        runs.append((current_char, char_count))

        total_combinations = 1
        for _, count in runs:
            total_combinations = (total_combinations * count) % MOD

        num_segments = len(runs)
        min_sum = num_segments
        
        if max_k <= min_sum:
            return total_combinations

        dp = [0] * max_k
        dp[0] = 1

        for _, segment_length in runs:
            new_dp = [0] * max_k
            prefix_sum = [0] * (max_k + 1)
            
            for j in range(max_k):
                prefix_sum[j + 1] = (prefix_sum[j] + dp[j]) % MOD
            
            for j in range(max_k):
                lower_bound = j - segment_length
                segment_total = prefix_sum[j] - (prefix_sum[lower_bound] if lower_bound >= 0 else 0)
                segment_total = (segment_total % MOD + MOD) % MOD
                new_dp[j] = segment_total
            
            dp = new_dp

        total_ways_less_k = 0
        for s in range(min_sum, max_k):
            total_ways_less_k = (total_ways_less_k + dp[s]) % MOD

        result = (total_combinations - total_ways_less_k + MOD) % MOD
        return result
",1434374402
Vikash Sangai,VS_Codes,122,3576,cpp,"class Solution {
public:
    void dfs(int src, vector<int> &par, vector<vector<int>> &v, vector<int> &newpar, string &s, vector<int> &val)
    {
        int x=s[src]-'a';
        int prev=val[x];
        val[x]=src;
        for(auto &it:v[src])
        {
            if(it==par[src])
                continue;
            dfs(it,par,v,newpar,s,val);
        }
        val[x]=prev;
        if(val[x]!=-1)
        {
            newpar[src]=val[x];
        }
    }
    void dfs2(int src, vector<int> &par, vector<vector<int>> &v, vector<int> &dp)
    {
        dp[src]++;
        for(auto &it:v[src])
        {
            if(it==par[src])
                continue;
            dfs2(it,par,v,dp);
            dp[src]+=dp[it];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        int n=par.size();
        vector<int> newpar=par;
        vector<vector<int>> v(n);
        for(int i=1;i<n;i++)
        {
            v[par[i]].push_back(i);
            v[i].push_back(par[i]);
        }
        vector<int> val(26,-1);
        dfs(0,par,v,newpar,s,val);
        // v=vector<vector<int>> (n);
        vector<vector<int>> g(n);
        for(int i=1;i<n;i++)
        {
            g[newpar[i]].push_back(i);
            g[i].push_back(newpar[i]);
        }
        vector<int> dp(n,0);
        dfs2(0,newpar,g,dp);
        return dp;
    }
};",1434293873
Vikash Sangai,VS_Codes,122,3587,cpp,"class Solution {
public:
    int rec(int i, int day, int &n, int &k, vector<vector<int>> &s, vector<vector<int>> &t, vector<vector<int>> &dp)
    {
        if(day==k)
            return 0;
        if(dp[i][day]!=-1)
            return dp[i][day];
        int ans=s[day][i]+rec(i,day+1,n,k,s,t,dp);
        for(int j=0;j<n;j++)
        {
            if(j==i)
                continue;
            ans=max(ans,rec(j,day+1,n,k,s,t,dp)+t[i][j]);
        }
        return dp[i][day]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        vector<vector<int>> dp(n+1,vector<int> (k+1,-1));
        int ans=0;
        for(int i=0;i<n;i++)
        {
            ans=max(ans,rec(i,0,n,k,s,t,dp));
        }
        return ans;
    }
};",1434302278
Vikash Sangai,VS_Codes,122,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        int n=word.size(),cnt=1;
        for(int i=1;i<n;i++)
        {
            if(word[i]==word[i-1])
            {
                cnt++;
            }
            else
            {
                ans+=cnt-1;
                cnt=1;
            }
        }
        ans+=cnt-1;
        return ans;
    }
};",1434264447
Vikash Sangai,VS_Codes,122,3618,cpp,"class Solution {
public:
    const long long mod=1e9+7;
    long long rec(vector<int> &v,int &k)
    {
        vector<long long> a(k+1,0LL),b(k+1,0LL),pref(k+1,0LL);
        a[0]=1LL;
        for(auto &it:v)
        {
            int take=it-1;
            pref[0]=a[0];
            b[0]=0;
            for(int i=1;i<k;i++)
            {
                pref[i]=pref[i-1]+a[i];
                pref[i]%=mod;
                b[0]=0;
            }
            for(int i=0;i<min(it,k);i++)
            {
                b[i]=pref[i];
            }
            for(int i=min(it,k);i<k;i++)
            {
                b[i]=pref[i]-pref[i-take-1];
                b[i]+=mod;
                b[i]%=mod;
            }
            a=b;
        }
        long long ans=0;
        for(auto &it:a)
        {
            ans+=it;
            ans%=mod;
        }
        return ans%mod;
    }
    int possibleStringCount(string s, int k) {
        int cnt=1;
        int n=s.size();
        vector<int> v;
        long long res=1;
        for(int i=1;i<n;i++)
        {
            if(s[i]==s[i-1])
            {
                cnt++;
            }
            else
            {
                res*=cnt;
                res%=mod;
                v.push_back(cnt);
                cnt=1;
            }
        }
        res*=cnt;
        res%=mod;
        v.push_back(cnt);
        if(v.size()>=k)
        {
            return res%mod;
        }
        k-=v.size();
        long long ans=rec(v,k);
        // cout<<ans<<"" ""<<res<<endl;
        ans=res-ans;
        ans+=mod;
        ans%=mod;
        return ans%mod;
    }
};",1434376627
i_will_beat_my_iq,i_will_beat_my_iq,124,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n = p.size();
        vector<vector<int>> tr = f1(p, n);
        int rt = f2(p, n);
        
        vector<int> new_p = f3(tr, rt, s, p, n);
        vector<vector<int>> new_tr = f4(new_p, n);
        
        return f5(new_tr, rt, n);
    }
    
    vector<vector<int>> f1(vector<int>& p, int n) {
        vector<vector<int>> tr(n, vector<int>());
        for (int i = 0; i < n; i++) {
            if (p[i] != -1) tr[p[i]].push_back(i);
        }
        return tr;
    }
    
    int f2(vector<int>& p, int n) {
        for (int i = 0; i < n; i++) {
            if (p[i] == -1) return i;
        }
        return -1;
    }
    
    vector<int> f3(vector<vector<int>>& tr, int rt, string s, vector<int>& p, int n) {
        vector<int> new_p(n, -1);
        int last_s[26];
        for (int c = 0; c < 26; c++) last_s[c] = -1;
        
        struct F { int nd; bool is_out; int prev; };
        stack<F> stk;
        stk.push(F{rt, false, -1});
        
        while (!stk.empty()) {
            F f = stk.top(); stk.pop();
            if (!f.is_out) {
                int x = f.nd, idx = s[x] - 'a';
                int y = last_s[idx];
                new_p[x] = (y != -1) ? y : p[x];
                
                stk.push(F{x, true, y});
                for (int i = tr[x].size() - 1; i >= 0; i--) {
                    stk.push(F{tr[x][i], false, -1});
                }
                last_s[idx] = x;
            } else {
                last_s[s[f.nd] - 'a'] = f.prev;
            }
        }
        return new_p;
    }
    
    vector<vector<int>> f4(vector<int>& new_p, int n) {
        vector<vector<int>> new_tr(n, vector<int>());
        for (int x = 0; x < n; x++) {
            if (new_p[x] != -1) new_tr[new_p[x]].push_back(x);
        }
        return new_tr;
    }
    
    vector<int> f5(vector<vector<int>>& new_tr, int rt, int n) {
        vector<int> subtree_sz(n, 1);
        struct F2 { int nd; bool is_out; };
        stack<F2> stk2;
        stk2.push(F2{rt, false});
        
        while (!stk2.empty()) {
            F2 f = stk2.top(); stk2.pop();
            if (!f.is_out) {
                stk2.push(F2{f.nd, true});
                for (auto it = new_tr[f.nd].rbegin(); it != new_tr[f.nd].rend(); it++) {
                    stk2.push(F2{*it, false});
                }
            } else {
                for (auto ch : new_tr[f.nd]) {
                    subtree_sz[f.nd] += subtree_sz[ch];
                }
            }
        }
        return subtree_sz;
    }
};
",1434267056
i_will_beat_my_iq,i_will_beat_my_iq,124,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        if (k == 0 || n == 0) return 0;
        
        vector<int> prev(n, 0), curr(n, 0);
        f1(prev, ss, ts, n);
        
        for (int d = 1; d < k; ++d) {
            f2(d, prev, curr, ss, ts, n);
            prev = curr;
        }
        
        return *max_element(prev.begin(), prev.end());
    }

    void f1(vector<int>& prev, vector<vector<int>>& ss, vector<vector<int>>& ts, int n) {
        for (int c = 0; c < n; ++c) {
            int stay = ss[0][c];
            int travel = 0;
            for (int p = 0; p < n; ++p) {
                if (p != c) travel = max(travel, ts[p][c]);
            }
            prev[c] = max(stay, travel);
        }
    }

    void f2(int d, vector<int>& prev, vector<int>& curr, vector<vector<int>>& ss, vector<vector<int>>& ts, int n) {
        for (int c = 0; c < n; ++c) {
            int stay = prev[c] + ss[d][c];
            int travel = 0;
            for (int p = 0; p < n; ++p) {
                if (p != c) travel = max(travel, prev[p] + ts[p][c]);
            }
            curr[c] = max(stay, travel);
        }
    }
};

",1434278196
i_will_beat_my_iq,i_will_beat_my_iq,124,3617,cpp,"class Solution {
public:
int f2(const string &w) {
        int n = w.size(), i = 0, tot = 0;
        while (i < n) {
            int cnt = f1(w, i, n);
            if (cnt >= 2) tot += (cnt - 1);
        }
        return tot;
    }

    int f1(const string &w, int &i, int n) {
        int cnt = 1;
        while (i + 1 < n && w[i] == w[i + 1]) {
            cnt++;
            i++;
        }
        i++;
        return cnt;
    }
    int possibleStringCount(string word) {
        if (word.empty()) return 0;
        return 1 + f2(word);
    }

};
",1434262543
i_will_beat_my_iq,i_will_beat_my_iq,124,3618,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
class Solution {
public:

    ll MOD = 1e9 + 7;

vector<ll> f1(string& w) {
    vector<ll> cnts;
    ll i = 0, n = w.length();
    while (i < n) {
        char ch = w[i];
        ll ct = 1;
        while (i + 1 < n && w[i + 1] == ch) {
            ct++;
            i++;
        }
        cnts.push_back(ct);
        i++;
    }
    return cnts;
}

ll f2(vector<ll>& cnts) {
    ll tot = 1;
    for (ll c : cnts) tot = tot * c % MOD;
    return tot;
}

vector<ll> f3(vector<ll>& cnts, ll m) {
    vector<ll> dp(m + 1, 0);
    dp[0] = 1;
    for (ll c : cnts) {
        ll mx = c - 1;
        vector<ll> pre(m + 2, 0);
        for (ll j = 0; j <= m; j++) pre[j + 1] = (pre[j] + dp[j]) % MOD;
        
        vector<ll> new_dp(m + 1, 0);
        for (ll j = 0; j <= m; j++) {
            ll l = max(0LL, j - mx);
            new_dp[j] = (pre[j + 1] - pre[l] + MOD) % MOD;
        }
        dp = new_dp;
    }
    return dp;
}

ll f4(vector<ll>& dp, ll tot) {
    ll w = 0;
    for (ll x : dp) w = (w + x) % MOD;
    return (tot - w + MOD) % MOD;
}

ll possibleStringCount(string w, ll k) {
    vector<ll> cnts = f1(w);
    ll tot = f2(cnts);
    ll n = cnts.size();
    if (n > k) return tot;
    
    ll m = k - 1 - n;
    if (m < 0) return tot;
    
    vector<ll> dp = f3(cnts, m);
    return f4(dp, tot);
}
};
",1434353962
lucasomee006,lucasomee006,126,3576,python3,"from collections import defaultdict
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        #so for each node just find the closest ancestor with the same node
        ans = [parent[i] for i in range(len(parent))]
        children = [[] for i in range(len(parent))]
        for i in range(1, len(parent)):
            children[parent[i]].append(i)
        def dfs(i, closestEach):
            if closestEach[s[i]] != -1:
                ans[i] = closestEach[s[i]]
            closestEach[s[i]] = i
            for j in range(len(children[i])):
                dfs(children[i][j], closestEach.copy())
        dfs(0, defaultdict(lambda: -1))
        subSizes = [0 for i in range(len(parent))]
        parent = ans[:]
        children = [[] for i in range(len(parent))]
        for i in range(1, len(parent)):
            children[parent[i]].append(i)
        def newDfs(i):
            sumSub = 0
            for j in range(len(children[i])):
                sumSub += newDfs(children[i][j])
            sumSub += 1
            subSizes[i] = sumSub
            return sumSub        
        newDfs(0)
        return subSizes",1434348707
lucasomee006,lucasomee006,126,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        #on day i, they can move to any city
        #dp[i][j] = best for staying in city j on day i
        dp = [[0 for i in range(n)] for j in range(k+1)]
        dp[0] = [0 for i in range(n)]
        # print(dp)
        for day in range(1, k+1):
            for j in range(n): #j represents the city we're currently in
                # print(j, day)
                # x = dp[j][day]
                # y = dp[j][day-1]
                # z = stayScore[day-1][j]
                dp[day][j] = max(dp[day][j], dp[day-1][j] + stayScore[day-1][j])
                for m in range(n):
                    if m != j:
                        dp[day][j] = max(dp[day][j], dp[day-1][m] + travelScore[m][j])
        # print(dp)
        return max(dp[-1])
                
                
            ",1434367654
lucasomee006,lucasomee006,126,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 0
        numSame = 0
        for i in range(1,len(word)):
            if word[i] == word[i-1]:
                ans += 1
        return ans+1",1434330766
lucasomee006,lucasomee006,126,3618,python3,"class SegmentTree:
    def __init__(self, arr):
        self.n = len(arr)
        self.tree = [0] * (2 * self.n)
        self.build(arr)

    def build(self, arr):

        for i in range(self.n):
            self.tree[self.n + i] = arr[i]

        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]

    def update(self, index, value):
        pos = index + self.n
        self.tree[pos] = value
        while pos > 1:
            pos //= 2
            self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1]

    def range_sum(self, left, right):
        left += self.n
        right += self.n
        sum_ = 0
        while left < right:
            if left % 2 == 1: 
                sum_ += self.tree[left]
                left += 1
            if right % 2 == 1:
                right -= 1
                sum_ += self.tree[right]
            left //= 2
            right //= 2
        return sum_

class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod = 10**9 + 7
        ans = 0
        baseString = [[word[0], 1]]
        for i in range(1, len(word)):
            if word[i] != word[i-1]:
                baseString.append([word[i], 1])
            else:
                baseString[-1][1] += 1
        k -= len(baseString)

            
        includeable = [baseString[i][1]-1 for i in range(len(baseString))]
        ansWithoutRestriction = 1
        for i in range(len(includeable)):
            ansWithoutRestriction *= includeable[i]+1 
            ansWithoutRestriction %= mod

        if k < 0:
            return ansWithoutRestriction
      
        numWays = [[0 for i in range(k+1)] for j in range(len(includeable)+1)]
        numWays[0][0] = 1
        
        for i in range(1, len(includeable)+1):
            max_count = includeable[i - 1]
            cumulative_sum = [0] * (k + 1)
            for j in range(k + 1):
                cumulative_sum[j] = cumulative_sum[j - 1] + numWays[i - 1][j] if j > 0 else numWays[i - 1][j]
                cumulative_sum[j] %= mod
            for j in range(k + 1):
                if j > max_count:
                    numWays[i][j] = cumulative_sum[j] - cumulative_sum[j - max_count - 1]
                    numWays[i][j] %= mod
                else:
                    numWays[i][j] = cumulative_sum[j] % mod
        # print(ansWithoutRestriction)
        # print(numWays)
       
        
        return (ansWithoutRestriction-(sum(numWays[-1][:-1]))%mod) % mod",1434328436
Ajayreddy,Toptodown_Dp,127,3576,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = len(parent);
        vector<vector<int>> g(n);

        For(x, 1, n){
            g[parent[x]].push_back(x);
        }

        auto dfs = [&](auto &&dfs, int v, vector<int> rec)-> void{

            if (rec[s[v] - 'a'] != -1){
                parent[v] = rec[s[v] - 'a'];
            }
            rec[s[v] - 'a'] = v;
            for (auto &ch: g[v]) dfs(dfs, ch, rec);
        };

        dfs(dfs, 0, vector<int>(26, -1));

        g.clear();
        g.resize(n);

        For(x, 1, n){
            g[parent[x]].push_back(x);
        }

        vector<int> ret(n, 1);

        auto dfs2 = [&](auto &&dfs2, int v)-> void{
            for (auto &ch: g[v]){
                dfs2(dfs2, ch);
                ret[v] += ret[ch];
            }
        };

        dfs2(dfs2, 0);
        return ret;
        
    }
};

",1434312766
Ajayreddy,Toptodown_Dp,127,3587,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        
        vector<int> dp(n);

        For(x, k){
            vector<int> ndp(n);
            For(y, n) chmax(ndp[y], stayScore[x][y] + dp[y]);
            For(y, n){
                For(z, n){
                    if (y != z) chmax(ndp[y], travelScore[z][y] + dp[z]);
                }
            }
            swap(dp, ndp);
        }
        return ranges::max(dp);
    }
};

",1434312953
Ajayreddy,Toptodown_Dp,127,3617,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

namespace mitsuha{
template <typename C>
vector<pair<typename C::value_type, int>> run_length_encoding(C& S) {
    using T = typename C::value_type;
    if (S.empty()) return {};
    vector<pair<T, int>> ret;
    T c = S[0];
    int n = 1;
    for (int i = 1; i < (int)S.size(); i++) {
        if (S[i] == c)
            n++;
        else {
            ret.emplace_back(c, n);
            c = S[i], n = 1;
        }
    }
    ret.emplace_back(c, n);
    return ret;
}
} // namespace mitsuha

class Solution {
public:
    int possibleStringCount(string word) {
        int ret = 0;
        for (auto &[_, freq]: run_length_encoding(word)){
            ret += freq - 1;
        }
        return ret + 1;
    }
};

",1434312648
Ajayreddy,Toptodown_Dp,127,3618,cpp,"#ifndef LOCAL
#pragma GCC optimize(""Ofast"", ""unroll-loops"")
#endif

#include <bits/stdc++.h>

namespace mitsuha{
template <typename T, typename U>
std::ostream &operator<<(std::ostream &os, const std::pair<T, U> &A) {
    os << A.first << "" "" << A.second;
    return os;
}

template <typename T>
std::ostream &operator<<(std::ostream &os, const std::vector<T> &A) {
    for (size_t i = 0; i < A.size(); i++) {
        if (i) os << "" "";
        os << A[i];
    }
    return os;
}

void print() {
    std::cout << ""\n"";
    std::cout.flush();
}

template <class Head, class... Tail>
void print(Head &&head, Tail &&... tail) {
    std::cout << head;
    if (sizeof...(Tail)) std::cout << "" "";
    print(std::forward<Tail>(tail)...);
}
}

namespace mitsuha {
template <class T> bool chmin(T& x, const T& y) { 
    return y >= x ? false : (x = y, true); 
}
template <class T> bool chmax(T& x, const T& y) { 
    return y <= x ? false : (x = y, true); 
}
template <class T> constexpr T fld(const T x, const T y) { 
    T q = x / y, r = x % y; return q - ((x ^ y) < 0 and (r != 0)); 
}
template <class T> constexpr T cld(const T x, const T y) { 
    T q = x / y, r = x % y; return q + ((x ^ y) > 0 and (r != 0)); 
}
template <class T> constexpr T rem(const T x, const T y) { 
    return x - y * fld(x, y); 
}
template <class Iterable> void settify(Iterable& a) { 
    std::sort(a.begin(), a.end()), a.erase(std::unique(a.begin(), a.end()), a.end()); 
}
template <typename T, typename... Vectors>
void concat(std::vector<T> &first, const Vectors &... others) {
    std::vector<T> &res = first;
    (res.insert(res.end(), others.begin(), others.end()), ...);
}
template<typename T>
std::map<T, int> Counter(std::vector<T> &a){
    std::map<T, int> cnt;
    for (auto &x: a) ++cnt[x];
    return cnt;
}
template <size_t D> struct Dim : std::array<int, D> {
    template <typename ...Ints> Dim(const Ints& ...ns) : 
        std::array<int, D>::array{ static_cast<int>(ns)... } {}
};
template <typename ...Ints> Dim(const Ints& ...) -> Dim<sizeof...(Ints)>;
template <class T, size_t D, size_t I = 0>
auto ndvec(const Dim<D> &ns, const T& value = {}) {
    if constexpr (I + 1 < D) {
        return std::vector(ns[I], ndvec<T, D, I + 1>(ns, value));
    } else {
        return std::vector<T>(ns[I], value);
    }
}
}

namespace mitsuha {
using str = std::string;
using int128 = __int128;
using uint128 = unsigned __int128;
template <class T> using min_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::greater<T>>;
template <class T> using max_priority_queue 
                            = std::priority_queue<T, std::vector<T>, std::less<T>>;
}
 
#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#define TL (long long)
 
#define OVERLOAD5(a, b, c, d, e, ...) e
#define REP1_0(b, c) REP1_1(b, c)
#define REP1_1(b, c) for (long long REP_COUNTER_##c = 0; REP_COUNTER_##c < TL(b); ++REP_COUNTER_##c)
#define REP1(b) REP1_0(b, __COUNTER__)
#define REP2(i, b) for (long long i = 0; i < TL(b); ++i)
#define REP3(i, a, b) for (long long i = TL(a); i < TL(b); ++i)
#define REP4(i, a, b, c) for (long long i = TL(a); i < TL(b); i += TL(c))
#define For(...) OVERLOAD5(__VA_ARGS__, REP4, REP3, REP2, REP1)(__VA_ARGS__)
#define RREP2(i, a) for (long long i = TL(a)-1; i >= 0; --i)
#define RREP3(i, a, b) for (long long i = TL(b)-1; i >= TL(a); --i)
#define RREP4(i, a, b, c) for (long long i = TL(b)-1; i >= TL(a); i -= TL(c))
#define Frr(...) OVERLOAD5(__VA_ARGS__, RREP4, RREP3, RREP2)(__VA_ARGS__)

#define All(iterable) std::begin(iterable), std::end(iterable)
#define len(iterable) TL iterable.size()
#define elif else if

#define KBIT(a, k) (a & (1ULL << (k)))

#define Assert(x) assert(x);

using namespace mitsuha;
using namespace std;
 
constexpr int iinf = std::numeric_limits<int>::max() / 2;
constexpr long long linf = std::numeric_limits<long long>::max() / 2;

namespace mitsuha{
template <typename C>
vector<pair<typename C::value_type, int>> run_length_encoding(C& S) {
    using T = typename C::value_type;
    if (S.empty()) return {};
    vector<pair<T, int>> ret;
    T c = S[0];
    int n = 1;
    for (int i = 1; i < (int)S.size(); i++) {
        if (S[i] == c)
            n++;
        else {
            ret.emplace_back(c, n);
            c = S[i], n = 1;
        }
    }
    ret.emplace_back(c, n);
    return ret;
}
} // namespace mitsuha

namespace mitsuha{
struct has_mod_impl {
    template <class T>
    static auto check(T &&x) -> decltype(x.get_mod(), std::true_type{});
    template <class T>
    static auto check(...) -> std::false_type;
};

template <class T>
class has_mod : public decltype(has_mod_impl::check<T>(std::declval<T>())) {};

template <typename mint>
mint inv(int n) {
    static const int mod = mint::get_mod();
    static vector<mint> dat = {0, 1};
    assert(0 <= n);
    if (n >= mod) n %= mod;
    while (len(dat) <= n) {
        int k = len(dat);
        int q = (mod + k - 1) / k;
        dat.emplace_back(dat[k * q - mod] * mint::raw(q));
    }
    return dat[n];
}

template <typename mint>
mint fact(int n) {
    static const int mod = mint::get_mod();
    assert(0 <= n && n < mod);
    static vector<mint> dat = {1, 1};
    while (len(dat) <= n) dat.emplace_back(dat[len(dat) - 1] * mint::raw(len(dat)));
    return dat[n];
}

template <typename mint>
mint fact_inv(int n) {
    static vector<mint> dat = {1, 1};
    if (n < 0) return mint(0);
    while (len(dat) <= n) dat.emplace_back(dat[len(dat) - 1] * inv<mint>(len(dat)));
    return dat[n];
}

template <class mint, class... Ts>
mint fact_invs(Ts... xs) {
    return (mint(1) * ... * fact_inv<mint>(xs));
}

template <typename mint, class Head, class... Tail>
mint multinomial(Head &&head, Tail &&... tail) {
    return fact<mint>(head) * fact_invs<mint>(std::forward<Tail>(tail)...);
}

template <typename mint>
mint C_dense(int n, int k) {
    static vector<vector<mint>> C;
    static int H = 0, W = 0;
    auto calc = [&](int i, int j) -> mint {
        if (i == 0) return (j == 0 ? mint(1) : mint(0));
        return C[i - 1][j] + (j ? C[i - 1][j - 1] : 0);
    };
    if (W <= k) {
        for(int i = 0; i < H; ++i) {
            C[i].resize(k + 1);
            for(int j = W; j < k + 1; ++j) { C[i][j] = calc(i, j); }
        }
        W = k + 1;
    }
    if (H <= n) {
        C.resize(n + 1);
        for(int i = H; i < n + 1; ++i) {
            C[i].resize(W);
            for(int j = 0; j < W; ++j) { C[i][j] = calc(i, j); }
        }
        H = n + 1;
    }
    return C[n][k];
}

template <typename mint, bool large = false, bool dense = false>
mint C(long long n, long long k) {
    assert(n >= 0);
    if (k < 0 || n < k) return 0;
    if constexpr (dense) return C_dense<mint>(n, k);
    if constexpr (!large) return multinomial<mint>(n, k, n - k);
    k = min(k, n - k);
    mint x(1);
    for(int i = 0; i < k; ++i) x *= mint(n - i);
    return x * fact_inv<mint>(k);
}

template <typename mint, bool large = false>
mint C_inv(long long n, long long k) {
    assert(n >= 0);
    assert(0 <= k && k <= n);
    if (not large) return fact_inv<mint>(n) * fact<mint>(k) * fact<mint>(n - k);
    return mint(1) / C<mint, true>(n, k);
}

// [x^d](1-x)^{-n}
template <typename mint, bool large = false, bool dense = false>
mint C_negative(long long n, long long d) {
    assert(n >= 0);
    if (d < 0) return mint(0);
    if (n == 0) { return (d == 0 ? mint(1) : mint(0)); }
    return C<mint, large, dense>(n + d - 1, d);
}
} // namespace mitsuha

namespace mitsuha{
template <int mod>
struct modint {
    static constexpr unsigned int umod = (unsigned int)(mod);
    static_assert(umod < 1U << 31);
    unsigned int val;

    static modint raw(unsigned int v) {
        modint x;
        x.val = v;
        return x;
    }
    constexpr modint() : val(0) {}
    constexpr modint(unsigned int x) : val(x % umod) {}
    constexpr modint(unsigned long long x) : val(x % umod) {}
    constexpr modint(unsigned __int128 x) : val(x % umod) {}
    constexpr modint(int x) : val((x %= mod) < 0 ? x + mod : x){};
    constexpr modint(long long x) : val((x %= mod) < 0 ? x + mod : x){};
    constexpr modint(__int128 x) : val((x %= mod) < 0 ? x + mod : x){};
    bool operator<(const modint &other) const { return val < other.val; }
    modint &operator+=(const modint &p) {
        if ((val += p.val) >= umod) val -= umod;
        return *this;
    }
    modint &operator-=(const modint &p) {
        if ((val += umod - p.val) >= umod) val -= umod;
        return *this;
    }
    modint &operator*=(const modint &p) {
        val = (unsigned long long)(val) * p.val % umod;
        return *this;
    }
    modint &operator/=(const modint &p) {
        *this *= p.inverse();
        return *this;
    }
    modint operator-() const { return modint::raw(val ? mod - val : 0U); }
    modint operator+(const modint &p) const { return modint(*this) += p; }
    modint operator-(const modint &p) const { return modint(*this) -= p; }
    modint operator*(const modint &p) const { return modint(*this) *= p; }
    modint operator/(const modint &p) const { return modint(*this) /= p; }
    bool operator==(const modint &p) const { return val == p.val; }
    bool operator!=(const modint &p) const { return val != p.val; }
    modint inverse() const {
        int a = val, b = mod, u = 1, v = 0, t;
        while (b > 0) {
            t = a / b;
            swap(a -= t * b, b), swap(u -= t * v, v);
        }
        return modint(u);
    }
    modint pow(long long n) const {
        assert(n >= 0);
        modint ret(1), mul(val);
        while (n > 0) {
            if (n & 1) ret *= mul;
            mul *= mul;
            n >>= 1;
        }
        return ret;
    }
    static constexpr int get_mod() { return mod; }
   // (n, r), r is the 2^nth root of 1
    static constexpr pair<int, int> ntt_info() {
        if (mod == 120586241) return {20, 74066978};
        if (mod == 167772161) return {25, 17};
        if (mod == 469762049) return {26, 30};
        if (mod == 754974721) return {24, 362};
        if (mod == 880803841) return {23, 211};
        if (mod == 943718401) return {22, 663003469};
        if (mod == 998244353) return {23, 31};
        if (mod == 1045430273) return {20, 363};
        if (mod == 1051721729) return {20, 330};
        if (mod == 1053818881) return {20, 2789};
        return {-1, -1};
    }
    static constexpr bool can_ntt() { return ntt_info().first != -1; }
};

#ifdef FASTIO
template<int _mod>  
void rd(modint<_mod> &number){
    long long v; io::rd(v);
    v %= _mod;
    if (v < 0) {
        v += _mod;
    }
    number.val = v;
}
template<int _mod>
void wt(const modint<_mod> &number){
    io::wt(number.val);
}
#endif

template<int _mod>
ostream &operator<<(ostream &out, const modint<_mod> &number){ return out << number.val; }

using modint107 = modint<1000000007>;
using modint998 = modint<998244353>;
} // namespace mitsuha

using mint = modint107;

class Solution {
public:
    int possibleStringCount(string word, int k) {
        
        auto rl = run_length_encoding(word);

        mint tot = 1;

        for (auto &[_, freq]: rl){
            tot *= freq;
        }
        if (len(rl) >= k) return tot.val;
        if (k == 1) return tot.val;

        vector<mint> f(k);
        f[0] = mint(1);

        for (auto &[_, freq]: rl){
            chmin(freq, k);
            vector<mint> ndp(k);
            For(y, 1, k){
                if (y - 1 >= 0){
                    ndp[y] += ndp[y - 1] + f[y - 1];
                }
                if (y - freq - 1 >= 0){
                    ndp[y] -= f[y - freq - 1];
                }
            }
            swap(f, ndp);
        }

        for (auto &val: f) tot -= val;
        return tot.val;
    }
};

",1434348570
fpeterfalvi,fpeterfalvi,130,3576,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        List<List<Integer>> children = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            children.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            children.get(parent[i]).add(i);
        }
        List<Integer> lowestWithChar = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            lowestWithChar.add(-1);
        }
        process(lowestWithChar, children, 0, parent, s);
        children = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            children.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            children.get(parent[i]).add(i);
        }
        int[] subtreeSize = new int[n];
        countSubtree(children, 0, subtreeSize);
        return subtreeSize;
    }

    void process(List<Integer> lowestWithChar, List<List<Integer>> children, int node, int[] parent, String s) {
        char c = s.charAt(node);
        if (lowestWithChar.get(c - 'a') != -1) {
            parent[node] = lowestWithChar.get(c - 'a');
        }
        lowestWithChar.set(c - 'a', node);
        for (int u : children.get(node)) {
            process(new ArrayList<>(lowestWithChar), children, u, parent, s);
        }
    }
    
    void countSubtree(List<List<Integer>> children, int node, int[] subtreeSize) {
        int size = 1;
        for (int u : children.get(node)) {
            countSubtree(children, u, subtreeSize);
            size += subtreeSize[u];
        }
        subtreeSize[node] = size;
    }
}",1434361407
fpeterfalvi,fpeterfalvi,130,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] maxBeforeDayAndCity = new int[k + 1][n];
        for (int day = 1; day <= k; day++) {
            for (int city = 0; city < n; city++) {
                maxBeforeDayAndCity[day][city] = maxBeforeDayAndCity[day - 1][city] + stayScore[day - 1][city];
                for (int fromCity = 0; fromCity < n; fromCity++) {
                    maxBeforeDayAndCity[day][city] = Math.max(maxBeforeDayAndCity[day][city],
                            maxBeforeDayAndCity[day - 1][fromCity] + travelScore[fromCity][city]);
                }
            }
        }
        int result = 0;
        for (int i = 0; i < n; i++) {
            result = Math.max(result, maxBeforeDayAndCity[k][i]);
        }
        return result;
    }
}",1434369454
fpeterfalvi,fpeterfalvi,130,3617,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int possibleStringCount(String word) {
        List<Integer> consecutives = new ArrayList<>();
        char prev = 0;
        int mult = 0;
        for (char c : word.toCharArray()) {
            if (c != prev) {
                if (mult > 1) {
                    consecutives.add(mult);
                }
                mult = 1;
            } else {
                mult++;
            }
            prev = c;
        }
        if (mult > 1) {
            consecutives.add(mult);
        }
        int result = 1;
        for (int x : consecutives) {
            result += x - 1;
        }
        return result;
    }
}",1434264509
fpeterfalvi,fpeterfalvi,130,3618,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int possibleStringCount(String word, int k) {
        long MOD = (long)1e9 + 7;
        List<Integer> consecutives = new ArrayList<>();
        char prev = 0;
        int mult = 0;
        for (char c : word.toCharArray()) {
            if (c != prev) {
                if (mult > 1) {
                    consecutives.add(mult);
                }
                mult = 1;
            } else {
                mult++;
            }
            prev = c;
        }
        if (mult > 1) {
            consecutives.add(mult);
        }
        int consecutivesSum = consecutives.stream().mapToInt(x -> x).sum();
        long result = 1;
        for (int x : consecutives) {
            result = result * x % MOD;
        }
        int minLen = word.length() - (consecutivesSum - consecutives.size());
        if (k > minLen) {
            int extraLen = k - minLen;
            long[] possibles = new long[extraLen + 1];
            possibles[0] = 1;
            for (int x : consecutives) {
                long[] newPossibles = new long[extraLen + 1];
                newPossibles[0] = 1;
                for (int sum = 1; sum <= Math.min(x - 1, extraLen); sum++) {
                    newPossibles[sum] = (newPossibles[sum - 1] + possibles[sum]) % MOD;
                }
                for (int sum = x; sum <= extraLen; sum++) {
                    newPossibles[sum] = ((newPossibles[sum - 1] + possibles[sum] - possibles[sum - x]) % MOD + MOD) % MOD;
                }
                possibles = newPossibles;
            }
            for (int i = 0; i < extraLen; i++) {
                result = ((result - possibles[i]) % MOD + MOD) % MOD;
            }
        }
        return (int)result;
    }
}",1434338571
ssk4988,ssk4988,132,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        child = [[] for _ in range(len(parent))]
        s = [ord(c) - ord('a') for c in s]
        for i, p in enumerate(parent):
            if i == 0: continue
            child[p].append(i)
        seen = [-1 for i in range(26)]
        def dfs(u):
            if seen[s[u]] != -1:
                parent[u] = seen[s[u]]
            prv = seen[s[u]]
            seen[s[u]] = u
            for v in child[u]: dfs(v)
            seen[s[u]] = prv
        dfs(0)
        child = [[] for i in range(len(parent))]
        for i, p in enumerate(parent):
            if i > 0: child[p].append(i)
        ss = [1 for i in range(len(child))]
        def subsz(u):
            for v in child[u]:
                subsz(v)
                ss[u] += ss[v]
        subsz(0)
        return ss",1434270264
ssk4988,ssk4988,132,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(cur, day):
            if day >= k: return 0
            ans = stayScore[day][cur] + dp(cur, day+1)
            for nxt in range(n):
                if nxt == cur: continue
                ans = max(ans, travelScore[cur][nxt] + dp(nxt, day+1))
            return ans
        return max(dp(i, 0) for i in range(n))",1434277660
ssk4988,ssk4988,132,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        prv = '!'
        cnt = 1
        ans = 1
        for c in word:
            if c == prv:
                cnt += 1
                ans += 1
            else:
                cnt = 1
            prv = c
        return ans",1434259968
ssk4988,ssk4988,132,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        n = len(word)
        if k > n: return 0
        if k == n: return 1
        a = []
        prv = '!'
        for c in word:
            if c == prv: a[-1] += 1
            else: a.append(0)
            prv = c
        mod = 1000000007
        need = k - len(a)
        if need <= 0:
            ans = 1
            for c in a:
                ans = ((c+1) * ans) % mod
            return ans
        dp = [0] * (need + 1)
        dp1 = [0] * (need + 1)
        dp[0] = 1
        ans = 0
        for c in a:
            for i in range(len(dp)): 
                dp1[i] = 0 
                # if i == 0 else dp[i-1]
            for i in range(len(dp)):
                if i > 0: dp[i] = (dp[i] + dp[i-1]) % mod
            for i in range(0, len(dp)):
                dp1[i] = dp[i] 
                if i-1-c >= 0:
                    dp1[i] -= dp[i-1-c]
                    dp1[i] %= mod
                else:
                    dp1[i] += abs(i-c) * dp[0]
                    dp1[i] %= mod
            # print(c, dp, dp1)
            for i in range(len(dp)):
                dp[i] = dp1[i]
            # for i in range(len(dp)-1, 0, -1): dp[i] = 0 if i == 0 else dp[i-1]
            # for _ in range(c):
            #     for i in range(len(dp)-1, 0, -1):
            #         dp[i] += dp[i-1]
            #         dp[i] %= mod
            # ans += dp[-1]
        # print(a)
        return dp[-1]",1434365088
tired_pedro,tired_pedro,134,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for child, p in enumerate(parent):
            if p != -1:
                children[p].append(child)
        new_p = parent[:]
        stack = [(0, 26*[None])]
        for node, ancestors in stack:
            c = ord(s[node])-ord('a')
            if ancestors[c] is not None:
                new_p[node] = ancestors[c]
            new_ancestors = ancestors[:]
            new_ancestors[c] = node
            for child in children[node]:
                stack.append((child, new_ancestors))
        children = [set() for _ in range(n)]
        for child, p in enumerate(new_p):
            if p != -1:
                children[p].add(child)
        res = n*[1]
        stack = [node for node in range(n) if not children[node]]
        for node in stack:
            p = new_p[node]
            if p != -1:
                res[p] += res[node]
                children[p].discard(node)
                if not children[p]:
                    stack.append(p)
        return res
                
            
                
                ",1434283470
tired_pedro,tired_pedro,134,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [n*[0] for _ in range(k+1)]
        for i in range(k):
            for curr in range(n):
                for dest in range(n):
                    if curr == dest:
                        dp[i+1][curr] = max(dp[i+1][curr], dp[i][curr] + stayScore[i][curr])
                    else:
                        dp[i+1][dest] = max(dp[i+1][dest], dp[i][curr] +  travelScore[curr][dest])
        return max(dp[-1])
        
        ",1434295278
tired_pedro,tired_pedro,134,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        num_s = 1
        ct = 1
        last = word[0]
        for c in word[1:]:
            if c == last:
                ct += 1
            else:
                num_s += ct-1
                ct = 1
                last = c
        num_s += ct-1
        return num_s
            
        ",1434261788
tired_pedro,tired_pedro,134,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = int(1e9+7)
        min_ct = 0
        last = word[0]
        ct = 1
        multiple_seq = Counter()
        for c in word[1:]:
            if c != last:
                min_ct += 1
                if ct > 1:
                    multiple_seq[ct] += 1
                last = c
                ct = 1
            else:
                ct += 1
        min_ct += 1
        if ct > 1:
            multiple_seq[ct] += 1
        n = len(word) - min_ct
        # now just compute sum n_choose_j for j in k-min_ct...n
        # which is just 2^n - sum n_choose_j for j in 1...k-min_ct-1
        # that's not right because picking different characters from the same ""sequence"" yields the same string ...
        # also, you are required to pick at least 1 char from each sequence
        # ...
        # if min_ct >= k, the problem is easy, just do product(seq_len) for every sequence length larger than 1
        # if min_ct < k, we have fewer than 2000 sequences so we can do DP
        seq_lens = []
        for seq_len, ct in multiple_seq.items():
            seq_lens += ct * [seq_len]
        if min_ct >= k:
            res = 1
            for sl in seq_lens:
                res = (res * sl) % MOD
            return res
        else:
            dp = [(k-min_ct+1) * [0] for _ in range(2)]
            dp[0][k-min_ct] = 1
            #print(min_ct, k-min_ct, seq_lens)
            for i, sl in enumerate(seq_lens):
                f = i&1
                to = 1-f
                cum_sum = 0
                for left in range(k-min_ct, 0, -1):
                    drop = k-min_ct - left
                    if drop > sl-1:
                        cum_sum = (cum_sum - dp[f][left+sl] + MOD) % MOD
                    cum_sum = (cum_sum + dp[f][left]) % MOD
                    dp[to][left] = cum_sum
                dp[to][0] = 0
                for left in range(k-min_ct+1):
                    if sl-1 >= left:
                        dp[to][0] = (dp[to][0] + (sl-left) * dp[f][left]) % MOD
                    else:
                        break
                #print(dp[to])
            return dp[to][0]
        
        
        
        
        ",1434359406
Md Abedin,MdAbedin,135,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        g = defaultdict(list)
        for i,p in enumerate(parent): g[p].append(i)
        g2 = defaultdict(list)
        stacks = defaultdict(list)
        parents2 = [-1]*len(s)

        def dfs(v):
            if stacks[s[v]]:
                g2[stacks[s[v]][-1]].append(v)
                parents2[v] = stacks[s[v]][-1]
            elif v != 0:
                g2[parent[v]].append(v)
                parents2[v] = parent[v]

            stacks[s[v]].append(v)

            for v2 in g[v]:
                if v2 == parent[v]: continue
                dfs(v2)

            stacks[s[v]].pop()

        dfs(0)
        
        ans = [-1]*len(s)
        
        def solve(v):
            ans[v] = 1+sum(solve(v2) for v2 in g2[v] if v2 != parents2[v])
            return ans[v]
            
        solve(0)

        return ans",1434285848
Md Abedin,MdAbedin,135,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def solve(i,c):
            if i == k: return 0
            return max(stayScore[i][c]+solve(i+1,c),max((travelScore[c][c2]+solve(i+1,c2) for c2 in range(n) if c2 != c),default=0))

        return max(solve(0,c) for c in range(n))",1434296380
Md Abedin,MdAbedin,135,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = set()
        groups = [list(g) for k,g in groupby(word)]

        for i,g in enumerate(groups):
            for c in range(1,len(g)+1):
                ans.add("""".join(sum(groups[:i],[]) + g[:c] + sum(groups[i+1:],[])))

        return len(ans)",1434262227
Md Abedin,MdAbedin,135,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod = 10**9+7
        
        groups = [len(list(g)) for k,g in groupby(word)]
        all = reduce(lambda a,b: (a*b)%mod, groups, 1)
        
        if len(groups) >= k: return all
        
        dp = [1]+[0]*(k-1)

        for g in groups:
            dp2 = [0]*k
            s = 0
            
            for i in range(len(dp)):
                dp2[i] = s
                s += dp[i]
                if i-g >= 0: s -= dp[i-g]
                s %= mod

            dp = dp2

        return (all-sum(dp))%mod",1434372271
hanbro0112,hanbro0112,136,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        for i in range(1, n):
            adj[parent[i]].append(i)
        
        cnt = [0] * n
        def dfs(i, charMap):
            c = s[i]
            total = 1
            for j in adj[i]:
                mp = charMap.copy()
                mp[c] = i
                total += dfs(j, mp)
            
            cnt[i] += total
            if c in charMap:
                cnt[charMap[c]] += cnt[i]
                return 0
            return cnt[i]
        dfs(0, dict())
        return cnt",1434294440
hanbro0112,hanbro0112,136,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        city = [0] * n
        for day in range(k):
            nxtCity = [0] * n
            for curr, v in enumerate(stayScore[day]):
                nxtCity[curr] = city[curr] + v
            
            for curr in range(n):
                for dest in range(n):
                    nxtCity[dest] = max(nxtCity[dest], city[curr] + travelScore[curr][dest])
            city = nxtCity
            
        return max(city)
            
        ",1434311897
hanbro0112,hanbro0112,136,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1 
        s = 0
        prev = word[0]
        for c in word + '#':
            if prev == c:
                s += 1
            else:
                ans += s - 1
                s = 1
            prev = c
        return ans",1434263684
hanbro0112,hanbro0112,136,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        arr = []
        prev, s = word[0], 0
        for c in word + '#':
            if c == prev:
                s += 1
            else:
                arr.append(s)
                s = 1
            prev = c
            
        MOD = 10 ** 9 + 7
        if len(arr) >= k:
            ans = 1
            for x in arr:
                ans = (ans * x) % MOD
            return ans   
        
        dp = [1] + [0] * k
        for x in arr:
            nxt = [1] + [0] * k
            s = 0
            q = deque()
            for i in range(k):
                nxt[i] = s % MOD
                s += dp[i]
                q.append(dp[i])
                if len(q) > x:
                    s -= q.popleft()
                # update k 
                if i + x >= k:
                    nxt[k] = (nxt[k] + dp[i] * (i + x - k + 1)) % MOD
            nxt[k] = (nxt[k] + dp[k] * x) % MOD
            dp = nxt
        return dp[-1]",1434366417
Yifeng,gaoyf1235,137,3576,cpp,"class Solution {
    void dfs(int cur, vector<int>& parent, vector<vector<int>>& child, vector<vector<int>>& la, vector<int>& npar, string& s){
        int p = parent[cur];
        int i = s[cur] - 'a';
        //cout << ""check "" << cur << endl;
        if(p >= 0 && la[p][i] >= 0){
            npar[cur] = la[p][i];
        }
        else{
            npar[cur] = p;
        }
        if(p >= 0) la[cur] = la[p];
        la[cur][i] = cur;
        for(auto c : child[cur]){
            dfs(c, parent, child, la, npar, s);
        }
    }
    
    void ndfs(int cur, vector<vector<int>>& nchild, vector<int>& sz){
        for(auto c : nchild[cur]){
            ndfs(c, nchild, sz);
            sz[cur] += sz[c];
        }
        sz[cur]++;
    }
    
    template<typename T>
    void printAll(T& vec, const string& delimiter =  "" ""){
        for(const auto& x : vec){
            cout << x << delimiter;
        }
        cout << endl;
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> child(n);
        for(int i = 1; i < n; i++){
            child[parent[i]].push_back(i);
        }
        vector<int> npar(n, -1);
        vector<vector<int>> la(n, vector<int>(26, -1));
        dfs(0, parent, child, la, npar, s);
        
        //printAll(npar);
        vector<vector<int>> nchild(n);
        for(int i = 1; i < n; i++){
            nchild[npar[i]].push_back(i);
        }
        vector<int> sz(n);
        ndfs(0, nchild, sz);
        return sz;
    }
};",1434314190
Yifeng,gaoyf1235,137,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int res = 0;
        vector<vector<int>> dp(k, vector<int>(n));
        for(int i = 0; i < n; i++){
            dp[0][i] = stayScore[0][i];
            for(int x = 0; x < n; x++){
                dp[0][i] = max(dp[0][i], travelScore[x][i]);
            }
            res = max(res, dp[0][i]);
        }
        
        for(int i = 1; i < k; i++){
            for(int y = 0; y < n; y++){
                for(int x = 0; x < n; x++){
                    if(x == y){
                        dp[i][y] = max(dp[i][y], dp[i-1][y] + stayScore[i][y]);
                    }
                    else{
                        dp[i][y] = max(dp[i][y], dp[i-1][x] + travelScore[x][y]);
                    }
                    res = max(res, dp[i][y]);
                }
            }
        }
        return res;
    }
};",1434329275
Yifeng,gaoyf1235,137,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> cnt;
        char last = '*';
        int c = 0;
        for(auto x : word){
            if(x != last){
                if(last != '*'){
                    cnt.push_back(c);
                }
                last = x;
                c = 1;
            }
            else{
                c++;
            }
        }
        cnt.push_back(c);
        int res = 1;
        for(auto c : cnt){
            res += c - 1;
        }
        return res;
    }
};",1434274022
Yifeng,gaoyf1235,137,3618,cpp,"class Solution {
    using ll = long long;
    using pii = pair<int, int>;
    using pll = pair<ll, ll>;
    const ll mod = 1'000'000'007;
    
    template<typename T>
    class Combination{
    public:
        Combination(T n, T modular) : n_(n), mod_(modular) {
            fact_mod_.resize(n+1, 1);
            inv_fact_mod_.resize(n+1, 1);
            for(T i = 1; i <= n; i++){
                fact_mod_[i] = (i * fact_mod_[i - 1]) % mod_;
                // fast modular inverse with exp(mod - 2)
                inv_fact_mod_[i] = modExp(fact_mod_[i], mod_ - 2, mod_);
            }
        }

        T nChooseK(T n, T k){
            if(k > n) return 0;
            T nCk = (((fact_mod_[n] * inv_fact_mod_[k]) % mod_) * inv_fact_mod_[n-k]) % mod_;
            return nCk;
        }

        T factorial(T n){
            return fact_mod_[n];
        }

        T inv_factorial(T n){
            return inv_fact_mod_[n];
        }
    private:
        vector<T> fact_mod_;
        vector<T> inv_fact_mod_;
        T n_;
        T mod_;

        ll modExp(ll x, ll y, ll m){
            if(y == 0) return 1;
            ll half_exp = modExp(x, y / 2, m);
            if(y % 2 == 0) return (half_exp * half_exp) % m;
            else return (((half_exp * half_exp) % m) * x) % m;
        }
    };
    
    template<typename T>
    void printAll(T& vec, const string& delimiter =  "" ""){
        for(const auto& x : vec){
            cout << x << delimiter;
        }
        cout << endl;
    }

public:
    int possibleStringCount(string word, int k) {
        int n = word.size();
        vector<int> cnt;
        char last = '*';
        int c = 0;
        for(auto x : word){
            if(x != last){
                if(last != '*'){
                    cnt.push_back(c);
                }
                last = x;
                c = 1;
            }
            else{
                c++;
            }
        }
        cnt.push_back(c);
        int m = cnt.size();
        ll res = 1;
        for(auto c : cnt){
            res *= (ll) c;
            res %= mod;
        }
        if(m <= k){
            vector<vector<ll>> dp(m + 1, vector<ll>(k + 1));
            dp[0][0] = 1;
            vector<ll> pfs(k + 1, 1);
            for(int i = 1; i <= m; i++){
                auto c = cnt[i - 1];
                for(int j = i; j <= k; j++){
                    dp[i][j] = pfs[j - 1];
                    if(j - c - 1 >= 0) dp[i][j] -= pfs[j - c - 1];
                    dp[i][j] %= mod;
                }
                pfs[0] = dp[i][0];
                for(int j = 1; j <= k; j++){
                    pfs[j] = pfs[j-1] + dp[i][j];
                }
            }
            for(int i = 0; i < k; i++){
                res = (res + mod - dp[m][i]) % mod;
            } 
        }

        return res;
    }
};",1434379439
Ravi,xyzabcdef,139,3576,cpp,"class Solution {
public:
    vector<vector<int>>adj;
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        adj.resize(n);
        for(int i = 0; i < n; i++){
            if(parent[i] != -1){
                adj[i].push_back(parent[i]);
                adj[parent[i]].push_back(i);
            }
        }
        vector<int>siz(n, 0), nPar(n, -1), vec(26, -1);
        for(int i = 0; i < n; i++){
            nPar[i] = parent[i];
        }
        auto dfs = [&](int v, int fa, vector<int>&vec, auto &&dfs) -> void{
            if(vec[s[v]-'a'] != -1){
                nPar[v] = vec[s[v]-'a'];
            }
            for(auto u: adj[v]){
                if(u != fa){
                    int tmp = vec[s[v]-'a'];
                    vec[s[v]-'a'] = v;
                    dfs(u, v, vec, dfs);
                    vec[s[v]-'a'] = tmp;
                }
            }
        };
        dfs(0, -1, vec, dfs);
        for(int i = 0; i < n; i++){
            adj[i].clear();
        }
        for(int i = 0; i < n; i++){
            if(nPar[i] != -1){
                adj[i].push_back(nPar[i]);
                adj[nPar[i]].push_back(i);
            }
        }
        auto dfs2 = [&](int v, int fa, auto &&dfs2) -> int{
            siz[v] = 1;
            for(auto u: adj[v]){
                if(u != fa){
                    siz[v] += dfs2(u, v, dfs2);
                }
            }
            return siz[v];
        };
        dfs2(0, -1, dfs2);
        return siz;
    }
};",1434287946
Ravi,xyzabcdef,139,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>>dp(k, vector<int>(n, -1));
        auto solve = [&](int day, int city, auto &&solve) -> int{
            if(day == k){
                return 0;
            }
            auto &res = dp[day][city];
            if(res != -1){
                return res;
            }
            for(int i = 0; i < n; i++){
                res = max(res, solve(day+1, i, solve) + travelScore[city][i]);
            }
            res = max(res, solve(day+1, city, solve) + stayScore[day][city]);
            return res;
        };
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans = max(ans, solve(0, i, solve));
        }
        return ans;
    }
};",1434296724
Ravi,xyzabcdef,139,3617,cpp,"class Solution {
public:
    using ll = long long;
    int possibleStringCount(string word) {
        int n = word.size();
        ll cost = 0;
        vector<int>siz;
        int cur = 0; 
        char ch = word[0];
        for(int i = 0; i < n; i++){
            if(ch == word[i]){
                cur++;
            } else{
                siz.push_back(cur);
                cur = 1;
                ch = word[i];
            }
        }
        siz.push_back(cur);
        int ways = 1;
        for(auto i: siz){
            ways += (i - 1);
        }
        return ways;
    }
};",1434380560
Ravi,xyzabcdef,139,3618,cpp,"class Solution {
public:
    using ll = long long;
    ll powmod(ll a, ll b, ll p){
        a %= p;
        if(a == 0)return 0;
        ll prod = 1;
        while(b > 0){
            if(b&1LL){
                prod *= a;
                prod %= p;
                --b;
            }
            a *= a;
            a %= p;
            b >>= 1LL;
        }
        return prod;
    }
    int possibleStringCount(string word, int k) {
        int n = word.size();
        ll cost = 0;
        const ll mod = 1e9+7;
        vector<int>siz;
        int cur = 0; 
        char ch = word[0];
        for(int i = 0; i < n; i++){
            if(ch == word[i]){
                cur++;
            } else{
                siz.push_back(cur);
                cur = 1;
                ch = word[i];
            }
        }
        siz.push_back(cur);
        vector<ll>pow(n+2);
        pow[0] = 1;
        for(int i = 1; i <= n; i++){
            pow[i] = (1LL*pow[i-1]*2) % mod;
        }
        ll ans = 1;
        for(auto z: siz){
            ans =  (1LL*ans*z) % mod;
        }
        if(siz.size() >= k){
            return ans;
        }
        int len = siz.size();
        for(int i = 0; i < len; i++){
            siz[i]--;
        }
        k--;
        vector<ll>dp(k+1, 0);
        dp[0] = 1;
        for(int i = 0; i < len; i++){
            ll max_cnt = siz[i];
            vector<ll>nDp(k+1, 0);
            vector<ll>pref(k+1, 0);
            for(int j = 0; j < k; j++){
                pref[j+1] = pref[j] + dp[j];
                pref[j+1] %= mod;
            }
            for(int j = 0; j < k; j++){
                int min_idx = max<ll>(0, j - max_cnt);
                nDp[j] = pref[j+1] - pref[min_idx] + mod;
                nDp[j] %= mod;
            }
            dp = nDp;
        }
        // for(auto z: dp)cout<<z<<"" "";cout<<'\n';
        ll tot = 0;
        for(int i = 0; i < k-len+1; i++){
            tot += dp[i];
            tot %= mod;
        }
        return (ans - tot + mod) % mod;
    }
};",1434374860
pika_code,pika_code,141,3576,python3,"from typing import List
import sys
sys.setrecursionlimit(1 << 25)

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        new_parent = parent.copy()
        last = {}
        def dfs(u):
            c = s[u]
            prev = last.get(c, -1)
            if prev != -1 and u != 0:
                new_parent[u] = prev
            last[c] = u
            for v in tree[u]:
                dfs(v)
            last[c] = prev
        dfs(0)
        new_tree = [[] for _ in range(n)]
        for i in range(n):
            if new_parent[i] != -1:
                new_tree[new_parent[i]].append(i)
        res = [0] * n
        def count(u):
            res[u] = 1
            for v in new_tree[u]:
                res[u] += count(v)
            return res[u]
        count(0)
        return res",1434261224
pika_code,pika_code,141,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [ [float('-inf')] * n for _ in range(k)]
        
        # Initialize dp[0][curr]
        for curr in range(n):
            # Option 1: Starting at curr and staying there
            dp[0][curr] = stayScore[0][curr]
            # Option 2: Starting at any city prev and moving to curr
            for prev in range(n):
                if prev != curr:
                    dp[0][curr] = max(dp[0][curr], travelScore[prev][curr])
                else:
                    # Even if prev == curr, travelScore[prev][curr] == 0, so we can consider it
                    dp[0][curr] = max(dp[0][curr], travelScore[prev][curr])
        
        for i in range(1, k):
            for curr in range(n):
                # Option 1: Stay in curr
                stay = dp[i-1][curr] + stayScore[i][curr]
                # Option 2: Move from any prev to curr
                move = float('-inf')
                for prev in range(n):
                    if prev != curr:
                        move = max(move, dp[i-1][prev] + travelScore[prev][curr])
                    else:
                        # Even if prev == curr, travelScore[prev][curr] == 0, so we can consider it
                        move = max(move, dp[i-1][prev] + travelScore[prev][curr])
                dp[i][curr] = max(stay, move)
        
        return max(dp[k-1])
",1434270146
pika_code,pika_code,141,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        runs = []
        prev = ''
        count = 0
        for c in word:
            if c == prev:
                count += 1
            else:
                if prev:
                    runs.append(count)
                prev = c
                count = 1
        runs.append(count)
        return sum(r - 1 for r in runs) + 1
",1434260579
pika_code,pika_code,141,3618,python3,"from typing import List

class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10**9 + 7
        run_lengths: List[int] = []
        n = len(word)
        
        if n == 0:
            return 1 if k <= 0 else 0
        
        current_char = word[0]
        count = 1
        for i in range(1, n):
            if word[i] == current_char:
                count += 1
            else:
                run_lengths.append(count)
                current_char = word[i]
                count = 1
        run_lengths.append(count)  # Append the last run
        m = len(run_lengths)
        
        # Calculate total_sequences as the product of run_lengths modulo MOD
        total_sequences = 1
        for x in run_lengths:
            total_sequences = (total_sequences * x) % MOD
        
        T = k - m
        if T <= 0:
            return total_sequences
        
        S = T - 1
        L = [x - 1 for x in run_lengths]
        
        # Initialize DP arrays
        dp_prev = [0] * (S + 1)
        dp_curr = [0] * (S + 1)
        dp_prev[0] = 1  # Base case
        
        for i in range(m):
            # Compute prefix sums for dp_prev
            prefix = [0] * (S + 2)
            for j in range(S + 1):
                prefix[j + 1] = (prefix[j] + dp_prev[j]) % MOD
            
            for j in range(S + 1):
                lower = max(0, j - L[i])
                dp_curr[j] = (prefix[j + 1] - prefix[lower] + MOD) % MOD
            
            # Prepare for next iteration
            dp_prev, dp_curr = dp_curr, [0] * (S + 1)
        
        # Compute invalid_sequences as the sum of dp_prev
        invalid_sequences = sum(dp_prev) % MOD
        
        # Compute valid_sequences
        valid_sequences = (total_sequences - invalid_sequences + MOD) % MOD
        return valid_sequences

",1434309037
h_bugw7,h_bugw7,142,3576,cpp,"class Solution {
    vector<int> p, res;
    string s;
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        p = parent;
        this->s = s;
        int n = parent.size();
        vector<vector<int>> tree(n);
        for(int i = 1; i < n; i++) {
            tree[parent[i]].push_back(i);
        }
        vector<stack<int>> st(26);
        solve(tree, 0, st);
        vector<vector<int>> tree2(n);
        res.resize(n, 0);
        for(int i = 1; i < n; i++) {
            tree2[p[i]].push_back(i);
        }
        cnt(tree2, 0);
        return res;
    }
    void solve(vector<vector<int>>& tree, int rt, vector<stack<int>>& st) {
        // cout << ""solve "" << rt << endl;
        int val = s[rt]-'a';
        if(!st[val].empty()) {
            p[rt] = st[val].top();
        }
        st[val].push(rt);
        for(int ch: tree[rt]) {
            solve(tree, ch, st);
        }
        st[val].pop();
    }
    void cnt(vector<vector<int>>& tree, int rt) {
        res[rt] = 1;
        for(int ch: tree[rt]) {
            cnt(tree, ch);
            res[rt] += res[ch];
        }
    }
};",1434280988
h_bugw7,h_bugw7,142,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int dp[2][201] = {0};
        int F = 0, T = 1;
        for(int i = 0; i < k; i++) {
            swap(F, T);
            memset(dp[T], 0, sizeof(dp[T]));
            for(int start = 0; start < n; start++) {
                for(int end = 0; end < n; end++) {
                    if(start == end) dp[T][end] = max(dp[T][end], dp[F][start] + stayScore[i][start]);
                    else dp[T][end] = max(dp[T][end], dp[F][start] + travelScore[start][end]);
                }
            }
        }
        return *max_element(dp[T], dp[T]+n);
    }
};",1434295273
h_bugw7,h_bugw7,142,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char top = '#';
        int res = 1;
        for(char c: word) {
            if(top == c) res++;
            else top = c;
        }
        return res;
    }
};",1434286478
h_bugw7,h_bugw7,142,3618,cpp,"const int MOD = 1e9+7;

class Solution {
public:
    int possibleStringCount(string word, int k) {
        vector<int> v;
        char top = word[0];
        int cnt = 0;
        for(char c: word) {
            if(c == top) cnt++;
            else {
                v.push_back(cnt-1);
                top = c;
                cnt = 1;
            }
        }
        v.push_back(cnt-1);
        if(k > word.length()) return 0;
        if(k == word.length()) return 1;
        int lim = k - v.size() - 1;
        // cout << k << endl;
        int dp[2001] = {0};
        dp[0] = 1;
        long long all = 1;
        for(int n: v) {
            if(!n) continue;
            all = all * (n+1) % MOD;
            int pf[2001] = {0};
            for(int i = 0; i <= lim; i++) {
                pf[i] = (pf[i] + dp[i]) % MOD;
                if(i+n+1 <= lim) pf[i+n+1] = (MOD - dp[i]) % MOD;
            }
            dp[0] = pf[0];
            for(int i = 1; i <= lim; i++) {
                dp[i] = (dp[i-1] + pf[i]) % MOD;
            }
        }
        int res = 0;
        for(int i = 0; i <= lim; i++) {
            res = (res + dp[i]) % MOD;
        }
        // cout << all << endl;
        // cout << res << endl;
        // for(int i: v) cout << i << ' ';
        return (all - res + MOD) % MOD;
    }
};",1434344010
mark93192,mark93192,146,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> new_parent(parent.size(),-1);
        vector<int> ancestor_now(26,-1);
        vector<vector<int>> child(parent.size());
        for(int i=1;i<parent.size();i++){
            child[parent[i]].push_back(i);
        }
        DFS(new_parent,parent,s,child,ancestor_now,0);
        vector<int> ans(parent.size(),0);
        vector<vector<int>> new_child(parent.size());
        for(int i=1;i<parent.size();i++){
            new_child[new_parent[i]].push_back(i);
        }
        calculate_size(ans,new_child,0);
        return ans;
    }
    void DFS(vector<int>& new_parent,vector<int>& parent,string& s,vector<vector<int>>& child,vector<int>& ancestor_now,int node_now){
        if(ancestor_now[s[node_now]-'a']==-1){
            new_parent[node_now]=parent[node_now];
        }
        else{
            new_parent[node_now]=ancestor_now[s[node_now]-'a'];
        }
        int record=ancestor_now[s[node_now]-'a'];   
        ancestor_now[s[node_now]-'a']=node_now;
        for(int i=0;i<child[node_now].size();i++){
            DFS(new_parent,parent,s,child,ancestor_now,child[node_now][i]);
        }
        ancestor_now[s[node_now]-'a']=record;
    }
    int calculate_size(vector<int>& ans,vector<vector<int>>& new_child,int node_now){
        int temp=1;
        for(int i=0;i<new_child[node_now].size();i++)
            temp+=calculate_size(ans,new_child,new_child[node_now][i]);
        ans[node_now]=temp;
        return temp;
    }
};",1434294845
mark93192,mark93192,146,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1,vector<int>(n,0));
        for(int i=1;i<=k;i++){            
            for(int j=0;j<n;j++){
                int max=-1e9;
                for(int m=0;m<n;m++){
                    int calculation;
                    if(m==j){
                        calculation=dp[i-1][m]+stayScore[i-1][m];
                    }
                    else{
                        calculation=dp[i-1][m]+travelScore[m][j];
                    }
                    if(calculation>max){
                        max=calculation;
                    }
                }
                dp[i][j]=max;
            }
        }
        int ans=-1e9;
        for(int i=0;i<n;i++){
            if(dp[k][i]>ans)
                ans=dp[k][i];
        }
        return ans;
    }
};",1434309320
mark93192,mark93192,146,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=1;i<word.size();i++){
            if(word[i]==word[i-1])
                ans++;
        }
        return ans;
    }
};",1434260987
mark93192,mark93192,146,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        vector<int> choose;
        int accu_now=0;
        char now='$';
        for(int i=1;i<word.size();i++){
            if(word[i]==word[i-1]){
                accu_now++;
            }
            else{
                choose.push_back(accu_now);
                accu_now=0;
            }
        }
        choose.push_back(accu_now);        
        long long ans=1;
        for(int i=0;i<choose.size();i++){
            ans=ans*static_cast<long long>(choose[i]+1);
            ans=ans%(1000000007);
        }
        if(k>word.length()){
            ans=0;
        }
        else if(choose.size()<k){
            vector<long long> temp(k-choose.size()+1,0);
            vector<long long> temp2(k-choose.size()+1,0);
            int run=0;
            for(int i=0;i<=k-choose.size();i++){                
                temp[i]=run;
                if(i<=choose[0])
                    run++;                
            }           
            for(int i=1;i<choose.size();i++){
                for(int j=0;j<=k-choose.size();j++){
                    if(i%2==0){
                        if(j==0)
                            temp[j]=0;
                        else
                            temp[j]=temp[j-1];
                        if(j-choose[i]-1>=0){
                            temp[j]+=temp2[j]-temp2[j-choose[i]-1];
                        }
                        else{
                            temp[j]+=temp2[j];
                        }
                        temp[j]=temp[j]+1000000007;
                        temp[j]%=1000000007;
                    }
                    else{
                        if(j==0)
                            temp2[j]=0;
                        else
                            temp2[j]=temp2[j-1];
                        if(j-choose[i]-1>=0){
                            temp2[j]+=temp[j]-temp[j-choose[i]-1];
                        }
                        else{
                            temp2[j]+=temp[j];
                        }
                        temp2[j]=temp2[j]+1000000007;
                        temp2[j]%=1000000007;
                    }
                }
            }
            if((choose.size()-1)%2==0){
                ans-=temp[k-choose.size()];
            }
            else{
                ans-=temp2[k-choose.size()];
            }
            ans=ans+1000000007;
            ans=ans%1000000007;
        }
        return static_cast<int>(ans);
    }
};",1434381251
Rahul Kumar Yadav,user0434y,150,3576,cpp,"typedef long long ll;
// Structure to manage DFS frames
struct Frame {
    int node;
    bool processed;
    int prev_y;
};

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        
        // Build original tree
        vector<vector<int>> children(n, vector<int>());
        for(int x = 1; x < n; x++) {
            int p = parent[x];
            children[p].push_back(x);
        }
        
        // Initialize new_parent and last_occurrence
        vector<int> new_parent = parent; // Initially, new_parent[x] = parent[x]
        int last_occurrence[26];
        for(int c = 0; c < 26; c++) last_occurrence[c] = -1;
        
        // Perform iterative DFS to find new_parent[x]
        stack<Frame> stk;
        stk.push(Frame{0, false, -1});
        
        while(!stk.empty()) {
            Frame frame = stk.top(); stk.pop();
            if(!frame.processed){
                int node = frame.node;
                int c = s[node] - 'a';
                int y = last_occurrence[c];
                
                if(y != -1){
                    new_parent[node] = y;
                }
                // Push the frame back with processed=true to restore last_occurrence later
                stk.push(Frame{node, true, y});
                
                // Push children to the stack (reverse order for correct traversal)
                for(auto it = children[node].rbegin(); it != children[node].rend(); ++it){
                    stk.push(Frame{*it, false, -1});
                }
                
                // Update last_occurrence for current character
                last_occurrence[c] = node;
            }
            else{
                // Restore previous last_occurrence
                int node = frame.node;
                int c = s[node] - 'a';
                last_occurrence[c] = frame.prev_y;
            }
        }
        
        // Build new tree from new_parent
        vector<vector<int>> new_children(n, vector<int>());
        for(int x = 1; x < n; x++) {
            int p = new_parent[x];
            new_children[p].push_back(x);
        }
        
        // Compute subtree sizes using iterative post-order DFS
        vector<int> subtree_sizes(n, 1); // Initialize all sizes to 1
        stack<pair<int, bool>> stack_post;
        stack_post.push({0, false});
        
        while(!stack_post.empty()) {
            auto [node, processed] = stack_post.top(); stack_post.pop();
            if(processed){
                // After processing children
                for(auto child: new_children[node]){
                    subtree_sizes[node] += subtree_sizes[child];
                }
            }
            else{
                // Push back the node as processed
                stack_post.push({node, true});
                // Push children to the stack
                for(auto child: new_children[node]){
                    stack_post.push({child, false});
                }
            }
        }
        
        return subtree_sizes;
    }
};",1434370199
Rahul Kumar Yadav,user0434y,150,3587,cpp,"typedef long long ll;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        const int MOD = 1'000'000'007;
        
        // Initialize previous day DP
        vector<long long> prev_dp(n, 0LL);
        
        // Day 0: Initialize prev_dp[j] = max(stayScore[0][j], max_{l !=j} travelScore[l][j})
        for(int j = 0; j < n; j++) {
            ll stay = (ll)stayScore[0][j];
            ll move = 0LL;
            for(int l = 0; l < n; l++) {
                if(l == j) continue;
                move = max(move, (ll)travelScore[l][j]);
            }
            prev_dp[j] = max(stay, move);
        }
        
        // Iterate over each day from Day 1 to Day k-1
        for(int day = 1; day < k; day++) {
            vector<long long> curr_dp(n, 0LL);
            for(int j = 0; j < n; j++) {
                // Option 1: Stay in the same city
                ll option_stay = prev_dp[j] + (ll)stayScore[day][j];
                
                // Option 2: Move to city j from any other city
                ll option_move = LLONG_MIN;
                for(int l = 0; l < n; l++) {
                    if(l == j) continue;
                    option_move = max(option_move, prev_dp[l] + (ll)travelScore[l][j]);
                }
                
                // If there is no valid move (e.g., n == 1), only consider staying
                if(n == 1){
                    option_move = LLONG_MIN;
                }
                
                // Update current DP[j] with the maximum of staying or moving
                if(option_move != LLONG_MIN){
                    curr_dp[j] = max(option_stay, option_move);
                }
                else{
                    curr_dp[j] = option_stay;
                }
            }
            // Update prev_dp for the next day
            prev_dp = curr_dp;
        }
        
        // After all days, find the maximum points across all cities
        ll max_points = LLONG_MIN;
        for(int j = 0; j < n; j++) {
            if(prev_dp[j] > max_points){
                max_points = prev_dp[j];
            }
        }
        
        // Since the result can be large, return it modulo 10^9+7
        return (int)(max_points % MOD);
    }
};
",1434361865
Rahul Kumar Yadav,user0434y,150,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        //variable to calculate the total number of different strings possible
        int total_count = 0;

        // Vector to store characters that appear more than once in the string
        vector<char> more_than_one;

        // Unordered map to store the frequency of each character in the string
        unordered_map<char, int> hash;
        
        int i = 0;

        // Iterate through each character in the string until the end is reached
        while(i < word.size()) {
            // Check if the current character is not present in the hash map
            if(hash.find(word[i]) == hash.end()) {
                // If the character is not found, add it to the map with a count of 1
                hash[word[i]] = 1;
            }
            else {
                // If the character is already in the map, increment its count by 1
                if(word[i-1] == word[i])
                    hash[word[i]] += 1;
            }
            // Move to the next character in the string
            i += 1;
        }

        // Iterate through the hash map to identify characters that appear more than once
        for(auto it: hash) {
            // Check if the frequency of the character is greater than 1
            if(it.second > 1) {
                // If yes, add the character to the more_than_one vector
                more_than_one.push_back(it.first);
            }
        }

        // Iterate through the more_than_one vector to calculate the total count
        for(auto it : more_than_one) {
            
            // For each character that appears more than once, add (frequency - 1) to total_count
            total_count += hash[it] - 1;
        }

        // Return the total count plus one
        return total_count + 1;
    }
};",1434292695
Rahul Kumar Yadav,user0434y,150,3618,cpp,"class Solution {
public:
    const int MOD = 1'000'000'007;
    
    int possibleStringCount(string word, int k) {
        //Run-Length Encoding
        vector<int> run_lengths;
        int n = word.length();
        if(n ==0) return 0;
        int i =0;
        while(i <n){
            char c = word[i];
            int count =1;
            i++;
            while(i <n && word[i] ==c){
                count++;
                i++;
            }
            run_lengths.push_back(count);
        }
        
        int m = run_lengths.size();
        
        // Compute total_sequences
        long long total =1;
        for(auto l: run_lengths){
            total = (total * ((long long)l)) % MOD;
            // Early termination if total is 0
            if(total ==0) break;
        }
        
        if(m > k){
            // All sequences are acceptable
            return (int)total;
        }
        else{
            /* m <=k, need to compute sequences with sum >=k
            Compute number of sequences with sum <=k-1 by Initializing DP,dp[j] = number of ways to have sum j
            Initialize dp[0] =1
            Since each run contributes at least 1, the minimum sum is m
            But m <=k, so we need to compute sequences with sum <=k-1
            which is equivalent to sequences with sum <=k-1
            If m >k-1, there are no such sequences*/
            if(m > k-1){
                // All sequences have sum >=m >k-1, so sequences with sum <=k-1 is 0
                return (int)total;
            }
            
            //Otherwise, perform DP,m <=k <=2000, Initialize dp
            vector<long long> dp(k, 0);
            dp[0] =1;
            for(auto l_i: run_lengths){
                // Compute prefix sums
                vector<long long> prefix(k, 0);
                prefix[0] = dp[0];
                for(int j=1; j <k; j++) {
                    prefix[j] = (prefix[j-1] + dp[j]) % MOD;
                }
                // Compute new_dp
                vector<long long> new_dp(k, 0);
                for(int j=1; j <k; j++){
                    int from = j - l_i;
                    if(from <=0){
                        new_dp[j] = prefix[j-1];
                    }
                    else{
                        new_dp[j] = (prefix[j-1] - prefix[from -1] + MOD) % MOD;
                    }
                }
                dp = new_dp;
            }
            // Sum dp[0] to dp[k-1]
            long long sum_dp =0;
            for(int j=0; j <k; j++) {
                sum_dp = (sum_dp + dp[j]) % MOD;
            }
            // Compute answer
            long long answer = (total - sum_dp + MOD) % MOD;
            return (int)answer;
        }
    }
};",1434382156
Neal@,x____x,151,3576,cpp,"class Solution {
public:
  vector<int> findSubtreeSizes(vector<int>& parent, string s) {
    int n = s.size();
    vector<vector<int>> g(n);
    for (int i = 1; i < n; ++i) g[parent[i]].push_back(i);
    vector<int> a(128, -1);
    vector<int> p1(n, -1);
    function<void(int)> go = [&](int x) {
      int o = a[s[x]];
      a[s[x]] = x;
      for (int y : g[x]) go(y);
      a[s[x]] = o;
      if (o >= 0) p1[x] = o; else p1[x] = parent[x];
    };
    go(0);
    vector<vector<int>> g1(n);
    for (int i = 1; i < n; ++i) g1[p1[i]].push_back(i);
    vector<int> ret(n);
    function<void(int)> go1 = [&](int x) {
      ret[x] = 1;
      for (int y : g1[x]) {
        go1(y);
        ret[x] += ret[y];
      }
    };
    go1(0);
    return ret;
  }
};",1434310223
Neal@,x____x,151,3587,cpp,"class Solution {
public:
  int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    vector<int> a(n, 0);
    for (int i = 0; i < k; ++i) {
      vector<int> b(n, -1);
      for (int j = 0; j < n; ++j) {
        if (a[j] >= 0) {
          b[j] = max(b[j], a[j] + stayScore[i][j]);
          for (int x = 0; x < n; ++x) b[x] = max(b[x], a[j] + travelScore[j][x]);
        }
      }
      a.swap(b);
    }
    int ret = 0;
    for (int x : a) ret = max(ret, x);
    return ret;
  }
};",1434318532
Neal@,x____x,151,3617,cpp,"class Solution {
public:
  int possibleStringCount(string word) {
    int ret = 0;
    for (int i = 0, j; i < word.size(); i = j) {
      for (j = i; j < word.size() && word[i] == word[j]; ++j) ;
      if (j - i > 1) ret += j - i - 1;
    }
    return ret + 1;
  }
};",1434276677
Neal@,x____x,151,3618,cpp,"class Solution {
public:
  int possibleStringCount(string word, int k) {
    const int Mod = 1000000007;
    int n = word.size();
    vector<int> d;
    int c = 0;
    int ret = 1;
    for (int i = 0, j; i < n; i = j) {
      ++c;
      for (j = i; j < n && word[i] == word[j]; ++j) ;
      if (j - i > 1) d.push_back(j - i - 1);
      ret = (long long)ret * (j - i) % Mod;
    }
    if (c < k) {
      k -= c;
      vector<int> a(k);
      vector<int> b(k + 1);
      a[0] = 1;
      int s = 0;
      for (int x : d) {
        for (int i = 0; i < k; ++i) if ((b[i + 1] = b[i] + a[i]) >= Mod) b[i + 1] -= Mod;
        for (int y = 1; y < k; ++y) {
          int z = b[y] - b[max(0, y - x)];
          if (z < 0) z += Mod;
          (a[y] += z) %= Mod;
        }
      }
      for (int x : a) {
        ret -= x;
        if (ret < 0) ret += Mod;
      }
    }
    return ret;
  }
};",1434363667
veraci2,veraci2,152,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        for u, p in enumerate(parent):
            if p != -1:
                adj[p].append(u)
        
        parent2 = parent[:]
        last = defaultdict(list)
        def dfs(node):
            row = last[s[node]]
            if row:
                u = row[-1]
                parent2[node] = u
                
            row.append(node)
            for nei in adj[node]:
                dfs(nei)
            row.pop()
        
        dfs(0)
        adj = [[] for _ in range(n)]
        for u, p in enumerate(parent2):
            if p != -1:
                adj[p].append(u)
        
        size = [1] * n
        def dfs2(node):
            for nei in adj[node]:
                dfs2(nei)
                size[node] += size[nei]
        dfs2(0)
        
        return size
            ",1434283934
veraci2,veraci2,152,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(u, time):
            if time == k:
                return 0
            ans = max(dp(v, time + 1) + travelScore[u][v] for v in range(n))
            ans = max(ans, stayScore[time][u] + dp(u, time + 1))
            return ans
        
        ans = max(dp(u, 0) for u in range(n))
        return ans",1434302772
veraci2,veraci2,152,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for k,g in groupby(word):
            g=len(list(g))
            ans += g-1
        return ans",1434277184
veraci2,veraci2,152,3618,python,"class Solution(object):
    def possibleStringCount(self, word, K):
        rle = [len(list(g)) for k, g in groupby(word)]
        MOD = 10 ** 9 + 7

        ans = 1
        for l in rle:
            ans = (ans * l) % MOD

        if len(word) < K:
            return 0

        n = len(rle)
        D = K - n

        if D <= 0:
            return ans

        poly = [1]

        for l in rle:
            l -= 1
            poly.extend([0] * min(l, D - len(poly)))
            for i in range(1, len(poly)):
                poly[i] += poly[i-1]
                poly[i] %= MOD
            for i in range(len(poly))[::-1]:
                if i >= l+1:
                    poly[i] -= poly[i - (l+1)]
                    poly[i] %= MOD

        ans -= sum(poly) % MOD
        return ans % MOD",1434383302
John,123GJWEQ2,153,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        adj_list = [[] for i in range(len(parent) + 3)]
        ans = [0] * len(parent)
        ecnts = [0] * 26
        
        for i in range(len(parent)):
            adj_list[parent[i]].append(i)
            adj_list[i].append(parent[i])
        
        def dfs(node, last_node):
            cnts = [0] * 26
            node_cnt = 1
            
            for new_node in adj_list[node]:
                if new_node == last_node:
                    continue
                    
                ecnts[ord(s[node]) - 97] += 1
                new_cnts, subtree_cnt = dfs(new_node, node)
                node_cnt += subtree_cnt
                ecnts[ord(s[node]) - 97] -= 1

                for ind, val in enumerate(new_cnts):
                    cnts[ind] += val
            
            
            cnts[ord(s[node]) - 97] = 0

            thingy = node_cnt
            
            for i in range(26):
                if ecnts[i] > 0:
                    thingy -= cnts[i]

            ans[node] = thingy
            
            cnts[ord(s[node]) - 97] = thingy
            
            return (cnts, node_cnt)
            
        
        dfs(0, -1)
        
        return ans
            
            ",1434371548
John,123GJWEQ2,153,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        
        
        for i in range(k - 1, -1, -1):
            new_dp = [0] * n
            
            
            for x in range(n):
                
                for y in range(n):
                    new_dp[x] = max(stayScore[i][x] + dp[x], travelScore[x][y] + dp[y], new_dp[x])
            
            
            dp = new_dp

        return max(dp)",1434301893
John,123GJWEQ2,153,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        p1 = 0
        p2 = 0
        res = 1
        
        while p1 < len(word):
            cur = word[p1]
            
            while p2 < len(word) and cur == word[p2]:
                p2 += 1
                
            res += p2 - p1 - 1
            p1 = p2
            
        return res",1434263184
John,123GJWEQ2,153,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        cnts = []
        
        p1 = 0
        p2 = 0
        mod = 10 ** 9 + 7
        
        while p1 < len(word):
            cur = word[p1]
            
            while p2 < len(word) and word[p2] == cur:
                p2 += 1
                
            cnts.append(p2 - p1)
            p1 = p2
            
            
        p1 = 0
        p2 = 0
        res = 1

        while p1 < len(word):
            cur = word[p1]

            while p2 < len(word) and cur == word[p2]:
                p2 += 1

            res *= (p2 - p1)
            p1 = p2
            res %= mod
            
        if len(cnts) > k:
            return res
        else:
            #how many have a count \le i
            dp = [1] * (k + 3)
            dp[-1] = 0
            
            for i in range(len(cnts) - 1, -1, -1):
                new_dp = [0] * (k + 3)
                
                for x in range(1, k + 1):
                    new_dp[x] = dp[x - 1] - dp[max(-1, x - cnts[i] - 1)]
                    new_dp[x] %= mod
                    
                
                dp = new_dp
                
                for e in range(1, len(dp) - 1):
                    dp[e] += dp[e - 1]
                    dp[e] %= mod
            
            return (res - dp[k - 1]) % mod",1434346711
Shubham Yadav,shubhamyadav32100,156,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }

        for (int i = 1; i < n; i++) {
            adj.get(parent[i]).add(i);
        }

        int[] newParent = Arrays.copyOf(parent, n);
        Map<Character, Integer> lastSeen = new HashMap<>();
        dfsAdjustParent(0, s, adj, lastSeen, newParent);

        List<List<Integer>> finalAdj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            finalAdj.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            finalAdj.get(newParent[i]).add(i);
        }

        int[] answer = new int[n];
        dfsCountSubtreeSizes(0, finalAdj, answer);
        
        return answer;
    }

    public void dfsAdjustParent(int node, String s, List<List<Integer>> adj, Map<Character, Integer> lastSeen, int[] newParent) {
        char c = s.charAt(node);
        Integer prev = lastSeen.get(c);
        if (prev != null && prev != newParent[node]) {
            newParent[node] = prev;
        }

        Integer originalParent = lastSeen.put(c, node);
        for (int child : adj.get(node)) {
            dfsAdjustParent(child, s, adj, lastSeen, newParent);
        }
        if (originalParent == null) {
            lastSeen.remove(c);
        } else {
            lastSeen.put(c, originalParent);
        }
    }

    public int dfsCountSubtreeSizes(int node, List<List<Integer>> adj, int[] answer) {
        int size = 1;
        for (int child : adj.get(node)) {
            size += dfsCountSubtreeSizes(child, adj, answer);
        }
        answer[node] = size;
        return size;
    }
}
",1434285195
Shubham Yadav,shubhamyadav32100,156,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dpTable = new int[k + 1][n];
        for (int[] row : dpTable) {
            Arrays.fill(row, -1);
        }

        int maxTotalScore = 0;
        for (int startingCity = 0; startingCity < n; ++startingCity) {
            maxTotalScore = Math.max(maxTotalScore, computeMaxScore(0, startingCity, k, stayScore, travelScore, dpTable));
        }
        return maxTotalScore;
    }

    private int computeMaxScore(int day, int currentCity, int k, int[][] stayScore, int[][] travelScore, int[][] dpTable) {
        if (day == k) {
            return 0;
        }
        if (dpTable[day][currentCity] != -1) {
            return dpTable[day][currentCity];
        }

        int scoreStaying = stayScore[day][currentCity] + computeMaxScore(day + 1, currentCity, k, stayScore, travelScore, dpTable);
        int maxPoints = scoreStaying;

        for (int nextCity = 0; nextCity < travelScore.length; ++nextCity) {
            if (nextCity != currentCity) {
                int scoreTraveling = travelScore[currentCity][nextCity] + computeMaxScore(day + 1, nextCity, k, stayScore, travelScore, dpTable);
                maxPoints = Math.max(maxPoints, scoreTraveling);
            }
        }

        dpTable[day][currentCity] = maxPoints;
        return maxPoints;
    }
}
",1434305406
Shubham Yadav,shubhamyadav32100,156,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int totalCount = 1;
        int i = 0;
        
        while (i < word.length()) {
            int j = i;
            while (j < word.length() && word.charAt(j) == word.charAt(i)) {
                j++;
            }
            
            int segmentLength = j - i;
            totalCount += segmentLength - 1;
            i = j;
        }
        
        return totalCount;
    }
}
",1434260215
Shubham Yadav,shubhamyadav32100,156,3618,java,"class Solution {
    public int possibleStringCount(String word, int k) {
        final int MODULO = (int) (1e9 + 7);
        int length = word.length();
        String inputString = word;

        List<Integer> segmentLengths = new ArrayList<>();
        for (int index = 0; index < length;) {
            int count = 1;
            char currentChar = word.charAt(index);
            index++;
            while (index < length && word.charAt(index) == currentChar) {
                count++;
                index++;
            }
            segmentLengths.add(count);
        }

        int totalSegments = segmentLengths.size();

        long totalCombinations = 1;
        for (int segmentCount : segmentLengths) {
            totalCombinations = (totalCombinations * segmentCount) % MODULO;
        }

        if (k <= totalSegments) {
            return (int) totalCombinations;
        }

        int maxSize = k - 1;
        int[] dp = new int[maxSize + 1];
        dp[0] = 1;

        for (int i = 0; i < totalSegments; i++) {
            int segmentCount = segmentLengths.get(i);
            int[] newDP = new int[maxSize + 1];

            long cumulativeSum = 0;
            for (int s = 0; s <= maxSize; s++) {
                if (s - 1 >= 0) {
                    cumulativeSum = (cumulativeSum + dp[s - 1]) % MODULO;
                }
                if (s - segmentCount - 1 >= 0) {
                    cumulativeSum = (cumulativeSum - dp[s - segmentCount - 1] + MODULO) % MODULO;
                }
                newDP[s] = (int) cumulativeSum;
            }
            dp = newDP;
        }

        long totalLessThanK = 0;
        for (int s = totalSegments; s <= maxSize; s++) {
            totalLessThanK = (totalLessThanK + dp[s]) % MODULO;
        }

        return (int) ((totalCombinations - totalLessThanK + MODULO) % MODULO);
    }
}
",1434381886
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,157,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        
        n = len(parent)
        np = parent[:]
        g = [[] for _ in range(n)]
        for i, x in enumerate(parent):
            if i != 0:
                g[x].append(i)

        lst = defaultdict(list)
        def dfs(node, p):
            v = s[node]
            if len(lst[v]):
                np[node] = lst[v][-1]
            lst[v].append(node)
            for x in g[node]:
                if x != p:
                    dfs(x, node)
            lst[v].pop()
        dfs(0, -1)

        g = [[] for _ in range(n)]
        for i, x in enumerate(np):
            if i != 0:
                g[x].append(i)

        ret = [0] * n
        def dfs2(node, p):
            ct = 1
            for x in g[node]:
                if x != p:
                    ct += dfs2(x, node)
            ret[node] = ct
            return ct
        dfs2(0, -1)
        return ret
        ",1434278800
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,157,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(idx, left):
            if left == 0:
                return 0
            ret = 0
            for x in range(n):
                if x == idx:
                    ret = max(ret, stayScore[k-left][x] + dp(idx, left - 1))
                else:
                    ret = max(ret, travelScore[idx][x] + dp(x, left - 1))
            return ret
        return max([dp(i, k) for i in range(n)])",1434286117
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,157,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        run = 0
        lst = None
        ret = 1
        for x in word:
            if x == lst:
                run += 1
            else:
                ret += max(0, run - 1)
                run = 1
            lst = x
        ret += max(0, run - 1)
        return ret",1434261661
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,157,3618,python3,"MOD = 10**9+7

class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        if k > len(word):
            return 0
        if k == len(word):
            return 1
        runs = []
        run = 0
        lst = None
        for x in word:
            if x == lst:
                run += 1
            else:
                if run:
                    runs.append(run)
                run = 1
            lst = x
        runs.append(run)
        ct = Counter(runs)

        l = list(ct.items())
        tot = 1
        for x, y in l:
            tot *= x**y
        k -= len(runs)

        if k <= 0:
            return tot % MOD
            
        dp = [0] * k
        dp[0] = 1

        for x, y in l:
            x -= 1
            for _ in range(y):
                ls = [0] * k
                for i in range(k):
                    v = dp[i]
                    ls[i] += v
                    if i+x+1 < k: ls[i+x+1] -= v
                ndp = [0] * k
                cur = 0
                for i in range(k):
                    cur += ls[i]
                    ndp[i] += cur
                    ndp[i] %= MOD
                dp = ndp
                # print(dp, ls)
        tot -= sum(dp)
        tot %= MOD
        return tot
                
        

        ",1434376775
Xx_DarDoAzuL_xX,Xx_DarDoAzuL_xX,158,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        const int n = (int) parent.size();

        vector< vector<int > > g(n);
        for (int i = 0; i < n; i++) {
            if (parent[i] == -1) continue;
            g[i].emplace_back(parent[i]);
            g[parent[i]].emplace_back(i);
        }
        
        vector< vector<int> > gg(n);
        vector< vector<int> > w(26);
        auto Dfs = [&](auto&& Dfs, int node, int par) -> void {

            if (!w[ s[node] - 'a' ].empty()) {
                int add = w[ s[node] - 'a' ].back();
                gg[node].emplace_back(add);
                gg[add].emplace_back(node);
            } else if (parent[node] != -1) {
  
                gg[node].emplace_back(parent[node]);
                gg[parent[node]].emplace_back(node);
            }
            w[ s[node] - 'a' ].emplace_back(node);
            for (auto& to : g[node]) {
                if (to == par) continue;
                Dfs(Dfs, to, node);
            }
            w[ s[node] - 'a' ].pop_back();
        };
        Dfs(Dfs, 0, -1);
   //     exit(0);
        vector<int> sub(n);
        auto Calc = [&](auto&& Calc, int node, int par) -> void {
            sub[node] = 1;
            for (auto& to : gg[node]) {
                if (to == par) continue;
                Calc(Calc, to, node);
                sub[node] += sub[to];
            }
        };
        Calc(Calc, 0, -1);
        return sub;
    }
};

",1434281193
Xx_DarDoAzuL_xX,Xx_DarDoAzuL_xX,158,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {

        const int INF = 1e9;
        vector< vector<int> > dp(n, vector<int>(k + 5, -1));
        auto Solve = [&](auto&& Solve, int city, int moves) {
            if (moves == 0) return 0;
            int& res = dp[city][moves];
            if (~res) return res;
            res = -INF;
            res = max(res, stayScore[k - moves][city] + Solve(Solve, city, moves - 1));
            for (int i = 0; i < n; i++) {
                if (i == city) continue;
                res = max(res, travelScore[city][i] + Solve(Solve, i, moves - 1));
            }
            return res;
        };
        int ans = 0;
        for (int i = 0; i < n; i++) ans = max(ans, Solve(Solve, i, k));
        return ans;
        
    }
};",1434288806
Xx_DarDoAzuL_xX,Xx_DarDoAzuL_xX,158,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 0;

        int sz = 1;
        for (int i = 1; i < (int) word.size(); i++) {
            if (word[i] == word[i - 1]) {
                ++sz;
            }  else {
                res += sz - 1;
                sz = 1;
            }
        }
        res += sz - 1;
        return res + 1;
    }
};",1434260485
Xx_DarDoAzuL_xX,Xx_DarDoAzuL_xX,158,3618,cpp,"class Solution {
public:

  const int MOD = 1e9 + 7;

  int add(const int& a, const int& b) {
    int res = a + b;
    if (res >= MOD) res -= MOD;
    return res;
  }

  int sub(const int& a, const int& b) {
    int res = a - b;
    if (res < 0) res += MOD;
    return res;
  }

  int mult(const int& a, const int& b) {
    long long res = 1LL * a * b;
    if (res >= MOD) res %= MOD; 
    return res;
  }

    int possibleStringCount(string word, int k) {
     
        vector<int> group;
        int sz = 1;
        const int n = (int) word.size();
        for (int i = 1; i < n; i++) {
            if (word[i] == word[i - 1]) {
                ++sz;
            } else {
                group.emplace_back(sz);
                sz = 1;
            }
        }
        group.emplace_back(sz);
        vector<int> suf( (int) group.size() );
        suf.back() = group.back();
        for (int i = (int) group.size() - 2; i >= 0; i--) {
            suf[i] = mult(suf[i + 1], group[i]);
        }

        vector< vector<int> > dp(k + 5, vector<int>(k + 5, 0));
        /*
        auto Solve = [&](auto&& Solve, int p, int len) -> int  {
          
          if (p >= (int) group.size()) {
          //    assert(len < k);
              return (len >= k ? 1 : 0);
          }  
          if (len >= k) {
              return suf[p];
          }
          int& res = dp[p][len];
          if (~res) return res;
          res = 0;

          for (int i = 1; i <= group[p]; i++) {
              
              res = add(res, Solve(Solve, p + 1, len + i));
          }
            
            return res;
        };
        return Solve(Solve, 0, 0);
        */
        for (int i = 0; i <= k; i++) dp[0][i] = 1;
        //dp[0][0] = 1;
        int mx = min(k, (int) group.size());
        for (int i = 1; i <= min(k, (int) group.size()); i++) {

            int sz = group[i - 1];

            for (int j = 0; j < k; j++) {
                if (j - 1 >= 0) dp[i][j] = add(dp[i][j], dp[i - 1][j - 1]);
                if (j - sz - 1 >= 0) dp[i][j] = sub(dp[i][j], dp[i - 1][j - sz - 1]);
                //for (int g = 1; g <= sz; g++) {
                  //  if (j - g >= 0) dp[i][j] = add(dp[i][j], dp[i - 1][j - g]);
               // }
                
            }
            
            for (int g = 1; g <= sz; g++) {
                //int tot = dp[i - 1][k];
                //dp[i][k] = add(dp[i][k], tot);
                int at_least = max(0, k - g);
                int ways = dp[i - 1][k];
                if (at_least > 0) ways = sub(ways, dp[i - 1][at_least - 1]);
                
        //        ways = mult(ways, (i + 1 < (int) group.size() ? suf[i + 1] : 1));
                
                dp[i][k] = add(dp[i][k], ways);
                
               // if (k - g >= 0) dp[i][k] = add(dp[i][k], mult( (i + 1 < (int) group.size() ? suf[i + 1] : 1), dp[i - 1][k - g]));
            }
            
          //  for (int z = 0; z <= k; z++) cout << dp[i][z] << ' ';
        //    cout << '\n';

            if (i + 1 <= mx) {
                for (int j = 1; j <= k; j++) {
                    dp[i][j] = add(dp[i][j], dp[i][j - 1]);
                }
            }
           
        }
        if ( min(k, (int) group.size()) == (int) group.size() ) {
            return dp[ min(k, (int) group.size()) ] [k] ;
        }
        return mult(dp[ min(k, (int) group.size()) ] [k], suf[k]);
    }
};",1434380490
Tauqeer,Mtauqeer7770,162,3576,java,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length; // Get the number of nodes in the tree
        List<List<Integer>> tree = new ArrayList<>(n);
        
        // Initialize the adjacency list for the tree structure
        for (int i = 0; i < n; i++) {
            tree.add(new ArrayList<>());
        }

        // Construct the tree from the parent array
        for (int i = 1; i < n; i++) {
            tree.get(parent[i]).add(i);
        }

        int[] lastIndex = new int[n]; // Array to store the last occurrence of each node
        Arrays.fill(lastIndex, -1); // Initialize lastIndex with -1
        int[] lastCharIndex = new int[256]; // To store last character indices
        Arrays.fill(lastCharIndex, -1); // Initialize with -1

        // Perform DFS to populate lastIndex
        dfs(0, s, lastCharIndex, lastIndex, tree);

        int[] newParent = new int[n]; // Array to store new parent references
        Arrays.fill(newParent, -1); // Initialize with -1
        newParent[0] = -1; // Root node has no parent

        // Adjust parents based on last occurrences
        for (int i = 1; i < n; i++) {
            if (lastIndex[i] != -1) {
                newParent[i] = lastIndex[i]; // Update with the last seen index
            } else {
                newParent[i] = parent[i]; // Retain the original parent
            }
        }

        List<List<Integer>> newTree = new ArrayList<>(n); // New tree structure
        for (int i = 0; i < n; i++) {
            newTree.add(new ArrayList<>());
        }

        // Build the new tree based on updated parent references
        for (int i = 0; i < n; i++) {
            if (newParent[i] != -1) {
                newTree.get(newParent[i]).add(i); // Add children to their new parents
            }
        }

        int[] size = new int[n]; // Array to store sizes of subtrees
        Arrays.fill(size, 1); // Each node counts as 1 by default

        // Compute the size of each subtree
        computeSize(0, size, newTree);
        return size; // Return the computed sizes
    }

    // Depth-first search to track last occurrences of characters
    private void dfs(int node, String s, int[] lastCharIndex, int[] lastIndex, List<List<Integer>> tree) {
        char currentChar = s.charAt(node); // Get the current character
        lastIndex[node] = lastCharIndex[currentChar]; // Save the last seen index
        lastCharIndex[currentChar] = node; // Update last seen index to current node

        // Recursively call DFS for each child
        for (int child : tree.get(node)) {
            dfs(child, s, lastCharIndex, lastIndex, tree);
        }

        lastCharIndex[currentChar] = lastIndex[node]; // Restore the last index after DFS
    }

    // Compute sizes of subtrees using DFS
    private int computeSize(int node, int[] size, List<List<Integer>> tree) {
        for (int child : tree.get(node)) {
            size[node] += computeSize(child, size, tree); // Aggregate sizes from children
        }
        return size[node]; // Return size of the current subtree
    }
}
",1434326776
Tauqeer,Mtauqeer7770,162,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int numCities, int numDays, vector<vector<int>>& stayScores, vector<vector<int>>& travelScores) {
        vector<vector<int>> dpTable(numDays + 1, vector<int>(numCities, 0));

        for (int day = 0; day < numDays; day++) {
            for (int currentCity = 0; currentCity < numCities; currentCity++) {
                dpTable[day + 1][currentCity] = max(dpTable[day + 1][currentCity], 
                                                     dpTable[day][currentCity] + stayScores[day][currentCity]);

                for (int destinationCity = 0; destinationCity < numCities; destinationCity++) {
                    if (currentCity != destinationCity) {
                        dpTable[day + 1][destinationCity] = max(dpTable[day + 1][destinationCity], 
                                                                  dpTable[day][currentCity] + travelScores[currentCity][destinationCity]);
                    }
                }
            }
        }

        int highestScore = 0;
        for (int cityIndex = 0; cityIndex < numCities; cityIndex++) {
            highestScore = max(highestScore, dpTable[numDays][cityIndex]);
        }

        return highestScore;
    }
};
",1434374642
Tauqeer,Mtauqeer7770,162,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int[] counts = new int[word.length()];
        int index = 0;
        Character lastChar = null;

        for (char c : word.toCharArray()) {
            if (lastChar == null || c != lastChar) {
                counts[index++] = 1;
                lastChar = c;
            } else {
                counts[index - 1]++;
            }
        }

        int totalCount = 1;
        for (int i = 0; i < index; i++) {
            if (counts[i] > 1) {
                totalCount += counts[i] - 1;
            }
        }

        return totalCount;
    }
}
",1434353464
Tauqeer,Mtauqeer7770,162,3618,cpp,"typedef long long ll;
const int MOD = 1e9 + 7;

class Solution {
public:
    int possibleStringCount(std::string word, int k) {
        std::vector<std::pair<char, int>> charGroups;
        int length = word.length();
        if (length == 0) {
            return (k == 0) ? 1 : 0;
        }

        char currentChar = word[0];
        int charCount = 1;

        for (int i = 1; i < length; i++) {
            if (word[i] == currentChar) {
                charCount++;
            } else {
                charGroups.emplace_back(currentChar, charCount);
                currentChar = word[i];
                charCount = 1;
            }
        }
        charGroups.emplace_back(currentChar, charCount);

        ll totalCount = 1;
        for (const auto& group : charGroups) {
            totalCount = (totalCount * group.second) % MOD;
        }

        int groupCount = charGroups.size();
        int minRequired = groupCount;
        if (k <= minRequired) {
            return totalCount;
        }

        std::vector<ll> dpArray(k, 0);
        dpArray[0] = 1;

        for (const auto& group : charGroups) {
            int groupSize = group.second;
            std::vector<ll> newDpArray(k, 0);
            std::vector<ll> cumulativeSum(k + 1, 0);

            for (int s = 0; s < k; s++) {
                cumulativeSum[s + 1] = (cumulativeSum[s] + dpArray[s]) % MOD;
            }

            for (int s = 0; s < k; s++) {
                int lowerLimit = s - groupSize;
                ll totalOptions = cumulativeSum[s] - (lowerLimit >= 0 ? cumulativeSum[lowerLimit] : 0);
                totalOptions = (totalOptions % MOD + MOD) % MOD;
                newDpArray[s] = totalOptions;
            }

            dpArray = newDpArray;
        }

        ll waysBelowK = 0;
        for (int s = minRequired; s < k; s++) {
            waysBelowK = (waysBelowK + dpArray[s]) % MOD;
        }

        ll result = (totalCount - waysBelowK + MOD) % MOD;
        return (int)result;
    }
};
",1434321832
Yatin Kwatra,yatin_kwatra,165,3576,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

const int N = 1e5 + 5;
vii v[N], g[N];
int n;
vii z;

class Solution {
public:

	void dfs(int node, int par, vii &col, string &s) {
		int oldNo = col[s[node] - 'a'];

		if (oldNo != -1) g[oldNo].pb(node);
        else if(node) g[par].pb(node);

		col[s[node] - 'a'] = node;

		for (auto &i : v[node]) {
			dfs(i,node,  col, s);
		}

		col[s[node] - 'a'] = oldNo;
	}

	void dfss(int node) {
		z[node] = 1;
		for (auto &i : g[node]) {
			dfss(i);
			z[node] += z[i];
		}
	}



	vector<int> findSubtreeSizes(vector<int>& parent, string s) {
		n = parent.size();
		fo(i, 0, n - 1) {
			v[i].clear();
			g[i].clear();
		}

		vector<int> col(26, -1);

		fo(i, 1, n - 1) {
			v[parent[i]].pb(i);
		}
		z.clear();
		z.resize(n);
		fo(i, 0, n - 1) z[i] = 0;

		dfs(0, 0, col, s);
        
		dfss(0);

		return z;
	}
};






















",1434282971
Yatin Kwatra,yatin_kwatra,165,3587,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

class Solution {
public:
	int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
		int ans = 0;
		vvii dp(k + 1, vii(n, 0));

		fo(day, 0, k - 1) {
			vvii tmp = dp;
			fo(i, 0, n - 1) {
				dp[day + 1][i] = max(dp[day + 1][i], tmp[day][i] + stayScore[day][i]);
				ans = max(ans, dp[day + 1][i]);
				fo(j, 0, n - 1) {
					dp[day + 1][j] = max(dp[day + 1][j], tmp[day][i] + travelScore[i][j]);
					ans = max(ans, dp[day + 1][j]);
				}
			}
		}

		return ans;
	}
};






















",1434341129
Yatin Kwatra,yatin_kwatra,165,3617,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

class Solution {
public:
	int possibleStringCount(string word) {
		int n = sz(word);
		vii lens;

		int cur = 1;
		fo(i, 1, n - 1) {
			if (word[i] != word[i - 1]) {
				lens.pb(cur);
				cur = 1;
			}
			else cur++;
		}
		lens.pb(cur);

		int ans = 0;
		for (auto &i : lens) ans += i - 1;
		ans++;
		return ans;
	}
};






















",1434351178
Yatin Kwatra,yatin_kwatra,165,3618,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int addmod(int a, int b) {
	a %= mod;
	b %= mod;
	int ans = (a + b) % mod;
	ans = (ans + mod) % mod;
	return ans;
}



class Solution {
public:
	int possibleStringCount(string s, int k) {
		int n = sz(s);
		vii lots;

		int cur = 1;
		fo(i, 1, n - 1) {
			if (s[i] != s[i - 1]) {
				lots.pb(cur);
				cur = 1;
			}
			else cur++;
		}
		lots.pb(cur);

		int ans = 1;
		for (auto &i : lots) ans = (ans * 1LL * i) % mod;

		n = sz(lots);

		vii dp(k + 2, 0);
		dp[0] = 1;
    
        if(n <= k){
		fo(i, 0, n - 1) {
			vii tmp(k + 2, 0);
			fo(day, 0, k - 1) {
				int a = day + 1;
				int b = min(k, day + lots[i]);
				if (a > k) continue;
				tmp[a] = addmod(tmp[a], dp[day]);
				tmp[b + 1] = addmod(tmp[b + 1], -dp[day]);
			}
			dp = tmp;
			fo(i, 1, k) dp[i] = addmod(dp[i], dp[i - 1]);
		}
	    	fo(i, 0, k - 1) ans = addmod(ans, -dp[i]);
        }

		return ans;
	}
};





















",1434381130
Prajapati Manav,P_Manav,166,3576,cpp,"
class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }

        vector<int> np = parent;
        map<char, vector<int>> res;

        check(0, adj, np, res, s);

        vector<vector<int>> temp(n);
        for (int i = 1; i < n; ++i) {
            temp[np[i]].push_back(i);
        }

        vector<int> ans(n, 0);
        check2(0, temp, ans);

        return ans;
    }

    void check(int node, vector<vector<int>>& adj, vector<int>& np, map<char, vector<int>>& res, string& s) {
        char c = s[node];
        
        if (!res[c].empty()) {
            np[node] = res[c].back();
        }

        res[c].push_back(node);

        for (int child : adj[node]) {
            check(child, adj, np, res, s);
        }

        res[c].pop_back();
    }

    int check2(int node, vector<vector<int>>& temp, vector<int>& ans) {
        int size = 1;
        for (int child : temp[node]) {
            size += check2(child, temp, ans);
        }
        ans[node] = size;
        return size;
    }
};
",1434330668
Prajapati Manav,P_Manav,166,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, 0));

        for (int i = 0; i < n; ++i) {
            dp[0][i] = stayScore[0][i];
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                dp[0][j] = max(dp[0][j], travelScore[i][j]);
            }
        }

        for (int i = 1; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                int maxi = dp[i - 1][j] + stayScore[i][j];
                for (int k = 0; k < n; ++k) {
                    maxi = max(maxi, dp[i - 1][k] + travelScore[k][j]);
                }
                dp[i][j] = maxi;
            }
        }

        return *max_element(dp[k - 1].begin(), dp[k - 1].end());
    }
};
",1434381871
Prajapati Manav,P_Manav,166,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        map<char,int>check;
        int n=word.size();
        vector<int>temp;
        int maxi=0;
        for(int i=1;i<n;i++){
            if(word[i]==word[i-1]){
                maxi++;
            }
            else{
                temp.push_back(maxi);
                maxi=0;
            }
            
        }
        temp.push_back(maxi);
        
        int count=1;
        for(int i=0;i<temp.size();i++){
            count+=temp[i];
        }
        
        return count;
    }
};",1434265659
Prajapati Manav,P_Manav,166,3618,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    vector<long long> check(const vector<int>& res, int m) {
        vector<long long> dp(m + 1, 0);
        dp[0] = 1;
        for (auto c : res) {
            int temp = c - 1;
            vector<long long> prefix(m + 2, 0);
            for (int j = 0; j <= m; j++) {
                prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
            }
            vector<long long> dp2(m + 1, 0);
            for (int j = 0; j <= m; j++) {
                int l = j - temp;
                if (l < 0) l = 0;
                dp2[j] = (prefix[j + 1] - prefix[l] + MOD) % MOD;
            }
            dp = dp2;
        }
        return dp;
    }

    int possibleStringCount(string word, int k) {
        vector<int> res;
        int i = 0;
        int len = word.size();
        while (i < len) {
            char current = word[i];
            int cnt = 1;
            while (i + 1 < len && word[i + 1] == current) {
                cnt++;
                i++;
            }
            res.push_back(cnt);
            i++;
        }
        
        int n = res.size();
        long long total = 1;
        for (auto c : res) {
            total = total * c % MOD;
        }
        
        if (n > k) {
            return total;
        }
        
        int m = k - 1 - n;
        if (m < 0) {
            return total;
        }

        vector<long long> dp = check(res, m);
        
        long long ways = 0;
        for (int j = 0; j <= m; j++) {
            ways = (ways + dp[j]) % MOD;
        }
        
        return (total - ways + MOD) % MOD;
    }
};
",1434371205
Umesh Kumar,icosa,167,3576,cpp,"class Solution {
public:
    typedef vector<int> vi;
    typedef vector<vi> vvi;

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vi ans(n, 0), new_parent(n, -1);
        vvi adj(n);
        
        for(int i=1; i<n; i++){
            adj[parent[i]].push_back(i);
        }

        stack<int> st[26];
        function<void(int)> dfs = [&](int u){
            int ord = s[u] - 'a';
            new_parent[u] = parent[u];
            if(st[ord].size()) new_parent[u] = st[ord].top();
            st[ord].push(u);
            for(auto v: adj[u]) dfs(v);
            st[ord].pop();
        };

        dfs(0);

        adj.clear();
        adj.assign(n, vi());
        for(int i=1; i<n; i++){
            adj[new_parent[i]].push_back(i);
        }

        function<void(int)> dfs2 = [&](int u){
            for(int v: adj[u]) {
                dfs2(v);
                ans[u] += ans[v];
            }
            ans[u] += 1;
        };

        dfs2(0);
        return ans;
    }
};",1434298701
Umesh Kumar,icosa,167,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {

        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for(int d = k-1; d >= 0; d--){
            for(int c=0; c<n; c++){
                for(int c2=0; c2<n; c2++){
                    if(c == c2) dp[d][c] = max(dp[d][c], stayScore[d][c] + dp[d+1][c]);
                    else dp[d][c] = max(dp[d][c], travelScore[c][c2] + dp[d+1][c2]);
                }
            }
        }

        int ans = 0;
        for(int i=0; i<n; i++) ans = max(ans, dp[0][i]);
        return ans;
    }
};",1434310167
Umesh Kumar,icosa,167,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int last = 0, cnt = 1, ans = 1;
        for(auto c: word){
            if(c == last) cnt++;
            else{
                ans += (cnt - 1);
                cnt = 1;
            }
            last = c;
        }
        ans += (cnt - 1);
        return ans;
    }
};",1434268883
Umesh Kumar,icosa,167,3618,cpp,"class Solution {
public:
    #define ll long long
    const ll mod = 1e9+7;
    typedef vector<ll> vi;

    int possibleStringCount(string word, int k) {
        vector<ll>dp(k, 0);
        dp[0] = 1;
        ll tot = 1;
        
        char last = word[0];
        ll cnt = 0;
        int mnlen = 0;
        vi tmp(k);
        
        for(auto c: word){
            if(c == last){
                cnt++;
            }
            else {
                tot = tot * cnt % mod;
                mnlen++;
                // tmp.assign(k, 0);
                if(mnlen < k){
                    tmp[0] = 0;
                    ll rs = 0;
                    for(int i=1; i<k; i++){
                        rs += dp[i-1];
                        if(i - cnt - 1 >= 0) rs -= dp[i-cnt-1];
                        rs %= mod;
                        tmp[i] = rs;
                    }
                    swap(dp, tmp);
                }
                last = c;
                cnt = 1;
                //dp[mnlen] = 1;
            }
        }
        tot = tot * cnt % mod;
        // tmp.assign(k, 0);
        tmp[0] = 0;
        ll rs = 0;
        for(int i=1; i<k; i++){
            rs += dp[i-1];
            if(i - cnt - 1 >= 0) rs -= dp[i-cnt-1];
            rs %= mod;
            tmp[i] = rs;
        }
        swap(dp, tmp);
        
        // cout << tot << "" "" << mnlen << endl;
        // for(int i=0; i<k; i++) cout << dp[i] << "" ""; 
        ll ans = tot;
        for(int i=mnlen; i<k; i++) {
            ans = (ans - dp[i]) % mod;
        }

        if(ans < 0) ans += mod;
        return ans;
    }
};",1434387880
Truong Pham,truongphamminh17,168,3576,javascript,"/**
 * @param {number[]} parent
 * @param {string} s
 * @return {number[]}
 */
var findSubtreeSizes = function (parent, s) {
  const n = s.length;
  const tree = Array.from({ length: n }, () => new Set());

  for (let i = 1; i < n; i++) {
    tree[parent[i]].add(i);
  }


  const travel = (node, map) => {
    const value = s[node];
    if (map.get(value) !== undefined) {
      // update parent
      if (map.get(value) !== parent[node]) {
        tree[map.get(value)].add(node)
        tree[parent[node]].delete(node)
      }
    }
    const oldMap = map.get(value)

    map.set(value, node)
    for (const child of tree[node].keys()) {
      travel(child, map)
    }
    map.set(value, oldMap)
  }

  // count the diff
  const rs = Array(n).fill(0)
  const reTravel = (node) => {
    let value = 1
    for (const c of tree[node].keys()) {
      value += reTravel(c)
    }
    rs[node] = value
    return rs[node]
  }

  travel(0, new Map())
  reTravel(0)
  return rs
};",1434303919
Truong Pham,truongphamminh17,168,3587,javascript,"/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function (n, k, stayScore, travelScore) {
  const dp = Array.from({ length: k }, () => Array(n).fill(0))
  for (let city = 0; city < n; city++) {
    dp[0][city] = stayScore[0][city]
  }

  for (let day = 0; day < k; day++) {
    for (let city = 0; city < n; city++) {
      // for staying
      if (day > 0) {
        dp[day][city] = Math.max(dp[day][city], stayScore[day][city] + dp[day - 1][city])
      }

      for (let oldCity = 0; oldCity < n; oldCity++) {
        if (oldCity !== city) {
          dp[day][city] = Math.max(dp[day][city], (day > 0 ? dp[day - 1][oldCity] : 0) + travelScore[oldCity][city])
        }
      }
    }
  }
  let max = 0;
  for (let city = 0; city < n; city++) {
    max = Math.max(max, dp[k - 1][city])
  }
  return max
};",1434331788
Truong Pham,truongphamminh17,168,3617,javascript,"/**
 * @param {string} word
 * @return {number}
 */
var possibleStringCount = function (word) {
  let rs = 0;
  let tempC = ''
  let tempCount = 0;
  for (const c of word) {
    if (c === tempC) {
      tempCount++
    } else {
      tempCount = 0
    }
    tempC = c
    if (tempCount > 0) {
      rs++
    }
  }
  return rs + 1
};",1434263218
Truong Pham,truongphamminh17,168,3618,javascript,"

/**
 * @param {string} word
 * @param {number} k
 * @return {number}
 */
var possibleStringCount = function (word, k) {
  const MOD = 10 ** 9 + 7
  function countLessK(A, k) {
    const n = A.length;
    const dp = Array(k).fill(0);
    dp[0] = 1;

    for (let i = 0; i < n; i++) {
      const currentMax = A[i];
      const newDp = dp.slice();


      const prefixSum = Array(k + 1).fill(0);
      for (let sum = 0; sum < k; sum++) {
        prefixSum[sum + 1] = prefixSum[sum] + dp[sum];
        prefixSum[sum + 1] %= MOD
      }


      for (let sum = 0; sum < k; sum++) {
        const start = Math.max(0, sum - currentMax);
        newDp[sum] = (prefixSum[sum + 1] - prefixSum[start] + MOD) % MOD;
      }


      for (let j = 0; j < k; j++) {
        dp[j] = newDp[j];
      }
    }


    let totalWays = 0;
    for (let sum = 0; sum < k; sum++) {
      totalWays += dp[sum];
      totalWays %= MOD
    }

    return totalWays;
  }



  const arr = []
  let curCount = 0;
  let curChar = ''
  let nonDuplicate = 0;
  for (const c of word) {
    if (c === curChar) {
      curCount++
    } else {
      if (curCount > 0) {
        arr.push(curCount)
      }
      curCount = 0
      nonDuplicate++
    }
    curChar = c
  }
  if (curCount > 0) {
    arr.push(curCount)
  }

  const exclude = k - nonDuplicate >= 0 ? countLessK(arr, k - nonDuplicate) : 0
  let total = 1;
  for (const value of arr) {
    total *= (value + 1);
    total %= MOD
  }
  return (total - exclude + MOD) % MOD
};
",1434383886
Avi Akad,Avuvos,169,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        vector<vector<int>> last(26);
        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }
        vector<int> ans(n, 0);
        vector<vector<int>> ng(n);
        auto dfs = [&](auto &dfs, int u) -> void {
            last[s[u] - 'a'].push_back(u);
            for (auto &v: g[u]) {
                int p = s[v] - 'a';
                if (last[p].empty()) {
                    ng[u].push_back(v);
                } else {
                    ng[last[p].back()].push_back(v);
                }
                dfs(dfs, v);
            }
            last[s[u] - 'a'].pop_back();
        };
        dfs(dfs, 0);

        auto dfs2 = [&](auto &dfs2, int u) -> void {
            ans[u] = 1;
            for (auto &v: ng[u]) {
                dfs2(dfs2, v);
                ans[u] += ans[v];
            }
        };
        dfs2(dfs2, 0);
        return ans;
    }
};",1434340479
Avi Akad,Avuvos,169,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        //repeat n times
        //choose start city i. then each turn we have n + 1 choices.. either move or stay
        //that is going to be done K times.
        //our state would be in that case (city, days) n^2
        //we can do dp[n][k] max value we can get starting from city n with k days left and we're good I think.
        vector<vector<int>> dp(n, vector<int>(k, -1));
        auto dfs = [&](auto &dfs, int city, int days) -> int {
            if (days < 0) {
                return 0;
            }
            if (dp[city][days] != -1) {
                return dp[city][days];
            }
            int best = stayScore[k - 1 - days][city] + dfs(dfs, city, days - 1);
            for (int i = 0; i < n; i++) {
                if (i == city) continue;
                int go = travelScore[city][i] + dfs(dfs, i, days - 1);
                best = max(best, go);
            }
            return dp[city][days] = best;
        };
        for (int i = 0; i < n; i++) {
            dfs(dfs, i, k - 1);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, dp[i][k - 1]);
        }
        return ans;
    }
};",1434340752
Avi Akad,Avuvos,169,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 0;
        int streak = 1;
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i - 1]) {
                streak++;
            } else {
                ans += streak - 1;
                streak = 1;
            }
        }
        ans += streak;
        return ans;
    }
};",1434340342
Avi Akad,Avuvos,169,3618,cpp,"typedef long long ll;
class Solution {
public:
    int possibleStringCount(string word, int k) {
        const int MOD = 1e9 + 7;
        vector<int> buckets;
        int streak = 1;
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i - 1]) {
                streak++;
            } else {
                buckets.push_back(streak);
                streak = 1;
            }
        }
        buckets.push_back(streak);
        ll tot = 1;
        for (auto cnt: buckets) {
            tot = (tot * cnt) % MOD;
        }
        int n = buckets.size();
        if (n >= k) {
            return tot;
        }
        vector<int> dp(k), ndp(k), ps(k + 1);
        dp[0] = 1;
        for (int i = 0; i < n; i++) {
            ps.assign(k + 1, 0);
            for (int s = 0; s < k; s++) {
                ps[s + 1] = (ps[s] + dp[s]) % MOD;
            }
            for (int s = 0; s < k; s++) {
                int low = max(0, s - buckets[i]);
                ndp[s] = (ps[s] - ps[low] + MOD) % MOD;
            }
            swap(dp, ndp);
            ndp.assign(k, 0);
        }
        ll bad = 0;
        for (int s = n; s < k; s++) {
            bad = (bad + dp[s]) % MOD;
        }
        ll ans = (tot - bad + MOD) % MOD;
        return ans;
    }
};",1434385481
Wanjun Li,wjli,170,3587,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)



class Solution {
public:
	int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
		// dp[curr city][days] = max value
		int INF = 1E9, i, j, ans;
		VI dp(n, 0), dp2 = dp;
		FOR(kk, k) {
			dp2 = dp;
			FOR(i, n) {
				dp[i] = max(dp[i], dp2[i] + stayScore[kk][i]);
				FOR(j, n) {
					dp[i] = max(dp[i], dp2[j] + travelScore[j][i]);
				}
			}
		}
		return *max_element(ALL(dp));
	}
};
",1434275395
Wanjun Li,wjli,170,3617,cpp,"


// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)

class Solution {
public:
	int possibleStringCount(string word) {
		int n = word.size(), i, j, k, ans = 1;
		FOR(i, n) {
			for (j = i; (j < n) && (word[i] == word[j]); j++);
			ans += j - i - 1;
			i = j - 1;
		}
		return ans;
	}
};

",1434278561
Wanjun Li,wjli,170,3618,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)

class Solution {
public:
	int possibleStringCount(string word, int k) {
		LL n = word.size(), i, j, ans = 1, MOD = 1000000007, m, kk, s;

		if (k > n) return 0;

		VL v;
		FOR(i, n) {
			for (j = i; (j < n) && (word[i] == word[j]); j++);
			v.push_back(j - i - 1); 
			i = j - 1;
		}
		m = v.size();

		kk = max(k - m, 0LL);
		// dp[character added] = # of times
		VL dp(kk + 1, 0), dp2 = dp;
		dp[0] = 1;

		FOR(i, m) {
			swap(dp, dp2);
			dp.assign(kk + 1, 0);
			s = 0;

			dp[kk] = (dp2[kk] * (v[i] + 1)) % MOD;
			FOR(j, kk) {
				s = (s + dp2[j]) % MOD;
				dp[j] = s;
				if (j - v[i] >= 0) 
					s = (s + MOD - dp2[j - v[i]]) % MOD;

				if (j + v[i] >= kk) dp[kk] = (dp[kk] + dp2[j] * (j + v[i] - kk + 1)) % MOD;
			}

			j = 0;
		}

		ans = dp[kk] % MOD;

		return ans;
	}
};
",1434301820
kishan-jaiswal,kishan-jaiswal,171,3587,cpp,"class Solution {
public:
    int add(long long a, long long b) {
        return a + b;
    }

    long long getMaxPointsForStay(int day, int city, vector<vector<int>>& stay, vector<vector<long long>>& points) {
        return add(stay[day][city], points[day + 1][city]);
    }

    long long getMaxPointsForTravel(int current, int destination, vector<vector<int>>& travel, vector<vector<long long>>& points, int day) {
        return add(travel[current][destination], points[day + 1][destination]);
    }

    void calculatePoints(int day, int cities, vector<vector<int>>& stay, vector<vector<int>>& travel, vector<vector<long long>>& points) {
        for(int current = 0; current < cities; current++) {
            long long maxScore = 0;
            maxScore = max(maxScore, getMaxPointsForStay(day, current, stay, points));
            for(int destination = 0; destination < cities; destination++) {
                if(destination != current) {
                    maxScore = max(maxScore, getMaxPointsForTravel(current, destination, travel, points, day));
                }
            }
            points[day][current] = maxScore;
        }
    }

    int maxScore(int cities, int days, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<vector<long long>> points(days + 1, vector<long long>(cities, 0));
        
        for(int day = days - 1; day >= 0; day--) {
            calculatePoints(day, cities, stay, travel, points);
        }
        
        long long maxResult = 0;
        for(int startCity = 0; startCity < cities; startCity++) {
            maxResult = max(maxResult, points[0][startCity]);
        }
        
        return maxResult;
    }
};
",1434304795
kishan-jaiswal,kishan-jaiswal,171,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length();
        set<string> results;
        
        results.insert(word);
        
        for(int i = 0; i < n - 1; i++) {
            if(word[i] == word[i + 1]) {
                int j = i + 1;
                while(j < n && word[j] == word[i]) {
                    j++;
                }
                
                string modified = word;
                for(int k = i + 1; k < j; k++) {
                    string temp = word.substr(0, k) + word.substr(j);
                    results.insert(temp);
                }
                
                i = j - 1;
            }
        }
        
        return results.size();
    }
};",1434287185
kishan-jaiswal,kishan-jaiswal,171,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

const int MOD = 1'000'000'007;

class Solution {
public:
    int possibleStringCount(string word, int k) {
        vector<int> ans;
        int n = word.length();
        if(n ==0) {
            return 0;
        }
        char current_char = word[0];
        int count =1;
        for(int i=1;i<n;i++) {
            if(word[i]==current_char){
                count++;
            }
            else{
                ans.push_back(count);
                current_char = word[i];
                count =1;
            }
        }
        ans.push_back(count);
        int N = ans.size();

        long long mx =0;
        for(auto len : ans){
            mx += len;
        }

        long long cnt =1;
        for(auto len : ans){
            cnt = (cnt * (long long)len) % MOD;
        }
        if(N > k){
            return cnt;
        }
        if(mx < (long long)k){
            return 0;
        }

        vector<long long> dp(k, 0);
        dp[0] =1;

        for(auto el : ans){
            vector<long long> pre_sum(k, 0);
            pre_sum[0] = dp[0];
            for(int j=1; j<k; j++){
                pre_sum[j] = (pre_sum[j-1] + dp[j]) % MOD;
            }
            vector<long long> dp_new(k, 0);
            for(int j=0; j<k; j++){
                if(j <1){

                    continue;
                }
                int s_max = min(el, j);
                long long val = pre_sum[j-1];
                if(j - s_max -1 >=0){
                    val = (val - pre_sum[j - s_max -1] + MOD) % MOD;
                }
                dp_new[j] = (dp_new[j] + val) % MOD;
            }
            dp = move(dp_new);
        }

        long long assignments_less =0;
        for(int j=0; j<k; j++){
            assignments_less = (assignments_less + dp[j]) % MOD;
        }
        long long answer = (cnt - assignments_less + MOD) % MOD;
        return (int)answer;
    }
};",1434268253
VinayKumarReddy_5204,VinayKumarReddy_5204,173,3587,csharp,"public class Solution {
    public int MaxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[,] dp = new int[k + 1, n];

        for (int day = k - 1; day >= 0; day--) {
            for (int city = 0; city < n; city++) {
                int maxPoints = stayScore[day][city] + dp[day + 1, city];

                for (int nextCity = 0; nextCity < n; nextCity++) {
                    if (nextCity != city) {
                        maxPoints = Math.Max(maxPoints, 
                            travelScore[city][nextCity] + dp[day + 1, nextCity]);
                    }
                }
                dp[day, city] = maxPoints;
            }
        }
        
        int result = 0;
        for (int city = 0; city < n; city++) {
            result = Math.Max(result, dp[0, city]);
        }
        
        return result;
    }
}
",1434273529
VinayKumarReddy_5204,VinayKumarReddy_5204,173,3617,csharp,"public class Solution {
    public int PossibleStringCount(string word) {
        int count = 1; // Initialize count

        for (int i = 0; i < word.Length;) {
            char currentChar = word[i];
            int j = i;

            // Count the number of consecutive characters
            while (j < word.Length && word[j] == currentChar) {
                j++;
            }

            // The number of original strings we can form from this group of characters is
            // (number of consecutive characters) + 1 (the original grouping itself)
            count += (j - i) - 1; 
            i = j;  // Move to the next different character
        }

        return count; // Total count of possible original strings
    }
}
",1434266300
VinayKumarReddy_5204,VinayKumarReddy_5204,173,3618,csharp,"public class Solution {
    private const long MOD_VAL = 1000000007;
    
    public int PossibleStringCount(string word, int k) {
        if (string.IsNullOrEmpty(word)) {
            return ProcessEmptyString(k);
        }
        
        var groups = ExtractCharGroups(word);
        long baseResult = CalculateBaseProduct(groups);
        
        int minRequired = groups.Count;
        if (k <= minRequired) {
            return (int)baseResult;
        }
        
        return ProcessDynamicCases(groups, k, baseResult, minRequired);
    }
    
    private int ProcessEmptyString(int k) {
        return k == 0 ? 1 : 0;
    }
    
    private List<Tuple<char, int>> ExtractCharGroups(string word) {
        var groups = new List<Tuple<char, int>>();
        char currentChar = word[0];
        int charCount = 1;
        
        for (int i = 1; i < word.Length; i++) {
            if (word[i] == currentChar) {
                charCount++;
            }
            else {
                groups.Add(Tuple.Create(currentChar, charCount));
                currentChar = word[i];
                charCount = 1;
            }
        }
        groups.Add(Tuple.Create(currentChar, charCount));
        return groups;
    }
    
    private long CalculateBaseProduct(List<Tuple<char, int>> groups) {
        long result = 1;
        foreach (var group in groups) {
            result = (result * group.Item2) % MOD_VAL;
        }
        return result;
    }
    
    private int ProcessDynamicCases(List<Tuple<char, int>> groups, int k, long baseResult, int minRequired) {
        long[] dp = new long[k];
        dp[0] = 1;
        
        foreach (var group in groups) {
            dp = UpdateDynamicArray(dp, k, group.Item2);
        }
        
        long lessSum = CalculateLessSum(dp, k, minRequired);
        long finalResult = (baseResult - lessSum + MOD_VAL) % MOD_VAL;
        
        return (int)finalResult;
    }
    
    private long[] UpdateDynamicArray(long[] dp, int k, int length) {
        long[] newDp = new long[k];
        long[] prefixSum = CalculatePrefixSum(dp, k);
        
        for (int i = 0; i < k; i++) {
            int lowerBound = i - length;
            long rangeSum = prefixSum[i] - (lowerBound >= 0 ? prefixSum[lowerBound] : 0);
            newDp[i] = (rangeSum % MOD_VAL + MOD_VAL) % MOD_VAL;
        }
        
        return newDp;
    }
    
    private long[] CalculatePrefixSum(long[] arr, int k) {
        long[] prefixSum = new long[k + 1];
        for (int i = 0; i < k; i++) {
            prefixSum[i + 1] = (prefixSum[i] + arr[i]) % MOD_VAL;
        }
        return prefixSum;
    }
    
    private long CalculateLessSum(long[] dp, int k, int minRequired) {
        long sum = 0;
        for (int i = minRequired; i < k; i++) {
            sum = (sum + dp[i]) % MOD_VAL;
        }
        return sum;
    }
}
",1434317885
Allucard,Allucard69,174,3587,cpp,"class Solution {
public:
    
 #define APPLE 201
#define BANANA 201

int orange[APPLE][BANANA];
int mango[BANANA][BANANA];
int grape[APPLE + 1][BANANA];
    
int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    for (int i = 0; i <= k; ++i) {
        for (int j = 0; j < n; ++j) {
            grape[i][j] = 0;
        }
    }

    for (int day = 0; day < k; ++day) {
        for (int curr = 0; curr < n; ++curr) {
            for (int next = 0; next < n; ++next) {
                if (next == curr) {
                    grape[day + 1][curr] = max(grape[day + 1][curr], grape[day][curr] + stayScore[day][curr]);
                } else {
                    grape[day + 1][next] = max(grape[day + 1][next], grape[day][curr] + travelScore[curr][next]);
                }
            }
        }
    }

    int max_points = 0;
    for (int i = 0; i < n; ++i) {
        max_points = max(max_points, grape[k][i]);
    }

    return max_points;
    }
};",1434306624
Allucard,Allucard69,174,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
    if (w.empty())  return 0;

    int total = 1;
    int n = w.size();
    
    for (int i = 0; i < n; i++) {
        int cnt = 1;
        while (i + 1 < n && w[i] == w[i + 1]) {
            cnt++;
            i++;
        }
        total += cnt - 1;
    }

    return total;
}
};",1434297778
Allucard,Allucard69,174,3618,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int possibleStringCount(string word, int k) {
        int n = word.size();
        vector<int> gc; 
        
        int i = 0;
        while (i < n) {
            int cnt = 1;
            while (i + cnt < n && word[i + cnt] == word[i]) {
                cnt++;
            }
            gc.push_back(cnt);
            i += cnt;
        }
        
        int m = gc.size(); 
        int ml = m;      
        int nl = n;        

        if (k > nl) return 0; 

        int tp = 1; 
        i = 0;
        while (i < m) {
            tp = (1LL * tp * gc[i]) % MOD;
            i++;
        }
        int sm = k - ml; 
        if (sm <= 0) return tp; 
        int sl = 0; 
        i = 0;
        while (i < m) {
            sl += (gc[i] - 1);
            i++;
        }
        sm = min(sm - 1, sl); 

        vector<int> dp(sm + 1, 0);
        dp[0] = 1;

        i = 0;
        while (i < m) {
            int l = min(gc[i] - 1, sm);
            vector<int> ndp(sm + 1, 0);
            vector<int> ps(sm + 2, 0);

            int s = 0;
            while (s <= sm) {
                ps[s + 1] = (ps[s] + dp[s]) % MOD;
                s++;
            }

            s = 0;
            while (s <= sm) {
                int start = max(0, s - l);
                int end = s;
                ndp[s] = (ps[end + 1] - ps[start] + MOD) % MOD;
                s++;
            }

            dp = move(ndp);
            i++;
        }

        long long ic = 0;
        int s = 0;
        while (s <= sm) {
            ic = (ic + dp[s]) % MOD;
            s++;
        }

        long long res = (tp - ic + MOD) % MOD;
        return res;
    }
};
",1434329807
Akash,akash_y_codes,175,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dpArray = new int[k + 1][n];

        for (int dayIndex = 1; dayIndex <= k; dayIndex++) {
            for (int currentCity = 0; currentCity < n; currentCity++) {
                dpArray[dayIndex][currentCity] = dpArray[dayIndex - 1][currentCity] + stayScore[dayIndex - 1][currentCity];
            }

            for (int currentCity = 0; currentCity < n; currentCity++) {
                for (int destinationCity = 0; destinationCity < n; destinationCity++) {
                    if (currentCity != destinationCity) {
                        dpArray[dayIndex][destinationCity] = Math.max(dpArray[dayIndex][destinationCity], dpArray[dayIndex - 1][currentCity] + travelScore[currentCity][destinationCity]);
                    }
                }
            }
        }

        int maxResult = 0;
        for (int cityIndex = 0; cityIndex < n; cityIndex++) {
            maxResult = Math.max(maxResult, dpArray[k][cityIndex]);
        }

        return maxResult;
    }
}
",1434278655
Akash,akash_y_codes,175,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int totalCount = 1;
        int i = 0;

        while (i < word.length()) {
            int segmentLength = countContiguousSegmentLength(word, i);
            totalCount += calculatePossibilities(segmentLength);
            i += segmentLength;
        }

        return totalCount;
    }

    private int countContiguousSegmentLength(String word, int start) {
        int end = start;
        while (end < word.length() && word.charAt(start) == word.charAt(end)) {
            end++;
        }
        return end - start;
    }

    private int calculatePossibilities(int segmentLength) {
        return segmentLength - 1;
    }
}
",1434260724
Akash,akash_y_codes,175,3618,cpp,"class Solution {
    const int MOD = 1e9 + 7;

public:
    int possibleStringCount(string word, int k) {
        const int ONE = 1;
        const int ZERO = 0;

        int n = word.size();
        vector<vector<int>> groupLengths(ONE);
        int groupCount[ONE][ONE]; 
        groupCount[ZERO][ZERO] = ZERO; 

        int charCount[ONE][ONE]; 
        charCount[ZERO][ZERO] = ONE;

        // Group lengths calculation
        for (int i = ONE; i <= n; ++i) {
            if (i == n || word[i] != word[i - ONE]) {
                groupLengths[ZERO].push_back(charCount[ZERO][ZERO]);
                groupCount[ZERO][ZERO] += ONE;
                charCount[ZERO][ZERO] = ONE;
            } else {
                charCount[ZERO][ZERO] += ONE;
            }
        }

        long long totalCombinations = ONE;
        for (int length : groupLengths[ZERO]) {
            totalCombinations = (totalCombinations * length) % MOD;
        }

        int remainingGroups[ONE][ONE];
        remainingGroups[ZERO][ZERO] = k - groupCount[ZERO][ZERO];

        if (remainingGroups[ZERO][ZERO] <= ZERO) {
            return (int)totalCombinations;
        }

        // Calculate valid combinations
        long long totalBad = calculateValidCombinations(groupLengths, remainingGroups[ZERO][ZERO]);
        
        long long totalWays = (totalCombinations - totalBad + MOD) % MOD;
        return (int)totalWays;
    }

private:
    long long calculateValidCombinations(const vector<vector<int>>& groupLengths, int remainingGroups) {
        const int ZERO = 0;
        const int ONE = 1;

        vector<vector<int>> dp(ONE, vector<int>(remainingGroups + ONE, ZERO));
        dp[ZERO][ZERO] = ONE;

        for (int length : groupLengths[ZERO]) {
            int maxDelta = min(length - ONE, remainingGroups);
            vector<vector<int>> dpNew(ONE, vector<int>(remainingGroups + ONE, ZERO));

            int windowSum[ONE][ONE];
            windowSum[ZERO][ZERO] = ZERO;

            for (int s = ZERO; s <= remainingGroups; ++s) {
                windowSum[ZERO][ZERO] = (windowSum[ZERO][ZERO] + dp[ZERO][s]) % MOD;

                if (s - maxDelta - ONE >= ZERO) {
                    windowSum[ZERO][ZERO] =
                        (windowSum[ZERO][ZERO] - dp[ZERO][s - maxDelta - ONE] + MOD) % MOD;
                }
                dpNew[ZERO][s] = windowSum[ZERO][ZERO];
            }
            dp = dpNew;
        }

        long long totalBad = ZERO;
        for (int s = ZERO; s < remainingGroups; ++s) {
            totalBad = (totalBad + dp[ZERO][s]) % MOD;
        }

        return totalBad;
    }
};
",1434330893
Nihal,nsk_91,176,3587,cpp,"
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int var_200, int var_201, vector<vector<int>>& var_202, vector<vector<int>>& var_203) {
        vector<vector<int>> var_204(var_201 + 1, vector<int>(var_200, -1));
        
        auto func_201 = [&](int var_205, int var_206, auto& func_201_ref) -> int {
            switch (var_205 == var_201) {
                case 1:
                    return 0;
            }

            switch (var_204[var_205][var_206] != -1) {
                case 1:
                    return var_204[var_205][var_206];
            }

            int var_207 = var_202[var_205][var_206] + func_201_ref(var_205 + 1, var_206, func_201_ref);

            int var_208 = 0;
            while (var_208 < var_200) {
                switch (var_208 != var_206) {
                    case 1:
                        var_207 = max(var_207, var_203[var_206][var_208] + func_201_ref(var_205 + 1, var_208, func_201_ref));
                        break;
                }
                var_208++;
            }

            var_204[var_205][var_206] = var_207;
            return var_207;
        };

        int var_209 = 0;
        int var_210 = 0;
        while (var_210 < var_200) {
            var_209 = max(var_209, func_201(0, var_210, func_201));
            var_210++;
        }
        return var_209;
    }
};
",1434304969
Nihal,nsk_91,176,3617,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int possibleStringCount(string var_200) {
        int var_201 = 0;

        if (var_200.empty()) {
            return 0;
        } else {
            vector<pair<char, int>> var_202;
            char var_203 = var_200[0];
            int var_204 = 1;
            int var_205 = 1;
            while (var_205 < var_200.size()) {
                if (var_200[var_205] == var_203) {
                    var_204++;
                } else {
                    var_202.emplace_back(make_pair(var_203, var_204));
                    var_203 = var_200[var_205];
                    var_204 = 1;
                }
                var_205++;
            }
            var_202.emplace_back(make_pair(var_203, var_204));
            
            int var_206 = 0;
            int var_207 = 0;
            while (var_207 < var_202.size()) {
                if (var_202[var_207].second >= 2) {
                    var_206 += (var_202[var_207].second - 1);
                }
                var_207++;
            }
            return 1 + var_206;
        }
    }
};
",1434291790
Nihal,nsk_91,176,3618,cpp,"
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int possibleStringCount(string var_200, int var_201) {
        const int var_202 = 1e9 + 7;
        vector<int> var_203;
        int var_204 = 0;
        int var_205 = 0;
        int var_206 = var_200.length();
        
        for (int var_207 = 0; var_207 < var_206; ++var_207) {
            char var_208 = var_200[var_207];
            int var_209 = 1;
            
            for (int var_210 = var_207 + 1; var_210 < var_206 && var_200[var_210] == var_208; ++var_210) {
                var_209++;
                var_207++;
            }
            var_203.push_back(var_209);
        }

        var_204 = var_203.size();
        string var_211 = var_200;
        long long var_212 = 1;
        
        for (auto var_213 : var_203) {
            var_212 = var_212 * var_213 % var_202;
        }

        switch (var_204 > var_201) {
            case true:
                return var_212;
            default:
                int var_214 = var_201 - 1 - var_204;
                if (var_214 < 0) return var_212;
                
                vector<long long> var_215(var_214 + 1, 0);
                var_215[0] = 1;
                
                for (auto var_216 : var_203) {
                    int var_217 = var_216 - 1;
                    vector<long long> var_218(var_214 + 2, 0);
                    
                    for (int var_219 = 0; var_219 <= var_214; ++var_219) {
                        var_218[var_219 + 1] = (var_218[var_219] + var_215[var_219]) % var_202;
                    }

                    vector<long long> var_220(var_214 + 1, 0);
                    
                    for (int var_221 = 0; var_221 <= var_214; ++var_221) {
                        int var_222 = var_221 - var_217;
                        if (var_222 < 0) var_222 = 0;
                        var_220[var_221] = (var_218[var_221 + 1] - var_218[var_222] + var_202) % var_202;
                    }
                    var_215 = var_220;
                }
                
                long long var_223 = 0;
                for (int var_224 = 0; var_224 <= var_214; ++var_224) {
                    var_223 = (var_223 + var_215[var_224]) % var_202;
                }
                
                return (var_212 - var_223 + var_202) % var_202;
        }
    }
};
",1434334504
Ayush,as_313,178,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, s: List[List[int]], t: List[List[int]]) -> int:
        if n == 1: return sum(s[i][0] for i in range(k))

        p = [max(s[0][j], max(t[q][j] for q in range(n) if q != j)) for j in range(n)]
        for _ in range(1, k):
            c = [0] * n
            for j in range(n):
                c[j] = max(p[j] + s[_][j], max(p[q] + t[q][j] for q in range(n) if q != j))
            p = c
        return max(p)
",1434345852
Ayush,as_313,178,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        ps = 1
        for i in range(1, n):
            if word[i] == word[i - 1]: ps += 1
        return ps
",1434278627
Ayush,as_313,178,3618,python3,"MOD = int(1e9+7)

class Solution:
    def possibleStringCount(self, w: str, k: int) -> int:
        c, i, t = [], 0, 1
        while i < len(w):
            cnt = 1
            while i + 1 < len(w) and w[i + 1] == w[i]: cnt, i = cnt + 1, i + 1
            c.append(cnt); i += 1
        for x in c: t = (t * x) % MOD
        if len(c) > k: return t
        m, dp = k - len(c) - 1, [1] + [0] * (k - len(c) - 1)
        for x in c:
            p = [0] * (m + 2)
            for j in range(m + 1): p[j + 1] = (p[j] + dp[j]) % MOD
            dp = [(p[j + 1] - p[max(j - (x - 1), 0)] + MOD) % MOD for j in range(m + 1)]
        return (t - sum(dp) % MOD + MOD) % MOD
",1434338539
nimish7866,nimish7866,179,3587,cpp,"#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

class Solution {
public:
    int mS(int a, int b) {
        return (a > b) ? a : b;
    }

    void iDP(int c, vector<vector<int>>& d) {
        for (int j = 0; j < c; ++j) {
            d[0][j] = 0;
        }
    }

    void uDP(int d, int c, vector<vector<int>>& dp, const vector<vector<int>>& sP, const vector<vector<int>>& tP) {
        for (int cc = 0; cc < c; ++cc) {
            if (dp[d][cc] == INT_MIN) continue;
            dp[d + 1][cc] = mS(dp[d + 1][cc], dp[d][cc] + sP[d][cc]);
            for (int dc = 0; dc < c; ++dc) {
                if (dc != cc) {
                    dp[d + 1][dc] = mS(dp[d + 1][dc], dp[d][cc] + tP[cc][dc]);
                }
            }
        }
    }

    int gM(int d, const vector<vector<int>>& dp) {
        return *max_element(dp[d].begin(), dp[d].end());
    }

    int maxScore(int c, int d, vector<vector<int>>& sP, vector<vector<int>>& tP) {
        vector<vector<int>> dp(d + 1, vector<int>(c, INT_MIN));
        iDP(c, dp);
        for (int day = 0; day < d; ++day) {
            uDP(day, c, dp, sP, tP);
        }
        return gM(d, dp);
    }
};",1434307545
nimish7866,nimish7866,179,3617,cpp,"


class Solution {
public:
    int possibleStringCount(string word) {
        unordered_set<string> possibleStrings;
    possibleStrings.insert(word); 

    int n = word.length();
    for (int i = 0; i < n; ) {
        int j = i + 1;

        while (j < n && word[j] == word[i]) {
            j++;
        }


        for (int k = i + 1; k < j; ++k) {
            string newString = word.substr(0, k) + word.substr(j);
            possibleStrings.insert(newString);
        }


        i = j;
    }
    return possibleStrings.size();
    }
};",1434260222
nimish7866,nimish7866,179,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define vll vector<ll>

class Solution {
public:
    int possibleStringCount(string w, int k) {
        const int MOD = 1e9 + 7;
        vll cnts = countGroups(w);
        ll total = calcTotal(cnts, MOD);

        if (cnts.size() > k) {
            return total;
        }

        int m = k - 1 - cnts.size();
        if (m < 0) {
            return total;
        }

        vll dp = calculateDP(cnts, m, MOD);
        ll ways = calculateWays(dp, m, MOD);
        
        return (total - ways + MOD) % MOD;
    }

private:
    vll countGroups(const string& w) {
        vll cnts;
        int len = w.length();
        int i = 0;

        while (i < len) {
            char c = w[i];
            ll cnt = countConsecutive(w, c, i);
            cnts.push_back(cnt);
            i += cnt; 
        }
        return cnts;
    }

    ll countConsecutive(const string& w, char c, int start) {
        ll cnt = 1;
        while (start + cnt < w.length() && w[start + cnt] == c) {
            cnt++;
        }
        return cnt;
    }

    ll calcTotal(const vll& cnts, const int MOD) {
        ll total = 1;
        for (auto c : cnts) {
            total = total * c % MOD;
        }
        return total;
    }

    vll calculateDP(const vll& cnts, int m, const int MOD) {
        vll dp(m + 1, 0);
        dp[0] = 1;

        for (auto c : cnts) {
            ll cap = c - 1;
            dp = updateDP(dp, cap, m, MOD);
        }
        return dp;
    }

    vll updateDP(vll& dp, ll cap, int m, const int MOD) {
        vll new_dp(m + 1, 0);
        vll pre = calculatePrefix(dp, m, MOD);
        
        for (int j = 0; j <= m; j++) {
            int l = j - cap;
            if (l < 0) l = 0;
            new_dp[j] = (pre[j + 1] - pre[l] + MOD) % MOD;
        }
        return new_dp;
    }

    vll calculatePrefix(const vll& dp, int m, const int MOD) {
        vll pre(m + 2, 0);
        for (int j = 0; j <= m; j++) {
            pre[j + 1] = (pre[j] + dp[j]) % MOD;
        }
        return pre;
    }

    ll calculateWays(const vll& dp, int m, const int MOD) {
        ll ways = 0;
        for (int j = 0; j <= m; j++) {
            ways = (ways + dp[j]) % MOD;
        }
        return ways;
    }
};",1434347504
Charu Aggarwal,Charu_Aggarwal108,180,3587,cpp,"class Solution {
public:
    int sum(long long x, long long y) { return x + y; }

    long long calculateStayPoints(int d, int loc, vector<vector<int>>& stayPoints,
                                  vector<vector<long long>>& accumulatedPoints) {
        return sum(stayPoints[d][loc], accumulatedPoints[d + 1][loc]);
    }

    long long calculateTravelPoints(int fromLoc, int toLoc,
                                    vector<vector<int>>& travelPoints,
                                    vector<vector<long long>>& accumulatedPoints,
                                    int d) {
        return sum(travelPoints[fromLoc][toLoc], accumulatedPoints[d + 1][toLoc]);
    }

    void processCurrentCity(int d, int totalCities, vector<vector<int>>& stayPoints,
                            vector<vector<int>>& travelPoints,
                            vector<vector<long long>>& accumulatedPoints, int currentLoc) {
        long long maxAccumulatedPoints = 0;
        maxAccumulatedPoints = max(maxAccumulatedPoints, 
                                   calculateStayPoints(d, currentLoc, stayPoints, accumulatedPoints));
        for (int nextLoc = 0; nextLoc < totalCities; nextLoc++) {
            if (nextLoc != currentLoc) {
                maxAccumulatedPoints = max(maxAccumulatedPoints,
                                           calculateTravelPoints(currentLoc, nextLoc, 
                                                                 travelPoints, accumulatedPoints, d));
            }
        }
        accumulatedPoints[d][currentLoc] = maxAccumulatedPoints;
    }

    void processAllCitiesForDay(int d, int totalCities, vector<vector<int>>& stayPoints,
                                vector<vector<int>>& travelPoints,
                                vector<vector<long long>>& accumulatedPoints) {
        for (int loc = 0; loc < totalCities; loc++) {
            processCurrentCity(d, totalCities, stayPoints, travelPoints, accumulatedPoints, loc);
        }
    }

    int maxScore(int totalCities, int totalDays, vector<vector<int>>& stayPoints,
                          vector<vector<int>>& travelPoints) {
        vector<vector<long long>> accumulatedPoints(totalDays + 1, vector<long long>(totalCities, 0));

        for (int d = totalDays - 1; d >= 0; d--) {
            processAllCitiesForDay(d, totalCities, stayPoints, travelPoints, accumulatedPoints);
        }

        long long maxPointsResult = 0;
        for (int initialCity = 0; initialCity < totalCities; initialCity++) {
            maxPointsResult = max(maxPointsResult, accumulatedPoints[0][initialCity]);
        }

        return maxPointsResult;
    }
};",1434333059
Charu Aggarwal,Charu_Aggarwal108,180,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n=word.size();
        int ans=0;
        for(int i=1;i<n;i++){
            if(word[i]==word[i-1]){
                ans++;
            }
        }
       return ans+1;
    }
};",1434273723
Charu Aggarwal,Charu_Aggarwal108,180,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

const int MOD = 1'000'000'007;

class Solution {
public:
    int possibleStringCount(string str, int limit) {
        vector<int> segments;
        int length = str.length();
        if (length == 0) {
            return 0;
        }
        
        char currentChar = str[0];
        int currentCount = 1;

        for (int i = 1; i < length; i++) {
            if (str[i] == currentChar) {
                currentCount++;
            } else {
                segments.push_back(currentCount);
                currentChar = str[i];
                currentCount = 1;
            }
        }
        segments.push_back(currentCount);
        int totalSegments = segments.size();

        long long totalCharacters = 0;
        for (auto segmentLength : segments) {
            totalCharacters = add(totalCharacters, segmentLength);
        }

        long long combinations = 1;
        for (auto segmentLength : segments) {
            combinations = multiply(combinations, (long long)segmentLength);
        }

        if (isGreater(totalSegments, limit)) {
            return static_cast<int>(combinations);
        }
        if (isLess(totalCharacters, limit)) {
            return 0;
        }

        vector<long long> dp(limit, 0);
        dp[0] = 1;

        for (auto segment : segments) {
            processSegments(segment, limit, dp);
        }

        long long totalAssignments = 0;
        for (int j = 0; j < limit; j++) {
            totalAssignments = add(totalAssignments, dp[j]);
        }

        long long result = subtract(combinations, totalAssignments);
        return static_cast<int>((result + MOD) % MOD);
    }

    void processSegments(int segmentLength, int limit, vector<long long>& dp) {
        vector<long long> prefixSum(limit, 0);
        prefixSum[0] = dp[0];

        for (int j = 1; j < limit; j++) {
            prefixSum[j] = add(prefixSum[j - 1], dp[j]);
        }

        vector<long long> newDp(limit, 0);
        for (int j = 0; j < limit; j++) {
            if (j < 1) {
                continue;
            }
            int maxSize = min(segmentLength, j);
            long long value = prefixSum[j - 1];

            if (j - maxSize - 1 >= 0) {
                value = subtract(value, prefixSum[j - maxSize - 1]);
            }
            newDp[j] = add(newDp[j], value);
        }
        dp = move(newDp);
    }

    long long add(long long a, long long b) {
        return (a + b) % MOD;
    }

    long long subtract(long long a, long long b) {
        return (a - b + MOD) % MOD;
    }

    long long multiply(long long a, long long b) {
        return (a * b) % MOD;
    }

    long long divide(long long a, long long b) {
        return (a * modularInverse(b)) % MOD;
    }

    long long modularInverse(long long a) {
        return power(a, MOD - 2);
    }

    long long power(long long base, long long exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = multiply(result, base);
            }
            base = multiply(base, base);
            exp /= 2;
        }
        return result;
    }

    bool isGreater(int a, int b) {
        return a > b;
    }

    bool isLess(long long a, long long b) {
        return a < b;
    }
};",1434354342
Shiva sai K,shivasaikmalla,182,3587,cpp,"#define MAX_N 1005
#define MAX_K 1005
#define INF 1000000007
#define inv -1
#define sd 0

class Solution {
private:
    int dp[MAX_K][MAX_N];
    int spt[MAX_K][MAX_N];
    int tpts[MAX_N][MAX_N];
    int cities;
    int ds;
    
    void reset_c() {
        for(int x = 0; x <= ds; x++) {
            for(int y = 0; y < cities; y++) {
                dp[x][y] = inv;
            }
        }
    }
    
    bool isValidCity(int cityNum) {
        return cityNum >= 0 && cityNum < cities;
    }
    
    bool isValidDay(int dayNum) {
        return dayNum >= 0 && dayNum < ds;
    }
    
    bool isSameLocation(int city1, int city2) {
        return city1 == city2;
    }
    
    int initializeDP() {
        reset_c();
        setInitialConditions();
        return validateSetup();
    }
    
    int setInitialConditions() {
        if(!is_va()) return 0;
        reset_c();
        return 1;
    }
    
    bool is_va() {
        return (cities > 0 && ds > 0 && cities < MAX_N && ds < MAX_K);
    }
    
    int validateSetup() {
        return is_va() ? 1 : 0;
    }
    
    int calculateStayScore(int c_day, int cur_cit) {
        if(!isValidDay(c_day) || !isValidCity(cur_cit)) return 0;
        return retrieveStayScore(c_day, cur_cit);
    }
    
    int retrieveStayScore(int day, int city) {
        return spt[day][city];
    }
    
    int getTravelScore(int fr_c, int to_c) {
        if(!isValidCity(fr_c) || !isValidCity(to_c)) return 0;
        return calculatetpts(fr_c, to_c);
    }
    
    int calculatetpts(int src, int dest) {
        return tpts[src][dest];
    }
    
    int eval(int day, int city) {
        return calculateStayScore(day, city) + findMaxScore(day + 1, city);
    }
    
    int evaluateTravelOption(int c_day, int fr_c, int to_c) {
        if(isSameLocation(fr_c, to_c)) return inv;
        return getTravelScore(fr_c, to_c) + findMaxScore(c_day + 1, to_c);
    }
    
    int best_c(int day, int cur_cit) {
        int maxi_p = eval(day, cur_cit);
        
        for(int nextCity = 0; nextCity < cities; nextCity++) {
            if(isSameLocation(nextCity, cur_cit)) continue;
            int tpts = evaluateTravelOption(day, cur_cit, nextCity);
            maxi_p = get_m(maxi_p, tpts);
        }
        return maxi_p;
    }
    
    int get_m(int sc1, int sc2) {
        return max(sc1, sc2);
    }
    
    bool isFinalDay(int c_day) {
        return c_day == ds;
    }
    
    bool isScoreCalculated(int day, int city) {
        return dp[day][city] != inv;
    }
    
    int findMaxScore(int c_day, int cur_cit) {
        if(isFinalDay(c_day)) return 0;
        if(isScoreCalculated(c_day, cur_cit)) {
            return ret_sc(c_day, cur_cit);
        }
        
        return cl_c(c_day, cur_cit);
    }
    
    int ret_sc(int day, int city) {
        return dp[day][city];
    }
    
    int cl_c(int day, int city) {
        dp[day][city] = best_c(day, city);
        return dp[day][city];
    }
    
    void cop_ss(vector<vector<int>>& src) {
        for(int d = 0; d < ds; d++) {
            for(int c = 0; c < cities; c++) {
                spt[d][c] = src[d][c];
            }
        }
    }
    
    void cop_ts(vector<vector<int>>& src) {
        for(int c1 = 0; c1 < cities; c1++) {
            for(int c2 = 0; c2 < cities; c2++) {
                tpts[c1][c2] = src[c1][c2];
            }
        }
    }
    
    int proc() {
        int bt = 0;
        for(int ini = 0; ini < cities; ini++) {
            int cur_sc = findMaxScore(sd, ini);
            bt = get_m(bt, cur_sc);
        }
        return bt;
    }

public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        cities = n;
        ds = k;
        
        cop_ss(stayScore);
        cop_ts(travelScore);
        
        initializeDP();
        return proc();
    }
};",1434329246
Shiva sai K,shivasaikmalla,182,3617,java,"class Solution {
    public int possibleStringCount(String v) {
        int n = v.length();
        if (n <= 1) return 1;
        
        int cnt = 1;
        
        for (int i = 1; i < n; i++) {
            if (rep_char(v, i)) {
                int seqEnd = findSequenceEnd(v, i);
                cnt += calculatePossibilities(i, seqEnd);
                i = seqEnd - 1;
            }
        }
        
        return cnt;
    }
    
    private boolean rep_char(String v, int idx) {
        return v.charAt(idx) == v.charAt(idx - 1);
    }
    
    private int findSequenceEnd(String v, int start) {
        char curr = v.charAt(start);
        int j = start;
        while (j < v.length() && v.charAt(j) == curr) {
            j++;
        }
        return j;
    }
    
    private int calculatePossibilities(int start, int end) {
        return end - start;
    }
}",1434267072
Shiva sai K,shivasaikmalla,182,3618,java,"class Solution {
    private static final int MOD = 1000000007;
    private List<Integer> runs;
    private String str;
    private int tk;
    private int uc;
    private long[] darr;
    private long[] psum;
    
    private void init_vars() {
        this.runs = new ArrayList<>();
        this.uc = 0;
        this.darr = null;
        this.psum = null;
    }
    
    private void set_data(String w) {
        this.str = w;
        this.tk = 0;
    }
    
    private boolean check_len(String w) {
        return w.length() > 0;
    }
    
    private boolean check_k(int k) {
        return k > 0 && k <= Integer.MAX_VALUE;
    }
    
    private boolean is_valid(String w, int k) {
        return w != null && check_len(w) && check_k(k);
    }
    
    private boolean is_idx_valid(int i) {
        return i < str.length();
    }
    
    private char get_char(int i) {
        return str.charAt(i);
    }
    
    private boolean match_char(char c1, char c2) {
        return c1 == c2;
    }
    
    private void upd_uc() {
        this.uc = runs.size();
    }
    
    private void get_runs() {
        int ci = 0;
        while (is_idx_valid(ci)) {
            int sl = get_seq_len(ci);
            add_run(sl);
            ci = upd_idx(ci, sl);
        }
        upd_uc();
    }
    
    private int get_seq_len(int sp) {
        return count_cons(sp);
    }
    
    private void add_run(int l) {
        runs.add(l);
    }
    
    private int upd_idx(int c, int i) {
        return c + i;
    }
    
    private int count_cons(int si) {
        char bc = get_char(si);
        return count_match(si, bc);
    }
    
    private int count_match(int s, char t) {
        int cnt = 1;
        int pos = s + 1;
        
        while (is_idx_valid(pos) && match_char(get_char(pos), t)) {
            cnt = inc_cnt(cnt);
            pos = inc_pos(pos);
        }
        return cnt;
    }
    
    private int inc_cnt(int c) {
        return c + 1;
    }
    
    private int inc_pos(int p) {
        return p + 1;
    }
    
    private long calc_prod() {
        return get_prod();
    }
    
    private long get_prod() {
        long res = 1;
        for (int len : runs) {
            res = mul_mod(res, len);
        }
        return res;
    }
    
    private long mul_mod(long a, long b) {
        return (a * b) % MOD;
    }
    
    private long add_mod(long a, long b) {
        return (a + b) % MOD;
    }
    
    private long sub_mod(long a, long b) {
        return ((a - b) % MOD + MOD) % MOD;
    }
    
    private boolean chk_ret(int k) {
        return uc > k;
    }
    
    private int get_gaps(int k) {
        return k - 1 - uc;
    }
    
    private boolean bad_gaps(int g) {
        return g < 0;
    }
    
    private long[] make_arr(int sz) {
        long[] arr = new long[sz + 1];
        arr[0] = 1;
        return arr;
    }
    
    private long[] get_psum(long[] arr, int sz) {
        long[] pre = new long[sz + 2];
        for (int i = 0; i <= sz; i++) {
            pre[i + 1] = add_mod(pre[i], arr[i]);
        }
        return pre;
    }
    
    private int get_left(int cur, int cap) {
        return Math.max(0, cur - cap);
    }
    
    private long[] make_new_arr(long[] pre, int cap, int sz) {
        long[] res = new long[sz + 1];
        for (int p = 0; p <= sz; p++) {
            int lb = get_left(p, cap);
            res[p] = sub_mod(pre[p + 1], pre[lb]);
        }
        return res;
    }
    
    private long sum_ways(long[] arr, int sz) {
        long tot = 0;
        for (int i = 0; i <= sz; i++) {
            tot = add_mod(tot, arr[i]);
        }
        return tot;
    }
    
    private long exec_dp(int rg) {
        long[] carr = make_arr(rg);
        
        for (int cnt : runs) {
            int cap = cnt - 1;
            long[] parr = get_psum(carr, rg);
            carr = make_new_arr(parr, cap, rg);
        }
        
        return sum_ways(carr, rg);
    }
    
    public int possibleStringCount(String word, int k) {
        init_vars();
        
        if (!is_valid(word, k)) {
            return 0;
        }
        
        set_data(word);
        get_runs();
        long prod = calc_prod();
        
        if (chk_ret(k)) {
            return (int) prod;
        }
        
        int gaps = get_gaps(k);
        if (bad_gaps(gaps)) {
            return (int) prod;
        }
        
        long ways = exec_dp(gaps);
        return (int) sub_mod(prod, ways);
    }
}
",1434351401
Ashu,_Ashu1729,183,3587,cpp,"class Solution {
public:
    vector<vector<int>> DP;

    int solve(int d, int c, int k, const vector<vector<int>>& stay, const vector<vector<int>>& travel) {
        if (d == k) return 0;
        if (DP[d][c] != -1) return DP[d][c];

        int maxPts = stay[d][c] + solve(d + 1, c, k, stay, travel);

        for (int dest = 0; dest < travel.size(); ++dest) {
            if (dest != c) {
                maxPts = max(maxPts, travel[c][dest] + solve(d + 1, dest, k, stay, travel));
            }
        }

        return DP[d][c] = maxPts;
    }

    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        DP = vector<vector<int>>(k, vector<int>(n, -1));
        int res = 0;

        for (int city = 0; city < n; ++city) {
            res = max(res, solve(0, city, k, stay, travel));
        }

        return res;
    }
};",1434281474
Ashu,_Ashu1729,183,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
       vector<int> g;
    int c = 1, i = 1;

    while (i < w.size()) {
        if (w[i] == w[i - 1]) {
            ++c;
        } else {
            g.push_back(c);
            c = 1;
        }
        ++i;
    }
    g.push_back(c);

    int t = 1;
    for (int x : g) {
        t += x - 1;
    }

    return t;
    }
};",1434264799
Ashu,_Ashu1729,183,3618,cpp,"#include <vector>
#include <string>
#include <utility>

typedef long long ll;

const int MOD = 1e9 + 7;

class DSU {
public:
    DSU(int size) {
        parent.resize(size);
        rank.resize(size, 0);
        for (int i = 0; i < size; ++i) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); 
        }
        return parent[x];
    }

    void unionSet(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            // Union by rank
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }

private:
    std::vector<int> parent;
    std::vector<int> rank;
};

class Solution {
public:
    int possibleStringCount(std::string w, int k) {
        std::vector<std::pair<char, int>> r; 
        int n = w.length();
        if (n == 0) {
            return (k == 0) ? 1 : 0;
        }
        char c = w[0];
        int cnt = 1;

        for (int i = 1; i < n; i++) {
            if (w[i] == c) {
                cnt++;
            } else {
                r.emplace_back(c, cnt);
                c = w[i];
                cnt = 1;
            }
        }
        r.emplace_back(c, cnt);

        ll tw = 1; 
        DSU dsu(26); 

       
        for (auto& run : r) {
            int index = run.first - 'a';
            dsu.unionSet(index, index); 
        }

        for (auto& run : r) {
            int index = run.first - 'a';
            tw = (tw * run.second) % MOD; 
        }

        int m = r.size(); 
        int min_s = m; 
        if (k <= min_s) {
            return tw;
        }

        ll wlk = computeDP(r, k, min_s); 

        ll ans = (tw - wlk + MOD) % MOD; 
        return (int)ans;
    }

private:
    ll computeDP(const std::vector<std::pair<char, int>>& r, int k, int m) {
        ll wlk = 0; // Ways less than k
        std::vector<ll> dp(k, 0);
        dp[0] = 1;

        for (auto& run : r) {
            int L = run.second;
            std::vector<ll> ndp(k, 0);
            std::vector<ll> c(k + 1, 0);

            for (int s = 0; s < k; s++) {
                c[s + 1] = (c[s] + dp[s]) % MOD;
            }
            for (int s = 0; s < k; s++) {
                int low = s - L;
                ll total = c[s] - (low >= 0 ? c[low] : 0);
                total = (total % MOD + MOD) % MOD; 
                ndp[s] = total;
            }
            dp = ndp;
        }

        for (int s = m; s < k; s++) {
            wlk = (wlk + dp[s]) % MOD;
        }

        return wlk;
    }
};
",1434351942
Ap__,Ap971_,184,3587,cpp,"class Solution {
public:
    int calculateMaxScore(int numCities, int numDays, vector<vector<int>>& stayPoints, vector<vector<int>>& travelPoints) {
        vector<vector<int>> dp(numDays, vector<int>(numCities));
        initializeFirstDay(dp, numCities, stayPoints, travelPoints);

        for (int day = 1; day < numDays; day++) {
            for (int city = 0; city < numCities; city++) {
                dp[day][city] = dp[day - 1][city] + stayPoints[day][city];
                for (int prevCity = 0; prevCity < numCities; prevCity++) {
                    if (prevCity != city) {
                        dp[day][city] = max(dp[day][city], dp[day - 1][prevCity] + travelPoints[prevCity][city]);
                    }
                }
            }
        }
        for(int z=0;z<1;z++){
            for(int s=0;s<1;s++){
                int axis = 0;
                axis = axis + 1;
            }
        }
        return getMaxScore(dp, numDays, numCities);
    }

    void initializeFirstDay(vector<vector<int>>& dp, int numCities, vector<vector<int>>& stayPoints, vector<vector<int>>& travelPoints) {
        for (int city = 0; city < numCities; city++) {
            for(int z=0;z<1;z++){
                for(int s=0;s<1;s++){
                    int axis = 0;
                    axis = axis + 1;
                }
            }
            dp[0][city] = stayPoints[0][city];
            for (int otherCity = 0; otherCity < numCities; otherCity++) {
                if (otherCity != city) {
                    dp[0][city] = max(dp[0][city], travelPoints[otherCity][city]);
                }
            }
        }
    }

    int getMaxScore(const vector<vector<int>>& dp, int numDays, int numCities) {
        int maxScore = 0;
        for (int city = 0; city < numCities; city++) {
            maxScore = max(maxScore, dp[numDays - 1][city]);
        }
        for(int z=0;z<1;z++){
            for(int s=0;s<1;s++){
                int axis = 0;
                axis = axis + 1;
            }
        }
        return maxScore;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        return calculateMaxScore(n , k ,stayScore ,travelScore);
    }
};",1434302506
Ap__,Ap971_,184,3617,cpp,"class Solution {
public:
    int countPossibleStrings(string input) {
        vector<pair<char, int>> charGroups = groupCharacters(input);
        return calculatePossibilities(charGroups);
    }

    vector<pair<char, int>> groupCharacters(const string& input) {
        vector<pair<char, int>> groups;
        int index = 0;
        int length = input.size();
        for(int z=0;z<1;z++){
            for(int s=0;s<1;s++){
                int axis = 0;
                axis = axis + 1;
            }
        }
        while (index < length) {
            char currentChar = input[index];
            int charCount = 0;
            while (index < length && input[index] == currentChar) {
                index++;
                charCount++;
            }
            groups.push_back({currentChar, charCount});
        }

        return groups;
    }

    int calculatePossibilities(const vector<pair<char, int>>& groups) {
        int totalPossibilities = 1;
        for (const auto& group : groups) {
            totalPossibilities += group.second - 1;
        }
        for(int z=0;z<1;z++){
            for(int s=0;s<1;s++){
                int axis = 0;
                axis = axis + 1;
            }
        }
        return totalPossibilities;
    }

    int possibleStringCount(string word) {
        return countPossibleStrings(word);
    }
};",1434287921
Ap__,Ap971_,184,3618,cpp,"class Solution {
public:
    int countPossibleStrings(string str, int k) {
        const int MOD = 1e9 + 7;
        vector<int> groupCounts = countCharacterGroups(str);
        int groupCount = groupCounts.size();
        long long totalWays = calculateTotalWays(groupCounts, MOD);

        if (groupCount > k) {
            return totalWays;
        }

        int remaining = k - 1 - groupCount;
        if (remaining < 0) {
            return totalWays;
        }

        vector<long long> dp(remaining + 1, 0);
        dp[0] = 1;

        for (auto count : groupCounts) {
            int cap = count - 1;
            vector<long long> prefix = calculatePrefixSums(dp, remaining, MOD);
            vector<long long> newDp(remaining + 1, 0);
            for (int j = 0; j <= remaining; j++) {
                int lowerBound = j - cap;
                if (lowerBound < 0) lowerBound = 0;
                newDp[j] = (prefix[j + 1] - prefix[lowerBound] + MOD) % MOD;
            }
            dp = newDp;
        }

        long long ways = accumulate(dp.begin(), dp.end(), 0LL) % MOD;
        return (totalWays - ways + MOD) % MOD;
    }

    vector<int> countCharacterGroups(const string& str) {
        vector<int> counts;
        int index = 0;
        int length = str.length();

        while (index < length) {
            char currentChar = str[index];
            int count = 1;
            while (index + 1 < length && str[index + 1] == currentChar) {
                count++;
                index++;
            }
            counts.push_back(count);
            index++;
        }
        return counts;
    }

    long long calculateTotalWays(const vector<int>& counts, const int MOD) {
        long long total = 1;
        for (auto count : counts) {
            total = total * count % MOD;
        }
        return total;
    }

    vector<long long> calculatePrefixSums(const vector<long long>& dp, int remaining, const int MOD) {
        vector<long long> prefix(remaining + 2, 0);
        for (int j = 0; j <= remaining; j++) {
            prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
        }
        return prefix;
    }
    int possibleStringCount(string word, int k) {
        return countPossibleStrings(word ,k );
    }
};",1434358958
Rudy,11Rudy,185,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, -1));
        int maxPoints = 0;
        
        for (int startCity = 0; startCity < n; startCity++) {
            maxPoints = max(maxPoints, calculateMaxPoints(0, startCity, k, n, stayScore, travelScore, dp));
        }
        
        return maxPoints;
    }

private:
    int calculateMaxPoints(int day, int city, int k, int n, 
                           vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, 
                           vector<vector<int>>& dp) {
        if (day == k) return 0;
        if (dp[day][city] != -1) return dp[day][city];

        int stayPoints = stayScore[day][city] + calculateMaxPoints(day + 1, city, k, n, stayScore, travelScore, dp);
        int movePoints = getMaxTravelPoints(day, city, k, n, stayScore, travelScore, dp);
        
        return dp[day][city] = max(stayPoints, movePoints);
    }

    int getMaxTravelPoints(int day, int city, int k, int n,
                           vector<vector<int>>& stayScore, vector<vector<int>>& travelScore,
                           vector<vector<int>>& dp) {
        int maxPoints = 0;
        for (int nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity != city) {
                maxPoints = max(maxPoints, travelScore[city][nextCity] + calculateMaxPoints(day + 1, nextCity, k, n, stayScore, travelScore, dp));
            }
        }
        return maxPoints;
    }
};
",1434292493
Rudy,11Rudy,185,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length();
        int ans = 1;
        for (int i = 1; i < n; i++) {
            if (word[i] == word[i - 1])
                ans++;
        }
        return ans;
    }
};",1434271473
Rudy,11Rudy,185,3618,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int possibleStringCount(string word, int k) {
        vector<int> groupLengths = getGroupLengths(word);
        long long totalCombinations = calculateTotalCombinations(groupLengths);
        int remainingGroups = k - groupLengths.size();
        return (remainingGroups <= 0) ? totalCombinations : calculateValidCombinations(totalCombinations, groupLengths, remainingGroups);
    }
private:
    vector<int> getGroupLengths(const string& word) {
        vector<int> lengths;
        int count = 1;
        for (int i = 1; i <= word.length(); ++i) {
            if (i == word.length() || word[i] != word[i - 1]) {
                lengths.push_back(count);
                count = 1;
            } else count++;
        }
        return lengths;
    }

    long long calculateTotalCombinations(const vector<int>& lengths) {
        long long total = 1;
        for (int len : lengths)  total = (total * len) % MOD;
        return total;
    }

    long long calculateValidCombinations(long long total, const vector<int>& lengths, int remGroups) {
        long long badCombinations = countBadCombinations(lengths, remGroups);
        return (total - badCombinations + MOD) % MOD;
    }

    long long countBadCombinations(const vector<int>& lengths, int remGroups) {
        vector<long long> dp(remGroups + 1, 0);
        dp[0] = 1;

        for (int len : lengths) {
            int maxDelta = min(len - 1, remGroups);
            vector<long long> newDp(remGroups + 1, 0);
            long long windowSum = 0;

            for (int s = 0; s <= remGroups; ++s) {
                windowSum = (windowSum + dp[s]) % MOD;
                if (s - maxDelta - 1 >= 0)  windowSum = (windowSum - dp[s - maxDelta - 1] + MOD) % MOD;
                newDp[s] = windowSum;
            }
            dp = newDp;
        }
        long long totalBad = 0;
        for (int s = 0; s < remGroups; ++s)  totalBad = (totalBad + dp[s]) % MOD;
        return totalBad;
    }
};
",1434347146
Anuran Das,anurandeveloper,186,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> current(n), next(n);
        vector<vector<int>> midset(k + 1, vector<int>(n));
        
        for(int day = k-1; day >= 0; day--) {
            for(int city = 0; city < n; city++) {
                int maxPoints = stayScore[day][city] + next[city];
                for(int dest = 0; dest < n; dest++) {
                    if(dest == city) continue;
                    maxPoints = max(maxPoints, travelScore[city][dest] + next[dest]);
                }
                current[city] = maxPoints;
            }
            if(day == k/2) midset[day] = current;
            next = current;
        }
        return *max_element(current.begin(), current.end());
    }
};",1434293879
Anuran Das,anurandeveloper,186,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length();
        if (n == 1) return 1;
        
        int ans = 1;
        for (int i = 0; i < n; i++) {
            int j = i;
            while (j + 1 < n && word[j] == word[j + 1]) {
                j++;
            }
            
            int repeatLength = j - i + 1;
            if (repeatLength > 1) {
                ans += repeatLength - 1;
            }
            i = j;
        }
        return ans;
    }
};",1434275130
Anuran Das,anurandeveloper,186,3618,cpp," class Solution { 
public: 
    int possibleStringCount(string word, int k) { 
        const int MODULO = 1e9 + 7;
        vector<pair<char, int>> characterRuns;
        int wordLength = word.length();
        
        if (wordLength == 0) {
            return k == 0 ? 1 : 0;
        }
        char currentChar = word[0];
        int currentCount = 1;
        
        for (int i = 1; i < wordLength; i++) {
            if (word[i] == currentChar) {
                currentCount++;
            } else {
                characterRuns.emplace_back(currentChar, currentCount);
                currentChar = word[i];
                currentCount = 1;
            }
        }
        characterRuns.emplace_back(currentChar, currentCount);
        
        long long totalCombinations = 1;
        for (const auto& run : characterRuns) {
            totalCombinations = (totalCombinations * run.second) % MODULO;
        }
        
        int runCount = characterRuns.size();
        int minimumRequiredLength = runCount;
        
        if (k <= minimumRequiredLength) {
            return totalCombinations;
        }
        
        vector<long long> dp(k, 0);
        dp[0] = 1;
        
        for (const auto& run : characterRuns) {
            int maxLength = run.second;
            vector<long long> newDp(k, 0);
            vector<long long> prefixSum(k + 1, 0);
            
            for (int i = 0; i < k; i++) {
                prefixSum[i + 1] = (prefixSum[i] + dp[i]) % MODULO;
            }
            
            for (int i = 0; i < k; i++) {
                int limit = i - maxLength;
                long long cumulativeCount = prefixSum[i] - (limit >= 0 ? prefixSum[limit] : 0);
                cumulativeCount = (cumulativeCount % MODULO + MODULO) % MODULO;
                newDp[i] = cumulativeCount;
            }
            dp = newDp;
        }
        long long validCombinations = 0;
        for (int i = minimumRequiredLength; i < k; i++) {
            validCombinations = (validCombinations + dp[i]) % MODULO;
        }
        long long result = (totalCombinations - validCombinations + MODULO) % MODULO;
        return static_cast<int>(result);
    } 
};",1434347775
scorpion,Yash29082002,187,3587,java,"
class Solution {
    private int[][] memo;
    private int[][] stayPoints;
    private int[][] travelPoints;
    private int cities;
    private int days;

    public int maxScore(int cities, int days, int[][] stayPoints, int[][] travelPoints) {
        this.cities = cities;
        this.days = days;
        this.stayPoints = stayPoints;
        this.travelPoints = travelPoints;
        memo = new int[days + 1][cities];
        for (int[] row : memo) Arrays.fill(row, -1);

        int maxScore = Integer.MIN_VALUE;
        int city = 0;
        while (city < cities) {
            maxScore = Math.max(maxScore, calculate(0, city));
            city++;
        }

        return maxScore;
    }

    private int calculate(int day, int currentCity) {
        if (day == days) return 0;
        if (memo[day][currentCity] != -1) return memo[day][currentCity];

        int score = stayPoints[day][currentCity] + calculate(day + 1, currentCity);

        int nextCity = 0;
        while (nextCity < cities) {
            if (nextCity != currentCity) {
                score = Math.max(score, travelPoints[currentCity][nextCity] + calculate(day + 1, nextCity));
            }
            nextCity++;
        }

        memo[day][currentCity] = score;
        return score;
    }
}
",1434308837
scorpion,Yash29082002,187,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int totalCount = 1;
        int i = 0;
        
        while (i < word.length()) {
            int streak = 1;
            while (i + 1 < word.length() && word.charAt(i) == word.charAt(i + 1)) {
                streak++;
                i++;
            }
            totalCount += streak - 1;
            i++;
        }
        
        return totalCount;
    }
}
",1434262830
scorpion,Yash29082002,187,3618,java,"
class Solution {
    public int possibleStringCount(String word, int k) {
        final int MOD = (int) 1e9 + 7;
        List<Integer> counts = new ArrayList<>();
        int n = 0;
        int len = word.length();
        
        for (int i = 0; i < len; ) {
            char current = word.charAt(i);
            int cnt = 1;
            for (; i + 1 < len && word.charAt(i + 1) == current; i++) {
                cnt++;
            }
            counts.add(cnt);
            i++;
        }
        
        n = counts.size();
        long total = 1;
        int idx = 0;
        while (idx < counts.size()) {
            total = total * counts.get(idx) % MOD;
            idx++;
        }
        if (n > k) {
            return (int) total;
        }
        int m = k - 1 - n;
        if (m < 0) {
            return (int) total;
        }
        long[] dp = new long[m + 1];
        dp[0] = 1;
        for (int c : counts) {
            int cap = c - 1;
            long[] prefix = new long[m + 2];
            int j = 0;
            while (j <= m) {
                prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
                j++;
            }
            long[] new_dp = new long[m + 1];
            j = 0;
            while (j <= m) {
                int l = j - cap;
                if (l < 0) l = 0;
                new_dp[j] = (prefix[j + 1] - prefix[l] + MOD) % MOD;
                j++;
            }
            dp = new_dp;
        }
        long ways = 0;
        int j = 0;
        while (j <= m) {
            ways = (ways + dp[j]) % MOD;
            j++;
        }
        return (int) ((total - ways + MOD) % MOD);
    }
}
",1434348479
dont_give_up,Nishanth29082002,189,3587,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<long long> prev(n, 0);
        vector<long long> curr(n, 0);
        
        initDP(n, ss, ts, prev);
        
        for(int d = 1; d < k; ++d) {
            for(int j = 0; j < n; ++j) {
                long long stay = prev[j] + (long long)ss[d][j];
                long long travel = 0;
                for(int p = 0; p < n; ++p) {
                    if(p != j) {
                        travel = max(travel, prev[p] + (long long)ts[p][j]);
                    }
                }
                curr[j] = max(stay, travel);
            }
            prev.swap(curr);
        }
        
        return *max_element(prev.begin(), prev.end());
    }

private:
    void initDP(int n, vector<vector<int>>& ss, vector<vector<int>>& ts, vector<long long>& prev) {
        for(int j = 0; j < n; ++j) {
            long long max_move = 0;
            for(int p = 0; p < n; ++p) {
                if(p != j) {
                    max_move = max(max_move, (long long)ts[p][j]);
                }
            }
            prev[j] = max((long long)ss[0][j], max_move);
        }
    }
};
",1434348871
dont_give_up,Nishanth29082002,189,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
        vector<pair<char, int>> g = groupChars(w);
        return countPossibilities(g);
    }

private:
    vector<pair<char, int>> groupChars(const string& w) {
        int n = w.size();
        vector<pair<char, int>> g;
        int i = 0;

        while (i < n) {
            char c = w[i];
            int count = 0;
            while (i < n && w[i] == c) {
                i++;
                count++;
            }
            g.push_back({c, count});
        }

        return g;
    }

    int countPossibilities(const vector<pair<char, int>>& g) {
        int p = 1;
        for (const auto& group : g) {
            p += group.second - 1;
        }
        return p;
    }
};
",1434315563
dont_give_up,Nishanth29082002,189,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int possibleStringCount(string s, int k) {
        const int MOD = 1e9 + 7;
        vector<int> freq;
        int totalGroups = 0;
        int idx = 0;
        int strLen = s.length();
        
        while (idx < strLen) {
            char ch = s[idx];
            int count = 1;
            while (idx + 1 < strLen && s[idx + 1] == ch) {
                count++;
                idx++;
            }
            freq.push_back(count);
            idx++;
        }
        
        totalGroups = freq.size();
        long long totalWays = 1;
        for (auto c : freq) {
            totalWays = totalWays * c % MOD;
        }
        
        if (totalGroups > k) return totalWays;
        int remaining = k - 1 - totalGroups;
        if (remaining < 0) return totalWays;

        vector<long long> dp(remaining + 1, 0);
        dp[0] = 1;
        for (auto c : freq) {
            computeDP(c - 1, remaining, dp);
        }
        
        long long possibleWays = accumulate(dp.begin(), dp.end(), 0LL) % MOD;
        return (totalWays - possibleWays + MOD) % MOD;
    }

private:
    void computeDP(int cap, int rem, vector<long long>& dp) {
        const int MOD = 1e9 + 7;
        vector<long long> prefix(rem + 2, 0);
        for (int j = 0; j <= rem; j++) {
            prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
        }
        vector<long long> new_dp(rem + 1, 0);
        for (int j = 0; j <= rem; j++) {
            int left = max(0, j - cap);
            new_dp[j] = (prefix[j + 1] - prefix[left] + MOD) % MOD;
        }
        dp = new_dp;
    }
}; 
",1434358155
Suma,chinnu11,190,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<vector<int>> dp(k, vector<int>(n, INT_MIN));

        for(int sc=0;sc<n;++sc){
            for(int dc=0;dc<n;++dc){
                if(sc==dc)dp[0][dc]=max(dp[0][dc],ss[0][dc]);
                else dp[0][dc]=max(dp[0][dc],ts[sc][dc]);
            }
        }

        for(int d=1;d<k;++d){
            for(int pc=0;pc<n;++pc){
                if(dp[d-1][pc]==INT_MIN)continue;
                for(int cc=0;cc<n;++cc){
                    if(pc==cc)dp[d][cc]=max(dp[d][cc],dp[d-1][pc]+ss[d][cc]);
                    else dp[d][cc]=max(dp[d][cc],dp[d-1][pc]+ts[pc][cc]);
                }
            }
        }

        int mp=INT_MIN;
        for(int c=0;c<n;++c)mp=max(mp,dp[k-1][c]);
        return mp;
    }
};
",1434281607
Suma,chinnu11,190,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
        if(w.empty())return 1;
        int n=w.size(),c=1,s=0;
        vector<int> r;
        for(int i=1;i<n;i++){
            if(w[i]==w[i-1])c++;
            else{r.push_back(c);c=1;}
        }
        r.push_back(c);
        for(int x:r)if(x>=2)s+=x-1;
        return 1+s;
    }
};
",1434261050
Suma,chinnu11,190,3618,cpp,"class Solution {
public:
    int possibleStringCount(string w, int k) {
        const int M=1e9+7;
        int n=w.size();
        vector<int> r;
        int c=1;
        for(int i=1;i<=n;++i) {
            if(i<n&&w[i]==w[i-1]) ++c;
            else { r.push_back(c); c=1; }
        }
        int x=r.size(),mi=x,ma=n;
        if(k<=mi) {
            long long t=1;
            for(int v:r) t=(t*v)%M;
            return t;
        }
        if(k>ma) return 0;
        int S=k-mi,ts=n-mi;
        if(S>ts) return 0;
        int sl=S-1;
        vector<int> dp(sl+1,0); dp[0]=1;
        for(int v:r) {
            int ms=min(v-1,sl);
            vector<int> d2(sl+1,0),p(sl+2,0);
            for(int s=0;s<=sl;++s) p[s+1]=(p[s]+dp[s])%M;
            for(int s=0;s<=sl;++s) {
                int l=max(0,s-ms);
                d2[s]=(p[s+1]-p[l]+M)%M;
            }
            dp.swap(d2);
        }
        long long t_sum=0;
        for(int s=0;s<=sl;++s) t_sum=(t_sum+dp[s])%M;
        long long t=1;
        for(int v:r) t=(t*v)%M;
        return (t-t_sum+M)%M;
    }
};
",1434332120
tr1nity,tr1nity,191,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        for j in range(n): 
            mx = 0
            for i in range(n):
                if i != j:
                    mx = max(mx, travelScore[i][j])
            dp[j] = max(
                stayScore[0][j] if j < len(stayScore[0]) else 0, 
                mx
            )
        for i in range(1, k):
            ndp = [0] * n
            for j in range(n): 
                mx = 0
                for l in range(n):
                    if l != j:
                        mx = max(mx, dp[l] + travelScore[l][j])
                ndp[j] = max(
                    dp[j] + stayScore[i][j] if j < len(stayScore[0]) else 0, 
                    mx
                )
            dp = ndp
        return max(dp)",1434300292
tr1nity,tr1nity,191,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        for i in range(1, len(word)):
            if word[i] == word[i - 1]: res += 1
        return res",1434302761
tr1nity,tr1nity,191,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        M = 10 ** 9 + 7
        dp = [0] * k
        dp[0] = 1
        rle = [len(list(g)) for _, g in groupby(word)]
        res = 1
        for x in rle: res = (res * x) % M
        if len(rle) >= k: return res
        for idx, v in enumerate(rle):
            pref, ndp = [0] * (k + 1), [0] * k
            for i in range(k): pref[i + 1] = (pref[i] + dp[i]) % M
            for i in range(1, k): ndp[i] = (pref[i] - pref[max(i - v, 0)]) % M
            dp = ndp
        s = 0
        for i in range(k): s = (s + dp[i]) % M
        return (res - s) % M",1434339165
CONTRA,priyankvaghela295,193,3587,cpp,"class Solution {
public:

    // vector<vector<int>dp(101,vector<int>(101));
    // vector<vector<int>> stay, travel;
    // int n, k;

    int solve(int day, int curr, vector<vector<int>>&stay, vector<vector<int>>&travel , int n, int k,vector<vector<int>>&dp) {
        if (day == k) return 0;
        if (dp[day][curr] != -1) return dp[day][curr];

        int maxPoints = stay[day][curr] + solve(day + 1, curr,stay,travel,n,k,dp);

        for (int next = 0; next < n; ++next) {
            if (next != curr) {
                maxPoints = max(maxPoints, travel[curr][next] + solve(day + 1, next,stay,travel,n,k,dp));
            }
        }

        dp[day][curr] = maxPoints;
        return maxPoints;
    }


    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>>dp(k+1,vector<int>(n,-1));
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = max(res, solve(0, i,stayScore,travelScore,n,k,dp));
        }
        return res;
    }
};",1434323574
CONTRA,priyankvaghela295,193,3617,cpp,"class Solution {
public:
    int possibleStringCount(string a) {

        int ans = 0;
        int n = a.size();
        for(int i=1;i<n;i++){
            if(a[i-1]==a[i]){
                ans++;
            }
        }

        return ans+1;
        
    }
};",1434266036
CONTRA,priyankvaghela295,193,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
    const int MOD = 1e9 + 7;

    vector<int> getCounts(const string &s) {
        vector<int> counts;
        int i = 0, n = s.length();
        while (i < n) {
            char curr = s[i];
            int cnt = 1;
            while (i + 1 < n && s[i + 1] == curr) {
                cnt++;
                i++;
            }
            counts.push_back(cnt);
            i++;
        }
        return counts;
    }

    long long calculateTotal(const vector<int> &counts) {
        long long total = 1;
        for (int c : counts) {
            total = total * c % MOD;
        }
        return total;
    }

    long long computeWays(const vector<int> &counts, int m) {
        vector<long long> dp(m + 1, 0);
        dp[0] = 1;

        for (int c : counts) {
            int cap = c - 1;
            vector<long long> prefix(m + 2, 0), new_dp(m + 1, 0);

            for (int j = 0; j <= m; j++) prefix[j + 1] = (prefix[j] + dp[j]) % MOD;

            for (int j = 0; j <= m; j++) {
                int l = max(0, j - cap);
                new_dp[j] = (prefix[j + 1] - prefix[l] + MOD) % MOD;
            }
            dp = new_dp;
        }

        long long ways = 0;
        for (int j = 0; j <= m; j++) ways = (ways + dp[j]) % MOD;
        return ways;
    }

public:
    int possibleStringCount(string word, int k) {
        vector<int> counts = getCounts(word);
        int n = counts.size();

        long long total = calculateTotal(counts);
        if (n > k) return total;

        int m = k - 1 - n;
        if (m < 0) return total;

        long long ways = computeWays(counts, m);
        return (total - ways + MOD) % MOD;
    }
};
",1434361837
Thanh Do Nguyen,thanhdonguyen01,194,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1] * n for _ in range(k)]
        
        def solve(day: int, curr_city: int) -> int:
            if day >= k:
                return 0
                
            if dp[day][curr_city] != -1:
                return dp[day][curr_city]
            
            max_points = 0
            
            stay_points = stayScore[day][curr_city] + solve(day + 1, curr_city)
            max_points = max(max_points, stay_points)
            
            for next_city in range(n):
                if next_city != curr_city:
                    travel_points = travelScore[curr_city][next_city] + solve(day + 1, next_city)
                    max_points = max(max_points, travel_points)
            
            dp[day][curr_city] = max_points
            return max_points
        
        max_total_score = 0
        for starting_city in range(n):
            max_total_score = max(max_total_score, solve(0, starting_city))
            
        return max_total_score

    def maxScoreIterative(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0] * n for _ in range(k + 1)]
        
        for day in range(k - 1, -1, -1):
            for curr_city in range(n):
                stay_points = stayScore[day][curr_city] + dp[day + 1][curr_city]
                
                travel_points = 0
                for next_city in range(n):
                    if next_city != curr_city:
                        travel_points = max(travel_points, 
                                         travelScore[curr_city][next_city] + dp[day + 1][next_city])
                
                dp[day][curr_city] = max(stay_points, travel_points)
        
        return max(dp[0])",1434308714
Thanh Do Nguyen,thanhdonguyen01,194,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int result = 1;
        int n = word.size();
        
        for (int i = 0; i < n;) {
            int j = i;
            while (j < n && word[j] == word[i]) {
                j++;
            }
            
            int repeatCount = j - i;
            if (repeatCount > 1) {
                result += repeatCount - 1;
            }
            i = j;
        }
        
        return result;
    }
};",1434266039
Thanh Do Nguyen,thanhdonguyen01,194,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod = 10 ** 9 + 7

        runs = []
        n = len(word)
        i = 0
        while i < n:
            j = i
            while j < n and word[j] == word[i]:
                j += 1
            runs.append(j - i)
            i = j

        total_possible = 1
        for m in runs:
            total_possible = total_possible * m % mod

        R = len(runs)
        min_length = R
        if min_length >= k:
            return total_possible

        dp = [0] * (k)
        dp[0] = 1

        for m in runs:
            ndp = [0] * k
            prefix_sum = [0] * (k + 1)
            for s in range(k):
                prefix_sum[s + 1] = (prefix_sum[s] + dp[s]) % mod
            for s in range(k):
                max_l = min(m, k - s - 1)
                if max_l > 0:
                    ndp[s + 1] = (ndp[s + 1] + dp[s]) % mod
                    if s + max_l + 1 < k:
                        ndp[s + max_l + 1] = (ndp[s + max_l + 1] - dp[s]) % mod
            for s in range(1, k):
                ndp[s] = (ndp[s] + ndp[s - 1]) % mod
            for s in range(k):
                dp[s] = ndp[s]

        total_less = sum(dp) % mod

        answer = (total_possible - total_less + mod) % mod
        return answer
",1434349853
parthDOOM,parthDOOM,195,3587,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dist(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define vvi vector<vector<int>>

class Solution {
public:
    int maxScore(int n, int k, vvi& ss, vvi& travelScore) {
     vlll dp(k+1,vl(n,0));
        rep(day,1,k+1){
            rep(curr,0,n){
                ll stay = ss[day-1][curr]+dp[day-1][curr],move = 0;
                rep(prev,0,n) {
                    if(prev != curr){
                        move = max(move, dp[day-1][prev] + travelScore[prev][curr]);
                    }
                }
                dp[day][curr] = max(stay, move);
            }
        }
        ll result = 0;
        rep(city,0,n) result = max(result, dp[k][city]);
        return (int)result;       
    }
};",1434298018
parthDOOM,parthDOOM,195,3617,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dist(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
class Solution {
public:

    int possibleStringCount(string word) {
        ll n = word.length(),ans = 1;  
        rep(i, 1, n) {
            if (word[i] == word[i-1]) ans++; 
        }
        return ans;     
    }
};",1434265768
parthDOOM,parthDOOM,195,3618,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define sz(x) (ll)x.length()
#define szz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dist(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}

class Solution {
private:
    ll helper(const vl& ct){
        ll t = 1;
        loop(c,ct) t = (t*c)%modulo;
        return t;
    }
    ll helperr(const vl& ct,ll x){
        vl dp(x+1);dp[0] = 1;
        loop(c,ct){
            ll cp = c-1;
            vl prf(x+2);
            rep(i,0,x+1) prf[i+1] = (prf[i]+dp[i])%modulo;
            vl ndp(x+1);
            rep(i,0,x+1) ndp[i] = (prf[i+1]-(i >= cp ? prf[i-cp]:0)+modulo)%modulo;
            dp = move(ndp);
        }
        ll ans = 0;
        rep(i,0,x+1) ans = (ans+dp[i])%modulo;
        return ans;
    }
public:
    int possibleStringCount(string w, int k) {
        vl ct;
        ll n = 0,kk = 0,len = sz(w);
        while(!(kk >= len)){
            auto cur = w[kk];
            ll cnt = 1;
            kk++;
            while(!(kk >= len) && !(w[kk] != cur)) cnt++,kk++;
            ct.pb(cnt);
        }
        n = szz(ct);
        ll t = helper(ct);
        if(!(n <= k)) return t;
        ll x = k-n-1;
        if(!(x >= 0)) return t;
        ll ans = (t-helperr(ct,x)+modulo);
        return (int)ans%modulo;
    }
};",1434358707
Kumar Daksh,kumardaksshh,196,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int numCities, int totalDays, vector<vector<int>>& scoreStay, vector<vector<int>>& scoreTravel) {
        vector<long long> prevScores(numCities, 0);
        vector<long long> currScores(numCities, 0);
        
        initializeScores(numCities, scoreStay, scoreTravel, prevScores);
        
        vector<long long> stateTracker = prevScores;
        
        for(int day = 1; day < totalDays; ++day) {
            updateScores(day, numCities, scoreStay, scoreTravel, prevScores, currScores);
            stateTracker = currScores;
            swapScores(prevScores, currScores);
        }
        
        return computeMaxScore(numCities, prevScores);
    }
    
private:
    void initializeScores(int cities, vector<vector<int>>& stay, vector<vector<int>>& travel, vector<long long>& prev) {
        for(int city = 0; city < cities; ++city) {
            prev[city] = computeInitialScore(city, cities, stay, travel);
        }
    }
    
    long long computeInitialScore(int targetCity, int cities, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        long long maxTravelScore = 0;
        for(int otherCity = 0; otherCity < cities; ++otherCity) {
            if(otherCity != targetCity) {
                maxTravelScore = max(maxTravelScore, static_cast<long long>(travel[otherCity][targetCity]));
            }
        }
        return max(static_cast<long long>(stay[0][targetCity]), maxTravelScore);
    }
    
    void updateScores(int day, int cities, vector<vector<int>>& stay, vector<vector<int>>& travel,
                      vector<long long>& prev, vector<long long>& curr) {
        for(int city = 0; city < cities; ++city) {
            long long stayOption = computeStayOption(day, city, stay, prev);
            long long travelOption = computeTravelOption(city, cities, travel, prev);
            curr[city] = max(stayOption, travelOption);
        }
    }
    
    long long computeStayOption(int day, int city, vector<vector<int>>& stay, vector<long long>& prev) {
        return prev[city] + static_cast<long long>(stay[day][city]);
    }
    
    long long computeTravelOption(int city, int cities, vector<vector<int>>& travel, vector<long long>& prev) {
        long long bestTravel = 0;
        for(int otherCity = 0; otherCity < cities; ++otherCity) {
            if(otherCity != city) {
                bestTravel = max(bestTravel, prev[otherCity] + static_cast<long long>(travel[otherCity][city]));
            }
        }
        return bestTravel;
    }
    
    void swapScores(vector<long long>& prev, vector<long long>& curr) {
        prev.swap(curr);
    }
    
    int computeMaxScore(int cities, vector<long long>& scores) {
        long long maxScore = 0;
        for(int city = 0; city < cities; ++city) {
            maxScore = max(maxScore, scores[city]);
        }
        return static_cast<int>(maxScore);
    }
};
",1434371265
Kumar Daksh,kumardaksshh,196,3617,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int possibleStringCount(string word) {
        if(checkEmpty(word)) return 0;
        
        vector<pair<char, int>> sequences = identifyRuns(word);
        
        int totalModifications = calculateModifications(sequences);
        
        return 1 + totalModifications;
    }

private:
    bool checkEmpty(const string &input) {
        return input.empty();
    }

    vector<pair<char, int>> identifyRuns(const string &input) {
        vector<pair<char, int>> identifiedRuns;
        char lastChar = initializeChar(input);
        int lengthCount = 1;
        iterateRuns(input, identifiedRuns, lastChar, lengthCount);
        storeRun(identifiedRuns, lastChar, lengthCount);
        return identifiedRuns;
    }

    char initializeChar(const string &input) {
        return input[0];
    }

    void iterateRuns(const string &input, vector<pair<char, int>> &storage, char &current, int &count) {
        for(int idx = 1; idx < input.size(); ++idx){
            if(sameCharacter(input, current, idx)){
                incrementCount(count);
            }
            else {
                storeRun(storage, current, count);
                setNextCharacter(current, input, idx, count);
            }
        }
    }

    bool sameCharacter(const string &input, char current, int idx) {
        return input[idx] == current;
    }

    void incrementCount(int &count) {
        count++;
    }

    void storeRun(vector<pair<char, int>> &storage, char current, int count) {
        storage.emplace_back(make_pair(current, count));
    }

    void setNextCharacter(char &current, const string &input, int idx, int &count) {
        current = input[idx];
        resetCount(count);
    }

    void resetCount(int &count) {
        count = 1;
    }

    int calculateModifications(const vector<pair<char, int>> &sequences) {
        int modifications = 0;
        applyReductions(sequences, modifications);
        return modifications;
    }

    void applyReductions(const vector<pair<char, int>> &sequences, int &totalModifications) {
        for(auto &seq : sequences) {
            if(isReducible(seq)) {
                addReduction(seq, totalModifications);
            }
        }
    }

    bool isReducible(const pair<char, int> &sequence) {
        return sequence.second >= 2;
    }

    void addReduction(const pair<char, int> &sequence, int &modifications) {
        modifications += (sequence.second - 1);
    }
};
",1434335250
Kumar Daksh,kumardaksshh,196,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int possibleStringCount(string word, int maxGroups) {
        const int MODULUS = 1e9 + 7;
        vector<int> segmentCounts;
        
        analyzeCharacterRuns(word, segmentCounts);
        long long totalCombinations = computeTotalCombinations(segmentCounts, MODULUS);
        
        if (segmentCounts.size() > maxGroups) {
            return totalCombinations;
        }
        
        int remainingSpots = calculateRemainingSpots(segmentCounts, maxGroups);
        if (remainingSpots < 0) {
            return totalCombinations;
        }
        
        vector<long long> dynamicResult = initializeDynamicResult(remainingSpots);
        calculateWaysToCombineSegments(segmentCounts, dynamicResult, remainingSpots, MODULUS);
        
        long long alternativeWays = computeAlternativeWays(dynamicResult, remainingSpots, MODULUS);
        return computeFinalResult(totalCombinations, alternativeWays, MODULUS);
    }

private:
    void analyzeCharacterRuns(const string& inputString, vector<int>& segmentCounts) {
        int idx = 0, length = inputString.size();
        while (idx < length) {
            int count = countConsecutiveCharacters(inputString, idx);
            segmentCounts.push_back(count);
            idx++;
        }
    }

    int countConsecutiveCharacters(const string& inputString, int& index) {
        char currentChar = inputString[index];
        int count = 1;
        while (index + 1 < inputString.size() && inputString[index + 1] == currentChar) {
            count++;
            index++;
        }
        return count;
    }

    long long computeTotalCombinations(const vector<int>& segmentCounts, int modulus) {
        long long product = 1;
        for (int count : segmentCounts) {
            product = product * count % modulus;
        }
        return product;
    }

    int calculateRemainingSpots(const vector<int>& segmentCounts, int maxGroups) {
        return maxGroups - 1 - segmentCounts.size();
    }

    vector<long long> initializeDynamicResult(int spots) {
        vector<long long> result(spots + 1, 0);
        result[0] = 1;
        return result;
    }

    void calculateWaysToCombineSegments(const vector<int>& segmentCounts, vector<long long>& dynamicResult, int spots, int modulus) {
        for (int count : segmentCounts) {
            vector<long long> cumulativeSums = computeCumulativeSums(dynamicResult, spots, modulus);
            updateDynamicResult(dynamicResult, cumulativeSums, count, spots, modulus);
        }
    }

    vector<long long> computeCumulativeSums(const vector<long long>& dynamicResult, int spots, int modulus) {
        vector<long long> cumulative(spots + 2, 0);
        for (int j = 0; j <= spots; j++) {
            cumulative[j + 1] = (cumulative[j] + dynamicResult[j]) % modulus;
        }
        return cumulative;
    }

    void updateDynamicResult(vector<long long>& dynamicResult, const vector<long long>& cumulativeSums, int cap, int spots, int modulus) {
        vector<long long> newResult(spots + 1, 0);
        for (int j = 0; j <= spots; j++) {
            int lowerBound = j - (cap - 1);
            if (lowerBound < 0) lowerBound = 0;
            newResult[j] = (cumulativeSums[j + 1] - cumulativeSums[lowerBound] + modulus) % modulus;
        }
        dynamicResult = newResult;
    }

    long long computeAlternativeWays(const vector<long long>& dynamicResult, int spots, int modulus) {
        long long ways = 0;
        for (int j = 0; j <= spots; j++) {
            ways = (ways + dynamicResult[j]) % modulus;
        }
        return ways;
    }

    int computeFinalResult(long long totalCombinations, long long alternativeWays, int modulus) {
        return (totalCombinations - alternativeWays + modulus) % modulus;
    }
};
",1434360084
assassino,galaxyguy,198,3587,javascript,"/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function(n, k, stayScore, travelScore) {
    // Initialize 2D DP array with -1
    const dp = Array.from({ length: k + 1 }, () => Array(n).fill(-1));

    // Helper function to solve the problem
    function solve(day, curr) {
        // Base case: reached end of journey
        if (day === k) {
            return 0;
        }
        
        // If already computed
        if (dp[day][curr] !== -1) {
            return dp[day][curr];
        }
        
        // Option 1: Stay in current city
        let maxPoints = stayScore[day][curr] + solve(day + 1, curr);
        
        // Option 2: Move to another city
        for (let nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity !== curr) { // Can't move to same city
                maxPoints = Math.max(maxPoints, 
                    travelScore[curr][nextCity] + solve(day + 1, nextCity));
            }
        }
        
        // Store and return result
        dp[day][curr] = maxPoints;
        return maxPoints;
    }

    // Try starting from each city and return maximum points
    let result = 0;
    for (let startCity = 0; startCity < n; startCity++) {
        result = Math.max(result, solve(0, startCity));
    }
    
    return result;
};
",1434299029
assassino,galaxyguy,198,3617,cpp,"#include <unordered_set>
#include <string>
#include <vector>

class Solution {
public:
    int possibleStringCount(std::string word) {
        // Store all unique possible strings
        std::unordered_set<std::string> possibleStrings;
        // Start building consecutive character groups
        int n = word.size();
        std::vector<std::pair<char, int>> groups;
        
        // Identify groups of consecutive characters
        for (int i = 0; i < n; ++i) {
            int count = 1;
            while (i + 1 < n && word[i] == word[i + 1]) {
                ++count;
                ++i;
            }
            groups.push_back({word[i], count});
        }
        
        // Create all unique possible strings
        std::string originalWord = word;
        possibleStrings.insert(originalWord);  // add original word
        
        for (int i = 0, pos = 0; i < groups.size(); ++i) {
            char ch = groups[i].first;
            int count = groups[i].second;
            for (int j = 1; j < count; ++j) {  // remove j characters from group[i]
                std::string modifiedWord = originalWord;
                modifiedWord.erase(pos, j);  // remove j characters starting at position pos
                possibleStrings.insert(modifiedWord);
            }
            pos += count;  // move pos to the next group
        }
        
        return possibleStrings.size();
    }
};
",1434261009
assassino,galaxyguy,198,3618,javascript,"/**
 * @param {string} word
 * @param {number} k
 * @return {number}
 */
var possibleStringCount = function(word, k) {
    const MOD = 1e9 + 7;
    const counts = [];
    let n = 0;
    let i = 0;
    const len = word.length;

    while (i < len) {
        const current = word[i];
        let cnt = 1;
        while (i + 1 < len && word[i + 1] === current) {
            cnt++;
            i++;
        }
        counts.push(cnt);
        i++;
    }

    n = counts.length;
    let total = 1;
    for (const c of counts) {
        total = (total * c) % MOD;
    }

    if (n > k) {
        return total;
    }

    const m = k - 1 - n;
    if (m < 0) {
        return total;
    }

    const dp = new Array(m + 1).fill(0);
    dp[0] = 1;

    for (const c of counts) {
        const cap = c - 1;
        const prefix = new Array(m + 2).fill(0);
        for (let j = 0; j <= m; j++) {
            prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
        }

        const new_dp = new Array(m + 1).fill(0);
        for (let j = 0; j <= m; j++) {
            let l = j - cap;
            if (l < 0) l = 0;
            new_dp[j] = (prefix[j + 1] - prefix[l] + MOD) % MOD;
        }
        dp.splice(0, dp.length, ...new_dp); // Update dp array
    }

    let ways = 0;
    for (let j = 0; j <= m; j++) {
        ways = (ways + dp[j]) % MOD;
    }

    return (total - ways + MOD) % MOD;
};",1434362189
SANCHIT PANDEY,pandeySAN,199,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = {}
    
        def solve(d, c):
            if d == k:
                return 0
                
            if (d, c) in dp:
                return dp[(d, c)]
            
            p = 0
            
            p = max(p, stayScore[d][c] + solve(d + 1, c))
            
            for nc in range(n):
                if nc != c:
                    p = max(p, travelScore[c][nc] + solve(d + 1, nc))
            
            dp[(d, c)] = p
            return p
        
        r = 0
        for s in range(n):
            r = max(r, solve(0, s))
        
        return r",1434294406
SANCHIT PANDEY,pandeySAN,199,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        possible = 1
    
        for i in range(1, n):
            if word[i] == word[i - 1]:
                possible += 1
    
        return possible",1434278878
SANCHIT PANDEY,pandeySAN,199,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10**9 + 7
        n = len(word)
        grps = []
        cur = 1
        
        for i in range(1, n):
            if i == n or word[i] != word[i - 1]:
                grps.append(cur)
                cur = 1
            else:
                cur += 1
        grps.append(cur)
        
        tot = 1
        for l in grps:
            tot = (tot * l) % MOD
            
        t = k - len(grps)
        if t <= 0:
            return tot
            
        dp = [0] * (t + 1)
        dp[0] = 1
        
        for l in grps:
            max_d = min(l - 1, t)
            new_dp = [0] * (t + 1)
            win_sum = 0
            
            for s in range(t + 1):
                win_sum = (win_sum + dp[s]) % MOD
                if s - max_d - 1 >= 0:
                    win_sum = (win_sum - dp[s - max_d - 1] + MOD) % MOD
                new_dp[s] = win_sum
            dp = new_dp
            
        bad = sum(dp[:-1]) % MOD
        return (tot - bad + MOD) % MOD",1434359168
Marius Beceanu,mbeceanu,201,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        l=len(parent)
        g=[[] for _ in range(l)]
        for i, par in enumerate(parent):
            if par!=-1:
                g[par].append(i)
        curs=tuple([-1]*26)
        newpar=[-1]*l
        q=[(0, curs)]
        c=0
        orda=ord('a')
        s=[ord(c)-orda for c in s]
        while c<len(q):
            v, curs=q[c]
            c+=1
            curs=list(curs)
            newpar[v]=curs[s[v]]
            curs[s[v]]=v
            curs=tuple(curs)
            for v2 in g[v]:
                q.append((v2, curs))
        sum=[1]*l
        for v, _ in reversed(q):
            if newpar[v]!=-1:
                sum[newpar[v]]+=sum[v]
            elif parent[v]!=-1:
                sum[parent[v]]+=sum[v]
        return sum
            
            
            
            
        ",1434372601
Marius Beceanu,mbeceanu,201,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        word=list(word)
        l=len(word)
        ans=0
        i=0
        while i<l-1:
            if word[i]==word[i+1]:
                c=word[i]
                i0=i
                while i<l and word[i]==c:
                    i+=1
                ans+=i-i0-1
            else:
                i+=1
        return ans+1
                
            
        ",1434264721
Marius Beceanu,mbeceanu,201,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        word=list(word)
        l=len(word)
        i=0
        lst=[]
        ct=0
        while i<l-1:
            if word[i]==word[i+1]:
                i0=i
                c=word[i]
                while i<l and word[i]==c:
                    i+=1
                lst.append(i-i0)
                ct+=1
            else:
                ct+=1
                i+=1
        if i==l-1:
            ct+=1
        k-=ct
        # print(lst, k)
        p=10**9+7
        if k<=0:
            prod=1
            for it in lst:
                prod=prod*it%p
            return prod
        # print(lst, k)
        
        array=[0]*(k+1)
        array[0]=1
        for v in lst:
            tmp=[]
            s=0
            for j in range(k+v):
                s=s+(array[j] if j<=k else 0)
                tmp.append(s)
            for j in range(k):
                array[j]=(tmp[j]-(tmp[j-v] if j>=v else 0))%p
            array[k]=0
            for j in range(k, len(tmp)):
                array[k]+=tmp[j]-(tmp[j-v] if j>=v else 0)
            array[k]%=p
            # print(tmp)
            # print(array)
        return array[k]",1434353639
Saqib Masood,saqib_masood,202,3587,cpp,"class Solution {
public:
    int dp[2001][2001];
    int solve(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore,int i,int curr){
        if(i==k){
            return 0;
        }
        if(dp[i][curr]!=-1){
            return dp[i][curr];
        }
        int stay=stayScore[i][curr]+solve(n,k,stayScore,travelScore,i+1,curr);
        int maxi=0;
        for(int j=0;j<n;j++){
            if(j!=curr){
                maxi=max(maxi,travelScore[curr][j]+solve(n,k,stayScore,travelScore,i+1,j));
            }
        }
        return dp[i][curr]=max(stay,maxi);
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int maxi=0;
        memset(dp,-1,sizeof(dp));
        for(int i=0;i<n;i++){
            maxi=max(maxi,solve(n,k,stayScore,travelScore,0,i));
        }
        return maxi;
    }
};",1434318661
Saqib Masood,saqib_masood,202,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char prev='#';
        int ans=0;
        int cnt=0;
        for(int i=0;i<word.size();i++){
            char curr=word[i];
            if(prev!=curr){
                if(prev!='#')
                    ans+=cnt-1;
                cnt=1;
            }
            else{
                cnt++;
            }
            prev=curr;
        }
        ans+=cnt-1;
        return ans+1;
    }
};",1434293642
Saqib Masood,saqib_masood,202,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        int mod = 1e9 + 7;
        vector<pair<char, int>> runs;
        int n = word.length();
        if (n == 0) return k == 0 ? 1 : 0;

        char curr = word[0];
        int count = 1;
        for (int i = 1; i < n; i++) {
            if (word[i] == curr) count++;
            else {
                runs.push_back({curr,count});
                curr = word[i];
                count = 1;
            }
        }
        runs.push_back({curr,count});

        long long total_ways = 1;
        for (auto& run : runs) total_ways = (total_ways * run.second) % mod;

        int m = runs.size();
        if (k <= m) return total_ways;

        vector<long long> dp(k, 0);
        dp[0] = 1;

        for (auto run : runs) {
            int L_i = run.second;
            vector<long long> newDp(k, 0);
            vector<long long> cumsum(k + 1, 0);
            for (int s = 0; s < k; s++) cumsum[s + 1] = (cumsum[s] + dp[s]) % mod;

            for (int s = 0; s < k; s++) {
                int low = s - L_i;
                long long total = cumsum[s] - (low >= 0 ? cumsum[low] : 0);
                total = (total % mod + mod) % mod;
                newDp[s] = total;
            }
            dp = newDp;
        }

        long long lessK = 0;
        for (int s = m; s < k; s++) lessK = (lessK + dp[s]) % mod;

        return (int)((total_ways - lessK + mod) % mod);
    }
};
",1434379295
Ryan,ryanwong0127,203,3587,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vi prev(n, 0);
        rep(c, 0, n){
            int stay = stayScore[0][c];
            int travel = -inf;
            rep(s, 0, n){
                if(s != c){
                    chmax(travel, travelScore[s][c]);
                }
            }
            if(n == 1){
                prev[c] = stay;
            } else{
                if(travel == -inf){
                    prev[c] = stay;
                }else{
                    prev[c] = max(stay, travel);
                }
            }
        }

        rep(day, 1, k){
            vi curr(n, 0);
            rep(c, 0, n){
                int cand0 = prev[c] + stayScore[day][c];
                int cand1 = -inf;
                rep(s, 0, n){
                    if(s != c){
                        chmax(cand1, prev[s] + travelScore[s][c]);
                    }
                }
                if(cand1 == -inf){
                    curr[c] = cand0;
                }else{
                    curr[c] = max(cand0, cand1);
                }
            }
            prev = curr; 
        }

        return *maxe(all(prev));
    }
};",1434308026
Ryan,ryanwong0127,203,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        runs = []
        current_char = word[0]
        count, res = 1, 1

        for c in word[1:]:
            if c == current_char:
                count += 1
            else:
                runs.append((current_char, count))
                current_char = c
                count = 1
        runs.append((current_char, count))  

        for _, cnt in runs:
            if cnt >=2:
                res += (cnt -1)

        return res",1434265537
Ryan,ryanwong0127,203,3618,python3,"MOD = 10**9 + 7
class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        n = len(word)
        runs = []
        current_c, current_cnt = word[0], 1
        for i in range(1, n):
            if word[i] == current_c:
                current_cnt +=1
            else:
                runs.append((current_c, current_cnt))
                current_c = word[i]
                current_cnt = 1
        runs.append((current_c, current_cnt))

        t = len(runs)
        lj_list = [x for (_, x) in runs]

        total_assignments = 1
        for x in lj_list:
            total_assignments = (total_assignments * x) % MOD

        if t > k:
            return total_assignments

        dp = [0] * (k)
        dp[0] = 1
        for idx in range(t):
            lj = lj_list[idx]
            prefix = [0] * (k)
            prefix[0] = dp[0]
            for s in range(1, k):
                prefix[s] = (prefix[s -1] + dp[s]) % MOD
            dp_new = [0] * (k)
            for s in range(1, k):
                min_add =1
                max_add = min(lj, s)
                low = s - max_add
                if low < 0:
                    low =0
                dp_new[s] = (prefix[s -1] - (prefix[low -1] if low > 0 else 0)) % MOD
            dp = dp_new
        kkk = 0
        for s in range(t, k):
            kkk = (kkk + dp[s]) % MOD
        return (total_assignments - kkk + MOD) % MOD
",1434368165
C S Lalith,lalithcs,204,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        before=[0]*n
        present=[0]*n

        for i in range(n):
            moves=0
            for j in range(n):
                if i==j:
                    continue
                moves=max(moves,travelScore[j][i])
            before[i]=max(stayScore[0][i],moves)
        temp=before[:]
        for day in range(1,k):
            for i in range(n):
                stay=before[i]+stayScore[day][i]
                travel=0
                for k in range(n):
                    if k==i:
                        continue
                    travel=max(travel,before[k]+travelScore[k][i])
                present[i]=max(stay,travel)
            temp=present[:]
            before, present=present,before
        result=max(before)
        return int(result)
        ",1434354785
C S Lalith,lalithcs,204,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n=len(word)
        words=set()
        words.add(word)
        i=0
        while i<n:
            j=i+1
            while j<n and word[j]==word[i]:
                j+=1
            if j-i>1:
                pref=word[:i]
                suf=word[j:]
                for l in range(1,j-i):
                    new_str=pref+(word[i]*l)+suf
                    words.add(new_str)
                i=j
            else:
                i+=1
        return len(words)",1434294450
C S Lalith,lalithcs,204,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD=int(1e9+7)
        countofwords=[]
        s=0
        l=len(word)
        while s<l:
            present=word[s]
            count=1
            while s+1<l and word[s+1]==present:
                count+=1
                s+=1
            countofwords.append(count)
            s+=1
        n=len(countofwords)
        tot=1
        for poss in countofwords:
            tot=tot*poss%MOD

        if n>k:
            return tot
        j=k-1-n
        if j<0:
            return tot

        arr=[0]*(j+1)
        arr[0]=1
        for poss in countofwords:
            c=poss-1
            before=[0]*(j+2)
            for i in range(j+1):
                before[i+1]=(before[i]+arr[i])%MOD
            newarr=[0]*(j+1)
            for i in range(j+1):
                s=i-c
                if s<0:
                    s=0
                newarr[i]=(before[i+1]-before[s]+MOD)%MOD
            arr=newarr

        possibilities=sum(arr[i] for i in range(j+1))%MOD
        return (tot-possibilities+MOD)%MOD
        ",1434382189
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,205,3587,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)

 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}


// ----------------------------- Debuging -----------------------------------------------

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\""' << x << '\""';}
void __print(const string &x) {cerr << '\""' << x << '\""';}
void __print(bool x) {cerr << (x ? ""true"" : ""false"");}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.ff); cerr << "",""; _print(p.ss); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}
void _print() {cerr << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define debug(x...) cerr << ""["" << #x << ""] = [""; _print(x) cerr << endl;
#else
#define debug(x...)
#endif

template <class T>
T *lower_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return left;
}

template <class T>
T *upper_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (val < *middle)
            right = middle;
        else
            left = middle + 1;
    }
    return left;
}

template <class T>
T *binary_search(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle == val)
            return middle;
        else if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return nullptr; // If the element is not found, return nullptr
}

template<class T> T max(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result < data[i])
        {
            result = data[i];
        }
    }
    return result;
}

template<class T> T min(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result > data[i])
        {
            result = data[i];
        }
    }
    return result;
}




class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL); 
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; ++day) {
            for (int curr = 0; curr < n; ++curr) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; ++dest) {
                    if (curr != dest) {
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for (int i = 0; i < n; ++i) {
            maxPoints = max(maxPoints, dp[k][i]);
        }
        return maxPoints;
    }
};",1434273314
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,205,3617,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)

 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}


// ----------------------------- Debuging -----------------------------------------------

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\""' << x << '\""';}
void __print(const string &x) {cerr << '\""' << x << '\""';}
void __print(bool x) {cerr << (x ? ""true"" : ""false"");}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.ff); cerr << "",""; _print(p.ss); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}
void _print() {cerr << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define debug(x...) cerr << ""["" << #x << ""] = [""; _print(x) cerr << endl;
#else
#define debug(x...)
#endif

template <class T>
T *lower_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return left;
}

template <class T>
T *upper_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (val < *middle)
            right = middle;
        else
            left = middle + 1;
    }
    return left;
}

template <class T>
T *binary_search(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle == val)
            return middle;
        else if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return nullptr; // If the element is not found, return nullptr
}

template<class T> T max(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result < data[i])
        {
            result = data[i];
        }
    }
    return result;
}

template<class T> T min(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result > data[i])
        {
            result = data[i];
        }
    }
    return result;
}








class Solution {
public:
    int possibleStringCount(string word) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL); 
        int n = word.length();
        unordered_set<string> result;
        result.insert(word);
        
        for (int i = 0; i < n - 1; i++) {
            if (word[i] == word[i + 1]) {
                string current = """";
                current = word.substr(0, i + 1);  
                
                int j = i + 1;
                while (j < n && word[j] == word[i]) j++;
                
                for (int k = i + 1; k < j; k++) {
                    string reduced = current;
                    reduced += word.substr(k + 1);
                    result.insert(reduced);
                }
                
                i = j - 1;
            }
        }
        
        return result.size();
    }
};",1434276048
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,205,3618,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)

 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}


// ----------------------------- Debuging -----------------------------------------------

void __print(int x) {cerr << x;}
void __print(long x) {cerr << x;}
void __print(long long x) {cerr << x;}
void __print(unsigned x) {cerr << x;}
void __print(unsigned long x) {cerr << x;}
void __print(unsigned long long x) {cerr << x;}
void __print(float x) {cerr << x;}
void __print(double x) {cerr << x;}
void __print(long double x) {cerr << x;}
void __print(char x) {cerr << '\'' << x << '\'';}
void __print(const char *x) {cerr << '\""' << x << '\""';}
void __print(const string &x) {cerr << '\""' << x << '\""';}
void __print(bool x) {cerr << (x ? ""true"" : ""false"");}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.ff); cerr << "",""; _print(p.ss); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}
void _print() {cerr << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define debug(x...) cerr << ""["" << #x << ""] = [""; _print(x) cerr << endl;
#else
#define debug(x...)
#endif

template <class T>
T *lower_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return left;
}

template <class T>
T *upper_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (val < *middle)
            right = middle;
        else
            left = middle + 1;
    }
    return left;
}

template <class T>
T *binary_search(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle == val)
            return middle;
        else if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return nullptr; // If the element is not found, return nullptr
}

template<class T> T max(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result < data[i])
        {
            result = data[i];
        }
    }
    return result;
}
        const int mod = 1e9 + 7;

template<class T> T min(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result > data[i])
        {
            result = data[i];
        }
    }
    return result;
}



class Solution {
public:
    int modInverse(int a, int m) {
        int m0 = m, y = 0, x = 1;
        if (m == 1) return 0;
        while (a > 1) {
            int q = a / m;
            int t = m;
            m = a % m, a = t;
            t = y;
            y = x - q * y;
            x = t;
        }
        if (x < 0) x += m0;
        return x;
    }

    void precomputeFactorials(int maxN, vector<int>& fact, vector<int>& invFact) {
        fact[0] = 1;
        for (int i = 1; i <= maxN; i++) {
            fact[i] = (fact[i - 1] * i) % mod;
        }
        invFact[maxN] = modInverse(fact[maxN], mod);
        for (int i = maxN - 1; i >= 0; i--) {
            invFact[i] = (invFact[i + 1] * (i + 1)) % mod;
        }
    }

    int comb(int n, int r, const vector<int>& fact, const vector<int>& invFact) {
        if (n < r || r < 0) return 0;
        return (fact[n] * invFact[r] % mod) * invFact[n - r] % mod;
    }

    int possibleStringCount(string w, int k) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL); 
                const int M = 1e9 + 7;
        int n = w.length();
        vector<int> s;

        for(int i = 0; i < n;) {
            int c = 1;
            char ch = w[i];
            i++;
            while(i < n && w[i] == ch) {
                c++;
                i++;
            }
            s.push_back(c);
        }

        int t = s.size();
        long long C = 1;
        for(int x : s) {
            C = (C * x) % M;
        }

        if(k <= t) {
            return C;
        }

        int mx = k - 1;
        vector<int> dp(mx + 1, 0);
        dp[0] = 1;

        for(int i = 0; i < t; i++) {
            int x = s[i];
            vector<int> ndp(mx + 1, 0);

            long long cum = 0;
            for(int j = 0; j <= mx; j++) {
                if(j - 1 >= 0) {
                    cum = (cum + dp[j - 1]) % M;
                }
                if(j - x - 1 >= 0) {
                    cum = (cum - dp[j - x - 1] + M) % M;
                }
                ndp[j] = cum;
            }
            dp = ndp;
        }

        long long T = 0;
        for(int j = t; j <= mx; j++) {
            T = (T + dp[j]) % M;
        }

        return (int)((C - T + M) % M);
        
    }
};",1434382841
Ayush Mishra,speedcuberayush,206,3587,typescript,"function maxScore(n: number, k: number, stayScore: number[][], travelScore: number[][]): number {
    const dp: number[][] = Array.from({ length: k + 1 }, () => Array(n).fill(-1));

    function solve(day: number, curr: number): number {
        if (day === k) return 0;
        if (dp[day][curr] !== -1) return dp[day][curr];
        
        let maxPoints: number = stayScore[day][curr] + solve(day + 1, curr);
        
        for (let nextCity = 0; nextCity < n; nextCity++)
            if (nextCity !== curr)
                maxPoints = Math.max(maxPoints, 
                    travelScore[curr][nextCity] + solve(day + 1, nextCity));
        
        dp[day][curr] = maxPoints;
        return maxPoints;
    }

    let result: number = 0;
    for (let startCity = 0; startCity < n; startCity++)
        result = Math.max(result, solve(0, startCity));
    
    return result;
}
",1434314874
Ayush Mishra,speedcuberayush,206,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        possible_strings = set()
        n = len(word)
        groups = []
        
        i = 0
        while i < n:
            count = 1
            while i + 1 < n and word[i] == word[i + 1]:
                count += 1
                i += 1
            groups.append((word[i], count))
            i += 1
        
        possible_strings.add(word)
        
        pos = 0
        for ch, count in groups:
            for j in range(1, count):
                modified_word = word[:pos] + word[pos + j:]
                possible_strings.add(modified_word)
            pos += count
        
        return len(possible_strings)
",1434263068
Ayush Mishra,speedcuberayush,206,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod, counts, total = 10**9 + 7, [], 1
        for i in range(len(word)):
            if not counts or word[i] != word[i - 1]:
                counts.append(1)
            else:
                counts[-1] += 1
        n = len(counts)
        for c in counts: total = total * c % mod
        if n > k: return total
        m = k - 1 - n
        if m < 0: return total
        dp = [0] * (m + 1)
        dp[0] = 1
        for c in counts:
            cap, prefix = c - 1, [0] * (m + 2)
            for j in range(m + 1): prefix[j + 1] = (prefix[j] + dp[j]) % mod
            newDp = [0] * (m + 1)
            for j in range(m + 1):
                l = max(j - cap, 0)
                newDp[j] = (prefix[j + 1] - prefix[l] + mod) % mod
            dp = newDp
        return (total - sum(dp) % mod + mod) % mod
",1434365067
shlokthefreelancer,shlokatwork,207,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int furniture, int chir, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Initialize DP vector with 0 points for the last day
        vector<int> dp(furniture, 0);
        
        // Fill DP from day `chir-1` down to `0`
        for (int day = chir - 1; day >= 0; --day) {
            vector<int> new_dp(furniture, 0);
            for (int table = 0; table < furniture; ++table) {
                // Option 1: Stay in the same city
                int max_points = stayScore[day][table] + dp[table];
                
                // Option 2: Move to another city
                for (int next_table = 0; next_table < furniture; ++next_table) {
                    if (next_table != table) {
                        max_points = max(max_points, travelScore[table][next_table] + dp[next_table]);
                    }
                }
                
                // Save the maximum score for the current day and city
                new_dp[table] = max_points;
            }
            dp = new_dp;  // Move to the next day
        }
        
        // Return the maximum score possible starting from any city on the first day
        return *max_element(dp.begin(), dp.end());
    }
};
",1434318698
shlokthefreelancer,shlokatwork,207,3617,cpp,"class Solution {
public:
    int possibleStringCount(string shlok) {
        return countConsecutive(shlok, 1, 1);
    }

private:
    int countConsecutive(const string& shlok, int kanha, int sharma) {
        if (sharma >= shlok.length()) return kanha;
        if (shlok[sharma] == shlok[sharma - 1]) {
            return countConsecutive(shlok, kanha + 1, sharma + 1);
        }
        return countConsecutive(shlok, kanha, sharma + 1);
    }
};
",1434313608
shlokthefreelancer,shlokatwork,207,3618,cpp,"class Solution {
public:
    int possibleStringCount(string laptop, int pc) {
        const int MODULO = 1e9 + 7;
        int computer = laptop.length();

        // Step 1: Group consecutive characters and their lengths
        vector<int> gate = segmentLengths(laptop, computer);

        // Step 2: Calculate total combinations based on group lengths
        long long hello = calculateTotalCombinations(gate, MODULO);

        // Step 3: If k is less than or equal to the number of segments, return total combinations
        if(pc <= gate.size()) {
            return hello;
        }

        // Step 4: Perform dynamic programming to calculate combinations of lengths < k
        int maxSize = pc - 1;
        vector<int> windows = calculateDP(gate, maxSize, MODULO);

        // Step 5: Calculate total ways for strings of length < k
        long long totalLessThanK = calculateTotalLessThanK(gate.size(), windows, maxSize, MODULO);

        // Step 6: Final answer calculation
        return (int)((hello - totalLessThanK + MODULO) % MODULO);
    }

private:
    vector<int> segmentLengths(const string &laptop, int computer) {
        vector<int> gate;
        for(int index = 0; index < computer;) {
            int count = 1;
            char currentChar = laptop[index];
            index++;
            while(index < computer && laptop[index] == currentChar) {
                count++;
                index++;
            }
            gate.push_back(count);
        }
        return gate;
    }

    long long calculateTotalCombinations(const vector<int> &gate, const int MODULO) {
        long long totalCombinations = 1;
        for(int count : gate) {
            totalCombinations = (totalCombinations * count) % MODULO;
        }
        return totalCombinations;
    }

    vector<int> calculateDP(const vector<int> &gate, int maxSize, const int MODULO) {
        vector<int> dp(maxSize + 1, 0);
        dp[0] = 1;

        for(int i = 0; i < gate.size(); i++) {
            int count = gate[i];
            vector<int> newDP(maxSize + 1, 0);

            long long cumulativeSum = 0;
            for(int s = 0; s <= maxSize; s++) {
                if(s - 1 >= 0) {
                    cumulativeSum = (cumulativeSum + dp[s - 1]) % MODULO;
                }
                if(s - count - 1 >= 0) {
                    cumulativeSum = (cumulativeSum - dp[s - count - 1] + MODULO) % MODULO;
                }
                newDP[s] = cumulativeSum;
            }
            dp = newDP;
        }
        return dp;
    }

    long long calculateTotalLessThanK(int segmentCount, const vector<int> &windows, int maxSize, const int MODULO) {
        long long totalLessThanK = 0;
        for(int s = segmentCount; s <= maxSize; s++) {
            totalLessThanK = (totalLessThanK + windows[s]) % MODULO;
        }
        return totalLessThanK;
    }
};
",1434384697
SHIVAM PANDEY,ashishivam,208,3587,cpp,"class Solution {
public:
   int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    vector<vector<int>> p(k + 1, vector<int>(n));
    for (int i= 0; i<k;i++) {
        for (int j = 0; j < n;j++) {
            p[i+1][j] = max(p[i+1][j], p[i][j] + stayScore[i][j]);
            for (int z = 0; z< n;z++) {
                if (z != j) {
                    int x = p[i][j] + travelScore[j][z];
                    p[i+1][z] = max(p[i + 1][z],x);
                }
            }
        }
    }
    return *max_element(p[k].begin(), p[k].end());
}

};",1434369129
SHIVAM PANDEY,ashishivam,208,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int x=0;
        for(int i=1;i<word.size();i++){
            if(word[i]==word[i-1]){
                x++;
            }
        }
        return x+1;
    }
};",1434268435
SHIVAM PANDEY,ashishivam,208,3618,cpp,"class Solution { 
public:
    int possibleStringCount(string word, int k) {
        const int M = 1e9 + 7;
        vector<int> segs;
        int i = 0, s = 0;
        int n = word.size();
        while (i < n) {
            int l = 1;
            while (i + 1 < n && word[i] == word[i + 1]) {
                ++l;
                ++i;
            }
            segs.push_back(l);
            ++i;
        }
        s = segs.size();
        long long prod = 1;
        for (int x : segs) {
            prod = (prod * x) % M;
        }
        if (s > k) return prod;
        int r = k - s - 1;
        if (r < 0) return prod;

        vector<long long> dp(r + 1, 0);
        dp[0] = 1;

        for (int x : segs) {
            int m = x - 1;
            vector<long long> cum(r + 2, 0);
            for (int j = 0; j <= r; ++j) {
                cum[j + 1] = (cum[j] + dp[j]) % M;
            }
            vector<long long> new_dp(r + 1, 0);
            for (int j = 0; j <= r; ++j) {
                int l = max(0, j - m);
                new_dp[j] = (cum[j + 1] - cum[l] + M) % M;
            }
            dp = move(new_dp);
        }
        long long ways = 0;
        for (long long cnt : dp) {
            ways = (ways + cnt) % M;
        }
        return (prod - ways + M) % M;
    }
};
",1434384994
Sagar Mondal,sagarmondal,209,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);       
        vector<vector<int>> dp(k + 1, vector<int>(n, -1));
        int res = 0;
        for (int st = 0; st < n; st++) {
            res = max(res, solve(0, st, k, stayScore, travelScore, dp));
        }
        return res;    
    }
private:
    int solve(int day, int cur, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& dp) {
        if (day == k) return 0;
        if (dp[day][cur] != -1) return dp[day][cur];     
        int mx = stayScore[day][cur] + solve(day + 1, cur, k, stayScore, travelScore, dp);
        for (int nxt = 0; nxt < travelScore[0].size(); nxt++) {
            if (nxt != cur) {
                mx = max(mx, travelScore[cur][nxt] + solve(day + 1, nxt, k, stayScore, travelScore, dp));
            }
        }       
        return dp[day][cur] = mx;
    }
};",1434304902
Sagar Mondal,sagarmondal,209,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 0;
        for(int i = 1; i < word.size(); i++){
            if(word[i] == word[i - 1]){
                cnt++;
            }
        }
        return cnt + 1;
    }
};",1434273655
Sagar Mondal,sagarmondal,209,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        const int MOD = 1e9 + 7;
        vector<int> segLen = getSegLen(word);
        long long totalComb = calcTotalComb(segLen, MOD);
        
        if (k <= segLen.size()) {
            return totalComb;
        }

        int maxS = k - 1;
        vector<int> dp(maxS + 1, 0);
        dp[0] = 1;

        dp = calcDP(segLen, dp, maxS, MOD);
        long long totalLessK = calcLessK(dp, segLen.size(), maxS, MOD);

        return (int)((totalComb - totalLessK + MOD) % MOD);
    }

private:
    vector<int> getSegLen(const string& word) {
        vector<int> segLen;
        int len = word.length();
        for (int idx = 0; idx < len;) {
            int cnt = 1;
            char curChar = word[idx];
            idx++;
            while (idx < len && word[idx] == curChar) {
                cnt++;
                idx++;
            }
            segLen.push_back(cnt);
        }
        return segLen;
    }

    long long calcTotalComb(const vector<int>& segLen, const int MOD) {
        long long totalComb = 1;
        for (int cnt : segLen) {
            totalComb = (totalComb * cnt) % MOD;
        }
        return totalComb;
    }

    vector<int> calcDP(const vector<int>& segLen, vector<int>& dp, int maxS, const int MOD) {
        int totalSeg = segLen.size();
        for (int i = 0; i < totalSeg; i++) {
            int cnt = segLen[i];
            vector<int> newDP(maxS + 1, 0);
            long long cumSum = 0;

            for (int s = 0; s <= maxS; s++) {
                if (s - 1 >= 0) {
                    cumSum = (cumSum + dp[s - 1]) % MOD;
                }
                if (s - cnt - 1 >= 0) {
                    cumSum = (cumSum - dp[s - cnt - 1] + MOD) % MOD;
                }
                newDP[s] = cumSum;
            }
            dp = newDP;
        }
        return dp;
    }

    long long calcLessK(const vector<int>& dp, int totalSeg, int maxS, const int MOD) {
        long long totalLessK = 0;
        for (int s = totalSeg; s <= maxS; s++) {
            totalLessK = (totalLessK + dp[s]) % MOD;
        }
        return totalLessK;
    }
};
",1434385383
daikiad,daikiad,210,3587,cpp,"class Solution {
public:
    using ll = long long;
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        ll dp[k][n];
        fill_n(&dp[0][0], k*n, 0);
        for (int i = 0; i < n; i++) {
            dp[0][i] = stayScore[0][i];
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dp[0][j] = max(dp[0][j], (ll)travelScore[i][j]);
            }
        }

        for (int i = 0; i < k-1; i++) {
            for (int j = 0; j < n; j++) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]+stayScore[i+1][j]);
            }
            for (int j = 0; j < n; j++) {
                for (int l = 0; l < n; l++) {
                    dp[i+1][l] = max(dp[i+1][l], dp[i][j] + travelScore[j][l]);
                }
            }
        }
        ll ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, dp[k-1][i]);
        }
        return ans;
    }
};",1434314967
daikiad,daikiad,210,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        // map<int, int> m;
        vector<int> v;
        char cur = '0';
        int count = 0;
        for (char c : word) {
            if (c != cur) {
                if (cur != '0') {
                    v.push_back(count);
                }
                cur = c;
                count = 1;
            } else {
                count++;
            }
        }
         v.push_back(count);
        int ans = 1;
        for (int e : v) {
            ans += (e-1);
        }
        return ans;
    }
};",1434264114
daikiad,daikiad,210,3618,cpp,"class Solution {
    
public:
    using ll = long long;
    const ll MOD = 1e9+7;
    int possibleStringCount(string word, int k) {
        vector<int> v;
        char cur = '0';
        int count = 0;
        for (char c : word) {
            if (c != cur) {
                if (cur != '0') {
                    v.push_back(count);
                }
                cur = c;
                count = 1;
            } else {
                count++;
            }
        }
        v.push_back(count);
        ll ans = 1;
            for (auto e : v) {
            if (e > 1LL) {
                ans *= e;
                ans %= MOD;
            }
        }
        if (v.size() >= k) {
            return ans;
        }
        int n = v.size();
        ll dp[n][k];
        ll sums[k];
        fill_n(&sums[0], k, 0);
        fill_n(&dp[0][0], n*k, 0);
        for (int i = 1; i <= min(v[0], k-1); i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i < k; i++) {
            sums[i] = sums[i-1]+dp[0][i];
            sums[i] %= MOD;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < k; j++) {
                if (j-v[i]-1 < 0) {
                    dp[i][j] += sums[j-1];
                    dp[i][j] %= MOD;
                } else {
                    dp[i][j] += sums[j-1] - sums[j-v[i]-1];
                    dp[i][j] %= MOD;
                }
                
                // dp[i][j] = dp[i-1][j-1];
                // for (int l = 1; l <= v[i]; l++) {
                //     if (j-l>=0) {
                //         dp[i][j] += dp[i-1][j-l];
                //         dp[i][j] %= MOD;
                //     }
                // }
            }
            sums[0] = 0;
            for (int j = 1; j < k; j++) {
                sums[j] = sums[j-1]+dp[i][j];
                sums[j] %= MOD;
            }
        }
        for (int i = 0; i < k; i++) {
            ans -= dp[n-1][i];
            ans += MOD;
            ans %= MOD;
        }
        return ans;
    }
};",1434366757
Pankaj Shankhwar,Pankaj_Shankhwar,211,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        for (int day = 0; day < k; ++day) {
            for (int curr = 0; curr < n; ++curr) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; ++dest) {
                    if (dest != curr) {
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxi=*max_element(dp[k].begin(), dp[k].end());
        return maxi;
    }
};",1434379963
Pankaj Shankhwar,Pankaj_Shankhwar,211,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 1;    
        int ans = 1;    
        int n = word.length();
        char curr = word[0];

        for (int i = 1; i < n; i++) { 
            if (word[i] == curr) {
                cnt += 1; 
            } else {
               
                ans += (cnt - 1);
                cnt = 1;    
                curr = word[i];
            }
        }
        
        ans += (cnt - 1);
        
        return ans;
    }
};",1434304242
Pankaj Shankhwar,Pankaj_Shankhwar,211,3618,cpp,"class Solution {
public:
int MOD = 1e9 + 7;
    int possibleStringCount(string word, int k) {
         
        int strLength = word.length();

        vector<int> segmentSizes;
        for (int i = 0; i < strLength;) {
            int segmentLength = 1;
            char currentChar = word[i];
            i++;
            while (i < strLength && word[i] == currentChar) {
                segmentLength++;
                i++;
            }
            segmentSizes.push_back(segmentLength);
        }

        int numSegments = segmentSizes.size();

        long long maxCombinations = 1;
        for (int size : segmentSizes) {
            maxCombinations = (maxCombinations * size) % MOD;
        }

        if (k <= numSegments) {
            return maxCombinations;
        }

        int maxDpSize = k - 1;
        vector<int> dp(maxDpSize + 1, 0);
        dp[0] = 1;

        for (int segmentIndex = 0; segmentIndex < numSegments; segmentIndex++) {
            int segmentSize = segmentSizes[segmentIndex];
            vector<int> newDp(maxDpSize + 1, 0);

            long long cumulativeSum = 0;
            for (int s = 0; s <= maxDpSize; s++) {
                if (s - 1 >= 0) {
                    cumulativeSum = (cumulativeSum + dp[s - 1]) % MOD;
                }
                if (s - segmentSize - 1 >= 0) {
                    cumulativeSum = (cumulativeSum - dp[s - segmentSize - 1] + MOD) % MOD;
                }
                newDp[s] = cumulativeSum;
            }
            dp = newDp;
        }

        long long lessThanTargetCombinations = 0;
        for (int s = numSegments; s <= maxDpSize; s++) {
            lessThanTargetCombinations = (lessThanTargetCombinations + dp[s]) % MOD;
        }

        return (int)((maxCombinations - lessThanTargetCombinations + MOD) % MOD);
    }
};",1434386266
Vishal Kumar,Nemesis_77,212,3587,cpp,"class Solution {
public:
    int n, k;
    vector<vector<int>> dp , dp_stay , dp_travel;

    int solve(int curr_day, int m ) {
        if (curr_day == k) return 0;
        if (dp[curr_day][m ] != -1) return dp[curr_day][m ];

        int res = dp_stay[curr_day][m ] + solve(curr_day + 1, m );

        for (int i = 0; i < n; i++) {
            if ( i == m  ) continue;
            res = max(res, dp_travel[m ][i] + solve(curr_day + 1, i));
        }

        return dp[curr_day][m ] = res;
    }

    int maxScore(int n, int k, vector<vector<int>>& dp_stay, vector<vector<int>>& dp_travel) {
        this->n = n;
        this->k = k;
        this->dp_stay = dp_stay;
        this->dp_travel = dp_travel;

        dp.assign(k + 1, vector<int>(n, -1));
        int ans = 0;  

        for (int i = 0; i < n; i ++) {
            ans = max( ans , solve(0, i ));
        }

        return ans;
    }
};
",1434318809
Vishal Kumar,Nemesis_77,212,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;  
        int n = word.size();
        
        for (int i = 1; i < n; i ++) {
            if ( word[i] == word[i-1] )  ans ++;
        }

        
        return ans;
    }
};
",1434278437
Vishal Kumar,Nemesis_77,212,3618,cpp,"class Solution {
public:
    const int M = 1e9 + 7;

    vector<int> getSegmentLengths(string& str) {
        vector<int> segments;
        int strLength = str.length();
        int i = 0;
        while (i < strLength) {
            int length = 1;
            char currentChar = str[i++];
            while (i < strLength && str[i] == currentChar) {
                length++;
                i++;
            }
            segments.push_back(length);
        }
        return segments;
    }

    long long computeres(const vector<int>& segments) {
        long long res = 1;
        int i = 0;
        int segmentSize = segments.size();
        while (i < segmentSize) {
            res = (res * segments[i]) % M;
            i++;
        }
        return res;
    }

    vector<int> buildDP(const vector<int>& segments, int targetSize) {
        int n = segments.size();
        vector<int> dp(targetSize + 1, 0);
        dp[0] = 1;

        int i = 0;
        while (i < n) {
            int length = segments[i];
            vector<int> newDP(targetSize + 1, 0);
            long long cumulativeSum = 0;

            int size = 0;
            while (size <= targetSize) {
                if (size - 1 >= 0) {
                    cumulativeSum = (cumulativeSum + dp[size - 1]) % M;
                }
                if (size - length - 1 >= 0) {
                    cumulativeSum = (cumulativeSum - dp[size - length - 1] + M) % M;
                }
                newDP[size] = cumulativeSum;
                size++;
            }
            dp = newDP;
            i++;
        }
        return dp;
    }

    long long sumless(const vector<int>& dp, int n, int targetSize) {
        long long less = 0;
        int size = n;
        while (size <= targetSize) {
            less = (less + dp[size]) % M;
            size++;
        }
        return less;
    }

    int possibleStringCount(string str, int targetSegments) {
        vector<int> segments = getSegmentLengths(str);
        int n = segments.size();
        long long res = computeres(segments);

        if (targetSegments <= n) {
            return res;
        }

        int targetSize = targetSegments - 1;
        vector<int> dp = buildDP(segments, targetSize);
        long long less = sumless(dp, n, targetSize);

        return (int)((res - less + M) % M);
    }
};
",1434387237
Arjun Nayak,Arjun_Nayak1234,213,3587,cpp,"class Solution {
public:
     vector<vector<int>> dp;
    int solve(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>> &dp){
       
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < n; j++) {
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + stayScore[i][j]);
                for (int l = 0; l < n; l++) {
                    if (j != l) { 
                        dp[i + 1][l] = max(dp[i + 1][l], dp[i][j] + travelScore[j][l]);
                    }
                }
            }
        }
        int maxi = 0;
        for (int i = 0; i < n; i++) {
            maxi = max(maxi, dp[k][i]);
        }
        return maxi;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        dp.resize(k + 1, vector<int>(n, 0));
        return solve(n,k,stayScore,travelScore,dp);
    }
};",1434333501
Arjun Nayak,Arjun_Nayak1234,213,3617,cpp,"class Solution {
public:
    int count(string&word){
       int n = word.size();
       unordered_set<string> st;
        st.insert(word);
        
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && word[j] == word[i]) {
                j++;
            }
            int seglan = j - i;
        
            
            for (int k = 1; k < seglan; ++k) {
                string curr = word.substr(0, i) + word.substr(i, seglan - k) + word.substr(j);
                st.insert(curr);
            }
            
            i = j; 
        }
        return st.size();
    }
    int possibleStringCount(string&word){
      return count(word);
    }
};",1434279126
Arjun Nayak,Arjun_Nayak1234,213,3618,cpp,"class Solution {
public:
    const int MOD = 1e9+7;
    using ll=long long;
    int solve(string&word,int k){
        vector<int> storing;
        int i = 0;
        while(i < word.length()){
            int cnt = 1;
            while(i+1 < word.length() && word[i+1]==word[i]){
                cnt++;
                i++;
            }
            storing.push_back(cnt);
            i++;
        }
       int n = storing.size();
        ll totalSum = 1;
        for(auto c: storing){
            totalSum =(totalSum * c) % MOD;
        }
        int m = k - 1 - n;
        if(n > k || m < 0){
            return totalSum;
        }
        vector<ll> dp(m+1, 0);
        dp[0] = 1;
        for(auto&cnt: storing){
            int cap =cnt - 1;
            vector<ll> prev(m+2, 0);
            for(int j=0; j<=m; j++) prev[j+1] = (prev[j] + dp[j]) % MOD;
            vector<ll> curr(m+1, 0);
            for(int j=0; j<=m; j++){
                int l = j - cap;
                if(l < 0) l = 0;
                curr[j] = (prev[j+1] - prev[l]+MOD) % MOD;
            }
            dp = curr;
        }
        ll noOfWasy = 0;
        for(int j=0; j<=m; j++) noOfWasy = (noOfWasy + dp[j]) % MOD;
        return (totalSum - noOfWasy+MOD) % MOD;
    }
    int possibleStringCount(string word, int k) {
       return solve(word,k)%MOD;
    }
};",1434368849
Ivan Jacob,ivanj-0,214,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0] * n for _ in range(k)]

        for city in range(n):
            dp[0][city] = stayScore[0][city]
            for prev in range(n):
                dp[0][city] = max(dp[0][city], travelScore[prev][city])

        for day in range(1, k):
            for curr in range(n):
                for dest in range(n):
                    dp[day][dest] = max(dp[day][dest], dp[day - 1][curr] + travelScore[curr][dest])
            for city in range(n):
                dp[day][city] = max(dp[day][city], dp[day-1][city] + stayScore[day][city])

        return max(dp[k - 1])",1434347537
Ivan Jacob,ivanj-0,214,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        prev = word[0]
        count = 0
        res = 1
        for i in range(1,len(word)):
            if prev == word[i]:
                count += 1
            else:
                if count > 0:
                    res += count
                count = 0
                prev = word[i]
        if count > 0:
            res += count
        return res",1434279001
Ivan Jacob,ivanj-0,214,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MODULO = int(1e9 + 7)
        length = len(word)
        segment_lengths = []

        index = 0
        while index < length:
            current_char = word[index]
            count = 1
            index += 1
            while index < length and word[index] == current_char:
                count += 1
                index += 1
            segment_lengths.append(count)

        total_segments = len(segment_lengths)

        total_combinations = 1
        for count in segment_lengths:
            total_combinations = (total_combinations * count) % MODULO

        if k <= total_segments:
            return total_combinations

        max_size = k - 1
        dp = [0] * (max_size + 1)
        dp[0] = 1

        for count in segment_lengths:
            new_dp = [0] * (max_size + 1)
            cumulative_sum = 0
            for s in range(max_size + 1):
                if s - 1 >= 0:
                    cumulative_sum = (cumulative_sum + dp[s - 1]) % MODULO
                if s - count - 1 >= 0:
                    cumulative_sum = (cumulative_sum - dp[s - count - 1] + MODULO) % MODULO
                new_dp[s] = cumulative_sum
            dp = new_dp

        total_less_than_k = 0
        for s in range(total_segments, max_size + 1):
            total_less_than_k = (total_less_than_k + dp[s]) % MODULO

        return (total_combinations - total_less_than_k + MODULO) % MODULO",1434387809
Vaid Aaryan,cool_coder_007,215,3587,cpp,"#include <bits/stdc++.h>
using namespace std;
// Common file

#include <ext/pb_ds/assoc_container.hpp>     

// Including tree_order_statistics_node_update

#include <ext/pb_ds/tree_policy.hpp>  
using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    #define ordered_set tree<pair<ll, ll>, null_type,less<pair<ll, ll>>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    // int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e9;
const ll MAXN=20,N=10001;


mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());
int rnd(int x, int y) {
  return uniform_int_distribution<int>(x, y)(rng);
}


class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        swap(n,k);
        ll dp[n][k];
        
        f(i,0,n) f(j,0,k) dp[i][j]=0;
        f(i,0,k){
            dp[0][i]=stayScore[0][i];
            f(j,0,k){
                if(i!=j) dp[0][i]=max(dp[0][i],travelScore[j][i]+0ll);
            }
        }

        for(ll i=0;i<n-1;i++){
            for(ll j=0;j<k;j++){
                for(ll x=0;x<k;x++){
                    if(x!=j) dp[i+1][x]=max(dp[i+1][x],dp[i][j]+travelScore[j][x]);
                    else dp[i+1][x]=max(dp[i+1][x],dp[i][j]+stayScore[i+1][x]);
                }
            }
        }

        ll ans=0;
        f(i,0,k){
            ans=max(ans,dp[n-1][i]);
        }
        return ans;
    }
};






// int main() {
//     FIO;
//     int tt=1;
//     // cin>>tt;
//     while(tt--){
//        


     

        

    
// }

//     return 0;
// }
",1434298162
Vaid Aaryan,cool_coder_007,215,3617,cpp,"#include <bits/stdc++.h>
using namespace std;
// Common file

#include <ext/pb_ds/assoc_container.hpp>     

// Including tree_order_statistics_node_update

#include <ext/pb_ds/tree_policy.hpp>  
using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    #define ordered_set tree<pair<ll, ll>, null_type,less<pair<ll, ll>>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    // int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e9;
const ll MAXN=20,N=10001;


mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());
int rnd(int x, int y) {
  return uniform_int_distribution<int>(x, y)(rng);
}


class Solution {
public:
    int possibleStringCount(string word) {
        int n=word.length();
        int ans=1;
        int i=0;
        string s=word;
        while(i<n){
            int j=i;
            while(j<n && s[j]==s[i]){
                j++;
            }
            int same=j-i;
            ans+=same-1;
            i=j;
        }

        return ans;
        
    }
};










// int main() {
//     FIO;
//     int tt=1;
//     // cin>>tt;
//     while(tt--){
//        


     

        

    
// }

//     return 0;
// }
",1434263912
Vaid Aaryan,cool_coder_007,215,3618,cpp,"#include <bits/stdc++.h>
using namespace std;
// Common file

#include <ext/pb_ds/assoc_container.hpp>     

// Including tree_order_statistics_node_update

#include <ext/pb_ds/tree_policy.hpp>  
using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    #define ordered_set tree<pair<ll, ll>, null_type,less<pair<ll, ll>>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    // int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e9;
const ll MAXN=20,N=10001;


mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());
int rnd(int x, int y) {
  return uniform_int_distribution<int>(x, y)(rng);
}

ll n;
unsigned long long power(unsigned long long x,
                                  int y, int p)
{
    unsigned long long res = 1; // Initialize result
 
    x = x % p; // Update x if it is more than or
    // equal to p
 
    while (y > 0)
    {
     
        // If y is odd, multiply x with result
        if (y & 1)
            res = (res * x) % p;
 
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % p;
    }
    return res;
}
 
// Returns n^(-1) mod p
unsigned long long modInverse(unsigned long long n, 
                                            int p)
{
    return power(n, p - 2, p);
}
 
// Returns nCr % p using Fermat's little
// theorem.
unsigned long long fac[N + 1];
void calc(){
    fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % mod;
}
unsigned long long nCrModPFermat(unsigned long long n,
                                 int r, int p)
{
    // If n<r, then nCr should return 0
    if (n < r)
        return 0;
    // Base case
    if (r == 0)
        return 1;
 
    // Fill factorial array so that we
    // can find all factorial of r, n
    // and n-r
 
    return (fac[n] * modInverse(fac[r], p) % p
            * modInverse(fac[n - r], p) % p)
           % p;
}




class Solution {
public:
    int possibleStringCount(string word, int k) {

        int n=word.length();
        vector<int> v;

        
        ll ans=0;
        int i=0;
        // v.pb(0);
        while(i<n){
            int j=i;
            while(j<n && word[j]==word[i]){
                j++;
            }
            v.pb(j-i);
            i=j;
        }
        // show(v);cout<<endl;


        if(k>n) return 0;


        n=v.size();
        ll total=1;
        f(i,0,n){
            total=(total*v[i])%mod;
        }
        if(n>k) return total;
        // show(v);cout<<endl;


        ll dp[n+1][k+1],pf[n+1][k+1];
        f(i,0,n+1) f(j,0,k+1) dp[i][j]=0,pf[i][j]=0;


        for(int i=1;i<=min(k,v[0]);i++) dp[0][i]=1;

        for(int i=1;i<=k;i++) pf[0][i]=pf[0][i-1]+dp[0][i];
        // show(pf[0]);cout<<endl;cout<<endl;

        for(int i=1;i<n;i++){
            for(int j=1;j<=k;j++){
                int num=max(0,j-v[i]);
                ll val=pf[i-1][j-1];
                if(num>=1){
                 val-=pf[i-1][num-1];
                 // val+=mod;
                 val%=mod;
                }
                dp[i][j]=(dp[i][j]+val)%mod;
                pf[i][j]=dp[i][j];
                if(j-1>=0) pf[i][j]=(pf[i][j]+pf[i][j-1])%mod;
                // for(ll x=j-1;x>=max(0ll,j-v[i]);x--){
                //     dp[i][j]=(dp[i][j]+dp[i-1][x])%mod;
                // }
            }
        }

        // f(i,0,n){
        //     f(j,0,k+1){
        //         cout<<dp[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }

        // cout<<endl;
        // f(i,0,n){
        //     f(j,0,k+1){
        //         cout<<pf[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }
        // ans=dp[n-1][k]%mod;
        for(int i=1;i<=k-1;i++){
            ans=(ans+dp[n-1][i])%mod;
        }
        ans=(total-ans+mod)%mod;
        return ans;

        // return dp[n-1][k];



    }
};


// int main(){
//     string s;
//     cin>>s;
//     int k;
//     cin>>k;
//     Solution s1;
//     cout<<s1.possibleStringCount(s,k);
// }",1434384419
Lt Simon Riley,simon-riley,216,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, ss: List[List[int]], ts: List[List[int]]) -> int:
        dp = [[-1] * n for _ in range(k + 1)]
        
        def solve(d: int, c: int) -> int:
            if d == k:
                return 0
            
            if dp[d][c] != -1:
                return dp[d][c]
            
            m = ss[d][c] + solve(d + 1, c)
            i = 0
        
            while True:
                if i >= n:
                    break
                if i != c:
                    m = max(m, ts[c][i] + solve(d + 1, i))
                i += 1
        
            dp[d][c] = m
            return m

        mx = 0
        j = 0
        while j < n:
            mx = max(mx, solve(0, j))
            j += 1
        
        return mx
",1434297645
Lt Simon Riley,simon-riley,216,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        i = 1

        while i < len(word):
            if word[i] == word[i - 1]:
                res += 1
            i += 1

        return res
",1434274666
Lt Simon Riley,simon-riley,216,3618,python3,"class Solution:
    def possibleStringCount(self, w: str, k: int) -> int:
        M = int(1e9 + 7)
        n = len(w)

        sl = []
        i = 0
        while i < n:
            c = w[i]
            cnt = 1
            i += 1
            while i < n and w[i] == c:
                cnt += 1
                i += 1
            sl.append(cnt)

        ts = len(sl)

        tc = 1  
        for cnt in sl:
            tc = (tc * cnt) % M

        if k <= ts:
            return tc

        mx = k - 1 
        dp = [0] * (mx + 1)
        dp[0] = 1

        for j in range(ts):
            cnt = sl[j]
            new_dp = [0] * (mx + 1)

            cum = 0   
            s = 0

            # while i < n:
            #     c = w[i]
            #     cnt = 0
                
            #     while i < n and w[i] == c:
            #         cnt += 1
            #         i += 1
                    
            #     sl.append(cnt)
                
            while s <= mx:
                if s - 1 >= 0:
                    cum = (cum + dp[s - 1]) % M
                if s - cnt - 1 >= 0:
                    cum = (cum - dp[s - cnt - 1] + M) % M
                new_dp[s] = cum
                s += 1
            dp = new_dp

        tlk = 0  
        s = ts
        while s <= mx:
            tlk = (tlk + dp[s]) % M
            s += 1

        return (int((tc - tlk + M) % M))
",1434385314
ARYAN SATIJA,__ARYAN1__,217,3587,cpp,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007

#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvll vector<vector<long long int>>
#define vc vector<char>
#define vll vector<long long>
#define mii map<int, int>
#define mll map<long long, long long>
#define umii unordered_map<int, int>
#define si set<int>
#define sll set<long long>
#define msll multiset<long long>
#define rep(i, s, e) for (ll i = s; i <= e; i++)
#define ren(i, s, e) for (ll i = s; i >= e; i--)

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vvi dp(k+1, vi(n+1, 0));    
        ren(i, k-1, 0){
            rep(j, 0, n-1){
                dp[i][j] = stayScore[i][j] + dp[i+1][j];
                rep(k, 0, n-1){
                    if(k != j){
                        dp[i][j] = max(dp[i][j], dp[i+1][k] + travelScore[j][k]);
                    }
                }
            }
        }
        int ans = 0;
        rep(i, 0, n-1) ans = max(ans, dp[0][i]);
        return ans;
    }
};",1434379015
ARYAN SATIJA,__ARYAN1__,217,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int n = word.size();
        for(int i = 0; i < n;){
            int cnt = 0;
            char ch = word[i];
            while(i < n and word[i] == ch){
                i++;
                cnt++;
            }
            if(cnt > 1) ans += (cnt-1);
        }
        return ans;
    }
};",1434378650
ARYAN SATIJA,__ARYAN1__,217,3618,cpp,"#include <bits/stdc++.h>
using namespace std;

#define mod 1000000007

#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vb vector<bool>
#define vvi vector<vector<int>>
#define vvb vector<vector<bool>>
#define vvc vector<vector<char>>
#define vvll vector<vector<long long int>>
#define vc vector<char>
#define vll vector<long long>
#define mii map<int, int>
#define mll map<long long, long long>
#define umii unordered_map<int, int>
#define si set<int>
#define sll set<long long>
#define msll multiset<long long>
#define rep(i, s, e) for (ll i = s; i <= e; i++)
#define ren(i, s, e) for (ll i = s; i >= e; i--)

class Solution {
public:
    int possibleStringCount(string word, int k) {
        int n = word.size();
        vi cnt;
        for(int i = 0; i < n;){
            char ch = word[i];
            int tot = 0;
            while(i < n and word[i] == ch){
                i++;
                tot++;
            }
            cnt.push_back(tot-1);
        }
        
        
        ll tot = 1;
        for(auto c : cnt){
            tot = (tot * (c + 1))%mod;
        }
        
        ll tar = k - cnt.size();
        if(tar >= 0){
            vll dp(tar+1, 0);
            vll ndp(tar+1, 0);
            dp[0] = 1, ndp[0] = 1;
            for(auto c : cnt){
                ll sum = 0;
                rep(i, 0, tar-1){
                    sum = (sum + dp[i])%mod;
                    if(i - c - 1 >= 0){
                        sum = (sum - dp[i - c - 1] + mod)%mod;
                    }
                    ndp[i] = sum;
                }
                rep(i, 0, tar - 1){
                    dp[i] = ndp[i];
                }
            }   
            ll bad = 0;
            rep(i, 0, tar-1) bad = (bad + dp[i])%mod;
            return (tot - bad + mod)%mod;
        }
        
        return tot;
        
    }
};",1434380311
Divyansh Sikarwar,divyanshsikarwar,218,3587,python3,"class Solution:
    def __init__(self):
        self.dp = []
        self.stay_score = []
        self.travel_score = []
        self.n = 0
        self.k = 0
    
    def rec(self,ik,k,curr,stayScore,travelScore):
        if ik+1 > k:
            return 0


        stay = stayScore[ik][curr]

        ans = 0
        ans = max(ans, rec(ik+1,curr)+stay)

        ts = travelScore[curr]
        for i in range(len(ts)):
            if ts[i] == 0:
                continue
            ans = max(ans, rec(ik+1, i)+ts[i])

        return ans

    def solve(self, day: int, curr: int) -> int:
        if day == self.k:
            return 0
        
        if self.dp[day][curr] != -1:
            return self.dp[day][curr]
        
        
        max_points = self.stay_score[day][curr] + self.solve(day + 1, curr)
        
        
        for next_city in range(self.n):
            if next_city != curr:
                max_points = max(max_points, 
                                 self.travel_score[curr][next_city] + self.solve(day + 1, next_city))
        
        self.dp[day][curr] = max_points
        return max_points

    def maxScore(self, n: int, k: int, stayScore: list[list[int]], travelScore: list[list[int]]) -> int:
        
        self.n = n
        self.k = k
        self.stay_score = stayScore
        self.travel_score = travelScore
        
        
        self.dp = [[-1] * n for _ in range(k + 1)]
        
        
        result = 0
        for start_city in range(n):
            result = max(result, self.solve(0, start_city))
        
        self.rec(0,0,k,stayScore,travelScore)
        
        return result

                ",1434358256
Divyansh Sikarwar,divyanshsikarwar,218,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        ans = 1
        
        for i in range(1, n):
            if word[i-1] == word[i]:
                ans += 1
            
            nice = ""cool""
            wow = ""nice""
            for j in range(100):
                wow = nice
                
        return ans
",1434285531
Divyansh Sikarwar,divyanshsikarwar,218,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MODULO = int(1e9 + 7)
        length = len(word)


        kj = 11
        jj = 0
        for i in range(1023):
            kj+=1
            jj+= k
            nice = {""cool"" : ""nice""}

        # print(j)
        # k = k % 50
        # if k % 4 == 3:
        #     j = 11

        # print(j)
        
        segment_lengths = []
        index = 0
        while index < length:
            count = 1
            current_char = word[index]
            index += 1
            while index < length and word[index] == current_char:
                count += 1
                index += 1
            segment_lengths.append(count)

        total_segments = len(segment_lengths)

        
        total_combinations = 1
        for count in segment_lengths:
            total_combinations = (total_combinations * count) % MODULO

        if k <= total_segments:
            return total_combinations

        max_size = k - 1
        dp = [0] * (max_size + 1)
        dp[0] = 1

        
        for count in segment_lengths:
            new_dp = [0] * (max_size + 1)
            cumulative_sum = 0

            for s in range(max_size + 1):
                if s - 1 >= 0:
                    cumulative_sum = (cumulative_sum + dp[s - 1]) % MODULO
                if s - count - 1 >= 0:
                    cumulative_sum = (cumulative_sum - dp[s - count - 1] + MODULO) % MODULO
                new_dp[s] = cumulative_sum
            
            dp = new_dp

        
        total_less_than_k = 0
        for s in range(total_segments, max_size + 1):
            total_less_than_k = (total_less_than_k + dp[s]) % MODULO

        
        return (total_combinations - total_less_than_k + MODULO) % MODULO
",1434388134
Romain Lhotte,JasonMendoza2008,221,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n: int = len(parent)
        graph: list[set[int]] = [set() for _ in range(n)]
        for i in range(1, n):
            graph[parent[i]].add(i)

        new_parent: list[int] = parent.copy()
        closest_letter: list[int] = [-1] * 26
        def dfs_change(node: int):
            if closest_letter[ord(s[node])-ord('a')] != -1:
                new_parent[node] = closest_letter[ord(s[node])-ord('a')]
            if len(graph[node]) != 0:
                old_closest_letter: int = closest_letter[ord(s[node])-ord('a')]
                closest_letter[ord(s[node])-ord('a')] = node
                for child in graph[node]:
                    dfs_change(child)
                closest_letter[ord(s[node])-ord('a')] = old_closest_letter
        dfs_change(0)

        graph: list[set[int]] = [set() for _ in range(n)]
        for i in range(1, n):
            graph[new_parent[i]].add(i)

        subtree_sizes: list[int] = [0] * n
        def dfs(node: int):
            subtree_sizes[node] = 1
            for child in graph[node]:
                subtree_sizes[node] += dfs(child)
            return subtree_sizes[node]
        dfs(0)
        return subtree_sizes
",1434371684
Romain Lhotte,JasonMendoza2008,221,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans: int = 0

        for i in range(len(word)):
            if i == 0 or word[i] != word[i-1]:
                if i != 0:
                    ans += tmp_that_char - 1
                tmp_that_char = 1
            elif word[i] == word[i-1]:
                tmp_that_char += 1
                
        ans += tmp_that_char - 1
        return ans + 1

",1434270159
Romain Lhotte,JasonMendoza2008,221,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        mod: int = 10**9 + 7

        islands: list[int] = []

        for i in range(len(word)):
            if i == 0:
                tmp_that_char = 1
            elif word[i] == word[i-1]:
                tmp_that_char += 1
            elif word[i] != word[i-1]:
                islands.append(tmp_that_char)
                tmp_that_char = 1
        islands.append(tmp_that_char)

        all_possibilities: int = 1
        for island_size in islands:
            all_possibilities *= island_size
            all_possibilities %= mod

        if len(islands) > k:
            return all_possibilities

        # dp[i][j] => first i islands (i excluded), final word length j
        dp: list[list[int]] = [[0] * (k + 1) for _ in range(len(islands) + 1)]
        dp[0][0] = 1

        for i in range(1, len(islands) + 1):
            prefix_sum: list[int] = [0] * (k + 2)  # on dp[i-1] row, prefix_sum[j] = up to j-1 included
            for j in range(k + 1):
                prefix_sum[j + 1] = (prefix_sum[j] + dp[i-1][j]) % mod
            for j in range(1, k + 1):
                # sum from j - min(islands[i-1], j) to j - 1
                dp[i][j] = (prefix_sum[j] - prefix_sum[max(0, j - islands[i-1])]) % mod

        sum_ = 0
        for j in range(k):
            sum_ += dp[len(islands)][j] % mod
        return (all_possibilities - sum_) % mod
",1434356997
Anaranya Bose,anaranya02,222,3587,cpp,"class Solution {
public:
   int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        vector<int> dp(n, 0);
        
        for (int d = k - 1; d >= 0; --d) {
            vector<int> next_dp = dp;
            for (int c = 0; c < n; ++c) {
                int stay = s[d][c] + dp[c];
                int move = 0;
                for (int nc = 0; nc < n; ++nc) {
                    if (nc != c) move = max(move, t[c][nc] + dp[nc]);
                }
                next_dp[c] = max(stay, move);
            }
            dp = next_dp;
        }
        
        return *max_element(dp.begin(), dp.end());
    }
};",1434303739
Anaranya Bose,anaranya02,222,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
         map<char,int> m;
        int x=1;
        for(int i=1;i<w.size();i++){
            if(w[i] == w[i-1]){
                x++;
            }
        }
        int ans=1;
        for(auto i : m){
            if(i.second > 1){
                ans+= i.second - 1;
            }
        }
        return x;
    }
};",1434277336
Anaranya Bose,anaranya02,222,3618,cpp,"class Solution {
public:
    int possibleStringCount(string w, int k) {
    const int MOD = 1e9 + 7;
    vector<int> cnts;
    int len = w.length(), idx = 0;

    while (idx < len) {
        char ch = w[idx];
        int cnt = 0;
        while (idx < len && w[idx] == ch) {
            cnt++;
            idx++;
        }
        cnts.push_back(cnt);
    }

    int n = cnts.size();
    long long total = 1;

    for (int c : cnts) {
        total = total * c % MOD;
    }

    if (n > k) {
        return total;
    }

    int rem = k - 1 - n;
    if (rem < 0) {
        return total;
    }

    vector<long long> dp(rem + 1, 0);
    dp[0] = 1;

    for (int c : cnts) {
        int cap = c - 1;
        vector<long long> prefix(rem + 2, 0);

        for (int j = 0; j <= rem; j++) {
            prefix[j + 1] = (prefix[j] + dp[j]) % MOD;
        }

        vector<long long> new_dp(rem + 1, 0);
        for (int j = 0; j <= rem; j++) {
            int l = j - cap;
            if (l < 0) l = 0;
            new_dp[j] = (prefix[j + 1] - prefix[l] + MOD) % MOD;
        }
        dp.swap(new_dp);
    }

    long long ways = 0;
    for (int j = 0; j <= rem; j++) {
        ways = (ways + dp[j]) % MOD;
    }

    return (total - ways + MOD) % MOD;
}


};",1434384932
Alek Jarmov,starlex,223,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0 for _ in range(n)] for _ in range(k + 1)]

        for day in range(1, k + 1):
            for prev_city in range(n):
                for curr_city in range(n):
                    addition = 0
                    if curr_city == prev_city:
                        addition = stayScore[day - 1][curr_city]
                    else:
                        addition = travelScore[prev_city][curr_city]
                    dp[day][curr_city] = max(dp[day][curr_city], dp[day - 1][prev_city] + addition)
        return max(dp[-1])",1434318682
Alek Jarmov,starlex,223,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        prev = """"
        window = 0
        for char in word:
            if prev == char:
                window+=1
            else:
                res += window
                window = 0

            prev = char
        res+= window
        return res",1434263011
Alek Jarmov,starlex,223,3618,python3,"class Solution:
    def possibleStringCount(self, word: str, k: int) -> int:
        MOD = 10 ** 9 + 7
        res = 1
        prev = """"
        window = 1
        windows = []
        total_window_len = 0
        for char in word:
            if prev == char:
                window += 1
            else:
                if window > 1:
                    windows.append(window - 1)
                    total_window_len += window
                window = 1

            prev = char
        if window > 1:
            windows.append(window - 1)
            total_window_len += window
        res += window

        min_target_sum = k - (len(word) - total_window_len)
        min_target_sum -= len(windows)
        total_ways = 1
        for num in windows:
            total_ways = (total_ways * (num + 1)) % MOD

        if min_target_sum <= 0:
            return total_ways

        max_sum = min_target_sum - 1
        dp = [0] * (max_sum + 1)
        dp[0] = 1

        for num in windows:
            dp_new = [0] * (max_sum + 1)
            prefix_sum = [0] * (max_sum + 2)
            for s in range(max_sum + 1):
                prefix_sum[s + 1] = (prefix_sum[s] + dp[s]) % MOD
            for s in range(max_sum + 1):
                l = max(0, s - num)
                dp_new[s] = (prefix_sum[s + 1] - prefix_sum[l]) % MOD
            dp = dp_new

        total_ways_less_than_k = sum(dp) % MOD
        res = (total_ways - total_ways_less_than_k + MOD) % MOD
        return res",1434386733
cute_buns,cute_buns,224,3587,cpp,"class Solution {
public:
    // void printArr(vector<vector<int>>& dp) {
    //     for (int i = 0; i < dp.size(); i++) {
    //         for (int j = 0; j < dp[i].size(); j++) {
    //             cout << dp[i][j] << ' ';            
    //         }cout << '\n';
    //     }
    // }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1, vector<int>(n, 0));
        for (int i = 1; i <= k; i++) { // i-1 is the current day
            for (int j = 0; j < n; j++) { // j is the current city
                for (int h = 0; h < n; h++) {
                    dp[i][h] = max(dp[i][h], dp[i-1][j]+travelScore[j][h]);
                }
            }
            for (int j = 0; j < n; j++) {
                dp[i][j] = max(dp[i][j], dp[i-1][j]+stayScore[i-1][j]);
            }
        }
        // printArr(dp);
        int res = dp[k][n-1];
        for (int i = 0; i < n; i++) {
            res = max(dp[k][i], res);
        }
        return res;
    }
};",1434305194
cute_buns,cute_buns,224,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        int count = 0;
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i-1]) {
                count++;
            } else {
                res += count;
                count = 0;
            }
        }
        return res+count;
    }
};",1434265205
cute_buns,cute_buns,224,3618,cpp,"class Solution {
public:
    void printArr(vector<int>& arr) {
        for (int i = 0; i < arr.size(); i++) {
            cout << arr[i] << ' ';
        } cout << '\n';
    }
    void printArr(vector<long long>& arr) {
        for (int i = 0; i < arr.size(); i++) {
            cout << arr[i] << ' ';
        } cout << '\n';
    }

    int possibleStringCount(string word, int k) {
        long long MOD = (long long)(pow(10,9)+7);
        vector<int> counts;
        int count = 1;
        
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i-1]) {
                count++;
            } else {
                counts.push_back(count);
                count = 1;
            }
        }
        counts.push_back(count);
        int iterations = min((int)counts.size(), k);
        vector<vector<long long>> dp(iterations+1, vector<long long>(k, 0));

        for (int j = 1; j < min(counts[0]+1,k); j++) {
            dp[1][j] = j;
        }
        for (int j = min(counts[0]+1,k); j < k; j++) {
            dp[1][j] = dp[1][j-1];
        }

        for (int i =2 ; i <= iterations; i++) {
            for (int j =1 ; j < k; j++) {
                dp[i][j] = (dp[i-1][j-1]-dp[i-1][max(0,j-counts[i-1]-1)]+dp[i][j-1])%MOD;
            }
        }

        long long total = counts[0];
        for (int i = 1; i < counts.size(); i++) {
            total *= counts[i];
            total %= MOD;
        }
        // printArr(dp[1]);
        // printArr(dp[2]);

        // printArr(dp[iterations]);
        
        // printArr(counts);
        
        return (total-dp[iterations][k-1]+MOD)%MOD;

    }
};",1434387930
alejandroleon0011,alejandroleon0011,226,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> max_scores(n, 0);
        for (int i = k - 1; i >= 0; --i) {
            vector<int> new_max_scores(n, 0);
            for (int city = 0; city < n; ++city) {
                int score = stayScore[i][city] + max_scores[city];
                for (int dest = 0; dest < n; ++dest) {
                    if (dest != city) {
                        score = max(score, travelScore[city][dest] + max_scores[dest]);
                    }
                }
                new_max_scores[city] = score;
            }
            max_scores = new_max_scores;
        }
        int max_score = 0;
        for (auto score : max_scores) {
            max_score = max(max_score, score);
        }
        return max_score;
    }
};",1434294409
alejandroleon0011,alejandroleon0011,226,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 1;
        int n = word.size();
        int i = 0;
        while (i < n) {
            int j = i;
            char ch = word[i];
            while (i < n && ch == word[i]) {
                ++i;
            }
            cnt += i - j - 1;
        }
        return cnt;
    }
};",1434261706
alejandroleon0011,alejandroleon0011,226,3618,cpp,"class Solution {
public:
    int possibleStringCount(string word, int k) {
        vector<int> lengths;
        {
            int n = word.size();
            int i = 0;
            while (i < n) {
                int j = i;
                char ch = word[i];
                while (i < n && word[i] == ch) {
                    ++i;
                }
                lengths.push_back(i - j);
            }
        }
        
        const long long N = 1000000007;
        int m = lengths.size();
        k -= m;
        
        long long sum = 0;
        if (k > 0) {
            vector<long long> dp(k, 0);
            dp[0] = 1;
            
            /*
            for (int i = 0; i < m; ++i) {
                int max_i = lengths[i];
                for (int x = k - 1; x >= 0; --x) {
                    for (int t = 1; t < max_i && x - t >= 0; ++t) {
                        dp[x] = (dp[x] + dp[x - t]) % N;
                    }
                }
            }
            */
            
            for (int max_i : lengths) {
                vector<long long> new_dp(k, 0);
                long long window_sum = 0;
                for (int x = 0; x < k; ++x) {
                    window_sum = (window_sum + dp[x]) % N;
                    if (x >= max_i) {
                        window_sum = window_sum - dp[x - max_i];
                        if (window_sum < 0) {
                            window_sum += N;
                        }
                        else {
                            window_sum %= N;
                        }
                    }
                    new_dp[x] = window_sum;
                }
                dp = move(new_dp);
            }
            
            for (auto x : dp) {
                sum += x;
            }
            sum = sum % N;
        }
        long long prod = 1;
        for (int i = 0; i < m; ++i) {
            prod = (prod * lengths[i]) % N;
        }
        return prod < sum ? prod - sum + N : prod - sum;
    }
};",1434377918
Md. Maksudur Rahman,gin_spirit,228,3587,rust,"impl Solution {
    pub fn max_score(n: i32, k: i32, stay: Vec<Vec<i32>>, travel: Vec<Vec<i32>>) -> i32 {
        let n = n as usize;
        let k = k as usize;
        let mut dp = vec![vec![-1; n]; k + 1];
        
        fn solve(day: usize, curr: usize, n: usize, k: usize, stay: &Vec<Vec<i32>>, travel: &Vec<Vec<i32>>, dp: &mut Vec<Vec<i32>>) -> i32 {
            if day == k { return 0 }
            if dp[day][curr] != -1 { return dp[day][curr] }
            
            let mut max_pts = stay[day][curr] + solve(day + 1, curr, n, k, stay, travel, dp);
            for nxt in 0..n {
                if nxt != curr {
                    max_pts = max_pts.max(travel[curr][nxt] + solve(day + 1, nxt, n, k, stay, travel, dp));
                }
            }
            dp[day][curr] = max_pts;
            max_pts
        }
        (0..n).map(|start| solve(0, start, n, k, &stay, &travel, &mut dp)).max().unwrap()
    }
}",1434329516
Md. Maksudur Rahman,gin_spirit,228,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 1;
        for (int i=0; i<(int)word.size()-1; i++) {
            if (word[i] == word[i+1]) {
                cnt++;
            }
        }
        return cnt;
    }
};
",1434273955
Md. Maksudur Rahman,gin_spirit,228,3618,rust,"impl Solution {
    pub fn possible_string_count(word: String, k: i32) -> i32 {
        const MOD: i32 = 1_000_000_007;
        let n = word.len();
        let mut seg_len = Vec::new();
        let mut i = 0;

        while i < n {
            let cur_char = word.as_bytes()[i];
            let mut count = 0;
            while i < n && word.as_bytes()[i] == cur_char {
                i += 1;
                count += 1;
            }
            seg_len.push(count);
        }

        let t_seg = seg_len.len();
        let mut t_comb: i64 = 1;
        for &len in &seg_len {
            t_comb = (t_comb * len as i64) % MOD as i64;
        }

        if k as usize <= t_seg {
            return t_comb as i32;
        }

        let max_s = k as usize - 1;
        let mut dp = vec![0; max_s + 1];
        dp[0] = 1;

        for &len in &seg_len {
            let mut new_dp = vec![0; max_s + 1];
            let mut cum_sum: i64 = 0;
            for s in 0..=max_s {
                if s > 0 {
                    cum_sum = (cum_sum + dp[s - 1] as i64) % MOD as i64;
                }
                if s > len {
                    cum_sum = (cum_sum - dp[s - len - 1] as i64 + MOD as i64) % MOD as i64;
                }
                new_dp[s] = cum_sum as i32;
            }
            dp = new_dp;
        }

        let mut total_less_k: i64 = 0;
        for s in t_seg..=max_s {
            total_less_k = (total_less_k + dp[s] as i64) % MOD as i64;
        }

        ((t_comb - total_less_k + MOD as i64) % MOD as i64) as i32
    }
}",1434383508
Aryan,AryanMalik2004,230,3576,dart,"import 'dart:io';

class Solution {
  List<int> findSubtreeSizes(List<int> parent, String s) {
    int n = parent.length;
    List<List<int>> children = List.generate(n, (_) => []);
    List<int> answer = List.filled(n, 1);

    // Step 1: Build the initial tree structure
    for (int i = 1; i < n; i++) {
      children[parent[i]].add(i);
    }

    // Step 2: Perform a DFS to modify the tree based on character matching
    void dfs(int node, Map<String, int> ancestorMap) {
      String char = s[node];
      Map<String, int> currentMap = Map.of(ancestorMap); // Create a copy of the ancestor map

      // Check if there's an ancestor with the same character
      if (ancestorMap.containsKey(char)) {
        int closestAncestor = ancestorMap[char]!;
        
        // Reassign the parent of the current node to the closest matching ancestor
        children[parent[node]].remove(node); // Remove node from its current parent's children
        parent[node] = closestAncestor; // Set the new parent
        children[closestAncestor].add(node); // Add node to new parent's children
      }

      // Update the ancestor map with the current node
      currentMap[char] = node;
      
      // Recurse on children
      for (int child in List.from(children[node])) {  // Convert to List to avoid concurrent modification
        dfs(child, currentMap);
      }
    }

    // Step 3: Update the tree starting from the root
    dfs(0, {});

    // Step 4: Calculate subtree sizes in the final tree
    int calculateSubtreeSize(int node) {
      int size = 1;
      for (int child in children[node]) {
        size += calculateSubtreeSize(child);
      }
      answer[node] = size;
      return size;
    }

    calculateSubtreeSize(0);
    return answer;
  }

  void main() {
    print(""Enter the parent array (comma-separated):"");
    List<int> parent = stdin.readLineSync()!.split(',').map(int.parse).toList();

    print(""Enter the string s:"");
    String s = stdin.readLineSync()!;

    List<int> result = findSubtreeSizes(parent, s);
    print(""Subtree sizes: $result"");
  }
}
",1434267215
Aryan,AryanMalik2004,230,3587,dart,"import 'dart:io';
import 'dart:math';

class Solution {
  int maxScore(int n, int k, List<List<int>> stayScore, List<List<int>> travelScore) {
    // DP array to store the maximum points achievable for each day in each city
    List<List<int>> dp = List.generate(k + 1, (_) => List.filled(n, 0));

    // Iterate over each day
    for (int day = 0; day < k; day++) {
      // For each city, calculate points for staying and traveling
      for (int currCity = 0; currCity < n; currCity++) {
        // If the tourist stays in the current city
        dp[day + 1][currCity] = max(dp[day + 1][currCity], dp[day][currCity] + stayScore[day][currCity]);

        // If the tourist travels to another city
        for (int destCity = 0; destCity < n; destCity++) {
          if (currCity != destCity) {
            dp[day + 1][destCity] = max(dp[day + 1][destCity], dp[day][currCity] + travelScore[currCity][destCity]);
          }
        }
      }
    }

    // Find the maximum points achievable by the end of the journey
    return dp[k].reduce(max);
  }

  void main() {
    print(""Enter number of cities (n):"");
    int n = int.parse(stdin.readLineSync()!);

    print(""Enter number of days (k):"");
    int k = int.parse(stdin.readLineSync()!);

    print(""Enter stayScore matrix:"");
    List<List<int>> stayScore = [];
    for (int i = 0; i < k; i++) {
      print(""Enter stay scores for day ${i + 1} (comma-separated):"");
      stayScore.add(stdin.readLineSync()!.split(',').map(int.parse).toList());
    }

    print(""Enter travelScore matrix:"");
    List<List<int>> travelScore = [];
    for (int i = 0; i < n; i++) {
      print(""Enter travel scores for city ${i + 1} (comma-separated):"");
      travelScore.add(stdin.readLineSync()!.split(',').map(int.parse).toList());
    }

    int result = maxScore(n, k, stayScore, travelScore);
    print(""Maximum points the tourist can earn: $result"");
  }
}
",1434275170
Aryan,AryanMalik2004,230,3617,dart,"import 'dart:io';

class Solution {
  int possibleStringCount(String word) {
    int count = 1;  // Start with the original word as a possibility
    int i = 0;

    while (i < word.length) {
      int j = i;
      
      // Move j forward while the characters are the same
      while (j < word.length && word[j] == word[i]) {
        j++;
      }
      
      // Calculate the number of ways to ""decrease"" the character count in this group
      int groupLength = j - i;
      count += groupLength - 1;
      
      // Move i to the start of the next group
      i = j;
    }

    return count;
  }

  void main() {
    print(""Enter the word:"");
    String? word = stdin.readLineSync();
    
    if (word != null) {
      int result = possibleStringCount(word);
      print(""The total number of possible original strings is: $result"");
    } else {
      print(""No input provided."");
    }
  }
}
",1434261861
Ian Wong,ianwong1999,231,3576,cpp,"class Solution {
public:
    vector<int> anc[26];
    vector<int> g[100055];
    vector<int> vg[100055];
    string t;
    
    void dfs(int v, int par = -1) {
        int cur = t[v] - 'a';
        
        if (!anc[cur].empty()) {
            vg[anc[cur].back()].push_back(v);
        } else if (par != -1) {
            vg[par].push_back(v);
        }
        
        anc[cur].push_back(v);
        
        for (auto u : g[v]) if (u != par) {
            dfs(u, v);
        }
        
        anc[cur].pop_back();
    }
    
    int subsize[100055];
    
    void rdfs(int v, int par = -1) {
        subsize[v] = 1;
        
        for (auto u : vg[v]) if (u != par) {
            rdfs(u, v);
            subsize[v] += subsize[u];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        t = s;
        for (int i = 0; i < 26; i++) {
            anc[i].clear();
        }
        
        int n = parent.size();
        
        for (int i = 0; i < n; i++) {
            g[i].clear();
            vg[i].clear();
        }
        for (int i = 1; i < n; i++) g[parent[i]].push_back(i);
        
        dfs(0);
        rdfs(0);
        
        vector<int> res;
        
        for (int i = 0; i < n; i++) res.push_back(subsize[i]);
        return res;
    }
};",1434267854
Ian Wong,ianwong1999,231,3587,cpp,"class Solution {
public:
    int dp[255][255];
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        for (int i = 0; i <= k; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = 0;
            }
        }
        
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < n; j++) {
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + stayScore[i][j]);
                for (int to = 0; to < n; to++) {
                    dp[i + 1][to] = max(dp[i + 1][to], dp[i][j] + travelScore[j][to]);
                }
            }
        }
        
        int res = dp[k][0];
        
        for (int i = 1; i < n; i++) res = max(res, dp[k][i]);
        return res;
    }
};",1434275446
Ian Wong,ianwong1999,231,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int res = 1;
        
        for (int i = 0; i < n; i++) {
            int j = i;
            
            while (j < n && word[i] == word[j]) j++;
            
            if (j == i + 1) continue;
            
            
            res += j - i - 1;
            i = j - 1;
        }
        
        return res;
    }
};",1434260086
Vladislav,timetoai,232,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        childs = defaultdict(list)
        for ch, par in enumerate(parent):
            if par == - 1: continue
            childs[par].append(ch)
        
        def go(i=0, d={}):
            if s[i] in d:
                parent[i] = d[s[i]]
            d[s[i]] = i
            if childs[i]:
                for ch in childs[i][: - 1]:
                    go(ch, d.copy())
                go(childs[i][- 1], d)
            
        go()
        
        childs = defaultdict(list)
        for ch, par in enumerate(parent):
            if par == - 1: continue
            childs[par].append(ch)
        
        @cache
        def go1(i):
            res = 1
            for ch in childs[i]:
                res += go1(ch)
            return res
        
        return [go1(i) for i in range(len(s))]
        ",1434274084
Vladislav,timetoai,232,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def go(i, c):
            if i == k:
                return 0
            return max((stayScore[i][c] if nc == c else travelScore[c][nc]) + go(i + 1, nc) for nc in range(n))
        
        return max(go(0, c) for c in range(n))",1434281318
Vladislav,timetoai,232,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ret = 1
        cur, cnt = word[0], 1
        for ch in word[1:]:
            if ch == cur:
                cnt += 1
            else:
                ret += cnt - 1
                cur, cnt = ch, 1
        return ret + cnt - 1
        ",1434260882
Intellegent,Intellegent,234,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.length();
        vector<vector<int>> g(n);

        for (int i = 1; i < n; i++){
            g[i].push_back(parent[i]);
            g[parent[i]].push_back(i);
        }

        vector<int> ans(n, -1);
        vector<int> f(26, -1);
        auto dfs = [&](auto self, int c, int p) -> void{
            ans[c] = f[s[c] - 'a'];
            f[s[c] - 'a'] = c;
            
            for (int x : g[c]){
                if (x == p) continue;
                self(self, x, c);
            }

            f[s[c] - 'a'] = ans[c];
        };
        dfs(dfs, 0, -1);

        g.assign(n, vector<int>());
        for (int i = 1; i < n; i++){
            if (ans[i] == -1) ans[i] = parent[i];
            g[i].push_back(ans[i]);
            g[ans[i]].push_back(i);
        }

        vector<int> res(n);
        auto dfs2 = [&](auto self, int c, int p) -> int{
            res[c] = 1;
            for (int x : g[c]){
                if (x == p) continue;
                res[c] += self(self, x, c);
            }

            return res[c];
        };
        dfs2(dfs2, 0, -1);
        return res;
    }
};",1434275881
Intellegent,Intellegent,234,3587,cpp,"class Solution {
public:
    int maxScore(int n, int sz, vector<vector<int>>& a, vector<vector<int>>& b) {
        vector<vector<int>> dp(sz + 1, vector<int>(n));
        for (int i = 0; i < sz; i++){
            for (int j = 0; j < n; j++){
                for (int k = 0; k < n; k++){
                    int dif = b[j][k];
                    if (j == k) dif = a[i][k];
                    dp[i + 1][k] = max(dp[i + 1][k], dp[i][j] + dif);
                }
            }
        }

        int mx = 0;
        for (int i = 0; i < n; i++){
            mx = max(mx, dp[sz][i]);
        }

        return mx;
    }
};",1434283660
Intellegent,Intellegent,234,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for (int i = 0; i < word.length() - 1; i++){
            if (word[i] == word[i + 1]) ans++;
        }

        return ans;
    }
};",1434260843
Otabek Kholmirzaev,otabek_kholmirzaev,235,3576,csharp,"public class Solution {
    public int[] FindSubtreeSizes(int[] parent, string s) {
        int n = parent.Length;
        List<List<int>> adj = new List<List<int>>(n);
        for (int i = 0; i < n; i++) {
            adj.Add(new List<int>());
        }

        for (int i = 1; i < n; i++) {
            adj[parent[i]].Add(i);
        }

        int[] newParent = new int[n];
        Array.Fill(newParent, -1);
        Stack<int> stack = new Stack<int>();
        Dictionary<char, List<int>> anc = new Dictionary<char, List<int>>();

        void DFS(int node) {
            char c = s[node];
            if (!anc.ContainsKey(c)) {
                anc[c] = new List<int>();
            }

            if (anc[c].Count > 0) {
                newParent[node] = anc[c][^1];
            }

            anc[c].Add(node);

            foreach (var child in adj[node]) {
                DFS(child);
            }

            anc[c].RemoveAt(anc[c].Count - 1);
        }

        DFS(0);

        List<List<int>> final = new List<List<int>>(n);
        for (int i = 0; i < n; i++) {
            final.Add(new List<int>());
        }

        for (int i = 1; i < n; i++) {
            int p = newParent[i] == -1 ? parent[i] : newParent[i];
            final[p].Add(i);
        }

        int[] answer = new int[n];

        int calc(int node) {
            int size = 1;
            foreach (var child in final[node]) {
                size += calc(child);
            }
            answer[node] = size;
            return size;
        }

        calc(0);

        return answer;
    }
}
",1434285818
Otabek Kholmirzaev,otabek_kholmirzaev,235,3587,csharp,"public class Solution {
    private int[][] dp;
    private int[][] stayScore;
    private int[][] travelScore;
    private int n, k;
    
    public int MaxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.n = n;
        this.k = k;
        this.stayScore = stayScore;
        this.travelScore = travelScore;
        
        dp = new int[k + 1][];
        for (int i = 0; i <= k; i++) {
            dp[i] = new int[n];
            Array.Fill(dp[i], -1);
        }
        
        int max = 0;
        
        for (int start = 0; start < n; start++) {
            max = Math.Max(max, DFS(0, start));
        }
        
        return max;
    }
    
    private int DFS(int day, int cur) {
        
        if (day == k) {
            return 0;
        }
        
        if (dp[day][cur] != -1) {
            return dp[day][cur];
        }
        
        int max = 0;
        
        max = Math.Max(max, 
            stayScore[day][cur] + DFS(day + 1, cur));
        
        for (int next = 0; next < n; next++) {
            if (next != cur) {
                max = Math.Max(max,
                    travelScore[cur][next] + DFS(day + 1, next));
            }
        }
        
        dp[day][cur] = max;
        return max;
    }
}",1434271664
Otabek Kholmirzaev,otabek_kholmirzaev,235,3617,csharp,"public class Solution {
    public int PossibleStringCount(string word) {
        int n = word.Length;

        if (n == 1) return 1;
        
        HashSet<string> set = new HashSet<string>();

        set.Add(word);
        
        for (int i = 0; i < n - 1; i++) {
            if (word[i] == word[i + 1]) {
                int count = 1;
                while (i + count < n && word[i] == word[i + count]) {
                    count++;
                }
                
                for (int j = 1; j < count; j++) {
                    string newStr = word.Substring(0, i + 1) + 
                                     word.Substring(i + 1 + j);
                    set.Add(newStr);
                }
                
                i += count - 1;
            }
        }
        
        return set.Count;
    }
}",1434260521
Manideep Pasumarthi,MadX2702,236,3576,kotlin,"class Solution {
    fun findSubtreeSizes(parent: IntArray, S: String): IntArray {
        val n = parent.size
        val originalTree = Array(n) { mutableListOf<Int>() }
        for (i in 1 until n) {
            originalTree[parent[i]].add(i)
        }
        val newParent = parent.copyOf()
        val lastSeen = IntArray(26) { -1 }
        
        fun dfs(node: Int) {
            val c = S[node] - 'a'
            val prev = lastSeen[c]
            if (prev != -1 && node != 0) {
                newParent[node] = prev
            }
            lastSeen[c] = node
            for (child in originalTree[node]) {
                dfs(child)
            }
            lastSeen[c] = prev
        }
        
        dfs(0)
        
        val newTree = Array(n) { mutableListOf<Int>() }
        for (i in 1 until n) {
            newTree[newParent[i]].add(i)
        }
        
        val answer = IntArray(n)
        
        fun computeSize(node: Int): Int {
            var size = 1
            for (child in newTree[node]) {
                size += computeSize(child)
            }
            answer[node] = size
            return size
        }
        
        computeSize(0)
        return answer
    }
}
",1434283418
Manideep Pasumarthi,MadX2702,236,3587,kotlin,"class Solution {
    fun maxScore(n: Int, k: Int, stayScore: Array<IntArray>, travelScore: Array<IntArray>): Int {
        val dp = Array(k + 1) { IntArray(n) { Int.MIN_VALUE } }
        for (city in 0 until n) {
            dp[0][city] = 0
        }
        for (day in 0 until k) {
            for (curr in 0 until n) {
                if (dp[day][curr] == Int.MIN_VALUE) continue
                val stay = dp[day][curr] + stayScore[day][curr]
                if (stay > dp[day + 1][curr]) {
                    dp[day + 1][curr] = stay
                }
                for (dest in 0 until n) {
                    if (dest == curr) continue
                    val travel = dp[day][curr] + travelScore[curr][dest]
                    if (travel > dp[day + 1][dest]) {
                        dp[day + 1][dest] = travel
                    }
                }
            }
        }
        var max = Int.MIN_VALUE
        for (city in 0 until n) {
            if (dp[k][city] > max) {
                max = dp[k][city]
            }
        }
        return max
    }
}
",1434287469
Manideep Pasumarthi,MadX2702,236,3617,kotlin,"class Solution {
    fun possibleStringCount(word: String): Int {
        if (word.isEmpty()) return 0
        val counts = mutableListOf<Int>()
        var prev = word[0]
        var count = 1
        for (i in 1 until word.length) {
            if (word[i] == prev) {
                count++
            } else {
                counts.add(count)
                prev = word[i]
                count = 1
            }
        }
        counts.add(count)
        var sum = 0
        for (c in counts) {
            if (c > 1) {
                sum += (c - 1)
            }
        }
        return 1 + sum
    }
}
",1434278130
fxe6,hazardouscode,239,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        closest_ancestor = {}
        
        def dfs(node):
            char = s[node]
            prev_ancestor = closest_ancestor.get(char, None)
            closest_ancestor[char] = node
            for child in tree[node]:
                if closest_ancestor.get(s[child], -1) != -1:
                    parent[child] = closest_ancestor[s[child]]
                dfs(child)
            if prev_ancestor is not None:
                closest_ancestor[char] = prev_ancestor
            else:
                del closest_ancestor[char]
        
        dfs(0)
        
        final_tree = defaultdict(list)
        for i in range(1, n):
            final_tree[parent[i]].append(i)
        
        def count_subtree(node):
            total = 1
            for child in final_tree[node]:
                total += count_subtree(child)
            answer[node] = total
            return total
        
        answer = [0] * n
        count_subtree(0)
        
        return answer",1434277152
fxe6,hazardouscode,239,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(day, curr):
            if day == k:
                return 0

            #stay 
            best = stayScore[day][curr] + dp(day+1, curr)
            
            for i in range(n):
                #move
                best = max(best, travelScore[curr][i] + dp(day+1, i))

            return best
        
        ans = 0
        for i in range(n):
            ans = max(ans, dp(0, i))

        return ans",1434288870
fxe6,hazardouscode,239,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 0
        streak = 0
        prev = word[0]
    
        for i in range(len(word)):
            if word[i] == prev:
                streak += 1
            else:
                if streak != 1:
                    count += streak - 1
                streak = 1
            prev = word[i]

        count += streak
            
        return count",1434274807
systumm,rfUWS6azaX,240,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        
        vector<vector<int>> up(26);
        
        auto dfs = [&](auto &&dfs, int u) -> void {
            auto &vec = up[s[u] - 'a'];
            if (!vec.empty()) parent[u] = vec.back();
            vec.push_back(u);
            for (int v : adj[u]) {
                dfs(dfs, v);
            }
            vec.pop_back();
        };
        dfs(dfs, 0);
        
        adj = vector<vector<int>>(n, vector<int>());
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        
        vector<int> ans(n, 0);
        auto dfs2 = [&](auto &&dfs2, int u) -> void {
            ans[u] = 1;
            for (int v : adj[u]) {
                dfs2(dfs2, v);
                ans[u] += ans[v];
            }
        };
        dfs2(dfs2, 0);
        
        return ans;
    }
};",1434276752
systumm,rfUWS6azaX,240,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> scores(k + 1, vector<int>(n, 0));
        scores[0][0] = 0;
        
        for (int i = 0; i < k; i++) {
            for (int u = 0; u < n; u++) {
                for (int v = 0; v < n; v++) {
                    int current = u == v ? stayScore[i][u] : travelScore[u][v];
                    scores[i + 1][v] = max(scores[i + 1][v], scores[i][u] + current);
                }
            }
        }
        
        int ans = 0;
        for (int i = 0; i < n; i++) ans = max(ans, scores[k][i]);
        return ans;
    }
};",1434289116
systumm,rfUWS6azaX,240,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 1;
        
        for (int i = 0; i < n; i++) {
            int j = i;
            while (j < n && word[i] == word[j]) j++;
            int len = j - i;
            ans += len - 1;
            i = j - 1;
        }
        
        return ans;
    }
};",1434260317
Keshav,keshav1303,241,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
    
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }
        
        // Step 2: Track the last ancestor of each character encountered during DFS
        vector<int> newParent(n, -1);
        unordered_map<char, stack<int>> lastAncestor;

        function<void(int)> dfsAdjust = [&](int node) {
            // Save the current node as a potential ancestor for its character
            char currentChar = s[node];
            int originalParent = parent[node];
            
            // Check if we have a valid ancestor for the current character
            if (!lastAncestor[currentChar].empty()) {
                newParent[node] = lastAncestor[currentChar].top();
            } else {
                newParent[node] = originalParent;
            }

            // Push this node as the latest ancestor for its character
            lastAncestor[currentChar].push(node);
            
            // Recursively process the children
            for (int child : tree[node]) {
                dfsAdjust(child);
            }
            
            // Pop from the stack after processing all children to backtrack
            lastAncestor[currentChar].pop();
        };

        // Adjust parent relationships in the modified tree
        dfsAdjust(0);

        // Step 3: Rebuild the new tree based on modified parent relationships
        vector<vector<int>> newTree(n);
        for (int i = 1; i < n; ++i) {
            newTree[newParent[i]].push_back(i);
        }
        
        vector<int> ans(n, 0);
        
        function<int(int)> dfsSize = [&](int node) {
            int subtreeSize = 1; // Count the node itself
            for (int child : newTree[node]) {
                subtreeSize += dfsSize(child); // Add sizes of child subtrees
            }
            ans[node] = subtreeSize;
            return subtreeSize;
        };
        
        dfsSize(0); 

        return ans;
    }
};",1434268554
Keshav,keshav1303,241,3587,cpp,"class Solution {
public:
    int N; 
    
    int dfs(int day, int city, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& dp) {
        if (day == k) {
            return 0;
        }
        
        if (dp[day][city] != -1) {
            return dp[day][city];
        }

        // Option 1
        int maxPoints = stayScore[day][city] + dfs(day + 1, city, k, stayScore, travelScore, dp);

        // Option 2
        for (int dest = 0; dest < N; ++dest) {
            if (city != dest) { 
                maxPoints = max(maxPoints, travelScore[city][dest] + dfs(day + 1, dest, k, stayScore, travelScore, dp));
            }
        }
        return dp[day][city] = maxPoints;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        N = n;
        vector<vector<int>> dp(k, vector<int>(n, -1));
        int maxEarnedPoints = 0;
        for (int i = 0; i < n; ++i) {
            maxEarnedPoints = max(maxEarnedPoints, dfs(0, i, k, stayScore, travelScore, dp));
        }
        return maxEarnedPoints;
    }
};",1434290576
Keshav,keshav1303,241,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 1;
        int n = word.size();
        for(int i=0 ; i<n ; i++){
            int count = 0;
            while(i+1 < n && word[i] == word[i+1]){
                cnt++;
                i++;
            }
        }
        return cnt;
    }
};",1434264452
Apratim Dutta,apru_02,242,3576,cpp,"
class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();


        vector<vector<int>> children_orig(n, vector<int>());
        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                children_orig[parent[i]].push_back(i);
            }
        }

        vector<int> new_parent = parent;

        vector<int> last_seen(256, -1);


        dfs1(0, children_orig, s, new_parent, last_seen);


        vector<vector<int>> children_new(n, vector<int>());
        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                children_new[new_parent[i]].push_back(i);
            }
        }


        vector<int> answer(n, 0);
        compute_subtree_size(0, children_new, answer);

        return answer;
    }

private:

    void dfs1(int node, const vector<vector<int>>& children_orig,
              const string& s, vector<int>& new_parent,
              vector<int>& last_seen) {
        char c = s[node];
        int y = last_seen[static_cast<unsigned char>(c)];

        if (node != 0 && y != -1) {
            new_parent[node] = y;
        }

        int prev = last_seen[static_cast<unsigned char>(c)];

        last_seen[static_cast<unsigned char>(c)] = node;


        for (auto child : children_orig[node]) {
            dfs1(child, children_orig, s, new_parent, last_seen);
        }

        last_seen[static_cast<unsigned char>(c)] = prev;
    }

 
    int compute_subtree_size(int node, const vector<vector<int>>& children_new,
                             vector<int>& answer) {
        int size = 1; 
        for (auto child : children_new[node]) {
            size += compute_subtree_size(child, children_new, answer);
        }
        answer[node] = size;
        return size;
    }
};",1434283588
Apratim Dutta,apru_02,242,3587,cpp,"#include <algorithm>
#include <climits>
#include <utility>
#include <vector>

using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelScore) {

        vector<int> dp_prev(n, 0);
        vector<int> dp_current(n, 0);

        for (int city = 0; city < n; ++city) {

            int stay = stayScore[0][city];
            int travel = INT32_MIN;
            for (int prev_city = 0; prev_city < n; ++prev_city) {
                if (prev_city != city) {
                    travel = max(travel, travelScore[prev_city][city]);
                }
            }
            dp_current[city] = max(stay, travel);
        }

        dp_prev = dp_current;

        for (int day = 1; day < k; ++day) {
            for (int city = 0; city < n; ++city) {

                int stay = dp_prev[city] + stayScore[day][city];

                int travel = INT32_MIN;
                for (int prev_city = 0; prev_city < n; ++prev_city) {
                    if (prev_city != city) {
                        travel = max(travel, dp_prev[prev_city] +
                                                 travelScore[prev_city][city]);
                    }
                }
                dp_current[city] = max(stay, travel);
            }

            dp_prev = dp_current;
        }

        int max_points = INT_MIN;
        for (int city = 0; city < n; ++city) {
            max_points = max(max_points, dp_prev[city]);
        }
        return max_points;
    }
};
",1434292301
Apratim Dutta,apru_02,242,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int curr = 1;
        int ans = 0;
        for(int i = 1;i<word.size();i++){
            if(word[i]==word[i-1]){
                curr++;
            }
            else{
                ans += curr-1;
                curr = 1;
            }
        }
        ans+=curr-1;
        return ans+1;
    }
};",1434267925
Ammar shaikh,Ammar1510,243,3576,cpp,"class Solution {
public:
vector<int> b[26];
int n;
string s;
static const int N=1e5+5;
vector<int> g[N+1];
int npar[N+1],par[N+1];
vector<int> ans;
void dfs(int u){
    // cout<<u<<"" ""<<s[u]<<endl;
    if(b[s[u]-'a'].size())npar[u]=b[s[u]-'a'].back();
    else npar[u]=par[u];
    
    b[s[u]-'a'].push_back(u);
    for(int v:g[u]){
        dfs(v);
    }
    b[s[u]-'a'].pop_back();
}

void solve(int u){
    ans[u]=1;
    for(int v:g[u]){
        solve(v);
        ans[u]+=ans[v];
    }
}

    vector<int> findSubtreeSizes(vector<int>& parent, string str) {
        s=str;
        n=parent.size();
        for(int i=0;i<n;i++)par[i]=parent[i];
        for(int i=0;i<n;i++)if(par[i]!=-1)g[par[i]].push_back(i);
        memset(npar,-1,sizeof(npar));
        dfs(0);
        for(int i=0;i<n;i++)g[i].clear();
        for(int i=0;i<n;i++)if(npar[i]!=-1)g[npar[i]].push_back(i);
        ans.resize(n);
        solve(0);

        return ans;
    }
};",1434282809
Ammar shaikh,Ammar1510,243,3587,cpp,"class Solution {
public:
    static const int N=205;
    int dp[N+1][N+1];
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        for(int i=1;i<=k;i++){
            for(int j=0;j<n;j++){
                dp[i][j]=dp[i-1][j]+stayScore[i-1][j];
                for(int k=0;k<n;k++)
                    dp[i][j]=max(dp[i][j],dp[i-1][k]+travelScore[k][j]);
            }
        }
        int ans=0;
        for(int i=0;i<n;i++)ans=max(ans,dp[k][i]);
        return ans;
        
    }
};",1434292986
Ammar shaikh,Ammar1510,243,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int ans=1;
        int n=s.size();
        for(int i=0;i<n;){
         char c=s[i];
            int cnt=0;
            while(i<n && s[i]==c){
                i++;cnt++;
            }
            ans+=cnt-1;
        }
        return ans;
    }
};",1434260406
Wibo,Wibo,244,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n = p.size();
        vector<vector<int>> ch(n);
        for (int i=1; i<n; i++) ch[p[i]].push_back(i);

        vector<int> run(26, -1);
        vector<vector<int>> ch2(n);
        auto dfs = [&](auto &self, int u, int p) -> void {
            int prv = run[s[u]-'a'];
            if (prv != -1) ch2[prv].push_back(u);
            else if (p != -1) ch2[p].push_back(u);
            run[s[u]-'a'] = u;
            for (int v : ch[u]) self(self, v, u);
            run[s[u]-'a'] = prv;
        };
        dfs(dfs, 0, -1);

        vector<int> ans(n);
        auto dfs2 = [&](auto &self, int u) -> void {
            ans[u] = 1;
            for (int v : ch2[u]) {
                self(self, v);
                ans[u] += ans[v];
            }
        };
        dfs2(dfs2, 0);

        return ans;
    }
};",1434275876
Wibo,Wibo,244,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(2, vector<int>(n, 0));
        for (int i=0; i<k; i++) {
            int bi = i&1, bo = !bi;
            for (int j=0; j<n; j++) dp[bi][j] = dp[bo][j] + stayScore[i][j];
            for (int j=0; j<n; j++) {
                for (int k=0; k<n; k++) {
                    dp[bi][j] = max(dp[bi][j], dp[bo][k] + travelScore[k][j]);
                }
            }
        }
        int ans = -1;
        for (int i=0; i<n; i++) ans = max(ans, dp[(k+1)&1][i]);
        return ans;
    }
};",1434285010
Wibo,Wibo,244,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        vector<string> st;
        for (int l=0; l<(int)s.size(); ) {
            int r = l;
            while (r < (int)s.size() && s[l] == s[r]) r++;
            for (int i=l; i<r; i++) st.push_back(s.substr(0, i+1) + s.substr(r, s.size()-r));
            l = r;
        }
        sort(st.begin(), st.end());
        st.resize(unique(st.begin(), st.end()) - st.begin());
        return st.size();
    }
};",1434264499
Bikash kumar Kundu,bikashkundu99,245,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
         int n = parent.length;

        List<List<Integer>> children = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            children.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            children.get(parent[i]).add(i);
        }

        Map<Character, Deque<Integer>> closestAncestor = new HashMap<>();
        for (char ch = 'a'; ch <= 'z'; ch++) {
            closestAncestor.put(ch, new ArrayDeque<>());
        }

        dfsUpdateTree(0, parent, s, closestAncestor, children);

    
        List<List<Integer>> modifiedChildren = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            modifiedChildren.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            modifiedChildren.get(parent[i]).add(i);
        }

        int[] answer = new int[n];
        dfsCalculateSizes(0, modifiedChildren, answer);

        return answer;
    }
    public void dfsUpdateTree(int node, int[] parent, String s, Map<Character, Deque<Integer>> closestAncestor, List<List<Integer>> children) {
        char ch = s.charAt(node);

        if (!closestAncestor.get(ch).isEmpty()) {
            int ancestor = closestAncestor.get(ch).peek();
            parent[node] = ancestor;
        }

        closestAncestor.get(ch).push(node);

        for (int child : children.get(node)) {
            dfsUpdateTree(child, parent, s, closestAncestor, children);
        }

        closestAncestor.get(ch).pop();
    }

    public int dfsCalculateSizes(int node, List<List<Integer>> modifiedChildren, int[] answer) {
        int size = 1;

        for (int child : modifiedChildren.get(node)) {
            size += dfsCalculateSizes(child, modifiedChildren, answer);
        }

        answer[node] = size;
        return size;
    }
}",1434275440
Bikash kumar Kundu,bikashkundu99,245,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
       int[][] dp = new int[k][n];

        // Initialize dp for day 0 considering the maximum travel and stay scores
        for (int j = 0; j < n; j++) {
            dp[0][j] = stayScore[0][j];
            for (int prevCity = 0; prevCity < n; prevCity++) {
                dp[0][j] = Math.max(dp[0][j], travelScore[prevCity][j]);
            }
        }

        // Process each day after day 0
        for (int i = 1; i < k; i++) {
            int[] maxPointsPreviousDay = new int[n];
            System.arraycopy(dp[i - 1], 0, maxPointsPreviousDay, 0, n);

            for (int j = 0; j < n; j++) {
                // Calculate points if staying in the same city
                dp[i][j] = maxPointsPreviousDay[j] + stayScore[i][j];

                // Calculate points if traveling from any city prevCity to city j
                for (int prevCity = 0; prevCity < n; prevCity++) {
                    dp[i][j] = Math.max(dp[i][j], maxPointsPreviousDay[prevCity] + travelScore[prevCity][j]);
                }
            }
        }

        // Find the maximum points after k days
        int maxPoints = 0;
        for (int j = 0; j < n; j++) {
            maxPoints = Math.max(maxPoints, dp[k - 1][j]);
        }

        return maxPoints;
    }
}",1434285061
Bikash kumar Kundu,bikashkundu99,245,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        Set<String> uniqueStrings = new HashSet<>();
        uniqueStrings.add(word);

        int n = word.length();

        for (int i = 0; i < n; i++) {
            int j = i;
            while (j < n && word.charAt(j) == word.charAt(i)) {
                j++;
            }

            int count = j - i; 
            if (count > 1) {
                for (int k = 1; k < count; k++) {
                    String possibleOriginal = word.substring(0, i) +
                            word.substring(i, i + k) +
                            word.substring(j);
                    uniqueStrings.add(possibleOriginal);
                }
            }

            i = j - 1;
        }

        return uniqueStrings.size();
    }
}",1434265622
Pratyush Raman,therealpratyushraman,246,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<Integer>[] adjOriginal = new List[n];
        for (int i = 0; i < n; i++) adjOriginal[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) adjOriginal[parent[i]].add(i);

        int[] newParent = parent.clone();
        int[] charToNode = new int[26];
        Arrays.fill(charToNode, -1);

        dfs(0, adjOriginal, s, newParent, charToNode);

        List<Integer>[] adjNew = new List[n];
        for (int i = 0; i < n; i++) adjNew[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) adjNew[newParent[i]].add(i);

        int[] answer = new int[n];
        computeSizes(0, adjNew, answer);
        return answer;
    }

    private void dfs(int x, List<Integer>[] adj, String s, int[] newParent, int[] charToNode) {
        int c = s.charAt(x) - 'a';
        int prev = charToNode[c];
        if (prev != -1 && x != 0) newParent[x] = prev;
        charToNode[c] = x;
        for (int y : adj[x]) dfs(y, adj, s, newParent, charToNode);
        charToNode[c] = prev;
    }

    private int computeSizes(int x, List<Integer>[] adj, int[] answer) {
        int size = 1;
        for (int y : adj[x]) size += computeSizes(y, adj, answer);
        answer[x] = size;
        return size;
    }
}
",1434284390
Pratyush Raman,therealpratyushraman,246,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k + 1][n];
        for (int i = 0; i < n; i++) dp[0][i] = 0;
        for (int day = 0; day < k; day++) {
            int[] next = new int[n];
            for (int city = 0; city < n; city++) {

                next[city] = Math.max(next[city], dp[day][city] + stayScore[day][city]);

                for (int dest = 0; dest < n; dest++) {
                    if (dest != city) {
                        next[dest] = Math.max(next[dest], dp[day][city] + travelScore[city][dest]);
                    }
                }
            }
            dp[day + 1] = next;
        }
        int max = 0;
        for (int score : dp[k]) max = Math.max(max, score);
        return max;
    }
}
",1434272694
Pratyush Raman,therealpratyushraman,246,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int total = 1, n = word.length();
        for (int i = 0; i < n;) {
            char c = word.charAt(i++);
            int count = 1;
            while (i < n && word.charAt(i) == c) {
                i++; count++;
            }
            if (count > 1) total += count - 1;
        }
        return total;
    }
}
",1434293732
khanghn,khanghn,247,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
    
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)

        last_seen = {}
        new_parent = list(parent) 

        def adjust_parents(node):
            char = s[node]
            previous_ancestor = last_seen.get(char, None)

            if previous_ancestor is not None:
                new_parent[node] = previous_ancestor  

            last_seen[char] = node

            for child in tree[node]:
                adjust_parents(child)

            if previous_ancestor is None:
                del last_seen[char]
            else:
                last_seen[char] = previous_ancestor

        adjust_parents(0)

        final_tree = defaultdict(list)
        for i in range(1, n):
            final_tree[new_parent[i]].append(i)

        subtree_size = [0] * n

        def calculate_subtree_size(node):
            size = 1  
            for child in final_tree[node]:
                size += calculate_subtree_size(child)
            subtree_size[node] = size
            return size

        calculate_subtree_size(0)

        return subtree_size",1434274719
khanghn,khanghn,247,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
       

        dp = [[-float('inf')] * n for _ in range(k)]

        for j in range(n):
            dp[0][j] = stayScore[0][j]

            for m in range(n):
                if m != j:
                    dp[0][j] = max(dp[0][j], travelScore[m][j])

        for i in range(1, k):
            for j in range(n):
                dp[i][j] = dp[i-1][j] + stayScore[i][j]
                for m in range(n):
                    if m != j:
                        dp[i][j] = max(dp[i][j], dp[i-1][m] + travelScore[m][j])

        return max(dp[k-1])",1434286648
khanghn,khanghn,247,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        from itertools import groupby

        result = 1

        for _, group in groupby(word):
            group_length = len(list(group))
            print(group_length, group)
            result += group_length - 1

        return result",1434270297
Shashwat Tripathi,Fkaiser7,248,3576,cpp,"class Solution {
public:
    void dfs(int i,int par,vector<int>adj[],vector<int>&parent,string &s,
vector<vector<int>>&v){
        int c=s[i]-'a';
        int k=parent[i];
        if(v[c].size()){
            parent[i]=v[c].back();
        }
        v[c].push_back(i);
        for(auto it:adj[i]){
            if(it!=k){
                dfs(it,i,adj,parent,s,v);
            }
        }
        v[c].pop_back();
}
int dfs(int i,int par,vector<int>adj[],vector<int>&ans){
    int val=1;
    for(auto it:adj[i]){
        if(it!=par){
            val+=dfs(it,i,adj,ans);
        }
    }
    ans[i]=val;
    return val;
}
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<vector<int>>v(26);
        int n=s.length();
        vector<int>adj[n];
        for(int i=1;i<parent.size();i++){
            adj[parent[i]].push_back(i);
        }
        dfs(0,-1,adj,parent,s,v);
        vector<int>adj1[n];
        for(int i=1;i<n;i++){
            adj1[parent[i]].push_back(i);
        }
        vector<int>ans(n);
        dfs(0,-1,adj1,ans);
        return ans;
    }
};",1434277321
Shashwat Tripathi,Fkaiser7,248,3587,cpp,"class Solution {
public:
    int fuc(int i,int j,vector<vector<int>>& v1, vector<vector<int>>& v2,
vector<vector<int>>&dp){
        int k=v1.size();
        int n=v2.size();
        if(i==k){
            return 0;
        }
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        int s=0;
        for(int k=0;k<n;k++){
            if(k==j){
                s=max(s,v1[i][k]+fuc(i+1,k,v1,v2,dp));
            }
            else{
                s=max(s,v2[j][k]+fuc(i+1,k,v1,v2,dp));
            }
        }
        return dp[i][j]=s;
}
    int maxScore(int n, int k, vector<vector<int>>& v1, vector<vector<int>>& v2) {
        vector<vector<int>>dp(k,vector<int>(n,-1));
        int ma=0;
        for(int i=0;i<n;i++){
            ma=max(ma,fuc(0,i,v1,v2,dp));
        }
        return ma;
    }
};",1434287095
Shashwat Tripathi,Fkaiser7,248,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int ans=1;
        for(int i=0;i<s.length();){
            int j=i;
            int c=0;
            while(j<s.length()&&s[j]==s[i]){
                c++;
                j++;
            }
            ans+=c-1;
            i=j;
        }
        return ans;
    }
};",1434262006
Kuba Ornatek,Ometek,249,3576,python3,"class Solution:
    def DFS(self, node, graph, letters, new_parent, s):
        c = ord(s[node]) - ord('a')
        if (len(letters[c]) != 0):
            new_parent[node] = letters[c][-1]

        letters[c].append(node)

        for v in graph[node]:
            self.DFS(v, graph, letters, new_parent, s)
        
        letters[c].pop()

    def SIZE(self, node, graph, ans):
        curr = 1
        for v in graph[node]:
            self.SIZE(v, graph, ans)
            curr += ans[v]
        ans[node] = curr
        
    
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        graph = [[] for _ in range(n)]
        for i in range(1, len(parent)):
            graph[parent[i]].append(i)

        letters = [[] for _ in range(26)]
        new_parent = parent[:]

        self.DFS(0, graph, letters, new_parent, s)

        graph = [[] for _ in range(n)]
        for i in range(1, len(parent)):
            graph[new_parent[i]].append(i)

        ans = [0] * n

        self.SIZE(0, graph, ans)

        return ans",1434280853
Kuba Ornatek,Ometek,249,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1 for _ in range(n)] for _ in range(k)]  # dp[day][city]

        def solve(day, city, dp):
            # warunki brzegowe
            if (day == -1):
                return 0

            # czy juz policzone
            if (dp[day][city] != -1):
                return dp[day][city]

            # warunki rekurencyjne
            stay = stayScore[day][city] + solve(day - 1, city, dp)
            move = 0

            for prev_city in range(n):
                curr = travelScore[prev_city][city] + solve(day - 1, prev_city, dp)
                move = max(move, curr)

            dp[day][city] = max(stay, move)
            return dp[day][city]

        ans = 0
        for city in range(n):
            ans = max(ans, solve(k - 1, city, dp))

        return ans",1434295097
Kuba Ornatek,Ometek,249,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for i in range(1, len(word)):
            if (word[i] == word[i - 1]):
                ans += 1
        return ans",1434260143
Alok Tiwari,aloktiwari311113,252,3576,cpp,"class Solution {
public:
    int n;
    vector<vector<int>> tree;
    vector<int> np;
    vector<int> last_char;
    vector<vector<int>> new_tree;
    vector<int> szSub;
    string s_input;

    void buildTree(vector<int>& parent) {
        tree.assign(n, vector<int>());
        for(int i = 1; i < n; i++) {
            tree[parent[i]].push_back(i);
        }
    }

    void findP(int node) {
        int idx = s_input[node] - 'a';
        int prev = last_char[idx];
        if(prev != -1 && node != 0){
            np[node] = prev;
        }
        last_char[idx] = node;
        for(auto child: tree[node]){
            findP(child);
        }
        last_char[idx] = prev;
    }

    void buildTree(){
        new_tree.assign(n, vector<int>());
        for(int i = 0; i < n; i++){
            if(np[i] != -1){
                new_tree[np[i]].push_back(i);
            }
        }
    }

    int computeSize(int node){
        for(auto child: new_tree[node]){
            szSub[node] += computeSize(child);
        }
        return szSub[node];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = parent.size();
        s_input = s;
        buildTree(parent);
        np = parent;
        last_char.assign(26, -1);
        findP(0);
        buildTree();
        szSub.assign(n, 1);
        computeSize(0);
        return szSub;
    }
};",1434281239
Alok Tiwari,aloktiwari311113,252,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<vector<int>> result = stay;
        vector<long long> prev(n, 0);
        for(int j=0; j<n; j++) {
            prev[j] = stay[0][j];
            for(int p=0; p<n; p++) {
                if(p != j){
                    prev[j] = max(prev[j], (long long)travel[p][j]);
                }
            }
        }
        for(int d=1; d<k; d++){
            vector<long long> curr(n, 0);
            for(int j=0; j<n; j++){
                curr[j] = prev[j] + stay[d][j];
                for(int p=0; p<n; p++){
                    if(p !=j){
                        curr[j] = max(curr[j], prev[p] + travel[p][j]);
                    }
                }
            }
            prev = curr;
        }
        return *max_element(prev.begin(), prev.end());
        
    }
};",1434289182
Alok Tiwari,aloktiwari311113,252,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> gp;
        int n = word.size();
        int i = 0;

        while (i < n) {
            char curr = word[i];
            int count = 1;
            i++;
            while (i < n && word[i] == curr) {
                count++;
                i++;
            }
            gp.push_back(count);
        }

        
        int total = 1; 
        for (auto cnt : gp) {
            if (cnt > 1) {
                total += (cnt - 1);
            }
        }

        return total;
    }
};",1434268257
Zamfirescu George-Iulian,SkinnySnakeLimb,253,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        graph = [[] for _ in range(n)]

        for node, parentid in enumerate(parent):
            if parentid < 0:
                continue
            graph[parentid].append(node)
            

        closests = [-1] * n
        def find(node, byChar):
            c = s[node]
            cid = ord(c) - ord('a')
            if byChar[cid] != -1:
                closests[node] = byChar[cid]
            byChar[cid] = node
            for child in graph[node]:
                find(child, byChar.copy())

        find(0, [-1] * 26)

        parent = [parent[node] if closests[node] == -1 else closests[node] for node in range(n)]

        graph = [[] for _ in range(n)]

        for node, parentid in enumerate(parent):
            if parentid < 0:
                continue
            graph[parentid].append(node)

        sizes = [0] * n
        def findSizes(node):
            ret = 1

            for child in graph[node]:
                ret += findSizes(child)

            sizes[node] = ret
            return ret

        findSizes(0)

        return sizes

            ",1434285617
Zamfirescu George-Iulian,SkinnySnakeLimb,253,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        scores = [0] * n

        for day in range(k):
            newSc = [0] * n
            for u in range(n):
                for v in range(n):
                    if u == v:
                        newSc[u] = max(newSc[u], scores[u] + stayScore[day][u])
                    else:
                        newSc[v] = max(newSc[v], scores[u] + travelScore[u][v])
            scores = newSc

        return max(scores)",1434297592
Zamfirescu George-Iulian,SkinnySnakeLimb,253,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        reps = 0
        ch = -1
        ret = 1
        
        for c in word:
            if c != ch:
                if reps >= 2:
                    ret += reps - 1
                reps = 1
                ch = c
            else:
                reps += 1

        if reps >= 2:
            ret += reps - 1

        return ret",1434260838
MrRobot,Noah_will,254,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        int[] newParent = new int[n];
        int[] lastNode = new int[26];
        Arrays.fill(lastNode, -1);
        newParent[0] = -1;
        for (int i = 1; i < n; i++) {
            newParent[i] = parent[i];
        }
        List<Integer>[] tree = new ArrayList[n];
        for (int i = 0; i < n; i++) tree[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            tree[parent[i]].add(i);
        }
        dfs(0, s, lastNode, newParent, tree);
        List<Integer>[] newTree = new ArrayList[n];
        for (int i = 0; i < n; i++) newTree[i] = new ArrayList<>();
        for (int i = 1; i < n; i++) {
            int p = newParent[i];
            newTree[p].add(i);
        }
        int[] subtreeSize = new int[n];
        computeSize(0, newTree, subtreeSize);
        return subtreeSize;
    }

    private void dfs(int node, String s, int[] lastNode, int[] newParent, List<Integer>[] tree) {
        int c = s.charAt(node) - 'a';
        int prevLastNode = lastNode[c];
        if (lastNode[c] != -1 && node != 0) {
            newParent[node] = lastNode[c];
        }
        lastNode[c] = node;
        for (int child : tree[node]) {
            dfs(child, s, lastNode, newParent, tree);
        }
        lastNode[c] = prevLastNode;
    }

    private int computeSize(int node, List<Integer>[] tree, int[] subtreeSize) {
        int size = 1;
        for (int child : tree[node]) {
            size += computeSize(child, tree, subtreeSize);
        }
        subtreeSize[node] = size;
        return size;
    }
}
",1434275157
MrRobot,Noah_will,254,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k][n];
        for (int day = 0; day < k; day++) {
            for (int currCity = 0; currCity < n; currCity++) {
                if (day == 0) {
                    
                    dp[day][currCity] = stayScore[day][currCity];
                    
                    for (int prevCity = 0; prevCity < n; prevCity++) {
                        int points = travelScore[prevCity][currCity];
                        dp[day][currCity] = Math.max(dp[day][currCity], points);
                    }
                } else {
                    
                    dp[day][currCity] = dp[day - 1][currCity] + stayScore[day][currCity];
                    
                    for (int prevCity = 0; prevCity < n; prevCity++) {
                        int points = dp[day - 1][prevCity] + travelScore[prevCity][currCity];
                        dp[day][currCity] = Math.max(dp[day][currCity], points);
                    }
                }
            }
        }
        int maxPoints = Integer.MIN_VALUE;
        for (int city = 0; city < n; city++) {
            maxPoints = Math.max(maxPoints, dp[k - 1][city]);
        }
        return maxPoints;
    }
}
",1434290046
MrRobot,Noah_will,254,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int total = 1; 
        int n = word.length();
        for (int i = 0; i < n;) {
            char c = word.charAt(i);
            int j = i;
            while (j < n && word.charAt(j) == c) {
                j++;
            }
            int count = j - i;
            if (count > 1) {
                total += count - 1; 
            }
            i = j;
        }
        return total;
    }
}",1434267208
Facundo Galn,facug91,256,3576,cpp,"
static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
private:
	void update(vector<vector<int>>& tree, vector<int>& parent, string& s, vector<int>& curr, int u) {
		int tmp = curr[s[u]];
		if (tmp != -1)
			parent[u] = tmp;
		curr[s[u]] = u;
		for (int v: tree[u])
			update(tree, parent, s, curr, v);
		curr[s[u]] = tmp;
	}

public:
	vector<int> findSubtreeSizes(vector<int>& parent, string s) {
		const int n = (int)parent.size();
		vector<vector<int>> tree(n);
		for (int i = 1; i < n; i++)
			tree[parent[i]].push_back(i);
		vector<int> curr(128, -1);
		update(tree, parent, s, curr, 0);
		vector<int> sizes(n, 0), indegree(n, 0);
		for (int i = 1; i < n; i++)
			indegree[parent[i]]++;
		queue<int> q;
		for (int i = 0; i < n; i++)
			if (indegree[i] == 0)
				q.push(i);
		while (!q.empty()) {
			int u = q.front();
			q.pop();
			sizes[u]++;
			if (u == 0) break;
			sizes[parent[u]] += sizes[u];
			indegree[parent[u]]--;
			if (indegree[parent[u]] == 0)
				q.push(parent[u]);
		}
		return sizes;
	}
};",1434287487
Facundo Galn,facug91,256,3587,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
	vector<vector<int>> DP;
	int n, k;

	int dp(int day, int city, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
		if (day == k) return 0;
		int& res = DP[day][city];
		if (res != -1) return res;
		res = stayScore[day][city] + dp(day + 1, city, stayScore, travelScore);
		for (int i = 0; i < n; i++)
			if (i != city)
				res = max(res, dp(day + 1, i, stayScore, travelScore) + travelScore[city][i]);
		return res;
	}

public:
	int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
		this->n = n, this->k = k;
		DP.assign(k + 1, vector<int>(n, -1));
		int ans = 0;
		for (int i = 0; i < n; i++)
			ans = max(ans, dp(0, i, stayScore, travelScore));
		return ans;
	}
};",1434298275
Facundo Galn,facug91,256,3617,cpp,"static const int fastIO = [] {
	std::ios_base::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);
	return 0;
}();

class Solution {
public:
	int possibleStringCount(string word) {
		int ans = 1, cnt = 0;
		for (int i = 1; i < word.length(); i++) {
			if (word[i] == word[i - 1]) cnt++;
			else {
				ans += cnt;
				cnt = 0;
			}
		}
		ans += cnt;
		return ans;
	}
};",1434263147
timowendner,timowendner,259,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        down = defaultdict(list)
        for node, (p, l) in enumerate(zip(parent, s)):
            down[p].append((node, l))

        stack = [(-1, chr(ord('z')+1), [-1]*27)]
        seen = set()
        while stack:
            node, letter, prev = stack.pop()
            if node in seen:
                continue
            seen.add(node)
            cur = prev[ord(letter) - ord('a')]
            if cur != -1:
                parent[node] = cur
            prev = prev.copy()
            prev[ord(letter) - ord('a')] = node
            for child, l in down[node]:
                stack.append((child, l, prev))

        down = defaultdict(list)
        for node, p in enumerate(parent):
            down[p].append(node)
        ans = [-1]*len(parent)
        def search(node, graph):
            cur = 1
            for child in graph[node]:
                cur += search(child, graph)
            if node != -1:
                ans[node] = cur
            return cur
        search(-1, down)
        return ans
            ",1434287064
timowendner,timowendner,259,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0]*n
        for i in range(k):
            new = [0]*n
            for cur in range(n):
                for prev in range(n):
                    if cur == prev:
                        new[cur] = max(new[cur], dp[cur]+stayScore[i][cur])
                    else:
                        new[cur] = max(new[cur], dp[prev]+travelScore[prev][cur])
            dp = new
        return max(dp)",1434299088
timowendner,timowendner,259,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        last = None
        for letter in word:
            if letter == last:
                ans += 1
            last = letter
        return ans",1434260092
Sai Krishna,saikrishna17394,261,3576,cpp,"class Solution {
    vector<vector<int>> g;

    void dfs(int u, vector<int>& par, string& s, vector<int> vec) {
        if (vec[s[u] - 'a'] != -1) {
            par[u] = vec[s[u] - 'a'];
        }

        vec[s[u] - 'a'] = u;
        
        for (const auto& v : g[u]) {
            dfs(v, par, s, vec);
        }
    }

    void solve(int u, vector<int>& sz) {
        for (const auto& v : g[u]) {
            solve(v, sz);
            sz[u] += sz[v];
        }
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        g = vector<vector<int>>(n);

        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) {
                g[parent[i]].push_back(i);
            }
        }

        vector<int> v(26, -1);
        dfs(0, parent, s, v);


        for (int i = 0; i < n; i++) {
            g[i].clear();
        }

        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) {
                g[parent[i]].push_back(i);
            }
        }

        vector<int> sz(n, 1);
        solve(0, sz);

        return sz;
    }
};",1434280610
Sai Krishna,saikrishna17394,261,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, 0));

        for (int i = 0; i < n; i++) {
            dp[0][i] = stayScore[0][i];

            for (int j = 0; j < n; j++) {
                dp[0][i] = max(dp[0][i], travelScore[j][i]);
            }
        }

        for (int day = 1; day < k; day++) {
            for (int i = 0; i < n; i++) {
                dp[day][i] = stayScore[day][i] + dp[day - 1][i];

                for (int j = 0; j < n; j++) {
                    dp[day][i] = max(dp[day][i], dp[day - 1][j] + travelScore[j][i]);
                }
            }
        }

        return *max_element(dp[k - 1].begin(), dp[k - 1].end());
    }
};",1434291861
Sai Krishna,saikrishna17394,261,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int len = word.length();
        
        for (int i = 1; i < len; i++) {
            if (word[i] == word[i - 1]) {
                ans++;
            }
        }
        
        return ans;
    }
};",1434262092
Sayantan Chakraborty,cavi4762,262,3576,cpp,"void dfs(vector<int> adj[],vector<int> &par,int u,int vis[],stack<int> t[],const string &s)
{
    vis[u]=1;
    int ci=s[u]-'a';
    if(!t[ci].empty())
        par[u]=t[ci].top();
    t[ci].push(u);
    for(auto v:adj[u])
    {
        if(!vis[v])
            dfs(adj,par,v,vis,t,s);
    }
    t[ci].pop();
}

int dfs2(vector<int> adj[],int u,int vis[],vector<int> &st)
{
    vis[u]=1;
    int c=0;
    for(auto v:adj[u])
    {
        if(!vis[v])
            c+=dfs2(adj,v,vis,st);
    }
    st[u]=c+1;
    return c+1;
}

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        stack<int> t[26];
        int n=par.size();
        vector<int> adj[n];
        int i;
        for(i=1;i<n;i++)
        {
            adj[i].push_back(par[i]);
            adj[par[i]].push_back(i);
        }
        int vis[n];
        memset(vis,0,sizeof(vis));
        dfs(adj,par,0,vis,t,s);
        vector<int> adj2[n];
        memset(vis,0,sizeof(vis));
        for(i=1;i<n;i++)
        {
            adj2[i].push_back(par[i]);
            adj2[par[i]].push_back(i);
        }
        vector<int> st(n,0);
        dfs2(adj2,0,vis,st);
        return st;
    }
};",1434288724
Sayantan Chakraborty,cavi4762,262,3587,cpp,"int dp[201][201];

int solve(vector<vector<int>>& s, vector<vector<int>>& t,int i,int k,int n,int cur)
{
    if(i==k)
        return 0;
    if(dp[i][cur]!=-1)
        return dp[i][cur];
    int ans=0;
    int j;
    for(j=0;j<n;j++)
    {
        if(j==cur)
            ans=max(ans,s[i][cur]+solve(s,t,i+1,k,n,cur));
        else
            ans=max(ans,t[cur][j]+solve(s,t,i+1,k,n,j));
    }
    return dp[i][cur]=ans;
    
}

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp,-1,sizeof(dp));
        int i;
        int ans=0;
        for(i=0;i<n;i++)
            ans=max(ans,solve(stayScore,travelScore,0,k,n,i));
        return ans;
    }
};",1434299991
Sayantan Chakraborty,cavi4762,262,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int c=0;
        int ans=0;
        char last='#';
        for(auto x:word)
        {
            if(x==last)
            {
                ++c;
            }
            else
            {
                last=x;
                if(c>0)
                ans+=c-1;
                c=1;
            }
        }
        if(c>0)
            ans+=c-1;
        ans++;
        return ans;
    }
};",1434264320
BgykOWjKnD,BgykOWjKnD,263,3576,cpp,"#include <vector>
#include <unordered_map>
#include <stack>
#include <functional>

using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string& s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        
        // Step 1: Build the initial tree structure
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        // Step 2: Rewire nodes based on closest ancestor with the same character
        vector<int> new_parent(n, -1);
        unordered_map<char, stack<int>> ancestor_stack;  // Stack for each character to track closest ancestor

        function<void(int)> dfsRewire = [&](int node) {
            char ch = s[node];

            // Check if there's a previous ancestor with the same character
            if (!ancestor_stack[ch].empty()) {
                new_parent[node] = ancestor_stack[ch].top();  // Rewire to closest ancestor with same character
            } else {
                new_parent[node] = parent[node];  // Keep original parent if no ancestor found
            }

            // Push current node to the stack for this character
            ancestor_stack[ch].push(node);
            
            for (int child : tree[node]) {
                dfsRewire(child);
            }

            // Backtrack: pop the current node from the stack
            ancestor_stack[ch].pop();
        };

        dfsRewire(0);  // Start DFS from the root node (0)

        // Step 3: Build the final tree after rewiring
        vector<vector<int>> final_tree(n);
        for (int i = 1; i < n; ++i) {
            if (new_parent[i] != -1 && new_parent[i] != parent[i]) {
                final_tree[new_parent[i]].push_back(i);
            } else {
                final_tree[parent[i]].push_back(i);
            }
        }

        // Step 4: Calculate subtree sizes using DFS
        vector<int> answer(n, 0);

        function<int(int)> dfsCount = [&](int node) {
            int size = 1;
            for (int child : final_tree[node]) {
                size += dfsCount(child);
            }
            answer[node] = size;
            return size;
        };

        dfsCount(0);  // Start DFS from the root node (0)
        
        return answer;
    }
};
",1434287883
BgykOWjKnD,BgykOWjKnD,263,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        auto a = make_pair(stayScore, travelScore);

        vector<vector<int>> memo(k, vector<int>(n, -1));

        function<int(int, int)> dfs = [&](int day, int city) {
            if (day == k) return 0;

            if (memo[day][city] != -1) return memo[day][city];

            int maxPoints = 0;

            // Option 1: Stay in the current city
            maxPoints = max(maxPoints, stayScore[day][city] + dfs(day + 1, city));

            // Option 2: Travel to a different city
            for (int next_city = 0; next_city < n; ++next_city) {
                if (next_city != city) {  
                    // Move only if different
                    maxPoints = max(maxPoints, travelScore[city][next_city] + dfs(day + 1, next_city));
                }
            }

            return memo[day][city] = maxPoints;
        };

        int maxPoints = 0;
        for (int start_city = 0; start_city < n; ++start_city) {
            maxPoints = max(maxPoints, dfs(0, start_city));
        }

        return maxPoints;
    }
};
",1434292844
BgykOWjKnD,BgykOWjKnD,263,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        
        int ans = 1;
        
        for(int i = 1; i < n; i++){
            if(word[i] == word[i-1]) ans++;
        }
        
        return ans;
    }
};",1434267781
abhishek vaish,abhishekvaish,264,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for i in range(n)]
        for i in range(n):
            if parent[i] != -1:
                adj[parent[i]].append(i)
        
        def dfs(i,last):
            c = ord(s[i]) - ord('a')
            if last[c] != -1:
                parent[i] = last[c]
            last = last[:]
            last[c] = i 
            for v in adj[i]:
                dfs(v,last)
        
        # print(adj)
        # print(parent)
        dfs(0,[-1]*26)
        # print(parent)
        adj = [[] for i in range(n)]
        for i in range(n):
            if parent[i] != -1:
                adj[parent[i]].append(i)
                
        tree_size = [1] * n
        def dfs2(u):
            for v in adj[u]:
                tree_size[u] += dfs2(v)
            return tree_size[u]
        dfs2(0)
        return tree_size
            
            
            

                
      ",1434290828
abhishek vaish,abhishekvaish,264,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        def DP(u,d):
            if d == k: return 0 
            if memo[u][d] != -1: return memo[u][d]
            mx = stayScore[d][u] + DP(u,d+1)
            for v in range(n):
                mx = max( mx , travelScore[u][v] + DP(v,d+1))
            memo[u][d] = mx
            return mx 
        
        memo = [ [-1]*k for i in range(n)]
        return max([ DP(i,0) for i in range(n) ])",1434300631
abhishek vaish,abhishekvaish,264,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        curr , c = '', 1
        n = len(word)
        res = 1
        for i in range(n):
            if curr == word[i]:
                c += 1
                continue 
                
            res += c-1
            curr = word[i]
            c = 1
        res += c-1
        return res 
            
        ",1434263648
Burger Monstah,WRWRW,265,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        children = defaultdict(list)
        for i, p in enumerate(parent):
            children[p].append(i)
        new_graph = {0: -1}
        def go(node, parent, prev):
            if s[node] not in prev:
                new_graph[node] = parent
            else:
                new_graph[node] = prev[s[node]]
            
            nprev = {k: v for k, v in prev.items()}
            nprev[s[node]] = node
            for child in children[node]:
                if child != parent:
                    go(child, node, nprev)
    
        go(0, None, {})
        new_children = defaultdict(list)
        for k, v in new_graph.items():
            new_children[v].append(k)
        if None in new_children:
            del new_children[None]
        # print(new_children)
        res = [0] * len(s)
        def go2(node): 
            tmp = 1
            for child in new_children[node]:
                tmp += go2(child)
            res[node] = tmp
            return tmp
        go2(0)
        return res",1434291738
Burger Monstah,WRWRW,265,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @lru_cache(None)
        def go(day, city):
            if day > k:
                return 0
            res = 0
            for nxt_city in range(n):
                if nxt_city == city:
                    res = max(res, stayScore[day - 1][city] + go(day + 1, nxt_city))
                else:
                    res = max(res, travelScore[city][nxt_city]  + go(day + 1, nxt_city))
            return res
        
        return max(go(1, city) for city in range(n))",1434301114
Burger Monstah,WRWRW,265,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int: 
        v = []
        for c in word:
            if not v:
                v.append([c, 1])
                continue
            if c == v[-1][0]:
                v[-1][1] += 1
            else:
                v.append([c, 1])
        # print(v)
        res = 0
        for c, ct in v:
            res += ct - 1
            
        return res + 1",1434272369
skyinde2,skyinde2,266,3576,python3,"

class Solution:
    def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        
        for i in range(1, n):
            children[parent[i]].append(i)
        
        stack = [[] for _ in range(26)]

        def dfs0(i: int):
            index = ord(s[i]) - 97

            if len(stack[index]):
                parent[i] = stack[index][-1]

            stack[index].append(i)

            for j in children[i]:
                dfs0(j)

            stack[index].pop()
        
        dfs0(0)
        ret = [0] * n
        children = [[] for _ in range(n)]

        for i in range(1, n):
            children[parent[i]].append(i)

        def dfs1(i: int) -> int:
            cnt = 1
            for j in children[i]:
                cnt += dfs1(j)
            ret[i] = cnt
            return cnt
        
        for i in range(n):
            if ret[i] == 0:
                dfs1(i)
        
        return ret






        




",1434276913
skyinde2,skyinde2,266,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: list[list[int]], travelScore: list[list[int]]) -> int:
        dp_ = [0] * n
        dp = [0] * n

        for d in range(k):
            for i in range(n):
                dp[i] = dp_[i] + stayScore[d][i]
                for j in range(n):
                    dp[i] = max(dp[i], dp_[j] + travelScore[j][i])
            dp, dp_ = dp_, dp
        
        return max(dp_)",1434293605
skyinde2,skyinde2,266,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ret = 1

        last = '.'
        for ch in word:
            if last == ch:
                ret += 1
            last = ch

        return ret",1434260114
Xiaomeng Yang,yangxm,267,3576,cpp,"constexpr int MAXN = 100010;
constexpr int MAXM = 32;

int v[MAXN], par[MAXN];
vector<int> adj[MAXN];
vector<int> pre[MAXM];

void DFS1(int x, int p) {
  if (!pre[v[x]].empty()) {
    par[x] = pre[v[x]].back();
  }
  pre[v[x]].push_back(x);
  for (int y : adj[x]) {
    if (y != p) {
      DFS1(y, x);
    }
  }
  pre[v[x]].pop_back();
}

int DFS2(int x, int p, int* ret) {
  int sum = 1;
  for (int y : adj[x]) {
    if (y != p) {
      sum += DFS2(y, x, ret);
    }
  }
  return ret[x] = sum;
}

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
      int n = parent.size();
      for (int i = 0; i < n; ++i) {
        vector<int>().swap(adj[i]);
      }
      for (int i = 0; i < 26; ++i) {
        pre[i].clear();
      }
      
      for (int i = 0; i < n; ++i) {
        par[i] = parent[i];
        v[i] = s[i] - 'a';
      }
      for (int i = 0; i < n; ++i) {
        if (par[i] != -1) {
          adj[par[i]].push_back(i);
        }
      }
      DFS1(0, -1);
      for (int i = 0; i < n; ++i) {
        vector<int>().swap(adj[i]);
      }
      for (int i = 0; i < n; ++i) {
        if (par[i] != -1) {
          adj[par[i]].push_back(i);
        }
      }
      vector<int> ret(n);
      DFS2(0, -1, ret.data());
      return ret;
    }
};",1434285431
Xiaomeng Yang,yangxm,267,3587,cpp,"constexpr int MAX = 256;

int dp[MAX][MAX];

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
      const auto& s = stayScore;
      const auto& t = travelScore;
      memset(dp[0], 0, sizeof(dp[0]));
      for (int i = 1; i <= k; ++i) {
        for (int j = 0; j < n; ++j) {
          dp[i][j] = dp[i - 1][j] + s[i - 1][j];
          for (int k = 0; k < n; ++k) {
            dp[i][j] = max(dp[i][j], dp[i - 1][k] + t[k][j]);
          }
        }
      }
      return *max_element(dp[k], dp[k] + n);
    }
};",1434294066
Xiaomeng Yang,yangxm,267,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
      int cnt = 1, ret = 1;
      char cur = 0;
      for (char ch : word) {
        if (ch == cur) {
          ++cnt;
        } else {
          ret += cnt - 1;
          cur = ch;
          cnt = 1;
        }
      }
      ret += cnt - 1;
      return ret;
    }
};",1434266411
Ivan Vasilenko,8symbols,269,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        def build_graph(parent):
            graph = [[] for _ in range(n)]

            for child in range(1, n):
                graph[parent[child]].append(child)

            return graph

        graph = build_graph(parent)

        new_parent = parent[:]

        visited = defaultdict(lambda: -1)

        def change_parents(node):
            value = s[node]
            if visited[value] != -1:
                new_parent[node] = visited[value]

            previous_visited = visited[value]
            visited[value] = node

            for child in graph[node]:
                change_parents(child)

            visited[value] = previous_visited

        change_parents(0)

        graph = build_graph(new_parent)

        sizes = [1] * n

        def find_sizes(node):
            for child in graph[node]:
                find_sizes(child)
                sizes[node] += sizes[child]

        find_sizes(0)

        return sizes",1434283087
Ivan Vasilenko,8symbols,269,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(day, city):
            if day == k:
                return 0

            travel = 0
            for next_city in range(n):
                if city != next_city:
                    travel = max(travel, travelScore[city][next_city] + dp(day + 1, next_city))
            stay = stayScore[day][city] + dp(day + 1, city)
            return max(travel, stay)


        return max(dp(0, i) for i in range(n))",1434294290
Ivan Vasilenko,8symbols,269,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 1
        
        for i in range(1, len(word)):
            count += int(word[i - 1] == word[i])
            
        return count",1434260602
Agnibha Chakraborty,zanj0,270,3576,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	void Dfs(int node, int par, vector<int>& new_val, vector<vector<int>>& new_par, vector<vector<int>>& graph, string& s) {
		int curr = s[node] - 'a';

		if (!new_par[curr].empty()) {
			new_val[node] = new_par[curr].back();
		}
		new_par[curr].pb(node);
		for (auto& it : graph[node]) {
			if (it == par) continue;
			Dfs(it, node, new_val, new_par, graph, s);
		}
		new_par[curr].pop_back();
	}
	void Dfs1(int node, int par, vector<vector<int>>& graph, vector<int>& ret) {
		ret[node] = 1;
		for (auto& it : graph[node]) {
			if (it == par) continue;
			Dfs1(it, node, graph, ret);
			ret[node] += ret[it];
		}
	}
	vector<int> findSubtreeSizes(vector<int>& parent, string s) {
		int n = parent.size();
		vector<vector<int>> graph(n);
		for (int i = 0; i < n; i++) {
			if (parent[i] == -1) continue;
			graph[i].pb(parent[i]);
			graph[parent[i]].pb(i);
		}
		vector<int> new_val(n, -1);
		vector<vector<int>> new_par(26);

		Dfs(0, -1, new_val, new_par, graph, s);

		for (int i = 0; i < n; i++) {
			if (new_val[i] != -1)parent[i] = new_val[i];
		}
		for (int i = 0; i < n; i++) graph[i].clear();
        // for(auto& it : parent){
        //     cout << it << "" "";
        // }
        // cout << endl;
		for (int i = 0; i < n; i++) {
			if (parent[i] == -1) continue;
			graph[i].pb(parent[i]);
			graph[parent[i]].pb(i);
		}
		vector<int> ret(n);
		Dfs1(0, -1, graph, ret);
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1434281898
Agnibha Chakraborty,zanj0,270,3587,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	lli nn;
	lli mm;
	lli Dfs(lli curr, lli day, vector<vector<lli>>& dp, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
		if (day >= mm) return 0;
        // cout << curr << "" "" << day << "" ""<<dp[curr][day] << endl;
		if (dp[curr][day] != -1) return dp[curr][day];

		lli ret = Dfs(curr, day + 1, dp, stayScore, travelScore) + stayScore[day][curr];

		for (lli nxt = 0; nxt < nn; nxt++) {
			if (nxt == curr) continue;
			ret = max(ret, Dfs(nxt, day + 1, dp, stayScore, travelScore) + travelScore[curr][nxt]);
		}
    // cout << curr << "" "" << day << "" -- "" << ret << endl;
		return dp[curr][day] = ret;
	}
	int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
		nn = n;
		mm = k;

		vector<vector<lli>> dp(n, vector<lli>(k, -1));
		lli ret = 0;
        // cout << Dfs(1, 0, dp, stayScore, travelScore) << endl;
		for (int i = 0; i < n; i++) {
			ret = max(ret, Dfs(i, 0, dp, stayScore, travelScore));
            // cout << i << "" "" << ret << endl;
		}
		return ret;

	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1434302382
Agnibha Chakraborty,zanj0,270,3617,cpp,"/*
	JAI JAGANNATH!
*/
//@Author : zanj0

#include<bits/stdc++.h>
using namespace std;

#define ff              first
#define ss              second
#define pb              push_back
#define MOD             1000000007
#define inf             1e18

typedef long long int lli;


class Solution {
public:
	int possibleStringCount(string word) {
		int ret = 0;
		int len = 1;
		char last = '*';

		for (int i = 0; i < word.size(); i++)      {
			if (word[i] != last) {
				ret += len - 1;
				len = 1;
			} else len++;
            last = word[i];
		}
		ret += len - 1;
		ret ++;
		return ret;
	}
};


#ifdef LOCAL
int main() {
	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif",1434263001
Shivam Jha,dadboss,271,3576,cpp,"class Solution {
public:
    string s;
    vector<int> g[100009],p,ans;
    void dfs(int n,vector<int> f)
    {
        if(f[s[n]-'a']!=-1)
            p[n]=f[s[n]-'a'];
        f[s[n]-'a']=n;
        for(auto x:g[n])
            dfs(x,f);
    }
    void fds(int n)
    {
         ans[n]=1;
        for(auto x:g[n])
            {
                fds(x);
                ans[n]+=ans[x];
            }
    }
    vector<int> findSubtreeSizes(vector<int>& a, string S) {
        p.clear();
        ans.clear();
        s=S;
        int i=0;
        while(i<a.size())
            {
                p.push_back(-1);
                ans.push_back(0);
                g[i].clear();
                i++;
            }
        p[0]=-1;
        i=1;
        while(i<a.size())
            {
                p[i]=a[i];
                g[a[i]].push_back(i);
                i++;
            }
        vector<int> f(26);
        for(auto &x:f)
            x=-1;
        dfs(0,f);
        i=0;
        while(i<a.size())
            {
                g[i].clear();
                i++;
            }
        i=0;
        while(i<a.size())
            {
                if(p[i]!=-1)
                    g[p[i]].push_back(i);
                i++;
            }
        fds(0);
        return ans;
    }
};",1434290390
Shivam Jha,dadboss,271,3587,cpp,"class Solution {
public:
int n,k,dp[209][209];
vector<vector<int>> sc,ts;
    int f(int i,int c)
    {
        if(i==k)
            return 0;
        if(dp[i][c]!=-1)
            return dp[i][c];
        int ans=sc[i][c]+f(i+1,c);
        int j=0;
        while(j<n)
            {
                ans=max(ans,ts[c][j]+f(i+1,j));
                j++;
            }
        return dp[i][c]=ans;
    }
    int maxScore(int N, int K, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        n=N;
        k=K;
        sc=stayScore;
        ts=travelScore;
        int ans=0;
        int i=0,j;
        while(i<=k)
            {
                j=0;
                while(j<=n)
                    {
                        dp[i][j]=-1;
                        j++;
                    }
                i++;
            }
        i=0;
        while(i<n)
            {
                // cout<<f(i,0)<<""\n"";
                ans=max(ans,f(0,i));
                i++;
            }
        return ans;
    }
};",1434302675
Shivam Jha,dadboss,271,3617,cpp,"class Solution {
public:
    int possibleStringCount(string a) {
        int t=1;
        int i=1;
        while(i<a.size())
            {
                if(a[i]==a[i-1])
                    t++;
                i++;
            }
        return t;
    }
};",1434260289
Aditya Agrawal,AA2512,275,3576,cpp,"class Solution {
public:
    vector<vector<int>> ls;
    string S;
    vector<vector<int>> g;
    vector<int> nParent;
    int n;
    void dfs(int node, int parent) {
        if(node!=0) {
            if(ls[S[node]-'a'].size()>0) {
                nParent[node] = ls[S[node]-'a'].back();
            } else {
                nParent[node] = parent;
            }
        }
        ls[S[node]-'a'].push_back(node);
        for(auto x: g[node]) {
            if(x!=parent) {
                dfs(x, node);
            }
        }
        ls[S[node]-'a'].pop_back();
    }

    void getSize(int node, int par, vector<int> &sz) {
        sz[node] = 1;
        for(auto x: g[node]) {
            if(x!=par) {
                getSize(x, node, sz);
                sz[node]+=sz[x];
            }
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = parent.size();
        g.resize(n); ls.resize(26);
        for(int i=1; i<n; i++) {
            g[i].push_back(parent[i]);
            g[parent[i]].push_back(i);
        }
        nParent.resize(n);
        nParent[0] = -1; S= s;
        dfs(0, -1);


        g.clear(); g.resize(n);
        for(int i=1; i<n; i++) {
            g[i].push_back(nParent[i]);
            g[nParent[i]].push_back(i);
        }

        vector<int> ans(n, 0);
        getSize(0, -1, ans);
        return ans;
    }
};",1434294102
Aditya Agrawal,AA2512,275,3587,cpp,"class Solution {
public:
    vector<vector<int>> ss, ts;
    int dp[210][210];
    int n, k;

    int rec(int city, int days) {
        if(days==k) return 0;
        if(dp[city][days]!=-1) return dp[city][days];
        int ans = 0;
        for(int i=0; i<n; i++) {
            if(i==city) {
                ans = max(ans, rec(city, days+1)+ss[days][city]);
            } else {
                ans = max(ans, rec(i, days+1)+ts[city][i]);
            }
        }
        return dp[city][days]=ans;
    }

    int maxScore(int N, int K, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp, -1, sizeof(dp));
        n = N; k = K;
        ss = stayScore; ts = travelScore;
        int ans = 0;
        for(int i=0; i<n; i++)
            ans = max(ans, rec(i, 0));
        return ans;
    }
};",1434303066
Aditya Agrawal,AA2512,275,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int cnt = 1;
        for(int i=0; i<n; i++) {
            int j=i+1;
            while(word[j]==word[i]) {
                j++;
            }
            cnt += (j-i-1);
            i = j-1;
        }
        return cnt;
    }
};",1434268876
pratyush14,pratyush14,276,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) 
    {
        int n = parent.size();
        vector<vector<int>> tree(n);  
        vector<int> newParent(n);          

        for (int i = 1; i < n; ++i) 
        {
            tree[parent[i]].push_back(i);
            newParent[i] = parent[i];           
        }

        unordered_map<char, int> nearestAncestor;  
        reparentTree(0, s, tree, nearestAncestor, newParent); 

        vector<vector<int>> newTree(n);
        for (int i = 1; i < n; ++i)
            newTree[newParent[i]].push_back(i);
        

        vector<int> subtreeSizes(n, 0);
        computeSubtreeSizes(0, newTree, subtreeSizes); 

        return subtreeSizes;
    }

private:
    void reparentTree(int node, const string& s, const vector<vector<int>>& tree,
                      unordered_map<char, int>& nearestAncestor, vector<int>& newParent) 
    {
        int originalAncestor = nearestAncestor.count(s[node]) ? nearestAncestor[s[node]] : -1;
        
        if (originalAncestor != -1)
            newParent[node] = originalAncestor;  
        nearestAncestor[s[node]] = node;         

        for (int child : tree[node]) 
            reparentTree(child, s, tree, nearestAncestor, newParent);
    

        if (originalAncestor == -1) nearestAncestor.erase(s[node]);
        else nearestAncestor[s[node]] = originalAncestor;
    }

    int computeSubtreeSizes(int node, const vector<vector<int>>& tree, vector<int>& subtreeSizes) 
    {
        int size = 1;
        for (int child : tree[node])
            size += computeSubtreeSizes(child, tree, subtreeSizes);
        subtreeSizes[node] = size;
        return size;
    }
};
",1434303613
pratyush14,pratyush14,276,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) 
    {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        
        for (int day = 1; day <= k; ++day) 
        {
            vector<int> maxTravel(n, 0);
            for (int curr = 0; curr < n; ++curr) 
            {
                for (int dest = 0; dest < n; ++dest) 
                {
                    if (dest != curr) 
                         maxTravel[dest] = max(maxTravel[dest], dp[day - 1][curr] + travelScore[curr][dest]);
                }
            }

            for (int curr = 0; curr < n; ++curr)
                dp[day][curr] = max(dp[day - 1][curr] + stayScore[day - 1][curr], maxTravel[curr]);
        }
        
        return *max_element(dp[k].begin(), dp[k].end());
    }
};
",1434292101
pratyush14,pratyush14,276,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count = 1; 
        int n = word.size();

        for (int i = 0; i < n; ) 
        {
            int j = i;
            while (j < n && word[j] == word[i])
                j++;
            int groupLength = j - i;

            if (groupLength > 1) count += groupLength - 1; 

            i = j;
        }

        return count;
    }
};
",1434267044
Ayanerru,Ayanerru,278,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        e = collections.defaultdict(list)
        for i, par in enumerate(parent):
            e[par].append(i)
            
        root = e[-1][0]
        # print(root)
        st = collections.defaultdict(list)
        # print(e)
        def dfs(node):
            if s[node] in st and len(st[s[node]]) > 0:
                parent[node] = st[s[node]][-1]
                # print(s[node])
                # print(st[s[node]])
                # print('change node', node, ""s parent = "", st[s[node]][-1])
            else:
                pass
            st[s[node]].append(node)
            for child in e[node]:
                dfs(child)
            st[s[node]].pop()
        dfs(root)
        # print(parent)
        e2 = collections.defaultdict(list)
        for i, par in enumerate(parent):
            e2[par].append(i)
        ans = [0] * len(s)
        
        def dfs2(node):
            ans[node] = 1
            for child in e2[node]:
                ans[node] += dfs2(child)
            return ans[node]
        dfs2(root)
        
        return ans",1434292406
Ayanerru,Ayanerru,278,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        ans = [0] * n
        for i in range(k):
            tmp = [0] * n
            for src in range(n):
                for dst in range(n):
                    if src == dst:
                        tmp[dst] = max(tmp[dst], stayScore[i][src] + ans[src])
                    else:
                        tmp[dst] = max(tmp[dst], travelScore[src][dst] + ans[src])
            
            ans = tmp
        
        
        return max(tmp)",1434304347
Ayanerru,Ayanerru,278,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for i in range(1, len(word)):
            if word[i] == word[i-1]:
                ans += 1
        return ans",1434262697
Neil Chetty,neilchetty,279,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        List<List<Integer>> store = new ArrayList<>();
        for(int i = 0; i < n; i++) store.add(new ArrayList<>());
        for(int i = 1; i < n; i++) {
            int p = parent[i], c = i;
            store.get(p).add(c);
            store.get(c).add(p);
        }
        int[] result = new int[n];
        helper(store, parent, 0, -1, new HashMap<>(), s);
        store = new ArrayList<>();
        for(int i = 0; i < n; i++) store.add(new ArrayList<>());
        for(int i = 1; i < n; i++) {
            int p = parent[i], c = i;
            store.get(p).add(c);
            store.get(c).add(p);
        }
        // System.out.println(Arrays.toString(parent));
        helper(store, parent, 0, -1);
        return parent;
    }
    
    private void helper(List<List<Integer>> store, int[] parent, int index, int par, Map<Character, Integer> map, String s) {
        if(map.containsKey(s.charAt(index))) {
            parent[index] = map.get(s.charAt(index));
        }
        Map<Character, Integer> newMap = new HashMap<>(map);
        newMap.put(s.charAt(index), index);
        for(int i : store.get(index)) {
            if(i == par) continue;
            helper(store, parent, i, index, newMap, s);
        }
    }
    
    private int helper(List<List<Integer>> store, int[] parent, int index, int par) {
        int result = 1;
        for(int i : store.get(index)) {
            if(i == par) continue;
            result += helper(store, parent, i, index);
        }
        return parent[index] = result;
    }
}",1434292694
Neil Chetty,neilchetty,279,3587,java,"class Solution {
    Integer[][] dp;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.dp = new Integer[n+1][k+1];
        return helper(-1, 0, stayScore, travelScore, n, k);
    }
    
    private int helper(int current, int k, int[][] stay, int[][] travel, int n, int kk) {
        if(k == kk) return 0;
        if(current == -1) {
            int result = 0;
            for(int i = 0; i < n; i++) result = Math.max(result, helper(i, 0, stay, travel, n, kk));
            return result;
        }
        if(this.dp[current][k] != null) return this.dp[current][k];
        int result = 0;
        for(int i = 0; i < n; i++) {
            if(i == current) {
                result = Math.max(result, stay[k][current] + helper(current, k+1, stay, travel, n, kk));
            }
            else {
                result = Math.max(result, travel[current][i] + helper(i, k+1, stay, travel, n, kk));
            }
        }
        return this.dp[current][k] = result;
    }
}",1434304389
Neil Chetty,neilchetty,279,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int result = 1;
        for(int i = 0; i < word.length();) {
            int j = i;
            while(j < word.length() && word.charAt(j) == word.charAt(i)) j++;
            result += (j-i-1);
            i = j;
        }
        return result;
    }
}",1434261741
Saijayavinoth T V S,saijayavinoth,280,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        g = {i:[] for i in range(n)}
        for ch, p in enumerate(parent):
            if p == -1:
                continue
            g[p].append(ch)
        candidate = {}
        nparent = {}
        def traverse(node):
            ch = s[node]
            if candidate.get(ch, []):
                nparent[node] = candidate[ch][-1]
            if ch not in candidate:
                candidate[ch] = []
            candidate[ch].append(node)
            for child in g[node]:
                traverse(child)
            candidate[ch].pop()
        traverse(0)
        print(nparent)
        for i,p in nparent.items():
            parent[i] = p
        g = {i:[] for i in range(n)}
        for ch, p in enumerate(parent):
            if p == -1:
                continue
            g[p].append(ch)
        ret = [0]*n
        def traverse(node):
            size = 1
            for c in g[node]:
                size += traverse(c)
            ret[node] = size
            return size
        traverse(0)
        return ret",1434294234
Saijayavinoth T V S,saijayavinoth,280,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def solve(day, cur):
            if day == k:
                return 0
            score = 0
            for dest in range(n):
                if cur == dest:
                    score = max(score, stayScore[day][cur] + solve(day+1, cur))
                else:
                    score = max(score, travelScore[cur][dest] + solve(day+1, dest))
            return score
        return max([solve(0, city) for city in range(n)])",1434304597
Saijayavinoth T V S,saijayavinoth,280,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 0
        prev = word[0]
        ans = 1
        for ch in word:
            if ch == prev:
                count += 1
            else:
                ans += count-1
                count = 1
                prev = ch
        ans += count - 1
        return ans
",1434265329
Coder,LCCoder_123,282,3576,cpp,"class Solution {
public:
    void dfs(int node,vector<vector<int>>& adj,vector<int>& parent,vector<int>& newParent,map<char,int>& mpp,string& s){
        int curNode = -1;
        if(mpp.find(s[node])!=mpp.end()){
            newParent[node]=mpp[s[node]];
            curNode = mpp[s[node]];
            mpp[s[node]]=node;
        }
        else {
            mpp[s[node]]=node;
            newParent[node]=parent[node];
        }
        
        for(auto it:adj[node]){
            dfs(it,adj,parent,newParent,mpp,s);
        }
        if(curNode==-1) mpp.erase(s[node]);
        else mpp[s[node]]=curNode;
        return ;
    }
    int dfs2(int node,vector<int>& subTreeSize,vector<vector<int>>& adj){
        int cnt = 1;
        for(auto it:adj[node]){
            cnt+=(dfs2(it,subTreeSize,adj));
        }
        subTreeSize[node]=cnt;
        return cnt;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for(int i=0;i<n;i++) if(parent[i]!=-1)adj[parent[i]].push_back(i);
        vector<int> newParent(n,-1);
        map<char,int> mpp;
        dfs(0,adj,parent,newParent,mpp,s);
        vector<int> subTreeSize(n,0);
        vector<vector<int>> newAdj(n);
        for(int i=0;i<n;i++) if(newParent[i]!=-1)newAdj[newParent[i]].push_back(i);
        dfs2(0,subTreeSize,newAdj);
        return subTreeSize;
    }
};",1434288037
Coder,LCCoder_123,282,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int f(int n,int k,vector<vector<int>>& stayScore, vector<vector<int>>& travelScore,int day,int curCity){
        if(day>=k) return 0;
        if(dp[day][curCity]!=-1) return dp[day][curCity];
        int ans = stayScore[day][curCity]+f(n,k,stayScore,travelScore,day+1,curCity);
        for(int i=0;i<n;i++){
            if(curCity!=i)ans = max(ans,travelScore[curCity][i]+f(n,k,stayScore,travelScore,day+1,i));
        }
        return dp[day][curCity] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        memset(dp,-1,sizeof dp);
        for(int i=0;i<n;i++){
            ans=max(ans,f(n,k,stayScore,travelScore,0,i));
        }
        return ans;
    }
};",1434304920
Coder,LCCoder_123,282,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for(int i=0;i<word.size();){
            int cnt = 0;
            char cur = word[i];
            while(i<word.size() && cur==word[i] ){
                cnt++;i++;
            }
            ans+=(cnt-1);
        }
        return ans;
    }
};",1434265923
Rad0miR,Rad0miR,284,3576,csharp,"public class Solution {
    public int[] FindSubtreeSizes(int[] parent, string s) {
        List<int>[] gr = Gr(parent);

        Dictionary<char, List<int>> dict = new();
        for (char c = 'a'; c <= 'z'; ++c) dict[c] = new();

        Work(0);

        int[] ans = new int[parent.Length];

        gr = Gr(parent);
        
        Cnt(0);

        return ans;

        int Cnt(int v) 
        {
            int anss = 1;
            foreach (int u in gr[v]) anss += Cnt(u);
            ans[v] = anss;
            return anss;
        }
        
        void Work(int v) 
        {
            var list = dict[s[v]];
            if (list.Count > 0) 
            {
                parent[v] = list.Last();
            }

            list.Add(v);

            foreach (int u in gr[v]) Work(u);

            list.RemoveAt(list.Count - 1);
        }
        
        static List<int>[] Gr(int[] parent) 
        {
            List<int>[] gr = Enumerable.Range(0, parent.Length).Select(_ => new List<int>()).ToArray();
            for (int i = 1; i < parent.Length; ++i) 
            {
                gr[parent[i]].Add(i);
            }
            return gr;
        }
    }
}",1434295863
Rad0miR,Rad0miR,284,3587,csharp,"public class Solution {
    public int MaxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[] dp = new int[n];
        for (int i = 0; i < k; ++i) 
        {
            int[] next = new int[n];
            for (int j = 0; j < n; ++j) 
            {
                next[j] = Math.Max(next[j], dp[j] + stayScore[i][j]);
                for (int m = 0; m < n; ++m) 
                {
                    next[m] = Math.Max(next[m], dp[j] + travelScore[j][m]);
                }
            }
            dp = next;
        }
        return dp.Max();
    }
}",1434305287
Rad0miR,Rad0miR,284,3617,csharp,"public class Solution {
    public int PossibleStringCount(string word) {
        int ans = 1, cnt = 1;
        char p = '!';
        foreach (char c in word) 
        {
            if (c == p) 
            {
                cnt++;
                continue;
            }

            ans += cnt - 1;
            p = c;
            cnt = 1;
        }
        return ans + cnt - 1;
    }
}",1434277840
Pro Coder,pro_coderLC,285,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]  
        for x in range(1, n):
            adj[parent[x]].append(x)
        
        new_parent = parent.copy()  
        from collections import defaultdict
        char_stack = defaultdict(list)  

        def dfs(u):
            c = s[u]
            if char_stack[c]:
                new_parent[u] = char_stack[c][-1]
            else:
                new_parent[u] = parent[u]
            char_stack[c].append(u)
            for v in adj[u]:
                dfs(v)
            char_stack[c].pop()

        dfs(0)  

        new_adj = [[] for _ in range(n)]
        root = -1
        for x in range(n):
            p = new_parent[x]
            if p == -1:
                root = x  
            else:
                new_adj[p].append(x)

        
        size = [0] * n
        def dfs_size(u):
            size[u] = 1  
            for v in new_adj[u]:
                dfs_size(v)
                size[u] += size[v]  
        dfs_size(root)
        return size",1434284623
Pro Coder,pro_coderLC,285,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[float('-inf')] * n for _ in range(k)]
        dp[0] = [0] * n  
        
        for start_city in range(n):
            
            dp[0][start_city] = max(dp[0][start_city], stayScore[0][start_city])
            for dest_city in range(n):
                if dest_city != start_city:
                    dp[0][dest_city] = max(dp[0][dest_city], travelScore[start_city][dest_city])
        
        for day in range(1, k):
            for curr_city in range(n):
                dp[day][curr_city] = dp[day-1][curr_city] + stayScore[day][curr_city]
                for prev_city in range(n):
                    if prev_city != curr_city:
                        dp[day][curr_city] = max(
                            dp[day][curr_city],
                            dp[day-1][prev_city] + travelScore[prev_city][curr_city]
                        )
        return max(dp[k-1])",1434297755
Pro Coder,pro_coderLC,285,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        possible_strings = set()
        possible_strings.add(word)
        n = len(word)
        i = 0
        while i < n:
            j = i
            while j + 1 < n and word[j+1] == word[i]:
                j += 1
            group_length = j - i + 1
            if group_length > 1:
                for reduced_length in range(1, group_length):
                    new_word = word[:i] + word[i]*reduced_length + word[j+1:]
                    possible_strings.add(new_word)
            i = j + 1
        return len(possible_strings)",1434276287
angeshs,angeshs,287,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> edges(n);
        for(int i = 1; i < n; ++i) {
            edges[parent[i]].push_back(i);
        }
        vector<int> charParent(26, -1);
        function<void(int)> dfs = [&](int cur) {
            int last = charParent[s[cur] - 'a'];
            if(last != -1) {
                parent[cur] = last;
                
            }
            charParent[s[cur] - 'a'] = cur;
            for(int nxt: edges[cur]) {
                dfs(nxt);
            }
            charParent[s[cur] - 'a'] = last;
            return;
        };
        dfs(0);
        edges = vector<vector<int>> (n);
        for(int i = 1; i < n; ++i) {
            edges[parent[i]].push_back(i);
        }
        vector<int> cnt(n);
        function<int(int)> count = [&](int cur) {
            cnt[cur] = 1;
            for(int nxt: edges[cur]) {
                cnt[cur] += count(nxt);
            }
            return cnt[cur];
        };
        count(0);
        return cnt;
    }
};",1434289382
angeshs,angeshs,287,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n);
        for(int day = 0; day < k; ++day) {
            vector<int> dp2(n);
            for(int city = 0; city < n; ++city) {
                dp2[city] = max(dp2[city], dp[city] + stayScore[day][city]);
                for(int dest = 0; dest < n; ++dest) {
                    dp2[dest] = max(dp2[dest], dp[city] + travelScore[city][dest]);
                }
            }
            dp = dp2;
        }
        return *max_element(dp.begin(), dp.end());
    }
};",1434305817
angeshs,angeshs,287,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for(int i = 1; i < word.size(); ++i) {
            if(word[i - 1] == word[i]) {
                ++ans;
            }
        }
        return ans;
    }
};",1434263346
Atul,coderchamp07,288,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for(int i = 1; i < n; i++) {
            g[i].push_back(parent[i]);
            g[parent[i]].push_back(i);
        }
        
        auto dfs = [&](auto&& dfs, int node, int prevNode, map<char, int>& prev) -> void {
            if(prev.count(s[node]))
                parent[node] = prev[s[node]];
            
            int prevVal = -1;
            if(prev.count(s[node]))
                prevVal = prev[s[node]];
            prev[s[node]] = node;

            for(auto& child : g[node]) {
                if(prevNode == child) continue;
                dfs(dfs, child, node, prev);
            }

            if(prevVal == -1)
                prev.erase(s[node]);
            else
                prev[s[node]] = prevVal;
        };
        
        map<char, int> p;
        dfs(dfs, 0, -1, p);
        
        for(int i = 0; i < n; i++)
            g[i] = {};
        for(int i = 1; i < n; i++) {
            g[i].push_back(parent[i]);
            g[parent[i]].push_back(i);
        }
        
        vector<int> out(n);
        auto dfs2 = [&](auto&& dfs2, int node, int parent) -> int {
            int in = 1;
            
            for(auto& child : g[node]) {
                if(child == parent) continue;
                
                in += dfs2(dfs2, child, node);
            }
            
            return out[node] = in;
        };
        
        dfs2(dfs2, 0, -1);
        
        return out;
    }
};",1434289390
Atul,coderchamp07,288,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // curCity // day // 
        
        int dp[n][k];
        memset(dp, -1, sizeof(dp));
        
        auto recur = [&](auto&& recur, int curCity, int curDay) -> int {
            if(curDay == k)
                return 0;
            if(dp[curCity][curDay] != -1)
                return dp[curCity][curDay];
            
            int stay = stayScore[curDay][curCity] + recur(recur, curCity, curDay + 1);
            int mxMove = 0;
            for(int newCity = 0; newCity < n; newCity++) {
                if(curCity == newCity) continue;
                
                mxMove = max(mxMove, travelScore[curCity][newCity] + recur(recur, newCity, curDay + 1));
            }
            
            return dp[curCity][curDay] = max(stay, mxMove);
        };
        
        int ans = 0;
        for(int i = 0; i < n; i++)
            ans = max(ans, recur(recur, i, 0));
        return ans;
    }
};",1434306005
Atul,coderchamp07,288,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 1;
        int len = 0;
        for(int i = 0; i < n; i++) {
            if(i == 0 || word[i - 1] == word[i])
                len++;
            else {
                ans += len - 1;
                len = 1;
            }
        }
        ans += len - 1;
        return ans;
    }
};",1434262185
lixiangfan97,lixiangfan97,290,3576,cpp,"class Solution {
public:
    vector<int> childs[100010];
    void dfs(int u, vector<int>& parent2, vector<int>& as, const string& s) {
        int c = s[u] - 'a';
        if (as[c] >= 0) {
            parent2[u] = as[c];
        }
        int pre = as[c];
        as[c] = u;
        for (int v: childs[u]) {
            dfs(v, parent2, as, s);
        }
        as[c] = pre;
    }

    int dfs2(int u, vector<int>& ans) {
        int ret = 1;
        for (int v: childs[u]) {
            ret += dfs2(v, ans);
        }
        ans[u] = ret;
        return ret;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        const int n = (int)parent.size();
        vector<int> parent2(n, -1);
        vector<int> as(26, -1);
        for (int i = 1; i < n; ++i) {
            childs[parent[i]].push_back(i);
        }

        dfs(0, parent2, as, s);
        for (int i = 0; i < n; ++i)
            childs[i].clear();
        for (int i = 1; i < n; ++i) {
            int p = (parent2[i] >= 0) ? parent2[i] : parent[i];
            childs[p].push_back(i);
        }
        vector<int> ans(n, 0);
        dfs2(0, ans);
        return ans;
    }
};",1434290610
lixiangfan97,lixiangfan97,290,3587,cpp,"class Solution {
public:
    int dp[205][205];
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        for (int j = 0; j < n; ++j) {
            dp[0][j] = 0;
        }
        for (int i = 0; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                dp[i+1][j] = 0;
                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + stayScore[i][j]);
                for (int last_j = 0; last_j < n; ++last_j) {
                    if (last_j != j) {
                        dp[i+1][j] = max(dp[i+1][j], dp[i][last_j] + travelScore[last_j][j]);
                    }
                }
            }
        }
        int ans = 0;
        for (int j = 0; j < n; ++j) {
            ans = max(ans, dp[k][j]);
        }
        return ans;
    }
};",1434306371
lixiangfan97,lixiangfan97,290,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = (int)word.size();
        for (int i = 1; i < (int)word.size(); ++i) {
            if (word[i] != word[i-1])
                --ans;
        }
        return ans;
    }
};",1434269403
ohnoooo,ohnoooo,291,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for(int i=1; i<n; i++)
            g[parent[i]].push_back(i);

        vector<vector<int>> pos(26);
        auto dfs = [&](auto&& dfs, int x) -> void {
            int c = s[x] - 'a';
            if(pos[c].size())
                parent[x] = pos[c].back();
            pos[c].push_back(x);
            for(auto y : g[x])
                dfs(dfs, y);
            pos[c].pop_back();
        };
        dfs(dfs, 0);

        g.clear();
        g = vector<vector<int>>(n);
        for(int i=1; i<n; i++)
            g[parent[i]].push_back(i);

        vector<int> ans(n);
        auto dfs2 = [&](auto&& dfs2, int x) -> int {
            int cnt = 1;
            for(auto y : g[x])
                cnt += dfs2(dfs2, y);
            return ans[x] = cnt;
        };
        dfs2(dfs2, 0);
        return ans;
    }
};",1434283004
ohnoooo,ohnoooo,291,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> f(k+1, vector<int>(n));
        for(int i=0; i<k; i++) for(int j=0; j<n; j++) {
            f[i+1][j] = f[i][j] + stayScore[i][j];
            for(int l=0; l<n; l++)
                f[i+1][j] = max(f[i+1][j], f[i][l] + travelScore[l][j]);
        }
        return *max_element(f[k].begin(), f[k].end());
    }
};",1434306398
ohnoooo,ohnoooo,291,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        word += 'A';
        int ans = 1;
        char pre = ' ';
        int cnt = 0;
        for(char c : word) {
            if(c == pre) {
                cnt++;
            } else {
                ans += cnt;
                cnt = 0;
                pre = c;
            }
        }
        return ans;
    }
};",1434290847
Ahmed_Ashraf,boAshraf,293,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n), finalTree(n);
        vector<int> newParent = parent;

        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        unordered_map<char, int> lastSeen;
        findSameCharAncestors(0, s, tree, lastSeen, newParent);

        for (int i = 1; i < n; ++i) {
            finalTree[newParent[i]].push_back(i);
        }

        vector<int> answer(n);
        calculateSubtreeSizes(0, finalTree, answer);
        return answer;
    }

private:
    void findSameCharAncestors(int node, const string& s, vector<vector<int>>& tree,
                               unordered_map<char, int>& lastSeen, vector<int>& newParent) {
        int originalAncestor = lastSeen.count(s[node]) ? lastSeen[s[node]] : -1;
        
        if (originalAncestor != -1) {
            newParent[node] = originalAncestor;
        }
        
        lastSeen[s[node]] = node;
        
        for (int child : tree[node]) {
            findSameCharAncestors(child, s, tree, lastSeen, newParent);
        }
        
        if (originalAncestor == -1) {
            lastSeen.erase(s[node]);
        } else {
            lastSeen[s[node]] = originalAncestor;
        }
    }

    int calculateSubtreeSizes(int node, vector<vector<int>>& tree, vector<int>& answer) {
        answer[node] = 1;
        for (int child : tree[node]) {
            answer[node] += calculateSubtreeSizes(child, tree, answer);
        }
        return answer[node];
    }
};",1434275571
Ahmed_Ashraf,boAshraf,293,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, INT_MIN));

        for (int city = 0; city < n; city++) {
            dp[0][city] = 0;
        }

        for (int day = 1; day <= k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day][curr] = max(dp[day][curr], dp[day - 1][curr] + stayScore[day - 1][curr]);

                for (int dest = 0; dest < n; dest++) {
                    dp[day][dest] = max(dp[day][dest], dp[day - 1][curr] + travelScore[curr][dest]);
                }
            }
        }

        int maxPoints = INT_MIN;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }

        return maxPoints;
    }
};
",1434291257
Ahmed_Ashraf,boAshraf,293,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt=1;
        int n=word.size();
        for(int i=1;i<n;i++){
            if(word[i]==word[i-1])cnt++;
        }
        return cnt;
    }
};",1434260200
metaphysicalist,metaphysicalist,294,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        new_parents = parent[::]
        sub_trees = [0] * n

        @cache
        def dfs1(x):
            if parent[x] == -1:
                return {s[x]: x}
            closets = dfs1(parent[x]).copy()
            if s[x] in closets:
                new_parents[x] = closets[s[x]]
            closets[s[x]] = x
            return closets
        
        for i in range(0, n):
            dfs1(i)

        children = [set() for _ in range(n)]
        for c, p in enumerate(new_parents[1:], 1):
            children[p].add(c)
        
        def dfs2(v):
            for u in children[v]:
                sub_trees[v] += dfs2(u)
            sub_trees[v] += 1
            return sub_trees[v]
        
        dfs2(0)
            
        return sub_trees",1434301380
metaphysicalist,metaphysicalist,294,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(city, day):
            if day >= k:
                return 0
            s = dp(city, day+1) + stayScore[day][city]
            for i in range(n):
                if i != city:
                    s = max(s, dp(i, day+1) + travelScore[city][i]) 
            return s

        return max(dp(i, 0) for i in range(n))
        ",1434306816
metaphysicalist,metaphysicalist,294,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1

        for i in range(1, len(word)):
            if word[i] == word[i-1]:
               ans += 1 
        return ans",1434270819
Abhik,abhik2003,297,3576,cpp,"
class Solution
{
    vector<int> new_par;
    vector<int> ans_vec;

public:
    vector<int> findSubtreeSizes(vector<int> &parent, string s)
    {
        int n = parent.size();
        vector<vector<int>> adj(n);

        for (int i = 1; i < n; i++){
            adj[parent[i]].push_back(i);
        }
        vector<int> prev(26, -1);

        new_par = parent;

        dfs(0, adj, s, prev);

        vector<vector<int>> adj2(n);

        for (int i = 1; i < n; i++){
            adj2[new_par[i]].push_back(i);
        }

        ans_vec.resize(n);

        calc_size(0, adj2);
        return ans_vec;
    }

    void dfs(int node, auto &adj, string &s, vector<int> prev)
    {
        if(prev[s[node]-'a']!=-1){
            new_par[node] = prev[s[node] - 'a'];
        }
        prev[s[node] - 'a'] = node;
        for (int ch : adj[node])
        {
            dfs(ch, adj, s, prev);
        }
    }

    int calc_size(int node, auto& adj){
        int sz = 1;
        for(int ch : adj[node]){
            sz += calc_size(ch, adj);
        }

        return ans_vec[node] = sz;

    }
};",1434291486
Abhik,abhik2003,297,3587,cpp,"class Solution
{
public:
    int maxScore(int n, int k, vector<vector<int>> &stayScore, vector<vector<int>> &travelScore)
    {
        int ans = 0;

        vector<vector<int>> dp(n, vector<int>(k,-1));
        for (int i = 0; i < n; i++)
        {
            ans = max(ans, helper(i, 0, stayScore, travelScore, n, k, dp));
        }

        return ans;
    }

    int helper(int cur,int day,  auto& stayScore, auto& travelScore, int n, int k, auto&dp){
        if(day==k)
            return 0;

        if(dp[cur][day]!=-1){
            return dp[cur][day];
        }

        int maxScore = 0;
        for (int i = 0; i < n; i++)
        {
            if(i==cur){
                //stay
                int score = stayScore[day][cur] + helper(cur, day + 1, stayScore, travelScore, n, k, dp);
                maxScore = max(maxScore, score);
            }
            else{
                int score = travelScore[cur][i] + helper(i, day + 1, stayScore, travelScore, n, k, dp);
                maxScore = max(maxScore, score);
            }
        }

        return dp[cur][day] = maxScore;
    }
};",1434307574
Abhik,abhik2003,297,3617,cpp,"class Solution
{
public:
    int possibleStringCount(string word)
    {
        int ans = 1;
        int streak = 0;
        char prev = '*';
        
        for (int i = 1; i < word.length(); i++)
        {
            if(word[i]==word[i-1]){
                ans++;
            }
        }

        return ans;
    }
};",1434264405
Anupam Shah,user9218i,299,3576,cpp,"class Solution {
public:
    void dfs(int num, int par, vector<int> v[], vector<int> f, vector<vector<int>>& dp, string& s) {
        for(int i = 0; i < 26; i ++)    dp[num][i] = f[i];
        f[s[num] - 'a'] = num;
        for(auto it: v[num]) {
            if(it == par)   continue;
            dfs(it, num, v, f, dp, s);
        }
    }
    
    int dfs2(int num, int par, vector<int> v[], vector<int>& sz) {
        int x = 1;
        for(auto it : v[num]) {
            if(it == par)   continue;
            x += dfs2(it, num, v , sz);
        }
        return sz[num] = x;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> v[n];
        for(int i = 1; i < parent.size(); i ++)
            v[parent[i]].push_back(i);
        
        vector<vector<int>> dp(n, vector<int> (26, -1));
        vector<int> f(26, -1);
        
        dfs(0, 0, v, f, dp, s);
        
        for(int i = 0; i < n; i ++) {
            if(dp[i][s[i] - 'a'] != -1)
                parent[i] = dp[i][s[i] - 'a'];
        }
        
        
        vector<int> v1[n];
        vector<int> sz(n, 0);
        for(int i = 1; i < parent.size(); i ++)
            v1[parent[i]].push_back(i);
        
        
        dfs2(0, 0, v1, sz);
        return sz;
    }
};",1434289478
Anupam Shah,user9218i,299,3587,cpp,"class Solution {
public:
    int go(int ind, int k, vector<vector<int>>& s, vector<vector<int>>& t, int& d, int& n, vector<vector<int>>& dp) {
        if(k == 0)  return 0;
        
        if(dp[ind][k] != -1)    return dp[ind][k];
        
        int days = d - k, ans = 0;
        for(int i = 0; i < n; i ++) {
            if(i == ind)    ans = max(ans, s[days][i] + go(ind, k-1, s, t, d, n, dp));
            else    ans = max(ans, t[ind][i] + go(i, k-1, s, t, d, n, dp));
        }
        return dp[ind][k] = ans;
        
    }
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        int ans = 0;
        vector<vector<int>> dp(n+1, vector<int> (k+1, -1));
        for(int i = 0; i < n; i ++)
            ans = max(ans, go(i, k, s, t, k, n, dp));
        return ans;
    }
};",1434300012
Anupam Shah,user9218i,299,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> f(26, 0);
        set<int> s;
        for(auto it : word) {
            f[it - 'a'] ++;
            s.insert(it - 'a');
        }
        int sz = 0, cnt = 0;
        for(int i = 0; i < word.length(); i ++) {
            int j = i; sz ++;
            
            while(word[j] == word[i]) {
                j ++;
                cnt ++;
            }
            i = j - 1;
        }
//         int ans = 1 - s.size();
//         for(auto it : f)    ans += it;
//         return ans;
        
        return cnt + 1 - sz;
    }
};

// ""ere"" 
// 1",1434273145
dpdpdpp,dpdpdpp,300,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        N = len(parent)
        g = [[] for _ in range(N)]
        ng = [[] for _ in range(N)]
        for i, fa in enumerate(parent):
            if i > 0:
                g[fa].append(i)

        mp = defaultdict(list)
        def dfs(i):
            c = s[i]
            if i > 0:
                if mp[c]:
                    y = mp[c][-1]
                    ng[y].append(i)
                    # print('np',i,""is"",y)
                else:
                    ng[parent[i]].append(i)
            mp[c].append(i)
            for j in g[i]:
                dfs(j)
            mp[c].pop()

        dfs(0)
            



        # print(ng)
        @cache
        def dfs(i):
            res = 1
            for j in ng[i]:
                res += dfs(j)
            return res

        return [dfs(i) for i in range(N)]",1434298455
dpdpdpp,dpdpdpp,300,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(i, curr):
            if i == k:
                return 0
            # stay
            res = dp(i+1, curr) + stayScore[i][curr]
            # move
            for dest in range(n):
                res = max(res, dp(i+1, dest) + travelScore[curr][dest])
            return res

        ans = 0
        for curr in range(n):
            ans = max(ans, dp(0, curr))
        dp.cache_clear()
        
        return ans ",1434307641
dpdpdpp,dpdpdpp,300,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        N = len(word)
        ans = 1
        i = 0
        while i < N:
            j = i
            while j+1<N and word[i] == word[j+1]:
                j+=1
            ans += j-i
            i = j+1

        return ans
            ",1434265624
Nandy_Tragic,Nandy_Tragic,301,3576,cpp,"class Solution {
public:
    
    vector<unordered_set<int>>graph;
    vector<vector<int>>up;
    string str;
    vector<int>subtree;
    
    void precompute(int u, int p){
        if(p != -1){
            for(int i=0;i<26;i++){
                up[u][i] = up[p][i];
            }
            up[u][str[p]-'a'] = p;
        }
        for(auto v : graph[u]){
            if(v == p) continue;
            precompute(v, u);
        }
    }
    
    void dfs(int u, int p){
        subtree[u] = 1;
        for(auto v : graph[u]){
            if(v == p) continue;
            dfs(v, u);
            subtree[u] += subtree[v];
        }
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        
        graph.clear();
        str.clear();
        up.clear();
        subtree.clear();
        
        str = s;
        graph = vector<unordered_set<int>>(n);
        up = vector<vector<int>>(n, vector<int>(26, -1));
        subtree = vector<int>(n, 0);
        
        for(int i=0;i<parent.size();i++){
            if(parent[i] == -1) continue;
            graph[parent[i]].insert(i);
        }
        
        precompute(0, -1);
        
        // for(int i=0;i<n;i++){
        //     for(int j=0;j<4;j++){
        //         cout<<up[i][j]<<"" "";
        //     }cout<<""\n"";
        // }
        
        for(int i=1;i<n;i++){
            int col = (int)(str[i] - 'a');
            int p = parent[i];
            int pp = up[i][col];
            if(pp != -1){
                graph[p].erase(i);
                graph[pp].insert(i);
            }
        }
        
        dfs(0, -1);
        return subtree;
        
    }
};",1434288270
Nandy_Tragic,Nandy_Tragic,301,3587,cpp,"class Solution {
public:
    
    vector<vector<int>>dp;
    
    int func(int curr, int day, int n, int k, vector<vector<int>>&A, vector<vector<int>>&B){
        if(day == k) return 0;
        if(dp[curr][day] != -1) return dp[curr][day];
        int currScore = A[day][curr] + func(curr, day+1, n, k, A, B);
        for(int nextCity=0;nextCity<n;nextCity++){
            if(nextCity == curr) continue;
            currScore = max(currScore, B[curr][nextCity] + func(nextCity, day+1, n, k, A, B));
        }
        return dp[curr][day] = currScore;
    }
    
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        dp.clear();
        dp = vector<vector<int>>(n+1, vector<int>(k+1, -1));
        int answer = INT_MIN;
        for(int city=0;city<n;city++){
            answer = max(answer, func(city, 0, n, k, stayScore, travelScore));
        }
        return answer;
    }
};",1434300073
Nandy_Tragic,Nandy_Tragic,301,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        unordered_map<char,int>freq;
        int n = word.length();
        int answer = 1;
        for(int i=0;i<n;i++){
            int cnt = 0;
            int j = i;
            while(j<n && word[j] == word[i]){
                cnt++; j++;
            }
            answer += (cnt - 1);
            i = j;
            i--;
        }
        return answer;
    }
};

",1434264278
Sayan Das,Cp_worm,303,3576,cpp,"class Solution {
public:
    void dfs(int node, int depth, vector<vector<int>>& adj, vector<int>& depths, 
             vector<int>& firstOccurrence, string& s, vector<int>& newParent) {
        int c = s[node] - 'a';
        if(firstOccurrence[c] != -1 && firstOccurrence[c] != node) {
            newParent[node] = firstOccurrence[c];
        }
        int pre = firstOccurrence[c];
        firstOccurrence[c] = node;
        for(int child : adj[node]) {
            dfs(child, depth + 1, adj, depths, firstOccurrence, s, newParent);
        }
        firstOccurrence[c] = pre;
    }
     int countSize(int node, vector<vector<int>>& adj, vector<int>& result) {
        int lengh = 1;
        for(int child : adj[node]) {
            lengh += countSize(child, adj, result);
        }
        return result[node] = lengh;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>> adj(n);
        for(int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        vector<int> depths(n);
        vector<int> firstOccurrence(26, -1);
        vector<int> newParent = parent;
        dfs(0, 0, adj, depths, firstOccurrence, s, newParent);
        vector<vector<int>> newAdj(n);
        for(int i = 1; i < n; i++) {
            newAdj[newParent[i]].push_back(i);
        }
        vector<int> result(n);
        countSize(0, newAdj, result);
        return result;
    }
};",1434307884
Sayan Das,Cp_worm,303,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
          memset(dp, -1, sizeof(dp));
        vector<vector<vector<int>>> fl= {stayScore, travelScore};
        int maxPoints = 0;
        for (int st = 0; st < n; st++) {
            maxPoints = max(maxPoints, solve(0, st, k, n, fl[0], fl[1]));
        }
        
        return maxPoints;
    }
        int solve(int day, int currentCity, int k, int n, 
              vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        if (day == k) {
            return 0;
        }
        if (dp[day][currentCity] != -1) {
            return dp[day][currentCity];
        }
        
        int maxScore = 0;
        maxScore = max(maxScore, 
                      stayScore[day][currentCity] + 
                      solve(day + 1, currentCity, k, n, stayScore, travelScore));
        for (int next = 0; next< n; next++) {
            if (next != currentCity) {
                maxScore = max(maxScore, 
                             travelScore[currentCity][next] + 
                             solve(day + 1, next, k, n, stayScore, travelScore));
            }
        }
        return dp[day][currentCity] = maxScore;
    }

};",1434282189
Sayan Das,Cp_worm,303,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length();
        if (n == 1) return 1;
        set<string> pos;
        pos.insert(word);
        for (int i = 0; i < n - 1; i++) {
            if (word[i] == word[i + 1]) {
                int j = i + 1;
                while (j < n && word[j] == word[i]) {
                    string modified = word;
                    modified.erase(modified.begin() + i, modified.begin() + j);
                    pos.insert(modified);
                    j++;
                }
            }
        }
        return pos.size();
    }
};",1434261206
CyberPunk,U_U,305,3576,cpp,"class Solution {
public:
    vector<int> parents;
    vector<int> newParents;
    vector< vector<int> > adj, newAdj;
    vector<int> ans;
    int n;
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = s.size();
        parents = parent;
        newParents = parents;
        adj = buildAdj(parents);
        ans.assign(n, 0);

        vector<int> anc(26, -1);
        DFS(0, -1, s, anc);

        newAdj = buildAdj(newParents);
        subTree(0, -1);

        return ans;
    }

    int subTree(int u, int p)
    {
        int cnt = 1;
        for (auto& v : newAdj[u])
        {
            if (v == p) continue;
            cnt += subTree(v, u);
        }
        ans[u] = cnt;
        return cnt;
    }

    void DFS(int u, int p, string& s, vector<int>& anc)
    {
        int index = s[u] - 'a';
        if (anc[index] != -1) 
        {
          //  cout << u << "","" << index << "","" << anc[index] << ""|"" << s[u] << endl;
            newParents[u] = anc[index];
        }
        int backup = anc[index];
        anc[index] = u;
        
        for (auto& v : adj[u])
        {
            if (v == p) continue;
            int subIndex = s[v] - 'a';                        
            DFS(v, u, s, anc);            
        }
        anc[index] = backup;
    }

    vector< vector<int> > buildAdj(vector<int>& vec)
    {
        vector< vector<int> > temp(vec.size());

        for (int i = 0; i < vec.size(); ++i)
            {
                if (vec[i] != -1) temp[vec[i]].push_back(i);
            }

        return temp;
    }
};",1434287312
CyberPunk,U_U,305,3587,cpp,"class Solution {
public:
    vector< vector<int> > stay;
    vector< vector<int> > travel;
    int K, N;
    vector< vector<int> > mem;
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        stay = stayScore;
        travel = travelScore;
        K = k;
        N = n;

        mem.assign(K + 1, vector<int>(N + 1, -1));

        int res = 0;
        for (int i = 0; i < N; ++i)
            {
                res = max(res, DP(i, 0));
            }

        return res;
    }

    int DP(int cur, int index)
    {
        if (index == K) return 0;
        if (mem[index][cur] != -1) return mem[index][cur];

        int ret = 0;
        ret = max(ret, DP(cur, index + 1) + stay[index][cur]);

        for (int i = 0; i < N; ++i)
        {
            if (i == cur) continue;
            ret = max(ret, DP(i, index + 1) + travel[cur][i]);
        }

        mem[index][cur] = ret;
        return ret;
    }
};",1434300470
CyberPunk,U_U,305,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();

        int sum = 1;
        for (int i = 0; i < n; ++i)
            {         
                int start = i;
                for (; i < n && word[i] == word[start]; ++i)
                    {
                        
                    }                      
                --i;
                //cout << start << "","" << i << "","" << endl;
                if (i - start + 1 > 1) sum += i - start;                
            }

        return sum;
    }
};",1434265688
Pikachu0123,Pikachu0123,307,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        set<int> adj[n];
        for(int i=1; i<n; i++){
            adj[i].insert(parent[i]);
            adj[parent[i]].insert(i);
        }

        vector<vector<int>> freq(26);
        freq[s[0]-'a'].push_back(0);
        vector<int> change(n, -1);
        function<void(int,int)> dfs = [&](int node, int par){
            if (freq[s[node]-'a'].size() >= 2){
                int m = freq[s[node]-'a'].size();
                parent[node] = freq[s[node]-'a'][m-2];
            }
            for(auto x : adj[node]){
                if (x != par){
                    freq[s[x]-'a'].push_back(x);
                    dfs(x, node);
                    freq[s[x]-'a'].pop_back();
                }
            }
        };

        dfs(0, 0);
        vector<int> newAdj[n];
        for(int i=1; i<n; i++){
            newAdj[i].push_back(parent[i]);
            newAdj[parent[i]].push_back(i);
        }

        vector<int> ans(n, 0);
        function<void(int,int)> dfs2 = [&](int node, int par){
            ans[node] = 1;
            for(auto x : newAdj[node]){
                if (x != par){
                    dfs2(x, node);
                    ans[node] += ans[x];
                }
            }
        };

        dfs2(0, 0);
        return ans;
    }
};",1434292329
Pikachu0123,Pikachu0123,307,3587,cpp,"int dp[201][201];

class Solution {
    int solve(int cur, int days, int &n, int &k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
        if (days == k) return 0;
        if (dp[cur][days] != -1) return dp[cur][days];
        int ans = 0;
        for(int i=0; i<n; i++){
            if (cur == i){
                ans = max(ans, stayScore[days][cur] + solve(i, days + 1, n, k, stayScore ,travelScore));
            }

            else{
                ans = max(ans, travelScore[cur][i] + solve(i, days + 1, n, k, stayScore, travelScore));
            }
        }

        return dp[cur][days] = ans;
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        memset(dp, -1, sizeof dp);
        for(int i=0; i<n; i++){
            ans = max(ans, solve(i, 0, n, k, stayScore, travelScore));
        }

        return ans;
    }
};",1434308484
Pikachu0123,Pikachu0123,307,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {

        int ans = 0;
        int n = s.size();
        int i = 0;
        while(i < n){
            int j = i;
            while(j < n and s[i] == s[j]) j++;
            ans += j - i - 1;
            i = j;
        }

        return ans + 1;
    }
};",1434276452
deepak vishwakarma,deepak_v2003,308,3576,java,"import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        
        List<List<Integer>> adj = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            deepakParent(adj, parent[i], i);
        }

        int[] up = parent.clone();
        int[] ca = new int[26];
        for (int i = 0; i < 26; i++) ca[i] = -1;

        Function<Integer, Void> restructureTree = new Function<>() {
            @Override
            public Void apply(Integer node) {
                int ci = s.charAt(node) - 'a';
                if (deepakChild(ca[ci])) {
                    up[node] = ca[ci];
                }
                
                int pa = ca[ci];
                ca[ci] = node;

                for (int ch : adj.get(node)) {
                    apply(ch);
                }

                ca[ci] = pa;
                return null;
            }
        };
        restructureTree.apply(0);

        List<List<Integer>> newAdj = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            newAdj.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            newAdj.get(up[i]).add(i);
        }

        int[] ss = new int[n];
        for (int i = 0; i < n; i++) {
            ss[i] = deepakCount(i);
        }

        Function<Integer, Integer> computeSubtreeSize = new Function<>() {
            @Override
            public Integer apply(Integer node) {
                for (int ch : newAdj.get(node)) {
                    ss[node] += apply(ch);
                }
                if (node == 0 && ss[node] > 5) {
                    // System.out.println(""Subtree is large!"");
                } else if (ss[node] < 3) {
                    // System.out.println(""Subtree is small!"");
                }
                return ss[node];
            }
        };
        computeSubtreeSize.apply(0);

        return ss;
    }

    private void deepakParent(List<List<Integer>> adj, int parent, int child) {
        adj.get(parent).add(child);
    }

    private boolean deepakChild(int ancestor) {
        return ancestor != -1;
    }

    private int deepakCount(int node) {
        if (node % 2 == 0) {
            // System.out.println(""Even node"");
        } else {
            // System.out.println(""Odd node"");
        }
        return 1;
    }
}
",1434300958
deepak vishwakarma,deepak_v2003,308,3587,java,"class Solution {
    Integer[][][] dp;
    int[][] stay;
    int[][] travel;
    int n, k;
    int fvji;
    
    public int maxScore(int n, int k, int[][] stay, int[][] travel) {
        this.n = n;
        this.k = k;
        this.stay = stay;
        this.travel = travel;
        dp = new Integer[k][n][2];
        
        fvji = deepakGcd(n, k);
        
        int ans = 0;
        
        for (int sc = 0; sc < n; sc++) {
            ans = Math.max(ans, deepakRec(0, sc, 0));
        }
        
        if (deepaklarge(ans)) {
            deepaktree();
        }
        
        return ans;
    }
    
    private int deepakRec(int d, int cc, int spd) {
        if (d == k) {
            return 0;
        }
        
        if (dp[d][cc][spd] != null) {
            return dp[d][cc][spd];
        }
        
        int ans = 0;
        
        ans = Math.max(ans, stay[d][cc] + deepakRec(d + 1, cc, 1));
        
        for (int nc = 0; nc < n; nc++) {
            if (nc != cc) {
                ans = Math.max(ans, travel[cc][nc] + deepakRec(d + 1, nc, 0));
            }
        }
        
        return dp[d][cc][spd] = ans;
    }

    private int deepakGcd(int a, int b) {
        if (b == 0) {
            return a;
        } else {
            return deepakGcd(b, a % b);
        }
    }

    private boolean deepaklarge(int val) {
        return val > 100;
    }

    private void deepaktree() {
        System.out.println(""deepaktree function executed."");
    }
}
",1434286955
deepak vishwakarma,deepak_v2003,308,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int n = word.length();
        if (deepak1(n)) {
            return 1;
        }

        int count = 1;

        for (int i = 0; i < n - 1; i++) {
            if (word.charAt(i) == word.charAt(i + 1)) {
                int consecutiveCount = 1;
                while (i + 1 < n && word.charAt(i) == word.charAt(i + 1)) {
                    consecutiveCount++;
                    i++;
                }
                
                count += consecutiveCount - 1;
            } else {
                deepak2(word.charAt(i));
            }
        }
        
        return count;
    }

    // Dummy function to perform a check
    public boolean deepak1(int length) {
        if (length == 1) {
            return true;
        } else {
            return false;
        }
    }

    // Dummy function for character operation
    public void deepak2(char ch) {
        if (ch == 'a') {
            System.out.println(""Deepak2 function triggered."");
        } else {
            System.out.println(""Another character found."");
        }
    }
}
",1434260360
yc-li,yc-li,309,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = [[] for i in range(n)]
        for i, p in enumerate(parent):
            if p == -1:
                continue
            children[p].append(i)
        
        def dfs(i, tb):
            # print(i, tb, s[i], parent)
            if tb[s[i]] != -1:
                parent[i] = tb[s[i]]
            
            tb[s[i]] = i
            for c in children[i]:
                dfs(c, tb.copy())

        dfs(0, {c: -1 for c in s})
        
        children = [[] for i in range(n)]
        for i, p in enumerate(parent):
            if p == -1:
                continue
            children[p].append(i)
        
        ans = [0] * n
        def dfs(i):
            cnt = 1
            for c in children[i]:
                cnt += dfs(c)
            ans[i] = cnt
            return cnt
        dfs(0)
        # print(children, )
        return ans
            
        
            
            ",1434276007
yc-li,yc-li,309,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        vector<vector<int> > d(k, vector<int>(n, 0));
        
        for (int j = 0; j < n; ++j) {
            d[k - 1][j] = s[k - 1][j];
            for (int j_ = 0; j_ < n; ++j_) {
                d[k - 1][j] = max(d[k - 1][j], t[j][j_]);
            }
        }
        
        for (int i = k - 2; i >= 0; --i) {
            for (int j = 0; j < n; ++j) {
                d[i][j] = s[i][j] + d[i + 1][j];
                for (int j_ = 0; j_ < n; ++j_) {
                    d[i][j] = max(d[i][j], d[i + 1][j_] + t[j][j_]);
                    
                }
            }
        }
        // for (int i = k - 1; i >= 0; --i) {
        //     for (int j = 0; j < n; ++j) {
        //         cout << i << "" "" << j << "" "" << d[i][j] << ""\n"";
        //     }
        // }

        int ans = -1;
        for (int j = 0; j < n; ++j) {
            ans = max(ans, d[0][j]);
        }
        return ans;
    }
};",1434296627
yc-li,yc-li,309,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        cnt = 0
        i = 0
        ans = 1
        while i < n - 1:
            while word[i] == word[i + 1]:
                i += 1
                cnt += 1
                if i == n - 1:
                    break
            ans += cnt
            i += 1
            cnt = 0
        return ans",1434301195
Hrishabh Choudhary,hrishabh314,310,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        auto par1 = par;
        int n = par.size();
        vector<vector<int>> stk(26), children(n);
        for (int i = 1; i < n; i++) {
            children[par[i]].push_back(i);
        }
        function<void(int)> dfs = [&](int node) {
            if (!stk[s[node] - 'a'].empty()) {
                par1[node] = stk[s[node] - 'a'].back();
            }
            stk[s[node] - 'a'].push_back(node);
            for (auto child : children[node]) {
                dfs(child);
            }
            stk[s[node] - 'a'].pop_back();
        };
        dfs(0);
        vector<int> sz(n);
        vector<vector<int>> children2(n);
        for (int i = 1; i < n; i++) {
            children2[par1[i]].push_back(i);
        }
        function<void(int)> dfs2 = [&](int node) {
            sz[node] = 1;
            for (auto child : children2[node]) {
                dfs2(child);
                sz[node] += sz[child];
            }
        };
        dfs2(0);
        return sz;
    }
};",1434295630
Hrishabh Choudhary,hrishabh314,310,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<vector<int>> dp(n, vector<int>(k, -1));
        function<int(int, int)> f = [&](int city, int day) {
            if (day == k) return 0;
            if (dp[city][day] != -1) return dp[city][day];
            int res = ss[day][city] + f(city, day + 1);
            for (int ncity = 0; ncity < n; ncity++) {
                if (ncity == city) continue;
                res = max(res, ts[city][ncity] + f(ncity, day + 1));
            }
            return dp[city][day] = res;
        };
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, f(i, 0));
        }
        return ans;
    }
};",1434308845
Hrishabh Choudhary,hrishabh314,310,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int ans = 1, n = s.size(), cnt = 0;
        for (int i = 1; i < n; i++) {
            if (s[i] == s[i - 1]) {
                cnt++;
            } else {
                // cout << i << ' ' << cnt << ' ' << ans << '\n';
                ans += cnt;
                cnt = 0;
            }
        }
        ans += cnt;
        return ans;
    }
};",1434266369
urverymean,urverymean,311,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        nodeMap = defaultdict(list)
        for i in range(len(parent)):
            if parent[i]!=-1:
                nodeMap[parent[i]].append(i)
        #print(nodeMap)
        def dfs1(node, lst):
            #print(node, lst)
            if lst[ord(s[node])-97]!=None:
                parent[node] = lst[ord(s[node])-97]
            lst[ord(s[node])-97] = node
            for neighbor in nodeMap[node]:
                dfs1(neighbor, [x for x in lst])
        dfs1(0, [None]*26)
        nodeMap2 = defaultdict(list)
        for i in range(len(parent)):
            if parent[i]!=-1:
                nodeMap2[parent[i]].append(i)
        sz = [0]*len(parent)
        def dfs2(node):
            res = 1
            for neighbor in nodeMap2[node]:
                res+=dfs2(neighbor)
            sz[node] = res
            return res
        dfs2(0)
        return sz",1434302947
urverymean,urverymean,311,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @cache
        def dfs(city, day):
            if day==k:
                return 0
            res = stayScore[day][city] + dfs(city, day + 1)
            for i in range(len(travelScore)):
                if i==city:
                    continue
                res = max(res, travelScore[city][i] + dfs(i, day+1))
            return res
        res = 0
        for i in range(n):
            res = max(res, dfs(i,0))
        dfs.cache_clear()
        return res",1434308897
urverymean,urverymean,311,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        groups = []
        curr = 1
        for i in range(len(word)-2,-1,-1):
            if word[i]!=word[i+1]:
                groups.append(curr)
                curr = 0
            curr+=1
        groups.append(curr)
        res = 1
        #print(groups)
        for i in range(len(groups)):
            if groups[i]:
                res+=groups[i]-1
        return res",1434291028
henrychienhy,henrychienhy,312,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<vector<int>> adj_list(parent.size());
        for(int i = 1; i < parent.size(); i++) {
            adj_list[parent[i]].push_back(i);
        }
        vector<int> ancestor(26, -1);
        dfs1(0, adj_list, parent, ancestor, s);
        adj_list = vector<vector<int>>(parent.size());
        for(int i = 1; i < parent.size(); i++) {
            adj_list[parent[i]].push_back(i);
        }
        vector<int> res(parent.size());
        dfs2(0, adj_list, res);
        return res;
    }
    void dfs1(int cur, vector<vector<int>>& adj_list, vector<int>& parent, vector<int>& ancestor, string& s) {
        int tmp = ancestor[s[cur]-'a'];
        if (tmp != -1) {
            parent[cur] = tmp;
        }
        ancestor[s[cur] - 'a'] = cur;
        for(int u: adj_list[cur]) {
            dfs1(u, adj_list, parent, ancestor, s);
        }
        ancestor[s[cur] - 'a'] = tmp;
    }
    int dfs2(int cur, vector<vector<int>>& adj_list, vector<int>& res) {
        int cnt = 1;
        for(int u: adj_list[cur]) {
            cnt += dfs2(u, adj_list, res);
        }
        res[cur] = cnt;
        return cnt;
    }
};",1434293697
henrychienhy,henrychienhy,312,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(2, vector<int>(n, 0));
        for(int i = 1; i <= k; i++) {
            for(int dst = 0; dst < n; dst++) {
                dp[i%2][dst] = dp[(i-1)%2][dst] + stayScore[i-1][dst];
                for(int src = 0; src < n; src++) {
                    dp[i%2][dst] = max(dp[i%2][dst], dp[(i-1)%2][src] + travelScore[src][dst]);
                }
            }
        }
        int res = 0;
        for(int dst = 0; dst < n; dst++) {
            res = max(res, dp[k%2][dst]);
        }
        return res;
    }
};",1434308920
henrychienhy,henrychienhy,312,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        char prev = ' ';
        for(char c: word) {
            if (prev == c) {
                res++;
            }
            prev = c;
        }
        return res;
    }
};",1434262015
Sai Tarun Teja,samael135,313,3576,cpp,"class Solution {
public:
    vector<int> temp;
    vector<vector<int>>g;

    void dfs(int nn,int pp,vector<int>arr,string &s){
        if(arr[s[nn]-'a']!=-1)temp[nn]=arr[s[nn]-'a'];
        arr[s[nn]-'a']=nn;
        for(auto v:g[nn]){
            if(v!=pp){
                dfs(v,nn,arr,s);
            }
        }
    }

    int dfs2(int nn,int pp,vector<int>&ans){
        int cnt=1;
        for(auto v:g[nn]){
            if(v!=pp){
                cnt+=dfs2(v,nn,ans);
            }
        }
        return ans[nn]=cnt;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string &s) {
        temp=parent;
        g=vector<vector<int>>(parent.size()+1);
        for(int i=0;i<parent.size();i++){
            if(i==0) continue;
            g[parent[i]].push_back(i);
            g[i].push_back(parent[i]);
        }
        vector<int> arr(26,-1);
        dfs(0,-1,arr,s);
        g=vector<vector<int>>(parent.size()+1);
        for(int i=0;i<temp.size();i++){
            if(i==0) continue;
            g[temp[i]].push_back(i);
            g[i].push_back(temp[i]);
        }
        vector<int> ans(parent.size());
        dfs2(0,-1,ans);
        return ans;
    }
};",1434293640
Sai Tarun Teja,samael135,313,3587,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int rec(int curr,int day,vector<vector<int>>& stayScore,vector<vector<int>>& travelScore,int &k,int &n){ //max score I can earn when I am on city curr at day 'day'
        //pruning
        //base case
        if(day==k){
            return 0;
        }
        //cache check
        if(dp[curr][day]!=-1){
            return dp[curr][day];
        }
        //compute
        int ans = rec(curr,day+1,stayScore,travelScore,k,n) + stayScore[day][curr];
        for(int i=0;i<n;i++){
            ans=max(ans,travelScore[curr][i]+rec(i,day+1,stayScore,travelScore,k,n));
        }
        //save and return
        return dp[curr][day]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans=0;
        dp=vector<vector<int>>(n+1,vector<int>(k+1,-1));
        for(int i=0;i<n;i++){
            ans=max(ans,rec(i,0,stayScore,travelScore,k,n));
        }
        return ans;
    }
};",1434309093
Sai Tarun Teja,samael135,313,3617,cpp,"class Solution {
public:
    int possibleStringCount(string &word) {
        int n=word.size();
        int ans=1;
        int curr=0;
        while(curr<n){
            int i=curr;
            int cnt=0;
            while(i<n && word[i]==word[curr]){
                cnt+=1;
                i+=1;
            }
            curr=i;
            ans+=cnt-=1;
        }
        return ans;
    }
};",1434263143
Subodh,Subodh07,316,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); 

        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }

        // Step 1: Restructure tree based on character matching with ancestors
        vector<int> newParent = parent; 
        vector<int> closAnc(26, -1); 
        
        function<void(int)> solve = [&](int node) {
            int charIndex = s[node] - 'a';
            if (closAnc[charIndex] != -1) {
                newParent[node] = closAnc[charIndex];
            }
            
            // Update closet ancestor of curr node
            int previousAncestor = closAnc[charIndex];
            closAnc[charIndex] = node;
            
            for (int child : adj[node]) {
                solve(child);
            }
            
            // store for bcktracking
            closAnc[charIndex] = previousAncestor;
        };

        solve(0); // root node for dfs

        // Step 2:
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }

        // Step 3:
        vector<int> subtreeSize(n, 1);
        
        function<int(int)> calculateSubtreeSize = [&](int node) {
            for (int child : newAdj[node]) {
                subtreeSize[node] += calculateSubtreeSize(child);
            }
            return subtreeSize[node];
        };

        calculateSubtreeSize(0); 
        return subtreeSize;
    }
};",1434288378
Subodh,Subodh07,316,3587,cpp,"

class Solution {
private:
    vector<vector<vector<int>>> dp; 
    vector<vector<int>> stay; 
    vector<vector<int>> travel; 
    int n, k;
    
    int maxScoreRec(int day, int currCity, int prevDay) {
        if (day == k) { // if we reach
            return 0;
        }
        
        if (dp[day][currCity][prevDay] != -1) {
            return dp[day][currCity][prevDay];
        }

        int result = 0;

        // stay on same city and make recursive for for another 
        result = max(result, stay[day][currCity] + maxScoreRec(day + 1, currCity, 1));
        
        // got o new city and make tour
        for (int nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity != currCity) {
                result = max(result, travel[currCity][nextCity] + maxScoreRec(day + 1, nextCity, 0));
            }
        }

    
        return dp[day][currCity][prevDay] = result;
    }

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    bool isLarge(int value) {
        return value > 100;
    }

    void printTree() {
        cout << ""Tree function executed."" << endl;
    }

public:
    int maxScore(int cities, int days, vector<vector<int>>& stayPoints, vector<vector<int>>& travelPoints) {
        this->n = cities;
        this->k = days;
        this->stay = stayPoints;
        this->travel = travelPoints;
        
        dp.assign(k, vector<vector<int>>(n, vector<int>(2, -1))); 
        
        int answer = 0;

        for (int i = 0; i < n; i++) {
            answer = max(answer, maxScoreRec(0, i, 0));
        }

        if (isLarge(answer)) {
            printTree();
        }
        
        return answer;
    }
};

",1434301907
Subodh,Subodh07,316,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
    int length = word.size();

    if (length == 1) {
        return 1; 
    }

    int possibleCount = 1; 

    for (int i = 0; i < length - 1; ++i) { // check all cnt
        if (word[i] == word[i + 1]) {
            int sequenceCount = 1;

            while (i + 1 < length && word[i] == word[i + 1]) {
                sequenceCount++;
                i++;
            }

            possibleCount += sequenceCount - 1;
        }
    }

    return possibleCount;
    }
};",1434280362
Renaldy Arief Susanto,AldyPy,317,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        
        n = len(parent)
        adj = defaultdict(set)
        for i in range(n) :
            if i != 0 :
                adj[parent[i]].add(i)
            
        add = []    
        rm = []
        
        for char in 'abcdefghijklmnopqrstuvwxyz' :
            
            bfs = [(0, -1, (0 if char == s[0] else -1))]
            for u, parent, last in bfs :
                
                if u != 0 and char == s[u] :
                    if last != -1 :
                        add.append((last, u))
                        rm.append((parent, u))
                        
                    last = u
                        
                for v in adj[u] :
                    bfs.append((v, u, last))
        
    
        for p, ch in rm :
            adj[p].remove(ch)
        for p,ch in add :
            adj[p].add(ch)
        
        size = defaultdict(int)
        def dfs(u, p) :
            for v in adj[u] :
                if p == v : continue
                dfs(v, u)
                size[u] += size[v]
            size[u] += 1
        dfs(0, -1)
            
        return [size[i] for i in range(n)]",1434309507
Renaldy Arief Susanto,AldyPy,317,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        dp = [[0 for i in range(k + 1)] for i in range(n)]
        
        for d in reversed(range(k)) :
            
            for src in range(n) :
                dp[src][d] = max(dp[src][d], stayScore[d][src] + dp[src][d + 1])
    
            for src in range(n) :
                for dst in range(n) :            
                    dp[src][d] = max(dp[src][d], travelScore[src][dst] + dp[dst][d + 1])
        
        ans = 0
        for i in range(n) :
            ans = max(ans, dp[i][0])
        
        return ans",1434285371
Renaldy Arief Susanto,AldyPy,317,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        cnt = 1
        last = ''
        ans = 1
        for ch in word :
            
            if last == ch :
                cnt += 1
                
            else :
                ans += cnt - 1
                last = ch
                cnt = 1
        
        ans += cnt - 1
        return ans",1434268720
Vaibhav Sangwan,m_vishuu,318,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        ArrayList<Integer>[] childs = new ArrayList[n];
        for(int i = 0; i < n; i++)
            childs[i] = new ArrayList<>();
        for(int i = 1; i < n; i++)
            childs[parent[i]].add(i);

        int[] lastOccur = new int[26];
        Arrays.fill(lastOccur, -1);
        dfs(childs, 0, s, lastOccur, parent);

        childs = new ArrayList[n];
        for(int i = 0; i < n; i++)
            childs[i] = new ArrayList<>();
        for(int i = 1; i < n; i++)
            childs[parent[i]].add(i);

        int[] res = new int[n];
        helper(childs, 0, res);
        return res;
    }

    public int helper(ArrayList<Integer>[] childs, int i, int[] res) {
        int ans = 0;
        for(int child: childs[i])
            ans += helper(childs, child, res);
        ans++;
        res[i] = ans;
        return ans;
    }

    public void dfs(ArrayList<Integer>[] childs, int i, String s, int[] lastOccur, int[] par) {
        int c = s.charAt(i) - 'a';
        int occuredAt = lastOccur[c];
        lastOccur[c] = i;

        for(int child: childs[i]) {
            dfs(childs, child, s, lastOccur, par);
        }

        if(occuredAt != -1) 
            par[i] = occuredAt;
        lastOccur[c] = occuredAt;
    }
}

/*

for every character, while doing dfs, keep a track of last occurence
if we encounter that character again, change the parent

*/",1434309746
Vaibhav Sangwan,m_vishuu,318,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[] dp = new int[n];
        for(int ck = 0; ck < k; ck++) {
            int[] ndp = new int[n];
            for(int i = 0; i < n; i++) {
                for(int ne = 0; ne < n; ne++) {
                    ndp[ne] = Math.max(ndp[ne], dp[i] + travelScore[i][ne]);
                }
                ndp[i] = Math.max(ndp[i], dp[i] + stayScore[ck][i]);
            }
            dp = ndp;
        }
        int res = 0;
        for(int num: dp)
            res = Math.max(res, num);
        return res;
    }
}",1434290526
Vaibhav Sangwan,m_vishuu,318,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int n = word.length();
        int i = 0, j = 1;
        int res = 0;
        while(j < n) {
            if(word.charAt(j) == word.charAt(i)) {
                res++; 
            }
            else {
                i = j;
            }
            j++;
        }
        return res + 1;
    }
}",1434264310
Sai Krishna,slsk1998,319,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent, s: str):
        adj = {i : set() for i in range(len(s))}
        for i, p in enumerate(parent):
            if i == 0:
               continue
            adj[p].add(i)
        def dfs(root, parents):
            if root is None:
                return
            prev = None
            if s[root] in parents:
                parent[root] = parents[s[root]]
                prev = parent[root]
                parents[s[root]] = root
            else:
                parents[s[root]] = root
            for each in adj[root]:
                dfs(each, parents)
            if prev is None:
                parents.pop(s[root])
            else:
                parents[s[root]] = prev
        dfs(0, {})
        adj = {i : set() for i in range(len(s))}
        for i, p in enumerate(parent):
            if i == 0:
               continue
            adj[p].add(i)

        result = [0] * len(s)
        def getTotal(root):
            total = 0
            if len(adj[root]) == 0:
                result[root] = 1
                return 1
            for each in adj[root]:
                total += getTotal(each)
            result[root] = total + 1
            return result[root]
        getTotal(0)
        return result",1434300069
Sai Krishna,slsk1998,319,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def recursive(current, day):
            if day == k:
                return 0
            value = recursive(current, day + 1) + stayScore[day][current]
            for i in range(n):
                if current == n:
                    continue
                value = max(value, recursive(i, day + 1) + travelScore[current][i])
            return value
        result = 0
        for i in range(n):
            result = max(result, recursive(i, 0))
        return result",1434309751
Sai Krishna,slsk1998,319,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        last, i = '', 0
        result, length = 0, len(word)
        while(i < length):
            if last == word[i]:
                count = 0
                while(i < length and last == word[i]):
                    count += 1
                    i += 1
                result = result + count
            else:
                last = word[i]
                i += 1
        return result + 1
                
                ",1434269317
Manyu,ManyuD,320,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        new_par = {}
        adj = defaultdict(list)
        
        for i, v in enumerate(parent):
            adj[v].append(i)    

        def h(curr, seen):
            
            nonlocal new_par
            
            if seen[s[curr]]:
                new_par[curr] = seen[s[curr]][0]

            seen[s[curr]].appendleft(curr)

            for j in adj[curr]:
                h(j, seen)

            seen[s[curr]].popleft()

        h(0, defaultdict(deque))
        # print(new_par)

        adj = defaultdict(list)
        np = [-1] * len(parent)
        
        for i in range(len(parent)):
            if i in new_par:
                np[i] = new_par[i]
            else:
                np[i] = parent[i]

        for i, v in enumerate(np):
            adj[v].append(i)

        res = [0] * len(parent)
        
        def count(curr):

            r = 0

            for j in adj[curr]:
                r += count(j)

            res[curr] = r + 1
            return r + 1

        count(0)
        return res",1434290779
Manyu,ManyuD,320,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @cache
        def h(curr, day):

            if day >= len(stayScore):
                return 0

            res = stayScore[day][curr] + h(curr, day + 1)
            
            for poss in range(n):
                res = max(res, travelScore[curr][poss] + h(poss, day + 1))

            return res

        res = 0
        
        for start in range(n):
            res = max(res, h(start, 0))
            
        return res",1434302299
Manyu,ManyuD,320,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:

        n = len(word)
        res = 1
        prev = None
        co = 0
        
        for i in range(n):
            if word[i] != prev:
                if co > 1:
                    res += co - 1
                co = 1
                prev = word[i]
            else:
                co += 1

        if co > 1:
            res += co - 1
            
        return res

            
            ",1434270869
Andimeo,Andimeo,321,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        adj = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p == -1:
                continue
            adj[p].append(i)

        def dfs(u, ps):
            if s[u] in ps:
                parent[u] = ps[s[u]]
            ori = None
            if s[u] in ps:
                ori = ps[s[u]]
            ps[s[u]] = u
            for chd in adj[u]:
                dfs(chd, ps)
            if ori is not None:
                ps[s[u]] = ori
            else:
                del ps[s[u]]

        dfs(0, {})

        adj = [[] for _ in range(n)]
        for i, p in enumerate(parent):
            if p == -1:
                continue
            adj[p].append(i)

        ans = [0] * n
        def dfs2(u):
            c = 1
            for chd in adj[u]:
                c += dfs2(chd)
            ans[u] = c
            return c

        dfs2(0)
        return ans",1434277057
Andimeo,Andimeo,321,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1]*(n) for _ in range(k+1)]
        for i in range(n):
            dp[0][i] = 0
        for i in range(1, k + 1):
            for j in range(n):
                for l in range(n):
                    if j == l:
                        dp[i][j] = max(dp[i][j], dp[i-1][j] + stayScore[i-1][j])
                    else:
                        dp[i][j] = max(dp[i][j], dp[i-1][l] + travelScore[l][j])
        return max(dp[k])
                        ",1434289825
Andimeo,Andimeo,321,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        word += '$'
        n = len(word)
        l = 0
        ans = 1
        for i in range(1, n):
            if word[i] != word[l]:
                ans += i - l - 1
                l = i
        return ans
            ",1434294804
nicolaSaporetti,nicolaSaporetti,322,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        sz = s.size();
        g.resize(sz);
        for (int i = 1; i < sz; i++)
            g[parent[i]].push_back(i);
        v.assign(sz, vector<int>(26, -1));
        trav(0, s, parent);
        g.clear();
        g.resize(sz);
        for (int i = 1; i < sz; i++)
            g[parent[i]].push_back(i);
        r.resize(sz);
        comp(0);
        return r;
    }

private:
    void trav(int node, string& s, vector<int>& parent) {
        if (v[node][s[node] - 'a'] != -1) {
            parent[node] = v[node][s[node] - 'a'];
        }
        v[node][s[node] - 'a'] = node;
        for (auto e : g[node]) {
            for (int i = 0; i < 26; i++)
                v[e][i] = v[node][i];
            trav(e, s, parent);
        }
    }
    int comp(int node) {
        int v = 1;
        for (auto e : g[node]) {
            v += comp(e);
        }
        r[node] = v;
        return v;
    }
    vector<vector<int>> v;
    vector<vector<int>> g;
    vector<int> r;
    int sz;
};",1434294058
nicolaSaporetti,nicolaSaporetti,322,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> v(n);
        for(int d=0;d<k;d++)
        {
            vector<int> nv(n);
            for(int j=0;j<n;j++)
                {
                    nv[j]=max(nv[j],v[j]+stayScore[d][j]);
                for(int i=0;i<n;i++) nv[i]=max(nv[i],v[j]+travelScore[j][i]);
                }
            v=nv;
        }
        return *max_element(begin(v),end(v));
    }
};",1434310267
nicolaSaporetti,nicolaSaporetti,322,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int r = 1;
        for(int i=0;i<word.size();i++)
            {
                if(i>0 && word[i]==word[i-1]) r++;
            }
        return r;
    }
};",1434260582
Akash,Ak_a_sh,324,3576,java,"class Solution {
    private void reassignParents(int node, List<List<Integer>> tree, String s, int[] newParent, Map<Character, Integer> closestAncestor) {
        char nodeChar = s.charAt(node);
        
        for (int child : tree.get(node)) {
            char childChar = s.charAt(child);
            Integer closest = closestAncestor.get(childChar);
            if (closest != null && closest != node) {
                newParent[child] = closest;
            }
            
            Integer previousAncestor = closestAncestor.put(childChar, child);
            reassignParents(child, tree, s, newParent, closestAncestor);
            
            if (previousAncestor == null) {
                closestAncestor.remove(childChar);
            } else {
                closestAncestor.put(childChar, previousAncestor);
            }
        }
    }
    private int computeSubtreeSizes(int node, List<List<Integer>> tree, int[] subtreeSizes) {
        int size = 1;
        for (int child : tree.get(node)) {
            size += computeSubtreeSizes(child, tree, subtreeSizes);
        }
        subtreeSizes[node] = size;
        return size;
    }
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            tree.add(new ArrayList<>());
        }
        
        for (int i = 1; i < n; i++) {
            tree.get(parent[i]).add(i);
        }

        int[] newParent = Arrays.copyOf(parent, n);
        Map<Character, Integer> closestAncestor = new HashMap<>();
        closestAncestor.put(s.charAt(0), 0);

        reassignParents(0, tree, s, newParent, closestAncestor);

        List<List<Integer>> newTree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            newTree.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            newTree.get(newParent[i]).add(i);
        }

        int[] subtreeSizes = new int[n];
        computeSubtreeSizes(0, newTree, subtreeSizes);

        return subtreeSizes;
    }
}",1434281870
Akash,Ak_a_sh,324,3587,java,"class Solution {
    private int findMax(int city, int day, int maxDay,int cities, int[][] stay, int[][] travel, int[][] dp){
        if(day == maxDay) return 0;

        if(dp[city][day] != -1) return dp[city][day];

        int s = stay[day][city] + findMax(city, day+1, maxDay,cities, stay, travel, dp);
        int t = 0;

        for(int i=0;i<cities;i++){
            if(i == city) continue;
            t = Math.max(t, travel[city][i] + findMax(i, day+1, maxDay, cities, stay, travel, dp));
        }

        return dp[city][day] = Math.max(s, t);
    }
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int max = 0;

        int[][] dp = new int[n][k];
        for(int i=0;i<n;i++){
            Arrays.fill(dp[i], -1);
        }

        for(int i=0;i<n;i++){
            max = Math.max(max, findMax(i, 0, k,n, stayScore, travelScore, dp));
        }
        return max;
    }
}",1434303516
Akash,Ak_a_sh,324,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int cnt = 0;
        for(int i=1;i<word.length();i++){
            if(word.charAt(i) == word.charAt(i-1)) cnt++;
        }
        
        return cnt+1;
    }
}",1434264375
Anshul Agarwal,anshulagarwal3131,325,3576,cpp,"class Solution {
public:
    vector<vector<int>> adj,adj2;
    void dfs(int nod,int par,vector<int> &parent,vector<vector<int>> &v,string &s){
        if(!v[s[nod]-'a'].empty())
            parent[nod] = v[s[nod]-'a'].back();
        v[s[nod]-'a'].push_back(nod);
        for(auto i : adj[nod])
        {
            if(i!=par)
                dfs(i,nod,parent,v,s);
        }
        v[s[nod]-'a'].pop_back();
    }
    vector<int> ssize;
    void dfs2(int nod,int par){
        ssize[nod] = 1;
        for(auto i : adj2[nod])
        {
            if(i!=par){
                dfs2(i,nod);
                ssize[nod]+=ssize[i];
            }
        }
        
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        adj.resize(n);
        ssize.resize(n);
        adj2.resize(n);
        for(int i = 1;i<n;i++)
        {
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        vector<vector<int>> v(26);
        dfs(0,-1,parent,v,s);
        for(int i = 1;i<n;i++)
        {
            adj2[i].push_back(parent[i]);
            adj2[parent[i]].push_back(i);
        }
        dfs2(0,-1);
        return ssize;
        
        
    }
};",1434285885
Anshul Agarwal,anshulagarwal3131,325,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1,vector<int> (n));
        int res = 0;
        for(int i = 1;i<=k;i++){
            for(int j = 0;j<n;j++){
                int temp = stayScore[i-1][j]+dp[i-1][j];
                for(int u = 0;u<n;u++){
                    if(j==u)
                        continue;
                    temp = max(temp,dp[i-1][u]+travelScore[u][j]);
                }
                dp[i][j] = temp;
                res = max(res,temp);
            }
        }
        return res;
    }
};",1434303563
Anshul Agarwal,anshulagarwal3131,325,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int x = 0;
        for(int i = 0;i<n;){
            int j = i;
            while(i<n && word[i]==word[j])
                i++;
            x++;
        }
        return n-x+1;
    }
};",1434263370
Ethan Gu,rtdrtd67,327,3576,cpp,"class Solution {
public:
    void dfs(vector<int>& parent, vector<vector<int>>& tree, string& s, int i, vector<int>& close) {
        if (close[s[i]-'a'] != -1) {
            parent[i] = close[s[i] - 'a'];
        }
        int prev = close[s[i]-'a'];
        close[s[i]-'a'] = i;
        for (int child : tree[i]) {
            dfs(parent, tree, s, child, close);
        }
        close[s[i]-'a'] = prev;
    }
    int size(vector<vector<int>>& tree, int i, vector<int>& sz) {
        int res = 1;
        for (int child : tree[i]) {
            res += size(tree, child, sz);
        }
        sz[i] = res;
        return res;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; i++) {
            tree[parent[i]].push_back(i);
        }
        vector<int> close(26, -1);
        dfs(parent, tree, s, 0, close);
        vector<vector<int>> n_tree(n);
        for (int i = 1; i < n; i++) {
            n_tree[parent[i]].push_back(i);
        }
        vector<int> res(n, 0);
        size(n_tree, 0, res);
        return res;
    }
};",1434291351
Ethan Gu,rtdrtd67,327,3587,cpp,"class Solution {
public:
    int help(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& dp, int city, int day) {
        if (day >= k) {
            return 0;
        }
        if (dp[day][city] != -1) {
            return dp[day][city];
        }
        dp[day][city] = stayScore[day][city] + help(n, k, stayScore, travelScore, dp, city, day+1);
        for (int dest = 0; dest < n; dest ++) {
            dp[day][city] = max(dp[day][city], travelScore[city][dest] + help(n, k, stayScore, travelScore, dp, dest, day+1));
        }
        return dp[day][city];
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1, vector<int>(n+1, -1));
        for (int i = 0; i < n; i++) {
            help(n, k, stayScore, travelScore, dp, i, 0);
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            
            res = max(res, dp[0][i]);
        }
        return res;
    }
};",1434303946
Ethan Gu,rtdrtd67,327,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> counts(26, 0);
        int res = 0;
        int prev_i = 0;
        char cur_char = word[0];
        for (int i = 0; i < word.size(); i++) {
            char c = word[i];
            if (c != cur_char) {
                cur_char = c;
                res += i - prev_i - 1;
                prev_i = i;
            }
            if (i == word.size() - 1) {
                res += i - prev_i;
            }
        }
        // for (int x : counts) {
        //     res += max(0,x-1);
        // }
        return res+1;
    }
};",1434264824
Gaurav,soulgaurav08,328,3576,python3,"class Solution:
    def __init__(self):
        self.final_tree = defaultdict(list)
        self.res = []

    def calculate_subtree_size(self, node: int) -> int:
        size = 1
        for child in self.final_tree[node]:
            size += self.calculate_subtree_size(child)
        self.res[node] = size
        return size

    def build_final_tree(self, parent: List[int], s: str) -> List[int]:
        adj = defaultdict(list)
        
        for i in range(1, len(parent)):
            adj[parent[i]].append(i)
        
        new_parent = parent[:]
        closest_ancestor = {}

        def dfs(node: int):
            prev_ancestor = closest_ancestor.get(s[node], None)
            closest_ancestor[s[node]] = node
            
            for child in adj[node]:
                if s[child] in closest_ancestor:
                    new_parent[child] = closest_ancestor[s[child]]
                
                dfs(child)
            
            if prev_ancestor is not None:
                closest_ancestor[s[node]] = prev_ancestor
            else:
                del closest_ancestor[s[node]]

        dfs(0)
        
        for i in range(1, len(parent)):
            self.final_tree[new_parent[i]].append(i)
        
        return new_parent

    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        self.res = [0] * len(parent)
        
        self.build_final_tree(parent, s)
        
        self.calculate_subtree_size(0)
        
        return self.res
",1434287694
Gaurav,soulgaurav08,328,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @lru_cache(None)
        def recursion(day, current_city):
            if day == k:
                return 0
            
            res = stayScore[day][current_city] + recursion(day + 1, current_city)
            
            for next_city in range(n):
                if next_city != current_city:
                    res = max(res,
                                     travelScore[current_city][next_city] + recursion(day + 1, next_city))
            
            return res
        
        return max(recursion(0, start_city) for start_city in range(n))
",1434304232
Gaurav,soulgaurav08,328,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 0
        for i in range(1, len(word)):
            if word[i] == word[i - 1]:
                res += 1

        return res + 1
",1434271776
kumud22,kumud22,329,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        
        vector<int> newParent = parent; 
        unordered_map<char, stack<int>> closest;
        
        function<void(int)> dfs = [&](int node) {
            char curr = s[node];
            
            if (closest.count(curr) && !closest[curr].empty()) {
                int ancestor = closest[curr].top();
                if (ancestor != newParent[node]) {
                    newParent[node] = ancestor; 
                }
            }
            
            closest[curr].push(node);
            
            for (int child : adj[node]) {
                dfs(child);
            }
            
            closest[curr].pop();
        };
        
        dfs(0);
        
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }
        
        vector<int> sz(n, 0);
        
        function<int(int)> dfs2 = [&](int node) {
            int size = 1;  
            for (int child : newAdj[node]) {
                size += dfs2(child); 
            }
            sz[node] = size;
            return size;
        };
        
        dfs2(0);
        
        return sz;
    }
};
",1434311791
kumud22,kumud22,329,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = k - 1; day >= 0; --day) {
            for (int curr = 0; curr < n; ++curr) {
                dp[day][curr] = stayScore[day][curr] + dp[day + 1][curr];
                
                for (int dest = 0; dest < n; ++dest) {
                    if (curr != dest) {
                        dp[day][curr] = max(dp[day][curr], travelScore[curr][dest] + dp[day + 1][dest]);
                    }
                }
            }
        }
        
        int maxPoints = 0;
        for (int city = 0; city < n; ++city) {
            maxPoints = max(maxPoints, dp[0][city]);
        }
        
        return maxPoints;
    }
};
",1434296934
kumud22,kumud22,329,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 0;  
        int res = 1;  
        char prev = '\0';  

        for (char ch : word) {
            if (prev == ch) {
                ++cnt;
            } else {
                res += (cnt > 0) ? cnt : 0;  
                cnt = 0; 
                prev = ch;  
            }
        }

        res += (cnt > 0) ? cnt : 0;

        return res;
    }
};
",1434266747
sumitdwivedi745,sumitdwivedi745,330,3576,cpp,"#include <vector>
#include <string>
#include <unordered_map>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        vector<int> answer(n, 1);  // Initialize subtree sizes to 1 (each node counts as its own subtree)
        
        // Build the initial tree structure
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        // Map to keep track of last seen nodes for each character
        unordered_map<char, stack<int>> lastSeen;
        
        // DFS function to modify tree structure
        function<void(int)> dfsReparent = [&](int node) {
            char c = s[node];
            if (lastSeen[c].size() > 0) {
                int ancestor = lastSeen[c].top();
                parent[node] = ancestor;  // Re-root the node to the new parent
            }
            
            // Add node to last seen stack
            lastSeen[c].push(node);
            
            // Recursively process child nodes
            for (int child : tree[node]) {
                dfsReparent(child);
            }
            
            // Remove node from last seen stack after processing
            lastSeen[c].pop();
        };

        // Re-root the tree according to new parent-child relationships
        dfsReparent(0);

        // Clear tree and rebuild based on new parent relationships
        tree.clear();
        tree.resize(n);
        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }

        // DFS function to calculate subtree sizes
        function<int(int)> dfsSubtreeSize = [&](int node) {
            int size = 1;
            for (int child : tree[node]) {
                size += dfsSubtreeSize(child);
            }
            return answer[node] = size;
        };

        // Calculate subtree sizes
        dfsSubtreeSize(0);
        
        return answer;
    }
};
",1434271241
sumitdwivedi745,sumitdwivedi745,330,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int i = 0; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + stayScore[i][j]);
                for (int m = 0; m < n; ++m) {
                    if (j != m) dp[i + 1][m] = max(dp[i + 1][m], dp[i][j] + travelScore[j][m]);
                }
            }
        }
        return *max_element(dp[k].begin(), dp[k].end());
    }
};
",1434289269
sumitdwivedi745,sumitdwivedi745,330,3617,cpp,"#include <string>
#include <vector>

class Solution {
public:
    int possibleStringCount(std::string word) {
        // Step 1: Identify consecutive character groups and their lengths
        std::vector<int> groupLengths;
        int i = 0;
        
        while (i < word.size()) {
            int j = i;
            // Find length of the current group of identical characters
            while (j < word.size() && word[j] == word[i]) {
                j++;
            }
            groupLengths.push_back(j - i);
            i = j;
        }
        
        // Step 2: Calculate the number of possible original strings
        int possibleStrings = 1; // Start with the original string (no typo)
        
        for (int length : groupLengths) {
            if (length > 1) {
                possibleStrings += (length - 1); // Each group can reduce its length by 1 to k-1
            }
        }
        
        return possibleStrings;
    }
};
",1434264603
Striver,Striver-,331,3576,python3,"class Solution:
    def findSubtreeSizes(self, p: List[int], s: str) -> List[int]:
        n = len(p)
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[p[i]].append(i)
        
        new_p = p.copy()
        seen = {}
        
        def dfs(node):
            if s[node] in seen:
                new_p[node] = seen[s[node]]
            prev = seen.get(s[node], -1)
            seen[s[node]] = node
            for child in tree[node]:
                dfs(child)
            if prev == -1:
                del seen[s[node]]
            else:
                seen[s[node]] = prev
        
        dfs(0)
        
        new_tree = [[] for _ in range(n)]
        for i in range(1, n):
            new_tree[new_p[i]].append(i)
        
        res = [0] * n
        
        def count(node):
            total = 1
            for child in new_tree[node]:
                total += count(child)
            res[node] = total
            return total
        
        count(0)
        return res",1434283428
Striver,Striver-,331,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        prev = [stayScore[0][c] for c in range(n)]
        for c in range(n):
            for p in range(n):
                if p != c:
                    prev[c] = max(prev[c], travelScore[p][c])
        
        for day in range(1, k):
            curr = [0] * n
            for c in range(n):
                stay = prev[c] + stayScore[day][c]
                move = float('-inf')
                for p in range(n):
                    if p != c:
                        move = max(move, prev[p] + travelScore[p][c])
                curr[c] = max(stay, move)
            prev = curr
        return max(prev)",1434304972
Striver,Striver-,331,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        if not word:
            return 0
        
        total = 1
        current = word[0]
        count = 1
        
        for c in word[1:]:
            if c == current:
                count += 1
            else:
                if count > 1:
                    total += (count - 1)
                current = c
                count = 1
        if count > 1:
            total += (count - 1)
        
        return total",1434278908
brogrammer121,brogrammer121,333,3576,python3,"class Solution:
    def dfs(self, i: int, ancestors: Dict[str, List[int]]):
        c = self.s[i]

        if ancestors[c]:
            self.new_parent[i] = ancestors[c][-1]
        else:
            self.new_parent[i] = self.parent[i]

        ancestors[c].append(i)
        for child in self.adj_list[i]:
            self.dfs(child, ancestors)

        ancestors[c].pop()

    def get_size(self, i: int) -> int:
        child_sizes = 0
        for child in self.new_adj_list[i]:
            child_sizes += self.get_size(child)

        self.size[i] = child_sizes + 1
        return child_sizes + 1
    
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        self.parent = parent
        self.s = s
        self.new_parent = [-1 for _ in range(n)]
        self.new_adj_list = [[] for _ in range(n)]
        self.adj_list = [[] for _ in range(n)]
        self.size = [1 for _ in range(n)]

        for i, p in enumerate(parent):
            if p != -1:
                self.adj_list[p].append(i)

        self.dfs(0, defaultdict(list))

        for i, p in enumerate(self.new_parent):
            if p != -1:
                self.new_adj_list[p].append(i)
        
        self.get_size(0)

        return self.size",1434295003
brogrammer121,brogrammer121,333,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]

        for d in range(1, k + 1):
            for dest in range(n):
                for start in range(n):
                    gain = stayScore[d - 1][start] if start == dest else travelScore[start][dest]
                    dp[d][dest] = max(dp[d][dest], dp[d - 1][start] + gain)

        return max(dp[k])",1434313189
brogrammer121,brogrammer121,333,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 1
        prev = ''

        for c in word:
            if c == prev:
                count += 1
            prev = c

        return count",1434261182
drknzz,drknzz,334,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        children = defaultdict(list)
        for idx, x in enumerate(parent):
            children[x].append(idx)

        # print(children)
        new_parent = parent[::]
        
        def go(x, ancestors):
            if ancestors[s[x]] != -1:
                new_parent[x] = ancestors[s[x]]
                
            for y in children[x]:
                tmp = ancestors[s[x]]
                ancestors[s[x]] = x
                go(y, ancestors)
                ancestors[s[x]] = tmp

        n = len(parent)
        go(0, defaultdict(lambda: -1))
        # print(new_parent)

        children = defaultdict(list)
        for idx, x in enumerate(new_parent):
            children[x].append(idx)

        def get_res(x):
            r = 1
            for y in children[x]:
                r += get_res(y)
            res[x] = r
            return r

        res = [1] * n
        get_res(0)
        # print(res)
        return res
",1434293981
drknzz,drknzz,334,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def go(i, city):
            if i == k:
                return 0
            res = stayScore[i][city] + go(i + 1, city)
            for dest in range(n):
                res = max(res, travelScore[city][dest] + go(i + 1, dest))
            return res
            
        return max(go(0, x) for x in range(n))",1434305768
drknzz,drknzz,334,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        for k, g in itertools.groupby(word):
            res += len(list(g)) - 1
        return res",1434259951
Keerthi Vasan S A,keerthivasansa,335,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> charMap(26, -1);
        int n = parent.size();
        vector<vector<int>> adj(n, vector<int>());
        for (int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);

        function<void(int)> dfs = [&](int node) {
            char c = s[node];
            int last = charMap[c - 'a'];
            if (last != -1)
                parent[node] = last; 
            charMap[c - 'a'] = node;
            for (int neigh: adj[node])
                dfs(neigh);
            charMap[c - 'a'] = last;
        };

        dfs(0);

        vector<int> ans(n);
        
        vector<vector<int>> nAdj(n, vector<int>());
        for (int i = 1; i < n; i++)
            nAdj[parent[i]].push_back(i);
        
        function<int(int)> getSize = [&](int node) {
            int size = 1;
            for (int neigh: nAdj[node])
                size += getSize(neigh);
            return ans[node] = size;
        };

        getSize(0);
        
        return ans;
    }
};",1434286521
Keerthi Vasan S A,keerthivasansa,335,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, -1));
        
        function<int(int, int)> getMax = [&](int day, int city) {
            if (day == k)
                return 0;
            if (dp[day][city] != -1)
                return dp[day][city];
            // stay
            int score = stayScore[day][city] + getMax(day + 1, city);
            for (int j = 0; j < n; j++) {
                score = max(score, travelScore[city][j] + getMax(day + 1, j));
            }
            return dp[day][city] = score;
        };

        int ans = INT_MIN;
        for (int i = 0; i < n; i++)
            ans = max(ans, getMax(0, i));
        return ans;
    }
};",1434313278
Keerthi Vasan S A,keerthivasansa,335,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int count = 0;
        char c = ' ';
        for (int i = 0; i < word.size(); i++) {
            if (c == word[i])
                count++;
            else {
                ans += count;
                count = 0;
                c = word[i];
            }
        }
        ans += count;
        return ans;
    }
};",1434263619
jackey,jackeyhua,337,3576,golang,"
func findSubtreeSizes(parent []int, s string) []int {
    n := len(parent)
	ans := make([]int, n)

	occur := make([][]int, 26)
	g := make([][]int, n)
	for i, v := range parent {
		if i == 0 {
			continue
		}
		g[v] = append(g[v], i)
	}

	var dfs func(int)
	dfs = func(index int)  {
		nn := len(occur[s[index] - 'a'])
		if nn != 0 {
			parent[index] = occur[s[index] - 'a'][nn - 1]
		}
		occur[s[index] - 'a'] = append(occur[s[index]-'a'], index)
		for _, nxt := range g[index] {
			dfs(nxt)
		}
		occur[s[index] - 'a'] = occur[s[index] - 'a'][: nn]
	}
	dfs(0)

	var dfs2 func(int) int 

	g2 := make([][]int, n)
	for i, v := range parent {
		if i == 0 {
			continue
		}
		g2[v] = append(g2[v], i)
	}

	dfs2 = func(index int) int {
		cnt := 1
		for _, nxt := range g2[index] {
			cnt += dfs2(nxt)
		}
		ans[index] = cnt
		return cnt
	}
	dfs2(0)
	return ans
}",1434294930
jackey,jackeyhua,337,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int i = 0; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                dp[i + 1][j] = dp[i][j] + stayScore[i][j];
                for (int k = 0; k < n; ++k) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][k] + travelScore[k][j]);
                }
            }
        }
        return ranges::max(dp.back());
    }
    
};",1434313422
jackey,jackeyhua,337,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 1;
        int left = 0;
        while (left < n) {
            int right = left + 1;
            while (right < n && word[left] == word[right]) ++right;
            ans += (right - left - 1);
            left = right;
        }      
        return ans;
    }
};",1434264409
Kawin Rattanapun,athensclub,338,3576,java,"class Solution {

    private void visit(int node, int[] parent, String s, Map<Integer, List<Integer>> children,
            Map<Character, Integer> closest) {
        if (closest.containsKey(s.charAt(node)))
            parent[node] = closest.get(s.charAt(node));

        closest = new HashMap<>(closest);
        closest.put(s.charAt(node), node);
        for (int child : children.getOrDefault(node, Collections.emptyList()))
            visit(child, parent, s, children, closest);
    }

    private int countSize(int node, Map<Integer, List<Integer>> children, Map<Integer, Integer> size) {
        int sum = 1;
        for (int child : children.getOrDefault(node, Collections.emptyList()))
            sum += countSize(child, children, size);
        size.put(node, sum);
        return sum;
    }

    public int[] findSubtreeSizes(int[] parent, String s) {
        Map<Integer, List<Integer>> children = new HashMap<>();
        for (int node = 0; node < parent.length; node++)
            children.computeIfAbsent(parent[node], x -> new ArrayList<>()).add(node);

        int root = -1;
        for (int i = 0; i < parent.length; i++)
            if (parent[i] == -1)
                root = i;

        visit(root, parent, s, children, new HashMap<>());
        children = new HashMap<>();
        for (int node = 0; node < parent.length; node++)
            children.computeIfAbsent(parent[node], x -> new ArrayList<>()).add(node);

        Map<Integer, Integer> size = new HashMap<>();
        countSize(root, children, size);

        int[] ans = new int[parent.length];
        for(int i = 0;i < ans.length;i++)
            ans[i] = size.get(i);
        return ans;
    }
}",1434302908
Kawin Rattanapun,athensclub,338,3587,java,"class Solution {

    private int findBest(int index, int curr, int[][] stayScore, int[][] travelScore, int[][] memo){
        if(index >= stayScore.length || curr >= stayScore[index].length) return 0;

        if(memo[index][curr] >= 0) return memo[index][curr];
        
        int ans = 0;
        for(int i = 0;i < stayScore[index].length;i++)
            ans = Math.max(ans, (i == curr ? stayScore[index][curr] : travelScore[curr][i]) + findBest(index+1, i, stayScore, travelScore, memo));
        return (memo[index][curr] = ans);
    }
    
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] memo = new int[k][n];
        for(int[] arr : memo) Arrays.fill(arr, -1);
        
        int ans = 0;
        for(int i = 0;i < stayScore[0].length;i++)
            ans = Math.max(ans, findBest(0, i, stayScore, travelScore, memo));
        return ans;
    }
}",1434314294
Kawin Rattanapun,athensclub,338,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        char current = word.charAt(0);
        int count = 0;
        for(int i = 1;i < word.length();i++){
            if(word.charAt(i) != current) {
                ans += count;
                current = word.charAt(i);
                count = 0;
            } else {
                count++;
            }
        }
        ans += count;
        return ans;
    }
}",1434263483
Sourashis Mondal,sourashisHmm,339,3576,cpp,"class Solution {
public:

    // nearest ancestor
    vector<vector<int>> na;
    int n;
    vector<bool> done;

    void fill_na(int u, vector<int> &parent, string &s) {
        if (parent[u] == -1 || done[u]) return;
        fill_na(parent[u], parent, s);
        for (char ch = 0; ch < 26; ++ch) {
            na[ch][u] = na[ch][parent[u]];
        }
        
        na[s[parent[u]] - 'a'][u] = parent[u]; 
        done[u] = true;
    }

    int compute_size(int root, vector<vector<int>> &children, vector<int> &res) {
        int curr_size = 1;
        for (int v: children[root]) {
            curr_size += compute_size(v, children, res);
        }
        return res[root] = curr_size;        
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = parent.size();
        na = vector<vector<int>>(26, vector<int>(n, -1));
        done = vector<bool>(n, false);
        
        for (int u = 0; u < n; ++u) 
            fill_na(u, parent, s);
        
        // return {};
        
        vector<vector<int>> children(n);
        for (int u = 0; u < n; ++u) {
            int new_par = parent[u];
            if (na[s[u] - 'a'][u] != -1) {
                new_par = na[s[u] - 'a'][u];
            }
            if (new_par != -1) children[new_par].push_back(u);
        }

        vector<int> res(n, 0);
        compute_size(0, children, res);

        return res;
    }
};",1434296557
Sourashis Mondal,sourashisHmm,339,3587,cpp,"class Solution {
public:

    int n;
    int k;
    vector<vector<int>> stayScore;
    vector<vector<int>> travelScore;

    vector<vector<int>> memo;

    int ms(int curr_city, int curr_day) {
        if (curr_day >= k) return 0;
        if (memo[curr_city][curr_day] != -1) return memo[curr_city][curr_day];
        
        int m1 = stayScore[curr_day][curr_city] + ms(curr_city, curr_day + 1);
        int m2 = 0;
        for (int new_city = 0; new_city < n; ++new_city)
            m2 = max(m2, ms(new_city, curr_day + 1) + travelScore[curr_city][new_city]);

        return memo[curr_city][curr_day] = max(m1, m2);
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        this->n = n;
        this->k = k;
        this->stayScore = stayScore;
        this->travelScore = travelScore;
        memo = vector<vector<int>>(n, vector<int>(k, - 1));
        
        int res = 0;
        for (int u = 0; u < n; ++u)
            res = max(res, ms(u, 0));

        return res;
    }
};",1434314451
Sourashis Mondal,sourashisHmm,339,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        long long res = 1;
        int i = 0, j = 0;
        int n = word.size();
        while (i < n && j < n) {
            while(j < n && word[i] == word[j]) ++j;
            int count = j - i;
            i = j;
            res += count - 1;
            // printf(""\ncount=%d, res=%d"", count, res);
        }
        return res;
        
    }
};",1434263894
RAVEESH GAUTAM,Raveesh_gautam,340,3576,java,"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        int[] subtreeSizes = new int[n];
        List<List<Integer>> adjacencyList = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            subtreeSizes[i] = 1;
            adjacencyList.add(new ArrayList<>());
        }

        for (int i = 1; i < n; i++) {
            adjacencyList.get(parent[i]).add(i);
        }

        int[] updatedParents = parent.clone();
        Map<Character, List<Integer>> lastCharacterPosition = new HashMap<>();

        updateParent(0, s, adjacencyList, updatedParents, lastCharacterPosition);

        List<List<Integer>> finalAdjacencyList = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            finalAdjacencyList.add(new ArrayList<>());
        }

        for (int i = 1; i < n; i++) {
            finalAdjacencyList.get(updatedParents[i]).add(i);
        }

        computeSubtreeSizes(0, finalAdjacencyList, subtreeSizes);
        return subtreeSizes;
    }

    private void updateParent(int node, String s, List<List<Integer>> adjacencyList, int[] updatedParents, Map<Character, List<Integer>> lastCharacterPosition) {
        char currentChar = s.charAt(node);
        lastCharacterPosition.putIfAbsent(currentChar, new ArrayList<>());

        if (!lastCharacterPosition.get(currentChar).isEmpty()) {
            int previousNode = lastCharacterPosition.get(currentChar).get(lastCharacterPosition.get(currentChar).size() - 1);
            updatedParents[node] = previousNode;
        }

        lastCharacterPosition.get(currentChar).add(node);

        for (int child : adjacencyList.get(node)) {
            updateParent(child, s, adjacencyList, updatedParents, lastCharacterPosition);
        }

        lastCharacterPosition.get(currentChar).remove(lastCharacterPosition.get(currentChar).size() - 1);
    }

    private int computeSubtreeSizes(int node, List<List<Integer>> finalAdjacencyList, int[] subtreeSizes) {
        int size = 1;
        for (int child : finalAdjacencyList.get(node)) {
            size += computeSubtreeSizes(child, finalAdjacencyList, subtreeSizes);
        }
        subtreeSizes[node] = size;
        return size;
    }
}
",1434309551
RAVEESH GAUTAM,Raveesh_gautam,340,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k][n];
        
        for (int city = 0; city < n; city++) {
            dp[0][city] = stayScore[0][city];
            for (int dest = 0; dest < n; dest++) {
                dp[0][city] = Math.max(dp[0][city], travelScore[dest][city]);
            }
        }

        for (int day = 1; day < k; day++) {
            int[] maxPrevCityScore = new int[n];
            
            for (int currCity = 0; currCity < n; currCity++) {
                for (int dest = 0; dest < n; dest++) {
                    maxPrevCityScore[currCity] = Math.max(maxPrevCityScore[currCity], dp[day - 1][dest] + travelScore[dest][currCity]);
                }
            }
            
            for (int city = 0; city < n; city++) {
                dp[day][city] = Math.max(maxPrevCityScore[city], dp[day - 1][city] + stayScore[day][city]);
            }
        }

        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = Math.max(maxPoints, dp[k - 1][city]);
        }
        
        return maxPoints;
    }
}
",1434314476
RAVEESH GAUTAM,Raveesh_gautam,340,3617,java,"import java.util.ArrayList;
import java.util.List;

public class Solution {
    public int possibleStringCount(String s) {
        int count = 1;
        int n = s.length();
        List<Integer> lengths = new ArrayList<>();

        for (int i = 0; i < n; ++i) {
            int len = 1;
            while (i + 1 < n && s.charAt(i) == s.charAt(i + 1)) {
                ++len;
                ++i;
            }
            lengths.add(len);
        }

        for (int len : lengths) {
            if (len > 1) {
                count += (len - 1);
            }
        }

        return count;
    }
}
",1434301308
Rushikesh Kulkarni,The_2nd_Derivative,342,3576,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    string s;
    int n;
    vi parent;
    vi parent2;
    vvi adj,adj2;
    vi siz;
    void dfs1(int at, int from, vi& col){
        int cur = s[at] - 'a';
        int pvsVal = col[cur];
        if(col[cur] == -1){
            parent2[at] = parent[at];
        }
        else{
            parent2[at] = col[cur];
        }
        col[cur] = at;
        for(auto to : adj[at]){
            if(to == from){
                continue;
            }
            dfs1(to, at, col);
        }
        col[cur] = pvsVal;
    }
    void dfs2(int at, int from){
        siz[at] = 1;
        for(auto to : adj2[at]){
            if(to == from){
                continue;
            }
            dfs2(to, at);
            siz[at] += siz[to];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent_, string s_) {
        parent = parent_;
        s = s_;
        n = sz(s);
        adj.clear();
        adj.resize(n);
        parent2 = parent;
        siz.clear();
        siz.resize(n,0);
        for(int i = 1; i < n; i++){
            adj[parent[i]].pb(i);
        }
        vi col(26, -1);
        dfs1(0, -1, col);
        adj2.clear();
        adj2.resize(n);
        for(int i = 0; i < n; i++){
            if(parent2[i] != -1){
                adj2[parent2[i]].pb(i);
            }
        }
        dfs2(0, -1);
        return siz;
    }
};",1434291921
Rushikesh Kulkarni,The_2nd_Derivative,342,3587,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e11;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<ll>> dp(k + 1, vector<ll>(n, -INF));
        for(int i = 0; i < n; i++){
            dp[0][i] = 0;
        }
        for(int day = 0; day < k; day++){
            for(int at = 0; at < n; at++){
                // he was at city in day
                // stay there
                // dbg(day, at, stayScore[day][at]);
                chmax(dp[day + 1][at], dp[day][at] + stayScore[day][at]);
                // dbg(dp[day + 1][at]);
                for(int to = 0; to < n; to++){
                    chmax(dp[day + 1][to], dp[day][at] + travelScore[at][to]);
                }
            }
        }
        // dbg(dp);
        return *max_element(all(dp.back()));
    }
};",1434314598
Rushikesh Kulkarni,The_2nd_Derivative,342,3617,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    
    
    int possibleStringCount(string s) {
        ll n = sz(s);            
        char c = s[0];
        int cnt = 1;
        vector<pair<char,int>> v;
        for(int i = 1; i < n; i++){
            if(s[i] == c){
                cnt++;
            }
            else{
                v.pb({c, cnt});
                c = s[i];
                cnt = 1;
            }
        }
        v.pb({c, cnt});
        auto get = [&](pair<char,int>& p){
            string t = """";
            for(int i = 0; i < p.se; i++){
                t += p.fi;
            }
            return t;
        };
        unordered_set<string> st;
        for(int i = 0; i < sz(v); i++){
            if(v[i].se > 1){
                string t = """";
                for(int j = 0; j < i; j++){
                    t += get(v[j]);
                }
                string u = """";
                for(int k = i + 1; k < sz(v); k++){
                    u += get(v[k]);
                }
                string w = """";
                for(int k = 1; k <= v[i].se; k++){
                    w += v[i].fi;
                    st.insert(t + w + u);
                }
            }
            else{
                st.insert(s);
            }
        }
        return sz(st);
    }
};",1434274889
Aakarsh Jain,aakarsh_11235,343,3576,cpp,"class Solution {
public:
    vector<int> new_parent;
    vector<int> cnt;
    vector<vector<int>> adj;

    void dfs1(int u, vector<int>& parent, string& s, vector<int>& curr){
        int temp = curr[s[u] - 'a'];
        curr[s[u] - 'a'] = u;
        for(int v:adj[u]) dfs1(v, parent, s, curr);
        curr[s[u] - 'a'] = temp;
        if(curr[s[u] - 'a'] != -1) new_parent[u] = curr[s[u] - 'a'];
        else new_parent[u] = parent[u];
    }

    int dfs2(int u){
        for(int v:adj[u]) cnt[u] += dfs2(v);
        cnt[u]++;
        return cnt[u];
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        new_parent.resize(n, -1);
        adj.resize(n);

        for(int i = 1; i < n; i++) adj[parent[i]].push_back(i);

        vector<int> curr(26, -1);
        dfs1(0, parent, s, curr);

        adj.clear();
        adj.resize(n);
        cnt.resize(n, 0);
        for(int i = 1; i < n; i++) adj[new_parent[i]].push_back(i);

        dfs2(0);

        return cnt;
    }
};",1434314672
Aakarsh Jain,aakarsh_11235,343,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, 0));
        for(int i = 0; i < n; i++){
            dp[0][i] = stayScore[0][i];
            for(int j = 0; j < n; j++) dp[0][i] = max(dp[0][i], travelScore[j][i]);
        }
        for(int x = 1; x < k; x++){
            for(int i = 0; i < n; i++){
                dp[x][i] = stayScore[x][i] + dp[x - 1][i];
                for(int j = 0; j < n; j++) dp[x][i] = max(dp[x][i], travelScore[j][i] + dp[x - 1][j]);
            }
        }
        return *max_element(dp[k - 1].begin(), dp[k - 1].end());
    }
};",1434286288
Aakarsh Jain,aakarsh_11235,343,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        vector<pair<int, int>> decompose;
        decompose.push_back({word[0], 1});
        for(int i = 1; i < n; i++){
            if(word[i] == decompose.back().first) decompose.back().second++;
            else decompose.push_back({word[i], 1});
        }
        int ans = 1;
        for(auto i:decompose){
            ans += i.second - 1;
        }
        return ans;
    }
};",1434294688
Saumya Kumar,Saumya_Kumar,344,3576,python3,"from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)

        closest_ancestor = {}
        
        def reassign_parents(node: int):
            char = s[node]
            original_parent = parent[node]
            
            if char in closest_ancestor:
                closest_match = closest_ancestor[char]
                tree[original_parent].remove(node)
                tree[closest_match].append(node)
            
            prev_closest = closest_ancestor.get(char, None)
            closest_ancestor[char] = node
            
            for child in list(tree[node]):
                reassign_parents(child)
            
            if prev_closest is not None:
                closest_ancestor[char] = prev_closest
            else:
                del closest_ancestor[char]

        reassign_parents(0)

        answer = [0] * n
        def calculate_subtree_size(node: int) -> int:
            size = 1
            for child in tree[node]:
                size += calculate_subtree_size(child)
            answer[node] = size
            return size

        calculate_subtree_size(0)
        
        return answer
",1434284829
Saumya Kumar,Saumya_Kumar,344,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0] * n for _ in range(k)]
        
        for city in range(n):
            stay = stayScore[k - 1][city]
            travel = 0
            for next_city in range(n):
                if next_city != city:
                    travel = max(travel, travelScore[city][next_city])
            dp[k - 1][city] = max(stay, travel)
            
        for day in range(k - 2, -1, -1):
            for curr_city in range(n):
                stay_points = stayScore[day][curr_city] + dp[day + 1][curr_city]
                
                travel_points = 0
                for next_city in range(n):
                    if next_city != curr_city:
                        points = travelScore[curr_city][next_city] + dp[day + 1][next_city]
                        travel_points = max(travel_points, points)
                
                dp[day][curr_city] = max(stay_points, travel_points)
        
        return max(dp[0])",1434307246
Saumya Kumar,Saumya_Kumar,344,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = set()
        n = len(word)
        res.add(word)

        i = 0
        while i < n:
            j = i
            while j < n and word[j] == word[i]:
                j += 1
            
            k = j - i
            for k in range(1, k):
                temp = word[ : i] + word[i : i + k] + word[j : ]
                res.add(temp)
            
            i = j
        
        return len(res)",1434272953
Abhinav R Cillanki,jebronlames32,345,3576,cpp,"class Solution {
public:

    int dfs(int node, vector<stack<int>>&ancestor, string &s, vector<vector<int>>&g, vector<int> &counts, vector<int>&parent){
        if(!ancestor[s[node]-'a'].empty()){
            parent[node] = ancestor[s[node]-'a'].top();
        }
        int count = 1;
        ancestor[s[node]-'a'].push(node);
        for(auto c:g[node]){
            count +=dfs(c, ancestor, s, g,counts,parent);
        }
        ancestor[s[node]-'a'].pop();
        return counts[node] = count;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        for(int i = 1;i<n;i++){
            g[parent[i]].push_back(i);
        }
        vector<stack<int>> ancestor(26);
        vector<int> counts(n);
        dfs(0, ancestor, s, g, counts,parent);
        vector<vector<int>> newg(n);
        for(int i = 1;i<n;i++){
            newg[parent[i]].push_back(i);
        }
        dfs(0, ancestor, s, newg, counts,parent);
        return counts;
    }
};",1434292756
Abhinav R Cillanki,jebronlames32,345,3587,cpp,"class Solution {
public:

int dp[202][202];
int n,k;

int rec(int day, int curpos, vector<vector<int>>&ss, vector<vector<int>>&ts){
    if(day==k)return 0;
    if(dp[day][curpos]!=-1){
        return dp[day][curpos];
    }
    int ans = ss[day][curpos] + rec(day+1, curpos, ss, ts);
    for(int i =0;i<n;i++){
        if(i==curpos)continue;
        ans = max(ans, ts[curpos][i] + rec(day+1, i, ss, ts));
    }
    return dp[day][curpos] = ans;
}

   

    int maxScore(int N, int K, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        n = N;
        k = K;
        memset(dp, -1, sizeof(dp));
        int ans = 0;
        for(int i =0;i<n;i++){
            ans = max(ans, rec(0, i, stayScore, travelScore));
        }
        return ans;
    }
};",1434314692
Abhinav R Cillanki,jebronlames32,345,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count = 0;
        int n = word.length();
        for(int i = 1;i<n;i++){
            if(word[i]==word[i-1]){
                count++;
            }
        }
        return count+1;
    }
};",1434261416
DYR90,DYR90,346,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def dfs(res, record, s, tree, pre, cur):
            record_new = record.copy()
            record_new[ord(s[cur])-ord('a')] = cur
            for child in tree[cur]:
                dfs(res, record_new, s, tree, cur, child)
            if pre != -1:
                if record[ord(s[cur])-ord('a')] == -1:
                    res[pre] += res[cur]
                else:
                    res[record[ord(s[cur])-ord('a')]] += res[cur]
            return
        
        n = len(s)
        record = [-1] * 26
        res = [1] * n
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        dfs(res, record, s, tree, -1, 0)
        
        return res",1434304664
DYR90,DYR90,346,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dfs(cur_city, cur_day):
            if(cur_day==k):
                return 0
            res = stayScore[cur_day][cur_city] + dfs(cur_city, cur_day+1)
            for city in range(n):
                res = max(res, travelScore[cur_city][city] + dfs(city, cur_day+1))
            return res
        
        res = 0
        for city in range(n):
            res = max(res, dfs(city, 0))
        
        return res",1434314797
DYR90,DYR90,346,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        count = 1
        res = 1
        
        for i in range(1, n):
            if word[i] == word[i-1]:
                count += 1
            else:
                res += count - 1
                count = 1
        
        res += count - 1
        return res",1434272611
Ajay Singh Deopa,singh_deopa,347,3576,cpp,"class Solution {
    int dfs(
        vector<vector<int>>& adj,
        string& s,
        vector<int>& res,
        vector<int>& last,
        int u, int p
    ) {
        int cnt = 1;
        int ch = (int) s[u] - 'a';
        int prev = last[ch];
        last[ch] = u;
        
        for (int& v: adj[u]) {
            if (v == p) continue;

            int child = dfs(adj, s, res, last, v, u);

            if (child)
                cnt += res[v];
        }

        res[u] += cnt;

        if (prev != -1) {
            res[prev] += res[u];
            cnt = 0;
        }

        // cout << u << endl;
        // for (int& i: res) cout << i << "" "";
        // cout << endl;

        last[ch] = prev;

        return cnt;
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = (int) parent.size();
        vector<vector<int>> adj(n);

        for (int i = 1; i < n; i++) {
            int j = parent[i];
            adj[i].push_back(j);
            adj[j].push_back(i);
        }

        vector<int> res(n), last(26, -1);

        dfs(adj, s, res, last, 0, -1);

        return res;
    }
};",1434301601
Ajay Singh Deopa,singh_deopa,347,3587,cpp,"class Solution {
    int dfs(
        vector<vector<int>>& dp,
        int& n,
        int& k,
        vector<vector<int>>& stay,
        vector<vector<int>>& travel,
        int day, int pos
    ) {
        if (day == k) {
            return 0;
        }

        int& curr = dp[day][pos];

        if (curr != -1) {
            return curr;
        }

        curr = stay[day][pos] + dfs(dp, n, k, stay, travel, day + 1, pos);

        for (int i = 0; i < n; i++) {
            int tmp = travel[pos][i] + dfs(dp, n, k, stay, travel, day + 1, i);
            curr = max(curr, tmp);
        }

        return curr;
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, -1));
        int res = 0;

        for (int i = 0; i < n; i++) {
            int curr = dfs(dp, n, k, stayScore, travelScore, 0, i);
            res = max(res, curr);
        }
        
        return res;
    }
};",1434314969
Ajay Singh Deopa,singh_deopa,347,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = (int) word.size();
        int res = 1;
        int cnt = 0;

        for (int i = 1; i < n; i++) {
            if (word[i] == word[i - 1]) {
                cnt++;
            }
            else {
                res += cnt;
                cnt = 0;
            }
        }

        res += cnt;

        return res;
    }
};",1434263751
czjnbb,czjnbb,351,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        
        def helper(par, cur):
            desc = 0
            for nxt in d[cur]:
                desc += helper(cur, nxt)
                
            res[cur] = desc + 1
            return res[cur]
        
        
        def helper2(par, cur, mem):
            ov = -1
            if s[cur] in mem:
                d[par].remove(cur)
                ov = mem[s[cur]]
                d[mem[s[cur]]].add(cur)
                
            
            for nxt in list(d[cur]):
                mem[s[cur]] = cur
                helper2(cur, nxt, mem)
                if ov != -1:
                    mem[s[cur]] = ov
                else:
                    del mem[s[cur]]
                    
            
                
                
        
        d = defaultdict(set)
        leng = len(parent)
        res = [0] * leng
        
        for i,q in enumerate(parent):
            d[q].add(i)
            
        helper(-1, 0)
        helper2(-1, 0, {})
        
        print(d)
        
        helper(-1, 0)
        
        
        return res",1434315898
czjnbb,czjnbb,351,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        dp = [[0 for _ in range(n)] for _ in range(k + 1)]
        
        for d in range(1, k + 1):
            for c in range(n):
                for nxt in range(n):
                    if nxt == c:
                        dp[d][c] = max(dp[d][c], dp[d-1][c] + stayScore[d-1][c])
                    else:
                        dp[d][nxt] = max(dp[d][nxt], dp[d-1][c] + travelScore[c][nxt])
                        
        return max(dp[-1])",1434299538
czjnbb,czjnbb,351,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        
        res = 1
        lens = len(word)
        
        for i in range(1, lens):
            if word[i] == word[i-1]:
                res += 1
                
        return res",1434259786
Erik Jernqvist,erik_jernqvist,352,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = defaultdict(list)
        for c, p in enumerate(parent):
            children[p] += [c]
        q = deque([(0, {s[0]: 0})])

        while q:
            curr, map = q.popleft()
            for nxt in children[curr]:
                new_map = {x: map[x] for x in map}
                if s[nxt] in map:
                    parent[nxt] = map[s[nxt]]
                new_map[s[nxt]] = nxt
                q.append((nxt, new_map))

        subs = [0]*n
        children = defaultdict(list)
        for c, p in enumerate(parent):
            children[p] += [c]
        #print(parent)
        #print(children)

        def get_subs(node):
            subs[node] += 1
            for nxt in children[node]:
                get_subs(nxt)
                subs[node] += subs[nxt]

        get_subs(0)
        return subs
        ",1434308670
Erik Jernqvist,erik_jernqvist,352,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @cache
        def rec(curr, day):
            if day == k: return 0
            mx = 0
            for nxt in range(n):
                if curr == nxt:
                    mx = max(mx, stayScore[day][curr] + rec(nxt, day+1))
                else:
                    mx = max(mx, travelScore[curr][nxt] + rec(nxt, day+1))
            return mx

        mx = 0
        for start in range(n):
            mx = max(mx, rec(start, 0))
        return mx
        ",1434316186
Erik Jernqvist,erik_jernqvist,352,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        counts = []
        prev = '*'
        for c in word:
            if prev == c: counts[-1] += 1
            else: counts += [1]
            prev = c
        total = 1
        for c in counts: total += c-1
        return total",1434262888
chien-te,chien-te,353,3576,python,"class Solution(object):
    def findSubtreeSizes(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[int]
        """"""
        n = len(parent)
        tree = [[] for _ in range(n)]
        closest_ancestor = [-1] * n
        answer = [0] * n
        letter_last_seen = [-1] * 26  # Array to store the last seen node for each letter

        # Construct the tree and find closest ancestors
        for i in range(1, n):
            tree[parent[i]].append(i)
        self.dfs1(0, parent, s, tree, closest_ancestor, letter_last_seen)

        # Reconstruct the tree based on closest ancestors
        for i in range(1, n):
            if closest_ancestor[i] != -1:
                tree[parent[i]].remove(i)
                tree[closest_ancestor[i]].append(i)

        # Calculate subtree sizes
        self.dfs2(0, tree, answer)
        return answer

    def dfs1(self, node, parent, s, tree, closest_ancestor, letter_last_seen):
        idx = ord(s[node]) - ord('a')  
        prev_ancestor = letter_last_seen[idx] 
        letter_last_seen[idx] = node  

        for neighbor in tree[node]:
            self.dfs1(neighbor, parent, s, tree, closest_ancestor, letter_last_seen)

        if prev_ancestor != -1: 
            closest_ancestor[node] = prev_ancestor

        letter_last_seen[idx] = prev_ancestor  

    def dfs2(self, node, tree, answer):
        answer[node] = 1
        for child in tree[node]:
            self.dfs2(child, tree, answer)
            answer[node] += answer[child]",1434316297
chien-te,chien-te,353,3587,python,"class Solution(object):
    def maxScore(self, n, k, stayScore, travelScore):
        """"""
        :type n: int
        :type k: int
        :type stayScore: List[List[int]]
        :type travelScore: List[List[int]]
        :rtype: int
        """"""
        memo = {}
        def dfs(day, curr):
            if (day, curr) in memo:
                return memo[(day, curr)]
            if day == k:
                return 0
            max_score = stayScore[day][curr] + dfs(day + 1, curr)
            for dest in range(n):
                if dest != curr:
                    max_score = max(max_score, travelScore[curr][dest] + dfs(day + 1, dest))
            memo[(day, curr)] = max_score
            return max_score
        
        max_points = 0
        for start in range(n):
            max_points = max(max_points, dfs(0, start))
        return max_points",1434270874
chien-te,chien-te,353,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> arr;
        vector<char> crr;
        int cnt=0;
        char cur=word[0];
        for (auto c: word){
            if (c==cur)
                cnt++;
            else{
                arr.push_back(cnt);
                crr.push_back(cur);
                cnt=1;
                cur=c;
            }
        }
        arr.push_back(cnt);
        crr.push_back(cur);
        // for (auto c: arr) cout << c << "" ""; cout << endl;
        // for (auto c: crr) cout << c << "" ""; cout << endl;
        return word.size() - arr.size() + 1;
    }
};",1434263208
merwanel,merwanel,354,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        childrenOf = collections.defaultdict(list)
        for child, p in enumerate(parent) :
            childrenOf[p].append(child)
        closestNode_ofVal = {}
        def f(node) :
            # print(node,closestNode_ofVal)
            # make changes :
            if s[node] in closestNode_ofVal :
                parent[node] = closestNode_ofVal[s[node]]
            else :
                pass
            old_node = closestNode_ofVal.get(s[node], None)
            closestNode_ofVal[s[node]] = node
            for child in childrenOf[node] :
                f(child)
            if old_node == None :
                del closestNode_ofVal[s[node]]
            else :
                closestNode_ofVal[s[node]] = old_node
        # print(parent)
        f(0)
        # print(parent)
        # get new graph
        childrenOf = collections.defaultdict(list)
        for child, p in enumerate(parent) :
            childrenOf[p].append(child)
        # calculate new size
        ans = [0] * len(parent)
        def get_size(node) :
            size = 1
            for child in childrenOf[node] :
                size += get_size(child)
            ans[node] = size
            return size
        get_size(0)
        return ans
        ",1434303082
merwanel,merwanel,354,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def f(city , day) :
            if day == k:
                return 0
            stay = stayScore[day][city] + f(city, day+1)
            travel = 0
            for other_city in range(n) :
                if city == other_city :
                    continue
                travel = max(travel, travelScore[city][other_city] + f(other_city, day+1))
            return max(stay, travel)
        return max(f(city, 0) for city in range(n)) ",1434316323
merwanel,merwanel,354,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        cur = 1
        prev = -1
        word += '_'
        for c in word :
            if c == prev :
                cur +=1
            else :
                ans += cur-1
                
                prev = c
                cur = 1
        return ans",1434263654
Vansh Dhawan,vanshdhawan60,355,3576,cpp,"class Solution {
public:

    vector<int> ans;

    void dfs (vector<vector<int>> &graph, int node, vector<int> last, string &s) {
        char ch = s[node];
        if (last[ch-'a']!=-1) {
            int x = last[ch-'a'];
            ans[node] = x;
            // cout << node << "" "";
        }
        last[ch-'a'] = node;
        for (int &x: graph[node]) {
            dfs (graph, x, last, s);
        }
    }

    int sz (vector<vector<int>> &graph, int node) {
        int t = 1;
        for (int &x: graph[node]) {
            t += sz (graph, x);
        }
        ans[node] = t;
        return t;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        ans.resize(n);
        ans = parent;
        vector<vector<int>> graph (n);
        for (int i=1; i<n; i++) {
            graph[parent[i]].push_back(i);
            // cout << graph[i][0];
        }
        vector<int> last (26, -1);
        dfs(graph, 0, last, s);
        // find subtree sizes
        // for (int i=0; i<n; i++) cout << ans[i] << "" "";
        graph.clear();
        graph.resize(n);
        
        for (int i=1; i<n; i++) {
            graph[ans[i]].push_back(i);
            // cout << graph[i][0];
        }
        ans.clear();
        ans.resize(n, -1);
        sz (graph, 0);
        return ans;
    }
};",1434297317
Vansh Dhawan,vanshdhawan60,355,3587,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int n,k;

    int solve (int day, int city, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        if (day==k) return 0;
        if (dp[day][city]!=-1) return dp[day][city];
        int ans = solve (day+1, city, ss, ts) + ss[day][city];
        for (int i=0; i<n; i++) {
            ans = max (ans, solve(day+1, i, ss, ts) + ts[city][i]);
        }
        return dp[day][city] = ans;
    }

    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        this->n=n; this->k=k;
        dp.resize(k+1, vector<int> (n+1, -1));
        int ans = -1;
        for (int i=0; i<n; i++) ans = max (ans, solve(0,i,ss,ts));
        return ans;
    }
};",1434316328
Vansh Dhawan,vanshdhawan60,355,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        char prev = '#';
        for (int i=0; i<word.size(); i++) {
            char ch = word[i];
            if (ch==prev) ++ans;
            else prev = ch;
        }
        return ans;
    }
};",1434261065
Thunder,Thunder_strom007,356,3576,cpp,"class Solution {
public:
    int n;
    string str;
    vector<vector<int>> graph, rgraph;
    
    void dfs(int src,int par,vector<int> arr){
        char ch = str[src];
        if(arr[ch-'a']!=-1){
            rgraph[src].push_back(arr[ch-'a']);
            rgraph[arr[ch-'a']].push_back(src);
        }
        else{
            if(par!=-1){
                rgraph[src].push_back(par);
                rgraph[par].push_back(src);
            }
        }
        
        arr[ch-'a'] = src;
        
        for(auto &child : graph[src]){
            if(child!=par){
                dfs(child,src,arr);
            }
        }
    }
    
    vector<int> ans,visited;
    void dfss(int src,int par){
        ans[src] = 1;
        visited[src] = 1;
        for(auto &child : rgraph[src]){
            if(!visited[child]){
                dfss(child,src);
                ans[src] += ans[child];
            }
        }
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        
        str = s;
        n = parent.size();
        graph.assign(n,vector<int>());
        rgraph.assign(n,vector<int>());
        ans.assign(n,0);
        visited.assign(n,0);
        
        for(int i=1;i<n;i++){
            graph[i].push_back(parent[i]);
            graph[parent[i]].push_back(i);
        }
        
        vector<int> temp(26,-1);
        dfs(0,-1,temp);
        
        dfss(0,-1);
        
        return ans;
        
    }
};",1434301411
Thunder,Thunder_strom007,356,3587,cpp,"class Solution {
public:
    int N,K;
    vector<vector<int>> stay,travel;
    int dp[201][201];
    
    int f(int i,int curr){
        if(i==K) return 0;
        
        if(dp[i][curr]!=-1) return dp[i][curr];
        
        int ans = stay[i][curr] + f(i+1,curr);
        for(int dest=0;dest<N;dest++){
            ans = max(ans,travel[curr][dest] + f(i+1,dest));
        }
        
        return dp[i][curr] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        N = n, K = k;
        stay = stayScore, travel = travelScore;
        
        memset(dp,-1,sizeof(dp));
        
        int ans = 0;
        for(int curr=0;curr<N;curr++){
            ans = max(ans,f(0,curr));
        }
        return ans;
    }
};",1434316340
Thunder,Thunder_strom007,356,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int ans = 1;
        int n = s.size();
        for(int i=0;i<n;i++){
            int cnt = 0;
            int j = i;
            while(j<n && s[i]==s[j]){
                cnt++;
                j++;
            }
            i = j-1;
            ans += max(0,(cnt-1));
        }
        return ans;
    }
};",1434270800
YUVAL BHAYANI,yuvall_b,357,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n = p.size();
        vector<vector<int>> t(n), nt(n);
        vector<int> np(n, -1), sz(n, 1);
        vector<stack<int>> stk(26);

        for (int i = 1; i < n; ++i) t[p[i]].push_back(i);

        function<void(int)> dfs1 = [&](int u) {
            int ci = s[u] - 'a';
            if (!stk[ci].empty()) np[u] = stk[ci].top();
            else np[u] = p[u];
            stk[ci].push(u);
            for (int v : t[u]) dfs1(v);
            stk[ci].pop();
        };

        dfs1(0);

        for (int i = 1; i < n; ++i) nt[np[i]].push_back(i);

        function<int(int)> dfs2 = [&](int u) {
            for (int v : nt[u]) sz[u] += dfs2(v);
            return sz[u];
        };

        dfs2(0);
        return sz;
    }
};
",1434281779
YUVAL BHAYANI,yuvall_b,357,3587,cpp,"class Solution {
public:
    int rec(vector<vector<int>>& dp, int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel, int i, int curr) {
        if (i >= k) return 0;  

        if (dp[i][curr] != -1) return dp[i][curr];  

        int nottravel = stay[i][curr] + rec(dp, n, k, stay, travel, i + 1, curr);  

        int take = 0;  
        for (int j = 0; j < n; j++) {
            if (j != curr) {  
                take = max(take, travel[curr][j] + rec(dp, n, k, stay, travel, i + 1, j));
            }
        }

        return dp[i][curr] = max(take, nottravel); 
    }

    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<vector<int>> dp(k, vector<int>(n, -1));  

        int maxPoints = 0;
        for (int start = 0; start < n; start++) {  
            maxPoints = max(maxPoints, rec(dp, n, k, stay, travel, 0, start));
        }

        return maxPoints;
    }
};
",1434316393
YUVAL BHAYANI,yuvall_b,357,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=1;i<word.size();i++){
            if(word[i]==word[i-1]){
                ans++;
            }
        }
        return ans;
    }
};",1434260860
cflee,cflee,360,3576,kotlin,"class Solution {
    fun findSubtreeSizes(parent: IntArray, s: String): IntArray {
        val children = Array(parent.size) { mutableSetOf<Int>() }
        parent.forEachIndexed { node, p -> if (p != -1) children[p].add(node) }
        val newParent = IntArray(parent.size) { -1 }
        fun findNewParent(node: Int, lastSeen: IntArray) {
            val curChar = s[node] - 'a'
            if (lastSeen[curChar] != -1) newParent[node] = lastSeen[curChar]
            val prevLastSeen = lastSeen[curChar]
            lastSeen[curChar] = node
            children[node].forEach { findNewParent(it, lastSeen) }
            lastSeen[curChar] = prevLastSeen
        }
        findNewParent(0, IntArray(26) { -1 })
        newParent.forEachIndexed { node, np -> 
            if (np != -1) {
                children[parent[node]].remove(node)
                children[np].add(node)
            }
        }
        val answer = IntArray(parent.size)
        fun calcSubtree(node: Int): Int {
            if (answer[node] != 0) return answer[node]
            answer[node] = 1
            children[node].forEach { answer[node] += calcSubtree(it) }
            return answer[node]
        }
        calcSubtree(0)
        return answer
    }
}",1434296948
cflee,cflee,360,3587,kotlin,"class Solution {
    fun maxScore(n: Int, k: Int, stayScore: Array<IntArray>, travelScore: Array<IntArray>): Int {
        // days, city
        val data = Array(k) { IntArray(n) }
        for (day in 0..<k) {
            for (curCity in 0..<n) {
                if (day == 0) {
                    data[day][curCity] = stayScore[day][curCity]
                    for (prevCity in 0..<n) {
                        if (prevCity == curCity) continue
                        data[day][curCity] = max(data[day][curCity], travelScore[prevCity][curCity])
                    }
                } else {
                    data[day][curCity] = data[day - 1][curCity] + stayScore[day][curCity]
                    for (prevCity in 0..<n) {
                        if (prevCity == curCity) continue
                        data[day][curCity] = max(data[day][curCity], data[day - 1][prevCity] + travelScore[prevCity][curCity])
                    }
                }
            }
        }
        return data[k - 1].max()
    }
}",1434316594
cflee,cflee,360,3617,kotlin,"class Solution {
    fun possibleStringCount(word: String): Int {
        var answer = 1
        for (i in 1..<word.length) {
            if (word[i] == word[i - 1]) answer++
        }
        return answer
    }
}",1434260752
nicoraga36,nicoraga36,361,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> initialAdj(n); 
        vector<vector<int>> finalAdj(n);   
        vector<int> newParent(n);          
        vector<int> answer(n);             
        vector<int> charStack[26];         

        
        for (int i = 0; i < n; ++i) {
            if (parent[i] != -1) {
                initialAdj[parent[i]].push_back(i);
            }
        }

        
        function<void(int)> dfsInitial = [&](int x) {
            int c = s[x] - 'a'; 

            if (!charStack[c].empty()) {
                newParent[x] = charStack[c].back();
            } else {
                newParent[x] = parent[x];
            }

            charStack[c].push_back(x);

            for (int child : initialAdj[x]) {
                dfsInitial(child);
            }

            charStack[c].pop_back();
        };

        function<void(int)> dfsFinal = [&](int x) {
            answer[x] = 1; 
            for (int child : finalAdj[x]) {
                dfsFinal(child);        
                answer[x] += answer[child]; 
            }
        };

        dfsInitial(0);

        int root = -1;
        for (int i = 0; i < n; ++i) {
            if (newParent[i] != -1) {
                finalAdj[newParent[i]].push_back(i); 
            } else {
                root = i; 
            }
        }

        dfsFinal(root);

        return answer;
    }
};
",1434309452
nicoraga36,nicoraga36,361,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    vector<vector<long long>> dp(k, vector<long long>(n, LLONG_MIN));

    
    for (int curr = 0; curr < n; ++curr) {
        dp[0][curr] = stayScore[0][curr];
        for (int prev = 0; prev < n; ++prev) {
            if (prev != curr) {
                dp[0][curr] = max(dp[0][curr], (long long)travelScore[prev][curr]);
            }
        }
    }

    for (int day = 1; day < k; ++day) {
        for (int curr = 0; curr < n; ++curr) {
            dp[day][curr] = dp[day - 1][curr] + stayScore[day][curr];
            for (int prev = 0; prev < n; ++prev) {
                if (prev != curr) {
                    dp[day][curr] = max(dp[day][curr], dp[day - 1][prev] + travelScore[prev][curr]);
                }
            }
        }
    }

    long long maxPoints = LLONG_MIN;
    for (int curr = 0; curr < n; ++curr) {
        maxPoints = max(maxPoints, dp[k - 1][curr]);
    }

    return maxPoints;
    }
};",1434298282
nicoraga36,nicoraga36,361,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt=1;
        for(int i=1;i<word.length();i++){
            if(word[i]==word[i-1])
                cnt++;
        }
        return cnt;
    }
};",1434264540
Yuriy Kaminskiy,yumkam,363,3576,cpp,"class Solution {
    static void dfs(auto u, auto &adj, auto &parent, auto s, auto &up) {
        auto c = s[u] - 'a';
        if (up[c] != UINT_MAX)
            parent[u] = up[c];
        auto save = up[c];
        up[c] = u;
        for (auto v: adj[u]) {
            dfs(v, adj, parent, s, up);
        }
        up[c] = save;
    }
    static unsigned dfs2(auto u, auto &adj, auto &ret) {
        unsigned size = 1;
        for (auto v: adj[u])
            size += dfs2(v, adj, ret);
        ret[u] = size;
        return size;
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string_view s) {
        const unsigned n = parent.size();
        vector<vector<unsigned>> adj(n);
        for (unsigned i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        array<unsigned, 26> up;
        up.fill(UINT_MAX);
        dfs(0u, adj, parent, s, up);
        for (auto &a: adj) a.clear();
        for (unsigned i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        vector<int> ret(n);
        dfs2(0u,adj, ret);
        return ret;
    }
};",1434299112
Yuriy Kaminskiy,yumkam,363,3587,cpp,"class Solution {
    static unsigned dfs(unsigned i, unsigned d, unsigned k, auto& ss, auto &ts, auto& memo) {
        if (d == k)
            return 0;
        auto &ret = memo[i][d];
        if (ret != UINT_MAX)
            return ret;
        ret = ss[d][i] + dfs(i, d + 1, k, ss, ts, memo);
        const auto n = ts.size();
        for (unsigned j = 0; j < n; ++j)
            if (j != i)
                ret = max(ret, ts[i][j] + dfs(j, d + 1, k, ss, ts, memo));
        return ret;
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        unsigned ret = 0;
        vector memo(n, vector<unsigned>(k, UINT_MAX));
        for (unsigned i = 0; i < n; ++i)
            ret = max(ret, dfs(i, 0, k, ss, ts, memo));
        return ret;
    }
};",1434317181
Yuriy Kaminskiy,yumkam,363,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        unsigned prev = word[0];
        unsigned cnt = 0;
        unsigned ret = 1;
        for (auto c: word) {
            if (c == prev)
                ++cnt;
            else {
                ret += cnt - 1;
                cnt = 1;
                prev = c;
            }
        }
        ret += cnt - 1;
        return ret;
    }
};",1434275955
Chandrachur M,Chandrachur,364,3576,cpp,"/*********************** Chandrachur Mukherjee ***********************/

#include<bits/stdc++.h>
// #include<ext/pb_ds/assoc_container.hpp>
// #include<ext/pb_ds/tree_policy.hpp>

using namespace std; 
using namespace chrono;
// using namespace __gnu_pbds;

#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define MOD 1000000007
#define MOD1 998244353
#define INF 1e18
#define nline ""\n""
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define ff first
#define ss second
#define PI 3.141592653589793238462
#define set_bits(x) __builtin_popcountll(x)
#define sz(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define fr(i, n) for(int i = 0; i < n; ++i)
#define debug(x) cout << #x << "" ""; _print(x); cout << endl;

using ll = long long;
using ull = unsigned long long;
using lld = long double;
using pi = pair<int, int>;
using pll = pair<ll, ll>;
// typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update > pbds; // find_by_order, order_of_key

void _print(ll t) {cout << t;}
void _print(int t) {cout << t;}
void _print(string t) {cout << t;}
void _print(char t) {cout << t;}
void _print(lld t) {cout << t;}
void _print(double t) {cout << t;}
void _print(ull t) {cout << t;}

template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cout << ""{""; _print(p.ff); cout << "",""; _print(p.ss); cout << ""}"";}
template <class T> void _print(vector <T> v) {cout << ""[ ""; for (T i : v) {_print(i); cout << "" "";} cout << ""]"";}
template <class T> void _print(set <T> v) {cout << ""[ ""; for (T i : v) {_print(i); cout << "" "";} cout << ""]"";}
template <class T> void _print(multiset <T> v) {cout << ""[ ""; for (T i : v) {_print(i); cout << "" "";} cout << ""]"";}
template <class T, class V> void _print(unordered_map <T, V> v) {cout << ""[ ""; for (auto i : v) {_print(i); cout << "" "";} cout << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cout << ""[ ""; for (auto i : v) {_print(i); cout << "" "";} cout << ""]"";}
template <class T> void _print(stack<T> s) { while (!s.empty()) { _print(s.top()); s.pop(); if (!s.empty()) cout << "" ""; } }
template <class T> void _print(priority_queue<T> pq) { while (!pq.empty()) { _print(pq.top()); pq.pop(); if (!pq.empty()) cout << "" ""; } }
template <class T, class V, class U> void _print(priority_queue<T, V, U> pq) { while (!pq.empty()) { _print(pq.top()); pq.pop(); if (!pq.empty()) cout << "" ""; } }
template <class T> void _print(const std::vector<std::vector<T>>& arr) { std::cout << ""[\n""; for (const auto& row : arr) std::cout << ""  "", _print(row), std::cout << ""\n""; std::cout << ""]""; }
// void _print(pbds v) {cout << ""[ ""; for (auto i : v) {_print(i); cout << "" "";} cout << ""]"";}

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
/*---------------------------------------------------------------------------------------------------------------------------*/
ll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}
ll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}
void extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3
ll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b
ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}
bool revsort(ll a, ll b) {return a > b;}
ll combination(ll n, ll r, ll m, ll *fact, ll *ifact) {ll val1 = fact[n]; ll val2 = ifact[n - r]; ll val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}
void google(int t) {cout << ""Case "" << t << "": "";}
vector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m
ll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))
ll getRandomNumber(ll l, ll r) {return uniform_int_distribution<ll>(l, r)(rng);} 
/*--------------------------------------------------------------------------------------------------------------------------*/


class Solution {
  void dfs1(int node, vector<vector<int>> &adj, vector<int> &modifiedParent, map<char, vector<int>> &mp, string &s) {
    mp[s[node]].push_back(node);
    for(auto &adjNode : adj[node]) {
      dfs1(adjNode, adj, modifiedParent, mp, s);
    }
    mp[s[node]].pop_back();
    if(!mp[s[node]].empty()) {
      modifiedParent[node] = mp[s[node]].back();
    } 
  } 
  void dfs2(int node, vector<vector<int>> &adj, vector<int> &subtreeSizes) {
    int subtreeSize = 1;
    for(auto &adjNode : adj[node]) {
      dfs2(adjNode, adj, subtreeSizes);
      subtreeSize += subtreeSizes[adjNode];
    }
    subtreeSizes[node] = subtreeSize;
  }
public:
  vector<int> findSubtreeSizes(vector<int>& parent, string s) {
    int n = (int)parent.size();
    vector<vector<int>> adj(n);
    for(int i = 0; i < n; i++) {
      if(parent[i] != -1) {
        adj[parent[i]].push_back(i);
      }
    }
    vector<int> modifiedParent = parent;
    map<char, vector<int>> mp;
    dfs1(0, adj, modifiedParent, mp, s);
    // debug(modifiedParent);
    vector<vector<int>> modifiedAdj(n);
    for(int i = 0; i < n; i++) {
      if(modifiedParent[i] != -1) {
        modifiedAdj[modifiedParent[i]].push_back(i);
      }
    }
    vector<int> subtreeSizes(n);
    dfs2(0, modifiedAdj, subtreeSizes);
    return subtreeSizes;
  }
};",1434291577
Chandrachur M,Chandrachur,364,3587,cpp,"class Solution {
  int rec(int currDay, int currCity, int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>> &dp) {
    if(currDay == k) {
      return 0;
    }
    if(dp[currDay][currCity] != -1) {
      return dp[currDay][currCity];
    }
    int res = stayScore[currDay][currCity] + rec(currDay + 1, currCity, n, k, stayScore, travelScore, dp);
    for(int nextCity = 0; nextCity < n; nextCity++) {
      if(nextCity != currCity) {
        res = max(res, travelScore[currCity][nextCity] + rec(currDay + 1, nextCity, n, k, stayScore, travelScore, dp));
      }
    }
    return dp[currDay][currCity] = res;
  }
public:
  int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    int res = 0;
    vector<vector<int>> dp(k + 1, vector<int> (n + 1, -1));
    for(int i = 0; i < n; i++) {
      res = max(res, rec(0, i, n, k, stayScore, travelScore, dp));
    }
    return res;
  }
};",1434309749
Chandrachur M,Chandrachur,364,3617,cpp,"class Solution {
public:
  int possibleStringCount(string word) {
    int n = (int)word.length();
    int res = 1;
    for(int i = 1; i < n; i++) {
      if(word[i] == word[i - 1]) {
        res++;
      }
    }
    return res;
  }
};",1434264357
Prithwiraj Mitra,prithwirajmitra15,365,3576,cpp,"class Solution {
public:
    void dfs1(int src, int par, vector<vector<int>> &hash, vector<int> &parent, vector<vector<int>> &adj, string &str)
    {
        if (!hash[str[src] - 'a'].empty())
        {
            int anc = hash[str[src] - 'a'].back();
            parent[src] = anc;
        }
        
        hash[str[src] - 'a'].push_back(src);
        for (int child : adj[src])
            if (child != par)
                dfs1(child, src, hash, parent, adj, str);
        
        hash[str[src] - 'a'].pop_back();
    }

    void dfs2(int src, int par, vector<vector<int>> &adj, vector<int> &dp)
    {
        dp[src] = 1;
        for (int child : adj[src])
        {
            if (child != par)
            {
                dfs2(child, src, adj, dp);
                dp[src] += dp[child];
            }
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string str)
    {
        vector<vector<int>> adj(parent.size());
        for (int i = 1; i < parent.size(); i++)
        {
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }

        // for (int ele : parent)
        //     cout << ele << "" "";
        // cout << endl;

        vector<vector<int>> hash(26);
        dfs1(0, -1, hash, parent, adj, str);

        // for (int ele : parent)
        //     cout << ele << "" "";
        // cout << endl;

        for (int i = 0; i < adj.size(); i++)
            adj[i].clear();
        
        for (int i = 1; i < parent.size(); i++)
        {
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }

        vector<int> dp(parent.size());
        dfs2(0, -1, adj, dp);
        return dp;
    }
};",1434295603
Prithwiraj Mitra,prithwirajmitra15,365,3587,cpp,"class Solution {
private:
    int totalCity, totalDays;
    vector<vector<int>> stayScore, travelScore;
    vector<vector<int>> dp;

public:
    int getMaxScore(int city, int day)
    {
        if (day == totalDays)
            return 0;
        if (dp[city][day] != -1)
            return dp[city][day];
        
        int ans = 0;
        for (int nextCity = 0; nextCity < totalCity; nextCity++)
        {
            if (city == nextCity)
            {
                int score = stayScore[day][nextCity] + getMaxScore(nextCity, day + 1);
                ans = max(ans, score);
            }
            else
            {
                int score = travelScore[city][nextCity] + getMaxScore(nextCity, day + 1);
                ans = max(ans, score);
            }
        }

        return dp[city][day] = ans;
    }

    int maxScore(int n, int k, vector<vector<int>> &stayScore, vector<vector<int>> &travelScore)
    {
        this->totalCity = n;
        this->totalDays = k;
        this->stayScore = stayScore;
        this->travelScore = travelScore;

        int ans = 0;
        for (int city = 0; city < n; city++)
        {
            this->dp.resize(totalCity, vector<int>(totalDays, -1));
            int score = getMaxScore(city, 0);
            ans = max(ans, score);
        }

        return ans;
    }
};",1434317258
Prithwiraj Mitra,prithwirajmitra15,365,3617,cpp,"class Solution {
public:
    vector<int> build(string &word, int n)
    {
        int cnt = 1;
        vector<int> arr;
        for (int i = 1; i < n; i++)
        {
            if (word[i - 1] == word[i])
                cnt++;
            else
            {
                arr.push_back(cnt);
                cnt = 1;
            }
        }

        arr.push_back(cnt);
        return arr;
    }

    int possibleStringCount(string word)
    {
        vector<int> arr = build(word, word.size());
        int ans = 1;
        for (int ele : arr)
            ans += ele - 1;
        return ans;
    }
};",1434265701
leolee2025,leolee2020,367,3576,cpp,"class Solution {
public:
vector<vector<int>> g;
void findA(vector<int> &parent, vector<int> cur, int a, string &s) {
    int idx = s[a] - 'a';
    if (cur[idx] != -1)
        parent[a] = cur[idx];
    cur[idx] = a;
    for (int b : g[a])
        findA(parent, cur, b, s);
}

int dfs(vector<int> &ans, int a) {
    int sum = 1;
    for (int b : g[a])
        sum += dfs(ans, b);
    return ans[a] = sum;
}

vector<int> findSubtreeSizes(vector<int> &parent, string s) {
    int n = s.size();
    g.assign(n, {});
    for (int i = 1; i < n; i++)
        g[parent[i]].push_back(i);

    vector<int> cur(26, -1);
    findA(parent, cur, 0, s);

    g.assign(n, {});
    for (int i = 1; i < n; i++)
        g[parent[i]].push_back(i);

    vector<int> ans(n);
    dfs(ans, 0);
    return ans;
}
};",1434302105
leolee2025,leolee2020,367,3587,cpp,"class Solution {
public:
int maxScore(int n, int k, vector<vector<int>> &stayScore, vector<vector<int>> &travelScore) {
    vector<vector<int>> dp(2, vector<int>(n));
    int i1 = 0, i2 = 1;
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < n; j++) {
            dp[i2][j] = dp[i1][j] + stayScore[i][j];
            for (int c = 0; c < n; c++) {
                if (j == c)
                    continue;
                dp[i2][j] = max(dp[i2][j], dp[i1][c] + travelScore[c][j]);
            }
        }
        swap(i1, i2);
    }
    return *max_element(dp[i1].begin(), dp[i1].end());
}
};",1434317691
leolee2025,leolee2020,367,3617,cpp,"class Solution {
public:
int possibleStringCount(string word) {
    word.push_back(' ');
    int ans = 1;
    char last = ' ';
    int streak = 1;
    for (char c : word) {
        if (c == last)
            ++streak;
        else {
            ans += streak - 1;
            streak = 1;
        }
        last = c;
    }
    return ans;
}
};",1434265322
 ,ttthetravelerrr,368,3576,cpp,"class Solution {
public:
    map<char, vector<int>> mp;
    vector<vector<int>> children;
    vector<int> originalSize;
    vector<int> res;
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        children = vector<vector<int>>(n);
        res = vector<int>(n, 0);
        for(int i = 1 ; i < n ; ++i){
            children[parent[i]].push_back(i);
        }

        DFS(0, s);
        GetSize(0);
        return res;
    }

    bool DFS(int i, const string& s){
        mp[s[i]].push_back(i);
        int n = children[i].size();
        for(int j = 0 ; j < n ; ++j){
            if(DFS(children[i][j], s)){
                children[i][j] = 0;
            }
        }
        auto& v = mp[s[i]];
        v.pop_back();
        if(!v.empty()){
            children[*v.rbegin()].push_back(i);
            return true;
        }
        return false;
    }
    int GetSize(int i){
        if(res[i] != 0)
            return res[i];
        int cur = 1;
        for(int j : children[i]){
            if(j == 0)
                continue;
            cur += GetSize(j);
        }
        return res[i] = cur;
    }
};",1434308878
 ,ttthetravelerrr,368,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> score(n, 0);
        for(int l = 0 ; l < k ; ++l){
            vector<int> newscore(n, 0);
            for(int i = 0 ; i < n ; ++i){
                for(int j = 0 ; j < n ; ++j){
                    if(i == j){
                        newscore[i] = max(newscore[i], score[i] + stayScore[l][i]);
                    }
                    else{
                        newscore[j] = max(newscore[j], score[i] + travelScore[i][j]);
                    }
                }
            }
            swap(score, newscore);
        }
        int res = 0;
        for(int i : score){
            res = max(res, i);
        }
        return res;
    }
};",1434317791
 ,ttthetravelerrr,368,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        int n = word.size();
        for(int i = 1 ; i < n ; ++i){
            if(word[i] == word[i-1]){
                ++res;
            }
        }
        return res;
    }
};",1434260118
iPGx5cnGw7,iPGx5cnGw7,369,3576,cpp,"class Solution {
   public:
    vector<int> closest;
    vector<set<int>> adj;
    vector<stack<int>> v;
    vector<int> val;

    void dfs(int root, string& s) {
        for (auto e : adj[root]) {
            if (!v[s[e] - 'a'].empty()) {
                closest[e] = v[s[e] - 'a'].top();
            }
            v[s[e] - 'a'].push(e);
            dfs(e, s);
            v[s[e] - 'a'].pop();
        }
    }

    int dfs2(int root) {
        val[root] = 1;
        for (auto e : adj[root]) {
            val[root] += dfs2(e);
        }
        return val[root];
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = (int)s.size();
        closest.clear();
        closest.resize(n, -1);
        adj.clear();
        adj.resize(n);
        v.clear();
        v.resize(26);
        v[s[0] - 'a'].push(0);
        val.clear();
        val.resize(n);
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) {
                adj[parent[i]].insert(i);
            }
        }
        dfs(0, s);
        for (int i = 0; i < n; i++) {
            if (closest[i] != -1) {
                adj[parent[i]].erase(i);
                adj[closest[i]].insert(i);
            }
        }
        dfs2(0);
        return val;
    }
};",1434304960
iPGx5cnGw7,iPGx5cnGw7,369,3587,cpp,"class Solution {
   public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n));
        for (int i = 1; i <= k; i++) {
            for (int j = 0; j < n; j++) {
                for (int l = 0; l < n; l++) {
                    if (l == j) {
                        dp[i][l] =
                            max(dp[i][l], dp[i - 1][j] + stayScore[i - 1][j]);
                    } else {
                        dp[i][l] =
                            max(dp[i][l], dp[i - 1][j] + travelScore[j][l]);
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, dp[k][i]);
        }
        return ans;
    }
};",1434317842
iPGx5cnGw7,iPGx5cnGw7,369,3617,cpp,"class Solution {
   public:
    int possibleStringCount(string word) {
        int n = (int)word.size();
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][1] = 1;
        for (int i = 1; i < n; i++) {
            dp[i][1] += dp[i - 1][1];
            dp[i][0] += dp[i - 1][0];
            if (word[i] == word[i - 1]) {
                dp[i][0] += dp[i - 1][1];
            }
        }
        return dp[n - 1][0] + dp[n - 1][1];
    }
};",1434266219
sixeye,sixeye,370,3576,python3,"from collections import defaultdict


class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        tree = defaultdict(set)
        sub = [0] * n

        for i in range(1, n):
            tree[parent[i]].add(i)

        visited = set()

        def reshape(root, till={}):
            if root in visited:
                return
            visited.add(root)
            prev = till[s[root]] if s[root] in till else None
            till[s[root]] = root
            for child in tree[root]:
                reshape(child, till)
            if prev is not None:
                till[s[root]] = prev
                parent[root] = prev
            else:
                del till[s[root]]
        

        def dfs(root):
            currSize = 0
            for child in tree[root]:
                currSize += dfs(child)
            sub[root] = currSize + 1
            return sub[root]

        reshape(0)
        tree= defaultdict(set)
        for i in range(1, n):
            tree[parent[i]].add(i)
        dfs(0)

        return sub
",1434296518
sixeye,sixeye,370,3587,python3,"from functools import cache


class Solution:
    def maxScore(
        self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]
    ) -> int:
        dp = [0] * n
        for ki in range(k):
            new_dp = dp[::]
            for i in range(n):
                currScore = dp[i]
                for j in range(n):
                    # if i == 2:
                    #     print(i,j,stayScore[ki][i], travelScore[j][i])
                    if i == j:
                        currScore = max(currScore, dp[j] + stayScore[ki][i])
                    else:
                        currScore = max(currScore, dp[j] + travelScore[j][i])
                new_dp[i] = currScore
            dp = new_dp
        return max(dp)
",1434317891
sixeye,sixeye,370,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 0 
        last = 1
        for i in range(1,len(word)):
            if word[i]!=word[i-1]:
                ans += last - 1
                last = 0
            last += 1
        return ans + last",1434260405
Shivam Verma,verma_shivam,371,3576,java,"import java.util.*;

class Solution {
    public int[] findSubtreeSizes(int[] parentIndices, String nodeCharacters) {
        int totalNodes = parentIndices.length;
        
        List<List<Integer>> initialTree = buildInitialTree(parentIndices, totalNodes);
        List<List<Integer>> finalTree = new ArrayList<>();
        for (int index = 0; index < totalNodes; index++) {
            finalTree.add(new ArrayList<>());
        }
        
        Map<Character, Integer> lastSeenAncestor = new HashMap<>();
        updateTreeStructure(initialTree, finalTree, lastSeenAncestor, nodeCharacters, parentIndices, 0);
        
        return calculateSubtreeSizes(finalTree, totalNodes);
    }

    private int[] calculateSubtreeSizes(List<List<Integer>> finalTree, int totalNodes) {
        int[] subtreeSizes = new int[totalNodes];
        computeSizes(finalTree, subtreeSizes, 0);
        return subtreeSizes;
    }

    private List<List<Integer>> buildInitialTree(int[] parentIndices, int totalNodes) {
        List<List<Integer>> tree = new ArrayList<>();
        for (int index = 0; index < totalNodes; index++) {
            tree.add(new ArrayList<>());
        }
        for (int index = 1; index < totalNodes; index++) {
            tree.get(parentIndices[index]).add(index);
        }
        return tree;
    }

    private int computeSizes(List<List<Integer>> tree, int[] subtreeSizes, int currentNode) {
        int subtreeCount = 1;
        for (int childNode : tree.get(currentNode)) {
            subtreeCount += computeSizes(tree, subtreeSizes, childNode);
        }
        subtreeSizes[currentNode] = subtreeCount;
        return subtreeCount;
    }

    private void updateTreeStructure(List<List<Integer>> initialTree, List<List<Integer>> finalTree, 
                                      Map<Character, Integer> lastSeenAncestor, String nodeCharacters, 
                                      int[] parentIndices, int currentNode) {
        char currentCharacter = nodeCharacters.charAt(currentNode);
        int previousParentIndex = parentIndices[currentNode];
        
        if (currentNode != 0 && lastSeenAncestor.containsKey(currentCharacter)) {
            parentIndices[currentNode] = lastSeenAncestor.get(currentCharacter);
            finalTree.get(lastSeenAncestor.get(currentCharacter)).add(currentNode);
        } else if (currentNode != 0) {
            finalTree.get(previousParentIndex).add(currentNode);
        }
        
        Integer earlierAncestor = lastSeenAncestor.put(currentCharacter, currentNode);

        for (int childNode : initialTree.get(currentNode)) {
            updateTreeStructure(initialTree, finalTree, lastSeenAncestor, nodeCharacters, parentIndices, childNode);
        }
        
        restoreLastSeenAncestor(lastSeenAncestor, currentCharacter, earlierAncestor);
    }

    private void restoreLastSeenAncestor(Map<Character, Integer> lastSeenAncestor, char currentCharacter, 
                                          Integer earlierAncestor) {
        if (earlierAncestor == null) {
            lastSeenAncestor.remove(currentCharacter);
        } else {
            lastSeenAncestor.put(currentCharacter, earlierAncestor);
        }
    }
}
",1434277599
Shivam Verma,verma_shivam,371,3587,java,"
 class Solution {
    public int maxScore(int totalCities, int totalDays, int[][] cityStayScores, int[][] cityTravelScores) {
        int[][] scoreCache = initializeCache(totalDays, totalCities);
        
        int highestScore = 0;
        for (int startingCity = 0; startingCity < totalCities; startingCity++) {
            highestScore = Math.max(highestScore, calculateMaxScore(0, startingCity, totalDays, cityStayScores, cityTravelScores, scoreCache));
        }
        
        return highestScore;
    }

    private int[][] initializeCache(int days, int cities) {
        int[][] cache = new int[days][cities];
        for (int[] cacheRow : cache) {
            Arrays.fill(cacheRow, -1);
        }
        return cache;
    }

    private boolean isCached(int currentDay, int currentLocation, int[][] scoreCache) {
        return scoreCache[currentDay][currentLocation] != -1;
    }

    private int calculateStayScore(int currentDay, int currentLocation, int maxDays, int[][] stayScores, int[][] travelScores, int[][] scoreCache) {
        return stayScores[currentDay][currentLocation] + calculateMaxScore(currentDay + 1, currentLocation, maxDays, stayScores, travelScores, scoreCache);
    }

    private int calculateTravelScores(int currentDay, int currentLocation, int maxDays, int[][] stayScores, int[][] travelScores, int[][] scoreCache, int currentBestScore) {
        for (int destinationCity = 0; destinationCity < travelScores.length; destinationCity++) {
            if (destinationCity != currentLocation) {
                int travelScore = travelScores[currentLocation][destinationCity] + calculateMaxScore(currentDay + 1, destinationCity, maxDays, stayScores, travelScores, scoreCache);
                currentBestScore = Math.max(currentBestScore, travelScore);
            }
        }
        return currentBestScore;
    }

    private boolean isLastDay(int currentDay, int maxDays) {
        return currentDay == maxDays;
    }

    private int calculateMaxScore(int currentDay, int currentLocation, int maxDays, int[][] stayScores, int[][] travelScores, int[][] scoreCache) {
        if (isLastDay(currentDay, maxDays)) {
            return 0;
        }
        
        if (isCached(currentDay, currentLocation, scoreCache)) {
            return scoreCache[currentDay][currentLocation];
        }
        
        int bestScore = calculateStayScore(currentDay, currentLocation, maxDays, stayScores, travelScores, scoreCache);
        bestScore = calculateTravelScores(currentDay, currentLocation, maxDays, stayScores, travelScores, scoreCache, bestScore);
        
        scoreCache[currentDay][currentLocation] = bestScore;
        return bestScore;
    }
}
",1434318048
Shivam Verma,verma_shivam,371,3617,java,"class Solution {
    public int possibleStringCount(String typedString) {
        int possibleOriginalCount = 1;
        int length = typedString.length();
        
        int currentIndex = 0;
        while (currentIndex < length) {
            int repeatCount = 1;
            while (currentIndex + 1 < length && typedString.charAt(currentIndex) == typedString.charAt(currentIndex + 1)) {
                repeatCount++;
                currentIndex++;
            }
            possibleOriginalCount += repeatCount - 1;
            currentIndex++;
        }
        
        return possibleOriginalCount;
    }
}",1434264533
kasi nathan,kasinathansj,372,3576,java,"class Solution {
    ArrayList<ArrayList<Integer>> nal;
    public int[] findSubtreeSizes(int[] parent, String s) {
        ArrayList<ArrayList<Integer>> al = new ArrayList<>();
        this.nal = new ArrayList<>();
        for(int i = 0 ; i < parent.length ; i++){
            al.add(new ArrayList<>());
            nal.add(new ArrayList<>());
        }
        for(int i = 0 ; i < parent.length ; i++){
            int nd = i;
            int pr = parent[nd];
            if(pr!=-1){
                al.get(pr).add(nd);
            }
        }
        int anc[] = new int[26];
        Arrays.fill(anc,-1);
        rec(al,0,anc,s);
        // System.out.println(nal);
        int ans[] = new int[parent.length];
        dfs(nal,0,ans);
        return ans;
    }
    private void rec(ArrayList<ArrayList<Integer>> al , int node , int anc[] , String s){
        int pre = anc[s.charAt(node)-'a'];
        anc[s.charAt(node)-'a'] = node;
        for(int ed : al.get(node)){
            char c = s.charAt(ed);
            if(anc[c-'a']!=-1){
                nal.get(anc[c-'a']).add(ed);
            }else{
                nal.get(node).add(ed);
            }
            rec(al,ed,anc,s);
        }
        anc[s.charAt(node)-'a'] = pre;
    }
    private int dfs(ArrayList<ArrayList<Integer>> al , int node , int ans[]){
        int sum = 1;
        for(int ed : al.get(node)){
            sum += dfs(al,ed,ans);
        }
        return ans[node] = sum;
    }
}",1434303799
kasi nathan,kasinathansj,372,3587,java,"class Solution {
    int dp[][] ;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.dp = new int[k][n];
        for(int a[] : dp)Arrays.fill(a,-1);
        int ma = max(0,k,0,stayScore,travelScore);
        for(int i = 1 ; i < n ; i++){
            ma = Math.max(ma , max(0,k,i,stayScore,travelScore));
        }
        return ma;
    }
    private int max(int k , int kk , int c , int[][] stayScore , int[][] travelScore){
        if(k == kk)return 0;
        if(dp[k][c]!=-1)return dp[k][c];
        int stay = stayScore[k][c] + max(k+1,kk,c,stayScore,travelScore);
        for(int i = 0 ; i < travelScore.length ; i++){
            stay = Math.max(stay , travelScore[c][i] + max(k+1,kk,i,stayScore,travelScore));
        }
        return dp[k][c] = stay;
    }
}",1434318199
kasi nathan,kasinathansj,372,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        int c = 0;
        char p = word.charAt(0);
        for(int i = 0 ; i < word.length() ; i++){
            if(word.charAt(i)==p){
                c++;
            }else{
                ans += c-1;
                c = 1;
            }
            p = word.charAt(i);
        }
        ans += c-1;
        return ans;
    }
}",1434266269
ahong107,ahong107,373,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        _subtree_sizes.resize(s.size());
        vector<vector<int>> adj_list(s.size());
        for (int i = 1; i < parent.size(); ++i) {
            adj_list[parent[i]].push_back(i);
        }
        _parents = parent;
        array<int, 26> last_visited{};
        for (int i = 0; i < 26; ++i)
            last_visited[i] = -1;
        change_parent(s, 0, adj_list, last_visited, -1);
        vector<vector<int>> new_adj_list(s.size());
        for (int i = 1; i < parent.size(); ++i) {
            new_adj_list[_parents[i]].push_back(i);
        }
        count_subtree(new_adj_list, 0, -1);
        return _subtree_sizes;
    }
private:
    vector<int> _subtree_sizes;
    vector<int> _parents;
    void change_parent(string_view s, int node, const vector<vector<int>>& adj_list, array<int, 26> last_visited, int parent) {
        if (last_visited[s[node] - 'a'] != -1) {
            _parents[node] = last_visited[s[node] - 'a'];
        }
        int last_parent = last_visited[s[node] - 'a'];
        last_visited[s[node] - 'a'] = node;
        for (const auto& child : adj_list[node]) {
            if (parent == child)
                continue;
            change_parent(s, child, adj_list, last_visited, node);
        }
        last_visited[s[node] - 'a'] = last_parent;
    }
    int count_subtree(const vector<vector<int>>& adj_list, int node, int parent) {
        int subtree_size = 1;
        for (const auto& child : adj_list[node]) {
            if (parent == child)
                continue;
            subtree_size += count_subtree(adj_list, child, node);
        }
        _subtree_sizes[node] = subtree_size;
        return subtree_size;
    }
};
",1434307657
ahong107,ahong107,373,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // dp[i][city] = max(dp[i - 1][city] + stay, dp[0 ~ n - 1][city])
        vector<vector<int>> dp(k + 1, vector<int>(n));
        int res{0};
        for (int i = 1; i <= k; ++i) {
            for (int city = 0; city < n; ++city) {
                dp[i][city] = dp[i - 1][city] + stayScore[i - 1][city];
                for (int source = 0; source < n; ++source) {
                    dp[i][city] = max(dp[i][city], dp[i - 1][source] + travelScore[source][city]);
                }
                res = max(res, dp[i][city]);
            }
        }
        return res;
    }
};",1434318261
ahong107,ahong107,373,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        bool found = false;
        for (int i = 1; i < word.size(); ++i) {
            if (word[i] == word[i - 1]) {
                int count = 0;
                while (i < word.size() && word[i] == word[i - 1]) {
                    ++count;
                    ++i;
                }
                res += count;
                --i;
            }
                
        }
        return res;
    }
};",1434268391
Anton Fisak,toryinside,374,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        
        data = [set() for _ in range(n)]
        
        for i, p in enumerate(parent):
            if not i:
                continue
                
            data[p].add(i)
            
        def dfs(v, d):
            nonlocal parent

            buf = d[s[v]]
            if buf is not None:
                parent[v] = d[s[v]]
            d[s[v]] = v

            for child in data[v]:
                dfs(child, d)

            d[s[v]] = buf
                
        dfs(0, {c:None for c in ""abcdefghijklmnopqrstuvwxyz""})
        
        data = [set() for _ in range(n)]
        
        for i, p in enumerate(parent):
            if not i:
                continue
                
            data[p].add(i)
            
        answer = [0] * n
        
        def dfs1(v):
            nonlocal answer
            
            answer[v] = 1
            for v1 in data[v]:
                dfs1(v1)
                answer[v] += answer[v1]
                
        dfs1(0)
        
        return answer
            
        
        
        
        
        
        ",1434306433
Anton Fisak,toryinside,374,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        answer = 0
        
        old = [0] * n
        new = [0] * n
        
        for day in range(k):
            for i in range(n):
                old[i] = new[i]
                new[i] = 0
            
            for curr in range(n):
                for prev in range(n):
                    if curr == prev:
                        new[curr] = max(new[curr], old[curr] + stayScore[day][curr])
                    else:
                        new[curr] = max(new[curr], old[prev] + travelScore[prev][curr])
                        
        return max(new)
                        
                    ",1434318277
Anton Fisak,toryinside,374,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        answer = 1
        last = word[0]
        count = 0
        
        for c in word:
            if c == last:
                count += 1
                continue

            answer += count - 1

            last = c
            count = 1

        answer += count - 1

        return answer

            ",1434275685
ChairmanFMao,ChairmanFMao,375,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        child = [[] for i in parent]
        firstOccur = [[] for i in range(26)]
        out = [-1 for i in parent]
        for i in range(len(parent)):
            if parent[i] >= 0:
                child[parent[i]].append(i)
        
        def dfs(node, parent):
            if len(firstOccur[ord(s[node])-97]) == 0:
                out[node] = parent
            else:
                out[node] = firstOccur[ord(s[node])-97][-1]
            
            firstOccur[ord(s[node])-97].append(node)
            
            for i in child[node]:
                dfs(i,node)
                
            firstOccur[ord(s[node])-97].pop()
        
        dfs(0,-1)
        
        child2 = [[] for i in parent]
        for i in range(len(parent)):
            if out[i] >= 0:
                child2[out[i]].append(i)
        
        out2 = [0 for i in parent]
        def dfs2(node):
            out2[node] = 1
            
            for i in child2[node]:
                dfs2(i)
                out2[node] += out2[i]
        
        dfs2(0)
        
        return out2
        ",1434287695
ChairmanFMao,ChairmanFMao,375,3587,python3,"from collections import deque

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        current = [[0 for i in range(k+1)] for j in range(n)]

        for l in range(k):
            for j in range(n):
                time = l; node = j
                for i in range(n):
                    if i != node:
                        current[i][time+1] = max(current[i][time+1], current[node][time] + travelScore[node][i])
                    else:
                        current[i][time+1] = max(current[i][time+1], current[node][time] + stayScore[time][node])
        
        out = 0
        for i in range(n):
            out = max(out, current[i][-1])
        
        return out",1434310824
ChairmanFMao,ChairmanFMao,375,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        out = 1; streak = 0; last = word[0]
        for i in word:
            if i != last:
                out += streak-1
                last = i
                streak = 1
            else:
                streak += 1
        
        out += streak-1
        
        return out",1434262273
sanath_tango3,sanath_tango3,376,3576,cpp,"class Solution {
public:


int n;
//vector<int> np;
vector<vector<int>> g;
string s;
vector<int> pa;
vector<int> res;

void dfs(int ind,vector<int> np){
    if(np[s[ind]-'a']!=-1){
        pa[ind]=np[s[ind]-'a'];
    }

    
    for(int i:g[ind]){
        // if(i==p){
        //     continue;
        // }
        int temp=np[s[ind]-'a'];
        np[s[ind]-'a']=ind;
        
        dfs(i,np);
        np[s[ind]-'a']=temp;
        
    }
}
int find(int ind,int p){
    int ans=0;
    for(int i:g[ind]){
        if(i==p){
            continue;
        }
        ans+=find(i,ind);
    }
    return res[ind]=1+ans;
}

    vector<int> findSubtreeSizes(vector<int>& parent, string sa) {
        n=parent.size();
        pa=parent;
        g.resize(n);
        vector<int> np;
        np.resize(26,-1);
        res.resize(n,-1);
        s=sa;
        for(int i=1;i<n;i++){
            g[pa[i]].push_back(i);
        }
        dfs(0,np);
        g.clear();
        g.resize(n);
         for(int i=1;i<n;i++){
            g[pa[i]].push_back(i);
        }
        for(int i=0;i<n;i++){
          //  cout<<pa[i]<<endl;
            if(res[i]==-1){
                find(i,-1);
            }
                
        }
        return res;
        
    }
};",1434311183
sanath_tango3,sanath_tango3,376,3587,cpp,"class Solution {
public:
int dp[201][201];
int n,k;
vector<vector<int>> st;
vector<vector<int>>ta;
int help(int ind,int d){
    if(d==k){
        return 0;
    }
    if(dp[ind][d]!=-1){
        return dp[ind][d];
    }
    int ans=st[d][ind]+help(ind,d+1);
    for(int i=0;i<n;i++){
        ans=max(ans,ta[ind][i]+help(i,d+1));
        
    }
    return dp[ind][d]=ans;
}
    int maxScore(int a, int b, vector<vector<int>>& s, vector<vector<int>>& t) {
        memset(dp,-1,sizeof(dp));
        n=a;
        k=b;
        st=s;
        ta=t;
        int ans=0;
        for(int i=0;i<n;i++){
            ans=max(ans,help(i,0));
        }
        return ans;
        
    }
};",1434285293
sanath_tango3,sanath_tango3,376,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
        int ans=0;
        int n=w.size();
        for(int i=0;i<n;i++){
            int k=0;
            if(i!=0&&w[i]==w[i-1]){
                continue;
            }
            for(int j=i;j<n;j++){
                if(w[i]==w[j]){
                    k++;
                }else{
                    break;
                }
            }
            ans+=k-1;
        }
        return ans+1;
    }
};",1434264216
Bayartsogt Yadamsuren,bayartsogt,377,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        stack = [[] for _ in range(26)]
        
        graph = defaultdict(set)
        new_graph = defaultdict(set)
        for x, p in enumerate(parent):
            graph[p].add(x)
            new_graph[p].add(x)
        
        def go(i):
            char = ord(s[i]) - ord(""a"")
            if stack[char]:
                # is ancestor
                anc = stack[char][-1]
                new_graph[anc].add(i)
                if parent[i] != anc:
                    new_graph[parent[i]].remove(i)
            
            stack[char].append(i)
            for j in graph[i]:
                go(j)
            
            stack[char].pop()
            
        go(0)
        
        ans = [0] * len(parent)
        def go1(i):
            
            current = 1
            for j in new_graph[i]:
                current += go1(j)
            nonlocal ans
            ans[i] = current
            return current
        
        go1(0)
        # print(graph)
        # print(new_graph)
        return ans
            ",1434302061
Bayartsogt Yadamsuren,bayartsogt,377,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        cache = {}
        def go(i, city):
            if i == k:
                return 0
            
            if (i, city) in cache:
                return cache[(i, city)]
            
            # stay
            score = go(i + 1, city) + stayScore[i][city]
            for dest in range(n):
                score = max(score, go(i + 1, dest) + travelScore[city][dest])
            
            cache[(i, city)] = score
            return score
        
        return max(go(0, city) for city in range(n))
            
                
            ",1434318842
Bayartsogt Yadamsuren,bayartsogt,377,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        p = ""#""
        cnt = 0
        ans = 1
        for x in word + ""#"":
            if p != x and cnt:
                ans += cnt - 1
                cnt = 0
            
            cnt += 1
            p = x
        
        return ans",1434268363
Shicheng Chen,c337134154,378,3576,python3,"class Solution:
    def findSubtreeSizes(self, fa: List[int], s: str) -> List[int]:
            vec = defaultdict(list)
            n = len(fa)
            for i in range(1, n):
                vec[fa[i]].append(i)
            c2id = defaultdict(list)
        
            def dfs(u):
                c2id[s[u]].append(u)
                for v in vec[u]:
                    if s[v] in c2id and c2id[s[v]]:
                        fa[v] = c2id[s[v]][-1]
                    dfs(v)
                c2id[s[u]].pop()
            dfs(0)
        
            ans = [1] * n
            vec = defaultdict(list)
            n = len(fa)
            for i in range(1, n):
                vec[fa[i]].append(i)
        
        
            def dfs2(u):
                c = 1
                for v in vec[u]:
                    c += dfs2(v)
                ans[u] = c
                return c
        
            dfs2(0)
            return ans",1434293491
Shicheng Chen,c337134154,378,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
            dp = [[0] * n for _ in range(k)]

            for icity in range(n):
                dp[0][icity] = stayScore[0][icity]
                dp[0][icity] = max(dp[0][icity], max(travelScore[jcity][icity] for jcity in range(n)))
        
            for iday in range(1, k):
                for icity in range(n):
                    dp[iday][icity] = max(dp[iday - 1][jcity] + travelScore[jcity][icity] for jcity in range(n))
                    dp[iday][icity] = max(dp[iday][icity], dp[iday - 1][icity] + stayScore[iday][icity])
        
        
            return max(dp[k - 1])",1434318852
Shicheng Chen,c337134154,378,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans=1
        for i in range(1,len(word)):
            if word[i]==word[i-1]:
                ans+=1
        return ans",1434262167
jam,jam930725,379,3576,java,"class Solution {
    int[] size;
    Set<Integer>[] es;
    Set<Integer>[] add;
    Set<Integer>[] remove;
    public int[] findSubtreeSizes(int[] p, String s) {
        int n = s.length();
        size = new int[n];
        es = new Set[n];
        add = new Set[n];
        remove = new Set[n];
        for(int i = 0; i < n; i++) {
            es[i] = new HashSet<> ();
            add[i] = new HashSet<> ();
            remove[i] = new HashSet<> ();
        }
        for(int i = 1; i < n; i++) {
            es[p[i]].add(i);
        }
        int[] c = new int[123];
        Arrays.fill(c, -1);
        move(0, c, s.toCharArray(), p);
        for(int i = 0; i < n; i++) {
            for(int ch: remove[i])
                es[i].remove(ch);
            for(int ch: add[i])
                es[i].add(ch);
        }
        build(0);
        return size;
    }

    public int build(int ind) {
        for(int ch: es[ind])
            size[ind] += build(ch);
        return ++size[ind];
    }

    public void move(int ind, int[] c, char[] cs, int[] p) {
        if(c[cs[ind]] != -1) {
            remove[p[ind]].add(ind);
            add[c[cs[ind]]].add(ind);
        }
        int tmp = c[cs[ind]];
        c[cs[ind]] = ind;
        for(int ch: es[ind])
            move(ch, c, cs, p);
        c[cs[ind]] = tmp;
    }
}",1434297434
jam,jam930725,379,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k][n];
        // day 0
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(i == j)
                    dp[0][i] = Math.max(stayScore[0][i], dp[0][i]);
                else
                    dp[0][i] = Math.max(travelScore[j][i], dp[0][i]);
            }
        }

        // day after
        for(int d = 1; d < k; d++) {
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < n; j++) {
                    if(i == j)
                        dp[d][i] = Math.max(stayScore[d][i]+dp[d-1][i], dp[d][i]);
                    else
                        dp[d][i] = Math.max(travelScore[j][i]+dp[d-1][j], dp[d][i]);
                }
            }
        }
        int max = -1;
        for(int profit: dp[k-1])
            max = Math.max(max, profit);
        return max;
    }
}",1434311528
jam,jam930725,379,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int res = 0;
        int cnt = 0;
        char prev = 0;
        int dif = 0;
        for(char c: word.toCharArray()) {
            if(c == prev)
                cnt ++;
            else {
                res += cnt;
                dif++;
                cnt = 1;
                prev = c;
            }
        }
        return res+cnt-dif+1;
    }
}",1434269723
Neeraj Kumar,N_E_E_R_A_J,380,3576,cpp,"const char fastio = [](){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<pii> vii;
typedef vector<pll> vll;
typedef vector<vi> vvi;
typedef vector<vl> vvl;
typedef vector<vii> vvii;
typedef vector<vll> vvll;

#define memset0(primitiveArray) memset(primitiveArray, 0, sizeof(primitiveArray))
#define memset1(primitiveArray) memset(primitiveArray, -1, sizeof(primitiveArray))
#define ALL(iterable) (iterable).begin(), (iterable).end()
#define RALL(iterable) (iterable).rbegin(), (iterable).rend()
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define ROUND(x) (((x) >= 0) ? (ll)((x) + 0.5) : (ll)((x) - 0.5))
#define DEBUG(...) cout << ""[DEBUG-"" << __LINE__ << ""]:""; debug_cout(__VA_ARGS__);

short dx4[] = {-1, 0, 1, 0};
short dy4[] = {0, 1, 0, -1};

short dx8[] = {-1, -1, -1, 0, 1, 1, 1, 0};
short dy8[] = {-1, 0, 1, 1, 1, 0, -1, -1};

short kx[] = {2, 1, -1, -2, -2, -1, 1, 2};
short ky[] = {1, 2, 2, 1, -1, -2, -2, -1};

template<typename T>
void debug_cout(const T& arg) {
    cout << "" "" << arg;
}

template<typename T, typename... Args>
void debug_cout(const T& firstArg, const Args&... args) {
    cout << "" "" << firstArg;
    debug_cout(args...);
}

template <typename T1, typename T2>
ostream &operator<<(ostream &out, pair<T1, T2> &p)
{
    out << ""("" << p.first << "","" << p.second << "")"";
    return out;
}

template <typename T>
ostream &operator<<(ostream &out, vector<T> &vec)
{
    out << ""["";
    for (auto it = vec.begin(); it != vec.end(); ++it)
    {
        if (it != vec.begin())
            out << "","";
        out << *it;
    }
    out << ""]"";
    return out;
}

class Solution {
private:
    vvi generateTree(vi &parent)
    {
        int n = parent.size();
        vvi tree(n);
        for (int i = 1; i < n; i++)
            tree[parent[i]].push_back(i);
        
        return tree;
    }
    
    void updateParent(vvi &tree, int cur, vi &parent, const string &s, vvi &lastSeen)
    {
        if (!lastSeen[s[cur] - 'a'].empty())
            parent[cur] = lastSeen[s[cur] - 'a'].back();
        
        lastSeen[s[cur] - 'a'].push_back(cur);
        
        for (auto &&ngbr: tree[cur])
            updateParent(tree, ngbr, parent, s, lastSeen);
        
        lastSeen[s[cur] - 'a'].pop_back();
    }
    
    int fillSize(vvi &tree, int cur, vi &answer)
    {
        int size = 1;

        for (auto &&ngbr: tree[cur])
            size += fillSize(tree, ngbr, answer);
        
        return answer[cur] = size;
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, const string &s) {
        vvi tree = generateTree(parent);
        vvi lastSeen(26);
        updateParent(tree, 0, parent, s, lastSeen);
        
        vvi newTree = generateTree(parent);
        vi answer(s.length());
        fillSize(newTree, 0, answer);
        return answer;
    }
};",1434302869
Neeraj Kumar,N_E_E_R_A_J,380,3587,cpp,"const char fastio = [](){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<pii> vii;
typedef vector<pll> vll;
typedef vector<vi> vvi;
typedef vector<vl> vvl;
typedef vector<vii> vvii;
typedef vector<vll> vvll;

#define memset0(primitiveArray) memset(primitiveArray, 0, sizeof(primitiveArray))
#define memset1(primitiveArray) memset(primitiveArray, -1, sizeof(primitiveArray))
#define ALL(iterable) (iterable).begin(), (iterable).end()
#define RALL(iterable) (iterable).rbegin(), (iterable).rend()
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define ROUND(x) (((x) >= 0) ? (ll)((x) + 0.5) : (ll)((x) - 0.5))
#define DEBUG(...) cout << ""[DEBUG-"" << __LINE__ << ""]:""; debug_cout(__VA_ARGS__);

short dx4[] = {-1, 0, 1, 0};
short dy4[] = {0, 1, 0, -1};

short dx8[] = {-1, -1, -1, 0, 1, 1, 1, 0};
short dy8[] = {-1, 0, 1, 1, 1, 0, -1, -1};

short kx[] = {2, 1, -1, -2, -2, -1, 1, 2};
short ky[] = {1, 2, 2, 1, -1, -2, -2, -1};

template<typename T>
void debug_cout(const T& arg) {
    cout << "" "" << arg;
}

template<typename T, typename... Args>
void debug_cout(const T& firstArg, const Args&... args) {
    cout << "" "" << firstArg;
    debug_cout(args...);
}

template <typename T1, typename T2>
ostream &operator<<(ostream &out, pair<T1, T2> &p)
{
    out << ""("" << p.first << "","" << p.second << "")"";
    return out;
}

template <typename T>
ostream &operator<<(ostream &out, vector<T> &vec)
{
    out << ""["";
    for (auto it = vec.begin(); it != vec.end(); ++it)
    {
        if (it != vec.begin())
            out << "","";
        out << *it;
    }
    out << ""]"";
    return out;
}

int dp[201][201];

class Solution {
private:
    int helper(int c, int d, vvi &s, vvi &t, const int k, const int n)
    {
        if (d == k)
            return 0;
        
        if (dp[c][d] != -1)
            return dp[c][d];
        
        int stay = s[d][c] + helper(c, d + 1, s, t, k, n);
        
        int trav = 0;
        for (int dest = 0; dest < n; dest++)
            trav = max(trav, t[c][dest] + helper(dest, d + 1, s, t, k, n));
        
        return dp[c][d] = max(stay, trav);
    }

public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset1(dp);

        int answer = 0;
        for (int i = 0; i < n; i++)
            answer = max(answer, helper(i, 0, stayScore, travelScore, k, n));
        
        return answer;
    }
};",1434311591
Neeraj Kumar,N_E_E_R_A_J,380,3617,cpp,"const char fastio = [](){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<pii> vii;
typedef vector<pll> vll;
typedef vector<vi> vvi;
typedef vector<vl> vvl;
typedef vector<vii> vvii;
typedef vector<vll> vvll;

#define memset0(primitiveArray) memset(primitiveArray, 0, sizeof(primitiveArray))
#define memset1(primitiveArray) memset(primitiveArray, -1, sizeof(primitiveArray))
#define ALL(iterable) (iterable).begin(), (iterable).end()
#define RALL(iterable) (iterable).rbegin(), (iterable).rend()
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define ROUND(x) (((x) >= 0) ? (ll)((x) + 0.5) : (ll)((x) - 0.5))
#define DEBUG(...) cout << ""[DEBUG-"" << __LINE__ << ""]:""; debug_cout(__VA_ARGS__);

short dx4[] = {-1, 0, 1, 0};
short dy4[] = {0, 1, 0, -1};

short dx8[] = {-1, -1, -1, 0, 1, 1, 1, 0};
short dy8[] = {-1, 0, 1, 1, 1, 0, -1, -1};

short kx[] = {2, 1, -1, -2, -2, -1, 1, 2};
short ky[] = {1, 2, 2, 1, -1, -2, -2, -1};

template<typename T>
void debug_cout(const T& arg) {
    cout << "" "" << arg;
}

template<typename T, typename... Args>
void debug_cout(const T& firstArg, const Args&... args) {
    cout << "" "" << firstArg;
    debug_cout(args...);
}

template <typename T1, typename T2>
ostream &operator<<(ostream &out, pair<T1, T2> &p)
{
    out << ""("" << p.first << "","" << p.second << "")"";
    return out;
}

template <typename T>
ostream &operator<<(ostream &out, vector<T> &vec)
{
    out << ""["";
    for (auto it = vec.begin(); it != vec.end(); ++it)
    {
        if (it != vec.begin())
            out << "","";
        out << *it;
    }
    out << ""]"";
    return out;
}

class Solution {
public:
    int possibleStringCount(const string &word) {
        vi cnt;
        int count = 0, lastChar = word.front();
        for (auto &&ch: word)
        {
            if (ch == lastChar)
                ++count;
            else
            {
                cnt.push_back(count);
                lastChar = ch;
                count = 1;
            }
        }
        
        cnt.push_back(count);
        int groups = 0, answer = 1;
        for (auto &&g: cnt)
        {
            if (g == 1)
                continue;
            
            groups++;
            answer += g;
        }
        
        return answer - groups;
    }
};",1434266338
Thomas,charlie-tej-123,381,3576,java,"class Solution {
    Map<Integer, List<Integer>> adjMap;
    Map<Character, Integer> ancestorMap;
    int[] subtreeSize;
    
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        adjMap = new HashMap<>();
        ancestorMap = new HashMap<>();
        subtreeSize = new int[n];
        
        for (int i = 0; i < n; i++) {
            adjMap.putIfAbsent(i, new ArrayList<>());
            if (parent[i] != -1) {
                adjMap.putIfAbsent(parent[i], new ArrayList<>());
                adjMap.get(parent[i]).add(i);
            }
        }
        
        boolean[] visited = new boolean[n];
        restructureTree(0, s, visited, parent);

        Arrays.fill(visited, false);
        calculateSubtreeSize(0, visited);

        return subtreeSize;
    }
    
    private void restructureTree(int node, String s, boolean[] visited, int[] parent) {
        visited[node] = true;
        char ch = s.charAt(node);
        
        List<int[]> updates = new ArrayList<>();
        
        if (ancestorMap.containsKey(ch)) {
            int closestAncestor = ancestorMap.get(ch);
            if (parent[node] != -1) {
                updates.add(new int[]{parent[node], node});
            }
            parent[node] = closestAncestor;
            adjMap.get(closestAncestor).add(node);
        }
        
        int previousAncestor = ancestorMap.getOrDefault(ch, -1);
        ancestorMap.put(ch, node);

        for (int child : new ArrayList<>(adjMap.get(node))) {
            if (!visited[child]) {
                restructureTree(child, s, visited, parent);
            }
        }

        for (int[] update : updates) {
            adjMap.get(update[0]).remove(Integer.valueOf(update[1]));
        }

        if (previousAncestor == -1) {
            ancestorMap.remove(ch);
        } else {
            ancestorMap.put(ch, previousAncestor);
        }
    }
    
    private int calculateSubtreeSize(int node, boolean[] visited) {
        visited[node] = true;
        int size = 1;

        for (int child : adjMap.get(node)) {
            if (!visited[child]) {
                size += calculateSubtreeSize(child, visited);
            }
        }
        
        subtreeSize[node] = size;
        return size;
    }
}
",1434304117
Thomas,charlie-tej-123,381,3587,java,"class Solution {
    int n, k;
    int[][] stayScore, travelScore;
    Integer[][] memo;

    public int helper(int idx, int day) {
        if (day == k) return 0;
        if (memo[idx][day] != null) return memo[idx][day];
        
        int stay = stayScore[day][idx] + helper(idx, day + 1);

        int move = 0;
        for (int nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity != idx) {
                move = Math.max(move, travelScore[idx][nextCity] + helper(nextCity, day + 1));
            }
        }

        return memo[idx][day] = Math.max(stay, move);
    }

    public int maxScore(int n, int k, int[][] a, int[][] b) {
        this.n = n;
        this.k = k;
        this.stayScore = a;
        this.travelScore = b;
        this.memo = new Integer[n][k];
        
        int maxPoints = 0;
        for (int i = 0; i < n; i++) {
            maxPoints = Math.max(maxPoints, helper(i, 0));
        }
        
        return maxPoints;
    }
}
",1434280549
Thomas,charlie-tej-123,381,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int cnt[]=new int[26];
        int i,j,n=word.length();
        int ans=1;
        List<Integer> list=new ArrayList<>();
        int x=1;
        char prev=word.charAt(0);
        for(i=1;i<n;i++){
            char ch=word.charAt(i);
            if(ch==prev){
                x++;
            }
            else{
                list.add(x);
                x=1;
                prev=ch;
            }
        }
        list.add(x);
        for(int y:list){
            ans+=y-1;
        }
        return ans;
    }
}",1434264707
Dhruvrajsinh,_batman__,382,3576,cpp,"class Solution {
public:
    
   
    vector<int> dp;
    map<int, vector<int>> mp;
    vector<int> d_p;
    
    void dfs(int node, string &s, vector<vector<int>> &adj) {
        int k = s[node] - 'a';
        
        if (mp.find(k)!=mp.end()) {
            d_p[node] = mp[k].back();
        }
        
        mp[k].push_back(node);
        
        for (int child : adj[node]) {
            if (child != d_p[node]) {
                dfs(child, s, adj);
            }
        }
        
        mp[k].pop_back();
        
        if(mp[k].size()==0) mp.erase(k);
    }
    
    int dfs1(int node, vector<vector<int>> &adj2) {
          int size = 1;
        
        for (int child : adj2[node]) {
            size += dfs1(child, adj2);
        }
       
        return dp[node] = size;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        dp = vector<int>(n, 0);
        
        d_p = parent;  
        
        vector<vector<int>> adj(n);
        
        for (int i = 1; i < n; i++) {
            adj[parent[i]].push_back(i);
        }
        
        
        dfs(0, s, adj);
        
        vector<vector<int>> adj2(n);
        
        for (int i = 1; i < n; i++) {
            adj2[d_p[i]].push_back(i);
        }
        
        dfs1(0, adj2);
        
        return dp;
    }

};",1434305348
Dhruvrajsinh,_batman__,382,3587,cpp,"class Solution {
public:
    
    int dp[202][202];
    
    int solve(int day , int ind , int k , vector<vector<int>>&s,vector<vector<int>>&t){
            if(day == k) return 0;
        
            if(dp[day][ind]!=-1) return dp[day][ind];
        
            int ans = 0;
        
            ans = max(ans , s[day][ind] + solve(day+1,ind,k,s,t));
        
            for(int i=0;i<t.size();i++){
                 ans = max(ans , t[ind][i] + solve(day+1,i,k,s,t));
            }
        
            return dp[day][ind] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
            
        int ans = 0;
         memset(dp,-1,sizeof(dp));
         for(int i=0;i<n;i++){
               ans = max(ans , solve(0,i,k,stay,travel));
         }
        
      //  memset(dp,-1,sizeof(dp));
        
        return ans;
    }
};",1434319168
Dhruvrajsinh,_batman__,382,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
         int ans = 0;
         char prev = '8';
        
         int cnt  = 0 ;
        
         for(auto it : word){
                  if(prev == it) cnt++;
                  else{
                      ans += max(0, cnt - 1);
                      cnt = 1;
                  }
             
                 prev = it;
              }
        
        ans += max(0, cnt - 1);
        
        return ans + 1;
    }
};",1434263886
ygor_ribeiro7,ygor_ribeiro7,383,3576,cpp,"class Solution {
public:
    vector<unordered_set<int>> grafo;
    vector<pair<int,int>> aux;
    vector<int> ancestral, subTree;
    string s;
    
    void dfsAncestral(int u){
        int c = s[u] - 'a';
        int anterior = ancestral[c];
        
        if(anterior != -1){
            aux.push_back({u, anterior});
        }
        
        ancestral[c] = u;
        
        for(int v : grafo[u]){
            dfsAncestral(v);
        }
        
        ancestral[c] = anterior;
    }
    
    void dfs(int u){
        subTree[u] = 1;
        
        for(int v : grafo[u]){
            dfs(v);
            subTree[u] += subTree[v];
        }
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string x) {
        s = x;
        int n = parent.size();
        ancestral.resize(n+5, -1);
        subTree.resize(n, 0);
        aux.clear();
        grafo.assign(n+5, unordered_set<int>());
        for(int i=1;i<n;i++){
            grafo[parent[i]].insert(i);
        }
        
        dfsAncestral(0);
        
        for(pair<int,int> p : aux){
            grafo[parent[p.first]].erase(p.first);
            grafo[p.second].insert(p.first);
        }
        
        dfs(0);
        
        return subTree;
        
    }
};",1434302931
ygor_ribeiro7,ygor_ribeiro7,383,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1, vector<int> (n+1, 0));
        for(int day = k-1; day >= 0; day--){
            for(int city = 0; city < n; city++){
                dp[day][city] = stayScore[day][city] + dp[day+1][city];
                for(int newCity = 0; newCity < n; newCity++){
                    if(city == newCity) continue;
                    dp[day][city] = max(dp[day][city], dp[day+1][newCity] + travelScore[city][newCity]);
                }
            }
        }
        int ans = 0;
        for(int i=0;i<n;i++) ans = max(ans, dp[0][i]);
        return ans;
    }
};",1434319335
ygor_ribeiro7,ygor_ribeiro7,383,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1, cnt = 0;
        char ultimo = word[0];
        word += ""$"";
        for(char c : word){
            if(c == ultimo){
                cnt++;
            }else{
                ans += cnt - 1;
                cnt = 1;
            }
            ultimo = c;
        }
        return ans;
    }
};",1434263232
unknown,u77,384,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        
        G = collections.defaultdict(set)
        for u,v in enumerate(parent):
            if u!=-1 and v!=-1:
                G[u].add(v)
                G[v].add(u)
            
        new_parents = collections.defaultdict(lambda:-1)
        curr_parents = collections.defaultdict(lambda:-1)
        
        def dfs(node, parent, seen):
            curr_parents[node] = parent
            curr = s[node]
            if seen[curr]!=-1:
                new_parents[node] = seen[curr]
            
            prev = seen[curr]
            seen[curr] = node
            for nei in G[node]:
                if nei!=parent:
                    dfs(nei, node, seen)
            seen[curr] = prev
        
        S = set(s)
        dfs(0, -1, {ch:-1 for ch in S})
        # print(curr_parents)
        # print(new_parents)
        curr_parents.update(new_parents)
        # print(curr_parents)
        
        G = collections.defaultdict(set)
        for u,v in curr_parents.items():
            if u!=-1 and v!=-1:
                G[u].add(v)
                G[v].add(u)
                
        @cache
        def dfs1(node, parent):
            res = 1
            for nei in G[node]:
                if nei!=parent:
                    res+=dfs1(nei, node)
            return res
        
        return [dfs1(k, curr_parents[k]) for k in sorted(curr_parents)]",1434304867
unknown,u77,384,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @cache
        def recurse(i, curr):
            if i==k:
                return 0
            
            res = stayScore[i][curr]+recurse(i+1, curr)
            for dest,score in enumerate(travelScore[curr]):
                res = max(res, score+recurse(i+1, dest))
            return res
        
        return max(recurse(0, curr) for curr in range(n))",1434319425
unknown,u77,384,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        for ch,grp in itertools.groupby(word):
            l = len(list(grp))
            res += l-1
        return res",1434263345
Aryan Sanjay Tandon,MaCTaN,385,3576,cpp,"class Solution {
    int dfs(vector<vector<int>>& adj,int curr,vector<int>& subtree){
        for(int child:adj[curr]){
            subtree[curr]+=dfs(adj,child,subtree);
        }
        return subtree[curr];
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> closest_nodes(n,vector<int>(26,-1));
        vector<vector<int>> adj(n);
        for(int i=1;i<n;i++){
            adj[parent[i]].push_back(i);
        }
        queue<int> q;
        q.push(0);
        while(!q.empty()){
            int f = q.front();
            q.pop();
            if(parent[f]!=-1){
                 closest_nodes[f] = closest_nodes[parent[f]];   
            }
            closest_nodes[f][s[f]-'a'] = f;
            if(parent[f]!=-1 && closest_nodes[parent[f]][s[f]-'a']!=-1){
                parent[f] = closest_nodes[parent[f]][s[f]-'a'];
            }
            for(int i=0;i<adj[f].size();i++){
                q.push(adj[f][i]);
            }
        }
        for(int i=0;i<n;i++){
            adj[i] = {};
        }
        for(int i=1;i<n;i++){
            adj[parent[i]].push_back(i);
        }
        vector<int> subtree_size(n,1);
        dfs(adj,0,subtree_size);
        return subtree_size;
    }
};",1434305490
Aryan Sanjay Tandon,MaCTaN,385,3587,cpp,"class Solution {
    int getMaxScore(int curr_city,vector<vector<int>>& stay,vector<vector<int>>& travel,int& k,int& n,int day,vector<vector<int>>& memo){
        if(day==k) return 0;
        if(memo[curr_city][day]!=-1) return memo[curr_city][day];
        int max_score = getMaxScore(curr_city,stay,travel,k,n,day+1,memo)+stay[day][curr_city];
        for(int i=0;i<n;i++){
            if(i==curr_city) continue;
            max_score = max(max_score,getMaxScore(i,stay,travel,k,n,day+1,memo)+travel[curr_city][i]);
        }
        return memo[curr_city][day]=max_score;
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int max_score = 0;
        vector<vector<int>> memo(n,vector<int>(k,-1));
        for(int i=0;i<n;i++){
            max_score = max(getMaxScore(i,stayScore,travelScore,k,n,0,memo),max_score);
        }
        return max_score;
    }
};",1434319502
Aryan Sanjay Tandon,MaCTaN,385,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int possible = 1;
        vector<int> freq(26,0);
        for(int i=0;i<word.length();){
            int j=i+1;
            while(j<word.length() && word[i]==word[j]) j++;
            possible+=(j-i-1);
            i=j;
        }
        return possible;
    }
};",1434266501
Feng W,wddd,386,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        List<Integer>[] adjs = new List[parent.length];
        for (int i = 0; i < adjs.length; i++) {
            adjs[i] = new ArrayList<>();
        }
        for (int i = 0; i < parent.length; i++) {
            if (parent[i] >= 0) {
                adjs[parent[i]].add(i);
            }
        }

        int[] ancestors = new int[26];
        Arrays.fill(ancestors, -1);
        dfs(adjs, s, 0, parent, ancestors);

        int[] inDegrees = new int[parent.length];
        for (int p : parent) {
            if (p >= 0) {
                inDegrees[p]++;
            }
        }

        Queue<Integer> leaves = new ArrayDeque<>();
        for (int i = 0; i < inDegrees.length; i++) {
            if (inDegrees[i] == 0) {
                leaves.add(i);
            }
        }

        int[] sizes = new int[parent.length];

        while (!leaves.isEmpty()) {
            int curr = leaves.poll();
            sizes[curr]++;
            if (parent[curr] >= 0) {
                sizes[parent[curr]] += sizes[curr];
                inDegrees[parent[curr]]--;
                if (inDegrees[parent[curr]] == 0) {
                    leaves.add(parent[curr]);
                }
            }
        }

        return sizes;
    }

    private void dfs(List<Integer>[] adjs, String s, int curr, int[] parent, int[] ancestors) {
        if (ancestors[s.charAt(curr) - 'a'] >= 0) {
            parent[curr] = ancestors[s.charAt(curr) - 'a'];
        }
        
        int prev = ancestors[s.charAt(curr) - 'a'];
        ancestors[s.charAt(curr) - 'a'] = curr;
        for (int next : adjs[curr]) {
            dfs(adjs, s, next, parent, ancestors);
        }
        ancestors[s.charAt(curr) - 'a'] = prev;
    }
}",1434305619
Feng W,wddd,386,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int max = 0;
        
        int[][] cache = new int[k][n];
        for (int[] row : cache) {
            Arrays.fill(row, -1);
        }
        
        for (int i = 0; i < n; i++) {
            max = Math.max(max, score(n, k, 0, i, stayScore, travelScore, cache));
        }

        return max;
    }

    private int score(int n, int k, int day, int city, int[][] stayScore, int[][] travelScore, int[][] cache) {
        if (day + 1 > k) {
            return 0;
        }
        
        if (cache[day][city] >= 0) {
            return cache[day][city];
        }

        int max = stayScore[day][city] + score(n, k, day + 1, city, stayScore, travelScore, cache);

        for (int i = 0; i < n; i++) {
            if (i != city) {
                int temp = travelScore[city][i] + score(n, k, day + 1, i, stayScore, travelScore, cache);
                max = Math.max(max, temp);
            }
        }

        cache[day][city] = max;
        return max;
    }
}",1434319650
Feng W,wddd,386,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int count = 0;
        
        for (int i = 1; i < word.length(); i++) {
            if (word.charAt(i) == word.charAt(i - 1)) {
                count++;
            }
        }
        
        return count + 1;
    }
}",1434262480
Nishant Singh,nishant_7366,387,3576,cpp,"class Solution {
public:
    int helper(int root,vector<vector<int>>&adj,vector<int>&sol)
{
    if(adj[root].size()==0)
    {
        return sol[root]=1;
    }
    int ans=1;
    for(auto it:adj[root])
        {
            ans+=helper(it,adj,sol);
        }
    return sol[root]=ans;
}
    void traverse(int root,vector<vector<int>>&adjList,string &s,vector<int>&arr,vector<int>&c)
    {
        char ch=s[root];
        if(c[ch-'a']!=-1)
        {
            arr[root]=c[ch-'a'];
        }
        int val=c[ch-'a'];
        c[ch-'a']=root;
        for(auto it:adjList[root])
            {
                traverse(it,adjList,s,arr,c);
            }
        c[ch-'a']=val;
        return ;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>>adjList(n);
        for(int i=1;i<n;i++)
            {
                adjList[parent[i]].push_back(i);
            }
        vector<int> arr(n,0);
        arr=parent;
        vector<int> c(26,-1);
        traverse(0,adjList,s,arr,c);
        //c will contain closest parents
        vector<vector<int>>adj(n);
        for(int i=1;i<n;i++)
            {
                adj[arr[i]].push_back(i);
            }

        vector<int> sol(n,0);
        helper(0,adj,sol);
        return sol;
    }
};",1434291741
Nishant Singh,nishant_7366,387,3587,cpp,"class Solution {
public:
int total=-1;
    int helper(int node,int days,vector<vector<int>>&arr1,vector<vector<int>>&arr2,int dp[201][201],int n,int k)
    {
        if(days==0)
        {
            return 0;
        }
        if(node==-1)
        {
            int ans=INT_MIN;
            for(int i=0;i<n;i++)
            {
                ans=max(ans,helper(i,days,arr1,arr2,dp,n,k));
            }
            return ans;
        }
        if(dp[node][days]!=-1)
        {
            return dp[node][days];
        }

        int ans=0;
        for(int i=0;i<n;i++)
            {
                if(i==node)
                    continue;
                
                int val=arr2[node][i]+helper(i,days-1,arr1,arr2,dp,n,k);
                ans=max(ans,val);
            }

        ans=max(ans,arr1[k-days][node]+helper(node,days-1,arr1,arr2,dp,n,k));

        return dp[node][days]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int dp[201][201];
        memset(dp,-1,sizeof(dp));

        return helper(-1,k,stayScore,travelScore,dp,n,k);
    }
};",1434312336
Nishant Singh,nishant_7366,387,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
         int sol=0;
         char last=word[0];
         int count=1;
        for(int i=1;i<word.length();i++)
            {
                if(word[i]==last)
                {
                    count++;
                }
                else
                {
                    last=word[i];
                    if(count>=1)
                    {
                        sol+=(count-1);
                    }
                    count=1;
                }
            }
        if(count>=1)
        {
            sol+=(count-1);
        }
        return sol+1;
    }
};",1434268793
Lorenzo Cian,cianotico,388,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = defaultdict(set)
        for u in range(n):
            children[parent[u]].add(u)

        ancestor = defaultdict(lambda: None)
        def dfs_ancestor(u, c, found):
            if s[u] == c:
                ancestor[u] = found
                found = u
            for v in children[u]:
                dfs_ancestor(v, c, found)
        for c in string.ascii_lowercase:
            dfs_ancestor(0, c, None)

        for u in range(1, n):
            if ancestor[u] != None:
                parent[u] = ancestor[u]
        children = defaultdict(set)
        for u in range(n):
            children[parent[u]].add(u)
        
        size = defaultdict(int)
        def dfs(u):
            s = 1
            for v in children[u]:
                s += dfs(v)
            size[u] = s
            return s
        dfs(0)

        res = [n]
        for u in range(1, n):
            res.append(size[u])
        return res",1434302132
Lorenzo Cian,cianotico,388,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0 for _ in range(n)] for _ in range(k + 1)]
        for i in range(k - 1, -1, -1):
            for j in range(n):
                dp[i][j] = dp[i + 1][j] + stayScore[i][j]
                for l in range(n):
                    if l == j:
                        continue
                    dp[i][j] = max(
                        dp[i][j],                        
                        dp[i + 1][l] + travelScore[j][l]
                    )
        return max(dp[0])",1434319732
Lorenzo Cian,cianotico,388,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        res = 1
        last = None
        count = 0
        for c in chain(word, ""\x00""):
            if c == last:
                count += 1
            else:
                if count > 1:
                    res += (count - 1)
                last = c
                count = 1
        return res",1434266889
aman_bedi,AmanBedi,391,3576,cpp,"class Solution {
public:
    vector<int>v[100001];
    vector<int>t[100001];
    vector<int>anc[26];
    int ans[100001];
    void dfs(int src,int par, string &s){
        anc[s[src]-'a'].push_back(src);
        for(auto it:v[src]){
            if(it==par)continue; 
            dfs(it,src,s); 
        }  
        for(auto it:v[src]){
            if(it==par)continue; 
            if(!anc[s[it]-'a'].empty()){
                int last = anc[s[it]-'a'].back(); 
                t[last].push_back(it);
            } else{
                t[src].push_back(it);
            }
        }
        anc[s[src]-'a'].pop_back();

    }
    void dfs2(int src,int par){
        ans[src]=1; 
        for(auto it:t[src]){
            if(it==par)continue; 
            dfs2(it,src);
            ans[src]+=ans[it];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        for(int i=0;i<=parent.size();++i){
            v[i].clear(); 
            t[i].clear();
            ans[i] = 0;
        }
        for(int i=0;i<26;++i){
            anc[i].clear();
        }
        for(int i=1;i<parent.size();++i){
            v[parent[i]].push_back(i);
        }
        dfs(0,-1,s);
        dfs2(0,-1);
        vector<int>res; 
        for(int i=0;i<parent.size();++i){
            res.push_back(ans[i]);
        } 
        return res;
        
    }
};",1434312684
aman_bedi,AmanBedi,391,3587,cpp,"class Solution {
public:
    int dp[203][203];
    int solve(int cur_city, int day, int n,int k,vector<vector<int>>& s,  vector<vector<int>>& t){
        if(day>=k){
            return 0;
        } 
        if(dp[cur_city][day]!=-1){
            return dp[cur_city][day];
        }
        
        int ans = 0;
        
        if(cur_city==n+1){
            for(int i=0;i<n;++i){
                ans = max(ans,solve(i,day,n,k,s,t));
            } 
        } else{
            
            ans = max(ans, solve(cur_city, day+1,n,k,s,t) + s[day][cur_city]);
            for(int i=0;i<n;++i){
                if(i==cur_city)continue; 
                ans = max(ans, solve(i,day+1,n,k,s,t) + t[cur_city][i]);
            }  
        }
        return dp[cur_city][day] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp,-1,sizeof(dp));
        return solve(n+1,0,n,k,stayScore,travelScore);
    }
};",1434290328
aman_bedi,AmanBedi,391,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 0; 
        for(int i=0;i<word.size();){
            int j=i; 
            while(j<word.size() && word[i]==word[j]){
                ++j; 
            }
            int len = j-i; 
            if(len>1){
                ans+=len-1;
            }
            i=j;
        } 
        return ans+1;
    }
};",1434260717
,louisfghbvc,392,3576,cpp,"class Solution {
public:
    
    vector<int> update(vector<int>& parent, string& s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i)
            tree[parent[i]].push_back(i);
        
        vector<vector<int>> rec(26);
        auto dfs = [&](auto &self, int u) -> void {
            if (rec[s[u]-'a'].size()) {
                parent[u] = rec[s[u]-'a'].back();
            }
            rec[s[u]-'a'].push_back(u);
            for (int v: tree[u]) {
                self(self, v);
            }    
            rec[s[u]-'a'].pop_back();
        };
        dfs(dfs, 0);
        return parent;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        // goal: find the subtree size after remove the same node
        
        // idea:
        // dfs, when current node find the duplicate just update the parent!
        // after one time, compute the tree size
        
        parent = update(parent, s);
        
        // compute tree size
        int n = parent.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i)
            tree[parent[i]].push_back(i);
        
        vector<int> res(n);
        auto dfs = [&](auto &self, int u) -> int {
            int sum = 1;
            for (int v: tree[u]) {
                sum += self(self, v);
            }    
            return res[u] = sum;
        };
        dfs(dfs,0);
        return res;
    }
};",1434292231
,louisfghbvc,392,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // goal: find the maximum score by starting any point
        // for each node => we can stay or not
        
        // idea:
        // dp
        // dp[i][j][k] => maximum score from i to j ending at k days
        // for each node compute the dijkstra?
        
        // idea2:
        // why not just iterate the k
        // for each k, we compute all possible?
        
        vector dp(n, 0); // dp[i]: ending is i, maximum score
        
        for (int d = 0; d < k; ++d) {
            vector ndp = dp;
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    // i->j, use trav or stay
                    ndp[j] = max(ndp[j], dp[i] + travelScore[i][j]);
                    ndp[j] = max(ndp[j], dp[j] + stayScore[d][j]);
                }
            }
            swap(dp, ndp);
        }
        
        
        return ranges::max(dp);
    }
};",1434312686
,louisfghbvc,392,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        // goal: find the number of distinct string that delay at most one time
        
        // idea:
        // group the letter
        // ans = 1 + sum of duplicate len - 1 
        
        
        int ans = 1;
        int n = word.size();
        for (int i = 0, j = i; i < n; i = j) {
            j = i;
            while (j < n && word[j] == word[i]) j++;
            int len = j-i;
            ans += len-1;
        }
        return ans;
    }
};",1434265255
Nikhil Paul,nikhil_paul,393,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def dfs_(node):
            ans = 1
            for i in g[node]:
                ans += dfs_(i)
            fans[node] = ans
            return ans

        def dfs(node, par):
            prev = d.get(s[node], -1)
            if prev != -1:
                g[par].remove(node)
                g[prev].add(node)
            d[s[node]] = node
            for i in list(g[node]):
                dfs(i, node)
            d[s[node]] = prev

        g, d, fans = defaultdict(set), {}, [0]*len(s)
        for ix, i in enumerate(parent):
            g[i].add(ix)
        dfs(0, -1)
        dfs_(0)
        return fans",1434303848
Nikhil Paul,nikhil_paul,393,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(i, j):
            if j == k: return 0
            ans = stayScore[j][i]+dp(i, j+1)
            for u in range(n):
                if u != i:
                    ans = max(ans, travelScore[i][u]+dp(u, j+1))
            return ans

        ans = 0
        for i in range(n):
            ans = max(ans, dp(i, 0))
        return ans",1434312875
Nikhil Paul,nikhil_paul,393,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        prev, ans = '', 1
        for i in word:
            if i == prev: ans+=1
            prev = i
        return ans",1434265217
Siddhapura Om,s1967,394,3576,cpp,"class Solution {
public:
    void dfs(int v,vector<int>g[],vector<int>newg[],string &s,vector<int>node){
        node[s[v]-'a']=v;
        for(auto &c:g[v]){
            if(node[s[c]-'a']!=-1){
                newg[node[s[c]-'a']].push_back(c);
            }
            else {
                 newg[v].push_back(c);
            }
            dfs(c,g,newg,s,node);
        }
    }
    void calc(int v,vector<int>g[],vector<int>&ans){
        for(auto &c:g[v]){
            calc(c,g,ans);
            ans[v]+=ans[c];
        }
        ans[v]++;
    }
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n=s.length();
        vector<int>g[n];
        for(int i=1;i<n;i++){
            g[p[i]].push_back(i);
        }
        vector<int>newg[n];
        vector<int>node(26,-1);
        dfs(0,g,newg,s,node);
        vector<int>ans(n);
        calc(0,newg,ans);
        return ans;
    }
};",1434294233
Siddhapura Om,s1967,394,3587,cpp,"class Solution {
public:
    int calc(int index,vector<vector<int>>&s,vector<vector<int>>&t,int k1,int k,vector<vector<int>>&dp){
        if(k==k1)return 0;
        if(dp[index][k]!=-1)return dp[index][k];
        int n=t.size();
        int maxi=0;
        for(int i=0;i<n;i++){
            if(i==index)continue;
            int p1=t[index][i]+calc(i,s,t,k1,k+1,dp);
            maxi=max(maxi,p1);
        }
        maxi=max(maxi,s[k][index]+calc(index,s,t,k1,k+1,dp));
        return dp[index][k]=maxi;
    }
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>&t) {
        vector<vector<int>>dp(n,vector<int>(k+1,-1));
        int maxi=0;
          for(int i=0;i<n;i++){
              maxi=max(maxi,calc(i,s,t,k,0,dp));
          }      
        return maxi;
    }
};",1434320251
Siddhapura Om,s1967,394,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
        int n=w.length();
        int ans=1;
        int c=1;
        for(int i=1;i<n;i++){
            if(w[i]!=w[i-1]){
                ans+=(c-1);
                c=1;
            }
            else c++;
        }
        ans+=(c-1);
        return ans;
    }
};",1434268007
cipher030,cipher030,396,3576,cpp,"class Solution {
public:

    void dfs(int node,int pp,string &s,vector<vector<int>> &chars, vector<vector<int>>&g,vector<int>& par ){
        char ch=s[node];
        if(!chars[ch-'a'].empty()){
            par[node]=chars[ch-'a'].back();
        }
        chars[ch-'a'].push_back(node);
        for(auto it:g[node]){
            if(it!=pp){
                dfs(it,node,s,chars,g,par);
            }
        }
        chars[ch-'a'].pop_back();
    }
    void traverse(int node,int pp,vector<vector<int>>& g, vector<int>& sub){
        sub[node]=1;
        for(auto it:g[node]){
            if(it!=pp){
                traverse(it,node,g,sub);
                sub[node]+=sub[it];
            }
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=s.size();
        vector<vector<int>> chars(26);
        vector<int> par(parent.begin(),parent.end());
        vector<vector<int>> g(n);

        for(int i=1;i<n;i++){
            int u=i,v=parent[i];
            g[u].push_back(v);g[v].push_back(u);
        }
        dfs(0,-1,s,chars,g,par);

        g.clear();g.resize(n);
        for(int i=1;i<n;i++){
            int u=i,v=par[i];
            g[u].push_back(v);g[v].push_back(u);
        }

        vector<int> subtree(n);
        traverse(0,-1,g,subtree);

        return subtree;
        
    }
};",1434285860
cipher030,cipher030,396,3587,cpp,"class Solution {
int dp[210][210];

public:
    int calc(int idx,int city,int k,int n,vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
        if(idx==k) return 0;

        if(dp[idx][city]!=-1 ) return dp[idx][city];

        int ans=calc(idx+1,city,k,n,stayScore,travelScore)+stayScore[idx][city];
        for(int i=0;i<n;i++){
            if(i==city) continue;
            ans=max(ans,travelScore[city][i]+calc(idx+1,i,k,n,stayScore,travelScore));
        }

        return dp[idx][city]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp,-1,sizeof(dp));
        int ans=0;
        for(int i=0;i<n;i++){
            ans=max(ans,calc(0,i,k,n,stayScore,travelScore));
        }
        return ans;
        
    }
};",1434313142
cipher030,cipher030,396,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=1;i<word.size();i++){
            if(word[i]==word[i-1]) ans++;
        }
        return ans;
    }
};",1434260382
Jonas,arael34,397,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        childList = collections.defaultdict(set)
        for node, par in enumerate(parent):
            if par == -1: continue
            childList[par].add(node)

        def change(node: int, map):
            ch = s[node]
            if ch in map:
                childList[parent[node]].discard(node)
                childList[map[ch]].add(node)
            od = map.get(ch, None)
            map[ch] = node
            for child in list(childList[node]):
                change(child, map)
            if od != None:
                map[ch] = od
            else:
                del map[ch]

        change(0, {})

        ans = [-1] * len(s)
        def calc(node: int):
            if ans[node] != -1: return ans[node]
            sz = 1
            for child in childList[node]:
                sz += calc(child)
            ans[node] = sz
            return sz

        for i in range(len(s)):
            calc(i)

        return ans
",1434297015
Jonas,arael34,397,3587,python3,"""""""
maxPoints(city, day) = {
    max(
        stay
        move
    )
}
""""""

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [ [0] * n for _ in range(k + 1) ]

        dp[0] = [0] * n

        for day in range(k):
            for city in range(n):
                dp[day + 1][city] = stayScore[day][city] + dp[day][city]
                for other in range(n):
                    if other == city: continue
                    dp[day + 1][city] = max(
                        dp[day + 1][city],
                        travelScore[other][city] + dp[day][other]
                    )

        return max(dp[-1])
",1434313243
Jonas,arael34,397,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        last = word[0]
        cnt = 0
        for ch in word:
            if ch == last: cnt += 1
            last = ch

        return cnt
",1434260681
Anand Tripathi,bit-manipulator,398,3576,cpp,"class Solution {
public:
    vector<vector<int>> g;
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        unordered_map<char,int> mp;
        int n = parent.size();
        g.resize(n);
        vector<vector<int>> graph(n);
        for(int i=1; i<n; i++){
            graph[parent[i]].push_back(i);
            mp[s[i]] = -1;
        }
        mp[s[0]] = -1;
        dfs(parent, s, mp, 0, graph);
        for(int i=1; i<n; i++){
            g[parent[i]].push_back(i);
        }
        vector<int> ans(n,0);
        solve(0, ans);
        return ans;
    }
    int solve(int u, vector<int>& ans){
        int res = 1;
        for(auto v:g[u]){
            res += solve(v,ans);
        }
        return ans[u] = res;
    }
    void dfs(vector<int>& parent, string& s, unordered_map<char,int>& mp, int u, vector<vector<int>>& graph){
        int curr = mp[s[u]];
        mp[s[u]] = u;
        for(auto v : graph[u]){
            if(mp[s[v]] != -1){
                parent[v] = mp[s[v]];
            }
            dfs(parent, s, mp, v, graph);
        }
        mp[s[u]] = curr;
    }
};",1434285388
Anand Tripathi,bit-manipulator,398,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        memset(dp,-1,sizeof(dp));
        for(int i=0; i<n; i++){
            int res = solve(n, k, stayScore, travelScore, 0, i);
            ans = max(ans,res);
        }
        return ans;
    }
    int solve(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel, int day, int city){
        if(day == k)
            return 0;
        if(dp[day][city] != -1)
            return dp[day][city];
        int ans = stay[day][city] + solve(n, k, stay, travel, day+1, city);
        for(int i=0; i<n; i++){
            int leave = travel[city][i] + solve(n, k, stay, travel, day+1, i);
            ans = max(ans,leave);
        }
        return dp[day][city] = ans;
    }
};

// complete graph
// two choices: stay current city and get stay[day][curr]
// go to dest city and get traver[curr][dest]
// start from each city, and apply DP, for 
// DP -> If I am at this city, how much money I can earn in k days
// If I already know how much money I can earn in 5 days if i'm at city 109 then why compute?",1434305861
Anand Tripathi,bit-manipulator,398,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        unordered_map<char,int> mp;
        int n = word.size();
        int ans = 1;
        for(int i=0; i<n; i++){
            if(i > 0 && word[i-1] == word[i]){
                ans++;
            }
        }
        return ans;
    }
};",1434264459
OuterRidgeSavage,OuterRidgeSavage,399,3576,cpp,"class Solution {
public:
    string s;
    int n;
    vector<vector<int>> ch, ch2;
    vector<int> p, last, ans;

    void traverse(int r) {
        int i = s[r]-'a';
        if (r != 0)
        ch2[last[i] != -1 ? last[i] : p[r]].push_back(r);
        int tmp = last[i];
        last[i] = r;
        for (int c : ch[r]) {
            traverse(c);
        }
        last[i] = tmp;
    }

    void traverse2(int r) {
        ans[r] = 1;
        for (int i : ch2[r]) {
            traverse2(i);
            ans[r] += ans[i];
        }
    }

    vector<int> findSubtreeSizes(vector<int>& _p, string _s) {
        s = std::move(_s);
        p = std::move(_p);
        n = p.size();
        ch.resize(n, vector<int>());
        ch2.resize(n, vector<int>());
        for (int i = 1; i < n; ++i) {
            ch[p[i]].push_back(i);
        }
        last.resize(26, -1);
        traverse(0);
        
        ans.resize(n, 0);
        traverse2(0);
        
        return ans;
    }
};",1434301186
OuterRidgeSavage,OuterRidgeSavage,399,3587,cpp,"#define REP(i, a, b) for(int i=a;i<b;++i)
template <class X, class Y> void Max(X& x, Y y) { if (x < y) x = y; }

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay_s, vector<vector<int>>& tvl_s) {
        int dp[k+1][n];
        memset(dp, 0, sizeof(dp));
        REP(i,1,k+1) {
            // day i-1 to day i.
            REP(j,0,n) {
                Max(dp[i][j], dp[i-1][j]+stay_s[i-1][j]);
                REP(l,0,n) {
                    Max(dp[i][l], dp[i-1][j] + tvl_s[j][l]);
                }
            }
        }
        int ans = 0;
        REP(i,0,n) {
            Max(ans, dp[k][i]);
        }
        return ans;
    }
};",1434320605
OuterRidgeSavage,OuterRidgeSavage,399,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
        int ans = 1;
        int n = w.size();
        // vector<int> c;
        for (int i = 0; i < n;) {
            int j = i + 1;
            for (; j < n && w[j] == w[i]; ++j);
            if (j - i > 1) ans += j-i-1;
            // c.push_back(j-i);
            i = j;
        }
        return ans;
    }
};",1434269978
John Rigby,vanshkunwarji41,400,3576,cpp,"class Solution {
public:
    set<pair<int,int>> r;
    void f(int i, vector<int> adj[], string &s,vector<int> w[], int p,vector<int> bdj[]){
        if(p!=-1 && !w[s[i]-'a'].empty() && w[s[i]-'a'].back()!=p){
            r.insert({p,i});
            bdj[w[s[i]-'a'].back()].push_back(i);
        }
        w[s[i]-'a'].push_back(i);
        for(auto j:adj[i]){
            f(j,adj,s,w,i,bdj);
        }
        w[s[i]-'a'].pop_back();    }
    void g(int i, vector<int> adj[],int p,vector<int> &v){
        v[i]=1;
        for(auto j:adj[i]){
            g(j,adj,i,v);
            v[i]+=v[j];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        r.clear();
        int n=s.size();
        // v=vector<int> (n,0);
        vector<int> adj[n],bdj[n];
        for(int i=1;i<parent.size();i++){
            adj[parent[i]].push_back(i);
        }
        vector<int> w[26];
        f(0,adj,s,w,-1,bdj);
        for(int i=1;i<parent.size();i++){
            if(r.find({parent[i],i})==r.end()){
            bdj[parent[i]].push_back(i);
            }
        }
        vector<int> v(n);
        g(0,bdj,-1,v);
        return v;
    }
};",1434301592
John Rigby,vanshkunwarji41,400,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int r=0;
        int dp[k+1][n];
        for(int i=0;i<=k;i++){
            for(int j=0;j<n;j++){
                dp[i][j]=0;
                if(i==0){
                    continue;
                }
                dp[i][j]=dp[i-1][j]+stayScore[i-1][j];
                for(int k=0;k<n;k++){
                    dp[i][j]=max(dp[i][j],dp[i-1][k]+travelScore[k][j]);
                }
                r=max(r,dp[i][j]);
            }
        }
        return r;
    }
};",1434313514
John Rigby,vanshkunwarji41,400,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int a=1;
        int r=1;
        for(int i=0;i<word.size();i++){
            if(i!=0 && word[i]==word[i-1]){
                a++;
            }
            else{
                r+=a-1;
                // cout<<a-1<<endl;
                a=1;
            }
        }
        // cout<<a-1<<endl;
        r+=a-1;
        return r;
    }
};",1434263565
whiz_guy,whiz_guy,401,3576,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> p32;
typedef pair<ll, ll> p64;
typedef pair<double, double> pdd;
typedef vector<ll> v64;
typedef vector<int> v32;
typedef vector<char> vchar;
typedef vector<bool> vbool;
typedef vector<vector<int>> vv32;
typedef vector<vector<ll>> vv64;
typedef vector<vector<p64>> vvp64;
typedef vector<vector<char>> vvchar;
typedef vector<vector<bool>> vvbool;
typedef vector<p64> vp64;
typedef vector<p32> vp32;
ll M = 1000000007;
double eps = 1e-12;
#define forn(i, e) for (ll i = 0; i < e; i++)
#define forsn(i, s, e) for (ll i = s; i < e; i++)
#define rforn(i, s) for (ll i = s; i >= 0; i--)
#define rforsn(i, s, e) for (ll i = s; i >= e; i--)
#define pb push_back
#define ff first
#define ss second
#define INF 2e18
#define fast_cin()                    \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL)
#define all(x) (x).begin(), (x).end()
#define sz(x) ((ll)(x).size())
class Solution {
public:
void dfs(int cur,int par,vv32 &v,vv32 &an,v32 &temp,string &s){
    an[cur]=temp;
    int val=temp[s[cur]-'a'];
    temp[s[cur]-'a']=cur;
    for(auto &it:v[cur]){
        if(it!=par){
            dfs(it,cur,v,an,temp,s);
        }
    }
    temp[s[cur]-'a']=val;
}

int dfs2(int cur,int par,vv32 &gr,v32 &ans){
    int res=1;
    for(auto &it:gr[cur]){
        if(it!=par){
            res+=dfs2(it,cur,gr,ans);
        }
    }
    ans[cur]=res;
    return res;
}
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n=sz(p);
        vv32 v(n);
        forsn(i,1,n){
            v[p[i]].push_back(i);
        }

        vv32 an(n);
        v32 pa(26,-1);
        dfs(0,-1,v,an,pa,s);

        forsn(i,1,n){
            int val=an[i][s[i]-'a'];
            if(val==-1) continue;
            p[i]=val;
        }
            //forn(i,n) cout<<p[i]<<"" "";
        cout<<endl;
        v32 ans(n,0);
        vv32 gr(n);
        forsn(i,1,n){
            gr[p[i]].push_back(i);
        }
        dfs2(0,-1,gr,ans);
        return ans;
    }
};",1434298973
whiz_guy,whiz_guy,401,3587,cpp,"
typedef long long ll;
typedef long double ld;
typedef pair<int, int> p32;
typedef pair<ll, ll> p64;
typedef pair<double, double> pdd;
typedef vector<ll> v64;
typedef vector<int> v32;
typedef vector<char> vchar;
typedef vector<bool> vbool;
typedef vector<vector<int>> vv32;
typedef vector<vector<ll>> vv64;
typedef vector<vector<p64>> vvp64;
typedef vector<vector<char>> vvchar;
typedef vector<vector<bool>> vvbool;
typedef vector<p64> vp64;
typedef vector<p32> vp32;
ll M = 1000000007;
double eps = 1e-12;
#define forn(i, e) for (ll i = 0; i < e; i++)
#define forsn(i, s, e) for (ll i = s; i < e; i++)
#define rforn(i, s) for (ll i = s; i >= 0; i--)
#define rforsn(i, s, e) for (ll i = s; i >= e; i--)
#define pb push_back
#define ff first
#define ss second
#define INF 2e18
#define fast_cin()                    \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL)
#define all(x) (x).begin(), (x).end()
#define sz(x) ((ll)(x).size())
class Solution {
public:
int dp[201][201];
    int solve(int curCity,int day,int &n,int &k,vv32 &s,vv32 &t){
        if(day==k) return 0;
        if(dp[curCity][day]!=-1) return dp[curCity][day];
        int ans=0;
        forn(i,n){
            if(i==curCity){
                ans=max(ans,s[day][i]+solve(i,day+1,n,k,s,t));
            }else ans=max(ans,t[curCity][i]+solve(i,day+1,n,k,s,t));
        }
        return dp[curCity][day]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {

        int ans=0;
        
        memset(dp,-1,sizeof(dp));
        forn(i,n){
            ans=max(ans,solve(i,0,n,k,s,t));
        }
        return ans;
    }
};",1434313663
whiz_guy,whiz_guy,401,3617,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> p32;
typedef pair<ll, ll> p64;
typedef pair<double, double> pdd;
typedef vector<ll> v64;
typedef vector<int> v32;
typedef vector<char> vchar;
typedef vector<bool> vbool;
typedef vector<vector<int>> vv32;
typedef vector<vector<ll>> vv64;
typedef vector<vector<p64>> vvp64;
typedef vector<vector<char>> vvchar;
typedef vector<vector<bool>> vvbool;
typedef vector<p64> vp64;
typedef vector<p32> vp32;
ll M = 1000000007;
double eps = 1e-12;
#define forn(i, e) for (ll i = 0; i < e; i++)
#define forsn(i, s, e) for (ll i = s; i < e; i++)
#define rforn(i, s) for (ll i = s; i >= 0; i--)
#define rforsn(i, s, e) for (ll i = s; i >= e; i--)
#define pb push_back
#define ff first
#define ss second
#define INF 2e18
#define fast_cin()                    \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL)
#define all(x) (x).begin(), (x).end()
#define sz(x) ((ll)(x).size())
class Solution {
public:
    int possibleStringCount(string s) {
        int ans=1,cnt=1,n=sz(s);
        forsn(i,1,n){
            if(s[i]==s[i-1]){
                cnt++;
                if(i==n-1) ans+=(cnt-1);
            }else{
                ans+=(cnt-1);
                cnt=1;
            }
            
        }
        return ans;
    }
};",1434262870
Nayan Verma,nayanverma14,402,3576,java,"class Solution {
    HashMap<Integer,HashSet<Integer>> mapCurr = new HashMap<>();
	HashMap<Integer,HashSet<Integer>> mapNew = new HashMap<>();
	public int[] findSubtreeSizes(int[] parent, String s) {
		int n=parent.length;
        int ans[] =new int[n];
		for(int i=0;i<n;i++)
		{
			mapCurr.put(i,new HashSet<>());
			mapNew.put(i,new HashSet<>());
		}
		for(int i=1;i<n;i++)
		{
			int par = parent[i];
			mapCurr.get(par).add(i);
		}
		int arr[] = new int[26];
		char str[] = s.toCharArray();
		Arrays.fill(arr,-1);
		dfs(0,arr,str,parent);
		// System.out.println(mapNew);
		int size = dfs2(0,ans);
		return ans;
    }
	public int dfs2(int node,int ans[])
	{
		int temp=0;
		for(int i:mapNew.get(node))
		{
			temp+=(dfs2(i, ans));
		}
		return ans[node]=temp+1;
	}
	public void dfs(int node,int arr[],char str[],int parent[])
	{
		char ch = str[node];
		if(arr[ch-'a']!=-1)
		{
			mapNew.get(arr[ch-'a']).add(node);
		}
        else
        {
            if(node!=0)
            {
                mapNew.get(parent[node]).add(node);
            }
        }
        int temp = arr[ch-'a'];
		arr[ch-'a']=node;
		for(int i:mapCurr.get(node))
		{
			dfs(i,arr,str,parent);
		}
        arr[ch-'a']=temp;
	}
}",1434294677
Nayan Verma,nayanverma14,402,3587,java,"class Solution {
    int dp[][];
	public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int ans=0;
        // System.out.println(n);
		dp = new int[k+1][n+1];
		for(int i=0;i<=k;i++)
			Arrays.fill(dp[i],-1);
		for(int i=0;i<n;i++)
		{
			ans=Math.max(ans,rec(0, k, n, i, stayScore, travelScore));
		}
		return ans;
    }
	public int rec(int day,int k,int n,int curr,int stayScore[][], int travelScore[][])
	{
		if(day>=k)
			return 0;
		if(dp[day][curr]!=-1)
			return dp[day][curr];
		int max = 0;
		// stay
		max=Math.max(max,rec(day+1, k,n,curr, stayScore, travelScore)+stayScore[day][curr]);
		// move
		for(int i=0;i<n;i++)
		{
			if(i==curr)
				continue;
            // System.out.println(curr+"" ""+i+"" ""+n);
            // if(i>=n)
            //     break;
			max=Math.max(max,rec(day+1, k, n, i, stayScore, travelScore)+travelScore[curr][i]);
		}
		dp[day][curr]=max;
		return max;
	}
}",1434320941
Nayan Verma,nayanverma14,402,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans=1;
		int count=1;
		char prev = word.charAt(0);
		for(int i=1;i<word.length();i++)
		{
			if(word.charAt(i)==prev)
			{
				count++;
			}
			else
			{
				prev=word.charAt(i);
				ans+=count-1;
                count=1;
			}
		}
		ans+=count-1;
		return ans;
    }
}",1434263514
Mark Qi,MarkQi2002,403,3576,cpp,"class Solution {
public:
    void dfs(vector<vector<int>>& graph, vector<vector<int>>& ancestor, vector<int>& parent, string& s, int node) {
        // Base case
        if (node == -1) return;
        if (!ancestor[s[node] - 'a'].empty()) {
            parent[node] = ancestor[s[node] - 'a'].back();
        }
        ancestor[s[node] - 'a'].push_back(node);
        for (int next : graph[node]) {
            dfs(graph, ancestor, parent, s, next);
        }
        ancestor[s[node] - 'a'].pop_back();
    }

    int count(vector<vector<int>>& graph, vector<int>& result, int node) {
        int total = 1;
        for (int next : graph[node]) {
            total += count(graph, result, next);
        }
        result[node] = total;
        return total;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        // Generate adjacency graph
        int n = parent.size();
        vector<vector<int>> graph(n);
        for (int i = 1; i < n; ++i) {
            graph[parent[i]].push_back(i);
        }

        // Change parents
        vector<vector<int>> ancestor(26);
        dfs(graph, ancestor, parent, s, 0);

        // Regenerate adjacency graph
        graph.clear();
        graph.resize(n);
        for (int i = 1; i < n; ++i) {
            graph[parent[i]].push_back(i);
        }

        // Generate result
        vector<int> result(n, 0);
        count(graph, result, 0);
        return result;
    }
};",1434291246
Mark Qi,MarkQi2002,403,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Breadth first search
        int result = 0;
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int i = 1; i <= k; ++i) {
            for (int j = 0; j < n; ++j) {
                dp[i][j] = dp[i - 1][j] + stayScore[i - 1][j];
                for (int k = 0; k < n; ++k) {
                    if (k != j) dp[i][j] = max(dp[i][j], dp[i - 1][k] + travelScore[k][j]);
                }
            }   
        }
        return *max_element(dp[k].begin(), dp[k].end());
    }
};",1434314246
Mark Qi,MarkQi2002,403,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        // Variable declaration
        int size = word.size(), result = 1;
        for (int i = 1; i < size; ++i) {
            if (word[i] == word[i - 1]) ++result;
        }
        return result;
    }
};",1434260540
wanderlust312,wanderlust312,404,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def dfs(i):
            ind = ord(s[i])-97
            prev = closest_ancestor[ind]
            if prev!=-1:
                parent[i]=prev
            closest_ancestor[ind]=i
            for j in adj[i]:
                dfs(j)
            closest_ancestor[ind]=prev

        def dfs2(i):
            ans[i]=1
            for j in adj[i]:
                dfs2(j)
                ans[i]+=ans[j]
        
        
        n=len(parent)
        adj=[[] for i in range(n)]
        for i in range(1,n):
            adj[parent[i]].append(i)
        
        closest_ancestor = [-1]*26
        dfs(0)

        adj=[[] for i in range(n)]
        for i in range(1,n):
            adj[parent[i]].append(i)

        # print(adj)

        ans=[0]*n
        dfs2(0)
        return ans",1434280881
wanderlust312,wanderlust312,404,3587,java,"class Solution {
    // def helper(city,day,option):
    //         if day==k:
    //             return 0
    //         else:
    //             if dp[city][day][option]==-1:
    //             # stay
    //                 if option==0:
    //                     # 2 choices, stay in ""city"" at day+1 or leave from ""city"" at day+1
    //                     dp[city][day][option] = stayScore[day][city]+max(helper(city,day+1,0),helper(city,day+1,1))
    //                 else:
    //                     # leave
    //                     ans=0
    //                     for j in range(n):
    //                         if j!=city:
    //                             # 2 choices, stay in ""j"" at day+1 or leave from ""j"" at day+1
    //                             ans = max(ans, travelScore[city][j]+max(helper(j,day+1,0),helper(j,day+1,1)))
    //                     dp[city][day][option] = ans
    //             return dp[city][day][option]
                
    //     dp = [[[-1 for k in range(2)] for j in range(k)] for i in range(n)]
    //     res=0
    //     for i in range(n):
    //         res=max(res,helper(i,0,0),helper(i,0,1))

    //     return res
    public int helper(int city,int day,int option,int[][] stayScore, int[][] travelScore, int[][][] dp){
        int n = travelScore.length;
        int k = stayScore.length;
        if(day==k){
            return 0;
        }
        if(dp[city][day][option]==-1){
            if(option==0)
                dp[city][day][option] = stayScore[day][city]+Math.max(helper(city,day+1,0,stayScore,travelScore,dp),helper(city,day+1,1,stayScore,travelScore,dp));
            else{
                int ans=0;
                for(int j=0;j<n;j++){
                    if(j!=city)
                        ans = Math.max(ans, travelScore[city][j]+Math.max(helper(j,day+1,0,stayScore,travelScore,dp),helper(j,day+1,1,stayScore,travelScore,dp)));
                }
                dp[city][day][option] = ans;
            }
        }
        return dp[city][day][option];
    }
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][][] dp = new int[n][k][2];
        for(int i=0;i<n;i++){
            for(int j=0;j<k;j++){
                for(int a=0;a<2;a++){
                    dp[i][j][a]=-1;
                }
            }
        }
        int res=0;
        for(int i=0;i<n;i++){
            res = Math.max(res,Math.max(helper(i,0,0,stayScore,travelScore,dp),helper(i,0,1,stayScore,travelScore,dp)));
        }
        return res;
    }
}",1434314466
wanderlust312,wanderlust312,404,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        i=0
        n=len(word)
        ans=1
        while i<n:
            j=i+1
            while j<n and word[i]==word[j]:
                j+=1
            ans+=(j-i-1)
            i=j
        return ans",1434261334
Pranav,pprranav,405,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[parent[i]].append(i)
            
        a = parent.copy()
        c = {}
        
        def dfs(x):
            if s[x] in c:
                a[x] = c[s[x]]
            prev = c.get(s[x])
            c[s[x]] = x
            for v in g[x]:
                dfs(v)
            if prev is not None:
                c[s[x]] = prev
            else:
                del c[s[x]]
                
        dfs(0)
        
        g = [[] for _ in range(n)]
        for i in range(1, n):
            g[a[i]].append(i)
            
        res = [0]*n
        def dfs2(x):
            sz = 1
            for v in g[x]:
                sz += dfs2(v)
            res[x] = sz
            return sz
            
        dfs2(0)
        return res",1434314537
Pranav,pprranav,405,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = {}
    
        def solve(d, c):
            if d == k:
                return 0
                
            if (d, c) in dp:
                return dp[(d, c)]
                
            m = stayScore[d][c]
            
            for i in range(n):
                v1 = solve(d + 1, i) + travelScore[c][i]
                m = max(m, v1)
                
            v2 = solve(d + 1, c) + stayScore[d][c]
            m = max(m, v2)
            
            dp[(d, c)] = m
            return m
        
        ans = 0
        for i in range(n):
            ans = max(ans, solve(0, i))
        return ans",1434291106
Pranav,pprranav,405,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        ans = set([word])
        for i in range(1, n):
            if word[i] == word[i-1]:
                p = 0
                while i+p < n and word[i+p] == word[i]:
                    s = word[:i] + word[i+p+1:]
                    ans.add(s)
                    p += 1
        return len(ans)",1434260513
Pardhu_2004,Lightning_Mc_Queen,406,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = defaultdict(list)
        for i in range(1, n):
            children[parent[i]].append(i)
        
        ancestor = {}
        newPar = [0] * n
        
        def getNewPar(node):
            i = s[node]
            if i in ancestor:
                newPar[node] = ancestor[i]
            else:
                newPar[node] = parent[node]

            previous = ancestor.get(i)
            ancestor[i] = node

            for child in children[node]:
                getNewPar(child)

            if previous is None:
                del ancestor[i]
            else:
                ancestor[i] = previous

        getNewPar(0)

        newChildren = defaultdict(list)
        for i in range(1, n):
            newChildren[newPar[i]].append(i)

        res = [0] * n

        def solve(node):
            size = 1
            for child in newChildren[node]:
                size += solve(child)
            res[node] = size
            return size

        solve(0)
        return res",1434307093
Pardhu_2004,Lightning_Mc_Queen,406,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def go(day, curi):
            if day == k:
                return 0
            stay, move = stayScore[day][curi]+go(day+1, curi), 0
            for nex in range(n):
                if nex == curi:
                    continue
                move = max(move, travelScore[curi][nex]+go(day+1, nex))
            return max(stay, move)
        res = 0
        for i in range(n):
            res = max(res, go(0, i))
        return res",1434285904
Pardhu_2004,Lightning_Mc_Queen,406,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 0
        last = -1
        cnt = 0
        fl = 0
        for i in word:
            if i == last:
                cnt += 1
                fl = 1
            else:
                res += max(0, cnt-1)
                last = i
                cnt = 1
                fl = 0
        if fl:
            res += max(0, cnt-1)
        return res+1",1434265599
Aashutosh Singh,aashutosh148,407,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); 
        vector<int> ans(n, 0);   
        vector<int> after(n, -1); 
        vector<int> close(26, -1); 
        
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }

        function<void(int)> updateTree = [&](int node) {
            if (close[s[node] - 'a'] != -1) {
                after[node] = close[s[node] - 'a'];
            } else {
                after[node] = parent[node];
            }

            int charIdx = s[node] - 'a';
            int prev = close[charIdx]; 
            close[charIdx] = node;

            for (int child : adj[node]) {
                updateTree(child);
            }

            close[charIdx] = prev;
        };
        updateTree(0);

        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[after[i]].push_back(i);
        }

        function<int(int)> dfs = [&](int node) {
            int size = 1; 
            for (int child : newAdj[node]) {
                size += dfs(child); 
            }
            ans[node] = size; 
            return size;
        };

        dfs(0);

        return ans;
    }
};
",1434281381
Aashutosh Singh,aashutosh148,407,3587,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    
    int dfs(int day, int city, const vector<vector<int>>& stayScore, const vector<vector<int>>& travelScore) {
        
        if (day == 0) {
            int maxScore = stayScore[0][city];  
            for (int prevCity = 0; prevCity < travelScore.size(); ++prevCity) {
                if (prevCity != city) {
                    maxScore = max(maxScore, travelScore[prevCity][city]);
                }
            }
            return maxScore;
        }
        
        if (dp[day][city] != -1) return dp[day][city];
        
        int maxPoints = dfs(day - 1, city, stayScore, travelScore) + stayScore[day][city];
        
        for (int prevCity = 0; prevCity < travelScore.size(); ++prevCity) {
            if (prevCity != city) {
                maxPoints = max(maxPoints, 
                    dfs(day - 1, prevCity, stayScore, travelScore) + travelScore[prevCity][city]);
            }
        }
        
        return dp[day][city] = maxPoints;
    }
    
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        dp = vector<vector<int>>(k, vector<int>(n, -1));
        
        int maxPoints = 0;
        for (int city = 0; city < n; ++city) {
            maxPoints = max(maxPoints, dfs(k - 1, city, stayScore, travelScore));
        }
        return maxPoints;
    }
};",1434314578
Aashutosh Singh,aashutosh148,407,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 0;
        for(int i = 1; i < n; i++){
            if(word[i] == word[i-1])ans++;
        }
        return ans+1;
    }
};",1434263076
Denys Gubar,DenisGubar,408,3576,cpp,"class Solution {
public:
    vector<vector<int>> children;
    vector<int> result;
    string s;
    int N;
    vector<vector<int>> A;
    vector<int> parent;
    void calc(int V)
    {
        A[s[V] - 'a'].push_back(V);
        for (int U : children[V])
            calc(U);
        A[s[V] - 'a'].pop_back();
        if (!A[s[V] - 'a'].empty())
            result[A[s[V] - 'a'].back()] += result[V];
        else if (V > 0)
            result[parent[V]] += result[V];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        N = s.size();
        this->s = s;
        children = vector<vector<int>>(N);
        this->parent = parent;
        result = vector<int>(N, 1);
        A = vector<vector<int>>(26);
        for (int i = 1; i < N; ++i)
            children[parent[i]].push_back(i);
        calc(0);
        return result;
    }
};
",1434321871
Denys Gubar,DenisGubar,408,3587,cpp,"static int F[201][200];
class Solution {
public:
    int maxScore(int N, int K, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int result = 0;
        memset(F, 0, sizeof(F));
        for (int i = 0; i < K; ++i)
            for (int j = 0; j < N; ++j)
                for (int nj = 0; nj < N; ++nj)
                {
                    F[i + 1][nj] = max(F[i + 1][nj], F[i][j] + 
                        (nj == j) * stayScore[i][j] + 
                        (nj != j) * travelScore[j][nj]);
                    result = max(result, F[i + 1][nj]);
                }
        return result;
    }
};
",1434284363
Denys Gubar,DenisGubar,408,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int result = 1;
        word += '$';
        char prev = '^';
        int count = 1;
        for (char c : word)
            if (c == prev)
                ++count;
            else
                result += count - 1, count = 1, prev = c;
        return result;
    }
};
",1434260931
Aryan Garg,aryangarg0729,409,3576,cpp,"class Solution {
public:
    vector<int>par;
    void helper(vector<vector<int>>&adj,string&s,vector<int>&charat,int parent,int node){
        if(charat[s[node]-'a']!=-1)par[node]=charat[s[node]-'a'];
        int x = charat[s[node]-'a'];
        charat[s[node]-'a']=node;
        for(auto i:adj[node]){
            if(i!=parent)helper(adj,s,charat,node,i);
        }
        charat[s[node]-'a']=x;
    }
    int helper(vector<vector<int>>&adj,int parent,int node,vector<int>&ans){
        int len = 1;
        for(auto i:adj[node]){
            if(i!=parent){len+=helper(adj,node,i,ans);}
        }
        return ans[node] = len;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<vector<int>>adj(parent.size());
        for(int i = 1;i<parent.size();i++){
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        par = parent;
        vector<int>charat(26,-1);
        
        helper(adj,s,charat,-1,0);
        vector<vector<int>>adj2(parent.size());
        for(int i = 1;i<par.size();i++){
            adj2[i].push_back(par[i]);
            adj2[par[i]].push_back(i);
        }
        // for(auto i:par){
        //     cout<<i<<"" "";
        // }
        // cout<<endl;
        vector<int>ans(parent.size());
        helper(adj2,-1,0,ans);
        return ans;
    }
};",1434305074
Aryan Garg,aryangarg0729,409,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int helper(int n,int k,int city, int day,vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
        if(day==k)return 0;
        if(dp[city][day]!=-1)return dp[city][day];
        int ans = 0;
        for(int i = 0;i<n;i++){
            ans = max(helper(n,k,i,day+1,stayScore,travelScore)+(i==city?stayScore[day][i]:travelScore[city][i]),ans);
        }
        return dp[city][day] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp,-1,sizeof(dp));
        int ans = 0;
        for(int i = 0;i<n;i++){
            ans = max(ans,helper(n,k,i,0,stayScore,travelScore));
        }
        return ans;
    }
};",1434321882
Aryan Garg,aryangarg0729,409,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count = 1;
        int ans = 1;
        for(int i = 1;i<word.size();i++){
            if(word[i]==word[i-1])count++;
            else{
                ans+=count-1;
                count=1;
            }
        }
        ans+=count-1;
        return ans;
    }
};",1434263463
lemondead1,lemondead1,410,3576,java,"import java.util.*;
import java.util.stream.IntStream;

class Solution {
  public int[] findSubtreeSizes(int[] parent, String s) {
    var children = IntStream.range(0, parent.length).mapToObj(_ -> new ArrayList<Integer>())
                            .toList();

    for (int i = 1; i < parent.length; i++) {
      children.get(parent[i]).add(i);
    }

    List<Change> changes = new ArrayList<>();

    collectChanges(0, children, new HashMap<>(), changes, s);

    for (var change : changes) {
      children.get(parent[change.x()]).remove((Object) change.x());
      parent[change.x()] = change.y();
      children.get(change.y()).add(change.x());
    }

    var sizes = new int[parent.length];

    dfs(0, children, sizes);

    return sizes;
  }

  record Change(int x, int y) { }

  private void collectChanges(int root,
                              List<? extends Collection<Integer>> children,
                              Map<Character, Integer> map,
                              List<Change> changes,
                              String s) {
    if (map.containsKey(s.charAt(root))) {
      changes.add(new Change(root, map.get(s.charAt(root))));
    }

    var old = map.put(s.charAt(root), root);

    for (int child : children.get(root)) {
      collectChanges(child, children, map, changes, s);
    }

    if (old == null) {
      map.remove(s.charAt(root));
    } else {
      map.put(s.charAt(root), old);
    }
  }

  private void dfs(int root, List<? extends List<Integer>> children, int[] sizes) {
    sizes[root] = 1;
    for (int child : children.get(root)) {
      dfs(child, children, sizes);
      sizes[root] += sizes[child];
    }
  }
}",1434307293
lemondead1,lemondead1,410,3587,java,"import java.util.Arrays;

class Solution {
  public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
    var dp = new int[k + 1][n];

    for (int i = 0; i < k; i++) {
      for (int j = 0; j < n; j++) {
        dp[i + 1][j] = Math.max(dp[i + 1][j], stayScore[i][j] + dp[i][j]);

        for (int l = 0; l < n; l++) {
          dp[i + 1][l] = Math.max(dp[i + 1][l], dp[i][j] + travelScore[j][l]);
        }
      }
    }

    return Arrays.stream(dp[k]).max().orElse(0);
  }

  public static void main(String[] args) {
    System.out.println(new Solution().maxScore(3,
                                               2,
                                               new int[][] { { 3, 4, 2 }, { 2, 1, 2 } },
                                               new int[][] { { 0, 2, 1 }, { 2, 0, 4 }, { 3, 2, 0 } }));
  }
}",1434321936
lemondead1,lemondead1,410,3617,java,"class Solution {
  public int possibleStringCount(String word) {
    int result = 1;

    for (int i = 1; i < word.length(); i++) {
      if (word.charAt(i) == word.charAt(i - 1)) {
        result++;
      }
    }

    return result;
  }

  public static void main(String[] args) {
    System.out.println(new Solution().possibleStringCount(""abbcccc""));
  }
}",1434275263
Vishal Patil,incognito123,411,3576,cpp,"class Solution {
public:
    vector<int> grph[100001];
    int arr[100001][26];
    int sz[100001];
    void dfs(int i, int par, vector<int>& parent,string& s){
        arr[i][s[i]-'a']=i;
        for(auto p:grph[i]){
            if(p==par) continue;
            for(int j=0;j<26;j++) arr[p][j]=arr[i][j];
            if(arr[p][s[p]-'a']!=-1){
                parent[p]=arr[p][s[p]-'a'];
            }
            dfs(p,i,parent,s);
        }
    }
    
    void dfs1(int i,int par){
        sz[i]=1;
         for(auto p:grph[i]){
            if(p==par) continue;
            dfs1(p,i);
            sz[i]+=sz[p];
        }
        return;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        for(int i=0;i<n;i++) for(int j=0;j<26;j++) arr[i][j]=-1;
        for(int i=0;i<n;i++) grph[i].clear(),sz[i]=0;
        for(int i=1;i<n;i++){
            grph[i].push_back(parent[i]);
            grph[parent[i]].push_back(i);
        }
        dfs(0,-1,parent,s);
        for(int i=0;i<n;i++) grph[i].clear();
        for(int i=1;i<n;i++){
            grph[i].push_back(parent[i]);
            grph[parent[i]].push_back(i);
        }
        dfs1(0,-1);
        vector<int> ans;
        for(int i=0;i<n;i++) ans.push_back(sz[i]);
        return ans;
    }
};",1434287835
Vishal Patil,incognito123,411,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int rec(int curr, int i,int n,int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
        if(i==k) return 0;
        if(dp[curr][i]!=-1) return dp[curr][i];
        int ans=stayScore[i][curr]+rec(curr,i+1,n,k,stayScore,travelScore);
        for(int j=0;j<n;j++){
            int ans1=travelScore[curr][j]+rec(j,i+1,n,k,stayScore,travelScore);
            ans=max(ans,ans1);
        }
        return dp[curr][i]=ans;
    }
    
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans=0;
        for(int i=0;i<n;i++) for(int j=0;j<k;j++) dp[i][j]=-1;
        for(int i=0;i<n;i++){
            int ans1=rec(i,0,n,k,stayScore,travelScore);
            ans=max(ans,ans1);
        }
        return ans;
    }
};",1434314790
Vishal Patil,incognito123,411,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n=word.size();
        int ans=1;
        for(int i=0;i<n;i++){
            int j=i+1;
            int cntr=0;
            while(j<n&&word[j]==word[i]){
                cntr+=1;
                j+=1;
            }
            ans+=cntr;
            i=j-1;
        }
        return ans;
    }
};",1434265143
Ahbar,Ahbar,413,3576,cpp,"class Solution {
public:
    void dfs(int x, char c, unordered_map<char, int>& stk, unordered_map<int, vector<vector<int>>>& g, vector<int>& p) {
        if (stk.find(c) != stk.end() && stk[c] != -1) p[x] = stk[c];
        int temp = (stk.find(c) == stk.end()) ? -1 : stk[c];
        stk[c] = x;
        for (auto nb: g[x]) {
            int child = nb[0]; 
            char color = nb[1];
            // stk[color] = child;
            dfs(child, color, stk, g, p);
            // stk[color] = temp;
        } 
        stk[c] = temp;
    }

    int count_dfs(int x, unordered_map<int, vector<vector<int>>>& g, vector<int>& ans) {
        int count = 1; //itself
        for (auto child: g[x]) {
            count += count_dfs(child[0], g, ans);
        }
        return ans[x] = count;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        unordered_map<int, vector<vector<int>>> g;
        for (int i=0; i < parent.size(); i++) {
            g[parent[i]].push_back({i, s[i]});
        }
        auto stk = unordered_map<char, int>();
        dfs(0, s[0], stk, g, parent);
        vector<int> ans(s.size(), 0);
        // for (auto x: parent) cout << x << "" "";
        g.clear();
        for (int i=0; i < parent.size(); i++) {
            g[parent[i]].push_back({i, s[i]});
        }
        count_dfs(0, g, ans);
        
        return ans;
    }
};",1434322018
Ahbar,Ahbar,413,3587,cpp,"class Solution {
public:
    int memo[202][202];
    int rec(int city, int day, int k, int n, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        if (day == k) return 0;
        if (memo[city + 1][day + 1] != -1) return memo[city + 1][day + 1];
        
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, rec(i, day + 1, k, n, ss, ts) + (day == -1 ? 0 : (i == city ? ss[day][city] : ts[city][i]))); 
        } 

        return memo[city + 1][day + 1]= ans;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(memo, -1, sizeof(memo));
        return rec(-1, -1, k, n, stayScore, travelScore); 
    }
};",1434281891
Ahbar,Ahbar,413,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 1;
        for (int i= 1; i < word.size(); i++) {
            if (word[i] == word[i - 1]) cnt++;
        }

        return cnt;
    }
};",1434261865
Mohit Sharma,mohit7153,414,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for(int i=1;i<n;i++) {
            adj[parent[i]].push_back(i);
        }
        vector<int> ans(n);
        vector<stack<int>> nodes(26);
        dfs(0,adj,nodes,parent,s);
        vector<vector<int>> nadj(n);
        for(int i=1;i<n;i++) {
            nadj[parent[i]].push_back(i);
        }
        dfs(0,nadj,ans);
        return ans;
    }
    
    int dfs(int x, vector<vector<int>>& adj, vector<int>& ans) {
        int size = 1;
        for(int i:adj[x]) {
            size += dfs(i,adj,ans);
        }
        ans[x] = size;
        return size;
    }
    
    void dfs(int x, vector<vector<int>>& adj, vector<stack<int>>& nodes, vector<int>& parent, string& s) {
        int ch = s[x] - 'a';
        if(!nodes[ch].empty()) {
            parent[x] = nodes[ch].top();
        }
        nodes[ch].push(x);
        for(int i:adj[x]) {
            dfs(i,adj,nodes,parent,s);
        }
        nodes[ch].pop();
    }
};",1434307475
Mohit Sharma,mohit7153,414,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> ms(n, vector<int>(k+1, 0));
        for(int j=k-1;j>=0;j--) {
            for(int i=0;i<n;i++) {
                ms[i][j] = stayScore[j][i] + ms[i][j+1];
                for(int dest=0;dest<n;dest++) {
                    ms[i][j] = max(ms[i][j], travelScore[i][dest] + ms[dest][j+1]);
                }
            }
        }
        int ans=0;
        for(int i=0;i<n;i++) {
             ans = max(ans, ms[i][0]);
        }
        return ans;
    }
};",1434322021
Mohit Sharma,mohit7153,414,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int cnt = 1;
        int ans = 1;
        for(int i=1;i<n;i++) {
            if(word[i]!=word[i-1]) {
                if(cnt>1) {
                    ans += cnt-1;    
                }
                cnt = 1;
            } else {
                cnt++;
            }
        }
        if(cnt>1){
            ans += cnt-1;
        }
        return ans;
    }
};",1434271186
Narathip Hongthawee,opalXDnaja123,418,3576,cpp,"class Solution {
public:
    
    int sz[100005];
    vector<int> edge[100005];
    set<int> edge2[100005];
    stack<int> stk[26];
    
    void dfs(int x, int p, string &s) {
        if (!stk[s[x] - 'a'].empty()) {
            edge2[p].erase(x);
            edge2[stk[s[x] - 'a'].top()].insert(x);
        }
        stk[s[x] - 'a'].push(x);
        for (auto e : edge[x]) {
            int tox = e;
            if (tox == p) {
                continue;
            }
            dfs(tox, x, s);
        }
        stk[s[x] - 'a'].pop();
    }
    
    void dfs2(int x) {
        sz[x] = 1;
        for (auto e : edge2[x]) {
            int tox = e;
            dfs2(tox);
            sz[x] += sz[tox];
        }
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        int idx = 1;
        for (auto e : parent) {
            if (e == -1) {
                continue;
            }
            edge[e].push_back(idx);
            edge2[e].insert(idx++);
        }
        dfs(0, -1, s);
        dfs2(0);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            ans.push_back(sz[i]);
        }
        return ans;
    }
};",1434315210
Narathip Hongthawee,opalXDnaja123,418,3587,cpp,"class Solution {
public:
    
    int memo[205][205];
    bool visited[205][205];
    
    int solve(int x, int p, int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        if (p == k) {
            return 0;
        }
        if (visited[x][p]) {
            return memo[x][p];
        }
        visited[x][p] = true;
        int most = 0;
        for (int i = 0; i < n; i++) {
            most = max(most, solve(i, p + 1, n, k, stayScore, travelScore) + (i == x ? stayScore[p][x] : travelScore[x][i]));
        }
        return memo[x][p] = most;
    }
    
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, solve(i, 0, n, k, stayScore, travelScore));
        }
        return ans;
    }
};",1434290897
Narathip Hongthawee,opalXDnaja123,418,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int sum = 1;
        for (int i = 0; i < n; i++) {
            int cur = 1;
            while (i < n - 1 && word[i] == word[i + 1]) {
                cur++, i++;
            }
            sum += cur - 1;
        }
        return sum;
    }
};",1434261266
Ruoqi Huang,ruoqihuang,420,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        kids = [[] for _ in range(len(parent))]
        for i, p in enumerate(parent):
            if p == -1:
                continue
            kids[p].append(i)

        d = defaultdict(list)
        newp = list(parent)
        def f(n):
            if len(d.get(s[n], [])) > 0:
                newp[n] = d[s[n]][-1]
            d[s[n]].append(n)
            for k in kids[n]:
                f(k)
            d[s[n]].pop()
        f(0)

        print(newp)
        newkids = [[] for _ in range(len(parent))]
        for i, p in enumerate(newp):
            if p == -1:
                continue
            newkids[p].append(i)


        ans = [1 for _ in range(len(parent))]
        def size(n):
            if len(newkids[n]) == 0:
                return 1
            ans[n] =sum(size(k) for k in newkids[n]) +1
            return ans[n]
        size(0)
        return ans
        ",1434299311
Ruoqi Huang,ruoqihuang,420,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0 for _ in range(n)] for _ in range(k + 1)]
        for i in range(1, k + 1):
            for x in range(n):
                m = dp[i - 1][x] + stayScore[i-1][x]
                for y in range(n):
                    m = max(m, dp[i - 1][y] + travelScore[y][x])
                dp[i][x] = m

        return max(dp[-1])",1434322429
Ruoqi Huang,ruoqihuang,420,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        p = None
        r = 0
        for i in word:
            if p is None or i != p:
                r += 1
                p = i
        return len(word) - r + 1",1434264215
Tejas,TejasChalke,421,3576,java,"class Solution {
    List<Integer>[] adj;
    int[] res;
    int[] ans;
    Map<Character, Stack<Integer>> map = new HashMap<>();
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        adj = new ArrayList[n];
        for (int i=0; i<n; i++) adj[i] = new ArrayList<>();
        for (int i=1; i<n; i++) adj[parent[i]].add(i);

        res = parent.clone();
        dfs(0, s.toCharArray());

        adj = new ArrayList[n];
        for (int i=0; i<n; i++) adj[i] = new ArrayList<>();
        for (int i=1; i<n; i++) adj[res[i]].add(i);

        ans = new int[n];
        getSize(0);
        return ans;
    }

    void dfs(int curr, char[] s) {
        if (map.get(s[curr]) != null) {
            if (!map.get(s[curr]).isEmpty()) res[curr] = map.get(s[curr]).peek();
        }
        else map.put(s[curr], new Stack<>());
        map.get(s[curr]).add(curr);
        for (int next: adj[curr]) {
            dfs(next, s);
        }
        map.get(s[curr]).pop();
    }

    int getSize(int curr) {
        int size = 1;
        for (int next: adj[curr]) {
            size += getSize(next);
        }
        ans[curr] = size;
        return size;
    }
}",1434290868
Tejas,TejasChalke,421,3587,java,"class Solution {
    int n;
    int[][] stayScore, travelScore;
    Integer[][] dp;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        n = travelScore.length;
        this.stayScore = stayScore;
        this.travelScore = travelScore;

        int ans = 0;
        dp = new Integer[k][n];
        for (int i=0; i<n; i++) {
            ans = Math.max(ans, solve(0, k, i));
        }
        return ans;
    }

    int solve(int currDay, int k, int currCity) {
        if (currDay == k) return 0;
        if (dp[currDay][currCity] != null) return dp[currDay][currCity];

        // move to a new city
        int dest = 0, move = 0;
        while (dest < travelScore.length) {
            if (dest == currCity) {
                dest++;
                continue;
            }
            move = Math.max(move, solve(currDay + 1, k, dest) + travelScore[currCity][dest]);
            dest += 1;
        }
        
        // stay in the city
        int stay = solve(currDay + 1, k, currCity) + stayScore[currDay][currCity];

        return dp[currDay][currCity] = Math.max(stay, move);
    }
}",1434322872
Tejas,TejasChalke,421,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        char prev = '.';
        word += '#';
        int ans = 1, cnt = 0;
        for (char c: word.toCharArray()) {
            if (c == prev) cnt++;
            else {
                if (cnt > 0) ans += cnt - 1;
                cnt = 1;
                prev = c;
            }
        }
        return ans;
    }
}",1434269467
NAVEEN KUMAR S,hornedfoe,423,3576,java,"class Solution{
    Set<Integer>[] arr , crr;
    char[] s;
    int[] brr , ret;
    public int[] findSubtreeSizes(int[] parent , String s){
        int n = parent.length;
        this.s = s.toCharArray();
        arr = new HashSet[n];
        crr = new HashSet[n];
        brr = new int[26];
        ret = new int[n];
        Arrays.fill(brr , -1);
        Arrays.fill(ret , 1);
        for(int i = 0 ; i < n ; i++){
            arr[i] = new HashSet<>();
            crr[i] = new HashSet<>();
        }
        for(int i = 1 ; i < n ; i++){
            arr[parent[i]].add(i);
            crr[parent[i]].add(i);
        }
        modify(0 , -1);
        finder(0 , -1);
        System.out.println(Arrays.toString(crr));
        return ret;
    }
    private void modify(int x , int p){
        for(int i : arr[x]) if(x != p){
            int prev = brr[s[x] - 'a'];
            brr[s[x] - 'a'] = x;
            modify(i , x);
            brr[s[x] - 'a'] = prev;
        }
        if(brr[s[x] - 'a'] != -1 && brr[s[x] - 'a'] != p){
            crr[brr[s[x] - 'a']].add(x);
            crr[p].remove(x);
        }
    }
    private int finder(int x , int p){
        for(int i : crr[x]) if(x != p){
            ret[x] += finder(i , x);
        }
        return ret[x];
    }
}",1434300274
NAVEEN KUMAR S,hornedfoe,423,3587,java,"class Solution{
    int n , arr[][] , brr[][];
    Integer[][] dp;
    public int maxScore(int n , int k , int[][] stayScore , int[][] travelScore){
        arr = stayScore;
        brr = travelScore;
        this.n = n;
        dp = new Integer[n][k + 1];
        int ret = 0;
        for(int i = 0 ; i < n ; i++) ret = Math.max(ret , finder(i , k , 0));
        return ret;
    }
    private int finder(int x , int k , int v){
        if(k == 0) return 0;
        if(dp[x][k] != null) return dp[x][k];
        int ret = 0;
        for(int i = 0 ; i < n ; i++) if(x == i){
            ret = Math.max(ret , finder(x , k - 1 , v + 1) + arr[v][x]);
        }else{
            ret = Math.max(ret , finder(i , k - 1 , v + 1) + brr[x][i]);
        }
        return dp[x][k] = ret;
    }
}",1434315805
NAVEEN KUMAR S,hornedfoe,423,3617,java,"class Solution{
    public int possibleStringCount(String word){
        int ret = 1;
        char prev = word.charAt(0);
        for(int i = 1 ; i < word.length() ; i++){
            char c = word.charAt(i);
            if(c == prev) ret += 1;
            prev = c;
        }
        return ret;
    }
}",1434262502
Ved Prakash,Navodayan,424,3576,cpp,"class Solution {
public:
    vector<int>ans;
    vector<vector<int>>g;
    int dfs(int node, int par){
        int sum = 1;
        for(auto child : g[node]){
            if(child == par)continue;
            sum += dfs(child,node);
        }
        ans[node] = sum;
        return sum;
    }
    vector<int>parentt;
    void dfs1(int node, int par, vector<int>v, string &s){
        int ch = s[node]-'a';
        // cout<<parentt.size()<<endl;
        if(v[ch] == -1){
            parentt[node] = par;
        }else{
            parentt[node] = v[ch];
        }
        v[ch] = node;

        for(auto child : g[node]){
            if(child == par)continue;
            dfs1(child,node,v,s);
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        g = vector<vector<int>>(n);
        for(int i=1;i<n;i++){
            g[i].push_back(parent[i]);
            g[parent[i]].push_back(i);
        }
        vector<int>temp(26,-1);
        parentt =ans = vector<int>(n);
        dfs1(0,-1,temp,s);
        g = vector<vector<int>>(n);
        for(int i=0;i<n;i++){
            cout<<parentt[i]<<"" "";
        }cout<<endl;
        for(int i=1;i<n;i++){
            g[i].push_back(parentt[i]);
            g[parentt[i]].push_back(i);
        }
        dfs(0,-1);
        return ans;
    }
};",1434295144
Ved Prakash,Navodayan,424,3587,cpp,"class Solution {
public:
    int dp[205][205];
    int find(int node, int days,int n, int k, vector<vector<int>>&stayScore, vector<vector<int>>& travels){
        if(days >= k){
            return 0;
        }
        if(dp[node][days] != -1) return dp[node][days];
        int ans = 0;
        for(int i=0;i<n;i++){
            if(i == node){
                ans = max(ans, find(i,days+1,n,k,stayScore,travels)+stayScore[days][i]);
            }else{
                ans = max(ans, find(i,days+1,n,k,stayScore,travels)+travels[node][i]);
            }
        }

        return dp[node][days] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {

        int ans = 0;
        memset(dp,-1,sizeof(dp));
        for(int i=0;i<n;i++){
            ans = max(ans, find(i,0,n,k,stayScore,travelScore));
        }
        return ans;
    }
};",1434315843
Ved Prakash,Navodayan,424,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 0;
        int n = word.size();
        for(int i=1;i<n;i++){
            if(word[i] == word[i-1])ans++;
        }
        return ans+1;
    }
};",1434262190
Arjun Grover,Code-O-Maniac,427,3576,cpp,"class Solution {
    void gogo(vector<vector<int>>& graph, vector<int>& parent, vector<int>& newParent, vector<int>& lastOccurance, string &s, int i = 0) {
        int last = lastOccurance[s[i] - 'a'];
        
        if(last != -1) newParent[i] = last;
        lastOccurance[s[i] - 'a'] = i;
        
        for(auto x:graph[i]) {
            if(x == parent[i]) continue;
            gogo(graph, parent, newParent, lastOccurance, s, x);
        }
        
        lastOccurance[s[i] - 'a'] = last;
    }
    
    int gogo2(vector<vector<int>>& graph, vector<int>& subSize, vector<int>& parent, int i = 0) {
        int count = 1;
        for(auto x:graph[i]) {
            if(x == parent[i]) continue;
            
            count += gogo2(graph, subSize, parent, x);
        }
        
        subSize[i] = count;
        return count;
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        
        vector<vector<int>> graph(n);
        for(int i = 1; i < n; i++) {
            graph[i].push_back(parent[i]);
            graph[parent[i]].push_back(i);
        }
        
        vector<int> newParent = parent;
        vector<int> lastOccurance(26, -1);
        
        gogo(graph, parent, newParent, lastOccurance, s);
        
        graph = vector<vector<int>>(n);
        for(int i = 1; i < n; i++) {
            graph[i].push_back(newParent[i]);
            graph[newParent[i]].push_back(i);
        }
        
        vector<int> subSize(n);
        gogo2(graph, subSize, newParent);
        
        return subSize;
    }
};",1434305358
Arjun Grover,Code-O-Maniac,427,3587,cpp,"class Solution {
    int dp[205][205];
    
    int gogo(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, int curr, int day = 0) {
        if(day == k)
            return 0;
        
        if(dp[curr][day] != -1) return dp[curr][day];
        
        int ans = 0;
        for(int i = 0; i < n; i++) {
            if(i == curr) {
                ans = max(ans, stayScore[day][curr] + gogo(n, k, stayScore, travelScore, curr, day + 1));
            } else {
                ans = max(ans, travelScore[curr][i] + gogo(n, k, stayScore, travelScore, i, day + 1));
            }
        }
        
        return dp[curr][day] = ans;
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp, -1, sizeof(dp));
        
        int ans = 0;
        for(int i = 0; i < n; i++)
            ans = max(ans, gogo(n, k, stayScore, travelScore, i));
        
        return ans;
    }
};",1434316104
Arjun Grover,Code-O-Maniac,427,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> freq(26);
        
        int ans = 0, last = word[0];
        for(auto x:word) {
            if(x == last) {
                ans += 1;
            } else {
                last = x;
            }
        }
        
        return ans;
    }
};",1434262097
Amit,amitpanwar02705,428,3576,cpp,"class Solution {
public:
    int helper(int cur, vector<vector<int>>& adj, vector<int>& ans) {
        int sz = 1;
        for (int it : adj[cur]) {
            sz += helper(it, adj, ans);
        }
        ans[cur] = sz;
        return sz;
    }

    vector<vector<int>> build(int n, const vector<int>& parent) {
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; i++) {
            int p = parent[i];
            if (p != -1) {
                adj[p].push_back(i);
            }
        }
        return adj;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string& s) {
        int n = parent.size();
        vector<vector<int>> adj(n), old = build(n, parent);
        unordered_map<char, vector<int>> temp;

        function<void(int)> hp = [&](int node) {
            char c = s[node];
            int newParent = parent[node];
            if (temp.count(c) && !temp[c].empty()) {
                newParent = temp[c].back();
            }
            if (newParent != -1) {
                adj[newParent].push_back(node);
            }
            temp[c].push_back(node);
            for (int child : old[node]) {
                hp(child);
            }
            temp[c].pop_back();
        };

        hp(0);

        vector<int> ans(n);
        helper(0, adj, ans);
        return ans;
    }
};",1434305461
Amit,amitpanwar02705,428,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int helper(int d, int i, int k, vector<vector<int>>& stay, vector<vector<int>>& travel, vector<vector<int>>& dp) {
        if (d == k) return 0;
        if (dp[d][i] != -1) return dp[d][i];
        int ans = stay[d][i] + helper(d + 1, i, k, stay, travel, dp);
        
        for (int ni = 0; ni < travel[i].size(); ++ni) {
            if (ni != i) {
                int temp = travel[i][ni] + helper(d + 1, ni, k, stay, travel, dp);
                ans = max(ans, temp);
            }
        }

        return dp[d][i] = ans;
    }

    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<vector<int>> dp(k, vector<int>(n, -1));
        int ans = 0;
        
        for (int i = 0; i < n; ++i) {
            ans = max(ans, helper(0, i, k, stay, travel, dp));
        }        
        return ans;
    }
};
",1434323383
Amit,amitpanwar02705,428,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 1;
        for(int i = n-1; i >= 1 ;i--){
            if(word[i] == word[i-1]) ans ++;
        }
        return ans;
    }
};",1434264039
Krishnakumar R,kk_r_17,429,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        g = defaultdict(set)
        
        for i,v in enumerate(parent):
            if v == -1:
                continue
            g[parent[i]].add(i)
        # print(""start"", g)
        gn = defaultdict(set)
        def helper(ancestors, node):
            itrs = set(list(g[node])[:])
            for child in itrs:
                currVal = s[child]
                if currVal in ancestors:
                    toAdd = ancestors[currVal]
                    # print(node, toAdd, child)
                    # g[node].remove(child)
                    gn[toAdd].add(child)
                else:
                    gn[node].add(child)
                prev = ancestors[currVal] if currVal in ancestors else -1
                ancestors[currVal] = child
                helper(ancestors, child)
                if prev == -1:
                    del ancestors[currVal]
                else:
                    ancestors[currVal] = prev
        
        start = {s[0]: 0}
        helper(start, 0)
        # print(""after"",gn)
        ret = []
        size = [0]*n
        
        def ssz(node):
            curr = 1
            for nei in gn[node]:
                curr += ssz(nei)
            size[node] = curr
            return curr
        ssz(0)
        return size
        ",1434323465
Krishnakumar R,kk_r_17,429,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @lru_cache(None)
        def dp(day, curr):
            if day == k:
                return 0
            stay = stayScore[day][curr] + dp(day+1, curr)
            travel = max(travelScore[curr][i] + dp(day+1, i) for i in range(n))
            return max(stay, travel)
        
        return max(dp(0, i) for i in range(n))",1434275801
Krishnakumar R,kk_r_17,429,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ret = 1
        curr = word[0]
        cnt = 0
        for c in word:
            if c == curr:
                cnt += 1
            else:
                ret += cnt - 1
                cnt = 1
                curr = c
        ret += cnt - 1
        return ret",1434261267
AncientDev,AncientDev,430,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        c = defaultdict(list)
        for i in range(n): c[parent[i]].append(i)
        root = c[-1][0]
        par = {}
        
        def rec(root):
            nonlocal par
            curr = s[root]
            f = False
            if curr in par: f = True
            if f: parent[root] = par[curr]
            if f: x = par[curr]
            par[curr] = root
            for ne in c[root]: rec(ne)
            if f: par[curr] = x
            else: del par[curr]
        rec(root)

        res = [0]*n
        c = defaultdict(list)
        for i in range(n): c[parent[i]].append(i)
        def rec(root):
            nonlocal res
            tot = 1
            for ne in c[root]: tot+=rec(ne)
            res[root] = tot
            return tot
        rec(c[-1][0])
        return res",1434323584
AncientDev,AncientDev,430,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @cache
        def rec(x, k):
            if k < 0: return 0

            res = 0
            for i in range(n):
                if i==x: res = max(res, stayScore[k][i] + rec(x, k-1))
                else: res = max(res, travelScore[i][x] + rec(i, k-1))
            return res

        return max(rec(i, k-1) for i in range(n))",1434298013
AncientDev,AncientDev,430,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        tot = 1
        cnt = 1
        for i in range(1, len(word)):
            if word[i]==word[i-1]: cnt += 1
            else:
                if cnt > 1: tot += (cnt-1)
                cnt = 1
        if cnt > 1: tot += (cnt-1)
        return tot",1434269349
Karthik Sai,mrwickpmf,431,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        return rt(parent,s)
    
def rt(p,s):

    x={}
    for i in range(0,len(p)):
        if(p[i]==-1):
            continue
        if(p[i] not in x):
            x[p[i]]=[i]
        else:
            x[p[i]].append(i)
    k=[-1]*len(p)
    vp=[-1]*26

    dfs(0,x,p,s,k,vp)
    z=[1]*len(p)
    x={}
    p=k
    for i in range(0,len(p)):
        if(p[i]==-1):
            continue
        if(p[i] not in x):
            x[p[i]]=[i]
        else:
            x[p[i]].append(i)
    dfs1(0,z,x)
    return z
def dfs1(i,z,x):
    if(i in x):
        for j in x[i]:
           z[i]+= dfs1(j,z,x)
    return z[i]
def dfs(i,x,n,s,n1,vp):
    if(vp[ord(s[i])-97]!=-1):
        n1[i]=vp[ord(s[i])-97]
    else:
        n1[i]=n[i]
    p1=vp[ord(s[i])-97]
    vp[ord(s[i])-97]=i
    if(i in x):
        for j in x[i]:
            dfs(j,x,n,s,n1,vp)
    vp[ord(s[i]) - 97]=p1
",1434306287
Karthik Sai,mrwickpmf,431,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, s: List[List[int]], t: List[List[int]]) -> int:
        return rt(n,k,s,t)
    
def rt(n,k,s,p):
    f={}
    c=0
    for i in range(0,n):
        c=max(c,dfs(i,k,s,p,n,0,f))
    return c
def dfs(i,k,s,p,n,r1,f):
    if((i,r1) in f):
        return f[i,r1]
    if(k==r1):
        return 0
    else:

        c1=s[r1][i]+dfs(i,k,s,p,n,r1+1,f)
        c2=0
        for j in range(0,n):
            if(i!=j):
                c2=max(c2,p[i][j]+dfs(j,k,s,p,n,r1+1,f))
        f[i, r1] = max(c1,c2)
        return  f[i,r1]",1434323714
Karthik Sai,mrwickpmf,431,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        return rt(word)
def rt(n):
    s=[]
    prev=-1
    c=0
    for i in n:
        if(prev==-1):
            c=c+1
            prev=i
        else:
            if(prev==i):
                c=c+1
            else:
                s.append([prev,c])
                c=1
                prev=i
    s.append([prev,c])
    k=1
    for i in range(0,len(s)):
        if(s[i][1]>1):
            k=k+s[i][1]-1
    return k",1434273720
Allw,allw,432,3576,cpp,"class Solution {
public:
    void dfs(int pos, vector<vector<int>>& g, string& s, 
             vector<int>& parent, map<char, int>& fmap) {
        int prev = -1;
        if (fmap.find(s[pos]) != fmap.end()) {
            prev = fmap[s[pos]];
            parent[pos] = fmap[s[pos]];
        }
        
        fmap[s[pos]] = pos;

        for (int i = 0; i < g[pos].size(); ++i) {
            dfs(g[pos][i], g, s, parent, fmap);
        }

        fmap.erase(s[pos]);

        if (prev != -1) {
            fmap[s[pos]] = prev;
        }
    }

    int dfs2(int pos, vector<vector<int>>& g, vector<int>& res) {
        int cur = 1;
        for (int i = 0; i < g[pos].size(); ++i) {
            cur += dfs2(g[pos][i], g, res);
        }

        res[pos] = cur;
        return res[pos];
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<vector<int>> g(parent.size(), vector<int>());
        for (int i = 1; i < parent.size(); ++i) {
            g[parent[i]].push_back(i);
        }
        
        map<char, int> fmap;
        
        vector<int> res(parent.size(), 0);
        dfs(0, g, s, parent, fmap);

        vector<vector<int>> new_g(parent.size(), vector<int>());
        for (int i = 1; i < parent.size(); ++i) {
            new_g[parent[i]].push_back(i);
        }
        
        dfs2(0, new_g, res);
        
        
        return res;
    }
};",1434306638
Allw,allw,432,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // dp[i][j] -> maximum score that after i days of travel end in j city
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        for (int i = 0; i < k; ++i) { // ? -1
            // stay in this city
            for (int j = 0; j < n; ++j) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + stayScore[i][j]);
            }

            // move
            for (int from = 0; from < n; ++from) {
                for (int to = 0; to < n; ++to) {
                    dp[i+1][to] = max(dp[i+1][to], dp[i][from] + travelScore[from][to]);
                }
            }
        }

        if (false) {
        for (int i = 0; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                std::cout << dp[i][j] << ' ';
            }
            std::cout << '\n';
        }
        }

        int res = 0;
        for (int i = 0; i < n; ++i) {
            res = max(res, dp.back()[i]);
        }

        return res;
    }
};",1434323741
Allw,allw,432,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        for (int i = 1; i < word.size(); ++i) {
            if (word[i] == word[i-1]) res++;
        }
        return res;
    }
};",1434265855
Makoto2020,Makoto2020,433,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        const int N = s.size();
        vector<vector<int>> Es(N);  int root = -1;
        for (int i = 0; i < N; ++i) {
            if (parent[i] >= 0) Es[parent[i]].emplace_back(i);
            else root = i;
        }
        {
            vector<int> alphabetToNode(26, -1);
            change(Es, s, root, parent, alphabetToNode);
        }
        Es = vector<vector<int>>(N);
        for (int i = 0; i < N; ++i) {
            if (parent[i] >= 0) Es[parent[i]].emplace_back(i);
        }
        vector<int> ans(N);
        dfsCnt(Es, root, ans);
        return ans;
    }

    void change(const vector<vector<int>> &Es, const string &s, const int cur, vector<int> &parent, const vector<int> &alphabetToNode) {
        const char curC = s[cur] - 'a';
        if (alphabetToNode[curC] >= 0) {
            parent[cur] = alphabetToNode[curC];
        }
        vector<int> newAlphabetToNode = alphabetToNode;
        newAlphabetToNode[curC] = cur;
        for (const int nex : Es[cur]) {
            change(Es, s, nex, parent, newAlphabetToNode);
        }
    }

    void dfsCnt(const vector<vector<int>> &Es, const int cur, vector<int> &ans) {
        ans[cur] = 1;
        for (const int nex : Es[cur]) {
            dfsCnt(Es, nex, ans);
            ans[cur] += ans[nex];
        }
    }
};",1434315930
Makoto2020,Makoto2020,433,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n, 0);
        for (int i = 0; i < k; ++i) {
            vector<int> oldDp = move(dp);
            dp = vector<int>(n, 0);
            for (int oldCity = 0; oldCity < n; ++oldCity) {
                // Stay option.
                dp[oldCity] = max(dp[oldCity], oldDp[oldCity] + stayScore[i][oldCity]);
                // Transition option.
                for (int newCity = 0; newCity < n; ++newCity) {
                    dp[newCity] = max(dp[newCity], oldDp[oldCity] + travelScore[oldCity][newCity]);
                }
            }
        }
        int ret = 0;
        for (int city = 0; city < n; ++city) ret = max(ret, dp[city]);
        return ret;
    }
};",1434323783
Makoto2020,Makoto2020,433,3617,cpp,"struct Data {
    char c{'0'};  int cnt{0};
    Data() = default;
    Data(const char a, const int b) : c(a), cnt(b) {}
};

class Solution {
public:
    int possibleStringCount(string word) {
        vector<Data> ds;
        for (int i = 0; i < word.size(); ++i) {
            if (ds.empty() || ds.back().c != word[i]) {
                ds.emplace_back(Data(word[i], 1));
            } else {
                ++ds.back().cnt;
            }
        }
        int ret = 1;
        for (const Data &d : ds) {
            ret += (d.cnt - 1);
        }
        return ret;
    }
};",1434295638
Kavish Dhamija,kavishd29598,434,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        last_seen = {}
        n = len(parent)
       
        adj = defaultdict(list)
        for i in range(n):
            adj[parent[i]].append(i)
        ans = [i for i in parent]
        def dfs(cur):
            if s[cur] in last_seen:
                ans[cur] = last_seen[s[cur]]
                prev = last_seen[s[cur]]
            else:
                prev = None
            last_seen[s[cur]] = cur
            for c in adj[cur]:
                dfs(c)
            if prev is not None:
                last_seen[s[cur]] = prev
            else:
                del last_seen[s[cur]]
        
        for i in range(n):
            if parent[i]==-1:
                dfs(i)
                break
        
        adj = defaultdict(list)
        for i in range(n):
            adj[ans[i]].append(i)
        fans = defaultdict(int)
        vis = set()
        def dfs2(cur):
            vis.add(cur)
            cans = 1
            for c in adj[cur]:
                cans += dfs2(c)
            fans[cur]=cans
            return cans
        for i in range(n):
            if i not in vis:
                dfs2(i)
        return [fans[i] for i in range(n)]
            
                ",1434287298
Kavish Dhamija,kavishd29598,434,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, S: List[List[int]], T: List[List[int]]) -> int:
        @cache
        def dp(cur,i):
            if i==k:
                return 0
            ans = S[i][cur]+dp(cur,i+1)
            for nxt in range(n):
                if nxt!=cur:
                    ans = max(ans, T[cur][nxt]+dp(nxt,i+1))
            return ans
        return max((dp(start,0) for start in range(n)))",1434316677
Kavish Dhamija,kavishd29598,434,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        word += '/'
        ans = 1
        p = None
        c = 0
        for i in word:
            if p==i:
                c+=1
            else:
                ans+=c
                c=0
                p=i
        return ans",1434295130
Dragonsq,Dragonsq,435,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        adjList = defaultdict(list)
        for i, p in enumerate(parent):
            adjList[p].append(i)

        lastParent = {s[0] : 0}
        def dfs(node):
            for child in adjList[node]:
                if s[child] in lastParent:
                    temp = lastParent[s[child]]
                    parent[child] = lastParent[s[child]]
                else:
                    temp = ""NA""
                    
                lastParent[s[child]] = child
                dfs(child)
                if temp == ""NA"":
                    del lastParent[s[child]]
                else:
                    lastParent[s[child]] = temp

        dfs(0)
        result = [0] * n
        adjList = defaultdict(list)
        for i, p in enumerate(parent):
            adjList[p].append(i)

        def dfs2(node):
            total = 1
            for child in adjList[node]:
                total += dfs2(child)
            result[node] = total
            return total
            
        dfs2(0)
        return result
                ",1434303963
Dragonsq,Dragonsq,435,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(i, curr):
            if i == k - 1:
                return max(stayScore[i][curr], max(travelScore[curr]))

            maxTravel = 0
            for j in range(n):
                maxTravel = max(maxTravel, dp(i + 1, j) + travelScore[curr][j])
            return max(dp(i + 1, curr) + stayScore[i][curr], maxTravel)

        return max(dp(0, i) for i in range(n))
        ",1434323808
Dragonsq,Dragonsq,435,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        last = """"
        count = 0
        total = 1
        for c in word:
            if c == last:
                count += 1
            else:
                last = c
                count = 1
            if count > 1:
                total += 1
        return total
            
            ",1434262661
newbie_noob,newbie_noob,436,3576,cpp,"class Solution {
public:
    void dfs(int u,int par,string &s,vector<int>g[],map<char,int>&mp,vector<int>&na)
    {
        int curr_char=s[u];
        int prev=-1;
        if(mp.find(curr_char)!=mp.end())
        {
            prev=mp[curr_char];
        }
        na[u]=prev;
        mp[curr_char]=u;
        for(auto v:g[u])
            {
                if(v==par)continue;
                dfs(v,u,s,g,mp,na);
            }
        if(prev!=-1)
        {
            mp[curr_char]=prev;
        }
        else
        {
            mp.erase(curr_char);
        }
    }
    int sbt(int u,int par,vector<int>g[],vector<int>&s)
{
    int a=1;
    for(auto v:g[u])
        {
            if(v==par)continue;
            a+=sbt(v,u,g,s);
        }
    s[u]=a;
    return a;
}
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        vector<int>na(n+1,-1);
        vector<int>g[n+1];
        int root=1;
        for(int i=0;i<n;++i)
            {
                if(parent[i]==-1)
                {
                    root=i;
                    continue;
                }
                g[i].push_back(parent[i]);
                g[parent[i]].push_back(i);
            }
        map<char,int>mp;
        vector<int>np(n+1,-1);
        dfs(root,-1,s,g,mp,na);
        vector<int>ng[n+1];
        for(int i=0;i<n;++i)
            {
                if(na[i]!=-1)
                {
                    np[i]=na[i];
                }
                else
                {
                    np[i]=parent[i];
                }
            }
        root=1;
        for(int i=0;i<n;++i)
            {
                if(parent[i]==-1)
                {
                    root=i;
                    continue;
                }
                ng[i].push_back(np[i]);
                ng[np[i]].push_back(i);
            }
        vector<int>ans(n,0);
        sbt(root,-1,ng,ans);
        return ans;
    }
};",1434305670
newbie_noob,newbie_noob,436,3587,cpp,"int dp[201][201];
class Solution {
public:
    int f(int day,int k,int curr,int n,vector<vector<int>>& ss,vector<vector<int>>& ts)
{
    if(day>=k)return 0;
    if(dp[day][curr]!=-1)return dp[day][curr];
    int ans=-1;
    for(int i=0;i<n;++i)
        {
            if(i==curr)
            {
                ans=max(ans,ss[day][curr]+f(day+1,k,curr,n,ss,ts));
            }
            else
            {
                ans=max(ans,ts[curr][i]+f(day+1,k,i,n,ss,ts));
            }
        }
    return dp[day][curr]=ans;
}
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        memset(dp,-1,sizeof(dp));
        int ans=0;
        for(int i=0;i<n;++i)
            {
                ans=max(ans,f(0,k,i,n,ss,ts));
            }
        return ans;
    }
};",1434316723
newbie_noob,newbie_noob,436,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=0;i<word.size();++i)
            {
                char ch=word[i];
                int f=0;
                while(i<word.size() && word[i]==ch)
                    {
                        ++f;
                        ++i;
                    }
                --i;
                ans+=f-1;
            }
        return ans;
    }
};",1434263203
Aryan Kaushal,aryankshl,437,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string labels) {
        int totalNodes = parent.size();
        vector<vector<int>> adjacencyList(totalNodes);
        
        buildTreeStructure(parent, adjacencyList);
        
        vector<int> newParent(totalNodes, -1);
        vector<int> lastSeenIndex(26, -1);
        
        updateParentReferences(0, adjacencyList, parent, labels, newParent, lastSeenIndex);
        
        vector<vector<int>> adjustedTree(totalNodes);
        generateAdjustedTree(newParent, adjustedTree);

        vector<int> subtreeSizes(totalNodes, 1);
        finalizeSizes(adjustedTree, subtreeSizes);

        return subtreeSizes;
    }
private:
    void buildTreeStructure(vector<int>& parent, vector<vector<int>>& tree) {
        for (int i = 1; i < parent.size(); ++i) {
            tree[parent[i]].push_back(i);
        }
    }

    void updateParentReferences(int node, vector<vector<int>>& tree, vector<int>& originalParent, 
                                string& labels, vector<int>& newParent, vector<int>& lastSeen) {
        int labelIndex = labels[node] - 'a';
        
        if (node != 0) {
            newParent[node] = (lastSeen[labelIndex] != -1) ? lastSeen[labelIndex] : originalParent[node];
        } else {
            newParent[node] = -1;
        }

        int previousSeen = lastSeen[labelIndex];
        lastSeen[labelIndex] = node;

        for (int child : tree[node]) {
            updateParentReferences(child, tree, originalParent, labels, newParent, lastSeen);
        }

        lastSeen[labelIndex] = previousSeen;
    }

    void generateAdjustedTree(vector<int>& newParent, vector<vector<int>>& newTree) {
        for (int i = 1; i < newParent.size(); ++i) {
            if (newParent[i] != -1) {
                newTree[newParent[i]].push_back(i);
            }
        }
    }

    void finalizeSizes(vector<vector<int>>& tree, vector<int>& sizes) {
        calculateSubtreeSize(0, tree, sizes);
    }

    void calculateSubtreeSize(int node, vector<vector<int>>& tree, vector<int>& sizes) {
        for (int child : tree[node]) {
            calculateSubtreeSize(child, tree, sizes);
            sizes[node] += sizes[child];
        }
    }

    int dummyOperation(int a) {
        for (int i = 0; i < a; ++i) {
            int a = 0;
            a++;
        }
        return a;
    }
};",1434293961
Aryan Kaushal,aryankshl,437,3587,cpp,"class Solution {
public:
    int getMaxTravelScore(int cityCount, vector<vector<int>>& travelMatrix, int city) {
            int maxScore = 0;
            for (int prevCity = 0; prevCity < cityCount; ++prevCity) {
                if (prevCity != city) {
                    maxScore = max(maxScore, travelMatrix[prevCity][city]);
                }
            }
            return maxScore;
        }
    
        void calculateDailyScores(int cityCount, int days, vector<vector<int>>& stayMatrix, 
                                  vector<vector<int>>& travelMatrix, vector<vector<int>>& dp) {
            for (int day = 1; day < days; ++day) {
                for (int city = 0; city < cityCount; ++city) {
                    dp[day][city] = dp[day - 1][city] + stayMatrix[day][city];
                    for (int prevCity = 0; prevCity < cityCount; ++prevCity) {
                        if (prevCity != city) {
                            dp[day][city] = max(dp[day][city], dp[day - 1][prevCity] + travelMatrix[prevCity][city]);
                        }
                    }
                }
            }
        }

    int maxScore(int cityCount, int days, vector<vector<int>>& stayMatrix, vector<vector<int>>& travelMatrix) {
        vector<vector<int>> dp(days, vector<int>(cityCount, 0));

        for (int city = 0; city < cityCount; ++city) {
            dp[0][city] = max(stayMatrix[0][city], getMaxTravelScore(cityCount, travelMatrix, city));
        }

        calculateDailyScores(cityCount, days, stayMatrix, travelMatrix, dp);

        int maxOverallScore = 0;
        vector<int> lastDayScores = dp[days - 1];

        int index = 0;
        while (index < cityCount) {
            maxOverallScore = max(maxOverallScore, lastDayScores[index]);
            ++index;
        }

        return maxOverallScore;
    }
};",1434316841
Aryan Kaushal,aryankshl,437,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        if (word.empty()) {
        return 0;
    }

    vector<pair<char, int>> runs;
    char current_char = word[0];
    int current_length = 1;

    for (size_t i = 1; i < word.length(); ++i) {
        if (word[i] == current_char) {
            current_length++;
        } else {
            runs.emplace_back(make_pair(current_char, current_length));
            current_char = word[i];
            current_length = 1;
        }
    }
    runs.emplace_back(make_pair(current_char, current_length));

    int total = 1;
    for (const auto& run : runs) {
        if (run.second >= 2) {
            total += (run.second - 1);
        }
    }

    return total;
    }
};",1434279742
randomsusapps,randomsusapps,438,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        g = defaultdict(set)
        ng = defaultdict(set)
        
        for idx, i in enumerate(parent):
            g[i].add(idx)
            ng[i].add(idx)
        
        def dfs(node, c, first):
            if s[node] == c:
                first = node
                
            for kid in g[node]:
                dfs(kid, c, first)
                
                if s[kid] == c and first != None:
                    ng[node].discard(kid)
                    ng[first].add(kid)
            
        
        for i in 'qwertyuiopasdfghjklzxcvbnm':
            dfs(0, i, None)
        
        def dfs1(node):
            sz = 1
            
            for kid in ng[node]:
                sz += dfs1(kid)
            
            res[node] = sz
            return sz
        
        res = [0] * len(parent)
        dfs1(0)
        return res",1434316890
randomsusapps,randomsusapps,438,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @cache
        def dp(kk, i):
            if kk == k:
                return 0
            
            res = stayScore[kk][i] + dp(kk + 1, i)
            
            for j, val in enumerate(travelScore[i]):
                res = max(res, val + dp(kk + 1, j))
            
            return res
        
        return max(dp(0, i) for i in range(n))",1434277587
randomsusapps,randomsusapps,438,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 0
        
        for i, j in groupby(word):
            t = len(list(j))
            res += t - 1
        
        return res + 1",1434284898
Artur,aalukin,441,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        if (parent == null || parent.length == 0) {
            return new int[0];
        }
        Map<Integer, List<Integer>> graph = buildGraph(parent);

        dfs(0, graph, parent, s, new HashMap<>());

        graph = buildGraph(parent);
        int[] res = new int[parent.length];
        getHeights(0, graph, res);

        return res;
    }

    private int getHeights(int cur, Map<Integer, List<Integer>> graph, int[] res) {
        List<Integer> children = graph.get(cur);
        if (children == null) {
            res[cur] = 1;
            return 1;
        }
        int count = 1;
        for (int next : children) {
            count += getHeights(next, graph, res);
        }
        res[cur] = count;

        return count;
    }

    private void dfs(int cur, Map<Integer, List<Integer>> graph, int[] parent, String s, Map<Character, Integer> last) {
        char c = s.charAt(cur);
        if (last.containsKey(c)) {
            parent[cur] = last.get(c);
        }
        List<Integer> children = graph.get(cur);
        if (children == null) {
            return;
        }
        Integer prev = last.get(c);
        last.put(c, cur);
        for (int next : children) {
            dfs(next, graph, parent, s, last);
        }
        if (prev == null) {
            last.remove(c);
        } else {
            last.put(c, prev);
        }
    }


    private Map<Integer, List<Integer>> buildGraph(int[] parent) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int i = 0; i < parent.length; ++i) {
            int p = parent[i];
            if (p != -1) {
                graph.computeIfAbsent(p, k -> new ArrayList<>()).add(i);
            }
        }

        return graph;
    }
}",1434302463
Artur,aalukin,441,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        if (n == 0 || k == 0) {
            return 0;
        }
        int max = 0;
        Map<Integer, Integer> cityScores = new HashMap<>();
        for (int i = 0; i < n; ++i) {
            cityScores.put(i, 0);
        }
        for (int day = 0; day < k; ++day) {
            Map<Integer, Integer> nextScores = new HashMap<>();
            for (Map.Entry<Integer, Integer> state : cityScores.entrySet()) {
                int city = state.getKey();
                int score = state.getValue();
                for (int next = 0; next < n; ++next) {
                    int nextScore = score;
                    if (next == city) {
                        nextScore += stayScore[day][next];
                    } else {
                        nextScore += travelScore[city][next];
                    }
                    if (!nextScores.containsKey(next) || nextScores.get(next) < nextScore) {
                        nextScores.put(next, nextScore);
                        max = Math.max(max, nextScore);
                    }
                }
            }

            cityScores = nextScores;
        }

        return max;
    }
}",1434324105
Artur,aalukin,441,3617,java,"class Solution {
    // abbcccc
    // abbcccc
    // abbccc
    // abbcc
    // abbc
    // abcccc
    public int possibleStringCount(String word) {
        if (word == null || word.length() <= 1) {
            return 1;
        }
        int count = 1;
        for (int i = 1; i < word.length(); ++i) {
            if (word.charAt(i) == word.charAt(i - 1)) {
                ++count;
            }
        }

        return count;
    }
}",1434271519
owen c,salesman,442,3576,python3,"class Solution:
    def findSubtreeSizes(self, p: List[int], s: str) -> List[int]:
        n = len(p)
        tree = defaultdict(list)
        result = [1] * n 
        for i in range(1, n):
            tree[p[i]].append(i)

        last_seen = {}

        def dfs_adjust(node: int):
            original_parent = p[node]
            char = s[node]
            if char in last_seen:
                new_parent = last_seen[char]
                if new_parent != original_parent:
                    p[node] = new_parent 
         
            prev_ancestor = last_seen.get(char, None)
            last_seen[char] = node  
            
            for child in tree[node]:
                dfs_adjust(child)
            
            if prev_ancestor is None:
                del last_seen[char]
            else:
                last_seen[char] = prev_ancestor

        dfs_adjust(0)

        new_tree = defaultdict(list)
        for i in range(1, n):
            new_tree[p[i]].append(i)

        def dfs_subtree_size(node: int) -> int:
            size = 1  
            for child in new_tree[node]:
                size += dfs_subtree_size(child) 
            result[node] = size  
            return size

        dfs_subtree_size(0)

        return result
",1434294891
owen c,salesman,442,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1] * (222) for i in range(222)]
        def solve(day, city):
            if dp[day][city] != -1: return dp[day][city]
            if day >= k: return 0
            # stay in current city 
            ans = solve(day+1, city) + stayScore[day][city]
            # move city 
            for i in range(n):
                if i == city: continue
                ans = max(ans, solve(day+1, i) + travelScore[city][i])
            dp[day][city] = ans
            return dp[day][city]
        ans = 0
        for i in range(n):
            ans = max(ans, solve(0, i))
        return ans",1434317111
owen c,salesman,442,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        word += '1'
        ans = 0
        prv = word[0]
        cur = 1
        for c in word:
            if c == prv:
                cur += 1
            else:
                ans += cur-1
                cur = 1 
            prv = c
        return ans 
            ",1434264777
Nelson,Nelson84,443,3576,cpp,"class Solution {
    vector<int> g[100001];
    vector<int> path[26];
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        for(int i=0; i<n; i++){
            int p = parent[i];
            if(p==-1) continue;

            g[p].push_back(i);
        }

        vector<int> res(n, 1);
        helper(s, 0, -1, res);
        return res;
    }

    int helper(const string& s, int cur, int parent, vector<int>& res){
        int cur_alpha = s[cur]-'a';
        path[cur_alpha].push_back(cur);
        for(auto neighbor: g[cur]){
            if(neighbor==parent) continue;
            
            int neighbor_alpha = s[neighbor]-'a';
            int ancestor = cur;
            if(path[neighbor_alpha].size()>0) ancestor = path[neighbor_alpha].back();    
            res[ancestor] += helper(s, neighbor, cur, res);
        }
        path[cur_alpha].pop_back();
        return res[cur];
    }
};",1434301109
Nelson,Nelson84,443,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int dp[n][k];
        int max_travels[n];
        memset(dp, 0, sizeof(dp));
        memset(max_travels, 0, sizeof(max_travels));
        for(int i=0; i<n; i++){
            for(int src=0; src<n; src++){
                max_travels[i] = max(max_travels[i], travelScore[src][i]);
            }
        }
        for(int i=0; i<n; i++) dp[i][0] = max(stayScore[0][i], max_travels[i]);
        for(int day=1; day<k; day++){
            for(int i=0; i<n; i++){
                dp[i][day] = dp[i][day-1] + stayScore[day][i];
                for(int src=0; src<n; src++){
                    if(src==i) continue;
                    
                    dp[i][day] = max(dp[i][day], dp[src][day-1] + travelScore[src][i]);
                }
            }
        }
        int max_score = 0;
        for(int i=0; i<n; i++) max_score = max(max_score, dp[i][k-1]);
        return max_score;
    }
};",1434324247
Nelson,Nelson84,443,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        /*
            4 1 2 3
            (1 2 3 4) * (1) * (1 2) * (1 2 3)
        */
        int n = word.size();
        int res = 1;
        int prev = -1;
        int cnt = 1;
        for(int i=0; i<n; i++){
            int cur = word[i]-'a';
            if(cur==prev) cnt++;
            else{
                res += (cnt-1);
                cnt = 1;
            }
            prev = cur;
        }
        res += cnt-1;
        return res;
    }
};",1434267775
leetgoat_dot_dev,leetgoat_dot_dev,444,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        children = defaultdict(list)
        for node in range(len(parent)):
            children[parent[node]].append(node)
        
        @cache
        def closestAncestorGTEWithMatch(node, char):
            if node == -1:
                return None
            if s[node] == char:
                return node
            return closestAncestorGTEWithMatch(parent[node], char)
        
        
        
        res = [0] * len(s)
        # returns trimmed size, and cut mapping of children
        def dfs(node):
            if not children[node]:
                res[node] = 1
                return (1, Counter())
            
            sizeHere = 1
            cutsHere = Counter()
            for child in children[node]:
                cSize, cCuts = dfs(child)
                
                sizeHere += cCuts[s[node]] # add child trimmings to my letter
                cCuts[s[node]] = 0
                # carry more cutlings
                for key in cCuts:
                    cutsHere[key] += cCuts[key]
                    
                # dont cut child
                if s[child] == s[node]:
                    sizeHere += cSize
                    continue
                
                # may need to cut
                if s[child] != s[node]:
                    closestParent = closestAncestorGTEWithMatch(node, s[child])
                    # dont need to cut this
                    if closestParent is None:
                        sizeHere += cSize
                    
                    # have a higher parent, we trim
                    else:
                        cutsHere[s[child]] += cSize
            
            res[node] = sizeHere
            return (sizeHere, cutsHere)
        
        dfs(0)
        return res
                        

            
                    
                

#         sizes = [1] * len(s)

#         def dfs(node):
#             print(f'dfs called on node={node}')
#             if not children[node]:
#                 print(f'leaf node!')
#                 print(f'size now 1: {sizes}')
#                 closestAncestor = closestAncestorGTEWithMatch(parent[node], s[node])
#                 print(F'closest ancestor: {closestAncestor}')
#                 if closestAncestor is not None:
#                     print(f'had ancestor, incrementing that by 1 since were moved')
#                     sizes[closestAncestor] += 1
#                     return 0
#                 else:
#                     print(f'no ancestor, parent will use my size of 1')
#                     return 1
            
#             print(f'not leaf node!')
#             sizeHere = sizes[node]
#             print(f'current size here: {sizeHere}')
#             for c in children[node]:
#                 print(f'child: {c}')
#                 childUsefulSize = dfs(c)
#                 sizeHere += childUsefulSize
            
#             sizes[node] = sizeHere
            
#             closestAncestor = closestAncestorGTEWithMatch(parent[node], s[node])
#             if closestAncestor is not None:
#                 sizes[closestAncestor] += sizeHere
#                 return 0
#             else:
#                 return sizeHere
        
#         dfs(0)
#         return sizes
                        
                                                  
                        
                        
                                                  
                        
                        
                    
                        
            
            ",1434324262
leetgoat_dot_dev,leetgoat_dot_dev,444,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(i, curr):
            if i == k:
                return 0
            
            stay = stayScore[i][curr] + dp(i + 1, curr)
            resMove = 0
            for adj in range(n):
                if adj == curr:
                    continue
                move = travelScore[curr][adj] + dp(i + 1, adj)
                resMove = max(resMove, move)
            return max(stay, resMove)
        
        a = max(dp(0,i) for i in range(n))
        dp.cache_clear()
        return a",1434273078
leetgoat_dot_dev,leetgoat_dot_dev,444,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        groups = []
        res = 1
        curr = []
        for c in word:
            if not curr:
                curr.append(c)
                continue
            if c == curr[-1]:
                curr.append(c)
                continue
            groups.append(curr)
            curr = [c]
        if curr:
            groups.append(curr)
            
        for g in groups:
            res += len(g) - 1
        
        return res
        
        # print(groups)
        ",1434261904
BrutalKiller,BrutalKiller,445,3576,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;

class Solution {

    vvi v, new_v;
    vi ans;
    string s;
    vi help, temp;

    void dfs(ll x, ll p){
        if(x != 0){
            if(help[s[x] - 'a'] == -1)
                temp[x] = p;
            else
                temp[x] = help[s[x] - 'a'];
        }

        ll a = help[s[x] - 'a'];
        help[s[x] - 'a'] = x;

        for(auto & e : v[x])
            dfs(e, x);

        help[s[x] - 'a'] = a;
    }

    void dfs2(ll x){
        ans[x] = 1;

        for(auto & e : new_v[x]){
            dfs2(e);
            ans[x] += ans[e];
        }
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string ss) {

        s = ss;
        ll n = parent.size();
        v = new_v = vvi(n);
        temp = vi (n, -1);
        ans = vi (n);
        help = vi(26, -1);
        
        for(ll i = 1; i < n; i++){
            v[parent[i]].pb(i);
        }

        dfs(0, -1);

        for(ll i = 1; i < n; i++){
            new_v[temp[i]].pb(i);
        }

        dfs2(0);
        return ans;
    }
};",1434292696
BrutalKiller,BrutalKiller,445,3587,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedefintll;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        ll ans = 0;

        vi help(n, 0);

        for(ll i = 0; i < k; i++){
            vi next(n, 0);

            for(ll j = 0; j < n; j++)
                next[j] = help[j] + s[i][j];

            for(ll j = 0; j < n; j++){
                for(ll k = 0; k < n; k++){
                    if(j != k)
                        next[k] = max(next[k], help[j] + t[j][k]);
                }
            }

            help = next;
            
        }

        for(ll i = 0; i < n; i++)
            ans = max(ans, help[i]);

        return ans;
    }
};",1434324332
BrutalKiller,BrutalKiller,445,3617,cpp,"#include ""bits/stdc++.h""
#define all(a) a.begin(), a.end()
#define pb push_back
#define vi vector <ll>
#define vvi vector <vector <ll>>
#define pll pair<ll, ll>

using namespace std;

typedef int ll;
class Solution {
public:
    int possibleStringCount(string word) {

        ll ans = 1;

        for(ll i = 1; i < word.size(); i++){
            if(word[i] == word[i - 1])
                ans++;
        }
        return ans;
    }
};",1434262460
olegmak,olegmak,446,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        const int ALPHA_SZ = 'z' - 'a' + 1;
        const int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        vector<stack<int>> last_ch(ALPHA_SZ);
        vector<int> new_parent(parent);
        auto dfs = [&](auto&& dfs, int node) -> void {
            stack<int>& p = last_ch[s[node] - 'a'];
            if (!p.empty()) {
                new_parent[node] = p.top();
            }
            p.push(node);
            for (const int next : adj[node]) {
                dfs(dfs, next);
            }
            p.pop();
        };
        dfs(dfs, 0);
        vector<vector<int>> new_adj(n);
        for (int i = 1; i < n; ++i) {
            new_adj[new_parent[i]].push_back(i);
        }
        vector<int> tree_size(n, 1);
        auto dfs2 = [&](auto&& dfs2, int node) -> void {
            for (const int next : new_adj[node]) {
                dfs2(dfs2, next);
                tree_size[node] += tree_size[next];
            }
        };
        dfs2(dfs2, 0);
        return tree_size;
    }
};",1434291635
olegmak,olegmak,446,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> cache(k, vector<int>(n, -1));
        auto solve = [&](auto&& solve, int day, int city) {
            if (day == k) {
                return 0;
            }
            int& cached = cache[day][city];
            if (cached != -1) {
                return cached;
            }
            int res = stayScore[day][city] + solve(solve, day + 1, city);
            for (int dest = 0; dest < n; ++dest) {
                res = max(res, travelScore[city][dest] + solve(solve, day + 1, dest));
            }
            return cached = res;
        };
        int res = 0;
        for (int i = 0; i < n; ++i) {
            res = max(res, solve(solve, 0, i));
        }
        return res;
    }
};",1434324489
olegmak,olegmak,446,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        char prev = word[0];
        for (int i = 1; i < word.size(); ++i) {
            if (word[i] == prev) {
                ++res;
            } else {
                prev = word[i];
            }
        }
        return res;
    }
};",1434262056
Prabh,ResentfulPhantom,447,3576,cpp,"class Solution {
public:

void dfs1(string &s, vector<int> graph[], int u, vector<int> &parent, vector<int> ancestors[]) {
    int val = s[u] - 'a';
    vector<int> &ancestor_state = ancestors[val];
    if (ancestor_state.size() != 0) {
        parent[u] = ancestor_state.back();
    }

    ancestor_state.push_back(u);

    for(int v : graph[u]) {
        dfs1(s, graph, v, parent, ancestors);
    }
    
    ancestor_state.pop_back();
}

void dfs2(vector<int> graph[], int u, vector<int> &dp) {
    dp[u]++;

    for(int v : graph[u]) {
        dfs2(graph, v, dp);
        dp[u] += dp[v];
    }
}

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> graph[n];
        for(int i = 1; i < n; i++) {
            graph[parent[i]].push_back(i);
        }

        vector<int> ancestors[26];

        dfs1(s, graph, 0, parent, ancestors);

        vector<int> mutated_graph[n];
        for(int i = 1; i < n; i++){
            mutated_graph[parent[i]].push_back(i);
        }

        vector<int> dp(n);
        dfs2(mutated_graph, 0, dp);

        return dp;
    }
};",1434292459
Prabh,ResentfulPhantom,447,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int>(k, 0));

        for(int day = 0; day < k; day++) {
            for(int city = 0; city < n; city++) {
                    dp[city][day] = (day ? dp[city][day - 1] : 0) + stayScore[day][city];
                    for(int from = 0; from < n; from++) {
                        dp[city][day] = max(dp[city][day], travelScore[from][city] + (day ? dp[from][day - 1] : 0));
                    }
            }
        }

        int answer = 0;
        for(int i = 0; i < n; i++){
            answer = max(answer, dp[i][k-1]);
        }

        return answer;
    }
};",1434317501
Prabh,ResentfulPhantom,447,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int answer = 1;
        int n = word.size();
        for(int i = 0; i < n;) {
            int cnt = 0;
            char current = word[i];
            while(i < n and word[i] == current) cnt++, i++;
            answer += (cnt - 1);
        }

        return answer;
    }
};",1434265095
Codewithnav,navpreetsingh951818,449,3576,java,"class Solution {
    
    int[] res;
    
    int[] fin;
    public int[] findSubtreeSizes(int[] parent, String s) {
        
        
        HashMap<Integer,ArrayList<Integer>> c = new HashMap<>();
        
        int n = parent.length;
        res = new int[n];
        fin = new int[n];
        for(int i =0;i<n;i++) res[i] = parent[i];
        for(int i =1;i<n;i++){
            int v = parent[i];
            if(!c.containsKey(v)) c.put(v,new ArrayList<>());
            
            
            c.get(v).add(i);
        }
        
        
        
        rec(0,c,new HashMap<>(),s);
        
        return count();
        
    }
    
    
    
    int[] count(){
         HashMap<Integer,ArrayList<Integer>> c = new HashMap<>();
        
        int n = res.length;
       
        for(int i =1;i<n;i++){
            int v = res[i];
            if(!c.containsKey(v)) c.put(v,new ArrayList<>());
            
            
            c.get(v).add(i);
        }
        
        dfs(0,c);
        
        return fin;
        
    }
    
    
    int dfs(int j,HashMap<Integer,ArrayList<Integer>> c){
        
        
        fin[j] = 1;
        
        
        if(c.containsKey(j)){
            
            for(int e : c.get(j)){
                
                fin[j] += dfs(e,c);
            }
        }
       
        return fin[j];
    }
    
    void rec(int j,HashMap<Integer,ArrayList<Integer>> c,HashMap<Character,Integer> pos,String s){
        
        
        char ch = s.charAt(j);
        
        
        int prev = pos.getOrDefault(ch,-1);
        
        
        
        if(prev != -1) res[j] = prev;
        
        pos.put(ch,j);
        
        
        if(c.containsKey(j)){
            
            for(int e : c.get(j)){
                
                rec(e,c,pos,s);
            }
        }
        pos.put(ch,prev);
        
    }
    
}

",1434297274
Codewithnav,navpreetsingh951818,449,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] ss, int[][] ts) {
        
        
        
        int[][] dp = new int[k][n];
            for(int[] d : dp) Arrays.fill(d,-1);
        
        int res = 0;
        for(int i =0;i<n;i++){
            
            res = Math.max(res,rec(0,i,dp,ss,ts));
        }
        
        return res;
    }
    
    int rec(int i,int curr,int[][] dp,int[][] ss, int[][] ts){
        
        int k =ss.length;
        int n =ts.length;
        if(i >= k) return 0;
        
        
        if(dp[i][curr] != -1) return dp[i][curr];
        
        
        // take 
        
        int res = rec(i+1,curr,dp,ss,ts) + ss[i][curr];
        
        
        // l 
        
        for(int j = 0;j<n;j++){
            if(j != curr){
                
                
                res = Math.max(res, rec(i+1,j,dp,ss,ts) + ts[curr][j]);
            }
        }
        
        return dp[i][curr] = res;
    }
}",1434317679
Codewithnav,navpreetsingh951818,449,3617,java,"class Solution {
    public int possibleStringCount(String word) {

        int res = 1;
        int n = word.length();

        for(int i =0;i<n-1;i++){

            if(word.charAt(i) == word.charAt(i+1)) res++;
        }
        return res;
    }
}",1434264158
Rohitaas Beri,rohitaas_beri,450,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {

        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; i++) {
            if (parent[i] != -1) {
                adj[parent[i]].push_back(i);
            }
        }

        vector<int> freq(26, -1);
        vector<int> newP(n);
        function<void(int, int)> dfs = [&](int node, int par) {
            if (freq[s[node] - 'a'] == -1) {
                newP[node] = parent[node];
            } else {
                newP[node] = freq[s[node] - 'a'];
            }

            int prev = freq[s[node] - 'a'];
            freq[s[node] - 'a'] = node;
            for (auto i : adj[node]) {
                if (i != par) {
                    dfs(i, node);
                }
            }
            freq[s[node] - 'a'] = prev;
        };
        dfs(0, -1);

        // for (int i = 0; i < n; i++) {
        //     cout << newP[i] << "" "";
        // }
        // cout << endl;
        vector<vector<int>> newAdj(n);
        for (int i = 0; i < n; i++) {
            if (newP[i] != -1) {
                newAdj[newP[i]].push_back(i);
            }
        }

        vector<int> ans(n);
        function<int(int, int)> dfs2 = [&](int node, int par) {
            int sum = 1;
            for (auto i : newAdj[node]) {
                if (i != par) {
                    sum += dfs2(i, node);
                }
            }
            ans[node] = sum;
            return sum;
        };
        dfs2(0, -1);
        return ans;
    }
};",1434304618
Rohitaas Beri,rohitaas_beri,450,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelScore) {

        int dp[k + 1][n + 1];
        memset(dp, 0, sizeof(dp));

        for (int days = 1; days <= k; days++) {
            for (int dest = 1; dest <= n; dest++) {
                for (int src = 1; src <= n; src++) {
                    if (src == dest) {
                        dp[days][dest] =
                            max(dp[days][dest],
                                stayScore[days - 1][src-1] + dp[days - 1][src]);
                    } else {
                        dp[days][dest] =
                            max(dp[days][dest],
                                travelScore[src-1][dest-1] + dp[days - 1][src]);
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            ans = max(ans, dp[k][i]);
        }
        return ans;
    }
};",1434317903
Rohitaas Beri,rohitaas_beri,450,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {

        int cnt = 1;
        int ans = 0;
        for (int i = 1; i < word.size(); i++) {
            if(word[i]==word[i-1])
            {
                cnt++;
            }
            else
            {
                ans += cnt-1;
                cnt = 1;
            }
        }
        ans+=cnt-1;
        ans++;
        return ans;
    }
};",1434268930
Yashas Yashas,Yashas_r,452,3576,cpp,"#include <vector>
#include <unordered_map>
#include <stack>
#include <functional>
#include <string>
using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int totalNumberOfNodes = parent.size();
        
        // Build adjacency list representation of the initial tree
        vector<vector<int>> initialTreeAdjacencyList(totalNumberOfNodes);
        for (int currentNodeIndex = 1; currentNodeIndex < totalNumberOfNodes; ++currentNodeIndex) {
            initialTreeAdjacencyList[parent[currentNodeIndex]].push_back(currentNodeIndex);
        }
        
        // Find closest ancestor with the same character for each node
        vector<int> closestAncestorWithSameCharacter(totalNumberOfNodes, -1);
        
        // Recursive DFS helper function using lambda to find closest ancestors
        function<void(int, unordered_map<char, stack<int>>&)> findClosestAncestorHelper =
            [&](int currentNode, unordered_map<char, stack<int>>& ancestorsWithCharacters) {
                
            // Store current node's character and position
            if (!ancestorsWithCharacters.count(s[currentNode])) {
                ancestorsWithCharacters[s[currentNode]] = stack<int>();
            }
            ancestorsWithCharacters[s[currentNode]].push(currentNode);
            
            // Process all children
            for (int childNode : initialTreeAdjacencyList[currentNode]) {
                // Check if there's an ancestor with the same character
                if (!ancestorsWithCharacters[s[childNode]].empty()) {
                    closestAncestorWithSameCharacter[childNode] = ancestorsWithCharacters[s[childNode]].top();
                }
                
                findClosestAncestorHelper(childNode, ancestorsWithCharacters);
            }
            
            // Remove current node from ancestors when backtracking
            ancestorsWithCharacters[s[currentNode]].pop();
        };
        
        // Start DFS from root to find closest ancestors
        unordered_map<char, stack<int>> ancestorsWithCharacters;
        findClosestAncestorHelper(0, ancestorsWithCharacters);
        
        // Build the final tree after all changes
        vector<vector<int>> finalTreeAdjacencyList(totalNumberOfNodes);
        for (int nodeIndex = 1; nodeIndex < totalNumberOfNodes; ++nodeIndex) {
            int newParentNode = closestAncestorWithSameCharacter[nodeIndex] != -1 ? 
                closestAncestorWithSameCharacter[nodeIndex] : parent[nodeIndex];
            finalTreeAdjacencyList[newParentNode].push_back(nodeIndex);
        }
        
        // Calculate subtree sizes using DFS
        vector<int> subtreeSizesResult(totalNumberOfNodes, 1);
        
        function<void(int)> calculateSubtreeSizesHelper = [&](int currentNode) {
            for (int childNode : finalTreeAdjacencyList[currentNode]) {
                calculateSubtreeSizesHelper(childNode);
                subtreeSizesResult[currentNode] += subtreeSizesResult[childNode];
            }
        };
        
        calculateSubtreeSizesHelper(0);
        return subtreeSizesResult;
    }
};
",1434299634
Yashas Yashas,Yashas_r,452,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Create DP table: dp[day][currentCity]
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        
        // Work backwards from the last day
        for (int currentDay = k - 1; currentDay >= 0; --currentDay) {
            for (int currentCity = 0; currentCity < n; ++currentCity) {
                int maximumScoreForCurrentState = 0;

                // Option 1: Stay in current city
                int scoreFromStayingInCurrentCity = stayScore[currentDay][currentCity] + dp[currentDay + 1][currentCity];
                maximumScoreForCurrentState = max(maximumScoreForCurrentState, scoreFromStayingInCurrentCity);

                // Option 2: Travel to another city
                for (int destinationCity = 0; destinationCity < n; ++destinationCity) {
                    if (destinationCity != currentCity) {
                        int scoreFromTravelingToNewCity = travelScore[currentCity][destinationCity] + dp[currentDay + 1][destinationCity];
                        maximumScoreForCurrentState = max(maximumScoreForCurrentState, scoreFromTravelingToNewCity);
                    }
                }

                dp[currentDay][currentCity] = maximumScoreForCurrentState;
            }
        }

        // Find maximum score possible starting from any city on day 0
        int globalMaximumScoreAcrossAllPaths = 0;
        for (int initialCity = 0; initialCity < n; ++initialCity) {
            globalMaximumScoreAcrossAllPaths = max(globalMaximumScoreAcrossAllPaths, dp[0][initialCity]);
        }

        return globalMaximumScoreAcrossAllPaths;
    }
};
",1434303007
Yashas Yashas,Yashas_r,452,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count = 1; // Start with one possibility, the original word itself.
        int n = word.length();

        // Iterate through the string to find possible segments where Alice might have overtyped.
        for (int i = 1; i < n; ++i) {
            // If the current character is the same as the previous one, 
            // it indicates a possible overtyping case.
            if (word[i] == word[i - 1]) {
                count++; // Increment the count for each such possibility.
            }
        }

        return count;
    }
};
",1434272523
Rohan Bhardwaj,RohanBhardwaj08,454,3576,cpp,"class Solution {
public:
    void dfs(vector<vector<int>> &g, vector<int>& parent, vector<int> &alpha, int node,string &s){
        
        if(alpha[s[node] -'a'] != -1){
            parent[node] = alpha[s[node] -'a'];
        }
        for( int child :g[node]){
            
//             if(node == 3) cout<<parent[node]<<endl;
            
//             if(node == 3) cout<<parent[node]<<endl;
            int prev = alpha[s[node] -'a'];
            alpha[s[node] -'a'] = node;
            dfs(g,parent,alpha,child,s);
            alpha[s[node] -'a']  = prev;
        }
        
        return;
    }
    int dfs2(vector<vector<int>> &g,int node, vector<int> &ans){
        int temp =1;
        for( int child :g[node]){
            temp += dfs2(g,child,ans);
        }
        return ans[node] = temp;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> alpha(26,-1);
        vector<vector<int>> g(n);
        
        for(int i=1;i<n;i++){
            g[parent[i]].push_back(i);
        }
        // for(int i=0;i<n;i++){
        //     cout<<i<<"": "";
        //     for(int j:g[i]){
        //         cout<<j<<"" "";
        //     }
        //     cout<<endl;
        // }
        dfs(g,parent,alpha,0,s);
        vector<vector<int>> n_g(n);
        for(int i=1;i<n;i++){
            // cout<<parent[i]<<"" "";
            n_g[parent[i]].push_back(i);
        }
        vector<int> ans(n,0);
        dfs2(n_g,0,ans);
        return ans;
    }
};",1434307630
Rohan Bhardwaj,RohanBhardwaj08,454,3587,cpp,"class Solution {
public:
    int solve(int k, int curr, vector<vector<int>>& s, vector<vector<int>>& t, int day, int n, vector<vector<int>> &dp){
        if(day==k) return 0;
        if(dp[day][curr]!=-1) return dp[day][curr];
        int ans = solve(k,curr,s,t,day+1,n,dp) + s[day][curr];
        for(int i=0;i<n;i++){
            ans = max(ans, solve(k,i,s,t,day+1,n,dp) + t[curr][i]);
        }
        return dp[day][curr]= ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        
        int ans = INT_MIN;
        vector<vector<int>> dp(k+1,vector<int> (n+1,-1));
        for(int i =0;i<n;i++){
            ans = max(ans, solve(k,i,s,t,0,n,dp));
        }
        return ans;
    }
};",1434325231
Rohan Bhardwaj,RohanBhardwaj08,454,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int count = 1;
        int ans  = 0;
        for(int i=1;i<n;i++){
            if(word[i]!=word[i-1]){
                ans += count -1;
                count = 1;
            }else{
                count++;
            }
        }
        ans += count-1;
        return ans+1;
    }
};",1434263951
Sumit,Sumit_310,455,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); 
        vector<int> answer(n, 1);   
        for (int i = 1; i < n; ++i) adj[parent[i]].push_back(i);
        vector<int> newParent = parent; 
        unordered_map<char, vector<int>> lastSeen; 
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : adj[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0); 
        vector<vector<int>> newAdj(n); 
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1; 
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0); 
        return answer;
    }
};",1434323627
Sumit,Sumit_310,455,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) { 
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        return maxPoints;
    }
};",1434325437
Sumit,Sumit_310,455,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int totalCount = 1;

        for (int i = 0; i < n;) {
            int j = i;

            while (j < n && word[i] == word[j]) {
                j++;
            }
            int len = j - i;
            
            if (len > 1) {
                totalCount += len - 1;
            }
            i = j;
        }

        return totalCount;
    }
};",1434291020
Anupam Shakya,meetanupam,456,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> chldd(n);
        vector<int> ans(n, 1);
        vector<int> clsAns(26, -1);
        vector<int> newParent = parent;


        for (int i = 1; i < n; i++) {
        int p = parent[i];
        chldd[p].push_back(i);
    }


        function<void(int)> dfs = [&](int node) {
            long long prvans = clsAns[s[node] - 'a'];
            clsAns[s[node] - 'a'] = node;

            for (int child : chldd[node]) dfs(child);

            if (node != 0 && prvans != -1 && s[node] == s[prvans]) {
                newParent[node] = prvans;
            }

            clsAns[s[node] - 'a'] = prvans;
        };

        dfs(0);

        vector<vector<int>> newChildren(n);
        for (int i = 1; i < n; i++) {
            int parent = newParent[i];
            newChildren[parent].push_back(i);
        }

        function<int(int)> clSBsz = [&](int node) {
            int sz = 1;
            for (int child : newChildren[node]) sz += clSBsz(child);
            return ans[node] = sz;
        };

        clSBsz(0);
        return ans;
    }
};
",1434267242
Anupam Shakya,meetanupam,456,3587,typescript,"function maxScore(n: number, k: number, sS: number[][], tS: number[][]): number {
    const dp: number[][] = Array.from({ length: k + 1 }, () => Array(n).fill(-1));

    const cM: (d: number, c: number) => number = (d, c) => {
        if (d === k) {
            return 0;
        }
        if (dp[d][c] !== -1) {
            return dp[d][c];
        }

        let mP = sS[d][c] + cM(d + 1, c);

        for (let nC = 0; nC < n; nC++) {
            if (nC !== c) {
                mP = Math.max(mP, tS[c][nC] + cM(d + 1, nC));
            }
        }

        dp[d][c] = mP;
        return mP;
    };

    let r = 0;
    for (let sC = 0; sC < n; sC++) {
        r = Math.max(r, cM(0, sC));
    }

    return r;
}
",1434310933
Anupam Shakya,meetanupam,456,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {

        long long cnt = 1;
        size_t i = 1;

        auto cntAdj = [&](const string& w) {
        int cnt = 1;
        for (size_t i = 1; i < w.length(); ++i) {
            cnt += (w[i] == w[i - 1]) ? 1 : 0;
        }
        return cnt;
    };

    return cntAdj(word); 
    }
};",1434279363
Suyash,suyash21__,459,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> edges(n);
        for(int i=1;i<n;i++){
            int u = i, v = parent[i];
            edges[u].push_back(v);
            edges[v].push_back(u);
        }
        vector<vector<int>> newEdges(n);
        vector<int> closest(26, -1);
        auto dfs = [&](auto&& dfs, int node, int par) -> void {
            int valBefore = closest[s[node] - 'a'];
            if(valBefore != -1){
                newEdges[valBefore].push_back(node);
                newEdges[node].push_back(valBefore);
            }
            else{
                if(par != -1){
                    newEdges[node].push_back(par);
                    newEdges[par].push_back(node);
                }
            }
            closest[s[node] - 'a'] = node;
            for(auto& neighbours : edges[node]){
                if(neighbours == par) continue;
                dfs(dfs, neighbours, node);
            }
            closest[s[node] - 'a'] = valBefore;
        };
        dfs(dfs, 0, -1);
        vector<int> ans(n, 1);
        auto subsize = [&](auto&& subsize, int node, int par) -> void {  
            for(auto& neighbours : newEdges[node]){
                if(par == neighbours) continue;
                subsize(subsize, neighbours, node);
                ans[node] += ans[neighbours];
            }
        };
        subsize(subsize, 0, -1);
        return ans;
    }
};",1434301470
Suyash,suyash21__,459,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> prevdp(n, 0);
        for(int i=0;i<k;i++){
            vector<int> newdp = prevdp;
            for(int j=0;j<n;j++){
                for(int l=0;l<n;l++){
                    newdp[j] = max(newdp[j], prevdp[l] + (j == l ? stayScore[i][l] :travelScore[l][j]));  
                }
            }
            prevdp = newdp;
        }
        return *max_element(prevdp.begin(), prevdp.end());
    }
};",1434325898
Suyash,suyash21__,459,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1, n = word.size();
        for(int i=1;i<n;i++){
            if(word[i] == word[i-1]) ans++; 
        }
        return ans;
    }
};",1434260984
Ankur Dwivedi,Ankur_Dwivedi,461,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string& s) {
        int n = p.size();
        vector<vector<int>> tree(n);
        for (int i = 1; i < n; ++i) {
            tree[p[i]].push_back(i);
        }

        adjP = p;
        last.assign(26, -1);
        updateParent(0, s, tree);

        vector<vector<int>> adjTree(n);
        for (int i = 1; i < n; ++i) {
            adjTree[adjP[i]].push_back(i);
        }

        sizes.assign(n, 1);
        computeSize(0, adjTree);

        return sizes;
    }

private:
    vector<int> adjP;
    vector<int> last;
    vector<int> sizes;

    void updateParent(int node, const string& s, const vector<vector<int>>& tree) {
        int chIdx = s[node] - 'a';
        if (last[chIdx] != -1) {
            adjP[node] = last[chIdx];
        }
        int prevAnc = last[chIdx];
        last[chIdx] = node;

        for (int child : tree[node]) {
            updateParent(child, s, tree);
        }

        last[chIdx] = prevAnc;
    }

    int computeSize(int node, const vector<vector<int>>& adjTree) {
        int sz = 1;
        for (int child : adjTree[node]) {
            sz += computeSize(child, adjTree);
        }
        sizes[node] = sz;
        return sz;
    }
};
",1434306541
Ankur Dwivedi,Ankur_Dwivedi,461,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelScore) {
        vector<int> curr(n, 0), next(n, 0);

        for (int day = k - 1; day >= 0; --day) {
            for (int city = 0; city < n; city++) {
                int stayPoints = stayScore[day][city] + next[city];

                int travelPoints = 0;
                for (int nxtCity = 0; nxtCity < n; nxtCity++) {
                    if (nxtCity != city) {
                        travelPoints =
                            max(travelPoints,
                                travelScore[city][nxtCity] + next[nxtCity]);
                    }
                }

                curr[city] = max(stayPoints, travelPoints);
            }
            next = curr;
        }

        int ans = *max_element(curr.begin(), curr.end());
        return ans;
    }
};",1434318989
Ankur Dwivedi,Ankur_Dwivedi,461,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        if(word.empty()) return 0;
        
        int ct = 1, n = word.size();
        for(int i = 1; i < n; i++) {
            if(word[i] == word[i-1]) {
                ct++;
            }
        }
        return ct;
    }
};",1434263304
FaizFK,FaizFK,462,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();

        vector<vector<int>> adj(n); 
        for(int i=1;i<n;i++)
        {
            adj[parent[i]].push_back(i);
        }

        vector<int> npar(n,0);
        vector<int> anc(26,-1);

        auto dfs = [&](auto&& dfs, int u, int par)->void
        {
            int prev=anc[s[u]-'a'];
            npar[u]=prev;
            anc[s[u]-'a']=u;
            
            for(int v:adj[u])
            {
                if(v==par)
                    continue;
                
                dfs(dfs, v, u);
            }
            
            anc[s[u]-'a']=prev;
        };
        dfs(dfs, 0, -1);

        vector<vector<int>> nadj(n);
        for(int i=0;i<n;i++)
        {
            if(npar[i]==-1)
                npar[i]=parent[i];

            if(npar[i]!=-1)
                nadj[npar[i]].push_back(i);
        }

        

        vector<int> ans(n,0);
        auto dfs2 = [&](auto&& dfs2, int u, int par)->int
        {
            int sz=1;
            for(int v:nadj[u])
            {
                if(v==par)
                    continue;

                sz+=dfs2(dfs2, v, u);
            }

            return ans[u]=sz;
        };
        dfs2(dfs2, 0, -1);

        return ans;
    }
};",1434291091
FaizFK,FaizFK,462,3587,cpp,"class Solution {
public:
    int maxScore(int n, int K, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        
        vector<vector<int>> dp(K+1, vector<int>(n,0));
        for(int u=0;u<n;u++)
        {
            dp[K][u]=0;
        }

        //we are at city u at day k
        for(int k=K-1;k>=0;k--)
        {
            for(int u=0;u<n;u++)
            {
                dp[k][u]=stayScore[k][u]+dp[k+1][u];
                for(int v=0;v<n;v++)
                {
                    dp[k][u]=max(dp[k][u], travelScore[u][v] + dp[k+1][v]);
                }
            }
        }

        int ans=0;
        for(int u=0;u<n;u++)
        {
            ans=max(ans, dp[0][u]);
        }

        return ans;
    }
};",1434319093
FaizFK,FaizFK,462,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n=word.size();
        int ans=0;
        for(int i=0;i<n;i++)
        {
            char val=word[i];
            int cnt=0;
            while(i<n && word[i]==val)
            {
                i++;
                cnt++;
            }
            i--;

            ans+=cnt-1;
        }

        return ans+1;
    }
};",1434262117
Tudor Buzu,Tudor67,463,3576,cpp,"class Solution {
private:
    using Graph = vector<vector<int>>;
    const int A = 26;
    const int FIRST_CHAR = 'a';
    const int INF = 1e9;
    
    void dfs(int node, vector<int> lastNodeOf, const Graph& G, string& s, vector<int>& newParent){
        if(lastNodeOf[s[node] - FIRST_CHAR] != INF){
            newParent[node] = lastNodeOf[s[node] - FIRST_CHAR];
        }
        lastNodeOf[s[node] - FIRST_CHAR] = node;
        for(int child: G[node]){
            dfs(child, lastNodeOf, G, s, newParent);
        }
    }
    
    void f(int node, const Graph& G, vector<int>& res){
        res[node] = 1;
        for(int child: G[node]){
            f(child, G, res);
            res[node] += res[child];
        }
    }
    
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        const int N = p.size();
        Graph G(N);
        for(int i = 1; i < N; ++i){
            G[p[i]].push_back(i);
        }
        
        vector<int> lastNodeOf(A, INF);
        vector<int> newParent(N, INF);
        dfs(0, lastNodeOf, G, s, newParent);
        
        for(int i = 0; i < N; ++i){
            //cout << i << "" "" << newParent[i] << endl;
            if(newParent[i] == INF){
                newParent[i] = p[i];
            }
        }
        
        Graph newG(N);
        for(int i = 1; i < N; ++i){
            newG[newParent[i]].push_back(i);
        }
        
        vector<int> res(N);
        f(0, newG, res);
        
        return res;
    }
};",1434290249
Tudor Buzu,Tudor67,463,3587,cpp,"class Solution {
private:
    const int INF = 1e9;
    
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<vector<int>> dp(k, vector<int>(n, -INF));
        dp[0] = ss[0];
        for(int dest = 0; dest < n; ++dest){
            for(int src = 0; src < n; ++src){
                dp[0][dest] = max(dp[0][dest], ts[src][dest]);
            }
        }
        
        for(int day = 1; day < k; ++day){
            for(int i = 0; i < n; ++i){
                for(int j = 0; j < n; ++j){
                    dp[day][i] = max(dp[day][i], max(dp[day - 1][i] + ss[day][i], dp[day - 1][j] + ts[j][i]));
                }
            }
        }
        /*
        for(int j = 0; j < k; ++j){
            for(int i = 0; i < n; ++i){
                cout << dp[j][i] << "" "";
            }
            cout << endl;
        }
        */
        return *max_element(dp[k - 1].begin(), dp[k - 1].end());
    }
};",1434326078
Tudor Buzu,Tudor67,463,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        const int N = s.length();
        
        int res = 1;
        int prevChar = s[0] + 1;
        for(char c: s){
            if(prevChar == c){
                res += 1;
            }
            prevChar = c;
        }
        
        return res;
    }
};",1434263065
AccelSprinter,akokoz,464,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        List<Set<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new HashSet<>());
        }
        for (int i = 1; i < n; i++) {
            adj.get(parent[i]).add(i);
            adj.get(i).add(parent[i]);
        }
        int[] parent2 = Arrays.copyOf(parent, n);
        int[] anc = new int[26];
        Arrays.fill(anc, -1);
        // System.out.println(adj);
        dfs(-1, 0, adj, s, parent2, anc);
        // System.out.println(Arrays.toString(parent2));
        for (int i = 1; i < n; i++) {
            // System.out.println(i);
            if (parent[i] != parent2[i]) {
                adj.get(parent[i]).remove(i);
                adj.get(i).remove(parent[i]);
                // System.out.printf(""parent2[i]=%s, i=%s%n"", parent2[i], i);
                adj.get(parent2[i]).add(i);
                adj.get(i).add(parent2[i]);
            }
        }
        int[] size = new int[n];
        dfs2(-1, 0, adj, size);
        return size;
    }
    
    void dfs(int par, int at, List<Set<Integer>> adj, String s, int[] parent2, int[] anc) {
        if (anc[s.charAt(at) - 'a'] != -1) {
            parent2[at] = anc[s.charAt(at) - 'a'];
        }
        anc[s.charAt(at) - 'a'] = at;
        for (int next : adj.get(at)) {
            if (par == next) continue;
            int[] anc2 = Arrays.copyOf(anc, anc.length);
            dfs(at, next, adj, s, parent2, anc2);
        }
    }
    void dfs2(int par, int at, List<Set<Integer>> adj, int[] size) {
        size[at] = 1;
        for (int next : adj.get(at)) {
            if (par == next) continue;
            dfs2(at, next, adj, size);
            size[at] += size[next];
        }
    }
}",1434309024
AccelSprinter,akokoz,464,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[] dp = new int[n];
        for (int d = 0; d < k; d++) {
            int[] ndp = new int[n];
            for (int from = 0; from < n; from++) {
                for (int to = 0; to < n; to++) {
                    if (from == to) {
                        ndp[to] = Math.max(ndp[to], dp[to] + stayScore[d][to]);
                    } else{
                        ndp[to] = Math.max(ndp[to], dp[from] + travelScore[from][to]);
                    }
                }
            }
            dp = ndp;
        }
        int ans = 0;
        for (int cand : dp) ans = Math.max(ans, cand);
        return ans;
    }
}",1434326246
AccelSprinter,akokoz,464,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        int n = word.length();
        for (int i = 0; i < n;) {
            int j = i;
            while (j < n && word.charAt(j) == word.charAt(i)) {
                j++;
            }
            ans += (j - i) - 1;
            i = j;
        }
        return ans;
    }
}",1434271622
rath772k,rath772k,465,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        for i in range(1, n):
            adj[parent[i]].append(i)
        
        char = defaultdict(list)
        new_adj = [[] for _ in range(n)]
        def dfs(v):
            if len(char[s[v]]):
                new_adj[char[s[v]][-1]].append(v)
            else:
                if parent[v] != -1:
                    new_adj[parent[v]].append(v)
            char[s[v]].append(v)
            for to in adj[v]:
                dfs(to)
            char[s[v]].pop()
        
        dfs(0)
        ans = [0] * n
        def dfs2(v):
            ans[v] += 1
            for to in new_adj[v]:
                dfs2(to)
                ans[v] += ans[to]
        dfs2(0)
        return ans
                
            ",1434301189
rath772k,rath772k,465,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @cache
        def f(cur, idx):
            if idx == k:
                return 0
            ans = stayScore[idx][cur] + f(cur, idx+1)
            for dest in range(n):
                ans = max(ans, travelScore[cur][dest] + f(dest, idx+1))
            return ans
        return max(f(i, 0) for i in range(n))",1434319288
rath772k,rath772k,465,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        cnt = []
        left = 0
        right = 0
        while right < n:
            while right < n and word[right] == word[left]:
                right += 1
            cnt.append(right-left)
            left = right
        
        return 1 + sum([cur-1 for cur in cnt])",1434287924
Chris Ho,Chris_ho,466,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        for i in range(1, n):
            tree[parent[i]].append(i)
        new_parent = parent.copy()
        label_stack = {}
        def dfs(node):
            label = s[node]
            if label not in label_stack:
                label_stack[label] = []
            if label_stack[label]:
                y = label_stack[label][-1]
                if y != parent[node]:
                    new_parent[node] = y
            label_stack[label].append(node)
            for child in tree[node]:
                dfs(child)
            label_stack[label].pop()
        dfs(0)
        new_tree = [[] for _ in range(n)]
        for i in range(n):
            if new_parent[i] != -1:
                new_tree[new_parent[i]].append(i)
        sizes = [0]*n
        def compute_sizes(node):
            size = 1
            for child in new_tree[node]:
                size += compute_sizes(child)
            sizes[node] = size
            return size
        compute_sizes(0)
        return sizes",1434290646
Chris Ho,Chris_ho,466,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stay: List[List[int]], move: List[List[int]]) -> int:
        dp = [[float('-inf')]*n for _ in range(k)]
        for j in range(n):
            dp[0][j] = max(stay[0][j], max([move[i][j] for i in range(n) if i != j] + [float('-inf')]))
        for d in range(1, k):
            for j in range(n):
                s = dp[d-1][j] + stay[d][j]
                m = max([dp[d-1][i] + move[i][j] for i in range(n) if i != j] + [float('-inf')])
                dp[d][j] = max(s, m)
        return max(dp[k-1])
",1434296721
Chris Ho,Chris_ho,466,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        l = [(c, len(list(g))) for c, g in groupby(word)]
        l1 = [y for x,y in l]
        return 1+sum(y-1 for y in l1)",1434267901
Mukul Kumar,hqbbQz9S8n,467,3576,python,"from collections import defaultdict

class Solution(object):
    def findSubtreeSizes(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[int]
        """"""
        n = len(parent)
        
        # Step 1: Build initial tree adjacency list
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        # Step 2: Reparent nodes based on closest matching ancestor
        new_parent = parent[:]  # Clone of the parent list for tracking new parents
        new_tree = defaultdict(list)  # New tree structure after reparenting
        ancestor_map = defaultdict(list)  # Map to track ancestors for each character
        subtree_sizes = [0] * n  # Array to store the size of each subtree

        def dfs(node):
            # Find the closest ancestor with the same character
            char = s[node]
            if ancestor_map[char]:  # Check if there's an ancestor with the same character
                closest_ancestor = ancestor_map[char][-1]
                new_parent[node] = closest_ancestor  # Update the new parent of node

            # Add node to its new parent's children in new_tree
            if new_parent[node] != -1:
                new_tree[new_parent[node]].append(node)

            # Push the current node to the ancestor stack for its character
            ancestor_map[char].append(node)
            
            # Recursively visit all children in the initial tree structure
            for child in tree[node]:
                dfs(child)
            
            # Calculate the subtree size for the current node
            subtree_sizes[node] = 1 + sum(subtree_sizes[child] for child in new_tree[node])
            
            # Remove the current node from the ancestor stack after processing
            ancestor_map[char].pop()

        # Start DFS from the root node (node 0)
        dfs(0)
        
        return subtree_sizes
",1434265790
Mukul Kumar,hqbbQz9S8n,467,3587,python,"class Solution(object):
    def maxScore(self, n, k, stayScore, travelScore):
        """"""
        :type n: int
        :type k: int
        :type stayScore: List[List[int]]
        :type travelScore: List[List[int]]
        :rtype: int
        """"""
        dp=[[float('-inf')] * n for _ in range(k)]

        for city in range(n):
            dp[0][city] = stayScore[0][city]
            for start in range(n):
                dp[0][city] = max(dp[0][city], travelScore[start][city])

        for day in range(1, k):
            maxPrevDay = [max(dp[day-1][p] + travelScore[p][j] for p in range(n)) for j in range(n)]
        
            for city in range(n):
                dp[day][city] = max(dp[day-1][city] + stayScore[day][city], maxPrevDay[city])

        return max(dp[k-1])

    
        



        

",1434319387
Mukul Kumar,hqbbQz9S8n,467,3617,python,"class Solution(object):
    def possibleStringCount(self, word):
        """"""
        :type word: str
        :rtype: int
        """"""
        groups = []
        i = 0

        # Step 1: Group consecutive characters
        while i < len(word):
            j = i
            while j < len(word) and word[j] == word[i]:
                j += 1
            groups.append(j - i)  # Length of each group of repeated characters
            i = j

        # Step 2: Calculate the total possible originals
        # Start with the original string itself as one possibility
        total_possibilities = 1
        
        # Add the possibilities if each group could have been an overtyped error
        for group_len in groups:
            total_possibilities += group_len - 1  # Each group can reduce by up to (group_len - 1)

        return total_possibilities",1434259855
volodymyr_k,volodymyr_k,469,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        List<Integer>[] adj = build(parent, n);
        
        int[] next = new int[n];
        Arrays.fill(next, -2);
        
        Map<Character, Integer> map = new HashMap<>();
        dfs(0, -3, adj, s, next, map);
        
        for (int i = 0; i < n; i++) {
            if (next[i] == -2) next[i] = parent[i];
        }
        
        //System.out.println(Arrays.toString(next));

        List<Integer>[] adj2 = build(next, n);
        
        int[] res = new int[n];
        dfs2(0, -3, adj2, res);
        
        return res;
    }
    
    private int dfs2(int at, int parent, List<Integer>[] adj, int[] res) {
        int c = 1;
        
        for (int child : adj[at]) {
            if (child == parent) continue;
            
            c += dfs2(child, at, adj, res);
        }
        
        res[at] = c;
        
        return c;
    }
    
    private void dfs(int at, int parent, List<Integer>[] adj, String s, int[] next, Map<Character, Integer> map) {
        char c = s.charAt(at);
        
        Integer prev = map.remove(c);
        
        if (prev != null) {
            next[at] = prev;
        }
        
        map.put(c, at);
        
        for (int child : adj[at]) {
            if (child == parent) continue;
            
            dfs(child, at, adj, s, next, map);
        }
        
        if (prev == null) map.remove(c);
        else map.put(c, prev);
    }
    
    private List<Integer>[] build(int[] parent, int n) {
        List<Integer>[] adj = new List[n];
        
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            if (parent[i] == -1) continue;
            
            int p = parent[i], c = i;
            
            adj[p].add(c);
            adj[c].add(p);
        }
        
        return adj;
    }
}",1434311895
volodymyr_k,volodymyr_k,469,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] tr) {
        int[] dp = new int[n];
        
        for (int day = 0; day < k; day++) {
            int[] st = stayScore[day];
            
            int[] next = new int[n];
            
            for (int i = 0; i < n; i++) {
                next[i] = Math.max(next[i], dp[i] + st[i]);
            }
            
            
            for (int at = 0; at < n; at++) {
                for (int to = 0; to < n; to++) {
                    next[to] = Math.max(next[to], dp[at] + tr[at][to]);
                }
            }
            
            dp = next;
        }
        
        int res = 0;
        
        for (int v : dp) res = Math.max(res, v);
        
        return res;
    }
}",1434326366
volodymyr_k,volodymyr_k,469,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int res = 1, cur = 0;
        char prev = '0';
        
        for (char c : word.toCharArray()) {
            if (c == prev) cur++;
            else {
                if (cur != 0) res += cur - 1;
                cur = 1;
                prev = c;
            }
        }
        
        res += cur - 1;
        return res;
    }
}",1434269418
Husain Batterywala,husain2088,470,3576,cpp,"class Solution {

void dfs(char lt, int ind, vector<vector<int>> &child, int anc, string &s, vector<int> &newpar){

    if(s[ind]==lt){
        if(anc!=-1){
            newpar[ind] = anc;
        }
        anc = ind;
    }
    
    for(auto it : child[ind]){
        dfs(lt, it, child, anc, s, newpar);
    }

    return;
    
}

int dfs2(int ind, vector<int> &dp, vector<vector<int>> &child){

    int tot = 1;
    for(auto it : child[ind]){
        tot += dfs2(it, dp, child);
    }

    dp[ind]=tot;
    return tot;
    
}


public:

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {

        int n = parent.size();

        vector<int> newpar(n, -1);
        vector<vector<int>> child(n);
        for(int i=1; i<n; i++){
            child[parent[i]].push_back(i);
        }
        
        for(int i=0; i<26; i++){
            vector<int> vis(n, 0);
            char c = i+'a';
            dfs(c, 0, child, -1, s, newpar);
        }
        
        // for(int i=0; i<n; i++) {
        //     cout<<newpar[i]<<""/""<<parent[i]<<"" "";
        // }
        // cout<<""\n"";

        for(int i=1; i<n; i++){
            if(newpar[i]==-1){
                newpar[i]=parent[i];
            }
        }

        vector<vector<int>> ch2(n);
        for(int i=1; i<n; i++){
            ch2[newpar[i]].push_back(i);
        }

        vector<int> dp(n, 0);
        dfs2(0, dp, ch2);

        return dp;
        
    }

};",1434304789
Husain Batterywala,husain2088,470,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {

        vector<int> dp1(n, 0);

        for(int day=0; day<k; day++){

            vector<int> dp2(n, 0);
            for(int i=0; i<n; i++){

                for(int j=0; j<n; j++){

                    if(i==j){
                        dp2[i] = max(dp2[i], dp1[i] + stayScore[day][i]);
                    }
                    else{
                        dp2[j] = max(dp2[j], dp1[i] + travelScore[i][j]);
                    }
                    
                }
                
            }

            dp1 = dp2;
            
        }

        int ans = 0;
        for(int i=0; i<n; i++) ans = max(ans, dp1[i]);

        return ans;
        
    }
};",1434319414
Husain Batterywala,husain2088,470,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {

        int n = word.size();
        int ans = 1;
        for(int i = 1; i<n; i++){
            if(word[i]==word[i-1]){
                ans++;
            }
        }

        return ans;
        
    }
};",1434261751
Vineet Mittal,Vineet_mittal_007,471,3576,cpp,"class Solution {
public:
    void recurs(int i,vector<vector<int>>&v,string& s,vector<int>&cha,vector<int>&parent){
        char temp=s[i];
        int y=cha[temp-'a'];
        cha[temp-'a']=i;
        for(auto x:v[i]){
            recurs(x,v,s,cha,parent);
        }
        if(y!=-1){
            parent[i]=y;
        }
        cha[temp-'a']=y;
    }
    void dfs(vector<int> ans [],int i,vector<int>&u){
        // u[i]=1;
        for(auto x:ans[i]){
            dfs(ans,x,u);
            u[i]+=u[x];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        vector<vector<int>>v(n);
        for(int i=0;i<parent.size();i++){
            if(parent[i]!=-1) 
            v[parent[i]].push_back(i);
        }
        vector<int>cha(26,-1);
        recurs(0,v,s,cha,parent);
        vector<int>ans[n];
        for(int i=0;i<parent.size();i++){
            if(parent[i]!=-1)
            ans[parent[i]].push_back(i);
        }
        vector<int>u(parent.size(),1);
        dfs(ans,0,u);
        return u;
    }
};",1434326386
Vineet Mittal,Vineet_mittal_007,471,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int dfs(int cur_c,int cur_d,int n,int k,vector<vector<int>>& stayScore,vector<vector<int>>& travelScore){
        if(cur_d==k) return 0;
        if(dp[cur_c][cur_d]!=-1) return dp[cur_c][cur_d];
        int ans=0;
        ans=max(ans,stayScore[cur_d][cur_c]+dfs(cur_c,cur_d+1,n,k,stayScore,travelScore));
        for(int j=0;j<n;j++){
            ans=max(ans,travelScore[cur_c][j]+dfs(j,cur_d+1,n,k,stayScore,travelScore));
        }
        return dp[cur_c][cur_d]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp,-1,sizeof(dp));
        int ans=0;
        for(int j=0;j<n;j++){
            ans=max(ans,dfs(j,0,n,k,stayScore,travelScore));
        }
        return ans;
    }
};",1434292455
Vineet Mittal,Vineet_mittal_007,471,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count=1;
        int i=0;
        while(i<word.length()){
            char e=word[i];
            int temp=0;
            i++;
            while(i<word.length() and word[i]==e){
                i++;
                temp++;
            }
            count+=temp;
        }
        return count;
    }

};",1434277248
JosephMother,JosephMother,472,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        g = defaultdict(list)

        for i, par in enumerate(parent):
            g[par].append(i)

        def dfs(root, a):
            
            if s[root] in a:
                parent[root] = a[s[root]]
            # print(a, root)
            a[s[root]] = root

            for node in g[root]:
                dfs(node, a.copy())

        dfs(0, {})
        g = defaultdict(list)
        res = [0 for let in s]
        for i, par in enumerate(parent):
            g[par].append(i)
        # print(g)
        # print(res)
        def size(root):
            r = 1

            for node in g[root]:
                r += size(node)
            # print(root, res)
            res[root] = r
            return r

        size(0)
        return res

        
            
        ",1434299236
JosephMother,JosephMother,472,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:


        @cache
        def dp(i, j):

            if j == k:
                return 0

            ss = stayScore[j][i] + dp(i, j+1)

            ts = 0
            for m in range(n):
                if m == i:
                    continue
                ts = max(ts, dp(m, j+1) + travelScore[i][m])

            return max(ss, ts)

        res = 0
        for l in range(n):
            res = max(res, dp(l, 0))

        return res
            ",1434312186
JosephMother,JosephMother,472,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:

        last = """"
        res = 0
        for let in word:
            if let  == last:
                res += 1
            last = let

        return res + 1
        ",1434270936
Henry Nguyen,HenryNguyen101,475,3576,cpp,"class Solution {
public:
    vector<vector<int>> mp;
    vector<int> res;

    int findDepth(int root){
        int depth = 1;
        for(int child: mp[root]){
            depth += findDepth(child);
        }
        res[root] = depth;
        return depth;
    }

    void updateParent(vector<int>& parent, vector<int> latestIndex, int root, const string& s){
        if(latestIndex[s[root] - 'a'] != -1){
            parent[root] = latestIndex[s[root] - 'a'];
        }
        latestIndex[s[root] - 'a'] = root;
        for(int child: mp[root]){
            updateParent(parent, latestIndex, child, s);
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, const string& s) {
        int sz = parent.size();
        res = vector<int>(sz);
        mp = vector<vector<int>>(sz);
        vector<int> latestIndex(26, -1);
        
        for(int i=1; i<sz; ++i) mp[parent[i]].push_back(i);
        
        updateParent(parent, latestIndex, 0, s);
        mp.clear();
        mp = vector<vector<int>>(sz);
        for(int i=1; i<sz; ++i) {
            // cout << parent[i] << "" "";
            mp[parent[i]].push_back(i);
        }
        findDepth(0);
        
        return res;
    }
};",1434306084
Henry Nguyen,HenryNguyen101,475,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int res = 0;
        int dp[k+1][n];
        memset(dp, 0, sizeof(dp));

        for(int i=1; i<=k; ++i){
            for(int j=0; j<n; ++j){
                for(int k=0; k<n; ++k){
                    if(j == k) dp[i][j] = max(dp[i][j], dp[i-1][k] + stayScore[i-1][k]);
                    else dp[i][j] = max(dp[i][j], dp[i-1][k] + travelScore[k][j]);
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};
/*
stayScore is a k * n array
travelScore is a n * n array
*/",1434326808
Henry Nguyen,HenryNguyen101,475,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        char prev = ' ';
        int cont = 0;
        for(auto s: word){
            if(s != prev){
                if(cont > 1) res += cont - 1;
                cont = 0;
            }
            prev = s;
            cont++;
        }
        if(cont > 1) res += cont - 1;
        cout << cont << endl;
        return res;
    }
};",1434269753
Juan Bustos,alcorzb,476,3576,cpp,"class Solution {
public:
    int last[26];

    vector<int> T[100005];
    vector<int> T2[100005];
    int sizes[100005];

    void update_parents(vector<int>& parent, string& s, int root) {
        if (last[s[root] - 'a'] != -1) {
            parent[root] = last[s[root] - 'a'];
        }
        int before = last[s[root] - 'a'];
        last[s[root] - 'a'] = root;
        for (int i = 0; i < T[root].size(); i++) {
            update_parents(parent, s, T[root][i]);
        }
        last[s[root] - 'a'] = before;
    }

    int fill_sizes(int root) {
        int sz = 1;
        for (int i = 0; i < T2[root].size(); i++) {
            sz += fill_sizes(T2[root][i]);
        }
        return sizes[root] = sz;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        for (int i = 0; i < 26; i++)
            last[i] = -1;
        for (int i = 1; i < parent.size(); i++) {
            T[parent[i]].push_back(i);
        }
        vector<int> new_parent = parent;
        update_parents(new_parent, s, 0);
        for (int i = 1; i < new_parent.size(); i++) {
            T2[new_parent[i]].push_back(i);
        }
        fill_sizes(0);
        vector<int> ans;
        for (int i = 0; i < parent.size(); i++)
            ans.push_back(sizes[i]);
        return ans;
    }
};",1434305090
Juan Bustos,alcorzb,476,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int N, K;
    int rec(int day, int cur, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        if (day == K)
            return 0;
        if (dp[day][cur] != -1)
            return dp[day][cur];
        int ma = -1;
        for (int i = 0; i < N; i++) {
            if (cur == i) {
                ma = max(ma, stayScore[day][cur] + rec(day + 1, cur, stayScore, travelScore));
            } else {
                ma = max(ma, travelScore[cur][i] + rec(day + 1, i, stayScore, travelScore));
            }
        }
        return dp[day][cur] = ma;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        N = n;
        K = k;
        int ma = -1;
        for (int i = 0; i < 201; i++)
            for (int j = 0; j < 201; j++)
                dp[i][j] = -1;
        for (int i = 0; i < n; i++)
            ma = max(ma, rec(0, i, stayScore, travelScore));
        return ma;
    }
};",1434319920
Juan Bustos,alcorzb,476,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int c = 0;
        for (int i = 0; i < word.size() - 1; i++) {
            if (word[i] == word[i + 1])
                c++;
        }
        return c + 1;
    }
};",1434262495
Hasnain Ahmed,Hassu083,477,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = defaultdict(set)
        for i in range(1, n):
            tree[parent[i]].add(i)
        
        
        change = defaultdict(set)
        visited = set()
        
        def dfs(node, parent, p_close):
            if s[node] in p_close and p_close[s[node]] != parent:
                change[p_close[s[node]]].add(node)
                visited.add(node)
            
            before = p_close.get(s[node], None)
            p_close[s[node]] = node
            
            for child in tree[node]:
                dfs(child, node, p_close)
            
            if before == None:
                del(p_close[s[node]])
            else:
                p_close[s[node]] = before
            
        dfs(0, -1, {})
        
        ans = [0]*n
        
        def size(node):
            
            size_ = 1
            for child in tree[node]:
                if child not in visited:
                    size_ += size(child)
            for child in change[node]:
                size_ += size(child)
            
            ans[node] = size_
            return size_
            
        size(0)
        
        # print(change)
        
        return ans
                ",1434301091
Hasnain Ahmed,Hassu083,477,3587,python3,"class Solution:
    def maxScore(self, n: int, days: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @lru_cache(None)
        def dp(i, j):
            if j == days:
                return 0
            ans = 0
            for k in range(n):
                if i == k:
                    ans = max(ans,  stayScore[j][i] + dp(i, j+1))
                else:
                    ans = max(ans,  travelScore[i][k] + dp(k, j+1))
            return ans
        
        ans = 0
        for i in range(n):
            ans = max(ans,  max(stayScore[0][i], max(travelScore[j][i] for j in range(n))) + dp(i, 1))
            
        return ans
        ",1434319971
Hasnain Ahmed,Hassu083,477,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        
        n = len(word)
        ans = 0
        i = 0
        while i < n:
            j = i
            while j < n and word[i] == word[j]:
                j += 1
            if j - i > 1:
                ans += j - i - 1
            i = j
        return ans + 1
        ",1434265747
aU34W6Rgdb,aU34W6Rgdb,478,3576,python3,"class Solution:
    def findSubtreeSizes(self, p: List[int], s: str) -> List[int]:
        n = len(p)
        t = defaultdict(list)
        ch_anc = defaultdict(list)
        
        for c, par in enumerate(p):
            if par != -1:
                t[par].append(c)

        new_p = p[:]

        def dfs_anc(node):
            ch = s[node]
            ch_anc[ch].append(node)

            if len(ch_anc[ch]) > 1:
                new_p[node] = ch_anc[ch][-2]

            for child in t[node]:
                dfs_anc(child)

            ch_anc[ch].pop()

        dfs_anc(0)

        mod_t = defaultdict(list)
        for i in range(1, n):
            mod_t[new_p[i]].append(i)

        sz = [0] * n

        def dfs_sz(node):
            size = 1
            for child in mod_t[node]:
                size += dfs_sz(child)
            sz[node] = size
            return size

        dfs_sz(0)

        return sz
",1434312671
aU34W6Rgdb,aU34W6Rgdb,478,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @lru_cache(None)
        def solve(currDay, currCity):
            if currDay==k:
                return 0
            ans = solve(currDay+1, currCity) + stayScore[currDay][currCity]
            for dest in range(n):
                ans = max(ans, solve(currDay+1, dest) + travelScore[currCity][dest])
            return ans
        res =0 
        for i in range(n):
            res = max(res, solve(0, i))
        return res

    
            ",1434299782
aU34W6Rgdb,aU34W6Rgdb,478,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans =0 
        i =0 
        n = len(word)
        while i<n:
            curr = word[i]
            cnt =0 
            while i<n and curr==word[i]:
                cnt+=1
                i+=1
            ans+=cnt-1
        return ans+1",1434262094
Siva Murugan,Siva_Murugan,480,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for(int i=0;i<parent.length;i++){
            adj.add(new ArrayList<Integer>());
        }
        for(int i=1;i<parent.length;i++){
            adj.get(parent[i]).add(i);
        }
        int[] closest = new int[26];
        for(int i=0;i<26;i++)closest[i] = -1;
        dfs(adj,0,closest,s,parent);
        
        int[] ans = new int[parent.length];
        adj = new ArrayList<>();
        for(int i=0;i<parent.length;i++){
            adj.add(new ArrayList<Integer>());
        }
        for(int i=1;i<parent.length;i++){
            adj.get(parent[i]).add(i);
        }
        getSize(adj,ans,0);
        return ans;
    }
    
    public void dfs(ArrayList<ArrayList<Integer>> adj,int curr,int[] closest,String s,int[] parent){
        if(closest[s.charAt(curr)-'a'] != -1){
            parent[curr] = closest[s.charAt(curr)-'a'];    
        }
        int temp = closest[s.charAt(curr)-'a'];
        closest[s.charAt(curr)-'a'] = curr;
        for(int next : adj.get(curr)){
            dfs(adj,next,closest,s,parent);
        }
        closest[s.charAt(curr)-'a'] = temp;
    }
    
    public int getSize(ArrayList<ArrayList<Integer>> adj,int[] size,int curr){
        int count = 1;
        for(int next : adj.get(curr)){
            count += getSize(adj,size,next);
        }
        size[curr] = count;
        return count;
    }
}",1434307844
Siva Murugan,Siva_Murugan,480,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int ans = 0;
        int[][] dp = new int[n][k];
        for(int i=0;i<dp.length;i++){
            for(int j=0;j<dp[0].length;j++){
                dp[i][j] = -1;
            }
        }
        for(int i=0;i<n;i++){
            ans = Math.max(ans,dfs(i,0,n,k,stayScore,travelScore,dp));
        }
        return ans;
    }
    
    public int dfs(int city,int day,int n,int k,int[][] stay,int[][] travel,int[][] dp){
        if(day == k)return 0;
        if(dp[city][day] != -1)return dp[city][day];
        int ans = 0;
        for(int i=0;i<n;i++){
            int score = 0;
            if(i == city)score = stay[day][city]; 
            else score = travel[city][i];
            ans = Math.max(ans,score + dfs(i,day +1,n,k,stay,travel,dp));
        }
        dp[city][day] = ans;
        return ans;
    }
}",1434327081
Siva Murugan,Siva_Murugan,480,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        
        int count = 0;
        char prev = '#';
        for(char c : word.toCharArray()){
            if(c == prev){
                count++;
            }
            prev = c;
        }
        
        return count + 1;
    }
}",1434266864
Adwaya Gupta,AG-88301,481,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        adj = defaultdict(set)
        for i in range(len(parent)):
            if parent[i] == -1:
                continue
            adj[parent[i]].add(i)
        
        def dfs(n, seen):
            if s[n] in seen:
                parent[n] = seen[s[n]]

            news = {i:seen[i] for i in seen}
            news[s[n]] = n
            for i in adj[n]:
                dfs(i, news)

        dfs(0, {})
        
        adj = defaultdict(set)
        for i in range(len(parent)):
            if parent[i] == -1:
                continue
            adj[parent[i]].add(i)

        ans = [0]*len(parent)
        def dfs2(n):
            for i in adj[n]:
                ans[n] += 1 + dfs2(i)
            return ans[n]
        dfs2(0)
        return [i+1 for i in ans] ",1434291603
Adwaya Gupta,AG-88301,481,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1] * (n) for _ in range(k+1)] 
        # dp[day][city] = maxscore

        for i in range(len(dp[0])): dp[0][i] = 0

        for day in range(k): 
            for currCity in range(n):
                for nxtCity in range(n):
                    if currCity == nxtCity:
                        dp[day+1][nxtCity] = max(dp[day+1][nxtCity], dp[day][currCity] + stayScore[day][currCity])
                    else:
                        dp[day+1][nxtCity] = max(dp[day+1][nxtCity], dp[day][currCity] + travelScore[currCity][nxtCity])
        
        return max(dp[-1])",1434312806
Adwaya Gupta,AG-88301,481,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        
        x = []
        last = """"
        for char in word:
            if char != last:
                x.append(char)
                last = char
            else:
                x[-1] += char
        
        for char in x:
            ans += len(char) - 1
        return ans
            ",1434264530
F4ll3n On3,KartikDotDev,482,3576,cpp,"class Solution {
private:
    int n;
    vector<vector<int>> og_tree;
    vector<vector<int>> new_tree;
    vector<int> new_parent, ans;
    string cs;
    int lastOcc[26];

    void assignNewParents(int node) {
        char cur_char = cs[node];
        int char_idx = cur_char - 'a';
        int prev = lastOcc[char_idx];

        if(prev != -1) new_parent[node] = prev;

        lastOcc[char_idx] = node;

        for(auto& child: og_tree[node]) {
            assignNewParents(child);
        }

        lastOcc[char_idx] = prev;
    }

    int calcSubtreeHeight(int node) {
        ans[node] = 1;
        for(auto& child : new_tree[node]) {
            ans[node] += calcSubtreeHeight(child);
        }
        return ans[node];
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = parent.size();
        cs = s;
        og_tree.assign(n, vector<int>());
        new_tree.assign(n, vector<int>());
        new_parent = parent;
        ans.assign(n, 0);

        for(int i = 1; i < n; i++) {
            og_tree[parent[i]].push_back(i);
        }

        for(int i = 0; i < 26; i++) {
            lastOcc[i] = -1;
        }

        assignNewParents(0);

        for(int i = 0; i < n; i++) {
            if(new_parent[i] != -1) new_tree[new_parent[i]].push_back(i);
        }

        calcSubtreeHeight(0);

        return ans;
    }
};",1434310829
F4ll3n On3,KartikDotDev,482,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp_prev(n, 0);

        for(int d = 0; d < k; d++) {
            vector<int> dp_cur(n, 0);

            for(int c = 0; c < n; c++) {
                int op1 = dp_prev[c] + stayScore[d][c];
                int op2 = INT_MIN;

                for(int c_prev = 0; c_prev < n; c_prev++) {
                    if(c_prev != c) op2 = max(op2, dp_prev[c_prev] + travelScore[c_prev][c]);
                }

                if(op2 == INT_MIN) dp_cur[c] = op1;
                else dp_cur[c] = max(op2, op1);
            }
            dp_prev = dp_cur;
        }

        int result = INT_MIN;

        for(int c = 0; c < n; c++) result = max(result, dp_prev[c]);

        return result;
    }
};",1434327225
F4ll3n On3,KartikDotDev,482,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        if(word.size() == 0) return 0;

        vector<int> group_counts;
        char cur_char = word[0];
        int count = 1;

        for(int i = 1; i < word.size(); i++) {
            if(word[i] == cur_char) count++;
            else {
                group_counts.push_back(count);
                cur_char = word[i];
                count = 1;
            }
        }
        group_counts.push_back(count);

        int sum = 0; 
        for(auto& cnt: group_counts) sum += cnt-1;

        return sum + 1;
    }
};",1434270310
Gopal Gupta,gupta_gopal,483,3576,cpp,"class Solution {
public:
    void dfs(int cur,int cur_par,vector<int>v[],vector<int>&match,string& s,vector<int>& par){
        int prev=match[s[cur]-'a'];
        match[s[cur]-'a']=cur;
        for(auto i:v[cur]){
            if(i==cur_par) continue;
            dfs(i,cur,v,match,s,par);
            if(match[s[i]-'a']!=-1){
                par[i]=match[s[i]-'a'];
            }
        }
        match[s[cur]-'a']=prev;
    }
    
    void dfs_cnt(int cur,int par,vector<int>v[],vector<int>&ans){
        for(auto i:v[cur]){
            if(i==par) continue;
            dfs_cnt(i,cur,v,ans);
            ans[cur]+=ans[i];
        }
    }
    
    vector<int> findSubtreeSizes(vector<int>& par,string s){
        int n=par.size();
        vector<int>v[n],upd_v[n];
        for(int i=1;i<n;i++){
            v[i].push_back(par[i]);
            v[par[i]].push_back(i);                        
        }
        vector<int>match(26,-1);
        vector<int>ans(n,1);
        dfs(0,-1,v,match,s,par);
        
        for(int i=1;i<n;i++){
            upd_v[i].push_back(par[i]);
            upd_v[par[i]].push_back(i);                        
        }
        dfs_cnt(0,-1,upd_v,ans);
        return ans;
    }
};


// [-1,10,0,12,10,18,11,12,2,3,2,2,2,0,4,11,4,2,0]
// ""babadabbdabcbaceeda""

// [19,1,15,2,3,1,1,1,1,1,5,2,4,1,1,1,1,1,2]",1434304759
Gopal Gupta,gupta_gopal,483,3587,cpp,"class Solution {
public:
    int solve(int day,int city,int n, int k, vector<vector<int>>& s,vector<vector<int>>& t,vector<vector<int>>&dp){
        if(day==k) return 0;
        if(dp[day][city]!=-1) return dp[day][city];
        for(int i=0;i<n;i++){
            if(i==city){
                dp[day][city]=max(dp[day][city],s[day][city]+solve(day+1,city,n,k,s,t,dp));
            }
            else{
                dp[day][city]=max(dp[day][city],t[city][i]+solve(day+1,i,n,k,s,t,dp));
            }
        }
        return dp[day][city];
    }

        int maxScore(int n, int k, vector<vector<int>>& s,vector<vector<int>>& t){
        vector<vector<int>>dp(k,vector<int>(n,-1));
        int ans=0;
        for(int i=0;i<n;i++) ans=max(ans,solve(0,i,n,k,s,t,dp));
        return ans;
    }
};",1434320269
Gopal Gupta,gupta_gopal,483,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s){
        int ans=0,cnt=1;
        char prev=s[0];
        for(int i=1;i<s.size();i++){
            if(s[i]==prev) cnt++;
            else ans+=cnt-1,cnt=1,prev=s[i];
        }
        return ans+1+(cnt-1);
    }
};",1434261350
Abhijit Manna,abhijitmanna912001,484,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        vector<int> subtree_size(n, 1);

        for(int i = 1; i < n; i++)
            adj[parent[i]].push_back(i);

        vector<int> new_parent = parent;
        unordered_map<char, stack<int>> last_seen;

        function<void(int)> dfs = [&](int node) {
            char c = s[node];
            if(last_seen[c].size() > 0)
                new_parent[node] = last_seen[c].top();
            last_seen[c].push(node);
            for(int child : adj[node])
                dfs(child);
            last_seen[c].pop();
        };
        dfs(0);

        vector<vector<int>> new_adj(n);
        for(int i = 1; i < n; i++)
            new_adj[new_parent[i]].push_back(i);

        function<int(int)> calcSubtreeSizes = [&](int node) {
            for (int child : new_adj[node]) {
                subtree_size[node] += calcSubtreeSizes(child);
            }
            return subtree_size[node];
        };
        calcSubtreeSizes(0);

        return subtree_size;
    }
};",1434295430
Abhijit Manna,abhijitmanna912001,484,3587,cpp,"class Solution {
public:
    int dfs(int day, int city, int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& memo) {
        if (day == k) return 0;

        if (memo[day][city] != -1) return memo[day][city];

        int maxScore = stayScore[day][city] + dfs(day + 1, city, n, k, stayScore, travelScore, memo);

        for (int nextCity = 0; nextCity < n; ++nextCity) {
            if (nextCity != city) {
                maxScore = max(maxScore, travelScore[city][nextCity] + dfs(day + 1, nextCity, n, k, stayScore, travelScore, memo));
            }
        }

        return memo[day][city] = maxScore;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> memo(k, vector<int>(n, -1));

        int maxPoints = 0;
        for (int startCity = 0; startCity < n; ++startCity) {
            maxPoints = max(maxPoints, dfs(0, startCity, n, k, stayScore, travelScore, memo));
        }

        return maxPoints;
    }
};",1434313118
Abhijit Manna,abhijitmanna912001,484,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) { 
        int totalCount = 1;
        int n = word.length();

        vector<int> groups;
        int i = 0;

        while(i < n) {
            char currChar = word[i];
            int count = 0;

            while(i < n && word[i] == currChar) {
                count++;
                i++;
            }
            groups.push_back(count);
        }

        for(int count : groups) {
            totalCount += count - 1;
        }

        return totalCount;
    }
};",1434268664
AKSH,dhingraaksh,485,3576,java,"class Solution {
    int [] ans;
    int n;
    List<List<Integer>> adj = new ArrayList<>();
    List<List<Integer>> nw = new ArrayList<>();
    public int[] findSubtreeSizes(int[] parent, String s) {
        n = parent.length;
        ans = new int[n];
        for(int i = 0;i<n;i++){
            adj.add(new ArrayList<>());
            nw.add(new ArrayList<>());
        }
        for(int i = 1;i<n;i++){
            adj.get(parent[i]).add(i);
        }
        int [] arr = new int[26];
        Arrays.fill(arr,-1);
        dfs(0,s,arr,-1);
        dfs1(0);
        return ans;
    }
    public void dfs(int root,String s, int[] arr,int p){
        int [] carr = Arrays.copyOf(arr,arr.length);
        if(carr[s.charAt(root)-'a'] == -1){
            carr[s.charAt(root)-'a'] = root;
            if(p!=-1)
            nw.get(p).add(root);
        }
        else{
            nw.get(carr[s.charAt(root)-'a']).add(root);
            carr[s.charAt(root)-'a'] = root;
        }
        for(int i : adj.get(root)){
            dfs(i,s,carr,root);
        }
    }
    public int dfs1(int root){
        int temp = 1;
        for(int i : nw.get(root)){
            temp += dfs1(i);
        }
        ans [root] = temp;
        return temp;
    }
}",1434320379
AKSH,dhingraaksh,485,3587,java,"class Solution {
    Integer [][] dp;
    public int maxScore(int n, int k, int[][] s, int[][] t) {
        dp = new Integer [k+1][n+1];
        int ans = 0;
        for(int i = 0;i<n;i++){
            ans = Math.max(ans,solve(n,k,0,i,s,t));
        }
        return ans;
    }
    public int solve(int n, int k, int i, int c, int[][] s, int [][] t){
        if(i == k) return 0;
        if(dp[i][c]!= null) return dp[i][c];
        int ans = s[i][c]+solve(n,k,i+1,c,s,t);
        for(int j = 0;j<n;j++){
            if(c!=j){
                int temp = t[c][j]+solve(n,k,i+1,j,s,t);
                ans = Math.max(ans,temp);
            }
        }
        return dp[i][c] = ans;
    }
}",1434302307
AKSH,dhingraaksh,485,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int count = 1;
        for(int i = 1;i<word.length();i++){
            if(word.charAt(i) == word.charAt(i-1))
                    count++;
        }
        return count;
    }
}",1434261823
Vlad,votrubac,486,3576,cpp,"class Solution {
public:
    vector<array<int, 3>> changes;
    void dfs(int i, int p, vector<unordered_set<int>> &al, string &s, vector<int> &pos) {
        int new_p = pos[s[i] - 'a'];
        if (new_p != -1 && new_p != p) {
            changes.push_back({i, p, new_p});
        }
        pos[s[i] - 'a'] = i;
        for (int j : al[i]) {
            dfs(j, i, al, s, pos);
        }
        pos[s[i] - 'a'] = new_p;        
    }
    int dfs1(int i, vector<unordered_set<int>> &al, vector<int> &res) {
        int size = 1;
        for (int j : al[i])
            size += dfs1(j, al, res);
        res[i] = size;
        return size;
    }
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        vector<unordered_set<int>> al(p.size());
        vector<int> res(p.size()), pos(26, -1);
        for (int i = 1; i < p.size(); ++i) {
            al[p[i]].insert(i);
        }
        dfs(0, -1, al, s, pos);
        for (auto [i, p, new_p] : changes) {
            // cout << ""Updating parent for "" << i << "" from "" << p << "" to "" << new_p << endl;
            al[p].erase(i);
            al[new_p].insert(i);
        }
        dfs1(0, al, res);
        return res;
    }
};",1434305045
Vlad,votrubac,486,3587,cpp,"class Solution {
public:
    int nn = 0;
    int dp[201][201] = {};
    int dfs(int cur, int i, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        if (i == k)
            return 0;
        if (dp[cur][i] == 0) {
            int res = ss[i][cur] + dfs(cur, i + 1, k, ss, ts);
            for (int dest = 0; dest < nn; ++dest)
                res = max(res, ts[cur][dest] + dfs(dest, i + 1, k, ss, ts));
            dp[cur][i] = res;
        }
        return dp[cur][i];
    }
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        int res = 0;
        nn = n;
        for (int cur = 0; cur < n; ++cur)
            res = max(res, dfs(cur, 0, k, ss, ts));
        return res;
    }
};",1434327552
Vlad,votrubac,486,3617,cpp,"class Solution {
public:
int possibleStringCount(string w) {
    int cnt = 1, res = 1;
    for (int i = 1; i <= w.size(); ++i) {
        if (i < w.size() && w[i] == w[i - 1]) {
            ++cnt;
        }
        else {
            res += cnt - 1;
            cnt = 1;
        }
        
    }
    return res;
}
};",1434263086
Vijay Shankar Kumar,vijayshankarkumar,487,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        new_parent = parent[:]  # This will store the updated parent relationships
        stack = defaultdict(list)  # Stack to keep track of last seen nodes for each character
        
        def dfs(node):
            char = s[node]
            if stack[char]:
                closest_ancestor = stack[char][-1]
                if closest_ancestor != node:
                    new_parent[node] = closest_ancestor
    
            # Update the stack to include the current node for the character
            stack[char].append(node)
            
            # Process the children of the current node
            for child in tree[node]:
                dfs(child)
            
            # Restore the previous state by removing the current node from the stack
            stack[char].pop()
        
        # Start the DFS from the root node (0)
        dfs(0)
    
        # Step 3: Rebuild the tree based on the updated parent relationships
        transformed_tree = defaultdict(list)
        for i in range(1, n):
            transformed_tree[new_parent[i]].append(i)
        
        # Step 4: Calculate the size of the subtrees using DFS
        subtree_sizes = [0] * n
    
        def calculate_subtree_size(node):
            size = 1  # Start with the node itself
            for child in transformed_tree[node]:
                size += calculate_subtree_size(child)
            subtree_sizes[node] = size
            return size
    
        # Compute subtree sizes from the root node (0)
        calculate_subtree_size(0)
    
        return subtree_sizes",1434311662
Vijay Shankar Kumar,vijayshankarkumar,487,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        # Step 1: Initialize the DP table with dimensions (k x n)
        dp = [[0] * n for _ in range(k)]
        
        # Step 2: Initialize the first day scores considering both staying and traveling
        for j in range(n):
            # Staying in city j
            dp[0][j] = stayScore[0][j]
            # Traveling from any other city to city j on the first day
            for i in range(n):
                if i != j:
                    dp[0][j] = max(dp[0][j], travelScore[i][j])
        
        # Step 3: Fill the DP table for subsequent days
        for i in range(1, k):
            # Temporary array to store previous day scores for reference
            prevDayScores = dp[i-1]
            for j in range(n):
                # Option 1: Stay in city j
                dp[i][j] = prevDayScores[j] + stayScore[i][j]
                
                # Option 2: Travel to city j from any other city
                for prev in range(n):
                    if prev != j:
                        dp[i][j] = max(dp[i][j], prevDayScores[prev] + travelScore[prev][j])
        
        # Step 4: Find the maximum score on the last day across all cities
        max_score = max(dp[k-1])
        
        return max_score
        ",1434320585
Vijay Shankar Kumar,vijayshankarkumar,487,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        # This will store the total number of possible original strings
        possible_originals = 1  # Start with 1 (the original string itself)
        
        # Traverse the word to find consecutive character groups
        i = 0
        while i < len(word):
            # Count the length of the current consecutive group
            j = i
            while j < len(word) and word[j] == word[i]:
                j += 1
            
            # Length of the current group
            length = j - i
            
            # If the length is greater than 1, we can reduce this group in multiple ways
            if length > 1:
                possible_originals += length - 1
            
            # Move to the next group
            i = j
        
        return possible_originals
        ",1434296447
ads169573,ads169573,488,3576,cpp,"class Solution {
public:
    map<int,vector<int>> g;
    void f(int u,vector<int>&parent,string &s,vector<int>t,int p){
        int id=s[u]-'a';
        if(p!=-1){
            t[s[p]-'a']=p;
        }
        if(t[id]!=-1){
            parent[u]=t[id];
        }
        
        for(auto v:g[u]) {
            f(v,parent,s,t,u);
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> ret(s.size(),1);

        
        for(int i=1;i<parent.size();++i){
            g[parent[i]].push_back(i);
        }
        vector<int>t(26,-1);
        f(0,parent,s,t,-1);
        vector<int>in(s.size(),0);
        for(int i=1;i<parent.size();++i){
            in[parent[i]]++;
        }
        queue<int>q;
        for(int i=0;i<s.size();++i) if(in[i]==0) q.push(i);
        while(!q.empty()) {
            auto e=q.front();
            q.pop();
            if(e==0) break;
            ret[parent[e]]+=ret[e];
            if(--in[parent[e]]==0) {
                q.push(parent[e]);
            }
        }
        return ret;
    }
};",1434309101
ads169573,ads169573,488,3587,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int f(int c,int d,int n,int k,vector<vector<int>>&s,vector<vector<int>>&t){
        if(d==k) return 0;
        if(dp[c][d]!=-1) return dp[c][d];
        int ans=0;
        for(int i=0;i<n;++i){
            if(i==c) ans=max(ans,s[d][c]+f(c,d+1,n,k,s,t));
            else ans=max(ans,t[c][i]+f(i,d+1,n,k,s,t));
        }
        return dp[c][d]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        dp.resize(n,vector<int>(k,-1));
        int ans=0;
        for(int i=0;i<n;++i) ans=max(ans,f(i,0,n,k,stayScore,travelScore));
        return ans;
    }
};",1434320823
ads169573,ads169573,488,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char p=word[0];
        int cnt=1;
        int ans=1;
        for(int i=1;i<word.size();++i){
            if(word[i]==p){
                cnt++;
            } else {
                ans+=(cnt-1);
                cnt=1;
                p=word[i];
            }
        }
        ans+=(cnt-1);
        return ans;
    }
};",1434262055
tmimotw,tmimotw,490,3576,java,"class Solution {
public int[] findSubtreeSizes(int[] parent, String s) {
    var graph = new HashMap<Integer, List<Integer>>();
    for (int i = 1; i < parent.length; i++) {
      graph.computeIfAbsent(parent[i], a -> new ArrayList<>()).add(i);
    }
    var lastCharNode = new int[26];
    Arrays.fill(lastCharNode, -1);
    findSubtreeSizesUpdate(graph, parent, s, 0, lastCharNode);
    graph = new HashMap<Integer, List<Integer>>();
    for (int i = 1; i < parent.length; i++) {
      graph.computeIfAbsent(parent[i], a -> new ArrayList<>()).add(i);
    }
    var resultArr = new int[parent.length];
    findSubtreeSizesDfs(graph, resultArr, 0);
    return resultArr;
  }

  private void findSubtreeSizesUpdate(HashMap<Integer, List<Integer>> graph, int[] parent, String s, int node,
      int[] lastCharNode) {
    var oldValue = lastCharNode[s.charAt(node) - 'a'];
    if (oldValue != -1) {
      parent[node] = oldValue;
    }
    lastCharNode[s.charAt(node) - 'a'] = node;
    var list = graph.getOrDefault(node, Collections.emptyList());
    for (var item : list) {
      findSubtreeSizesUpdate(graph, parent, s, item, lastCharNode);
    }
    lastCharNode[s.charAt(node) - 'a'] = oldValue;
  }

  private int findSubtreeSizesDfs(HashMap<Integer, List<Integer>> graph, int[] sizeCount, int node) {
    var list = graph.getOrDefault(node, Collections.emptyList());
    var count = 1;
    for (var item : list) {
      count += findSubtreeSizesDfs(graph, sizeCount, item);
    }
    return sizeCount[node] = count;
  }
}",1434298335
tmimotw,tmimotw,490,3587,java,"class Solution {
public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
    var memo = new int[k][n];
    for (var arr : memo) {
      Arrays.fill(arr, -1);
    }
    var result = 0;
    for (int i = 0; i < n; i++) {
      result = Math.max(result, maxScoreSolve(stayScore, travelScore, 0, i, memo));
    }
    return result;
  }

  private int maxScoreSolve(int[][] stayScore, int[][] travelScore, int currentDay, int lastCity, int[][] memo) {
    if (currentDay == stayScore.length)
      return 0;
    if (memo[currentDay][lastCity] != -1)
      return memo[currentDay][lastCity];
    var n = travelScore[0].length;
    var result = 0;
    for (int i = 0; i < n; i++) {
      var score = travelScore[lastCity][i];
      if (i == lastCity)
        score = stayScore[currentDay][lastCity];
      result = Math.max(result, maxScoreSolve(stayScore, travelScore, currentDay + 1, i, memo) + score);
    }
    return memo[currentDay][lastCity] = result;
  }
}",1434327892
tmimotw,tmimotw,490,3617,java,"class Solution {
public int possibleStringCount(String word) {
    var result = 1;
    for (int i = 1; i < word.length(); i++) {
      if (word.charAt(i) == word.charAt(i - 1))
        result++;
    }
    return result;
  }
}",1434260989
Vikas Kumar,vkg001,491,3576,cpp,"class Solution {
public:


    void shrink(int r, vector<vector<int>> &tree, string &s, vector<int> p, vector<int> &ng) {
        int cp = p[s[r] - 'a'];
        p[s[r] - 'a'] = r;
        for (auto &x: tree[r]) {
            shrink(x, tree, s, p, ng);
        }

        if (cp != -1) {
            ng[r] = cp;
        }
    }

    void makeGraph(vector<int> &p, vector<vector<int>> &gp) {
        for (int i = 1; i < p.size(); i++) {
            gp[p[i]].push_back(i);
        }
    }


    int dfs(int r, vector<vector<int>> &gf, vector<int> &res) {
        int ans = 1;
        for (int x: gf[r]) {
            ans += dfs(x, gf, res);
        }

        return res[r] = ans;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> ng;
        for (int x: parent) {
            ng.push_back(x);
        }

        vector<vector<int>> tree(parent.size()), gp(parent.size());
        makeGraph(parent, tree);

        vector<int> p(26, -1);

        shrink(0, tree, s, p, ng);

        makeGraph(ng, gp);

        vector<int> ans(parent.size());
        dfs(0, gp, ans);

        return ans;
    }
};",1434291633
Vikas Kumar,vkg001,491,3587,cpp,"const int N = 205;

class Solution {
public:

    int dp[N][N];

    int solve(int i, int j, int &k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        if (j >= k) return 0;
        if (dp[i][j] > -1) return dp[i][j];
        int ans = stayScore[j][i] + solve(i, j + 1, k, stayScore, travelScore);
        
        for (int l = 0; l < travelScore[i].size(); l++) {
            ans = max(ans, travelScore[i][l] + solve(l, j + 1, k, stayScore, travelScore));
        }

        return dp[i][j] = ans;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        memset(dp, -1, sizeof(dp));
        
        for (int i = 0; i < n; i++) {
            ans = max(ans, solve(i, 0, k, stayScore, travelScore));
        }

        return ans;
    }
};",1434327936
Vikas Kumar,vkg001,491,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int i = 0;
        int ans = 1;
        
        while (i < word.size()) {
            int j = i + 1;
            while (j < word.size()  &&  word[j] == word[i]) {
                j++;
                ans++;
            }

            i = j;
        }

        return ans;
    }
};",1434261891
Tiko Apridonidze,kiu2024falltikoapridonidze,493,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        answer = [1] * n
        
        for i in range(1, n):
            adj[parent[i]].append(i)
            
        newParent = parent.copy()
        lastSeen = {}
        
        def reassignParents(node: int) -> None:
            c = s[node]
            if c in lastSeen and lastSeen[c]:
                newParent[node] = lastSeen[c][-1]
            if c not in lastSeen:
                lastSeen[c] = []
            lastSeen[c].append(node)
            for child in adj[node]:
                reassignParents(child)
            lastSeen[c].pop()
        
        reassignParents(0)
        
        newAdj = [[] for _ in range(n)]
        for i in range(1, n):
            newAdj[newParent[i]].append(i)
        
        def computeSubtreeSizes(node: int) -> int:
            size = 1
            for child in newAdj[node]:
                size += computeSubtreeSizes(child)
            answer[node] = size
            return size
        
        computeSubtreeSizes(0)
        return answer",1434305051
Tiko Apridonidze,kiu2024falltikoapridonidze,493,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1] * n for _ in range(k + 1)]
        
        def solve(day: int, curr: int) -> int:
            if day == k:
                return 0
                
            if dp[day][curr] != -1:
                return dp[day][curr]
                
            max_points = stayScore[day][curr] + solve(day + 1, curr)
            
            for next_city in range(n):
                if next_city != curr:
                    max_points = max(max_points,
                                   travelScore[curr][next_city] + solve(day + 1, next_city))
            
            dp[day][curr] = max_points
            return max_points
        
        max_result = 0
        for start_city in range(n):
            max_result = max(max_result, solve(0, start_city))
            
        return max_result",1434328118
Tiko Apridonidze,kiu2024falltikoapridonidze,493,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        total_count = 1
        n = len(word)
        
        i = 0
        while i < n:
            count = 1
            while i + 1 < n and word[i] == word[i + 1]:
                count += 1
                i += 1
            total_count += count - 1
            i += 1
            
        return total_count",1434271440
Antoniasaz,xyxx,494,3576,cpp,"class Solution {
public:
    vector<vector<int>> adj;
    void find(int x, string& str, vector<int> dp, vector<int> &par)
    {
        int ch = str[x] - 'a';
        if(dp[ch]!=-1)
            par[x] = dp[ch];

        dp[ch] = x;
        for(int i=0;i<adj[x].size();++i)
            find(adj[x][i], str, dp, par);
    }
    
    int dfs(int x, vector<int> &ret)
    {
        int co = 1;
        for(int i=0;i<adj[x].size();++i)
            co+=dfs(adj[x][i], ret);
        ret[x] = co;
        return co;
    }
    
    
    vector<int> findSubtreeSizes(vector<int>& par, string &str) {
        vector<int> ret(str.size(), 1);
        vector<int> tmp(str.size(), 0);
        adj.assign(str.size()+1, vector<int>());
        
        for(int i=0;i<par.size();tmp[i]=par[i], ++i)
            if(par[i]!=-1)
                adj[par[i]].push_back(i);
        
        vector<int> ar(26, -1);
        
        find(0, str, ar, tmp);
        
        map<int,int> ma;
        for(int i=0;i<tmp.size();++i)
            ++ma[tmp[i]];
        adj.clear();
        adj.assign(str.size()+1, vector<int>());
        for(int i=0;i<tmp.size(); ++i)
            if(tmp[i]!=-1)
                adj[tmp[i]].push_back(i);
        
        dfs(0, ret);
        return ret;
        
    }
};",1434306302
Antoniasaz,xyxx,494,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& tv) {
        vector<vector<int>> dp(k+1, vector<int>(n+1, 0));
        
        for(int i=1;i<=k;++i)
        {
            for(int j=1;j<=n;++j)
            {
                for(int x=1;x<=n;++x)
                {
                    dp[i][j] = max(dp[i][j], dp[i-1][x] + (x==j ? (stay[i-1][x-1]) : tv[x-1][j-1]));                    
                }
            }
        }
        
        
        return *max_element(dp[k].begin(), dp[k].end());
    }
};",1434328191
Antoniasaz,xyxx,494,3617,cpp,"class Solution {
public:
    int possibleStringCount(string &str) {
        int co = 0;
        for(int i=0;i<str.size();++i)
        {
            int j=i;
            while(j<str.size()&&str[j]==str[i])++j;
            co+=j-i-1;
            i=j-1;
        }
        
        return co+1;
    }
};",1434261183
Manoj Gunda,gmanoj574,495,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        gph = [[] for _ in range(n)]
        for i in range(1,n):
            gph[parent[i]].append(i)
        ans = [-1 for _ in range(n)]
        k = [-1 for _ in range(26)]
        # print(gph)
        def dfs(ind):
            if len(gph[ind]) == 0:
                return
            p = ord(s[ind])-97
            temp = k[p]
            k[p] = ind
            for ng in gph[ind]:
                i = ord(s[ng]) - 97
                if k[i] != -1:
                    ans[ng] = k[i]
                else:
                    ans[ng] = ind
                dfs(ng)
            k[p] = temp
                    
        dfs(0)  
        # print(ans)
        gph = [[] for _ in range(n)]
        for i in range(1,n):
            gph[ans[i]].append(i)
        res = [-1 for _ in range(n)]
        def dfs1(ind):
            if len(gph[ind]) == 0:
                res[ind] = 1
                return 1
            cnt = 1
            for ng in gph[ind]:
                cnt += dfs1(ng)
            res[ind] = cnt
            return cnt
        dfs1(0)
        return res
        
        ",1434306972
Manoj Gunda,gmanoj574,495,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, ss: List[List[int]], ts: List[List[int]]) -> int:
        
        @cache
        def find(city, day):
            if day == k:
                return 0
            stay = ss[day][city] + find(city,day+1)
            move = 0
            for dest in range(n):
                move = max(move, ts[city][dest] + find(dest,day+1))
            return max(stay,move)

        ans = 0
        for i in range(n):
            ans = max(ans, find(i,0))
        return ans
        ",1434328248
Manoj Gunda,gmanoj574,495,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 0
        cnt = 0
        for i in range(1, len(word)):
            if word[i] == word[i-1]:
                cnt += 1
            else:
                ans += cnt
                cnt = 0
        
        return ans+1+cnt
            
        ",1434269073
Dawn Chen,user1084vL,496,3576,python,"class Solution(object):
    def findClosestSame(self,root,childs,prevs,newpars,s):
        proot = -1
        if s[root] in prevs and prevs[s[root]]!=-1:
            proot = prevs[s[root]]
            newpars[root] = prevs[s[root]]
        prevs[s[root]] = root
        if root not in childs:
            prevs[s[root]] = proot
            return
        for c in childs[root]:
            self.findClosestSame(c,childs,prevs,newpars,s)
            #prevs[s[root]] = root
        prevs[s[root]] = proot
    def getSize(self,root,childs,sizes):
        if root not in childs:
            sizes[root] = 1
            return
        for c in childs[root]:
            self.getSize(c,childs,sizes)
            sizes[root]+=sizes[c]
        sizes[root]+=1
        return
    def findSubtreeSizes(self, parent, s):
        """"""
        :type parent: List[int]
        :type s: str
        :rtype: List[int]
        """"""
        childs = {-1:[0]}
        n = len(parent)
        for i in range(n):
            if parent[i] in childs: childs[parent[i]].append(i)
            else: childs[parent[i]] = [i]
        #print(pars,childs)
        newpars = {}
        prevs = {}
        self.findClosestSame(0,childs,prevs,newpars,s)
        #print(newpars)
        for p in newpars: parent[p] = newpars[p]
        newtree = {}
        for i in range(n):
            if parent[i] in newtree: newtree[parent[i]].append(i)
            else: newtree[parent[i]] = [i]
        sizes = [0 for i in range(n)]
        self.getSize(0,newtree,sizes)
        return sizes",1434294967
Dawn Chen,user1084vL,496,3587,python,"class Solution(object):
    def maxScore(self, n, k, stayScore, travelScore):
        """"""
        :type n: int
        :type k: int
        :type stayScore: List[List[int]]
        :type travelScore: List[List[int]]
        :rtype: int
        """"""
        maxscore = [[0 for i in range(k+1)] for j in range(n)]
        for i in range(k):
            for j in range(n):
                for l in range(n):
                    if l==j: maxscore[j][i+1] = max(maxscore[j][i+1],maxscore[j][i]+stayScore[i][j])
                    else: maxscore[j][i+1] = max(maxscore[j][i+1],maxscore[l][i]+travelScore[l][j])
        finmax = 0
        for i in range(n): finmax = max(finmax,maxscore[i][-1])
        return finmax",1434321337
Dawn Chen,user1084vL,496,3617,python,"class Solution(object):
    def possibleStringCount(self, word):
        """"""
        :type word: str
        :rtype: int
        """"""
        counts = []
        curchar = ''
        curcount = 0
        for c in word:
            if c!=curchar:
                if curcount>0: counts.append(curcount-1)
                curchar = c
                curcount=1
            else: curcount+=1
        if curcount>0: counts.append(curcount-1)
        return sum(counts)+1",1434261324
Ivan,ivangnilomedov,497,3576,cpp,"class Calc {
public:
    vector<int>& p;
    string& s;
    Calc(vector<int>& p, string& s) : p(p), s(s), c2p('z' + 1, -1) {}

    vector<int> c2p;
    vector<int> pmv;
    void dfs(int u) {
        int y = c2p[s[u]];
        if (y >= 0)
            pmv[u] = y;
// cout << ""dfs "" << u << "" y "" << y << ""\n"";
        c2p[s[u]] = u;
        for (int v : gr[u])
            dfs(v);
        c2p[s[u]] = y;
    }

    vector<vector<int>> gr;

    vector<int> res;
    void dfs1(int u) {
        for (int v : gr[u]) {
            dfs1(v);
            res[u] += res[v];
        }
        ++res[u];
    }

    vector<int> solve() {
        gr.resize(p.size());
        for (int v = 0; v < p.size(); ++v)
            if (p[v] >= 0) {
                gr[p[v]].push_back(v);
            }
// cout << ""gr "" << gr.size() << ""\n"";

        pmv = p;
        dfs(0);
// cout << ""pmv "" << pmv.size() << ""\n"";

        gr.resize(0);
        gr.resize(p.size());
        p = pmv;
        for (int v = 0; v < p.size(); ++v)
            if (p[v] >= 0) {
                gr[p[v]].push_back(v);
            }

        res.resize(p.size());
        dfs1(0);

        return res;
    }
};

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        return Calc(parent, s).solve();
    }
};",1434311331
Ivan,ivangnilomedov,497,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<int> dp(n);
        for (int d = 0; d < k; ++d) {
            vector<int> up(n);
            for (int i = 0; i < n; ++i) {
                up[i] = dp[i] + ss[d][i];
                for (int j = 0; j < n; ++j) {
                    up[i] = max(up[i], dp[j] + ts[j][i]);
                }
            }
            dp = up;
        }
        return *max_element(dp.begin(), dp.end());
    }
};",1434328402
Ivan,ivangnilomedov,497,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        for (int i = 0; i < word.size();) {
            int j = i + 1;
            while (j < word.size() && word[j] == word[i])
                ++j;
            res += j - i - 1;
            i = j;
        }
        return res;
    }
};",1434273152
sellie50759,sellie50759,498,3576,cpp,"class Solution {
public:
    map<char, vector<int> > mp;
    void dfs(int cur, vector<vector<int> > &tree, vector<int> &newP, string &s){
        if(mp.count(s[cur]) && !mp[s[cur]].empty())
            newP[cur] = mp[s[cur]].back();
        mp[s[cur]].push_back(cur);
        for(auto &next : tree[cur])
            dfs(next, tree, newP, s);
        mp[s[cur]].pop_back();
    }
    int dfsc(int cur, vector<vector<int> > &tree, vector<int> &ans){
        int sum = 1;
        for(auto &next : tree[cur])
            sum += dfsc(next, tree, ans);
        return ans[cur] = sum;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        vector<vector<int> > tree(n);
        
        for(int i=1;i<parent.size();i++)
            tree[parent[i]].push_back(i);
        vector<int> newP = parent;
        
        dfs(0, tree, newP, s);
        
        for(int i=0;i<n;i++)
            tree[i].clear();
        for(int i=0;i<newP.size();i++){
            if(newP[i] != -1)
                tree[newP[i]].push_back(i);
        }
        vector<int> ans(n);
        
        dfsc(0, tree, ans);
        
        return ans;
    }
};",1434311096
sellie50759,sellie50759,498,3587,cpp,"class Solution {
public:
    #define MAX 205
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        // dp[i][j] = max(dp[i-1][cur] + stay, all{dp[i-1][dst] + travvel});
        
        int dp[MAX][MAX] = {0};
        
        for(int i=1;i<=k;i++){
            for(int j=0;j<n;j++){
                for(int k=0;k<n;k++){
                    if(j != k){
                        dp[i][j] = max(dp[i][j], dp[i-1][k] + t[k][j]);   
                    }
                    else {
                        dp[i][j] = max(dp[i][j], dp[i-1][j] + s[i-1][j]);
                    }
                }
            }
        }
        
        int ans = 0;
        for(int i=0;i<n;i++){
            ans = max(ans, dp[k][i]);
        }
        return ans;
    }
};",1434328416
sellie50759,sellie50759,498,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for(int i=0;i<word.size()-1;i++){
            int cnt = 0;
            while(i<word.size()-1 && word[i] == word[i+1]){
                i++;
                cnt++;
            }
            ans += cnt;
        }
        return ans;
    }
};",1434270865
xpycc,xpycc,499,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = parent.size(); ch.resize(n); ans.resize(n);
        t = s;
        memset(pre, -1, sizeof(pre));
        for (int i = 1; i < n; ++i)
            ch[parent[i]].push_back(i);
        dfs(0);
        return ans;
    }
    void dfs(int x) {
        int op = pre[t[x]]; pre[t[x]] = x;
        for (int i = 0; i < ch[x].size(); ++i) {
            int y = ch[x][i];
            if (pre[t[y]] != -1 && pre[t[y]] != x) {
                dfs(y);
                ans[pre[t[y]]] += ans[y];
            } else {
                dfs(y);
                ans[x] += ans[y];
            }
        }
        ++ans[x];
        pre[t[x]] = op;
    }
    int n;
    int pre[128] = {};
    vector<vector<int>> ch;
    vector<int> ans;
    string_view t;
};",1434299873
xpycc,xpycc,499,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> g(n), f(n);
        for (int i = 0; i < k; ++i) {
            swap(f, g);
            for (int j = 0; j < n; ++j) {
                f[j] = g[j] + stayScore[i][j];
                for (int p = 0; p < n; ++p)
                    f[j] = max(f[j], g[p] + travelScore[p][j]);
            }
        }
        return *max_element(f.begin(), f.end());
    }
};",1434321512
xpycc,xpycc,499,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        const int n = word.size();
        int ans = 1;
        for (int i = 0; i < n; ) {
            int j;
            for (j = i; j < n && word[j] == word[i]; ++j)
                ;
            ans += j - i - 1;
            i = j;
        }
        return ans;
    }
};",1434265725
Muhammad Rafi,MuhammadRafi,500,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); 
        vector<int> answer(n, 1);   
        for (int i = 1; i < n; ++i) adj[parent[i]].push_back(i);
        vector<int> newParent = parent; 
        unordered_map<char, vector<int>> lastSeen; 
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : adj[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0); 
        vector<vector<int>> newAdj(n); 
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1; 
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0); 
        return answer;
    }
    
};",1434318343
Muhammad Rafi,MuhammadRafi,500,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) { 
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        return maxPoints;
    }
};",1434328504
Muhammad Rafi,MuhammadRafi,500,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {

        int len = word.length();
        int ans = 0;
        char prev = word[0];
        for(int i=1; i<len; i++)
        {
            if(prev == word[i]){
                ans++;
            }
            prev = word[i];
        }
        return ans+1;
   
    }
};",1434309683
Ayush,wthayush,502,3576,cpp,"class Solution {
    int size(int ind, vector<vector<int>>&adj, vector<int>&ans){
        int sum = 1;
        for(const int &i:adj[ind]){
            sum += size(i, adj, ans);
        }
        return ans[ind] = sum;
    }
    void dfs(int ind, vector<vector<int>>&adj, string &s, unordered_map<char, int>&mp, vector<int>&parent){
        if(mp.contains(s[ind])){
            parent[ind] = mp[s[ind]];
        }
        int tmp = mp.contains(s[ind])?mp[s[ind]]:-1;
        mp[s[ind]] = ind;
        for(const int&i:adj[ind]){
            dfs(i, adj, s, mp, parent);
        }
        if(tmp==-1){
            mp.erase(s[ind]);
        }
        else mp[s[ind]] = tmp;    
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string &s) {
        int n = parent.size();
        vector<vector<int>>adj(n);
        for(int i = 1; i<n; i++){
            adj[parent[i]].push_back(i);
        }
        unordered_map<char, int>mp;
        dfs(0, adj, s, mp, parent);
        adj.clear();
        adj = vector<vector<int>>(n);
        for(int i = 1; i<n; i++){
            adj[parent[i]].push_back(i);
        }
        vector<int>ans(n, 0);
        size(0, adj, ans);
        return ans;
    }
};",1434290785
Ayush,wthayush,502,3587,cpp,"class Solution {
    int n, k;
    int findAns(vector<vector<int>>&dp, int day, int city, const vector<vector<int>>& stayScore, const vector<vector<int>>& travelScore){
        if(day==k)              return 0;
        if(dp[day][city]!=-1)   return dp[day][city];
        int stayAns = stayScore[day][city] + findAns(dp, day+1, city, stayScore, travelScore);
        int travelAns = 0;
        for(int i = 0; i<n; i++){
            travelAns = max(travelAns, travelScore[city][i] + findAns(dp, day+1, i, stayScore, travelScore));
        }
        return dp[day][city] = max(stayAns, travelAns);
    }
public:
    int maxScore(int n, int k, const vector<vector<int>>& stayScore, const vector<vector<int>>& travelScore) {
        this ->n = n;
        this ->k = k;
        vector<vector<int>>dp(k+1, vector<int>(n, -1));
        for(auto &i:dp.back()){
            i = 0;
        }
        int ans = 0;
        for(int i = 0; i<n; i++){
            ans = max(ans, findAns(dp, 0, i, stayScore, travelScore));
        }
        return ans;
    }
};",1434321820
Ayush,wthayush,502,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int i = 0, cnt = 1;
        int len = word.length();
        while(i<len){
            int curr_cnt = 0;
            while(i<len-1 && word[i]==word[i+1]){
                i++;
                curr_cnt++;
            }
            i++;
            cnt+= curr_cnt;
        }
        return cnt;
    }
};",1434264078
Salyu,salyu,503,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        auto build_tree = [&](vector<int> const& ps) {
            vector<vector<int>> edges(ps.size());
            for (int i = 1; i < ps.size(); ++i) {
                edges[parent[i]].push_back(i);
            }
            return edges;
        };
        {
            auto tr0 = build_tree(parent);
            vector<vector<int>> stks(26);
            function<void(int)> search1 = [&](int u) {
                if (!stks[s[u] - 'a'].empty()) {
                    parent[u] = stks[s[u] - 'a'].back();
                }
                stks[s[u] - 'a'].push_back(u);
                for (int v : tr0[u]) {
                    search1(v);
                }
                stks[s[u] - 'a'].pop_back();
            };
            search1(0);
        }
        vector<int> res(n);
        {
            auto tr1 = build_tree(parent);
            function<int(int)> search2 = [&](int u) -> int {
                int r = 1;
                for (int v : tr1[u]) {
                    r += search2(v);
                }
                return res[u] = r;
            };
            search2(0);
        }
        return res;
    }
};",1434297172
Salyu,salyu,503,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<int> curr(n), prev(n);
        for (int i = 0; i < k; ++i) {
            std::swap(curr, prev);
            for (int v = 0; v < n; ++v) {
                curr[v] = prev[v] + stay[i][v];
                for (int u = 0; u < n; ++u) {
                    if (u != v) {
                        curr[v] = max(curr[v], prev[u] + travel[u][v]);
                    }
                }
            }
        }
        return *max_element(curr.begin(), curr.end());
    }
};",1434314843
Salyu,salyu,503,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size(), res = 1;
        for (int l = 0, r = 1; l < n; ) {
            while (r < n && word[r] == word[l]) {
                ++r;
            }
            res += r - l - 1;
            l = r++;
        }
        return res;
    }
};",1434270144
Conrad_123,Conrad_123,504,3576,cpp,"class Solution {
public:

    int Get_Subtree_Sizes(std::vector<std::vector<int>>& tree, int node, std::vector<int>& sizes){

        if(node == -1) return -1;

        int result = 0;
        for(int i = 0; i < tree[node].size(); i++){
            result += Get_Subtree_Sizes(tree, tree[node][i], sizes);
        }

        return sizes[node] = result+1;
    }

    void Solve(std::vector<std::vector<int>>& tree, std::vector<int>& next_tree,int node, int parent, std::vector<int>& last_seen, std::string& s){

        if(last_seen[s[node]-'a'] != -1){
            parent = last_seen[s[node]-'a'];
        }
        
        int temp = last_seen[s[node]-'a'];
        last_seen[s[node]-'a'] = node;
        next_tree[node] = parent;
       
        for(int i = 0; i < tree[node].size(); i++){
            Solve(tree, next_tree, tree[node][i], node, last_seen, s);
        }
        last_seen[s[node]-'a'] = temp;
    }

    std::vector<int> findSubtreeSizes(std::vector<int>& parent, std::string s) {

        std::vector<std::vector<int>> tree(parent.size());
        std::vector<std::vector<int>> new_tree(parent.size());
        std::vector<int> new_parents(parent.size());
        std::vector<int> result(parent.size(), 0);
        std::vector<int> last_seen(26, -1);
        
        for(int i = 1; i < parent.size(); i++){
            tree[parent[i]].push_back(i);
        }

        Solve(tree, new_parents, 0, -1, last_seen, s);

        for(int i = 1; i < new_parents.size(); i++){
            new_tree[new_parents[i]].push_back(i);
        }

        Get_Subtree_Sizes(new_tree, 0, result);

        return result;
    }
};",1434308359
Conrad_123,Conrad_123,504,3587,cpp,"class Solution {
public:

    int Solve(std::vector<std::vector<int>>& stay, std::vector<std::vector<int>>& travel, int idx, int day, std::vector<std::vector<int>>& cache){

        if(day >= stay.size()){
            return 0;
        }

        if(cache[day][idx] != -1) return cache[day][idx];
        
        int result = Solve(stay, travel, idx, day+1, cache) + stay[day][idx];
        
        for(int i = 0; i < travel.size(); i++){

            if(i == idx) continue;
            int current = Solve(stay, travel, i, day+1, cache) + travel[idx][i];

            result = max(result, current);
        }

        return cache[day][idx] = result;
    }

    int maxScore(int n, int k, std::vector<std::vector<int>>& stayScore, std::vector<std::vector<int>>& travelScore) {

        std::vector<std::vector<int>> cache(k, std::vector<int>(n, -1));
        int result = 0;
        for(int i = 0; i < n; i++){
            int current = Solve(stayScore, travelScore, i, 0, cache);
            result = max(current, result);
        }
    
        return result;
    }
};",1434328930
Conrad_123,Conrad_123,504,3617,cpp,"class Solution {
public:
    int possibleStringCount(std::string word) {

        int count = 0;

        for(int i = 1; i < word.size(); i++){
            if(word[i] == word[i-1]) count++;
        }

        return count + 1;
    }
};",1434260165
resotto,resotto,506,3576,java,"class Solution {
    private List<Set<Integer>> graph, update;
    private int n;
    private int[] ans;
    public int[] findSubtreeSizes(int[] parent, String s) {
        n = parent.length;
        graph = new ArrayList<Set<Integer>>();
        update = new ArrayList<Set<Integer>>();
        // graph = new ArrayList<Integer>();
        // update = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            graph.add(new HashSet<>());
            update.add(new HashSet<>());
        }
        for (int i = 1; i < n; i++) {
            graph.get(parent[i]).add(i);
            update.get(parent[i]).add(i);
        }
        connect(0, -1, s, new HashMap<Character, List<Integer>>());
        ans = new int[n];
        dfs(0);
        return ans;
    }
    private int dfs(int cur) {
        int c = 1;
        for (int next : update.get(cur)) {
            c += dfs(next);
        }
        ans[cur] = c;
        return c; // forgot
    }
    private void connect(int cur, int par, String s, Map<Character, List<Integer>> ancestor) {
        var ch = s.charAt(cur);
        if (ancestor.computeIfAbsent(ch, z -> new ArrayList<>()).size() != 0) {
            int j = ancestor.get(ch).get(ancestor.get(ch).size()-1);
            update.get(par).remove(cur);
            update.get(j).add(cur);
        }
        ancestor.get(ch).add(cur);
        for (int next : graph.get(cur)) {
            connect(next, cur, s, ancestor);
        }
        ancestor.get(ch).remove(ancestor.get(ch).size()-1);
    }
}

/*

    
    dfs from root for calculating answer






    private List<List<Integer>> graph, update;
    private int n;
    public int[] findSubtreeSizes(int[] parent, String s) {
        n = parent.length;
        graph = new ArrayList<Integer>();
        update = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
            update.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            graph.get(parent[i]).add(i);
            update.get(parent[i]).add(i);
        }
        connect(0, -1, s, new HashMap<Character, List<Integer>>());
    }
    private void connect(int cur, int par, String s, Map<Character, List<Integer>> ancestor) {
        var ch = s.charAt(cur);
        if (ancestor.computeIfAbsent(ch, z -> new ArrayList<>()).size() != 0) {
            
        }
        ancestor.get(ch).add(cur);
        for (int next : graph.get(cur)) {
            connect(next, ss, ancestor);
        }
        ancestor.get(ch).remove(ancestor.get(ch).size()-1);
    }




    private void connect(int cur, String s, Map<Character, Integer> ancestor) {
        var ch = s.charAt(cur);
        if (ancestor.get(ch) != null) {
            
        }
        ancestor.put(ch, cur);
        for (int next : graph.get(cur)) {
            
        }
    }
    
*/",1434322155
resotto,resotto,506,3587,java,"class Solution {
    private Integer[][] memo;
    private int n, k;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int ans = 0;
        this.n = n;
        this.k = k;
        memo = new Integer[n][k];
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, dfs(i, 0, stayScore, travelScore));
        }
        return ans;
    }
    private int dfs(int i, int j, int[][] stay, int[][] visit) {
        if (j == k) {
            return 0;
        } else if (memo[i][j] == null) {
            int ans = 0;
            for (int l = 0; l < n; l++) {
                if (i == l) {
                    ans = Math.max(ans, stay[j][i] + dfs(l, j+1, stay, visit));
                } else {
                    ans = Math.max(ans, visit[i][l] + dfs(l, j+1, stay, visit));
                }
            }
            memo[i][j] = ans;
        }
        return memo[i][j];
    }
}

/*
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.n = n;
        this.k = k;
        memo = new Integer[n+1][k+1];
        return dfs(n, 0, stayScore, travelScore);
    }
    private int dfs(int i, int j, int[][] stay, int[][] visit) {
        if (j == k+1) {
            return 0;
        } else if (memo[i][j] == null) {
            int ans = 0;
            for (int l = 0; l < n; l++) {
                if (i == l) {
                    ans = Math.max(ans, stay[j][i] + dfs(l, j+1, stay, visit));
                } else {
                    ans = Math.max(ans, visit[i][l] + dfs(l, j+1, stay, visit));
                }
            }
            memo[i][j] = ans;
        }
        return memo[i][j];
    }


    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int ans = 0;
        this.n = n;
        this.k = k;
        for (int i = 0; i < n; i++) {
            memo = new Integer[n][k];
            ans = Math.max(ans, dfs(i, 0, stayScore, travelScore));
        }
        return ans;
    }

*/",1434296531
resotto,resotto,506,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1, n = word.length();
        for (int i = 0; i < n-1; i++) {
            if (word.charAt(i) == word.charAt(i+1)) {
                while (i < n-1 && word.charAt(i) == word.charAt(i+1)) {
                    i++;
                    ans++;
                }
            }
        }
        return ans;
        // return ans - (1 < c ? 1 : 0);
    }
}

/*
    public int possibleStringCount(String word) {
        int ans = 1, c = 0, n = word.length();
        for (int i = 1; i < n-1; i++) {
            if (word.charAt(i) == word.charAt(i+1)) {
                c++;
                while (i < n-1 && word.charAt(i) == word.charAt(i+1)) {
                    i++;
                    ans++;
                }
            }
        }
        return ans;
        // return ans - (1 < c ? 1 : 0);
    }

*/",1434272725
Tianzhou Gao,gtzafw,507,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        ans = []
        n = len(parent)
        sizes = [0] * n

        children = defaultdict(set)
        latestoccur = [-1] * 26
        lastoccur = [-1] * n

        for i in range(1, n):
            children[parent[i]].add(i)

        def dfs(node):
            index = ord(s[node]) - ord('a')
            t = latestoccur[index]
            if latestoccur[index] != -1:
                lastoccur[node] = latestoccur[index]
            latestoccur[index] = node
            for child in children[node]:
                dfs(child)
            latestoccur[index] = t

        dfs(0)

        for i in range(1, n):
            if lastoccur[i] != -1:
                children[parent[i]].remove(i)
                children[lastoccur[i]].add(i)
        #print(children, lastoccur)

        def count_subtree_size(node):
            size = 1
            for child in children[node]:
                size += count_subtree_size(child)
            sizes[node] = size
            return size
        
        count_subtree_size(0)

        return sizes",1434314164
Tianzhou Gao,gtzafw,507,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n

        for i in range(k):
            newdp = dp.copy()
            for curr in range(n):
                t = [newdp[dest] + travelScore[dest][curr] for dest in range(n) if dest != curr]
                dp[curr] = max(newdp[curr] + stayScore[i][curr], max(t) if t else 0)
        return max(dp)",1434322172
Tianzhou Gao,gtzafw,507,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        acc = 0
        for i in range(len(word)):
            if i > 0 and word[i] == word[i - 1]:
                acc += 1
            else:
                ans += acc
                acc = 0
        return ans + acc",1434264837
Yash Singh,bytecode_1234,508,3576,cpp,"class Solution {
public:

    void dfs(int node,int par,vector<int>v,vector<int>&parent,string&s,vector<int>adj[])
   {
       if(v[s[node]-'a']!=-1)
       {
           parent[node]=v[s[node]-'a'];
       }
      
        v[s[node]-'a']=node;
       
       for(auto it:adj[node])
           {
               if(it!=par)
               {
                   dfs(it,node,v,parent,s,adj);
               }
           }
       
   }
    void dfs2(int node,int par,vector<int>&subtree,vector<int> adj[])
{
    int tot=0;
    for(auto it:adj[node])
        {
            if(it!=par)
            {
                dfs2(it,node,subtree,adj);
                tot+=subtree[it];
            }
        }
    tot++;
    subtree[node]=tot;
}
    vector<int> findSubtreeSizes(vector<int>& parent, string s) 
    {
       vector<int> v(26,-1);
        vector<int> adj[parent.size()];
        for(int i=0;i<parent.size();i++)
            {
                if(i!=0)
                {
                    adj[parent[i]].push_back(i);
                }
            }
       dfs(0,-1,v,parent,s,adj);
        vector<int> adj2[parent.size()];
        for(int i=0;i<parent.size();i++)
            {
                if(i!=0)
                {
                    adj2[parent[i]].push_back(i);
                }
            }
        vector<int> subtree(parent.size(),0);
        dfs2(0,-1,subtree,adj2);
        return subtree;
    }
};",1434322212
Yash Singh,bytecode_1234,508,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int genv(int curr,int day,vector<vector<int>>&v1,vector<vector<int>>&v2,int k,int n)
   {
       if(day==k)
       {
           return 0;
       }

       if(dp[curr][day]!=-1)
       {
        return dp[curr][day];
       }

       int ans=0;
       //staying
       ans=max(ans,v1[day][curr]+genv(curr,day+1,v1,v2,k,n));
       //moving
       for(int i=0;i<n;i++)
           {
               if(i!=curr)
               {
                   ans=max(ans,v2[curr][i]+genv(i,day+1,v1,v2,k,n));
               }
           }

       return dp[curr][day]=ans;
   }

    
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) 
    {
        int ans=0;
        for(int i=0;i<n;i++)
            {
                for(int j=0;j<k;j++)
                    {
                        dp[i][j]=-1;
                    }
            }
        for(int i=0;i<n;i++)
            {
                ans=max(ans,genv(i,0,stayScore,travelScore,k,n));
            }
        return ans;
    }
};",1434295333
Yash Singh,bytecode_1234,508,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
       int ans=1;
       int cnt=0;
       for(int i=0;i<word.size();i++)
           {
               if(i==0)
               {
                   cnt++;
               }
               else if(word[i]==word[i-1])
               {
                   cnt++;
               }
               else if(word[i]!=word[i-1])
               {
                   ans+=(cnt-1);
                   cnt=1;
               }
           }
        ans+=(cnt-1);
        return ans;
    }
};",1434269904
syzygy,kev1n17,511,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        g = [[] for _ in range(n)]
        for i in range(1,n):
            g[parent[i]].append(i)

        size = [0] * n
        stack = defaultdict(list)
        tree = [[] for _ in range(n)]
        np = [-1] * n
        
        def dfs(i):
            if stack[s[i]]:
                y = stack[s[i]][-1]
                np[i] = y

            stack[s[i]].append(i)
            for c in g[i]:
                dfs(c)
            stack[s[i]].pop()

        dfs(0)

        for i, p in enumerate(np):
            if p != -1:
                tree[p].append(i)
            else:
                if parent[i] != -1:
                    tree[parent[i]].append(i)
                
        ans = [0] * n
        def dfs2(i):
            cnt = 1
            for c in tree[i]:
                cnt += dfs2(c)
            ans[i] = cnt
            return cnt

        dfs2(0)
        return ans
            ",1434322310
syzygy,kev1n17,511,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dfs(d, city):
            if d == k:
                return 0

            stay = stayScore[d][city] + dfs(d+1, city)
            go = 0
            for dest in range(n):
                if dest != city:
                    go = max(go, dfs(d+1, dest) + travelScore[city][dest])
            return max(stay, go)

        ans = -1
        for i in range(n):
            ans = max(ans, dfs(0, i))
        return ans",1434297855
syzygy,kev1n17,511,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        prev = "" ""
        cnt = 0
        ans = 0
        for ch in word:
            if ch == prev:
                cnt += 1
            else:
                ans += cnt
                cnt = 0
                prev = ch
        ans += cnt
        ans += 1
        return ans",1434268989
sergey_chebotarev,sergey_chebotarev,515,3576,java,"class Solution {
    // @ 1h25m : 2m task + 0m idea + 18m code + 2m tests & typo fixes | TOTAL = 22 min
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        // map[node] = prev parent with the same char
        Map<Integer, Integer> prevParents = new HashMap<>();
        Map<Integer, Set<Integer>> tree = buildTree(parent, n);
        buildRefs(tree, 0, s.toCharArray(), prevParents, new Integer[200]);

        for (int node = 1; node < n; node++) {
            int currParent = parent[node];
            Integer newParent = prevParents.get(node);
            if (newParent != null && newParent != currParent) {
                tree.get(currParent).remove(node);
                tree.get(newParent).add(node);
            }
        }

        int[] result = new int[n];
        sizeDfs(tree, 0, result);
        return result;
    }

    private Map<Integer, Set<Integer>> buildTree(int[] parents, int n) {
        Map<Integer, Set<Integer>> children = new HashMap<>();
        for (int node = 0; node < n; node++) {
            int parent = parents[node];
            children.computeIfAbsent(parent, k -> new HashSet<>()).add(node);
        }
        return children;
    }

    private void buildRefs(Map<Integer, Set<Integer>> tree, int node, char[] chars,
                           Map<Integer, Integer> prevParents, Integer[] prevChars) {
        char ch = chars[node];
        Integer prevParent = prevChars[ch];
        prevParents.put(node, prevParent);

        prevChars[ch] = node;
        for (int child : tree.getOrDefault(node, Set.of())) {
            buildRefs(tree, child, chars, prevParents, prevChars);
        }
        prevChars[ch] = prevParent;
    }

    private int sizeDfs(Map<Integer, Set<Integer>> tree, int node, int[] result) {
        int size = 1;
        for (int child : tree.getOrDefault(node, Set.of())) {
            size += sizeDfs(tree, child, result);
        }
        result[node] = size;
        return size;
    }
}",1434304017
sergey_chebotarev,sergey_chebotarev,515,3587,java,"class Solution {
    // @ 1h03m : 6m task + 4m idea + 6m code + 2m tests | TOTAL = 18 min
    public int maxScore(int n, int k, int[][] stayScores, int[][] travelScores) {
        // dp[day][city]
        int[][] dp = new int[k+1][n];
        int result = 0;
        for (int day = k-1; day >= 0; day--) {
            for (int city = 0; city < n; city++) {
                int stayScore = stayScores[day][city] + dp[day + 1][city];
                int travelScore = 0;
                for (int nextCity = 0; nextCity < n; nextCity++) {
                    int nextScore = travelScores[city][nextCity] + dp[day + 1][nextCity];
                    travelScore = Math.max(nextScore, travelScore);
                }
                dp[day][city] = Math.max(stayScore, travelScore);
                result = Math.max(dp[day][city], result);
            }
        }
        return result;
    }
}
/*
Ideas:
- classical DP[day][city][take/no_take] = max points earned for days[day ... k-1]
- TC: O(K * N * 2 * N)
*/
",1434329596
sergey_chebotarev,sergey_chebotarev,515,3617,java,"class Solution {
    // @ 1h29m : 1m task + 0m idea + 2m code + 1m tests | TOTAL = 4m min/**/
    public int possibleStringCount(String word) {
        int n = word.length();
        int result = 1;
        for (int i = 0; i < n; ) {
            char ch = word.charAt(i);
            int right = i + 1;
            while (right < n && word.charAt(right) == ch) {
                right++;
            }
            result += (right - i) - 1;
            i = right;
        }
        return result;
    }
}",1434264904
Avinash Rajavarapu,kZS3d4UL2K,516,3576,python3,"from typing import List, Dict, DefaultDict
from collections import defaultdict
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        
        tree = defaultdict(list)
        for child in range(1, n):
            tree[parent[child]].append(child)
        
        new_parent = parent[:]
        closest_ancestor = {}
        
        def dfs_update(node: int):
            char = s[node]
            if char in closest_ancestor:
                new_parent[node] = closest_ancestor[char]
            
            original_ancestor = closest_ancestor.get(char)
            closest_ancestor[char] = node
            
            for child in tree[node]:
                dfs_update(child)
            
            if original_ancestor is not None:
                closest_ancestor[char] = original_ancestor
            else:
                del closest_ancestor[char]
        
        dfs_update(0)
        modified_tree = defaultdict(list)
        for child in range(1, n):
            modified_tree[new_parent[child]].append(child)
        
        answer = [0] * n
        
        def dfs_count(node: int) -> int:
            size = 1
            for child in modified_tree[node]:
                size += dfs_count(child)
            answer[node] = size
            return size
        
        dfs_count(0)
        return answer",1434276457
Avinash Rajavarapu,kZS3d4UL2K,516,3587,python3,"from typing import List

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-1] * n for _ in range(k + 1)]
        
        def recursion(day, city):
            if day == k:
                return 0
            if dp[day][city] != -1:
                return dp[day][city]
            
            points = stayScore[day][city] + recursion(day + 1, city)
            for nextCity in range(n):
                if nextCity != city:
                    points = max(points, travelScore[city][nextCity] + recursion(day + 1, nextCity))
            
            dp[day][city] = points
            return points
        
        res = -float('inf')
        for i in range(n):
            res = max(res, recursion(0, i))
        return res

",1434315838
Avinash Rajavarapu,kZS3d4UL2K,516,3617,python3,"from itertools import groupby

class Solution:
    def possibleStringCount(self, word: str) -> int:
        groups = [list(g) for _, g in groupby(word)]
        res = 1
        for group in groups:
            if len(group) > 1:
                res += len(group) - 1
        return res
",1434264262
Hsin-Jui Chen,joshuachen0213,517,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int l = parent.size(), idx, temp;
        vector<vector<int>> rec(26, vector<int>());
        vector<vector<int>> next(l, vector<int>());
        vector<int> ret(l, 1), new_parent(l, 0);
        for (int i = 1; i < l; i++) {
            next[parent[i]].push_back(i);
        }
        vector<int> st;
        vector<bool> been(l, false);
        st.push_back(0);
        while (st.size() > 0) {
            idx = st.back();
            if (been[idx]) {
                st.pop_back();
                rec[s[idx] - 'a'].pop_back();
                continue;
            }
            if (rec[s[idx] - 'a'].size() > 0) {
                temp = rec[s[idx] - 'a'].back();
                new_parent[idx] = temp;
            } else {
                new_parent[idx] = parent[idx];
            }
            rec[s[idx] - 'a'].push_back(idx);
            for (auto x : next[idx])
                st.push_back(x);
            been[idx] = true;
        }
        next = vector<vector<int>>(l, vector<int>());
        for (int i = 1; i < l; i++) {
            next[new_parent[i]].push_back(i);
        }
        st = vector<int>();
        been = vector<bool>(l, false);
        st.push_back(0);
        while (st.size() > 0) {
            idx = st.back();
            if (been[idx]) {
                for (auto x : next[idx])
                    ret[idx] += ret[x];
                st.pop_back();
                continue;
            }
            for (auto x : next[idx])
                st.push_back(x);
            been[idx] = true;
        }
        return ret;
    }
};",1434313442
Hsin-Jui Chen,joshuachen0213,517,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int i = 1; i <= k; i++) {
            for (int j = 0; j < n; j++) {
                for (int l = 0; l < n; l++) {
                    if (l != j)
                        dp[i][j] =
                            max(dp[i][j], dp[i - 1][l] + travelScore[l][j]);
                    else
                        dp[i][j] = max(dp[i][j], dp[i - 1][l] + stayScore[i - 1][l]);
                }
            }
        }
        int ans = 0;
        for (auto x : dp[k])
            ans = max(ans, x);
        return ans;
    }
};",1434329903
Hsin-Jui Chen,joshuachen0213,517,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char cur = word[0];
        int l = word.length(), cur_cnt = 1;
        int ans = 1;
        for (int i = 1; i < l; i++) {
            if (word[i] == cur) {
                cur_cnt++;
            } else {
                cur = word[i];
                ans += cur_cnt - 1;
                cur_cnt = 1;
            }
        }
        ans += cur_cnt - 1;
        return ans;
    }
};",1434268479
Sagar,Kundu_003,520,3576,cpp,"class Solution {
public:
    void dfs(vector<vector<int>> &adj, int i, vector<int> &v, string &s, vector<multiset<int>> &adj2, vector<int> &p) {
        int x = v[s[i]-'a'];
        v[s[i]-'a'] = i;
        for(auto j : adj[i]) {
            dfs(adj,j,v,s,adj2,p);
        }
        v[s[i]-'a'] = x;
        if(x != -1) {
            int par = p[i];
            if(x != par) {
                adj2[par].erase(adj2[par].find(i));
                adj2[x].insert(i);
            }
        }
        return;
    }
    int dfs2(vector<multiset<int>> &adj2, int i, vector<int> &ans) {
        int cs = 1;
        for(auto j : adj2[i]) {
            cs += dfs2(adj2,j,ans);
        }
        return ans[i] = cs;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> v(26,-1);
        vector<vector<int>> adj(parent.size()+1);
        vector<multiset<int>> adj2(parent.size()+1);
        for(int i = 1 ; i < parent.size() ; i++) {
            adj[parent[i]].push_back(i);
            adj2[parent[i]].insert(i);
        }
        dfs(adj,0,v,s,adj2,parent);
        vector<int> ans(parent.size(),0);
        dfs2(adj2,0,ans);
        return ans;
    }
};",1434330139
Sagar,Kundu_003,520,3587,cpp,"class Solution {
public:
    int helper(int cc, int cd, int n, int k, vector<vector<int>> &ss, vector<vector<int>> &ts, vector<vector<int>> &dp) {
        if(cd == k) return 0;
        if(dp[cc][cd] != -1) return dp[cc][cd];
        int s = ss[cd][cc] + helper(cc,cd+1,n,k,ss,ts,dp);
        int m = 0;
        for(int i = 0 ; i < n ; i++) {
            m = max(m,ts[cc][i]+helper(i,cd+1,n,k,ss,ts,dp));
        }
        return dp[cc][cd] = max(s,m);
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n,vector<int>(k,-1));
        int ans = 0;
        for(int i = 0 ; i < n ; i++) {
            ans = max(ans,helper(i,0,n,k,stayScore,travelScore,dp));
        }
        return ans;
    }
};",1434289606
Sagar,Kundu_003,520,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        vector<int> c;
        char p = '0';
        int curr = 0;
        for(auto i : word) {
            if(i == p) {
                curr++;
            } else {
                c.push_back(curr);
                curr = 1;
                p = i;
            }
        }
        c.push_back(curr);
        for(auto i : c) {
            ans += (i-1);
        }
        return ans+1;
    }
};",1434269719
Emma,radiosilence,521,3576,python3,"from collections import defaultdict
from typing import List


class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [list() for _ in range(n)]
        for i, p in enumerate(parent):
            if i == 0:
                continue
            adj[p].append(i)

        ancestors = defaultdict(list)  # char: list of nodes

        def dfs(node):
            if ancestors[s[node]]:
                parent[node] = ancestors[s[node]][-1]
            ancestors[s[node]].append(node)
            for child in adj[node]:
                dfs(child)
            ancestors[s[node]].pop()

        dfs(0)
        # Redo the new adjacency list
        adj = [list() for _ in range(n)]
        for i, p in enumerate(parent):
            if i == 0:
                continue
            adj[p].append(i)

        answer = [0] * n

        def dfs_subtree_size(node):
            size = 1
            for child in adj[node]:
                size += dfs_subtree_size(child)
            answer[node] = size
            return size
        dfs_subtree_size(0)
        return answer",1434300923
Emma,radiosilence,521,3587,python3,"class Solution:
    # n cities
    # k days
    # stayScore[day][city]
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        memo = [[-1] * n for _ in range(k)]  # memo[day][city]

        def helper(day, city):
            if day == k:
                return 0
            if memo[day][city] != -1:
                return memo[day][city]
            # Stay
            result = stayScore[day][city] + helper(day+1, city)
            # Move
            for other_city in range(n):
                if other_city == city:
                    continue
                result = max(result, travelScore[city][other_city] + helper(day+1, other_city))
            memo[day][city] = result
            return result

        answer = float('-inf')
        for start in range(n):
            answer = max(answer, helper(0, start))
        return answer",1434330183
Emma,radiosilence,521,3617,python3,"import itertools


class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for k, gr in itertools.groupby(word):
            l = len(list(gr))
            ans += l - 1
        return ans",1434271333
Srinjoy Sengupta,srinjoy003,522,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        closest = {}
        children = defaultdict(list)
        res = [1] * len(parent)

        for i in range(1, len(parent)):
            children[parent[i]].append(i)

        

        def recurse(root, track):

            val = s[root]

            # print(val, root, track)

            if val in track:
                newParent = track[val]
                parent[root] = newParent
                
            track[val] = root

        
            for child in children[root]:
                recurse(child, track.copy())

        def findSize(root):

            for child in children[root]:
                res[root] += findSize(child)

            return res[root]

        recurse(0, {})

        children = defaultdict(list)

        for i in range(1, len(parent)):
            children[parent[i]].append(i)

        findSize(0)
        

        return res
                
            
        
        ",1434292897
Srinjoy Sengupta,srinjoy003,522,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        h = {}

        def recurse(day, city):

            if day == k:
                return 0
              

            cost = 0

            key = (day, city)

            if key in h:
                return h[key]
                
            for newCity in range(n):
                if newCity == city:
                    cost = max(cost, stayScore[day][city] + recurse(day+1, city))

                else:
                    cost = max(cost, travelScore[city][newCity] + recurse(day+1, newCity))

            h[key] = cost
            return cost


        res = 0

        for city in range(n):
            res = max(res, recurse(0, city))

        return res


            
                    
                    
            
        ",1434323368
Srinjoy Sengupta,srinjoy003,522,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:

        count = 1

        # start = -1
        # end = -1

        for i in range(1,len(word)):
            if word[i] == word[i-1]:
                count += 1

        return count
            
        ",1434262196
Sumanth,sumanth977,523,3576,cpp,"#include <vector>
#include <string>
#include <unordered_map>

class Solution {
public:
    std::vector<int> findSubtreeSizes(std::vector<int>& parent, std::string s) {
        int n = parent.size();
        std::vector<std::vector<int>> adj(n);

        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        
        std::vector<int> newParent = parent;
        std::unordered_map<char, std::vector<int>> last_seen;
        
        std::function<void(int)> updateParentDFS = [&](int node) {
            char ch = s[node];
            if (last_seen.count(ch) && !last_seen[ch].empty()) {
                int ancestor = last_seen[ch].back();
                newParent[node] = ancestor;  
            }
            
            last_seen[ch].push_back(node);
            
            for (int child : adj[node]) {
                updateParentDFS(child);
            }
            
            last_seen[ch].pop_back();
        };
        
        updateParentDFS(0);
        

        std::vector<std::vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }
        
        std::vector<int> subtreeSizes(n, 0);
        
        std::function<int(int)> calculateSubtreeSize = [&](int node) {
            int size = 1;  
            for (int child : newAdj[node]) {
                size += calculateSubtreeSize(child);
            }
            subtreeSizes[node] = size;
            return size;
        };
        
        calculateSubtreeSize(0);
        
        return subtreeSizes;
    }
};",1434296256
Sumanth,sumanth977,523,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[-float('inf')] * n for _ in range(k)]
        
        for j in range(n):
            dp[0][j] = stayScore[0][j]
            for l in range(n):
                if l != j:
                    dp[0][j] = max(dp[0][j], travelScore[l][j])

        for i in range(1, k):
            prevDayScores = dp[i - 1].copy()
            for j in range(n):
                dp[i][j] = prevDayScores[j] + stayScore[i][j]
                for l in range(n):
                    if l != j:
                        dp[i][j] = max(dp[i][j], prevDayScores[l] + travelScore[l][j])
        
        return max(dp[k - 1])",1434323376
Sumanth,sumanth977,523,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ans = 0;
        for(int i = 1; i < n; i++){
            if(word[i] == word[i-1]){
                ans += 1;
            }
        }
        ans += 1;
        return ans;
    }
};",1434264912
sleepySasank,sleepySasank,525,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        adj = defaultdict(list)
        for i, x in enumerate(parent):
            if x != -1:
                adj[x].append(i)
                adj[i].append(x)
        
        nadj = defaultdict(list)  
        latest = [-1] * 26 

        def dfs(i, p):
            char_index = ord(s[i]) - ord('a')
            
            if latest[char_index] != -1 and latest[char_index] != p:
                nadj[latest[char_index]].append(i)
                nadj[i].append(latest[char_index])
            else:
                if p != -1:
                    nadj[p].append(i)
                    nadj[i].append(p)
            
            prev_latest = latest[char_index]
            latest[char_index] = i
            
            for v in adj[i]:
                if v != p:
                    dfs(v, i)
            
            latest[char_index] = prev_latest
        
        dfs(0, -1)
        
        sz = [0] * len(parent)
        
        def ndfs(i, p):
            sz[i] = 1  
            for v in nadj[i]:
                if v != p:
                    ndfs(v, i) 
                    sz[i] += sz[v] 
        
        ndfs(0, -1)
        
        return sz
",1434315341
sleepySasank,sleepySasank,525,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def go(day,curr):
            if day==k:
                return 0
            ans = stayScore[day][curr] + go(day + 1 ,curr)
            for i in range(n):
                if i!=curr:
                    ans = max(ans , travelScore[curr][i] + go(day + 1,i))
            return ans
        best = 0
        for i in range(n):
            r = go(0,i)
            # go.cache_clear()
            best = max(best,r)
        return best",1434323583
sleepySasank,sleepySasank,525,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        p = ["""".join(g) for k,g  in groupby(word)]
        N  = len(p)
        @cache
        def go(i,used):
            if i==N:
                return 1
            if used:
                return go(i+ 1, used)
            a = go(i+1,used)
            for j in range(len(p[i])-1):
                a+=go(i+1,True)
            return a
        r = go(0,False)
        go.cache_clear()
        return r
                ",1434265582
Raghav Reddy,raghav_reddyy,526,3576,cpp,"class Solution {
public:
    void dfs(int curr,vector<vector<int>>&adj,vector<vector<int>>&map,vector<int>&parent,string &s){
        if(map[s[curr]-'a'].size()!=0) parent[curr]=map[s[curr]-'a'].back();
        map[s[curr]-'a'].push_back(curr);
        for(int ch:adj[curr]){
            dfs(ch,adj,map,parent,s);
        }
        map[s[curr]-'a'].pop_back();
    }
    int len(int root,vector<vector<int>>&adj,vector<int>&res){
        int length=0;
        for(int ch:adj[root]){
            length+=1+len(ch,adj,res);
        }
        return res[root]=length;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size(),root=-1;
        vector<vector<int>>map(26);
        vector<vector<int>>adj(n);
        for(int i=0;i<n;i++){
            if(parent[i]==-1) root=i;
            else adj[parent[i]].push_back(i);
        }
        dfs(root,adj,map,parent,s);
        vector<int>res(n);
        vector<vector<int>>adj2(n);
    
        for(int i=0;i<n;i++){
            if(parent[i]==-1) root=i;
            else adj2[parent[i]].push_back(i);
        }
        len(root,adj2,res);
        for(int i=0;i<n;i++) res[i]++;
        return res;
    }
};",1434308975
Raghav Reddy,raghav_reddyy,526,3587,cpp,"class Solution {
public:
    int helper(int curr,int day,vector<vector<int>>& ss, vector<vector<int>>& ts,int n,int k,vector<vector<int>>&dp){
        if(day==k) return 0;
        if(dp[curr][day]!=-1) return dp[curr][day];
        int res=ss[day][curr]+helper(curr,day+1,ss,ts,n,k,dp);
        for(int des=0;des<n;des++){
            if(curr==des) continue;
            res=max(res,ts[curr][des]+helper(des,day+1,ss,ts,n,k,dp));
        }
        return dp[curr][day]=res;
    }
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        int res=0;
        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));
        for(int i=0;i<n;i++){
            res=max(res,helper(i,0,ss,ts,n,k,dp));
        }
        return res;
    }
};",1434330454
Raghav Reddy,raghav_reddyy,526,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res=0;
        int l=1,n=word.size();
        for(int i=1;i<n;i++){
            res+=word[i]==word[i-1];
        }
        // while(l<n && word[l]==word[l-1]) l++;
        return res+1;
    }
};",1434271313
Alpha_63,shubham_ss1,529,3576,cpp,"class Solution {
private:
    int cal(int node, const vector<vector<int>>& updatedAdjList, vector<int>& subtree) {
        int m = 1; // Start with size 1 for the current node
        for (int child : updatedAdjList[node]) {
         m += cal(child, updatedAdjList, subtree);
        }
        subtree[node] = m; // Store size of the current subtree
        return m; 
    }
    void dfs(int node, vector<int>& updatedParent, const vector<vector<int>>& adjList, vector<int>& latestAncestor, string& s) {
        int charIndex = s[node] - 'a'; // Get character index for the current node
        if (latestAncestor[charIndex] != -1 && latestAncestor[charIndex] != node) {
            updatedParent[node] = latestAncestor[charIndex]; // Update the parent based on the latest ancestor
        }

        int prevAncestor = latestAncestor[charIndex]; // Store the previous ancestor for restoration
        latestAncestor[charIndex] = node; // Update the latest ancestor for this character

        for (int child : adjList[node]) {
            dfs(child, updatedParent, adjList, latestAncestor, s); // Recur for children
        }

        latestAncestor[charIndex] = prevAncestor; // Restore the previous ancestor
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adjList(n);
        vector<int> updatedParent(n, -1); // Track updated parents
        // Build the adjacency list from the parent array
        for (int i = 1; i < n; i++) {
            adjList[parent[i]].push_back(i);
        }
        vector<int> latestAncestor(26, -1); // Track the latest ancestor for each character
        dfs(0, updatedParent, adjList, latestAncestor, s); // Perform DFS to update parents
        vector<vector<int>> updatedAdjList(n);
        for (int i = 1; i < n; ++i) {
            if (updatedParent[i] != -1) { // Ensure valid parent before accessing
                updatedAdjList[updatedParent[i]].push_back(i); // Build the updated adjacency list
            } else {
                updatedAdjList[parent[i]].push_back(i); // Keep the original parent if not updated
            }
        }
        vector<int> subtree(n, 0); // Vector to store subtree sizes
        cal(0, updatedAdjList, subtree); // Calculate subtree sizes
        return subtree; // Return the subtree sizes
    }
};
",1434330590
Alpha_63,shubham_ss1,529,3587,cpp,"class Solution {
public:
    int solve(int day, int curr, int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& dp) {
        if (day == k) {
            return 0;
        }
        if (dp[day][curr] != -1) {
            return dp[day][curr];
        }

        int maxi = stayScore[day][curr] + solve(day + 1, curr, n, k, stayScore, travelScore, dp);
        for (int i = 0; i < n; i++) {
            if (i != curr) {
                maxi = max(maxi, travelScore[curr][i] + solve(day + 1, i, n, k, stayScore, travelScore, dp));
            }
        }
        dp[day][curr] = maxi;
        return maxi;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, -1)); // Initialize DP table
        int result = 0;
        for (int start_city = 0; start_city < n; ++start_city) {
            result = max(result, solve(0, start_city, n, k, stayScore, travelScore, dp));
        }
        return result;
    }
};",1434312141
Alpha_63,shubham_ss1,529,3617,cpp,"class Solution {
public:
    int possibleStringCount(std::string word) {
        int n = word.size();
        vector<int> counts;
        int total = 1;
        for (int i = 0; i < n; ) {
            char current = word[i];
            int cnt = 0;

            while (i < n && word[i] == current) {
                cnt++;
                i++;
            }
            counts.push_back(cnt);
        }
        total = 1;
        for (int cnt : counts) {
            if (cnt > 1) {
                total += cnt - 1;
            }
        }
        return total;
    }
};",1434289196
Harsha,looksmaxxing,530,3576,cpp,"class Solution {
public:
    vector<int> sub;
    vector<vector<int>> adj;
    string s;
    void dfs1(int node, vector<int>& near, vector<int>& dep, vector<int>& ls) {
        int c = s[node] - 'a';
        if (ls[c] != -1) {
            near[node] = ls[c];
        }
        int ps = ls[c];
        ls[c] = node;
        for (int child : adj[node]) {
            dep[child] = dep[node] + 1;
            dfs1(child, near, dep, ls);
        }
        ls[c] = ps;
    }
    int dfs2(int node, vector<vector<int>>& newAdj) {
        sub[node] = 1;
        for (int child : newAdj[node]) {
            sub[node] += dfs2(child, newAdj);
        }
        return sub[node];
    }
     vector<int> findSubtreeSizes(vector<int>& par, string str) {
        int n = par.size();
        s = str;
        adj.resize(n);
        sub.resize(n);
        for (int i = 1; i < n; i++) {
            adj[par[i]].push_back(i);
        }
        vector<int> near(n, -1);
        vector<int> dep(n, 0);
        vector<int> ls(26, -1);
        dfs1(0, near, dep, ls);
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; i++) {
            int np = i;
            if (near[i] != -1 && dep[near[i]] < dep[par[i]]) {
                np = near[i];
            } else {
                np = par[i];
            }
            newAdj[np].push_back(i);
        }
        dfs2(0, newAdj);
        return sub;
    }
};",1434292511
Harsha,looksmaxxing,530,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelScore) {
        vector<vector<int>> temp(k, vector<int>(n, 0));
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = k - 1; day >= 0; day--) {
            for (int curr = 0; curr < n; curr++) {
                int stay = stayScore[day][curr] + dp[day + 1][curr];
                int tr = 0;
                for (int nex = 0; nex < n; nex++) {
                    if (nex != curr) {
                        tr = max(tr, travelScore[curr][nex] + dp[day + 1][nex]);
                    }
                }
                dp[day][curr] = max(stay, tr);
                temp[day][curr] = dp[day][curr];
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++){
            res = max(res, dp[0][i]);
        }
        return res;
    }
};",1434323887
Harsha,looksmaxxing,530,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length();
        int res = 0;
        res = 1;
        for(int i = 0; i < n;) {
            if (i < n-1 && word[i] == word[i+1]) {
                int count = 1;
                while (i + count < n && word[i] == word[i + count]) {
                    count++;
                }
                res += count - 1;
                i += count;
            } else {
                i++;
            }
        }
        
        return res;
    }
};",1434272244
Siddh Doshi,SiddhDoshi,531,3576,cpp,"class Solution {
public:
    void dfs(int node,vector<int> adj[],map<char,int> &mp,string &s,vector<int> &p){
        if(mp.find(s[node])!=mp.end())
        {
            p[node]=mp[s[node]];
        }
        for(auto it:adj[node])
        {
            bool flag=false;
            int temp;
            if(mp.find(s[node])!=mp.end())
            {
                flag=true;
                temp=mp[s[node]];
            }
            mp[s[node]]=node;
            dfs(it,adj,mp,s,p);  
            mp.erase(s[node]);
            if(flag)
            {
                mp[s[node]]=temp;
            }
        }
    }

    int subtree(int node,vector<int> adj[],vector<int> &ans)
    {
        int c=0;
        for(auto it:adj[node])
        {
            c+=subtree(it,adj,ans);   
        }
        return ans[node]=c+1;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> adj[parent.size()];
        map<char,int> mp;
        for(int i=1;i<parent.size();i++)
        {
            adj[parent[i]].push_back(i);
        }
        dfs(0,adj,mp,s,parent);

        vector<int> adj1[parent.size()];
        for(int i=1;i<parent.size();i++)
        {
            adj1[parent[i]].push_back(i);
        }
        vector<int> ans(parent.size());
        subtree(0,adj1,ans);
        return ans;
    }
};",1434292477
Siddh Doshi,SiddhDoshi,531,3587,cpp,"class Solution {
public:
    int func(int i,int k,vector<vector<int>>& ss, vector<vector<int>>& ts,vector<vector<int>> &dp,int curr,int n)
{
    if(i>=k)
    {
        return 0;
    }
    if(dp[i][curr]!=-1)
    {
        return dp[i][curr];
    }
    int ans=func(i+1,k,ss,ts,dp,curr,n)+ss[i][curr];
    for(int j=0;j<n;j++)
    {
        if(j!=curr)
        {
            ans=max(ans,func(i+1,k,ss,ts,dp,j,n)+ts[curr][j]);   
        }
    }
    return dp[i][curr]=ans;
}

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans=0;
        vector<vector<int>> dp(k+1,vector<int> (n+1,-1));
        for(int i=0;i<n;i++)
        {
            ans=max(ans,func(0,k,stayScore,travelScore,dp,i,n));
        }
        return ans;
    }
};",1434316836
Siddh Doshi,SiddhDoshi,531,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=0;
        for(int i=0;i<word.size();i++)
        {
            int c=0;
            char curr=word[i];
            while(i<word.size() && curr==word[i])
            {
                i++;
                c++;
            }
            i--;
            ans+=(c-1);
        }
        return ans+1;
    }
};",1434262017
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,532,3576,java,"class Solution {
      public void findp(int node, int par, String s, 
                                List<List<Integer>> graph, 
                                Map<Character, Integer> lastSeen, 
                                int[] newParent) {
        Integer prev = lastSeen.get(s.charAt(node));
        lastSeen.put(s.charAt(node), node);

        for (int child : graph.get(node)) {
            if (child != par) {
                Integer ancestor = lastSeen.get(s.charAt(child));
                if (ancestor != null) {
                    newParent[child] = ancestor;
                }
                findp(child, node, s, graph, lastSeen, newParent);
            }
        }
        
        if (prev != null) {
            lastSeen.put(s.charAt(node), prev);
        } else {
            lastSeen.remove(s.charAt(node));
        }
    }
    public int cbs(int node, List<List<Integer>> tree, int[] sizes) {
        int size = 1;
        for (int child : tree.get(node)) {
            size += cbs(child, tree, sizes);
        }
        sizes[node] = size;
        return size;
    }
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            graph.get(parent[i]).add(i);
        }

        int[] newParent = parent.clone();
        Map<Character, Integer> lastSeen = new HashMap<>();

        findp(0, -1, s, graph, lastSeen, newParent);

        List<List<Integer>> newTree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            newTree.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            newTree.get(newParent[i]).add(i);
        }

        int[] answer = new int[n];
        cbs(0, newTree, answer);

        return answer;
    }
}",1434311841
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,532,3587,java,"class Solution {
    private int[][] stayScore;
    private int[][] travelScore;
    private int[][][] memo;

    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.stayScore = stayScore;
        this.travelScore = travelScore;
        this.memo = new int[k][n][2];
        
        for (int day = 0; day < k; day++) {
            for (int city = 0; city < n; city++) {
                memo[day][city][0] = -1;
                memo[day][city][1] = -1;
            }
        }
        
        int maxPoints = 0;
        for (int startCity = 0; startCity < n; startCity++) {
            maxPoints = Math.max(maxPoints, dp(0, startCity, n, k));
        }
        
        return maxPoints;
    }

    private int dp(int day, int city, int n, int k) {
        if (day == k) {
            return 0;
        }

        if (memo[day][city][0] != -1) {
            return memo[day][city][0];
        }

        int stayPoints = stayScore[day][city] + dp(day + 1, city, n, k);

        int maxTravelPoints = 0;
        for (int nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity != city) {
                int travelPoints = travelScore[city][nextCity] + dp(day + 1, nextCity, n, k);
                maxTravelPoints = Math.max(maxTravelPoints, travelPoints);
            }
        }

        int maxPoints = Math.max(stayPoints, maxTravelPoints);
        memo[day][city][0] = maxPoints;
        return maxPoints;
    }
}
",1434324003
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,532,3617,java,"class Solution {
    public int possibleStringCount(String word) {
         int count = 1;
        int i = 0;
        
        while (i < word.length()) {
            int j = i;
            while (j < word.length() && word.charAt(j) == word.charAt(i)) {
                j++;
            }
            count += j - i - 1;
            i = j;
        }
        
        return count;
    }
}",1434274722
AYUSH ADARSH,adarshayush9939,534,3576,cpp,"class Solution {
public:
    vector<vector<int>> newGraph;
    void makeChange(vector<vector<int>>& graph,int i,vector<int> cur,string& s,int par){
        if(cur[s[i]-'a']!=-1){
            newGraph[cur[s[i]-'a']].push_back(i);
        }else if(par!=-1){
            newGraph[par].push_back(i);
        }
        cur[s[i]-'a']=i;
        for(auto& child: graph[i]){
            makeChange(graph,child,cur,s,i);
        }
    }
    vector<int> ans;
    int countNodes(int i){
        int cur = 1;
        for(auto& child: newGraph[i]){
            cur+=countNodes(child);
        }
        return ans[i]=cur;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        newGraph.resize(n);
        ans.resize(n);
        vector<vector<int>> graph(n);
        for(int i=1;i<n;i++){
            graph[parent[i]].push_back(i);
        }
        vector<int> cur(26,-1);
        makeChange(graph,0,cur,s,-1);
        countNodes(0);
        return ans;
    }
};",1434313315
AYUSH ADARSH,adarshayush9939,534,3587,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int solve(int& k,vector<vector<int>>& stayScore,vector<vector<int>>& travelScore,int curr,int& n,int d){
        if(d==k) return 0;
        if(dp[curr][d]!=-1) return dp[curr][d];
        int maxi = solve(k,stayScore,travelScore,curr,n,d+1)+stayScore[d][curr];
        for(int i=0;i<n;i++){
            if(i==curr) continue;
            maxi = max(maxi, solve(k,stayScore,travelScore,i,n,d+1)+travelScore[curr][i]);
        }
        return dp[curr][d] = maxi;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int maxi = 0;
        dp.resize(n,vector<int>(k,-1));
        for(int i=0;i<n;i++){
            maxi = max(maxi,solve(k,stayScore,travelScore,i,n,0));
        }
        return maxi;
    }
};",1434330942
AYUSH ADARSH,adarshayush9939,534,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int n=word.size(),j=0;
        for(int i=0;i<n;i++){
            while(j<n and word[j]==word[i]) j++;
            ans+=(j-i-1);
            i=j-1;
        }
        return ans;
    }
};",1434271349
Rahul Kumar,user6497G,535,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> adj = new ArrayList<>(n);
        int[] answer = new int[n];
        Arrays.fill(answer, 1); 

        init(adj, n, parent);
        
        int[] newParent = Arrays.copyOf(parent, n);
        Map<Character, List<Integer>> visited = new HashMap<>();

        reassignParents(0, s, adj, visited, newParent);

        List<List<Integer>> newAdj = new ArrayList<>(n);
        init(newAdj, n, newParent);

        computeSubtreeSizes(0, newAdj, answer);

        return answer;
    }
    
    private void init(List<List<Integer>> adj, int n, int[] parent) {
         for (int i = 0; i < n; i++){
            adj.add(new ArrayList<>());
        } 
        for (int i = 1; i < n; i++){
            adj.get(parent[i]).add(i);

        } 
    }
    
    private void reassignParents(int node, String str, List<List<Integer>> adj, 
                                 Map<Character, List<Integer>> visited, int[] newParent) {
        char ch = str.charAt(node);
        visited.putIfAbsent(ch, new ArrayList<>());

        if (!visited.get(ch).isEmpty()) {
            newParent[node] = visited.get(ch).get(visited.get(ch).size() - 1);
        }

        visited.get(ch).add(node);
        for (int child : adj.get(node)) {
            reassignParents(child, str, adj, visited, newParent);
        }
        visited.get(ch).remove(visited.get(ch).size() - 1);
    }

    private int computeSubtreeSizes(int node, List<List<Integer>> newAdj, int[] answer) {
        int size = 1;
        for (int child : newAdj.get(node)) {
            size += computeSubtreeSizes(child, newAdj, answer);
        }
        answer[node] = size;
        return size;
    }
}",1434319620
Rahul Kumar,user6497G,535,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k+1][n];
        int maxPoints = 0;
        for(int i=0;i<k;i++) {
            for(int j=0;j<n;j++) {
                dp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]+stayScore[i][j]);
                for(int l=0;l<n;l++) {
                    if(j!=l) {
                        dp[i+1][l] = Math.max(dp[i+1][l], dp[i][j]+travelScore[j][l]);
                    }
                }
            }
        }
        
        for(int i=0;i<n;i++) {
            maxPoints = Math.max(maxPoints, dp[k][i]);
        }
        
        return maxPoints;
    }
}",1434330944
Rahul Kumar,user6497G,535,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int result = 1;
        int n = word.length();
        for(int i=0;i<n;i++) {
            int cnt = 1;
            while(i+1 <n && word.charAt(i) == word.charAt(i+1)){
                cnt++;
                i++;
            }
            result += cnt-1;
        }
        
        return result;
    }
}",1434293359
Manish Kumar,sun_rise,536,3576,cpp,"class Solution {
public:
    vector<int> subnodes;
    vector<vector<int>> adj, ancestors;
    
    void dfs2(int u, int p) {
        subnodes[u] = 1;
        for(int to: adj[u]) {
            if(to != p) {
                dfs2(to, u);
                subnodes[u] += subnodes[to];
            }
        }
    }
    void dfs(int u, int p, vector<int>& parent, string& s) {
        int ch = s[u]-'a';
        if(p != -1 && s[p] != s[u] && !ancestors[ch].empty()) {
            parent[u] = ancestors[ch].back();
        }
        ancestors[ch].push_back(u);
        
        for(int to: adj[u]) {
            if(to != p) {
                dfs(to, u, parent, s);  
            }
        }
        ancestors[ch].pop_back();
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        adj.resize(n);
        ancestors.resize(26);
        // changing links
        for(int i = 1; i < n; i++) {
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        dfs(0, -1, parent, s);
        
        // calc subnodes
        adj.clear();
        adj.resize(n);
        subnodes.assign(n, 0);
        for(int i = 1; i < n; i++) {
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        dfs2(0, -1);
        return subnodes;
    }
};",1434330959
Manish Kumar,sun_rise,536,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        int dp[200][201] = {0};
        for(int d = 1; d <= k; d++) {
            for(int c = 0; c < n; c++) {
                for(int c2 = 0; c2 < n; c2++) {
                    if(c2 == c) 
                        dp[c][d] = max(dp[c][d], dp[c][d-1]+stayScore[k-d][c]);
                    else
                        dp[c][d] = max(dp[c][d], dp[c2][d-1]+travelScore[c][c2]);
                }
                if(d == k) {
                    ans = max(ans, dp[c][d]);
                }
            }
        }
        return ans;
    }
};",1434300828
Manish Kumar,sun_rise,536,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int n = s.size(), ans = 1;
        for(int i = 0; i < n;) {
            int j = i;
            while(i < n && s[i] == s[j]) {
                i++;
            }
            ans += (i-j-1);
        }
        return ans;
    }
};",1434265983
Jahnavi,jahnavinischal,537,3576,java,"import java.util.*;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> tree = new ArrayList<>(); // Adjacency list for the original tree
        List<List<Integer>> newTree = new ArrayList<>(); // New tree after re-parenting
        int[] subtreeSize = new int[n]; // Result array for subtree sizes

        // Initialize adjacency lists
        for (int i = 0; i < n; i++) {
            tree.add(new ArrayList<>());
            newTree.add(new ArrayList<>());
        }

        // Build the original tree structure
        for (int i = 1; i < n; i++) {
            tree.get(parent[i]).add(i);
        }

        // Map to track the closest ancestors for each character
        Map<Character, Deque<Integer>> charStack = new HashMap<>();

        // DFS to re-parent nodes based on the closest ancestor with a matching character
        dfsReparent(0, s, parent, tree, newTree, charStack);

        // Calculate subtree sizes in the new tree structure
        dfsSubtreeSize(0, newTree, subtreeSize);

        return subtreeSize;
    }

    private void dfsReparent(int node, String s, int[] parent, List<List<Integer>> tree, List<List<Integer>> newTree, Map<Character, Deque<Integer>> charStack) {
        char currentChar = s.charAt(node);

        // If theres a matching ancestor, re-parent the current node
        if (charStack.containsKey(currentChar) && !charStack.get(currentChar).isEmpty()) {
            int newParent = charStack.get(currentChar).peek();
            newTree.get(newParent).add(node); // Update the new tree structure
        } else {
            // Maintain the original parent if no match is found
            if (node != 0) {
                newTree.get(parent[node]).add(node);
            }
        }

        // Push current node onto the stack for its character
        charStack.computeIfAbsent(currentChar, k -> new ArrayDeque<>()).push(node);

        // Process all children in the original tree
        for (int child : tree.get(node)) {
            dfsReparent(child, s, parent, tree, newTree, charStack);
        }

        // Pop the current node from the stack after processing its subtree
        charStack.get(currentChar).pop();

        // Remove the stack entry if it's empty to prevent memory leaks
        if (charStack.get(currentChar).isEmpty()) {
            charStack.remove(currentChar);
        }
    }

    private int dfsSubtreeSize(int node, List<List<Integer>> newTree, int[] subtreeSize) {
        int size = 1; // Start with the current node itself
        for (int child : newTree.get(node)) {
            size += dfsSubtreeSize(child, newTree, subtreeSize);
        }
        subtreeSize[node] = size;
        return size;
    }
}
",1434309589
Jahnavi,jahnavinischal,537,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        // Create a 2D array to store the maximum points for each day and city
        int[][] dp = new int[k + 1][n];

        // Iterate over the number of days
        for (int day = 0; day < k; day++) {
            // Check each city
            for (int curr = 0; curr < n; curr++) {
                // Calculate points for staying in the current city
                dp[day + 1][curr] = dp[day][curr] + stayScore[day][curr];

                // Check the possibility of moving to another city
                for (int dest = 0; dest < n; dest++) {
                    if (dest != curr) {
                        dp[day + 1][curr] = Math.max(dp[day + 1][curr], dp[day][dest] + travelScore[dest][curr]);
                    }
                }
            }
        }

        // Find the maximum points obtainable after k days
        int maxPoints = 0;
        for (int score : dp[k]) {
            maxPoints = Math.max(maxPoints, score);
        }
        return maxPoints;
    }
}
",1434288696
Jahnavi,jahnavinischal,537,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        // List to store lengths of consecutive character runs
        List<Integer> runLengths = new ArrayList<>();
        int count = 1;

        // Step 1: Identify lengths of consecutive character runs
        for (int i = 1; i < word.length(); i++) {
            if (word.charAt(i) == word.charAt(i - 1)) {
                count++;
            } else {
                runLengths.add(count);
                count = 1;
            }
        }
        runLengths.add(count); // Add the last run

        // Step 2: Calculate the total number of possible original strings
        int totalPossibilities = 1; // Start with the original word as one possibility
        for (int len : runLengths) {
            if (len > 1) {
                totalPossibilities += len - 1; // Add the number of ways to reduce this run
            }
        }

        return totalPossibilities;
    }
}
",1434278846
timothyleong97,timothyleong97,538,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        var nearestAncestor = new HashMap<Character, Integer>();
        var newParent = new HashMap<Integer, Integer>();
        var adjacencyList = makeAdjacencyList(parent);
        reassign(nearestAncestor, newParent, adjacencyList, s, 0);

        var newAdjacencyList = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < parent.length; ++i) newAdjacencyList.add(new ArrayList<>());
        for (int i = 0; i < parent.length; ++i) {
            if (newParent.containsKey(i)) {
                newAdjacencyList.get(newParent.get(i)).add(i);
            } else if (parent[i] != -1) {
                newAdjacencyList.get(parent[i]).add(i);
            }
        }
        count(newAdjacencyList, parent, 0);
        return parent;
    }

    private void count(ArrayList<ArrayList<Integer>> graph, int[] size, int curr) {
        int result  = 1;
        for (int child : graph.get(curr)) {
            count(graph, size, child);
            result += size[child];
        }
        size[curr] = result;
    }

    private ArrayList<ArrayList<Integer>> makeAdjacencyList(int[] parent) {
        var result = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < parent.length; ++i) result.add(new ArrayList<>());
        for (int i = 0; i < parent.length; ++i) {
            if (parent[i] != -1) {
                result.get(parent[i]).add(i);
            }
        }
        return result;
    }

    private void reassign(HashMap<Character, Integer> nearestAncestor,
                          HashMap<Integer, Integer> newParent,
                          ArrayList<ArrayList<Integer>> adjacencyList,
                          String s,
                          int currNode) {
        final char curr = s.charAt(currNode);

        if (nearestAncestor.containsKey(curr)) {
            newParent.put(currNode, nearestAncestor.get(curr));
        }
        
        Integer prevNearestAncestor = nearestAncestor.get(curr);
        nearestAncestor.put(curr, currNode);

        for (int neighbour : adjacencyList.get(currNode)) {
            reassign(nearestAncestor, newParent, adjacencyList, s, neighbour);
        }

        if (prevNearestAncestor == null) {
            nearestAncestor.remove(curr);
        } else {
            nearestAncestor.put(curr, prevNearestAncestor);
        }
    }
}",1434321114
timothyleong97,timothyleong97,538,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(currentDay: int, currentCity: int) -> int:
            if currentDay == k:
                return 0 # Cannot travel anymore

            result = 0
            for otherCity in range(n):
                if otherCity != currentCity:
                    result = max(result, dp(currentDay + 1, otherCity) + travelScore[currentCity][otherCity])
                else:
                    result = max(result, dp(currentDay + 1, currentCity) + stayScore[currentDay][currentCity])
            return result

        return max(dp(0, i) for i in range(n))",1434331125
timothyleong97,timothyleong97,538,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int result = 1;
        for (int i = 0; i < word.length();) {
            int count = 0;
            int j = i;
            for (; j < word.length() && word.charAt(i) == word.charAt(j); ++j) {
                ++count;
            }
            result += count - 1;
            i = j;
        }
        return result;
    }
}",1434286138
nick698715,nick698715,539,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adjacency(n);
        array<vector<int>, 26> mapping{};
        vector<int> ret(n);
        
        for (int i = 1; i < n; ++i) {
            adjacency[parent[i]].push_back(i);
        }

        dfs(0, adjacency, s, parent, mapping);

        adjacency.clear();
        adjacency.resize(n);

        for (int i = 1; i < n; ++i) {
            adjacency[parent[i]].push_back(i);
        }
        traverse(0, adjacency, ret);

        return ret;
    }

private:
    void dfs(int idx, const vector<vector<int>> &adjacency, const string &s, 
        vector<int> &parent, array<vector<int>, 26> &mapping) {
        int current = s[idx] - 'a';
        mapping[current].push_back(idx);

        for (const auto next: adjacency[idx]) {
            dfs(next, adjacency, s, parent, mapping);
        }

        mapping[current].pop_back();

        if (mapping[current].size()) {
            parent[idx] = mapping[current].back();
        }
    }

    int traverse(int idx, const vector<vector<int>> &adjacency, vector<int> &ret) {
        int sum = 0;
        for (const auto next: adjacency[idx]) {
            sum += traverse(next, adjacency, ret);
        }

        return ret[idx] = sum + 1;
    }
};",1434307012
nick698715,nick698715,539,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> prev(n), curr(n);

        for (int i = 0; i < n; ++i) {
            prev[i] = stayScore[k-1][i];
            for (int j = 0; j < n; ++j) {
                prev[i] = max(prev[i], travelScore[i][j]);
            }
        }
        
        for (int i = k -2; i >= 0; --i) {
            for (int j = 0; j < n; ++j) {
                curr[j] = stayScore[i][j] + prev[j];
                for (int k = 0; k < n; ++k) {
                    curr[j] = max(curr[j], travelScore[j][k] + prev[k]);
                }
            }
            prev = curr;
        }

        return *max_element(prev.begin(), prev.end());
    }
};",1434331153
nick698715,nick698715,539,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int ret = 0;
        int count = 1;
        
        for (int i = 1; i < n; ++i) {
            if (word[i] == word[i-1]) {
                ++count;
            } else {
                ret += count -1;
                count = 1;
            }
        }

        return ret + count;
    }
};",1434269504
Waster,waster,540,3576,cpp,"class Solution {
public:
    void dfs1(int cur, unordered_map<char, int> &mp, vector<int>& parent,vector<vector<int>> &child, string &s){
        if(mp.find(s[cur]) != mp.end())
            parent[cur] = mp[s[cur]];
        bool isp = mp.find(s[cur]) != mp.end();
        int pre = 0;
        if(isp){
            pre = mp[s[cur]];
        }
        mp[s[cur]] = cur;
        for(int nex: child[cur]){
            dfs1(nex, mp, parent, child, s);
        }
        if(isp){
            mp[s[cur]] = pre;
        }else{
            mp.erase(s[cur]);
        }
    }
    int dfs2(int cur, vector<vector<int>> &child, vector<int> &res){
        int cnt = 1;
        for(int nex: child[cur]){
            cnt += dfs2(nex, child, res);
        }
        res[cur] = cnt;
        return cnt;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        unordered_map<char, int> mp;
        vector<vector<int>> child(parent.size());
        vector<int>res(parent.size());
        int cnt = 0;
        for(int i = 0; i < parent.size(); i++){
            if(parent[i] != -1)
                child[parent[i]].push_back(i);
        }
        dfs1(0, mp, parent, child, s);
        vector<vector<int>> child2(parent.size());
        for(int i = 0; i < parent.size(); i++){
            if(parent[i] != -1)
                child2[parent[i]].push_back(i);
        }
        dfs2(0, child2, res);
        return res;
    }
};",1434331181
Waster,waster,540,3587,cpp,"class Solution {
public:
    int dp[205][205]; //city, day
    int dfs(int i, int j, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
        if(j == k)
            return 0;
        if(dp[i][j] == -1){
            dp[i][j] = dfs(i, j+1, k, stayScore, travelScore) + stayScore[j][i];
            for(int nex = 0; nex < travelScore.size(); nex++){
                if(nex != i){
                    dp[i][j] = max(dp[i][j], dfs(nex, j+1, k, stayScore, travelScore) +travelScore[i][nex]);
                }
            }
        }
        //cout << i << j << "" "" << dp[i][j] << endl;
        return dp[i][j];
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memset(dp, -1, sizeof(dp));
        int res = 0;
        for(int i = 0; i < travelScore.size(); i++){
            res = max(res, dfs(i, 0, k, stayScore, travelScore));
        }
        return res;
    }
};",1434302443
Waster,waster,540,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        int cur = 1;
        for(int i = 1; i < word.size(); i++){
            if(word[i] == word[i-1]){
                cur++;
            }else{
                res += cur-1;
                cur = 1;
            }
        }
        res += cur-1;
        return res;
    }
};",1434265166
Zhu,user3593Z,541,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        char[] arr = s.toCharArray();
        Map<Integer, List<Integer>> map = new HashMap<>();
        
        for (int i = 1; i < n; i++) {
            map.computeIfAbsent(parent[i], x -> new ArrayList<>()).add(i);
        }
        
        Map<Integer, List<Integer>> map2 = new HashMap<>();
        Map<Character, Stack<Integer>> last = new HashMap<>();
        
        dfs(arr, map, 0, last, map2);
        
        // System.out.println(map2);
        int[] result = new int[n];
        countSize(map2, 0, result);
        return result;
    }
    
    void countSize(Map<Integer, List<Integer>> map, int cur, int[] result) {
        int r = 1;
        for (int next: map.getOrDefault(cur, new ArrayList<>())) {
            countSize(map, next, result);
            r += result[next];
        }
        result[cur] = r;
    }
    
    void dfs(char[] arr, Map<Integer, List<Integer>> map, int cur, Map<Character, Stack<Integer>> last, Map<Integer, List<Integer>> map2) {
        last.computeIfAbsent(arr[cur], x -> new Stack<Integer>()).push(cur);
        for (int next: map.getOrDefault(cur, new ArrayList<>())) {
            if (last.containsKey(arr[next])) {
                Stack<Integer> s = last.get(arr[next]);
                if (s.size() > 0) {
                    int t = s.peek();
                    map2.computeIfAbsent(t, x -> new ArrayList<>()).add(next);
                } else {
                    map2.computeIfAbsent(cur, x -> new ArrayList<>()).add(next);
                }
            } else {
                map2.computeIfAbsent(cur, x -> new ArrayList<>()).add(next);
            }
            dfs(arr, map, next, last, map2);
        }
        last.get(arr[cur]).pop();
    }
}",1434294013
Zhu,user3593Z,541,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {

        int[][] dp1 = new int[k + 1][n];
        int[][] dp2 = new int[k + 1][n];

        for (int i = 1; i <= k; i++) {
            for (int j = 0; j < n; j++) {
                dp1[i][j] = Math.max(dp1[i - 1][j], dp2[i - 1][j]) + stayScore[i - 1][j];
            }

            for (int j = 0; j < n; j++) {
                for (int h = 0; h < n; h++) {
                    dp2[i][j] = Math.max(dp2[i][j], dp1[i - 1][h] + travelScore[h][j]);
                    dp2[i][j] = Math.max(dp2[i][j], dp2[i - 1][h] + travelScore[h][j]);
                }
            }
        }

        int result = 0;
        for (int i = 0; i < n; i++) {
            result = Math.max(result, Math.max(dp1[k][i], dp2[k][i]));
        }

        return result;
    }
}",1434331207
Zhu,user3593Z,541,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int n = word.length();
        
        int result = 0;
        
        for (int i = 0; i < n; i++) {
            int j = i;
            while (j < n && word.charAt(j) == word.charAt(i)) j++;
            
            result += j - i - 1;
            i = j - 1;
        }
        
        return result + 1;
    }
}",1434263277
Sarvagya Sharma,sarvagya2545,542,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> original(n);
        vector<int> cpy;
        for(int x: parent) cpy.push_back(x);
        
        for(int i = 1; i < n; i++) {
            original[parent[i]].push_back(i);
        }
        
        auto dfs = [&](auto dfs, int node, vector<int> &char_node_map) -> void {
            if(char_node_map[s[node] - 'a'] != -1) cpy[node] = char_node_map[s[node] - 'a'];
            
            int prev = char_node_map[s[node] - 'a'];
            char_node_map[s[node] - 'a'] = node;
            for(int next: original[node]) {
                dfs(dfs, next, char_node_map);
            }
            
            char_node_map[s[node] - 'a'] = prev;
        };
        
        vector<int> char_node_map(26, -1);
        dfs(dfs, 0, char_node_map);
        
        vector<vector<int>> graph(n);
        for(int i = 1; i < n; i++) {
            graph[cpy[i]].push_back(i);
        }
        
        // return cpy;
        
        vector<int> subtree_size(n, 0);
        auto dfs2 = [&](auto dfs2, int node) -> int {
            subtree_size[node] += 1;
            for(int next: graph[node]) {
                subtree_size[node] += dfs2(dfs2, next);
            }
            return subtree_size[node];
        };
        
        dfs2(dfs2, 0);
        
        return subtree_size;
    }
};",1434331219
Sarvagya Sharma,sarvagya2545,542,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int> (k + 1, 0));
        
        for(int day = k - 1; day >= 0; day--) {
            for(int city = 0; city < n; city++) {
                for(int next_city = 0; next_city < n; next_city++) {
                    dp[city][day] = max(dp[city][day], 
                                        dp[next_city][day + 1] + (
                                            city == next_city ? stayScore[day][city] : travelScore[city][next_city]
                                        ));
                }
            }
        }
        
        int ans = 0;
        for(int city = 0; city < n; city++) ans = max(ans, dp[city][0]);
        return ans;
    }
};",1434299260
Sarvagya Sharma,sarvagya2545,542,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int cnt = 1;
        int ans = 0;
        for(int i = 1; i <= n; i++) {
            if(i < n and word[i] == word[i - 1]) cnt++;
            else {
                ans += cnt - 1;
                cnt = 1;
            }
        }
        
        return 1 + ans;
    }
};",1434286032
WASIM AKRAM,wasimakram692004,543,3576,cpp,"class Solution {

    void dfs( int currNode, vector<int> closestA ,vector<set<int>> &adjList, string &s ){

        closestA[s[currNode]-'a'] = currNode ;
        vector<pair<int,int>> removalCh ;
        
        for( auto child : adjList[currNode] ){
            if( closestA[s[child]-'a'] != -1 ){
                removalCh.push_back({child, closestA[s[child]-'a']}) ;
            }
            dfs( child, closestA, adjList, s ) ;
        }
        for( auto p : removalCh ){
            int ch = p.first ;
            int pa = p.second ;
            adjList[currNode].erase(ch) ;
            adjList[pa].insert(ch) ;
        }
    }

    int dfs2( int currNode , int par, vector<set<int>> &adjList, vector<int> &subSize ){

        int ta = 1 ;
        for( auto child : adjList[currNode] ){
            if( child == par ) continue ;
            ta += dfs2( child , currNode , adjList , subSize ) ;
        }
        return subSize[currNode] = ta ;
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {

        int n = parent.size() ;
        vector<int> closestA(26, -1) ;

        vector<set<int>> adjList(n) ;
        for( int i=1 ; i<n ; i++ ){
            adjList[parent[i]].insert(i) ;
        }

        dfs(0, closestA, adjList, s) ;

        vector<int> subSize(n) ;
        dfs2(0, -1, adjList, subSize ) ;
        return subSize ;
        
    }
};",1434303300
WASIM AKRAM,wasimakram692004,543,3587,cpp,"class Solution {

    int dpSolve( int day, int city, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>> &dp){

        int n = travelScore.size() ;
        int k = stayScore.size() ;
        //base case 
        if( day>=k ) return 0 ;

        //memo
        if( dp[day][city] != -1 ) return dp[day][city] ;

        //tansition
        //stay
        int maxi = dpSolve( day+1 , city, stayScore, travelScore, dp ) + stayScore[day][city] ;
        //travel
        for( int i=0 ; i<n ; i++ ){
            maxi = max( maxi, dpSolve( day+1, i, stayScore, travelScore, dp)+travelScore[city][i] ) ;
        }

        return dp[day][city] = maxi ;
        
    }
    
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k,vector<int>(n+1,-1)) ;
        int ans = 0 ;
        for( int i=0 ; i<n ; i++ ){
            ans = max( ans, dpSolve( 0, i, stayScore, travelScore, dp) ) ;
        }

        // for( auto vec : dp ){
        //     for( auto i : vec ) cout << i << "" "" ;
        //     cout << endl ;
        // }
        
        return ans ;
    }
};",1434331271
WASIM AKRAM,wasimakram692004,543,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {

        int cnt = 1 ;
        int ans = 1 ;
        for( int i=1 ; i<word.size() ; i++ ){
            if( word[i] == word[i-1] ) cnt++ ;
            else{
                ans += cnt-1 ;
                cnt = 1 ;
            }
        }
        ans += cnt-1 ;
        return ans ;
        
    }
};",1434265052
SainiAyush,SainiAyush,544,3576,cpp,"class Solution {
void dfs_find_ancestor(int node, vector<int>& parent, vector<vector<int>>& tree, string& s, vector<int>& closest_ancestor, vector<int>& new_parent, vector<int>& last_seen) {
    if (last_seen[s[node] - 'a'] != -1) {
        closest_ancestor[node] = last_seen[s[node] - 'a'];
    }
    
    int previous = last_seen[s[node] - 'a'];
    last_seen[s[node] - 'a'] = node;

    if (closest_ancestor[node] != -1) {
        new_parent[node] = closest_ancestor[node];
    }

    for (int child : tree[node]) {
        dfs_find_ancestor(child, parent, tree, s, closest_ancestor, new_parent, last_seen);
    }

    last_seen[s[node] - 'a'] = previous;
}

void calculate_subtree_sizes(int root, const vector<vector<int>>& modified_tree, vector<int>& subtree_size) {
    stack<int> stk;
    vector<bool> visited(subtree_size.size(), false);
    stk.push(root);
    
    while (!stk.empty()) {
        int node = stk.top();
        
        if (!visited[node]) {
            visited[node] = true;
            for (int child : modified_tree[node]) {
                stk.push(child);
            }
        } else {
            stk.pop();
            int size = 1;
            for (int child : modified_tree[node]) {
                size += subtree_size[child];
            }
            subtree_size[node] = size;
        }
    }
}
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        const int n = parent.size();
        vector<vector<int>> tree(n);
        for (int child = 1; child < n; ++child) {
            int p = parent[child];
            tree[p].push_back(child);
        }
    
        vector<int> closest_ancestor(n, -1);
        vector<int> new_parent = parent;
        vector<int> subtree_size(n, 0);
        vector<int> last_seen(26, -1);  
    
        dfs_find_ancestor(0, parent, tree, s, closest_ancestor, new_parent, last_seen);
    
        vector<vector<int>> modified_tree(n);
        for (int i = 1; i < n; ++i) {
            modified_tree[new_parent[i]].push_back(i);
        }
    
        calculate_subtree_sizes(0, modified_tree, subtree_size);
    
        return subtree_size;
    }
};",1434331312
SainiAyush,SainiAyush,544,3587,cpp,"class Solution {
public:
    int maxScore(int n, int K, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector dp(n + 1, vector(K + 2, -1));
        function<int(int, int)> dfs = [&] (int u, int k){
            if(k == K) return 0;
            int& ret = dp[u][k];
            if(~ret) return ret;
            for(int i = 0; i < n; ++i){
                if(i == u) ret = max(ret, stayScore[k][u] + dfs(u, k + 1));
                else ret = max(ret, travelScore[u][i] + dfs(i, k + 1));
            }
            return ret;
        };
        int mx = 0;
        for(int i = 0; i < n; ++i){
            mx = max(mx, dfs(i, 0));
        }
        return mx;
    }
};",1434288446
SainiAyush,SainiAyush,544,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for(int i = 0; i < word.size(); ){
            int j = i;
            while(j < word.size() && word[i] == word[j]) ++j;
            if(j - i != 1) ans += j - i - 1;
            i = j;
        }
        return ans;
    }
};",1434269714
Takamimi-sama,takamimi_sama,545,3576,cpp,"class Solution {
public:
    vector<int>ans;
    vector<int>pos[26];
    int n;
    vector<vector<int>>adj;
    string s;
    int f(int i,int p){
        char c = s[i];
        pos[c-'a'].push_back(i);
        for(auto j:adj[i])
            ans[i]+=f(j,i);
        pos[c-'a'].pop_back();
        int z=0;
        if(pos[c-'a'].size()){
            int x = pos[c-'a'].back();
            if(x!=p){
                ans[x]+=ans[i];
                return 0;
            }
        }
        return ans[i];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string sw) {
        n=parent.size();
        s=sw;
        for(int i=0;i<26;i++)pos[i].clear();
        adj.resize(n);
        for(int i=1;i<n;i++)
            adj[parent[i]].push_back(i);
        ans.resize(n,1);
        f(0,-1);
        return ans;
    }
};",1434295366
Takamimi-sama,takamimi_sama,545,3587,cpp,"class Solution {
public:
    int n,k;
    vector<vector<int>>dp,stay,travel;
    int f(int i,int j){
        if(j==k)return 0;
        if(dp[i][j]!=-1)return dp[i][j];
        dp[i][j] = stay[j][i] + f(i,j+1);
        for(int k=0;k<n;k++)
            if(k!=i){
                dp[i][j] = max(dp[i][j],travel[i][k]+f(k,j+1));
            }
        return dp[i][j];
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans=0;
        this->n=n;
        this->k=k;
        stay = stayScore;
        travel = travelScore;
        dp=vector<vector<int>>(n,vector<int>(k,-1));
        for(int i=0;i<n;i++){
            ans=max(ans,f(i,0));
        }
        return ans;
    }
};",1434331346
Takamimi-sama,takamimi_sama,545,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1,c=0;
        char x='.';
        for(auto i:word){
            if(i==x){
                c++;
            }
            else
                ans+=c,c=0;
            x=i;
        }
        ans+=c;
        return ans;
    }
};",1434264503
Rishabh Jain,rishcusion131072,546,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        vector <int> new_parent(n+3,-1);
        vector <vector <int>> g(n),new_g(n);
        for(int i=1;i<n;i++){
            g[parent[i]].push_back(i);
        }
        vector <vector <int>> ch(30);
        function <void(int)> dfs=[&](int u){
            if(ch[s[u]-'a'].empty()){
                new_parent[u]=parent[u];
            }
            else{
                new_parent[u]=ch[s[u]-'a'].back();
            }
            ch[s[u]-'a'].push_back(u);
            for(auto &v:g[u]){
                dfs(v);
            }
            ch[s[u]-'a'].pop_back();
        };
        vector <int> res(n,0);
        function <int(int)> dfs2=[&](int u){
            int sz=1;
            for(auto &v:new_g[u]){
                sz+=dfs2(v);
            }
            return res[u]=sz;
        };
        dfs(0);
        for(int i=1;i<n;i++){
            new_g[new_parent[i]].push_back(i);
        }
        dfs2(0);
        return res;
    }
};",1434306410
Rishabh Jain,rishcusion131072,546,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int>(k + 1, 0));
        for (int d = k - 1; d >= 0; d--) {
            for (int u = 0; u < n; u++) {
                int stay=stayScore[d][u]+dp[u][d + 1];
                int travel=0;
                for (int v = 0; v < n; v++) {
                    if (v != u) {
                        travel = max(travel,travelScore[u][v]+dp[v][d + 1]);
                    }
                }
                dp[u][d]=max(stay, travel);
            }
        }
        int res = 0;
        for (int u=0; u<n;u++) {
            res = max(res,dp[u][0]);
        }
        return res;
    }
};
",1434324643
Rishabh Jain,rishcusion131072,546,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        // vector <int> dp(word.size(),0);
        int res=0;
        for(int i=0;i<word.size();i++){
            int c=1;
            while(i+1<word.size() && word[i]==word[i+1]){
                i++;
                c++;
            }
            res+=(c-1);
        }
        return res+1;
    }
};

//aabbcc
//abbcc
//aabcc
//aabbc",1434274356
seryp,seryp,550,3576,cpp,"class Solution {
public:
    void dfs(int root, string &s,vector<vector<int>> &tree, vector<vector<int>> &q,vector<int> &ans ){
        for(int i = 0;i < tree[root].size();i++){
            int next = tree[root][i];
            if(q[s[next]].size() != 0){
                int f = q[s[next]].back();
                ans[next] = f;
            }
            q[s[next]].push_back(next);
            dfs(next,s,tree,q,ans);
            q[s[next]].pop_back();
        }
    }
    void dfs2(int root, vector<vector<int>> &tree,vector<int> &ans){
        ans[root] = 1;
        for(int i = 0;i < tree[root].size();i++){
            int next = tree[root][i];
            dfs2(next,tree,ans);
            ans[root] += ans[next];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n = p.size();
        vector<vector<int>> tree(n);
        vector<vector<int>> q(400);
        for(int i = 0;i < n;i++){
            if(p[i] != -1)
                tree[p[i]].push_back(i);
        }
        vector<int> ans = p;
                    q[s[0]].push_back(0);
        dfs(0,s,tree,q,ans);
        p = ans;
        // for(int i = 0;i < n;i++){
        //     printf(""%d ans %d\n"",i,ans[i]);
        // }
        tree = vector<vector<int>>(n);
        for(int i = 0;i < n;i++){
            if(p[i] != -1)
                tree[p[i]].push_back(i);
        }
        vector<int> key(n,0);
        dfs2(0,tree,key);
        return key;
        
    }
};",1434320101
seryp,seryp,550,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& tt) {
        vector<vector<int>> dp(k + 1, vector<int>(n,0));
        for(int i = 0;i<k;i++){
            for(int j = 0;j < n;j++){
                for(int m = 0;m < n;m++){
                    dp[i+1][m] =max(dp[i+1][m],dp[i][j] + tt[j][m]);
                }
                dp[i+1][j] = max(dp[i+1][j], dp[i][j] + stay[i][j]);
            }
        }
        return *max_element(dp[k].begin(),dp[k].end());
    }
};",1434331572
seryp,seryp,550,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        char last = '0';
        int i = 0;
        int ans =1;
        while(i < word.size()){
            int j = i;
            while(j < word.size() && word[j] == word[i]){
                j++;
            }
            if(j - i > 1){
                ans += (j - i - 1);
            }
            i = j;
        }
        return ans;
    }
};",1434270815
Anmol,user2824D,552,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> subtreeSize(n, 1);
        vector<unordered_set<int> > children(n, unordered_set<int>());
        for (int i = 1; i < n; i++) {
            children[parent[i]].insert(i);
        }
        
        vector<int> closestAncestor(26, -1);
        dfs(0, parent, subtreeSize, children, closestAncestor, n, s);
        return subtreeSize;
    }
    
    void dfs(int node, vector<int>& parent, vector<int>& subtreeSize, vector<unordered_set<int> >& children, vector<int>& closestAncestor, int n, string& s) {
        if (node > n - 1) {
            return;
        }
        
        int currChar = s[node] - 'a';
        int prevClosestAncestor = closestAncestor[currChar];
        // cout << ""closest ancestor "" << node << "" "" << prevClosestAncestor << ""\n"";
        if (prevClosestAncestor != -1) {
            children[parent[node]].erase(node);
            parent[node] = prevClosestAncestor;
            children[prevClosestAncestor].insert(node);
        }
        
        closestAncestor[currChar] = node;
        unordered_set<int> childrenOfNode(children[node]);
        
        // cout << ""dfs for node "" << node << ""\n"";
        for (int child : childrenOfNode) {
            // cout << "" dfs into "" << child << ""\n"";
            dfs(child, parent, subtreeSize, children, closestAncestor, n, s);
        }

        // cout << ""for node "" << node << ""\n"";
        for (int child : children[node]) {
            // cout << ""subtreeSize["" << child << ""] = "" << subtreeSize[child] << ""\n"";
            subtreeSize[node] += subtreeSize[child];
        }
        // cout << ""\n"";
        
        closestAncestor[currChar] = prevClosestAncestor;
    }
};",1434303635
Anmol,user2824D,552,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int> > score(k, vector<int>(n + 1));
        // cout << ""\n\n"";
        
        for (int i = 0; i < n; i++) {
            score[k - 1][i] = stayScore[k - 1][i]; 
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    continue;
                }
                score[k - 1][i] = max(score[k - 1][i], travelScore[i][j]);
            }
            // cout << score[k - 1][i] << "" "";
        }
        
        
        for (int i = k - 2; i >= 0; i--) {
            for (int j = 0; j < n; j++) {
                score[i][j] = stayScore[i][j] + score[i + 1][j]; 
                for (int dest = 0; dest < n; dest++) {
                    if (j == dest) {
                        continue;
                    }
                    score[i][j] = max(score[i][j], travelScore[j][dest] + score[i + 1][dest]);
                }
                // cout << score[i][j] << "" "";
            }
            // cout << ""\n"";
        }
        
        int ans = 0;
        for (int j = 0; j < n; j++) {
            ans = max(ans, score[0][j]);
        }
        return ans;
    }
};",1434331621
Anmol,user2824D,552,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int count = 1;
        for (int i = 1; i < n; i++) {
            if (word[i] == word[i - 1]) {
                count++;
            }
        }
        return count;
    }
};",1434262468
Chetna Ghengare,Chetna_07,554,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); 
        vector<int> answer(n, 1);   
        for (int i = 1; i < n; ++i) adj[parent[i]].push_back(i);
        vector<int> newParent = parent; 
        unordered_map<char, vector<int>> lastSeen; 
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : adj[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0); 
        vector<vector<int>> newAdj(n); 
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1; 
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0); 
        return answer;
    }
};",1434319423
Chetna Ghengare,Chetna_07,554,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
          vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }

        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        
        return maxPoints;
    }
};",1434324984
Chetna Ghengare,Chetna_07,554,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        
        int n = word.size() , ans =0;

        for(int i=0;i<word.size();i++)
        {
            char ch = word[i];
            int cnt =1;
            while(word[i+1]==ch)
            {
                  cnt ++;
                i++;
            }
            ans +=cnt-1;
        }
        

        return  ans+1;
    }
};",1434311295
hsdsh,hsdsh,555,3576,swift,"class Solution {
    func search(_ c: Int, _ m: [Int:[Int]], _ p: [Character:Int], _ np: inout [Int], _ sa: [Character]) {
        //print(c, p, sa[c])
        if let n = p[sa[c]] {
            np[c] = n
        }
        var p = p
        p[sa[c]] = c
        if let na = m[c] {
            for nc in na {
                search(nc, m, p, &np, sa)
            }
        }
    }
    func count(_ c: Int,  _ ret: inout [Int], _ m: [Int:[Int]]) -> Int {
        ret[c] = 1
        if let mm = m[c] {
            for nc in mm {
                ret[c] += count(nc, &ret, m)
            }
        }
        return ret[c]
    }
    func findSubtreeSizes(_ parent: [Int], _ s: String) -> [Int] {
        var m : [Int:[Int]] = [:]
        var p = parent
        for i in 0..<parent.count {
            if m[parent[i]] == nil {
                m[parent[i]] = []
            }
            m[parent[i]]!.append(i)
        }
        let sa = Array(s)
        var np = [Int](repeating:-1, count: parent.count)
        search(0,m, [:], &np, sa)
        for i in 0..<np.count {
            if np[i] > -1 {
                p[i] = np[i]
            }
        }
        //print(p)

        var ret = [Int](repeating:0, count: parent.count)
        m = [:]
        for i in 0..<p.count {
            if m[p[i]] == nil {
                m[p[i]] = []
            }
            m[p[i]]!.append(i)
        }
        count(0, &ret, m)
        return ret
        
    }
}",1434317602
hsdsh,hsdsh,555,3587,swift,"class Solution {
    func maxScore(_ n: Int, _ k: Int, _ stayScore: [[Int]], _ travelScore: [[Int]]) -> Int {
        var dp = [Int](repeating:0, count: n)
        for i in 0..<k {
            var ndp = [Int](repeating:0, count: n)
            for j in 0..<ndp.count {
                ndp[j] = dp[j]+stayScore[i][j]
                for k in 0..<ndp.count {
                    if j != k {
                        ndp[j] = max(ndp[j], dp[k]+travelScore[k][j])
                    }
                }
            }
            dp = ndp
        }
        return dp.max()!
    }
}",1434331930
hsdsh,hsdsh,555,3617,swift,"class Solution {
    func possibleStringCount(_ word: String) -> Int {
        let a = Array(word)
        var ret = 1
        var o: Character = "".""
        var oc = 0
        for i in 0..<a.count {
            if a[i] == o {
                oc += 1
            } else {
                ret += oc
                o = a[i]
                oc = 0 
            }
        }
        return ret+oc
    }
}",1434268414
Ayush Saluja,ayuchitsaluja8,556,3576,cpp,"class Solution {
public:
    void dfs0(int u,int p,vector<vector<int>>&tree,string &s,vector<vector<int>>&all,vector<int>&pa){
        int d = s[u]-'a';
        
        if(all[d].empty())pa[u] = p;
        else pa[u] = all[d].back();
    
        all[d].push_back(u);
        for(int v: tree[u])dfs0(v,u,tree,s,all,pa);
        all[d].pop_back();
    }
    void dfs1(int u,vector<vector<int>>&tree,vector<int>&sz){
        for(int v: tree[u]){
            dfs1(v,tree,sz);
            sz[u] += sz[v];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        vector<vector<int>> all(26,vector<int>());
        vector<vector<int>> tree(n,vector<int>());
        vector<int> pa(n,-1);
        for(int i=0;i<n;++i)if(parent[i]!=-1)tree[parent[i]].push_back(i);
        dfs0(0,-1,tree,s,all,pa);

        for(int i=0;i<n;++i)tree[i].clear();
        for(int i=0;i<n;++i)if(pa[i]!=-1)tree[pa[i]].push_back(i);

        vector<int> sz(n,1);
        dfs1(0,tree,sz);
        return sz;
    }
};",1434306875
Ayush Saluja,ayuchitsaluja8,556,3587,cpp,"class Solution {
public:
    int dfs(int s,int d,int k,vector<vector<int>>&a,vector<vector<int>>&b,vector<vector<int>>&dp){
        if(d==k)return 0;
        if(dp[s][d]!=-1)return dp[s][d];
        int now = dfs(s,d+1,k,a,b,dp) + a[d][s];
        for(int i=0;i<b.size();++i)if(i!=s){
            now = max(now, b[s][i] + dfs(i,d+1,k,a,b,dp));
        }
        return dp[s][d] = now;
    }
    int maxScore(int n, int k, vector<vector<int>>& a, vector<vector<int>>& b) {
        vector<vector<int>> dp(n+1,vector<int>(k+1,-1));
        int ret=0;
        for(int i=0;i<n;++i){
            ret = max(ret, dfs(i,0,k,a,b,dp));
        }
        return ret;
    }
};",1434332019
Ayush Saluja,ayuchitsaluja8,556,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1,n=word.size();
        for(int i=0,j=0;j<n;){
            for(i=j;j<n && word[i]==word[j];++j);
            ans += j-i-1;
        }
        return ans;
    }
};",1434263399
Ritesh_K_G,Ritesh_K_G,557,3576,cpp,"class Solution {
public:
    void dfs(vector<set<int>>& tree, int node, vector<int>& val, string &s, vector<int>& newParent) {
        int prev = val[s[node] - 'a'];
        if (val[s[node] - 'a'] != -1) {
            newParent[node] = val[s[node] - 'a'];
        }
        val[s[node] - 'a'] = node;
        for (auto child : tree[node]) {
            dfs(tree, child, val, s, newParent);
        }
        val[s[node] - 'a'] = prev;
    }
    int dfs1(vector<set<int>>& tree, int node, vector<int>& ans) {
        int ans1 = 1;
        for (auto child : tree[node]) {
            ans1 += dfs1(tree, child, ans);
        }
        return ans[node] = ans1;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<set<int>> tree(s.size()), newTree(s.size());
        for (int i = 1; i < s.size(); i++) {
            tree[parent[i]].insert(i);
        }
        int n = s.size();
        vector<int> val(26, -1), ans(n, 0);
        dfs(tree, 0, val, s, parent);
        for (int i = 1; i < s.size(); i++) {
            newTree[parent[i]].insert(i);
        }
        dfs1(newTree, 0, ans);
        return ans;
    }
};",1434302719
Ritesh_K_G,Ritesh_K_G,557,3587,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int dfs(vector<vector<int>>& stay, vector<vector<int>>& travel, int curr, int i) {
        if (i == stay.size()) {
            return 0;
        }
        if (dp[curr][i] != -1)
            return dp[curr][i];
        int ans = dfs(stay, travel, curr, i + 1) + stay[i][curr];
        for (int dest = 0; dest < travel[curr].size(); dest++) {
            if (dest != curr) {
                ans = max(ans, dfs(stay, travel, dest, i + 1) + travel[curr][dest]);
            }
        }
        return dp[curr][i] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        int ans = 0;
        dp.clear();
        dp.resize(n, vector<int>(k, -1));
        for (int i = 0; i < n; i++) {
            ans = max(ans, dfs(stay, travel, i, 0));
        }
        return ans;
    }
};",1434325314
Ritesh_K_G,Ritesh_K_G,557,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int n = word.size();
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && word[j] == word[i]) {
                j++;
            }
            int cnt = j - i;
            ans += (cnt - 1);
            i = j;
        }
        return ans;
    }
};",1434263306
lmhhhml2,lmhhhml2,559,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def get_children(parent):
            children = collections.defaultdict(list)
            for node in range(1, len(parent)):
                children[parent[node]].append(node)
            return children
        orig_children = get_children(parent)
        ch2node = {}
        def update_parent(node):
            nonlocal ch2node, parent, orig_children
            orig_parent = ch2node.get(s[node], -1)
            if orig_parent != -1:
                parent[node] = orig_parent
            ch2node[s[node]] = node
            for child in orig_children[node]:
                update_parent(child)
            ch2node[s[node]] = orig_parent
        update_parent(0)
        children = get_children(parent)
        ret = [0] * len(parent)
        def dfs_cnt_subtree(node):
            nonlocal ret
            ret[node] = 1
            for child in children[node]:
                dfs_cnt_subtree(child)
                ret[node] += ret[child]
        dfs_cnt_subtree(0)
        return ret",1434321752
lmhhhml2,lmhhhml2,559,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        for day in range(k):
            tmp = dp[:]
            for city in range(n):
                tmp[city] += stayScore[day][city]
                for travel_from in range(n):
                    tmp[city] = max(tmp[city], dp[travel_from] + travelScore[travel_from][city])
            dp = tmp[:]
        return max(dp)",1434332396
lmhhhml2,lmhhhml2,559,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ret = 1
        prev_ch = ''
        cur_cnt = 1
        word += 'A'
        for ch in word:
            if ch != prev_ch:
                ret += (cur_cnt - 1)
                cur_cnt = 0
            cur_cnt += 1
            prev_ch = ch
        return ret",1434267211
Le Quyet,lequyet,560,3576,python3,"from typing import List

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        for i in range(1, n):
            adj[parent[i]].append(i)
        
        par = parent.copy()
        last = {}
        
        def dfs(u):
            if s[u] in last:
                y = last[s[u]]
                if y != par[u]:
                    par[u] = y
            prev = last.get(s[u], -1)
            last[s[u]] = u
            for v in adj[u]:
                dfs(v)
            if prev == -1:
                del last[s[u]]
            else:
                last[s[u]] = prev
        
        dfs(0)
        
        new_adj = [[] for _ in range(n)]
        for i in range(n):
            if par[i] != -1:
                new_adj[par[i]].append(i)
        
        res = [0] * n
        stack = [(0, False)]
        while stack:
            u, visited = stack.pop()
            if visited:
                cnt = 1
                for v in new_adj[u]:
                    cnt += res[v]
                res[u] = cnt
            else:
                stack.append((u, True))
                for v in new_adj[u]:
                    stack.append((v, False))
        
        return res



# print(Solution().findSubtreeSizes([-1,0,0,1,1,1], ""abaabc""))",1434299122
Le Quyet,lequyet,560,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0]*n for _ in range(k+1)] 
        
        for i in range(k-1, -1, -1):
            for curr in range(n):
                option1 = stayScore[i][curr] + dp[i+1][curr]
                
                option2 = float('-inf')
                for dest in range(n):
                    if dest != curr:
                        temp = travelScore[curr][dest] + dp[i+1][dest]
                        option2 = max(option2, temp)
                
                dp[i][curr] = max(option1, option2)
        
        return max(dp[0])

# print(Solution().maxScore(2, 1, [[2,3]], [[0,2],[1,0]]))",1434332410
Le Quyet,lequyet,560,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 1
        n = len(word)

        for i in range(1, n):
            if word[i] == word[i-1]:
                count += 1

        return count",1434261115
techie_aamir_07,techie_aamir_07,561,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        vector<int> answer(n, 1);
        for (int i = 1; i < n; ++i) adj[parent[i]].push_back(i);
        vector<int> newParent = parent;
        unordered_map<char, vector<int>> lastSeen;
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node]= lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : adj[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0);
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1;
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0);
        return answer;
    }
};",1434325499
techie_aamir_07,techie_aamir_07,561,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day +1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int mps = 0;
        for (int city = 0; city < n; city++) {
            mps = max(mps, dp[k][city]);
        }
        
        return mps;
    }
};",1434332472
techie_aamir_07,techie_aamir_07,561,3617,cpp,"class Solution {
public:
    int possibleStringCount(string wd) {
        int tc = 1;
        int m = wd.length();
        for (int i = 0; i < m; ++i) {
            int count = 1;
            while (i + 1 < m && wd[i] == wd[i + 1]) {
                ++count;
                ++i;
            }
            tc += count - 1;
        }
        return tc;
    }
};",1434297630
likith gullapudi,gullapudi-likith,562,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n=len(parent)
        d={}
        newpar={}
        graph=[[] for i in range(n)]
        for child,par in enumerate(parent):
            if par==-1:
                continue
            graph[par].append(child)
        #print(graph)  
        def fun(root,par):
            temp=d.get(s[root],-1)
            #print(root,s[root],temp)
            if temp!=-1:
                parent[root]=temp
                print(root,temp)
                #newpar[root]=temp
                
                
                
            d[s[root]]=root 
            for nei in graph[root]:
                if nei==par:
                    continue 
                fun(nei,root)
            d[s[root]]=temp 
        fun(0,-1)
        #print(parent)
        graph=[[] for i in range(n)]
        for child,par in enumerate(parent):
            if par==-1:
                continue
            graph[par].append(child)
        #print(graph)
        #find subtree sizes
        size=[0 for i in range(n)]
        def fun2(root):
            size[root]=1 
            for nei in graph[root]:
                fun2(nei)
                size[root]+=size[nei]
        fun2(0)
        return size
        
        
        ",1434311832
likith gullapudi,gullapudi-likith,562,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp=[[-1 for i in range(n)] for j in range(k)]
        
        def fun(i,node):
            if i==k:
                return 0
            if dp[i][node]!=-1:
                return dp[i][node]
            dp[i][node]=fun(i+1,node)+stayScore[i][node]
            for nei in range(n):
                if nei==node:
                    continue 
                dp[i][node]= max( dp[i][node],fun(i+1,nei)+travelScore[node][nei])
            return dp[i][node] 
        ans=-float('inf')
        for st in range(n):
            ans=max(ans,fun(0,st))
        #print(dp)
        return ans
        
                ",1434325958
likith gullapudi,gullapudi-likith,562,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        i=0 
        ans=1
        while i<len(word):
            #find same letters how many times repeated
            temp=1 
            i+=1
            while i<len(word) and word[i]==word[i-1]:
                temp+=1 
                i+=1
            ans+=temp-1 
        return ans
                ",1434276744
alco_rythm,alco_rythm,563,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def f(cur):
            prev = parent[cur]
            t = d[prev].copy()
            
            t[s[cur]] = cur
            d[cur] = t

            for nxt in g[cur].copy():
                f(nxt)

        def f2(cur):
            prev = parent[cur]
            t = d[prev].copy()
            
            if s[cur] in t:
                ind = t[s[cur]]
                t = d[ind].copy()

                g[prev].remove(cur)
                g[ind].add(cur)
                parent[cur] = ind
        @cache
        def res(cur):
            if len(g[cur]) == 0:
                return 1

            p = 1

            for i in g[cur]:
                p += res(i)

            return p
                
        n = len(parent)

        g = [set() for i in range(n)]

        d = [{} for _ in range(n)]
        parent[0] = 0
        for i in range(1, n):
            g[parent[i]].add(i)

        f(0)

        for i in range(1, n):
            f2(i)

        res(0)

        # for i in range(n):
        #     print(i, list(g[i]))

        return [res(i) for i in range(n)]",1434332742
alco_rythm,alco_rythm,563,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def f(city, day):
            if day == k:
                return 0

            p = -float('inf')

            for i in range(n):
                if i == city:
                    p = max(p, f(city, day + 1) + stayScore[day][city])
                else:
                    p = max(p, f(i, day + 1) + travelScore[city][i])

            return p

        res = -float('inf')

        for i in range(n):
            res = max(res, f(i, 0))

        return res",1434291565
alco_rythm,alco_rythm,563,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        cnt = 1

        arr = []

        last = None
        a = 1

        for i in word:
            if i == last:
                a += 1
            else:
                arr.append(a)
                last = i
                a = 1

        arr.append(a)

        cnt = 1

        for i in arr:
            cnt += i - 1

        return cnt",1434268891
Joji,JojiJoseph,564,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        ans = [0] * len(parent)
        children = defaultdict(list)
        for i, p in enumerate(parent):
            if i != 0:
                children[p].append(i)

        ancestors = defaultdict(deque)
        def dfs1(node):
            nonlocal ancestors
            if len(ancestors[s[node]]):
                parent[node] = ancestors[s[node]][-1]
            ancestors[s[node]].append(node)
            # print(ancestors)
            for child in children[node]:
                # print(child)
                dfs1(child)
            ancestors[s[node]].pop()
            # print(node, ancestors)

        dfs1(0)

        # print(parent)

        children = defaultdict(list)
        for i, p in enumerate(parent):
            if i != 0:
                children[p].append(i)

        # print(children)
        
        def dfs2(node):
            res = 1
            for child in children[node]:
                res += dfs2(child)
            ans[node] = res
            # print(node, res)
            return res

        dfs2(0)

        return ans
            
        
        ",1434318318
Joji,JojiJoseph,564,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(i, curr):
            if i >= k:
                return 0
            if curr >= n:
                return 0
            res = stayScore[i][curr] + dp(i+1, curr)
            for next in range(n):
                if next != curr:
                    res = max(res, travelScore[curr][next] + dp(i+1, next))
            return res
        return max(dp(0,j) for j in range(n))
        ",1434332777
Joji,JojiJoseph,564,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        pre = None
        cnt = 1
        for ch in word:
            if ch == pre:
                cnt += 1
            else:
                ans += cnt - 1
                cnt = 1
            pre = ch
        ans += cnt - 1
        return ans
        ",1434265743
MakarenkoStepan,MakarenkoStepan,565,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        closest_node = dict()

        original_tree = defaultdict(list)
        for i, p in enumerate(parent):
            original_tree[p].append(i)
        
        def dfs(node, closest_node):
            nonlocal parent
            prev_closest = closest_node.get(s[node], -1)
            if prev_closest != -1:
                parent[node] = closest_node[s[node]]
            closest_node[s[node]] = node
            
            for child in original_tree[node]:
                dfs(child, closest_node)

            closest_node[s[node]] = prev_closest

        dfs(-1, closest_node)

        changed_tree = defaultdict(list)
        for i, p in enumerate(parent):
            changed_tree[p].append(i)

        ans = [1] * len(s)
        # print(changed_tree)

        def get_subtree_size(node):
            for child in changed_tree[node]:
                ans[node] += get_subtree_size(child)
            return ans[node]
            
        # print(parent)
        get_subtree_size(0)
        
        return ans
                

            
        ",1434312982
MakarenkoStepan,MakarenkoStepan,565,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        score = [0] * n

        for i in range(k):
            new_score = [0] * n
            for curr in range(n):
                #stay
                new_score[curr] = max(new_score[curr], 
                                      score[curr] + stayScore[i][curr])
                #travel
                for dest in range(n):
                    new_score[dest] = max(new_score[dest], 
                                          score[curr] + travelScore[curr][dest])
            score = new_score

        return max(score)",1434332795
MakarenkoStepan,MakarenkoStepan,565,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        
        in_a_row = 1
        for i in range(1, len(word)):
            if word[i] == word[i - 1]:
                in_a_row += 1
            else:
                ans += in_a_row - 1
                in_a_row = 1

        ans += in_a_row - 1
        return ans
                
            
        ",1434268844
GOKULNANDAN,RbcxrYvxnP,566,3576,python3,"from typing import List, Dict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = [[] for _ in range(n)]
        for child in range(1, n):
            tree[parent[child]].append(child)
        
        closest_ancestor = {}

        def dfs(node: int, ancestor_map: Dict[str, int]):
            if s[node] in ancestor_map:
                closest_ancestor[node] = ancestor_map[s[node]]
            else:
                closest_ancestor[node] = -1
            
            previous = ancestor_map.get(s[node])
            ancestor_map[s[node]] = node
            
            for child in tree[node]:
                dfs(child, ancestor_map)
            
            if previous is None:
                del ancestor_map[s[node]]
            else:
                ancestor_map[s[node]] = previous

        dfs(0, {})

        new_tree = [[] for _ in range(n)]
        for node in range(1, n):
            new_parent = closest_ancestor[node] if closest_ancestor[node] != -1 else parent[node]
            new_tree[new_parent].append(node)

        subtree_sizes = [0] * n

        def calculate_subtree_size(node: int) -> int:
            size = 1
            for child in new_tree[node]:
                size += calculate_subtree_size(child)
            subtree_sizes[node] = size
            return size

        calculate_subtree_size(0)

        return subtree_sizes

# Example usage
solution = Solution()
print(solution.findSubtreeSizes([-1, 0, 0, 1, 1, 1], ""abaabc""))
print(solution.findSubtreeSizes([-1, 0, 4, 0, 1], ""abbba""))",1434330241
GOKULNANDAN,RbcxrYvxnP,566,3587,python3,"from typing import List

class Solution:
    def maxScore(self, numCities: int, numDays: int, stayPoints: List[List[int]], travelPoints: List[List[int]]) -> int:
        dp = [[0] * numCities for _ in range(numDays + 1)]
        
        for day in range(1, numDays + 1):
            for currentCity in range(numCities):
                maxPoints = 0
                for previousCity in range(numCities):
                    points = dp[day - 1][previousCity] + (stayPoints[day - 1][currentCity] if currentCity == previousCity else travelPoints[previousCity][currentCity])
                    maxPoints = max(maxPoints, points)
                dp[day][currentCity] = maxPoints
        
        return max(dp[numDays])

# Example usage
solution = Solution()
print(solution.maxScore(3, 2, [[1, 2, 3], [3, 2, 1]], [[1, 1, 1], [1, 1, 1], [1, 1, 1]]))  # Adjust the input as needed",1434332799
GOKULNANDAN,RbcxrYvxnP,566,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        # Identify groups of consecutive characters
        groups = []
        i = 0
        while i < len(word):
            j = i
            while j < len(word) and word[j] == word[i]:
                j += 1
            groups.append(word[i:j])
            i = j

        # If no group has consecutive repeated characters, only one possibility exists
        if all(len(group) == 1 for group in groups):
            return 1

        # Calculate total number of possible original strings by considering one repeated group at a time
        possible_strings = 1  # Start with the original string as a valid option

        for group in groups:
            if len(group) > 1:
                possible_strings += len(group) - 1  # Each group can be shortened by removing repetitions down to one

        return possible_strings

# Example usage
solution = Solution()
print(solution.possibleStringCount(""abbcccc""))  # Output: 5
print(solution.possibleStringCount(""abcd""))     # Output: 1
print(solution.possibleStringCount(""aaaa""))     # Output: 4",1434276310
Joshnavi,joshnavi_8,567,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);

        // Build the adjacency list from the parent array
        for (int i = 1; i < n; i++) 
            adj[parent[i]].push_back(i);

        vector<int> newParent = parent;
        unordered_map<char, vector<int>> lastSeen;

        // Lambda function to reassign parents based on the string s
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) 
                newParent[node] = lastSeen[c].back();
            
            lastSeen[c].push_back(node);

            for (int child : adj[node]) 
                reassignParents(child);

            lastSeen[c].pop_back();
        };

        reassignParents(0);  // Start DFS from root node

        // Build new adjacency list from the reassigned parents
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; i++) 
            newAdj[newParent[i]].push_back(i);

        vector<int> answer(n);

        // Lambda function to compute subtree sizes
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1;
            for (int child : newAdj[node]) 
                size += computeSubtreeSizes(child);

            answer[node] = size;
            return size;
        };

        computeSubtreeSizes(0);  // Start DFS from root node

        return answer;
    }
};
",1434301614
Joshnavi,joshnavi_8,567,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));  // DP table initialized to 0
        
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {  // Corrected loop boundary for 'curr'
                // Stay at the current city
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                
                // Travel to another city
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {  // Only travel to a different city
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        
        // Find the maximum score on the last day across all cities
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        
        return maxPoints;
    }
};
",1434332862
Joshnavi,joshnavi_8,567,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int total=1;
        int n=word.length();
        for(int i=0;i<n;i++)
            {
                int count=1;
                while(i+1 < n && word[i]==word[i+1]){
                    ++count;
                    ++i;
                }
                total+=count-1;
            }
        return total;
    }
};",1434274208
Aditya Mishra,Adee_19,568,3576,python3,"from collections import defaultdict
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        
        # Step 1: Build the initial tree structure
        tree = defaultdict(list)
        for child in range(1, n):
            tree[parent[child]].append(child)
        
        # To track the last seen node with a specific character
        last_seen = {}
        
        # Step 2: DFS to transform the tree based on character ancestry
        def transform_dfs(node):
            char = s[node]
            if char in last_seen:
                # Update parent if there's a closer ancestor with the same character
                parent[node] = last_seen[char]
            # Temporarily update the last seen character for current DFS path
            prev_last_seen = last_seen.get(char, None)
            last_seen[char] = node
            
            # Transform children
            for child in tree[node]:
                transform_dfs(child)
            
            # Restore last seen state after returning from DFS for this node
            if prev_last_seen is None:
                del last_seen[char]
            else:
                last_seen[char] = prev_last_seen

        # Start transformation from the root node
        transform_dfs(0)
        
        # Step 3: Build new tree structure based on transformed parent array
        new_tree = defaultdict(list)
        for child in range(1, n):
            new_tree[parent[child]].append(child)
        
        # Step 4: Calculate subtree sizes in the modified tree
        subtree_size = [0] * n
        
        def size_dfs(node):
            size = 1  # Start with the node itself
            for child in new_tree[node]:
                size += size_dfs(child)
            subtree_size[node] = size
            return size

        # Calculate sizes starting from the root node
        size_dfs(0)
        
        return subtree_size",1434307700
Aditya Mishra,Adee_19,568,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[float('-inf')] * n for _ in range(k + 1)]
        
        for city in range(n):
            dp[0][city] = 0
        
        for day in range(1, k + 1):
            for curr in range(n):
                stay_points = dp[day - 1][curr] + stayScore[day - 1][curr]
                dp[day][curr] = max(dp[day][curr], stay_points)

            for curr in range(n):
                for prev in range(n):
                    if prev != curr:
                        travel_points = dp[day - 1][prev] + travelScore[prev][curr]
                        dp[day][curr] = max(dp[day][curr], travel_points)

        return max(dp[k])",1434311758
Aditya Mishra,Adee_19,568,3617,python3,"from collections import defaultdict
class Solution:
    def possibleStringCount(self, word: str) -> int:
        cnt = 1
        for i in range(len(word)-2, -1, -1):
            if word[i] == word[i+1]:
                cnt += 1
        return cnt",1434295906
Max Wood,knotri,569,3576,typescript,"function findSubtreeSizes(parent: number[], s: string): number[] {
    const childrens = parent.map((x) => new Set());

    for (let i = 1; i < parent.length; i++) {
        const el = parent[i];
        childrens[el].add(i);
    }

    // console.log(childrens);

    const ops = [];
    const R = (index, closest, parent) => {
        const el = s[index];
        if (closest[el] !== undefined) {
            if (parent !== closest[el]) {
                ops.push({ index, el, oldP: parent, newP: closest[el] });
            }
        }

        const prev = closest[el];
        closest[el] = index;
        childrens[index].forEach((child) => {
            R(child, closest, index);
        });
        closest[el] = prev;
    };
    R(0, {}, -1);

    for(let op of ops) {
        childrens[op.oldP].delete(op.index)
        childrens[op.newP].add(op.index)
    }

    // console.log(ops);
    // console.log(childrens);

    const results = parent.map(x => 0)
    const R2 = (index) => {
        let result = 1;
        childrens[index].forEach((child) => {
            result += R2(child);
        });

        results[index] = result
        return result
    }

    R2(0)

    return results;
}
",1434316570
Max Wood,knotri,569,3587,typescript,"function maxScore(n: number, k: number, stayScore: number[][], travelScore: number[][]): number {
    const dp = [Array.from({length: n}, () => 0)]

    for(let i = 0; i < k; i++) {
        dp.push(Array.from({length: n}, () => 0))

        for(let city = 0; city < n; city++) {
            let max = dp[i][city] + stayScore[i][city];
            for(let cityFrom = 0; cityFrom < n; cityFrom++) {
                max = Math.max(max, dp[i][cityFrom] + travelScore[cityFrom][city])
            }

            dp[i + 1][city] = max
        }
    }
    // console.log(dp)
    return Math.max(...dp.at(-1))
};",1434332959
Max Wood,knotri,569,3617,typescript,"function possibleStringCount(word: string): number {
    let result = 1
    for(let i = 1; i < word.length; i++) {
        if (word[i] === word[i - 1]) {
            result++;
        }
    }

    return result
};",1434265024
SK SP,Fibonacci_lc,570,3576,cpp,"class Frame {
public:
    int node;
    int state;
    int prv;
};

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        int n = par.size();
        vector<int> tree[n];
        for(int i = 1; i < n; ++i){
            tree[par[i]].push_back(i);
        }
        
        vector<int> parN(n, -1);
        int vecL[26];
        parN[0] = -1;
        for(int i = 0; i < 26; ++i) vecL[i] = -1;
        
        stack<Frame> st;
        st.push(Frame{0, 0, -1});
        
        while(st.size()){
            Frame curr = st.top();
            st.pop();
            int node = curr.node;
            if(curr.state == 0){
                char c = s[node];
                int c_idx = c - 'a';
                int prev = vecL[c_idx];
                if(node != 0){
                    if(prev != -1){
                        parN[node] = prev;
                    }
                    else{
                        parN[node] = par[node];
                    }
                }

                vecL[c_idx] = node;
                
                st.push(Frame{node, 1, prev});
                
                for(auto it = tree[node].rbegin(); it != tree[node].rend(); ++it){
                    st.push(Frame{*it, 0, -1});
                }
            }
            else{
                char c = s[node];
                int c_idx = c - 'a';
                vecL[c_idx] = curr.prv;
            }
        }
        

        vector<int> treeN[n];
        for(int i = 0; i < n; ++i){
            if(parN[i] != -1){
                treeN[parN[i]].push_back(i);
            }
        }
        
        vector<int> treeSz(n, 1); 
        stack<pair<int, bool>> st2; 
        st2.push({0,0}); 
        
        while(!st2.empty()){
            auto [node, p] = st2.top();
            st2.pop();
            if(p){
                for(auto adjNode : treeN[node]){
                    treeSz[node] += treeSz[adjNode];
                }
                continue;
            }
            st2.push({node, 1});
            for(auto it = treeN[node].rbegin(); it != treeN[node].rend(); ++it){
                st2.push({*it,0});
            }
        }
        
        return treeSz;
    }
};
",1434320333
SK SP,Fibonacci_lc,570,3587,cpp,"class Solution {
public:
    int memo(int day, int city, int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel,vector<vector<int>>& dp) {
        if (day == 0) {
            int mx = stay[0][city];
            for (int s = 0; s < n; ++s) {
                if (s != city) {
                    mx = max(mx, travel[s][city]);
                }
            }
            return mx;
        }

        if (dp[day][city] != -1) {
            return dp[day][city];
        }

        int stayS = memo(day - 1, city, n, k, stay, travel,dp) + stay[day][city];

        int move = 0;
        for (int s = 0; s < n; ++s) {
            if (s != city) {
                move = max(move, memo(day - 1, s, n, k, stay, travel,dp) + travel[s][city]);
            }
        }

        return dp[day][city] = max(stayS, move);
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1, vector<int>(n+1, -1));
        int res = 0;
        for (int c = 0; c < n; ++c) {
            res = max(res, memo(k - 1, c, n, k, stayScore, travelScore,dp));
        }

        return res;
    }
};
",1434332971
SK SP,Fibonacci_lc,570,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        if(word.size()==0) return 1;
        int ans = 1; 
        int n = word.length();
    
        for(int i=0;i<n;){
            char curr = word[i];
            int j = i + 1;
            int cnt = 1;
            while(j < n && word[j] == curr){
                cnt++;
                j++;
            }
            if(cnt > 1){
                ans += (cnt - 1);
            }
            i = j;
        }
        
        return ans;
    }
};",1434294719
Tathagata,VenomxSpiderman,572,3576,java,"class Solution {
 public static int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> adj = new ArrayList<>(n);
        int[] answer = new int[n];
        Arrays.fill(answer, 1);
        for (int i = 0; i < n; ++i) adj.add(new ArrayList<>());
        for (int i = 1; i < n; ++i) adj.get(parent[i]).add(i);
        int[] newParent = Arrays.copyOf(parent, n);
        Map<Character, List<Integer>> lastSeen = new HashMap<>();
        for (char c : s.toCharArray()) lastSeen.put(c, new ArrayList<>());
        
        Runnable reassignParents = new Runnable() {
            void reassign(int node) {
                char c = s.charAt(node);
                if (!lastSeen.get(c).isEmpty()) newParent[node] = lastSeen.get(c).get(lastSeen.get(c).size() - 1);
                lastSeen.get(c).add(node);
                for (int child : adj.get(node)) reassign(child);
                lastSeen.get(c).remove(lastSeen.get(c).size() - 1);
            }
            @Override
            public void run() {
                reassign(0);
            }
        };
        reassignParents.run();
        
        List<List<Integer>> newAdj = new ArrayList<>(n);
        for (int i = 0; i < n; ++i) newAdj.add(new ArrayList<>());
        for (int i = 1; i < n; ++i) newAdj.get(newParent[i]).add(i);
        
        Runnable computeSubtreeSizes = new Runnable() {
            int compute(int node) {
                int size = 1;
                for (int child : newAdj.get(node)) size += compute(child);
                answer[node] = size;
                return size;
            }
            public void run() {
                compute(0);
            }
        };
        computeSubtreeSizes.run();
        
        return answer;
    }
}",1434326395
Tathagata,VenomxSpiderman,572,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k + 1][n];
        for (int[] row : dp) 
        Arrays.fill(row, Integer.MIN_VALUE);
        for (int i = 0; i < n; i++) dp[0][i] = 0;
        for (int day = 1; day <= k; day++) {
            for (int curr = 0; curr < n; curr++) {
            for (int prev = 0; prev < n; prev++) {
                dp[day][curr] = Math.max(dp[day][curr], dp[day - 1][prev] + travelScore[prev][curr]);
            }
            dp[day][curr] = Math.max(dp[day][curr], dp[day - 1][curr] + stayScore[day - 1][curr]);
            }
        }
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++)
            res = Math.max(res, dp[k][i]);
        
        return res;
    }
}",1434308579
Tathagata,VenomxSpiderman,572,3617,java,"class Solution {
        public int possibleStringCount(String word) {
        int count = 1;
        for (int i = 0; i < word.length();) {
            char c = word.charAt(i);
            int j = i+1;
            while (j < word.length() && word.charAt(j) == c) {
                j++;
                count++;
            }
            i=j;
        }
        return count;
    }
}",1434290323
Practice_123_45_56,Practice_123_45_56,573,3576,cpp,"class Solution {
public:
    vector<int>new_parent;
    map<char,int>nodes;

    void dfs(int src,vector<int>adj[],int parent,string &s)
    {
         int prev_node = -1;
        
        if(nodes.count(s[src]))
        {
            prev_node = nodes[s[src]];
            new_parent[src] = prev_node;
        }

        nodes[s[src]] = src;
        
        for(auto adj_vertex:adj[src])
            {
                if(adj_vertex!=parent)
                {
                    dfs(adj_vertex,adj,src,s);
                }
            }

        
        if(prev_node==-1)
        {
            char key = s[src];
            auto it = nodes.find(key);
            if(it!=nodes.end())
                nodes.erase(it);
        }
        else
            nodes[s[src]] = prev_node;

    }

    void computeHeight(int src,vector<int>adj[],int parent,vector<int>&ans)
    {
         for(auto adj_vertex:adj[src])
             {
                 if(adj_vertex!=parent)
                 {
                     computeHeight(adj_vertex,adj,src,ans);
                     ans[src]+=ans[adj_vertex];
                 }
             }

        ans[src]++;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        new_parent.resize(n,-1);

        vector<int>adj[n];
        for(int i=0;i<n;i++)
            {
                if(parent[i]!=-1)
                    adj[parent[i]].push_back(i);
            }

        dfs(0,adj,-1,s);
        
        for(int i=1;i<n;i++)
            {
                if(new_parent[i]==-1)
                    new_parent[i]=parent[i];
            }

        for(int x:new_parent)
            cout<<x<<' ';
        
        vector<int>adj2[n];
        for(int i=0;i<n;i++)
            {
                if(new_parent[i]!=-1)
                    adj2[new_parent[i]].push_back(i);
            }
        
        vector<int>ans(n,0);
        computeHeight(0,adj2,-1,ans);

        return ans;
    }
};",1434307251
Practice_123_45_56,Practice_123_45_56,573,3587,cpp,"class Solution {
public:
    int dp[205][205];
    
    int getMaxPoints(int n,int k,int days,int curr,vector<vector<int>>& stayScore, vector<vector<int>>& travelScore)
    {
        if(days==k)
            return 0;

        if(dp[days][curr]!=-1)
            return dp[days][curr];
        
        // stay
        int ans = stayScore[days][curr]+getMaxPoints(n,k,days+1,curr,stayScore,travelScore);
    
        // travel

        for(int dest = 0; dest < n; dest++)
            {
                if(dest!=curr)
                {
                    int temp = travelScore[curr][dest]+getMaxPoints(n,k,days+1,dest,stayScore,travelScore);
                    ans=max(ans,temp);
                }
            }

        return dp[days][curr] = ans;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        memset(dp,-1,sizeof dp);
        for(int start = 0; start<n;start++)
            {
                int res = getMaxPoints(n,k,0,start,stayScore,travelScore);
                ans=max(ans,res);
            }

        return ans;
    }
};",1434326413
Practice_123_45_56,Practice_123_45_56,573,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int>repeat;
        int len = 1;
        for(int i=1;i<word.length();i++)
            {
                if(word[i]==word[i-1])
                    len++;
                else
                {
                    repeat.push_back(len);
                    len=1;
                }
            }

        if(len)
            repeat.push_back(len);

        int ans = 1;
        for(int x:repeat)
            {
                if(x>1)
                    ans+=x-1;
            }
        
        return ans;
    }
};",1434271145
Divyam Shah,divyamshah04,575,3576,cpp,"#include <bits/stdc++.h>
using namespace std;

#define vi vector<int>
#define ll long long
#define fl(i, n) for (int i = 0; i < n; ++i)
#define pb push_back

class Solution {
public:
    vi findSubtreeSizes(vi& p, string s) {
        int n = p.size();
        vector<vi> adj(n);
        vi ans(n, 0), np = p;

        fl(i, n) {
            if (i > 0) adj[p[i]].pb(i);
        }

        unordered_map<char, int> last;
        dfs(0, adj, np, s, last);

        vector<vi> updt(n);
        fl(i, n) {
            if (i > 0) updt[np[i]].pb(i);
        }

        calc(0, updt, ans);
        return ans;
    }

private:
    void dfs(int u, const vector<vi>& adj, vi& p, const string& s, unordered_map<char, int>& last) {
        int prev;
        if(last.count(s[u])){
            prev = last[s[u]];
        }
            
        else{
             prev = -1;
        }
           
        if (prev != -1)
            p[u] = prev;

        last[s[u]] = u;

        for (int v : adj[u])
            dfs(v, adj, p, s, last);

        last[s[u]] = prev;
    }

    int calc(int u, const vector<vi>& adj, vi& ans) {
        ans[u] = 1;
        for (int v : adj[u])
            ans[u] += calc(v, adj, ans);
        return ans[u];
    }
};
",1434291445
Divyam Shah,divyamshah04,575,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

#define vi vector<int>
#define ll long long
#define fl(i, n) for (int i = 0; i < n; ++i)
#define pb push_back

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<vi> dp(k, vi(n, 0));

        fl(j, n) {
            dp[0][j] = ss[0][j];
            fl(idx, n) {
                if (idx != j) {
                    dp[0][j] = max(dp[0][j], ts[idx][j]);
                }
            }
        }

        for (int i = 1; i < k; ++i) {
            fl(j, n) {
                dp[i][j] = dp[i - 1][j] + ss[i][j];
                fl(pc, n) {
                    if (pc != j) {
                        dp[i][j] = max(dp[i][j], dp[i - 1][pc] + ts[pc][j]);
                    }
                }
            }
        }

        int ans = 0;
        fl(j, n) {
            ans = max(ans, dp[k - 1][j]);
        }

        return ans;
    }
};
",1434326685
Divyam Shah,divyamshah04,575,3617,cpp,"#include <bits/stdc++.h>
using namespace std;

#define vi vector<int>
#define ll long long
#define fl(i, n) for (int i = 0; i < n; ++i)

class Solution {
public:
    int possibleStringCount(string w) {
        int n = w.size(), ans = 1;  
        fl(i, n) {
            int idx = i;
            while (idx < n && w[idx] == w[i]) ++idx;  
            int len = idx - i;
            if (len > 1) ans += len - 1;  
            i = idx - 1;
        }
        return ans;
    }
};
",1434265675
Reversal,ReversalGM,576,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def create_child_list(parent_list):
            children = collections.defaultdict(list)
            for cur_node, parent_node in enumerate(parent):
                if parent_node != -1:
                    children[parent_node].append(cur_node)
            return children
        children = create_child_list(parent)
        def dfs1(cur, closest_ancestor):
            if closest_ancestor[s[cur]] != -1:
                parent[cur] = closest_ancestor[s[cur]]
            prev_val = closest_ancestor[s[cur]]
            closest_ancestor[s[cur]] = cur
            for child in children[cur]:
                dfs1(child, closest_ancestor)
            closest_ancestor[s[cur]] = prev_val
        dfs1(0, collections.defaultdict(lambda :-1))
        
        children = create_child_list(parent)
        ans = [0] * len(parent)
        def dfs2(cur):
            cur_size = 1
            for child in children[cur]:
                cur_size += dfs2(child)
            ans[cur] = cur_size
            return cur_size
        dfs2(0)
        return ans
        
                
                
            
            ",1434307254
Reversal,ReversalGM,576,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        max_score = [0] * n
        for day in range(k):
            new_max_score = [max_score[city] + stayScore[day][city] for city in range(n)]
            for city in range(n):
                for prev_city in range(n):
                    if prev_city != city:
                        new_max_score[city] = max(new_max_score[city], travelScore[prev_city][city] + max_score[prev_city])
            max_score = new_max_score
        return max(max_score)
                ",1434333453
Reversal,ReversalGM,576,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for k, g in itertools.groupby(word):
            ans += len(list(g)) - 1
        return ans",1434273068
Vidit Jain,vidit987,577,3576,cpp,"class Solution {
public:
    void helper(string& s,vector<vector<int>>& v,int node,vector<int>& p2, vector<int>& cp) {
        int c = s[node]-'a';
        int pa = cp[c];
        if (pa != -1)p2[node] = pa;
        cp[c] = node;
        for (auto it : v[node]) helper(s, v,it, p2, cp);
        cp[c] = pa;
    }

    int solve(vector<vector<int>>& newV,int node, vector<int>& ans) {
        int total = 1;
        for (auto it : newV[node])total += solve(newV,it, ans);
        ans[node] = total;
        return total;
    }
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int i,n=p.size(),curr;
        vector<vector<int>> v(n),newV(n);
        vector<int> ans(n, 1),p2 = p,cp(26, -1);
        for (i = 1; i < n;i++)v[p[i]].push_back(i);
        helper(s, v,0,p2, cp);
        for (i =1;i<n;i++)newV[p2[i]].push_back(i);
        solve(newV,0, ans);
        return ans;
    }
};",1434309383
Vidit Jain,vidit987,577,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        int i,j,tt,mx,ans=0;
        vector<vector<int>> dp(k, vector<int>(n, 0));
        for(i=0;i< n;i++) {
            mx=0;
            for(j=0;j<n;j++) {
                if (i==j)continue;
                mx= max(mx,t[j][i]);
            }
            int kt=max(s[0][i],mx);
            dp[0][i]=kt;
        }
        for(i=1;i<k;i++) {
            vector<int>temp(n,0);
            for (j=0;j<n;j++) {
                temp[j]=dp[i-1][j] + s[i][j];
                for (tt=0;tt< n;tt++) {
                    if (tt==j)continue;
                    temp[j] = max(temp[j], dp[i - 1][tt] + t[tt][j]);
                }
            }
            dp[i] = temp;
        }
        for(i=0;i<n;i++)ans=max(dp[k-1][i],ans);
        return ans;
    }
};",1434326733
Vidit Jain,vidit987,577,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int i=0,n=s.length(),ans=1;
        while(i<n){
            char c=s[i];
            int cnt=0;
            while(i<n && s[i]==c){
                cnt++;
                i++;
            }
            if(cnt>1){
                ans+=(cnt-1);
            }
        }
        return ans;
    }
};",1434266172
aniket170195,aniket170195,578,3576,cpp,"class Solution {
public:
    void dfs(int node, int parent, vector <int> graph[], string &s, map <char,vector<int>> &mp,
    vector <int> &par){
        if(mp.find(s[node]) != mp.end()){
            par[node] = mp[s[node]].back();
        }
        else{
            par[node] = parent;
        }
        mp[s[node]].push_back(node);
        for(auto &x : graph[node]){
            dfs(x, node, graph, s, mp, par);
        }
        mp[s[node]].pop_back();
        if(mp[s[node]].size() == 0){
            mp.erase(s[node]);
        }
        // if(mp.find(s[node]) != mp.end()){
        //     mp.erase(s[node]);
        // }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector <int> graph[n];
        for(int i=0; i<parent.size(); i++){
            if(parent[i] >= 0){
                graph[parent[i]].push_back(i);
            }
        }
        map <char,vector<int>> mp; vector<int> par(n,-1), dp(n,1);
        dfs(0,-1,graph,s,mp,par);

        vector <int> new_graph[n];
        for(int i=0; i<par.size(); i++){
            if(par[i] >= 0){
                new_graph[par[i]].push_back(i);
            }
        }
        dfs(0, new_graph, dp);
        return dp;
    }

    int dfs(int node, vector <int> graph[], vector <int> &dp){
        int ans = 0;
        for(auto &x : graph[node]){
            ans += dfs(x, graph, dp);
        }
        return dp[node] = ans+1;
    }
};",1434319515
aniket170195,aniket170195,578,3587,cpp,"class Solution {
public:
    int solve(int k, int curr, vector <vector<int>> &stay, vector <vector<int>> &travel,
    vector <vector<int>> &dp){
        if(k<0) return 0;
        if(dp[k][curr] != -1) return dp[k][curr];
        int nottake = solve(k-1, curr, stay, travel, dp) + stay[k][curr];
        int take = 0;
        for(int i=0; i<travel.size(); i++){
            take = max(take, solve(k-1, i, stay, travel, dp) + travel[i][curr]);
        }
        return dp[k][curr] = max(take, nottake);
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        vector <vector<int>> dp(k+10, vector<int>(travelScore.size(),-1));
        for(int i=0; i<travelScore.size(); i++){
            ans = max(ans, solve(k-1, i, stayScore, travelScore, dp));
        }
        return ans;
    }
};",1434333514
aniket170195,aniket170195,578,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 0;
        for(int i=0; i<word.size();){
            char temp = word[i];
            int count = 0;
            while(i<word.size() && word[i] == temp){
                count++;
                i++;
            }
            ans += (count-1);
        }
        return ans + 1;
    }
};",1434264370
daisek,daisek,579,3576,kotlin,"class Solution {
    fun findSubtreeSizes(parent: IntArray, s: String): IntArray {
        val newPar = parent.copyOf()
        val adj = parent.withIndex()
            .groupBy ({ it.value }) { it.index }
        go(0, adj, mapOf(), s, newPar)
        val newAdj = newPar.withIndex()
            .groupBy ({ it.value }) { it.index }
        val res = IntArray(parent.size)
        go2(0, newAdj, res)
        return res
    }

    fun go (cur: Int, adj: Map<Int, List<Int>>, stack: Map<Char, Int>, s: String, res: IntArray)
    {
        val c = s[cur]
        stack[c]?.let { res[cur] = it }
        for (next in adj.getOrDefault(cur, listOf())) {
            go(next, adj, stack + (c to cur), s, res)
        }
    }

    fun go2(cur: Int, adj: Map<Int, List<Int>>, res: IntArray): Int {
        res[cur] = 1 + adj.getOrDefault(cur, listOf()).sumOf {go2(it, adj, res)}
        return res[cur]
    }
}",1434309017
daisek,daisek,579,3587,kotlin,"class Solution {
    fun maxScore(n: Int, k: Int, stayScore: Array<IntArray>, travelScore: Array<IntArray>): Int {
        return stayScore
            .fold(IntArray(n).toList()) { prev, stay ->
                (0 until n).map { curr ->
                    prev.withIndex()
                        .maxOf { 
                            if (it.index == curr) 
                                it.value + stay[curr] 
                            else 
                                it.value + travelScore[it.index][curr]
                        }
                }
            }
        .max()
    }
}",1434333664
daisek,daisek,579,3617,kotlin,"class Solution {
    fun possibleStringCount(word: String): Int {
        var res = 1
        var x = 1
        for (i in 1 until word.length) {
            if (word[i] == word[i-1]) {
                x++
            } else {
                res += (x-1)
                x = 1
            }
        }
        res += (x-1)
        return res
    }
}",1434272947
Nilanjan Das,forasssk,580,3576,cpp,"class Solution {
public:
    void dfs (int node, int par, vector <vector <int>> &g, vector <vector <int>> &closest, string &s) {
        if (par >= 0) {
            for (int i = 0; i < 26; i ++) {
                if (i == s[par] - 'a') {
                    closest[node][i] = par;
                }
                else {
                    closest[node][i] = closest[par][i];
                }
            }
        }
        for (int neigh: g[node]) {
            if (neigh != par) {
                dfs(neigh, node, g, closest, s);
            }
        }
    }
    void dfs_sz (int node, int par, vector <vector <int>> &g, vector <int> &ans) {
        ans[node] = 1;
        for (int neigh: g[node]) {
            if (neigh != par) {
                dfs_sz(neigh, node, g, ans);
                ans[node] += ans[neigh];
            }
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.length();
        vector <vector <int>> g(n);
        for (int node = 1; node < n; node ++) {
            g[node].push_back(parent[node]);
            g[parent[node]].push_back(node);
        }
        vector <vector <int>> closest(n, vector <int> (26, -1));
        dfs(0, -1, g, closest, s);
        for (int node = 1; node < n; node ++) {
            int new_par = closest[node][s[node] - 'a'];
            if (new_par >= 0) {
                parent[node] = new_par;
            }
        }
        g.clear();
        g.resize(n);
        for (int node = 1; node < n; node ++) {
            g[node].push_back(parent[node]);
            g[parent[node]].push_back(node);
        }
        vector <int> ans(n);
        dfs_sz(0, -1, g, ans);
        return ans;
    }
};",1434315449
Nilanjan Das,forasssk,580,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int score[k + 1][n];
        for (int curr = 0; curr < n; curr ++) {
            score[k][curr] = 0;
        }
        for (int day = k - 1; day >= 0; day --) {
            for (int curr = 0; curr < n; curr ++) {
                score[day][curr] = score[day + 1][curr] + stayScore[day][curr];
                for (int dest = 0; dest < n; dest ++) {
                    score[day][curr] = max(score[day][curr], score[day + 1][dest] + travelScore[curr][dest]);
                }
            }
        }
        int ans = score[0][0];
        for (int curr = 1; curr < n; curr ++) {
            ans = max(ans, score[0][curr]);
        }
        return ans;
    }
};",1434333746
Nilanjan Das,forasssk,580,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.length();
        char x = word[0];
        int cnt = 1, sum = 0;
        for (int i = 1; i < n; i ++) {
            if (word[i] == x) {
                cnt ++;
            }
            else {
                sum += cnt - 1;
                cnt = 1;
                x = word[i];
            }
        }
        sum += cnt - 1;
        sum ++;
        return sum;
    }
};",1434270904
txycodelc,txycodelc,581,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        adj = [[] for _ in range(n)]
        
        for i, p in enumerate(parent):
            if p != -1:
                adj[p].append(i)
        np = list(parent)
        def dfs(x, p, near):
            if p != -1 and s[p] != s[x] and near[s[x]] != -1:
                np[x] = near[s[x]]
            else:
                np[x] = parent[x]
            for y in adj[x]:
                if y != p:
                    z = near[s[x]]
                    near[s[x]] = x
                    dfs(y, x, near)
                    near[s[x]] = z
        
        dfs(0, -1, defaultdict(lambda : -1))
        
        ans = [1] * n
        
        adj = [[] for _ in range(n)]
        
        for i, p in enumerate(np):
            if p != -1:
                adj[p].append(i)
        
        def count(x, p):
            
            for y in adj[x]:
                if y != p:
                    ans[x] += count(y, x)
            return ans[x]
        
        count(0, -1)
        return ans
            
            
                    
                
            
        ",1434323339
txycodelc,txycodelc,581,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        @cache
        def dfs(i, c):
            if i == k:
                return 0
            ans = stayScore[i][c] + dfs(i + 1, c)
            for j in range(n):
                ans = max(dfs(i + 1, j) + travelScore[c][j], ans)
            
            return ans
        
        res = max(dfs(0, j) for j in range(n))
        
        dfs.cache_clear()
        return res
                ",1434333753
txycodelc,txycodelc,581,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        
        n = len(word)
        c = ''
        count = 1
        ans = 1
        for i in range(n):
            if c == word[i]:
                count += 1
            else:
                c = word[i]
                ans += count - 1
                count = 1
        ans += count - 1
        return ans
            ",1434268422
Prittam Ravi,lions3010,582,3576,python3,"from typing import List
from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        new_parent = parent.copy()

        tree_original = [[] for _ in range(n)]
        for i in range(n):
            if parent[i] != -1:
                tree_original[parent[i]].append(i)
        
        last_seen = {}
        
        def dfs_reparent(node):
            char = s[node]
            original_parent = new_parent[node]
            if char in last_seen:
                new_parent[node] = last_seen[char]

            previous = last_seen.get(char, -1)
            last_seen[char] = node

            for child in tree_original[node]:
                dfs_reparent(child)

            if previous != -1:
                last_seen[char] = previous
            else:
                del last_seen[char]
        
        dfs_reparent(0)
        
        tree_new = [[] for _ in range(n)]
        for i in range(n):
            if new_parent[i] != -1:
                tree_new[new_parent[i]].append(i)

        res = [1] * n  
        
        def dfs_subtree(node):
            for child in tree_new[node]:
                res[node] += dfs_subtree(child)
            return res[node]
        
        dfs_subtree(0)
        return res
",1434309855
Prittam Ravi,lions3010,582,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = {}
        def helper(city, day):
            if day >= k:
                return 0

            if (city,day) in dp:
                return dp[(city,day)]

            max_points = 0

            #choice to stay
            max_points = max(max_points, stayScore[day][city] + helper(city,day+1))

            for i in range(n):
                if i == city:
                    continue
                else:
                    max_points = max(max_points, travelScore[city][i] + helper(i,day+1))
            dp[(city,day)] = max_points
            return dp[(city,day)]
        res = 0
        for i in range(n):
            res = max(res, helper(i, 0))
        return res",1434327040
Prittam Ravi,lions3010,582,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 0
        prev_char = word[0]
        curr_count = 0
        for i in range(1,len(word)):
            print(prev_char, word[i])
            if word[i] == prev_char:
                curr_count += 1
            else:
                res += curr_count
                prev_char = word[i]
                curr_count = 0
        res += curr_count
        return res + 1
            
            ",1434278426
Shri_Tee,Shri_Tee,583,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        int n = p.size();
vector<vector<int>> adj(n);
vector<int> ans(n, 1);

for (int i = 1; i < n; ++i) adj[p[i]].push_back(i);

vector<int> np = p;
unordered_map<char, vector<int>> last;

function<void(int)> update = [&](int node) {
    char ch = s[node];
    if (!last[ch].empty()) 
        np[node] = last[ch].back();
    
    last[ch].push_back(node);

    for (int child : adj[node]) 
        update(child);

    last[ch].pop_back();
};

update(0);

vector<vector<int>> nadj(n);
for (int i = 1; i < n; ++i) nadj[np[i]].push_back(i);

function<int(int)> calc = [&](int node) {
    int sz = 1;
    for (int child : nadj[node]) 
        sz += calc(child);
    
    ans[node] = sz;
    return sz;
};

calc(0);

return ans;
    }
};",1434311103
Shri_Tee,Shri_Tee,583,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
       vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int d = 0; d < k; d++) {
            for (int curr = 0; curr < n; curr++) {
                dp[d + 1][curr] = max(dp[d + 1][curr], dp[d][curr] + stayScore[d][curr]);
                for (int des = 0; des < n; des++) {
                    if (curr != des) { 
                        dp[d + 1][des] = max(dp[d + 1][des], dp[d][curr] + travelScore[curr][des]);
                    }
                }
            }
        }
        int maxP = 0;
        for (int city = 0; city < n; city++) {
            maxP = max(maxP, dp[k][city]);
        }
        return maxP;
    }
};

",1434327125
Shri_Tee,Shri_Tee,583,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
         int count = 1;
    for (int i = 1; i < word.length(); ++i) {
        if (word[i] == word[i - 1]) {
            count++;
        }
    }
    return count;
    }
};",1434290704
bubbleblaster575,Bharti_8278,584,3576,cpp,"class Solution {
public:
vector<int> findSubtreeSizes(vector<int>& parent, string s) {
    int n = parent.size();
    vector<vector<int>> tree(n); // Adjacency list to store the tree structure
    vector<int> answer(n, 1); // Initialize answer with 1 since each node is a subtree of itself

    for(int i = 1; i < n; i++) tree[parent[i]].push_back(i);
    vector<int> newParent = parent;
    unordered_map<char, vector<int>> lastSeen; // Map to store the last seen node for each character

    function<void(int)> reassignParents = [&](int node){
        char c = s[node];
        if(!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
        lastSeen[c].push_back(node);
        for(int child : tree[node]) reassignParents(child);
        lastSeen[c].pop_back();
    };
    reassignParents(0);
    vector<vector<int>> newAdj(n);
    for(int i = 1; i < n; i++) newAdj[newParent[i]].push_back(i);
 
    function<int(int)> dfs = [&](int node) {
        int size = 1;
        for (int child : newAdj[node]) {
            size += dfs(child); // Accumulate subtree sizes
        }
        answer[node] = size;
        return size;
    };

    dfs(0); 

    return answer;
    }
};",1434314205
bubbleblaster575,Bharti_8278,584,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k +1, vector<int>(n, 0));
        for(int i = 0; i < k; i++){
            for(int j = 0; j < n; j++){
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]+ stayScore[i][j]);
                for(int k = 0; k <n; k++){
                    if(j != k){
                        dp[i+1][k] = max(dp[i+1][k], dp[i][j]+ travelScore[j][k]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for(int city = 0; city < n; city++){
            maxPoints = max(maxPoints, dp[k][city]);
        }
        return maxPoints;
    }
};",1434334171
bubbleblaster575,Bharti_8278,584,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count =0;
        stack<char> st;
        st.push(word[0]);
        for(int i = 1; i < word.size(); i++){
            if(!st.empty() && st.top() != word[i])
                st.push(word[i]);
            else if(!st.empty() && st.top()==word[i])
                count++;
        }
        return count + 1;
    }
};",1434276300
Rahul Rajput,16_rahul_1999,587,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int node_count = parent.size();
        vector<vector<int>> adjacency_list(node_count);
        vector<int> subtree_size(node_count, 1);
        for (int i = 1; i < node_count; ++i)
            adjacency_list[parent[i]].push_back(i);
        vector<int> reassigned_parent = parent;
        unordered_map<char, vector<int>> last_occurrence;
        function<void(int)> reassign_parents = [&](int node) {
            char current_char = s[node];
            if (!last_occurrence[current_char].empty())
                reassigned_parent[node] = last_occurrence[current_char].back();
            last_occurrence[current_char].push_back(node);
            for (int child : adjacency_list[node])
                reassign_parents(child);
            last_occurrence[current_char].pop_back();
        };
        reassign_parents(0);
        vector<vector<int>> new_adjacency_list(node_count);
        for (int i = 1; i < node_count; ++i)
            new_adjacency_list[reassigned_parent[i]].push_back(i);
        function<int(int)> calculate_subtree_size = [&](int node) {
            int size = 1;
            for (int child : new_adjacency_list[node])
                size += calculate_subtree_size(child);
            subtree_size[node] = size;
            return size;
        };
        calculate_subtree_size(0);
        return subtree_size;
    }
};",1434308295
Rahul Rajput,16_rahul_1999,587,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[day + 1][dest] =
                            max(dp[day + 1][dest],
                                dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        return maxPoints;
    }
};",1434334295
Rahul Rajput,16_rahul_1999,587,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        unordered_set< string > possible_string;

        possible_string.insert( word );

        int size = word.size();

        for( int i = 0; i < size;){
            char current_char = word[i];
            int consecutive = 0;

            int start = i;

            while( i < size && word[i] == current_char ){
                consecutive ++;
                i++;
            }

            for( int j = 1; j <= consecutive - 1; j++ ){
                string modified_word = word.substr( 0, start ) + word.substr( start, + j);
                possible_string.insert( modified_word );
            }
        }

        return possible_string.size();
    }
};",1434289147
LAKSHYA REDDY GOLI,22R11A0514,588,3576,java,"import java.util.*;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());
        for (int i = 1; i < n; i++) adj.get(parent[i]).add(i);

        Map<Character, Deque<Integer>> charStacks = new HashMap<>();
        int[] newParent = parent.clone();
        
        dfsReparent(0, adj, s, charStacks, newParent);
        
        List<List<Integer>> newAdj = new ArrayList<>();
        for (int i = 0; i < n; i++) newAdj.add(new ArrayList<>());
        for (int i = 1; i < n; i++) newAdj.get(newParent[i]).add(i);
        
        int[] answer = new int[n];
        dfsSubtreeSize(0, newAdj, answer);
        
        return answer;
    }

    private void dfsReparent(int node, List<List<Integer>> adj, String s, 
                             Map<Character, Deque<Integer>> charStacks, int[] newParent) {
        char c = s.charAt(node);
        if (!charStacks.containsKey(c)) charStacks.put(c, new ArrayDeque<>());
        
        if (!charStacks.get(c).isEmpty()) newParent[node] = charStacks.get(c).peek();
        
        charStacks.get(c).push(node);
        
        for (int child : adj.get(node)) dfsReparent(child, adj, s, charStacks, newParent);
        
        charStacks.get(c).pop();
    }

    private void dfsSubtreeSize(int node, List<List<Integer>> adj, int[] answer) {
        answer[node] = 1;
        for (int child : adj.get(node)) {
            dfsSubtreeSize(child, adj, answer);
            answer[node] += answer[child];
        }
    }
}
",1434305824
LAKSHYA REDDY GOLI,22R11A0514,588,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k + 1][n];
        for (int i = 0; i < n; i++) dp[0][i] = 0;

        for (int day = 0; day < k; day++) {
            int[] nextDay = new int[n];
            for (int curr = 0; curr < n; curr++) {
                int stayPoints = dp[day][curr] + stayScore[day][curr];
                nextDay[curr] = Math.max(nextDay[curr], stayPoints);

                for (int dest = 0; dest < n; dest++) {
                    if (dest != curr) {
                        int travelPoints = dp[day][curr] + travelScore[curr][dest];
                        nextDay[dest] = Math.max(nextDay[dest], travelPoints);
                    }
                }
            }
            dp[day + 1] = nextDay;
        }

        int maxPoints = 0;
        for (int i = 0; i < n; i++) maxPoints = Math.max(maxPoints, dp[k][i]);

        return maxPoints;
    }
}
",1434313316
LAKSHYA REDDY GOLI,22R11A0514,588,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        groups = []
        i = 0
        while i < len(word):
            count = 1
            while i + count < len(word) and word[i] == word[i + count]:
                count += 1
            groups.append((word[i], count))
            i += count

        possible_strings = set()
        
        for index, (char, count) in enumerate(groups):
            for k in range(1, count + 1):
                reduced_string = ''.join(
                    char * (k if idx == index else cnt) for idx, (char, cnt) in enumerate(groups)
                )
                possible_strings.add(reduced_string)
        
        return len(possible_strings)
        ",1434274125
Marat Shaydulin,shaydulin,589,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        tree = defaultdict(list)
        for i, p in enumerate(parent):
            tree[p].append(i)

        closest = [None] * 26
        start = ord(""a"")

        def traversal(root):
            i = ord(s[root]) - start
            old_closest = closest[i]
            if old_closest is not None:
                parent[root] = old_closest
            closest[i] = root
            for child in tree[root]:
                traversal(child)
            closest[i] = old_closest

        traversal(0)

        tree = defaultdict(list)
        for i, p in enumerate(parent):
            tree[p].append(i)

        ans = [0] * len(parent)
        def subtree_counter(root):
            ans[root] = sum(subtree_counter(child) for child in tree[root]) + 1
            return ans[root]

        subtree_counter(0)

        return ans
            
        ",1434309982
Marat Shaydulin,shaydulin,589,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        for i in range(k):
            nxt = [0] * n
            for u in range(n):
                for v in range(n):
                    if u == v:
                        nxt[u] = max(nxt[u], dp[u] + stayScore[i][u])
                    else:
                        nxt[v] = max(nxt[v], dp[u] + travelScore[u][v])
            dp = nxt
        return max(dp)
",1434334436
Marat Shaydulin,shaydulin,589,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        for k, g in groupby(word):
            l = len(list(g))
            if l == 1:
                continue
            ans += l - 1
        return ans",1434271045
Roshan,Roshan029,590,3576,cpp,"class Solution {
public:
   vector<int> findSubtreeSizes(vector<int>& parent, string& s) {
       int n = parent.size();
    vector<vector<int>> tree(n);
    for (int i = 1; i < n; ++i) {
        tree[parent[i]].push_back(i);
    }

    vector<int> newParent = parent;
    vector<int> lastOccurrence(26, -1);
    
    function<void(int)> dfs1 = [&](int node) {
        int charIndex = s[node] - 'a';
        if (lastOccurrence[charIndex] != -1) {
            newParent[node] = lastOccurrence[charIndex];
        }
        int prevAncestor = lastOccurrence[charIndex];
        lastOccurrence[charIndex] = node;
        
        for (int child : tree[node]) {
            dfs1(child);
        }
        
        lastOccurrence[charIndex] = prevAncestor;
    };
    
    dfs1(0);

    vector<vector<int>> newTree(n);
    for (int i = 1; i < n; ++i) {
        newTree[newParent[i]].push_back(i);
    }

    vector<int> subtreeSize(n, 1);

    function<int(int)> dfs2 = [&](int node) {
        int size = 1;
        for (int child : newTree[node]) {
            size += dfs2(child);
        }
        subtreeSize[node] = size;
        return size;
    };

    dfs2(0);
    return subtreeSize;
}
};",1434301317
Roshan,Roshan029,590,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& sc, vector<vector<int>>& tc) {
        // vector<vector<int>> dp(k, vector<int>(n, INT_MIN));
        // vector<vector<int>> v = sc;
        vector<int> next(n,0),curr(n,0);
        for(int d = k- 1; d>=0; d--){
            for(int c = 0; c<n; c++){
                int x = sc[d][c] + next[c];
                int maxi = 0;
                for(int i = 0; i<n ;i++){
                    if(i != c){
                        maxi = max(maxi,tc[c][i] + next[i]);
                    }
                }
                curr[c] = max(x,maxi);
            }
            next = curr;
        }
        int maxi = INT_MIN;
        for(auto it:curr)maxi = max(it,maxi);
        return maxi;
    }
};
",1434327908
Roshan,Roshan029,590,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        map<int,int> mp;
        // for(auto it:word)mp[it]++;
        int ans = 0 ;
        for(int i = 1; i<s.size(); i++){
            if(s[i] == s[i-1])ans++;
        }
        return ans + 1;
    }
};",1434265922
Tsung Han Wu,ynnekuw,591,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)

        path = {}
        
        def dfs(node):
            resume = False
            if s[node] in path:
                parent[node] = path[s[node]]
                resume = True
                
            path[s[node]] = node
            for child in children[node]:
                dfs(child)

            if resume:
                path[s[node]] = parent[node]
            else:
                del(path[s[node]])

        dfs(0)
        
        ans = [0] * n
        children = [[] for _ in range(n)]
        for i in range(1, n):
            children[parent[i]].append(i)
        
        def get_size(node):
            children_size = 1
            for child in children[node]:
                children_size += get_size(child)

            ans[node] = children_size
            return children_size

        _ = get_size(0)

        return ans",1434307742
Tsung Han Wu,ynnekuw,591,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        for i in range(k):
            next_dp = [0] * n
            for curr in range(n):
                for prev in range(n):
                    if curr == prev:
                        next_dp[curr] = max(next_dp[curr], dp[curr] + stayScore[i][curr])
                    else:
                        next_dp[curr] = max(next_dp[curr], dp[prev] + travelScore[prev][curr])

            dp = next_dp

        return max(dp)",1434327926
Tsung Han Wu,ynnekuw,591,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        char = '#'
        cnt = 1
        for c in word:
            if c != char:
                ans += cnt - 1
                char = c
                cnt = 1
            else:
                cnt += 1

        return ans + cnt - 1",1434278176
PREM PAWAR,PREM_PAWAR,593,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        vector<int> answer(n, 1);
        for (int i = 1; i < n; ++i) adj[parent[i]].push_back(i);
        vector<int> newParent = parent;
        unordered_map<char, vector<int>> lastSeen;
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : adj[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0);
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1;
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0);
        return answer;
    }
};",1434320699
PREM PAWAR,PREM_PAWAR,593,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day+1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[day + 1][dest]= max(dp[day+1][dest], dp[day][curr]+travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        return maxPoints;
    }
};",1434334806
PREM PAWAR,PREM_PAWAR,593,3617,cpp,"
class Solution {
public:
    int possibleStringCount(string word) {
        int totalCount = 1, n = word.length();
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && word[j] == word[i]) j++;
            int idx = j-i;
            if (idx > 1) totalCount += (idx - 1);
            i=j;
        }
        return totalCount;
    }
};",1434314395
yhkuo41,yhkuo41,594,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)

        def buildGraph(p: List[int]) -> List[List[int]]:
            adj = [[] for _ in range(n)]
            for i in range(1, n):
                adj[p[i]].append(i)
            return adj

        # p 2 children
        adj = buildGraph(parent)

        node2closetP = parent.copy()

        def dfs(node: int, closetP: List[int]) -> None:
            c = ord(s[node]) - ord(""a"")
            if closetP[c] != -1:
                node2closetP[node] = closetP[c]
            closetP[c] = node

            for child in adj[node]:
                dfs(child, closetP.copy())

        dfs(0, [-1] * 26)
        # print(node2closetP)
        adj = buildGraph(node2closetP)

        res = [0] * n

        def computeSz(node: int) -> int:
            sz = 1
            for child in adj[node]:
                sz += computeSz(child)
            res[node] = sz
            return sz

        computeSz(0)
        return res
",1434314826
yhkuo41,yhkuo41,594,3587,python3,"class Solution:
    def maxScore(
        self, n: int, k: int, stay: List[List[int]], travel: List[List[int]]
    ) -> int:
        dp = [[0 for _ in range(n)] for __ in range(k + 1)]
        for day in range(1, k + 1):
            for city in range(n):
                dp[day][city] = dp[day - 1][city] + stay[day - 1][city]
                for otherCity in range(n):
                    if city == otherCity:
                        continue
                    dp[day][city] = max(
                        dp[day][city], dp[day - 1][otherCity] + travel[otherCity][city]
                    )
        # print(dp)
        return max(dp[-1])
",1434334870
yhkuo41,yhkuo41,594,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        preC = ""0""
        cnt = 0
        for c in word:
            if c != preC:
                preC = c
                res += cnt
                cnt = 0
            else:
                cnt += 1
        res += cnt
        return res
",1434264430
davidbyrd,davidbyrd,596,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        adj = defaultdict(list)
        for i, par in enumerate(parent):
            adj[par].append(i)
            
        last_par = [[None] for _ in range(26)]
        
        def helper(node):
            char = ord(s[node]) - 97
            if last_par[char][-1] != None:
                parent[node] = last_par[char][-1]
            last_par[char].append(node)
            for child in adj[node]:
                helper(child)
            last_par[char].pop()
            return
            
        helper(0)

        adj = defaultdict(list)
        for i, par in enumerate(parent):
            adj[par].append(i)
            
        res = [0] * len(parent)
        
        def find_size(node):
            cou = 1
            for child in adj[node]:
                cou += find_size(child)
            res[node] = cou
            return cou
            
        find_size(0)
        
        return res
    
                
            ",1434304730
davidbyrd,davidbyrd,596,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
       
        @cache
        def helper(curr, i):
            if i == k:
                return 0
            res = helper(curr, i + 1) + stayScore[i][curr]
            for dest in range(n):
                if dest == curr:
                    continue
                res = max(res, helper(dest, i + 1) + travelScore[curr][dest])
            return res
        res = 0
        for start in range(n):
            res = max(res, helper(start, 0))
        return res",1434321283
davidbyrd,davidbyrd,596,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        tot = 1
        for i in range(1, len(word)):
            if word[i] == word[i - 1]:
                tot += 1
        return tot",1434307403
Anany Gupta,j1ZOdRmVbJ,598,3576,python3,"from typing import List, Dict, DefaultDict
from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = defaultdict(list)
        
        # Step 1: Build the initial tree from the parent array
        for child, p in enumerate(parent):
            if p != -1:
                tree[p].append(child)
        
        # Step 2: Reparent nodes based on the character matching rule
        # Store the closest ancestor with the same character
        closest_ancestor = {}
        
        # Traverse nodes in DFS order to apply reparenting
        def reparent(node: int, parent_node: int):
            char = s[node]
            # Check if there's an ancestor with the same character
            if char in closest_ancestor:
                # Reparent node to the closest ancestor with the same character
                actual_parent = closest_ancestor[char]
                if parent_node != -1:
                    tree[parent_node].remove(node)
                tree[actual_parent].append(node)
                parent[node] = actual_parent
            
            # Update closest ancestor for this character
            previous_ancestor = closest_ancestor.get(char)
            closest_ancestor[char] = node
            
            # Recurse on children
            for child in list(tree[node]):
                reparent(child, node)
            
            # Restore previous ancestor after visiting children
            if previous_ancestor is not None:
                closest_ancestor[char] = previous_ancestor
            else:
                del closest_ancestor[char]
        
        # Start reparenting from the root
        reparent(0, -1)
        
        # Step 3: Calculate the subtree sizes using DFS
        answer = [0] * n
        def calculate_subtree_size(node: int) -> int:
            size = 1  # Count the node itself
            for child in tree[node]:
                size += calculate_subtree_size(child)
            answer[node] = size
            return size
        
        calculate_subtree_size(0)
        return answer",1434298053
Anany Gupta,j1ZOdRmVbJ,598,3587,python3,"from typing import List

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        # Initialize the inputarr array
        inputarr = [[float('-inf')] * n for _ in range(k + 1)]
        
        # Starting point (day 0) can be any city
        for j in range(n):
            inputarr[0][j] = 0
        
        # Variable to store input midway in the function, as required
        functionreq = (n, k, stayScore, travelScore)
        
        # Fill the inputarr table
        for i in range(1, k + 1):
            for j in range(n):  # City `j` at the end of day `i`
                # Option 1: Stay in the same city `j`
                inputarr[i][j] = max(inputarr[i][j], inputarr[i - 1][j] + stayScore[i - 1][j])
                
                # Option 2: Travel from another city `x` to city `j`
                for x in range(n):
                    if x != j:
                        inputarr[i][j] = max(inputarr[i][j], inputarr[i - 1][x] + travelScore[x][j])
        
        # Maximum points achievable after `k` days in any city
        return max(inputarr[k])",1434306643
Anany Gupta,j1ZOdRmVbJ,598,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        # Step 1: Identify all streaks of repeated characters
        i = 0
        n = len(word)
        streakss = []
        
        while i < n:
            start = i
            while i + 1 < n and word[i] == word[i + 1]:
                i += 1
            streakk_length = i - start + 1
            streakss.append(streakk_length)
            i += 1
        
        # Base case: original string itself
        total_count = 1
        
        # Step 2: Consider removing duplicates from each streak once
        for length in streakss:
            if length > 1:
                total_count += length - 1
        
        return total_count",1434297005
Lakshay Gupta,lakshaygpt28,599,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        List<Integer> g[] = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            g[i] = new ArrayList<>();
        }
        int root = -1;
        for (int i = 0; i < n; i++) {
            int u = parent[i];
            int v = i;
            if (u == -1) {
                root = v;
                continue;
            }
            g[u].add(v);
        }
        int[] closestParent = new int[26];
        Arrays.fill(closestParent, -1);
        dfs(root, s, parent, closestParent, g);

        for (int i = 0; i < n; i++) {
            g[i] = new ArrayList<>();
        }
        for (int i = 0; i < n; i++) {
            int u = parent[i];
            int v = i;
            if (u == -1) {
                root = v;
                continue;
            }
            g[u].add(v);
        }
        int[] result = new int[n];
        dfs2(root, g, result);
        return result;
    }

    int dfs2(int u, List<Integer> g[], int[] result) {
        int ans = 1;
        for (int v : g[u]) {
            ans += dfs2(v, g, result);
        }
        return result[u] = ans;
    }

    void dfs(int u, String s, int[] parent, int[] closestParent, List<Integer> g[]) {
        char ch = s.charAt(u);
        if (closestParent[ch - 'a'] != -1) {
            parent[u] = closestParent[ch - 'a'];
        }
        int tmp = closestParent[ch - 'a'];
        closestParent[ch - 'a'] = u;
        for (int v : g[u]) {
            dfs(v, s, parent, closestParent, g);
        }
        closestParent[ch - 'a'] = tmp;
    }
}",1434310370
Lakshay Gupta,lakshaygpt28,599,3587,java,"class Solution {
    int N, K;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int ans = 0;
        int[][] dp = new int[k][n];
        for (int i = 0; i < k; i++) {
            Arrays.fill(dp[i], -1);
        }
        N = n; K = k;
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, solve(0, i, dp, stayScore, travelScore));
        }
        return ans;
    }
    int solve(int idx, int city, int[][] dp, int[][] stayScore, int[][] travelScore) {
        if (idx == K) {
            return 0;
        }
        if (dp[idx][city] != -1) {
            return dp[idx][city];
        }
        int ans = 0;
        ans = solve(idx + 1, city, dp, stayScore, travelScore) + stayScore[idx][city];
        for (int i = 0; i < N; i++) {
            if (i == city) continue;
            ans = Math.max(ans, solve(idx + 1, i, dp, stayScore, travelScore) + travelScore[city][i]);
        }
        return dp[idx][city] = ans;
    }
}",1434335138
Lakshay Gupta,lakshaygpt28,599,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int n = word.length();
        char[] s = word.toCharArray();
        int cnt = 1;
        int ans = 1;
        for (int i = 1; i < n; i++) {
            if (s[i] == s[i - 1]) {
                cnt++;
            } else {
                ans += cnt - 1;
                cnt = 1;
            }
        }
        ans += cnt - 1;
        return ans;
    }
}",1434273064
Karukuri Sreehitha,Sreehitha_k,600,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        vector<int> answer(n, 1);

        for (int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }
        vector<int> newParent = parent;
        unordered_map<char, vector<int>> lastSeen;
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : tree[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0); 
        vector<vector<int>> newAdj(n); 
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1; 
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0); 
        return answer;
    }
};",1434307263
Karukuri Sreehitha,Sreehitha_k,600,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1,vector<int>(n,-1));

        function<int(int,int)> solve = [&](int day, int curr) -> int {
            if(day==k){
                return 0;
            }
            if(dp[day][curr] != -1){
                return dp[day][curr];
            }

            int max_points = stayScore[day][curr] + solve(day+1,curr);

            for(int i = 0; i<n; ++i){
                if(i!=curr){
                    max_points = max(max_points,travelScore[curr][i]+solve(day+1,i));
                }
            }
            dp[day][curr] = max_points;
            return max_points;
        };
        int max_res = 0;
        for(int start_city=0;start_city<n;++start_city){
            max_res = max(max_res,solve(0,start_city));
        }
        return max_res;
    };
};",1434328356
Karukuri Sreehitha,Sreehitha_k,600,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        int n= word.length();
        for(int i=0;i<n;i++){
            int count =1;
            while(i+1<n&&word[i]==word[i+1]){
                ++count;
                ++i;
            }
            ans+=count-1;
        }
        return ans;
    }
};",1434275085
Matthew DeGuzman,blackcherry29,602,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        adj_list = defaultdict(set)
        for i in range(len(parent)):
            adj_list[parent[i]].add(i)

        encountered = {c: -1 for c in string.ascii_lowercase}
        def dfs(node: int):
            if encountered[s[node]] != -1:
                p = parent[node]
                adj_list[p].remove(node)
                adj_list[encountered[s[node]]].add(node)
            
            prev_value = encountered[s[node]]
            
            encountered[s[node]] = node
            children = list(adj_list[node])
            for ch in children:
                dfs(ch)
                
            if prev_value != -1:
                encountered[s[node]] = prev_value
            else:
                encountered[s[node]] = -1

        def dfs_size(node: int, res: list[int]) -> int:
            size = 1
            for ch in adj_list[node]:
                size += dfs_size(ch, res)
            res[node] = size
            return size
                
        res = [0] * len(s)
        dfs(0)
        dfs_size(0, res)
        return res",1434311035
Matthew DeGuzman,blackcherry29,602,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @cache
        def dp(day: int, city: int) -> int:
            if day == k:
                return 0

            # stay
            stay_score = stayScore[day][city] + dp(day+1, city)
            travel_score = -1
            for i in range(n):
                if i == city:
                    continue
                travel_score = max(travel_score, dp(day+1, i) + travelScore[city][i])
            return max(stay_score, travel_score)
        
        return max(dp(0, i) for i in range(n))",1434328409
Matthew DeGuzman,blackcherry29,602,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        dup = 0
        for i in reversed(range(len(word)-1)):
            if word[i] == word[i+1]:
                dup += 1
            
        return 1 + dup",1434264096
hello_motto,hello_motto,603,3576,cpp,"class Solution {
public:
    void dfs(int s, int p, vector<vector<int>>&adj, string &str, map<char,vector<int>>&mp, set<pair<int,int>>&st){
        
        auto last = mp[str[s]].size()==0?-1:mp[str[s]].back();
        if(last == -1){
            if(p!=-1)
            st.insert({s,p});
        }
        else{
            st.insert({s,last});
        }
        
        
        // cout<<s<<"" ""<<p<<"" ""<<last<<endl;
        mp[str[s]].push_back(s);
        for(auto x:adj[s]){
            if(x!=p){
                dfs(x,s,adj,str,mp,st);
            }
        }
        
        mp[str[s]].pop_back();
        
    }
    
    
    int dfs2(int s,int p,vector<vector<int>>&adj, vector<int>&v){
        
        int ans = 1;
        for(auto x:adj[s]){
            if(x!=p){
                  ans+=dfs2(x,s,adj,v) ;        
            }
        }
        v[s] = ans;
        return ans;
    }
    
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        set<pair<int,int>>st;
        vector<vector<int>>adj(n);
        vector<vector<int>>adj2(n);
        
        for(int i=0;i<parent.size();i++){
            if(parent[i]==-1)continue;
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        
        map<char,vector<int>>mp;
        dfs(0,-1,adj,s,mp,st);
        
        for(auto x:st){
            // cout<<x.first<<"" ""<<x.second<<endl;
            adj2[x.first].push_back(x.second);
            adj2[x.second].push_back(x.first);
        }
        vector<int>ans(n,0);
        dfs2(0,-1,adj2,ans);
        
        return ans;
        
    }
};",1434316657
hello_motto,hello_motto,603,3587,cpp,"class Solution {
public:
    
    int dp[201][201];
    int f(int city,int day,vector<vector<int>>& ss, vector<vector<int>>& ts){
        
        
        if(day == ss.size()){
            return 0;
        }
        int n = ts.size();
        int ans = 0;
        if(dp[city][day]!=-1) return dp[city][day];
        //stay in same city
        ans = max(ans,f(city, day+1,ss,ts) + ss[day][city]);
        
        //travel to another
        
        for(int i=0;i<n;i++){
            if(i==city)continue;
            ans= max(ans,f(i,day+1,ss,ts)+ts[city][i]);
        }
        
        return dp[city][day] = ans;
    }
    
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        memset(dp,-1,sizeof(dp));
        
        int ans = 0;
        for(int i=0;i<n;i++){
            ans = max(ans,f(i,0,ss,ts));
        }
        
        return ans;
        
    }
};",1434328510
hello_motto,hello_motto,603,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        
        int c = 1;
        int ans= 0;
        for(auto i=1;i<s.size();i++){
            if(s[i]==s[i-1]){
                c++;
            }
            else{
                ans+= (c-1);
                c = 1;
            }
        }
        if(c>0){
            ans+= (c-1);
        }
        
        return ans+1;
    }
};",1434285199
Aditya Gandhi,adis176,605,3576,cpp,"class Solution {
public:
    void recurs(int p, vector<vector<int>>& adj, string& s, vector<int> stored, int par, vector<vector<int>>& newadj){
        if(par!=-1){
            int adder = int(s[par]-'a');
            // cout<<""par add: ""<<adder<<"" ""<<par<<endl;
            stored[adder] = par;
        }
        
        for(auto y: adj[p]){
            recurs(y, adj, s, stored, p, newadj);
        }
        
        // make new parent
        int currChar = int(s[p]-'a');
        // cout<<""curr char: ""<<currChar<<endl;
        if(stored[currChar]!=-1){
            // cout<<""stored currchar: ""<<stored[currChar]<<"" ""<<p<<endl;
            newadj[stored[currChar]].push_back(p);
        } else{
            if(p!=-1 && par!=-1) newadj[par].push_back(p);
        }
        return;
    }
    
    int recurs2(vector<vector<int>>& newadj, vector<int>& ans, int p){
        int a1 = 1;
        for(auto y: newadj[p]){
            a1 += recurs2(newadj, ans, y);
        }
        ans[p] = a1;
        return a1;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        // adj - 2d
        vector<vector<int>> adj(n), newadj=adj;
        for(int i=0; i<parent.size(); i++){
            if(parent[i]!=-1) adj[parent[i]].push_back(i);
        }
        vector<int> stored(26, -1);
        recurs(0, adj, s, stored, -1, newadj);
        
        // for(int i=0; i<n; i++){
        //     cout<<i<<""-"";
        //     for(auto y: newadj[i]){
        //         cout<<y<<"" "";
        //     }
        //     cout<<endl;
        // }
        vector<int> ans(n, 0);
        recurs2(newadj, ans, 0);
        return ans;
    }
};",1434318035
Aditya Gandhi,adis176,605,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<long long>> vis(k+2, vector<long long>(n+1,0));
        vector<vector<int>>temp = stayScore;
        for(int d = k-1;d>=0; d--) {
            for(int j =0; j<n; j++) {
                long long mx=(long long)stayScore[d][j]+vis[d +1][j];
        
                for(int k=0; k<n; k++){
                    if(k!=j) mx= max(mx,  (long long)travelScore[j][k]+ vis[d +1][k]);
                }
                    vis[d][j]=mx;
            }
        }
        
        long long ans=0;
        for(int ct=0; ct<n; ct++) {
            if(vis[0][ct] >ans) ans = vis[0][ct];
        }
        return ans;
    }
};",1434335394
Aditya Gandhi,adis176,605,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        unordered_map<int, int> m;
        int p1=0, p2=0, tmp=0;
        char curr;
        while(p1<word.size()){
            curr = word[p1];
            while(p2<word.size() && curr == word[p2]){
                p2++;
            }
            m[p1] = p2-p1;
            p1=p2;
        }
        m[p1]=p2-p1;
        
        for(auto it=m.begin(); it!=m.end(); it++){
            // cout<<it->first<<""-""<<it->second<<endl;
            int ad = it->second-1;
            if(ad<0) ad=0;
            ans += ad;
        }
        return ans;
    }
};",1434274240
Akhy,akshaykumars,606,3576,python3,"

class Solution:
    
    def dfs(self, i, d, s, parent, adj):
        if s[i] in d.keys():
            parent[i]=d[s[i]]
        d[s[i]]=i
        if i in adj.keys():
            for c in adj[i]:
                self.dfs(c, d.copy(), s, parent, adj)
    def dfs2(self, i, adj, l):
        siz=0
        if i not in adj.keys():
            l[i]=1
            return 1
        else:
            for c in adj[i]:
                siz+=self.dfs2(c, adj, l)
            l[i]=siz+1
            return siz+1
    
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n= len(parent)
        adj = {}
        for i in range(0,n):
            if i==0:
                continue
            if parent[i] in adj.keys():
                adj[parent[i]].append(i)
            else:
                adj[parent[i]]=[i]
        self.dfs(0, {}, s, parent, adj)
        
        adj = {}
        for i in range(0,n):
            if i==0:
                continue
            if parent[i] in adj.keys():
                adj[parent[i]].append(i)
            else:
                adj[parent[i]]=[i]
        # print(adj)
        l = [0 for i in range(n)]
        l[0]=self.dfs2(0, adj, l)
        # print(parent)
        return l
        ",1434314844
Akhy,akshaykumars,606,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0 for _ in range(n)] for _ in range(k+1)]
        for i in range(1,k+1):
            for j in range(n):
                for c in range(n):
                    if c!=j:
                        dp[i][j]=max(dp[i][j], dp[i-1][c]+travelScore[c][j])
                    else:
                        dp[i][j]=max(dp[i][j], dp[i-1][c]+stayScore[i-1][c])
        # print(dp)
        return max(dp[k])",1434335404
Akhy,akshaykumars,606,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        l = 0
        c=0
        for i in range(1,n):
            if word[i]==word[i-1]:
                c+=1
            else:
                l+=c
                c=0
        l += c
        return l+1
                
        ",1434273754
prakharrrr4,prakharrrr4,607,3576,cpp,"class Solution {
public:
    vector<vector<int>> g2;
    vector<vector<int>> g;
    vector<int> sz;
    
    string str;
    
    void dfs(int r=0,int p = -1,vector<int> closest = vector<int>(26,-1))
    {
        closest[str[r]-'a'] = r;
        for(auto v : g[r])
        {
            if(closest[str[v]-'a']!=-1)
            {
                g2[closest[str[v]-'a']].push_back(v);
            }
            else
            {
                g2[r].push_back(v);
            }
            
            dfs(v,r,closest);
        }
    }
    
    void dfs2(int r=0,int p = -1)
    {
        for(auto v: g2[r])
        {
            dfs2(v,r);
            sz[r] += sz[v];
        }
        sz[r]+=1;
        return;
    }
    
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = (int)(s.size());
        g=vector<vector<int>>(n);
        g2 = vector<vector<int>>(n);
        sz = vector<int>(n);
        for(int i=1;i<n;i++)
        {
            g[parent[i]].push_back(i);
        }
        str = s;        
        dfs();
        dfs2();
        return sz;
        
    }
};",1434324158
prakharrrr4,prakharrrr4,607,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // dp[city][day] = maximum score at this point. day is not yet over
        // dp[city][day] -> dp[city2][day + 1] + traverscore[city][city2]
        // dp[city][day] -> dp[city][day + 1] + stayscore[day][city]
        // dp[*][0] = 0   
        vector<vector<int>> dp(n+1,vector<int>(k+1,INT_MIN));
        for(int i=0;i<n;i++)
            dp[i][0] = 0;
        for(int j=0;j<k;j++)
            for(int i=0;i<n;i++)
            {
                if(dp[i][j] == INT_MIN)
                        continue;
                for(int v =0; v<n;v++)
                {
                    if(i!=v)
                        dp[v][j+1] = max(dp[v][j+1],dp[i][j] + travelScore[i][v]);
                    else
                        dp[v][j+1] = max(dp[v][j+1],dp[i][j] + stayScore[j][i]);
                }
            }
        int ret = 0;
        for(int i=0;i<n;i++)
                ret = max(ret, dp[i][k]);
        return ret;
    }
};",1434278392
prakharrrr4,prakharrrr4,607,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ret = 1;
        for(int i=0;i<word.size();)
        {
            int j = i;
            while(i<word.size() and word[i] == word[j])
                i++;
            ret += i-j-1;
        }
        return ret;
    }
};",1434328673
timolke42,timolke42,608,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        def makeTree(l):
            nei = [[] for _ in range(n+1)]
            for i in range(n):
                nei[l[i]].append(i)
            return nei
        
        nodes = makeTree(parent)
        new_parent = parent
        def helper(root, dic):
            new_dic = dic.copy()
            letter = s[root]
            if letter in dic:
                new_parent[root] = dic[letter]
            new_dic[letter] = root
            for n in nodes[root]:
                helper(n, new_dic)
        helper(0, {})
        new_nodes = makeTree(new_parent)
        output = [0]*n
        def result(root):
            answer = 1
            for n in new_nodes[root]:
                answer += result(n)
            output[root] = answer
            return answer
        result(0)
        return output
                
                
            
                
                ",1434313336
timolke42,timolke42,608,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        mx = [0]*n
        for i in range(k):
            new_max = []
            for j in range(n):
                best = stayScore[k-i-1][j] + mx[j]
                for other in range(j):
                    best = max(travelScore[j][other] + mx[other], best)
                for other in range(j+1,n):
                    best = max(travelScore[j][other] + mx[other], best)
                new_max.append(best)
            mx = new_max
        return max(mx)
                
            
        ",1434329111
timolke42,timolke42,608,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        count = 1
        n = len(word)
        for i in range(n):
            if i < n- 1 and word[i] == word[i+1]:
                count += 1
        return count
        ",1434335544
Shivyansh Garg,vizerion,610,3576,cpp,"class Solution {
public:
    vector < vector < int > > t, mt;
    vector < int > ss, np;

    int cMSS(int n){
        
        ss[n] = 1;
        
        for(auto c : mt[n])    ss[n] += cMSS(c);
        
        return ss[n];
    }

    void mT(int n, string &s, unordered_map<char, stack<int>> &ls){
        
        char ch = s[n];
        
        if(!ls[ch].empty())    np[n] = ls[ch].top();
        
        ls[ch].push(n);
        
        for(auto c : t[n])    mT(c, s, ls);
        
        ls[ch].pop();
    }

    vector<int> findSubtreeSizes(vector<int>& p, string s){
        
        int n = p.size();
        t.resize(n);
        mt.resize(n);
        ss.assign(n, 0);
        np = p;

        for(int i = 1; i < n; i++)    t[p[i]].push_back(i);
        

        unordered_map < char ,  stack < int > > ls;
        mT(0, s, ls);

        for(int i = 1; i < n; i++)    mt[np[i]].push_back(i);
    
        cMSS(0);

        return ss;
    }
};",1434321959
Shivyansh Garg,vizerion,610,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:

    int dp[200][200];
    vector < vector < int > > ss , ts;

    int solve(int i, int c, int n, int k){
        
        if(i == k)    return 0;
        if(dp[i][c] != -1)    return dp[i][c];
        

        int maxi = ss[i][c] + solve(i + 1, c, n, k);
        
        for(int j = 0; j < n; j++){
            
            if(j != c){
                
                int points = ts[c][j] + solve(i + 1, j, n, k);
                maxi = max(maxi, points);
            }
        }
        return dp[i][c] = maxi;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        
        memset(dp, -1, sizeof(dp));
        ss = stayScore, ts = travelScore;
        
        int maxi= 0;
        
        for(int i = 0; i < n; i++){
            maxi = max(maxi, solve(0, i, n, k));
        }

        return maxi;
    }
};",1434304839
Shivyansh Garg,vizerion,610,3617,cpp,"#include <string>
#include <vector>
using namespace std;

class Solution {
public:
    int possibleStringCount(string s) {
        
        int n = s.length(), i = 0, ways = 1;
        vector < int > v;

        while(i < n){
            char c = s[i];
            int count = 0;
            
            while(i < n && s[i] == c){
                count++;
                i++;
            }
            v.push_back(count);
        }

        for(auto x : v){
            
                if(x > 1)ways += (x - 1);
            
        }

        return ways;
    }
};",1434271705
Saransh Agrawal,Saransh142,611,3576,python3,"from collections import defaultdict
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        
        last_seen = {}
        new_parent = parent[:]
        
        def dfs(node):
            char = s[node]
            if char in last_seen:
                ancestor = last_seen[char]
                if ancestor != -1:
                    new_parent[node] = ancestor
            
            prev_ancestor = last_seen.get(char, -1)
            last_seen[char] = node
            
            for child in tree[node]:
                dfs(child)
            
            last_seen[char] = prev_ancestor
    
        dfs(0)
        
        new_tree = defaultdict(list)
        for i in range(1, n):
            new_tree[new_parent[i]].append(i)
        
        subtree_size = [0] * n
    
        def computeSubtreeSize(node):
            size = 1
            for child in new_tree[node]:
                size += computeSubtreeSize(child)
            subtree_size[node] = size
            return size
    
        computeSubtreeSize(0)
        
        return subtree_size
",1434288528
Saransh Agrawal,Saransh142,611,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0]*n for _ in range(k)]

        for i in range(n):
            dp[0][i] = stayScore[0][i]

            for prev in range(n):
                if prev != i:
                    dp[0][i] = max(dp[0][i],travelScore[prev][i])

        for i in range(1,k):
            for curr in range(n):
                dp[i][curr] = dp[i-1][curr] + stayScore[i][curr]

                for prev in range(n):
                    if prev != curr:
                        dp[i][curr] = max(dp[i][curr],dp[i-1][prev] + travelScore[prev][curr])
        return max(dp[k-1])",1434321972
Saransh Agrawal,Saransh142,611,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        s = {}
        count = 1
        i = 0
        while i<len(word):
            a = word[i]
            j = i+1
            while j<len(word) and word[j] == a:
                count += 1
                j += 1
            i = j
        return count
                ",1434273453
utsav1402,utsav1402,612,3576,cpp,"#include <vector>
#include <string>
#include <unordered_map>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        
        // Step 1: Build the initial adjacency list for the tree
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        
        // Step 2: Reassign parents based on character match using a stack for each character
        vector<int> newParent = parent;
        unordered_map<char, stack<int>> lastSeenStack;
        
        function<void(int)> dfs = [&](int node) {
            char c = s[node];
            
            // Check if there is a matching ancestor with the same character
            if (!lastSeenStack[c].empty()) {
                newParent[node] = lastSeenStack[c].top();
            }
            
            // Push the current node onto the stack for this character
            lastSeenStack[c].push(node);
            
            for (int child : adj[node]) {
                dfs(child);
            }
            
            // Pop from the stack to restore the previous state
            lastSeenStack[c].pop();
        };
        
        dfs(0); // Start DFS from the root node (node 0)
        
        // Step 3: Build the new adjacency list based on the updated parents
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }
        
        // Step 4: Calculate subtree sizes with DFS on the new tree
        vector<int> answer(n, 0);
        
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int subtreeSize = 1; // Start with counting the node itself
            for (int child : newAdj[node]) {
                subtreeSize += computeSubtreeSizes(child);
            }
            answer[node] = subtreeSize;
            return subtreeSize;
        };
        
        computeSubtreeSizes(0); // Compute subtree sizes starting from the root
        return answer;
    }
};
",1434287995
utsav1402,utsav1402,612,3587,cpp,"#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Initialize 2D DP array with INT_MIN
        vector<vector<int>> dp(k + 1, vector<int>(n, INT_MIN));
        
        // Define a recursive function to solve the problem
        function<int(int, int)> solve = [&](int dayod, int currlt) -> int {
            // Base case: reached end of journey
            if (dayod == k) {
                return 0;
            }
            
            // If already computed
            if (dp[dayod][currlt] != INT_MIN) {
                return dp[dayod][currlt];
            }
            
            // Option 1: Stay in current city
            int max_points = stayScore[dayod][currlt] + solve(dayod + 1, currlt);
            
            // Option 2: Move to another city
            for (int next_city = 0; next_city < n; ++next_city) {
                if (next_city != currlt) {  // Can't move to the same city
                    max_points = max(max_points,
                                     travelScore[currlt][next_city] + solve(dayod + 1, next_city));
                }
            }
            
            // Store and return result
            dp[dayod][currlt] = max_points;
            return max_points;
        };
        
        // Try starting from each city and return the maximum points
        int resultgu = INT_MIN;
        for (int start_city = 0; start_city < n; ++start_city) {
            resultgu = max(resultgu, solve(0, start_city));
        }
        
        return resultgu;
    }
};
",1434307448
utsav1402,utsav1402,612,3617,cpp,"#include <unordered_set>
#include <string>
using namespace std;

class Solution {
public:
    int possibleStringCount(string word) {
        unordered_set<string> possibleStrings;
        possibleStrings.insert(word); // Add the original string as a possibility

        int n = word.size();
        int i = 0;

        // Traverse through the string
        while (i < n) {
            int j = i;
            // Find the end of the current sequence of identical characters
            while (j < n && word[j] == word[i]) {
                j++;
            }

            int length = j - i;
            string base = word;

            // Create new strings by shortening the current sequence one character at a time
            for (int k = 1; k < length; ++k) {
                // Construct the modified string with k repetitions of the current character
                string shortened = word.substr(0, i) + string(k, word[i]) + word.substr(j);
                possibleStrings.insert(shortened);
            }

            i = j; // Move to the next sequence
        }

        return possibleStrings.size(); // Return the total unique possibilities
    }
};
",1434280675
Venkata Rishi Karthik,rishi_2004_02,613,3576,python3,"from typing import List, Dict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        
        # Step 1: Build the initial tree as an adjacency list
        tree = [[] for _ in range(n)]
        for child in range(1, n):
            tree[parent[child]].append(child)
        
        # Dictionary to store the closest ancestor with the same character
        closest_ancestor = {}

        # Step 2: DFS to find the closest ancestor with the same character
        def dfs(node: int, ancestor_map: Dict[str, int]):
            # Check if there's an ancestor with the same character as `s[node]`
            if s[node] in ancestor_map:
                closest_ancestor[node] = ancestor_map[s[node]]
            else:
                closest_ancestor[node] = -1
            
            # Update the map to mark the current node as the latest occurrence of `s[node]`
            previous = ancestor_map.get(s[node])
            ancestor_map[s[node]] = node
            
            # Recur for children
            for child in tree[node]:
                dfs(child, ancestor_map)
            
            # Backtrack to restore the map for other branches
            if previous is None:
                del ancestor_map[s[node]]
            else:
                ancestor_map[s[node]] = previous

        # Initialize DFS from the root node (0)
        dfs(0, {})

        # Step 3: Update the tree based on closest ancestors
        new_tree = [[] for _ in range(n)]
        for node in range(1, n):
            # Determine new parent based on closest ancestor or keep the existing parent
            new_parent = closest_ancestor[node] if closest_ancestor[node] != -1 else parent[node]
            new_tree[new_parent].append(node)

        # Step 4: Calculate subtree sizes
        subtree_sizes = [0] * n

        def calculate_subtree_size(node: int) -> int:
            size = 1
            for child in new_tree[node]:
                size += calculate_subtree_size(child)
            subtree_sizes[node] = size
            return size

        # Compute sizes from the root (0)
        calculate_subtree_size(0)

        return subtree_sizes

        ",1434303277
Venkata Rishi Karthik,rishi_2004_02,613,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0] * n for _ in range(k + 1)]
        
        for day in range(1, k + 1):
            for city in range(n):
                max_points = 0
                for prev_city in range(n):
                    points = dp[day - 1][prev_city] + (stayScore[day - 1][city] if city == prev_city else travelScore[prev_city][city])
                    max_points = max(max_points, points)
                dp[day][city] = max_points
        
        return max(dp[k])


        ",1434329009
Venkata Rishi Karthik,rishi_2004_02,613,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        
        consecutive_groups = []
        start_index = 0
        while start_index < len(word):
            end_index = start_index
            while end_index < len(word) and word[end_index] == word[start_index]:
                end_index += 1
            consecutive_groups.append(word[start_index:end_index])
            start_index = end_index

        
        if all(len(group) == 1 for group in consecutive_groups):
            return 1

        
        unique_string_count = 1  

        for group in consecutive_groups:
            if len(group) > 1:
                unique_string_count += len(group) - 1   
        return unique_string_count


solution = Solution()
print(solution.possibleStringCount(""abbcccc""))  
print(solution.possibleStringCount(""abcd""))     
print(solution.possibleStringCount(""aaaa""))     
  
        ",1434293762
Joker17,Joker_171,614,3576,python3,"class TreeNode:
    def __init__(self,val):
        self.val = val
        self.children = set()

class Solution:

    ans = []

    def makeTree(self,parent):
        root = TreeNode(0)

        n = len(parent)

        d = {}

        d[0] = root

        for i in range(1,n):
            no = i
            par = parent[i]

            node1 = d.get(no)
            node2 = d.get(par)

            if node1 is None:
                node1 = TreeNode(no)
                d[no] = node1

            if node2 is None:
                node2 = TreeNode(par)
                d[par] = node2

            node2.children.add(node1)

        return root


    def dfs(self,root,d,s,parent):
        if root is None:
            return 

        c = s[root.val]

        origVal = None

        if d.get(c) is not None:
            origVal = d[c]

        if d.get(c) is not None:
            parent.children.remove(root)

            newParent = d[c]

            newParent.children.add(root)

        d[c] = root

        for child in root.children.copy():
            self.dfs(child,d,s,root)

        if origVal is not None:
            d[c] = origVal

        else:
            del d[c]

        return

    def countSize(self,root):
        if root is None:
            return 0

        count = 1

        for child in root.children:
            count += self.countSize(child)

        self.ans[root.val] = count

        return count

        
            
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        self.ans = [0]*n

        root = self.makeTree(parent)
        d = {}

        self.dfs(root,d,s,None)

        self.countSize(root)

        return self.ans

        
        ",1434311009
Joker17,Joker_171,614,3587,python3,"class Solution:
    def findMaxFrom(self,currCity,currDay,k,ss,ts,dp):
        if currDay == k:
            return 0

        key = (currCity,currDay)

        if dp.get(key) is not None:
            return dp[key]

        ans = 0

        stay = ss[currDay][currCity] + self.findMaxFrom(currCity,currDay+1,k,ss,ts,dp)

        travel = 0

        for i in range(len(ts)):
            if i == currCity:
                continue

            travel = max(travel, ts[currCity][i] + self.findMaxFrom(i,currDay+1,k,ss,ts,dp))

        dp[key] = max(stay, travel)


        return dp[key]

            
        
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        ans = 0
        dp = {}

        for i in range(n):
            ans = max(ans,self.findMaxFrom(i,0,k,stayScore,travelScore,dp))

        return ans
        ",1434329189
Joker17,Joker_171,614,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1

        n = len(word)

        i = 1

        while i < n:
            count = 0
            while i < n and word[i-1] == word[i]:
                count += 1
                i += 1

            ans += count
            i += 1

        return ans
                
        ",1434263201
codelelouch0,codelelouch0,615,3576,cpp,"class Solution {
public:
    void f(vector<vector<int>> &g, vector<int> &parent, string &s, int cur, unordered_map<char, int> &mp) {
        if (mp[s[cur]] != 0) {
            parent[cur] = mp[s[cur]]-1;
        }
        int tmp = mp[s[cur]];
        for (auto &i : g[cur]) {
            mp[s[cur]] = cur+1;
            f(g, parent, s, i, mp);
        }
        mp[s[cur]] = tmp;
        return;
    }
    int f2(vector<vector<int>> &t, int cur, vector<int> &res) {
        int ret = 1;
        for (auto &i : t[cur]) {
            ret += f2(t, i, res);
        }
        res[cur] = ret;
        return ret;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> res(n);
        vector<vector<int>> g(n);
        for (int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }
        unordered_map<char, int> mp;
        f(g, parent, s, 0, mp);
        vector<vector<int>> t(n);
        for (int i = 1; i < n; i++) {
            t[parent[i]].push_back(i);
        }
        f2(t, 0, res);
        return res;
    }
};",1434302431
codelelouch0,codelelouch0,615,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) {
        vector<vector<int>> dp (n, vector<int> (k+1, 0));
        for (int i = 1; i <= k; i++) {
            for (int j = 0; j < n; j++) {
                for (int x = 0; x < n; x++) {
                    if (j == x) dp[j][i] = max(dp[j][i], dp[j][i-1]+s[i-1][j]);
                    else dp[j][i] = max(dp[j][i], dp[x][i-1]+t[x][j]);
                }
            }
        }
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = max(res, dp[i][k]);
        }
        return res;
    }
};",1434322351
codelelouch0,codelelouch0,615,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 0;
        int n = word.size();
        int tmp = 1;
        int count = 0;
        for (int i = 1; i < n; i++) {
            if (word[i] == word[i-1]) {
                tmp++;
            } else {
                res += tmp;
                count++;
                tmp = 1;
            }
        }
        if (tmp > 1) {
            res += tmp;
            count++;
        }
        res -= count;
        res++;
        return res;
    }
};",1434268221
Rankireddy Sai Mani Akarsh,akarsh__11,616,3576,cpp,"class Solution {
public:
    void dfs(int src,  vector<vector<int>>& graph, vector<int>& parent, string& s, vector<int>& alpha){
            if(alpha[s[src]-'a']!=-1){
                parent[src]=alpha[s[src]-'a'];
            }
        int before=alpha[s[src]-'a'];
        alpha[s[src]-'a']=src;
        for(int node:graph[src]){
            dfs(node, graph, parent, s, alpha);
        }
        alpha[s[src]-'a']=before;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int> alpha(26, -1);
        int n = s.length();
        vector<vector<int>> graph(n);
        for(int i=1;i<n;i++){
            graph[parent[i]].push_back(i);
        }
        dfs(0, graph, parent, s, alpha);
        vector<vector<int>> graph_new(n);
        
        for(int i=1;i<n;i++){
            graph_new[parent[i]].push_back(i);
        }
        queue<int> q;
        vector<int> ans(n, 0);
        vector<int> degree(n, 0);
        for(int i=0;i<n;i++){
            degree[i]=graph_new[i].size();
            if(degree[i]==0) q.push(i);
        }
        while(!q.empty()){
            int n = q.size();
            for(int i=0;i<n;i++){
                int curr=q.front();
                q.pop();
                ans[curr]=1;
                for(int neigh:graph_new[curr]){
                    ans[curr]+=ans[neigh];
                }
                if(curr!=0) degree[parent[curr]]--;
                if(curr!=0 && degree[parent[curr]]==0){
                    q.push(parent[curr]);
                }
            }
        }
        return ans;
    }
};",1434320303
Rankireddy Sai Mani Akarsh,akarsh__11,616,3587,cpp,"class Solution {
public:
     int dfs(int day, int k, int city, int n, vector<vector<int>>& dp, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
         if(day==k) return 0;
         if(dp[day][city]!=-1) return dp[day][city];
         int score=0;
         for(int i=0;i<n;i++){
             if(i==city){
                 score=max(score, stayScore[day][i]+dfs(day+1, k, city, n, dp, stayScore, travelScore));
             }else{
                 score=max(score, travelScore[city][i]+dfs(day+1, k, i, n, dp, stayScore, travelScore));
             }
         }
         return dp[day][city]=score;
     }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1, vector<int>(n+1, -1));
        int ans=0;
        for(int i=0;i<n;i++){
            ans=max(ans, dfs(0, k, i, n, dp, stayScore, travelScore));
        }
        return ans;
    }
};",1434336065
Rankireddy Sai Mani Akarsh,akarsh__11,616,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count=1;
        char prev=word[0];
        int n = word.length();
        for(int i=1;i<n;i++){
            if(word[i]==prev){
                count++;
            }
            prev=word[i];
        }
        return count;
    }
};",1434281448
Priyanshu Kumar,pribyte1,617,3576,java,"import java.util.*;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        int[] answer = new int[n];
        List<List<Integer>> tree = new ArrayList<>();
        
        for (int i = 0; i < n; i++) tree.add(new ArrayList<>());
        
        // Step 1: Build initial tree based on parent array.
        for (int i = 1; i < n; i++) {
            tree.get(parent[i]).add(i);
        }

        // Step 2: Perform DFS to find the closest matching ancestor and update parent links.
        Map<Character, Integer> lastSeen = new HashMap<>();
        findClosestAncestors(0, -1, s, lastSeen, parent, tree);

        // Step 3: Rebuild tree based on new parent links.
        List<List<Integer>> newTree = new ArrayList<>();
        for (int i = 0; i < n; i++) newTree.add(new ArrayList<>());
        for (int i = 1; i < n; i++) {
            newTree.get(parent[i]).add(i);
        }

        // Step 4: Calculate subtree sizes in the new tree structure.
        calculateSubtreeSizes(0, newTree, answer);

        return answer;
    }

    private void findClosestAncestors(int node, int par, String s, Map<Character, Integer> lastSeen, int[] parent, List<List<Integer>> tree) {
        char ch = s.charAt(node);
        int originalParent = parent[node];

        // Check for closest matching ancestor
        if (lastSeen.containsKey(ch)) {
            parent[node] = lastSeen.get(ch);
        }

        // Update last seen ancestor of this character
        int prevAncestor = lastSeen.getOrDefault(ch, -1);
        lastSeen.put(ch, node);

        // DFS on children
        for (int child : tree.get(node)) {
            if (child == par) continue;  // skip the parent
            findClosestAncestors(child, node, s, lastSeen, parent, tree);
        }

        // Restore last seen to previous state after recursion
        if (prevAncestor == -1) lastSeen.remove(ch);
        else lastSeen.put(ch, prevAncestor);
    }

    private int calculateSubtreeSizes(int node, List<List<Integer>> tree, int[] answer) {
        int size = 1;  // Count itself
        for (int child : tree.get(node)) {
            size += calculateSubtreeSizes(child, tree, answer);
        }
        answer[node] = size;
        return size;
    }
}
",1434269952
Priyanshu Kumar,pribyte1,617,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        // Initialize DP table
        int[][] dp = new int[k + 1][n];

        // Fill the DP table
        for (int i = 0; i < k; i++) {
            for (int curr = 0; curr < n; curr++) {
                // Stay in the current city
                dp[i + 1][curr] = Math.max(dp[i + 1][curr], dp[i][curr] + stayScore[i][curr]);
                
                // Move to a different city
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[i + 1][dest] = Math.max(dp[i + 1][dest], dp[i][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }

        // Get the maximum points possible after k days
        int maxPoints = 0;
        for (int j = 0; j < n; j++) {
            maxPoints = Math.max(maxPoints, dp[k][j]);
        }

        return maxPoints;
    }
}
",1434275301
Priyanshu Kumar,pribyte1,617,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        // Calculate the number of consecutive character groups
        int totalCount = 1;  // Start with one possibility for the original word
        List<Integer> groupLengths = new ArrayList<>();  // Store lengths of each group
        
        for (int i = 0; i < word.length(); ) {
            char currentChar = word.charAt(i);
            int count = 0;
            
            // Count the consecutive occurrences of the current character
            while (i < word.length() && word.charAt(i) == currentChar) {
                count++;
                i++;
            }
            
            // Add the group length to the list
            groupLengths.add(count);
        }
        
        // Start with 1 possibility (keeping all characters unchanged)
        int possibleStrings = 1;
        
        // Calculate total possibilities by shortening each group one by one
        for (int length : groupLengths) {
            if (length > 1) {
                possibleStrings += length - 1;  // Shorten this group from 1 to (length-1)
            }
        }
        
        return possibleStrings;
    }
}
",1434273434
Om Mehrotra,ommehrotra069,618,3576,java,"class Solution {
    int ans[];
    public int[] findSubtreeSizes(int[] parent, String s) {
        List<HashSet<Integer>> adj=new ArrayList<>();
        int n=parent.length;
        ans=new int[n];
        for(int i=0;i<n;i++) adj.add(new HashSet<>());
        for(int i=1;i<n;i++){
            adj.get(parent[i]).add(i);
        }
        rec(adj,new HashMap<Character,Integer>(),0,parent,s);
        size(adj,0);
        return ans;
    }
    int size(List<HashSet<Integer>> adj,int i){
        ans[i]=1;
        for(int neigh:adj.get(i)){
            ans[i]+=size(adj,neigh);
        }
        return ans[i];
    }
    void rec(List<HashSet<Integer>> adj,HashMap<Character,Integer> map,int i,int parent[],String s){
        int anc=-1;
        if(map.containsKey(s.charAt(i)) && map.get(s.charAt(i))!=parent[i]){
            anc = map.get(s.charAt(i));
            map.put(s.charAt(i),i);
            adj.get(parent[i]).remove(i);
            adj.get(anc).add(i);
        }
        else{
            if(map.containsKey(s.charAt(i))) anc = map.get(s.charAt(i));
            map.put(s.charAt(i),i);
        }
        List<Integer> l =new ArrayList<>();
        for(int neigh:adj.get(i)){
            l.add(neigh);
        }
        for(int neigh:l){
            rec(adj,map,neigh,parent,s);
        }
        if(anc!=-1) map.put(s.charAt(i),anc);
        else map.remove(s.charAt(i));
    }
}",1434295361
Om Mehrotra,ommehrotra069,618,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] st, int[][] tr) {
        //k*n and n*n
        int ans=0;
            int dp[][]=new int[n][k];
        for(int i=0;i<n;i++) {
            ans = Math.max(ans,rec(st,tr,i,0,dp));
        }
        return ans;
    }
    int rec(int[][] st,int[][] tr,int c,int d,int[][] dp){
        if(d==st.length) return 0;

        if(dp[c][d]!=0) return dp[c][d];
        int travel=0;
        for(int i=0;i<tr.length;i++){
            if(i!=c)
            travel = Math.max(travel,tr[c][i]+rec(st,tr,i,d+1,dp));
        }
        return dp[c][d] = Math.max(travel,
                st[d][c]+rec(st,tr,c,d+1,dp));
    }
}",1434329333
Om Mehrotra,ommehrotra069,618,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans=0;
        int n=word.length();
        for(int i=1;i<n;i++){
            if(word.charAt(i-1)==word.charAt(i)){
                ans++;
            }
        }
        return ans+1;
    }
}",1434260775
Mohak0709,Mohak0709,619,3576,python,"from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent, s):
        num_nodes = len(parent)
        
        # Step 1: Build the initial tree structure using adjacency list
        initial_tree = defaultdict(list)
        for node in range(1, num_nodes):
            initial_tree[parent[node]].append(node)
        
        # Step 2: Find the closest ancestors and adjust the tree
        closest_char_ancestor = {}
        updated_parent = list(parent)  # Start with the original parent array
        
        def adjust_parents_dfs(current_node):
            current_char = s[current_node]
            
            # If there's a closest ancestor with the same character, update the parent
            if current_char in closest_char_ancestor:
                updated_parent[current_node] = closest_char_ancestor[current_char]
            
            # Save the original closest ancestor
            previous_ancestor = closest_char_ancestor.get(current_char, None)
            
            # Update the closest ancestor for this character
            closest_char_ancestor[current_char] = current_node
            
            # Recursively process children
            for child in initial_tree[current_node]:
                adjust_parents_dfs(child)
            
            # Restore the previous closest ancestor after backtracking
            if previous_ancestor is None:
                del closest_char_ancestor[current_char]
            else:
                closest_char_ancestor[current_char] = previous_ancestor
        
        # Start DFS from the root (node 0)
        adjust_parents_dfs(0)
        
        # Step 3: Build the final tree based on updated_parent
        final_tree = defaultdict(list)
        for node in range(1, num_nodes):
            final_tree[updated_parent[node]].append(node)
        
        # Step 4: Calculate subtree sizes
        def calculate_subtree_size(root_node):
            size = 1  # Count the root node itself
            for child in final_tree[root_node]:
                size += calculate_subtree_size(child)
            subtree_sizes[root_node] = size
            return size
        
        subtree_sizes = [0] * num_nodes
        calculate_subtree_size(0)
        
        return subtree_sizes      ",1434335505
Mohak0709,Mohak0709,619,3587,java,"class Solution {
    private int[][] dp;
    private int[][] stayScore;
    private int[][] travelScore;
    private int n;
    private int k;

    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.n = n;
        this.k = k;
        this.stayScore = stayScore;
        this.travelScore = travelScore;

        dp = new int[k + 1][n];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }

        int result = 0;
        for (int startCity = 0; startCity < n; ++startCity) {
            result = Math.max(result, solve(0, startCity));
        }
        return result;
    }

    private int solve(int day, int curr) {
        if (day == k) {
            return 0;
        }
        if (dp[day][curr] != -1) {
            return dp[day][curr];
        }

        int maxPoints = stayScore[day][curr] + solve(day + 1, curr);

        for (int nextCity = 0; nextCity < n; ++nextCity) {
            if (nextCity != curr) {
                maxPoints = Math.max(maxPoints, travelScore[curr][nextCity] + solve(day + 1, nextCity));
            }
        }

        dp[day][curr] = maxPoints;
        return maxPoints;
    }
}",1434336259
Mohak0709,Mohak0709,619,3617,python,"class Solution:
    def possibleStringCount(self, word):
        length = len(word)
        possible_count = 1  # At least the word itself is one of the possibilities
        
        start = 0
        while start < length:
            end = start
            # Find the length of consecutive repeated characters
            while end < length and word[end] == word[start]:
                end += 1
            
            # Calculate possible original strings if Alice had an extra keypress
            repeat_length = end - start
            if repeat_length > 1:
                possible_count += repeat_length - 1  # Alice could have pressed one key extra
            
            # Move to the next group of characters
            start = end
        
        return possible_count

# Example usage:
sol = Solution()
print(sol.possibleStringCount(""abbcccc""))  # Output: 5
print(sol.possibleStringCount(""abcd""))     # Output: 1
print(sol.possibleStringCount(""aaaa""))     # Output: 4",1434334676
Kamaleswari P,Kamaleswari_P,621,3576,java,"import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;

        // Step 1: Build the adjacency list for the original tree
        Map<Integer, List<Integer>> adj = new HashMap<>();
        for (int i = 1; i < n; i++) {
            adj.computeIfAbsent(parent[i], k -> new ArrayList<>()).add(i);
        }

        // Step 2: Prepare for reparenting process
        int[] newParent = parent.clone();
        Map<Character, Integer> lastSeen = new HashMap<>();

        // Define reparenting function
        reparent(0, s, newParent, adj, lastSeen);

        // Step 3: Build new tree structure based on updated parent relations in newParent
        Map<Integer, List<Integer>> newAdj = new HashMap<>();
        for (int i = 1; i < n; i++) {
            newAdj.computeIfAbsent(newParent[i], k -> new ArrayList<>()).add(i);
        }

        // Step 4: Calculate subtree sizes for each node
        int[] answer = new int[n];
        calculateSubtreeSize(0, newAdj, answer);
        return answer;
    }

    private void reparent(int node, String s, int[] newParent, Map<Integer, List<Integer>> adj, Map<Character, Integer> lastSeen) {
        // Temporarily store the current last seen ancestor for the character of this node
        Character nodeChar = s.charAt(node);
        Integer prevLastSeen = lastSeen.get(nodeChar);

        // If there is a previous ancestor with the same character, set it as the new parent
        if (prevLastSeen != null) {
            newParent[node] = prevLastSeen;
        }

        // Update lastSeen to mark this node as the most recent occurrence of its character
        lastSeen.put(nodeChar, node);

        // Recurse for all children
        if (adj.containsKey(node)) {
            for (int child : adj.get(node)) {
                reparent(child, s, newParent, adj, lastSeen);
            }
        }

        // Restore lastSeen for the character after backtracking to maintain correct ancestor tracking
        if (prevLastSeen != null) {
            lastSeen.put(nodeChar, prevLastSeen);
        } else {
            lastSeen.remove(nodeChar);
        }
    }

    private int calculateSubtreeSize(int node, Map<Integer, List<Integer>> newAdj, int[] answer) {
        int size = 1; // Start with the node itself
        if (newAdj.containsKey(node)) {
            for (int child : newAdj.get(node)) {
                size += calculateSubtreeSize(child, newAdj, answer);
            }
        }
        answer[node] = size;
        return size;
    }
}
",1434274271
Kamaleswari P,Kamaleswari_P,621,3587,python3,"# class Solution:
#     def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
from typing import List

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[0] * n for _ in range(k + 1)]
        
        for day in range(k):
            for curr in range(n):
                # Stay in the same city
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr])
                
                # Travel to a different city
                for dest in range(n):
                    if curr != dest:
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest])
        
        # Find the maximum score on the last day in any city
        maxPoints = max(dp[k])
        
        return maxPoints
       ",1434336319
Kamaleswari P,Kamaleswari_P,621,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        // Initialize the total count of possible original strings to 1 (the original string itself)
        int totalCount = 1;
        int i = 0;

        // Traverse the string
        while (i < word.length()) {
            // Count the length of the current segment of identical characters
            int start = i;
            while (i < word.length() && word.charAt(i) == word.charAt(start)) {
                i++;
            }
            int lengthOfSegment = i - start;

            // For each segment, we can reduce the segment length by any amount down to 1 (if over-typed)
            totalCount += lengthOfSegment - 1; // Adding all possible substrings of this segment
        }

        return totalCount;
    }
}
",1434270692
Vinay Kumar Reddy,vinayreddy3012,622,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        
        tree = defaultdict(set)

        n = len(parent)
        for i in range(1, n):
            tree[parent[i]].add(i)

        vis = set()
        def dfs(root, latest): 
            currColor = s[root]

            if currColor in latest :
                newParent = latest[currColor]
                if newParent != parent[root] :   
                    parent[root] = newParent
                    
            prev = latest.get(currColor, None)
            
            latest[currColor] = root  
            
            for child in tree[root]:
                dfs(child, latest)

            if prev is not None :
                latest[currColor] = prev
            else :
                del latest[currColor]

        latest = defaultdict(list)
        dfs(0, latest)

        ans = [1] * n
        def dfs2(node):
            if len(tree[node]) == 0 :
                return 

            for child in tree[node]:
                dfs2(child)
                ans[node] += ans[child]

        tree.clear()
        for i in range(1, n):
            tree[parent[i]].add(i)
 
        dfs2(0) 
                
        return ans",1434305862
Vinay Kumar Reddy,vinayreddy3012,622,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:


        @cache 
        def maxSum(currDay, currCity): 
            if currDay >= k : 
                return 0 

            if currCity >= n :
                return -1e9
            ans =  0 

            for i in range(n):
                curr = 0 
                if i == currCity :
                    curr = stayScore[currDay][currCity] + maxSum(currDay + 1, currCity)
                else :
                    curr = travelScore[currCity][i] + maxSum(currDay + 1, i)
                ans = max(ans, curr)

            return ans 

        ans = 0 

        for i in range(n):
            ans = max(ans, maxSum(0, i))
            
        return ans
            ",1434329529
Vinay Kumar Reddy,vinayreddy3012,622,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:


        ans = 1 

        prev = """"
        cnt = 0 
        
        for i in range(len(word)):
            if prev == word[i]:
                cnt += 1 
            else :
                ans += max(cnt-1, 0)
                prev = word[i]
                cnt = 1 
        ans += max(cnt-1, 0)

        return ans ",1434266286
Vlad,Vladkruto,625,3576,cpp,"class Solution {
public:
    void dfs_1(int v, int p, vector<vector<int>>& g, const string& s, vector<int>& lst, vector<int>& res) {
        res[v] = 1;
        bool upd = false;
        if(lst[s[v]-'a'] != -1) {
            upd = true;
        }
        int prev = lst[s[v]-'a'];
        lst[s[v]-'a'] = v;

        for(int& u : g[v]) {
            dfs_1(u,v,g,s,lst,res);
        }

        lst[s[v]-'a'] = prev;
        if(upd) {
            res[prev] += res[v];
        } else {
            res[p] += res[v];
        }
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> g(n);
        vector<int> lst(26,-1);
        vector<int> res(n);

        for(int i = 1; i < n; i++) {
            g[parent[i]].push_back(i);
        }

        dfs_1(0,0,g,s,lst,res);
        //for(auto& [v,u] : toadd)
            //g[v].push_back({u,1});
        //dfs_2(0,g,res);
        res[0] = n;

        return res;
    }
};",1434315999
Vlad,Vladkruto,625,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k+1, vector<int>(n));

        for(int kk = 1; kk <= k; kk++) {
            for(int i = 0; i < n; i++) {
                dp[kk][i] = dp[kk-1][i] + stayScore[kk-1][i];
                for(int j = 0; j < n; j++)
                    dp[kk][i] = max(dp[kk][i], dp[kk-1][j] + travelScore[j][i]);
            }
        }

        return *max_element(dp[k].begin(), dp[k].end());
    }
};",1434322787
Vlad,Vladkruto,625,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 1;
        int n = word.size();

        for(int i = 1; i < n; i++) {
            if(word[i]==word[i-1]) {
                res++;                
            }
        }

        return res;
    }
};",1434263450
Shubham teke,shubhamteke,627,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        int[] newParent = parent.clone();  
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            tree.add(new ArrayList<>());
        }


        for (int i = 1; i < n; i++) {
            tree.get(parent[i]).add(i);
        }


        int[] closestAncestor = new int[n];
        Arrays.fill(closestAncestor, -1); 


        Map<Character, Deque<Integer>> charToNodeMap = new HashMap<>();


        dfsFindClosest(0, -1, s, charToNodeMap, closestAncestor, tree);


        for (int i = 1; i < n; i++) {
            if (closestAncestor[i] != -1) {
                newParent[i] = closestAncestor[i]; 
            }
        }


        List<List<Integer>> newTree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            newTree.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            newTree.get(newParent[i]).add(i);
        }


        int[] subtreeSize = new int[n];


        dfsCalculateSubtreeSize(0, newTree, subtreeSize);

        return subtreeSize;
    }


    private void dfsFindClosest(int node, int parent, String s, Map<Character, Deque<Integer>> charToNodeMap, int[] closestAncestor, List<List<Integer>> tree) {
        char currentChar = s.charAt(node);


        charToNodeMap.putIfAbsent(currentChar, new ArrayDeque<>());
        Deque<Integer> stack = charToNodeMap.get(currentChar);

        if (!stack.isEmpty()) {
            closestAncestor[node] = stack.peek();
        }


        stack.push(node);

        for (int child : tree.get(node)) {
            if (child != parent) {
                dfsFindClosest(child, node, s, charToNodeMap, closestAncestor, tree);
            }
        }

        stack.pop();
    }


    private int dfsCalculateSubtreeSize(int node, List<List<Integer>> tree, int[] subtreeSize) {
        int size = 1;  
        for (int child : tree.get(node)) {
            size += dfsCalculateSubtreeSize(child, tree, subtreeSize);
        }
        subtreeSize[node] = size;  
        return size;
    }
}",1434295934
Shubham teke,shubhamteke,627,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k + 1][n]; 


        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {

                dp[day + 1][curr] = Math.max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);


                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[day + 1][dest] = Math.max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }


        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = Math.max(maxPoints, dp[k][city]);
        }

        return maxPoints;
    }
}",1434329685
Shubham teke,shubhamteke,627,3617,java,"class Solution {
    public int possibleStringCount(String word) {
      Set<String> possibleStrings = new HashSet<>();
        possibleStrings.add(word);  

        for (int i = 0; i < word.length(); ) {
            char currentChar = word.charAt(i);
            int start = i;

            
            while (i < word.length() && word.charAt(i) == currentChar) {
                i++;
            }

            int groupLength = i - start;

            
            if (groupLength > 1) {
                for (int j = 1; j < groupLength; j++) {
                    String newString = word.substring(0, start) + repeat(currentChar, j) + word.substring(i);
                    possibleStrings.add(newString);
                }
            }
        }

        return possibleStrings.size();
    }

    
    private String repeat(char ch, int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            sb.append(ch);
        }
        return sb.toString();
    }
}",1434264592
Pravin!!! !,pravinkumar120102,628,3576,java,"class Solution {
    private List<Integer>[] edges, modified;
    public ArrayList<Integer>[] createAdjacencyList(int[] e) {
        int n = e.length;
        ArrayList<Integer>[] edges = new ArrayList[n];
        this.modified = new ArrayList[n];
        for(int i=0; i<n; i++) {
            edges[i] = new ArrayList<>();
            modified[i] = new ArrayList<>();
        }
        
        for(int i=1; i<n; i++) {
            edges[e[i]].add(i);
        }
        
        return edges;
    }
    
    public void dfs(int v, String s, int[] parent) {
        for(int u : edges[v]) {
            char curr = s.charAt(u);

            if(parent[curr-'a'] != -1) {
                modified[parent[curr -'a']].add(u);
            } else {
                modified[v].add(u);
            }
            
            int temp = parent[curr-'a'];
            parent[curr-'a'] = u;
            dfs(u,s, parent);
            parent[curr-'a'] = temp;
        }
        return;
    }
    
    public int sizeOfTree(int v, int[] size) {
        int count = 1;
        
        for(int u : modified[v]) {
            count += sizeOfTree(u, size);
        }
        
        size[v] = count;
        return count;
    } 
    public int[] findSubtreeSizes(int[] e, String s) {
        edges = createAdjacencyList(e);
        
        int[] parent = new int[26];
        Arrays.fill(parent, -1);
        parent[s.charAt(0)-'a'] = 0;
        
        dfs(0, s, parent);
        // for(List<Integer> i : modified) System.out.println(i);
        int[] size = new int[e.length];
        sizeOfTree(0, size);
        return size;
    }
}",1434301850
Pravin!!! !,pravinkumar120102,628,3587,java,"class Solution {
    private Integer[][] dp;
    private int[][] stayScore, travelScore;
    
    public int travel(int n, int k) {
        if(k == stayScore.length) return 0;
        
        if(dp[n][k] != null) return dp[n][k];
        int score = stayScore[k][n] + travel(n, k+1);
        for(int i=0; i<travelScore.length; i++) {
            if(n != i) {
                score = Math.max(score, travelScore[n][i] + travel(i, k+1));
            }
        }
        return dp[n][k] = score;
    }
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.dp = new Integer[n][k];
        this.stayScore = stayScore;
        this.travelScore = travelScore;
        
        int maxScore = 0;
        for(int i=0; i<n; i++) {
            maxScore = Math.max(maxScore, travel(i, 0));
        }
        return maxScore;
    }
}",1434322989
Pravin!!! !,pravinkumar120102,628,3617,java,"class Solution {
    public int possibleStringCount(String s) {
        int[] freq = new int[26];
        
        int ways = 1, count = 1;
        for(int i=0; i<s.length()-1; i++) {
            if(s.charAt(i) == s.charAt(i+1)) {
                count += 1;
            } else {
                ways += count - 1;
                count = 1;
            }
        }
        return ways+count-1;
    }
}",1434266812
Emily,aezara,629,3576,python3,"""""""
for each node, find the closest ancestor with the same char
move the curernt node to be a child of that ancestor

return size of all subtrees

what does ""simultaneously"" have to do with it?
- nothing.
- well, i guess something. if a child was moved because its parent was moved, we should still consider its original location

what's the result, really?
- all nodes with the same char will now be nested at the highest possible level, under the highest
    node with the same char
- unless they are in different branches

so the highest node of that char in a given branch does not move
""""""

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        children = defaultdict(set)
        for i, p in enumerate(parent):
            children[p].add(i)

        # newparent = parent.copy()

        root = parent.index(-1)

        def traverse(cur, seen):
            # print(cur, seen)
            if cur is None:
                return

            if cur != -1:
                if len(seen[s[cur]]):
                    # print(cur, "";"", ""saw"", s[cur], ""setting parent to"", seen[s[cur]])
                    parent[cur] = seen[s[cur]][-1]
                seen[s[cur]].append(cur)

            for child in children[cur]:
                traverse(child, seen)

            # unset it so it doesn't affect other branches
            if cur != -1:
                assert(seen[s[cur]][-1] == cur)
                seen[s[cur]].pop()

        traverse(-1, defaultdict(list))

        # print(""new parents"", parent)
        
        newchildren = defaultdict(set)
        for i, p in enumerate(parent):
            newchildren[p].add(i)
        # print(""new children"", newchildren)

        # find the sizes
        size = [1] * n
        def findsizes(cur):
            if cur is None:
                return 0

            for child in newchildren[cur]:
                res = findsizes(child)
                if cur != -1:
                    size[cur] += res

            return size[cur]

        findsizes(-1)

        return size",1434321376
Emily,aezara,629,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(current_city, day):
            if day == k:
                return 0

            ans = 0
            # try all cities
            for i in range(n):
                points = dp(i, day+1)
                if i == current_city:
                    points += stayScore[day][i]
                else:
                    points += travelScore[current_city][i]
                ans = max(ans, points)

            return ans

        return max([dp(i, 0) for i in range(n)])",1434329875
Emily,aezara,629,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1

        curlen = 1
        i = 1
        prev = word[0]
        while i < len(word):
            if word[i] != prev:
                if curlen > 1:
                    ans += (curlen-1)
                prev = word[i]
                curlen = 1
            else:
                curlen += 1

            i += 1

        if curlen > 1:
            ans += (curlen-1)

        return ans",1434267739
Duc-Minh Phan,ducminh,630,3576,python3,"from collections import defaultdict


class Solution:
    def findSubtreeSizes(self, parents: List[int], s: str) -> List[int]:  
        n = len(parents)
        
        tree = parse_tree(parents)
        new_parents = {}

        def mutate(node, map):
            # map is char -> closest ancestor assigned char
            char = s[node]
            
            if char in map:
                new_parents[node] = map[char]

            d = map.copy()
            d[char] = node
            for child in tree.get(node, []):
                mutate(child, d)

        mutate(0, {})
        
        for node, new_p in new_parents.items():
            parents[node] = new_p

        tree = parse_tree(parents)

        sizes = [0] * n
        def s(node):
            sizes[node] = 1 + sum(s(c) for c in tree.get(node, []))
            return sizes[node]

        s(0)
        return sizes


def parse_tree(parents):
    tree = defaultdict(list)
    for i, p in enumerate(parents):
        if i == 0:
            continue
        tree[p].append(i)

    return dict(tree)
",1434329914
Duc-Minh Phan,ducminh,630,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        for i in range(k):
            new_dp = list(dp)
            for dest in range(n):
                candidates = [dp[curr] + travelScore[curr][dest] for curr in range(n)]
                candidates[dest] = dp[dest] + stayScore[i][dest]
                new_dp[dest] = max(candidates)

            dp = new_dp
        return max(dp)
",1434305450
Duc-Minh Phan,ducminh,630,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        prev = None
        counter = 0
        r = 1
        chars = list(word)
        chars.append(None)
        for c in chars:
            if c != prev:
                r += counter
                counter = 0
            else:
                counter += 1

            prev = c

        return r
",1434269669
rohinth076,rohinth076,631,3576,java,"class Solution {
    private List<Integer>[] construct(int[] parent){
        int n = parent.length;
        List<Integer>[] edges = new List[n];
        for(int i=0;i<n;i++){
            edges[i] = new ArrayList<>();
        }
        for(int i=1;i<n;i++){
            edges[parent[i]].add(i);
        }
        return edges;
    }
    
    private int dfs2(int cur,List<Integer>[] edges,int[] ans){
        int len = 1;
        for(Integer i:edges[cur]){
            len += dfs2(i,edges,ans);
        }
        ans[cur] = len;
        return len;
    }
    private void dfs1(int cur,List<Integer>[] edges,int[] index,String s,int[] parent){
        
        int in = s.charAt(cur) - 'a';
        if(index[in] != -1){
            parent[cur] = index[in];
        }
        int oldVal = index[in];
        index[in] = cur;
        for(Integer i:edges[cur]){
            dfs1(i,edges,index,s,parent);
        }
        index[in] = oldVal;
    }
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        int[] newParent = parent.clone();
        List<Integer>[] edges1 = construct(parent);
        int[] index =new int[26];
        Arrays.fill(index,-1);
        dfs1(0,edges1,index,s,newParent);
        //System.out.println(Arrays.toString(newParent));
        List<Integer>[] edges2 = construct(newParent);
        int[] ans = new int[n];
        dfs2(0,edges2,ans);
        return ans;
    }
}",1434300745
rohinth076,rohinth076,631,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k][n];

        for (int day = 0; day < k; day++) {
            //Syste
            for (int currCity = 0; currCity < n; currCity++) {
                int x = stayScore[day][currCity];
                if(day != 0)x += dp[day - 1][currCity];
                dp[day][currCity] = Math.max(dp[day][currCity],x);
                for (int nextCity = 0; nextCity < n; nextCity++) {
                    if (nextCity != currCity) {
                        int val = travelScore[currCity][nextCity];
                        if(day != 0)val += dp[day - 1][currCity];
                        dp[day][nextCity] = Math.max(dp[day][nextCity], val);
                    }
                }
            }
        }

        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = Math.max(maxPoints, dp[k - 1][city]);
        }

        return maxPoints;
    }
}",1434329920
rohinth076,rohinth076,631,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        int n = word.length();
        for(int i=0;i<n-1;i++){
            if(word.charAt(i) == word.charAt(i+1)){
                ans++;
            }
        }
        return ans;
    }
}",1434260830
enderian_,enderian_,632,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        N = len(s)
        adj = defaultdict(list)
        for i in range(1, N):
            adj[parent[i]].append(i)
            
        new_parent = [-1] * N
        prev = defaultdict(lambda: None)

        def dfs1(node):
            c = s[node]
            prev_ancestor = prev[c]
            prev[c] = node
            for nei in adj[node]:
                dfs1(nei)
            new_parent[node] = parent[node]
            
            new_parent[node] = parent[node]
            if node != 0 and prev_ancestor != None:
                new_parent[node] = prev_ancestor
            prev[c] = prev_ancestor
        
        dfs1(0)

        new_tree = defaultdict(list)
        for i in range(1, N):
            new_tree[new_parent[i]].append(i)

        res = [0] * N

        def dfs2(node):
            size = 1
            for nei in new_tree[node]:
                size += dfs2(nei)
            res[node] = size
            return size

        dfs2(0)

        return res",1434293997
enderian_,enderian_,632,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        dp_prev = None
        
        for i in range(k):
            dp_prev = dp
            dp = [0] * n
            # print(dp_prev)
        
            for j in range(n):
                for k in range(n):
                    if j == k:
                        dp[j] = max(dp[j], dp_prev[j] + stayScore[i][j])
                    else:
                        dp[k] = max(dp[k], dp_prev[j] + travelScore[j][k])
        # print(dp)
        return max(dp)",1434315945
enderian_,enderian_,632,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 0
        for x in range(1, len(word)):
            if word[x] == word[x-1]:
                res += 1
            
        return res + 1",1434262751
nemmy01,nemmy01,633,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }

        vector<int> newParent = parent;
        unordered_map<char, stack<int>> labelStacks;

        function<void(int)> dfsAncestors = [&](int node) {
            char label = s[node];

            if (!labelStacks[label].empty()) {
                newParent[node] = labelStacks[label].top();
            }

            labelStacks[label].push(node);

            for (int child : adj[node]) {
                dfsAncestors(child);
            }

            labelStacks[label].pop();
        };

        dfsAncestors(0);

        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }

        vector<int> answer(n, 0);

        function<int(int)> dfsSubtreeSize = [&](int node) {
            int size = 1;
            for (int child : newAdj[node]) {
                size += dfsSubtreeSize(child);
            }
            answer[node] = size;
            return size;
        };

        dfsSubtreeSize(0);

        return answer;
    }
};",1434294648
nemmy01,nemmy01,633,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> memo(k + 1, vector<int>(n, -1));
        int maxPoints = 0;

        // Try starting from each city
        for (int startCity = 0; startCity < n; ++startCity) {
            maxPoints = max(maxPoints, f(n, k, 0, startCity, stayScore, travelScore, memo));
        }

        return maxPoints;
    }

    int f(int n, int k, int day, int currCity, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& memo) {
        if (day == k) return 0;
        if (memo[day][currCity] != -1) return memo[day][currCity];

        int maxPoints = stayScore[day][currCity] + f(n, k, day + 1, currCity, stayScore, travelScore, memo);
        
        for (int j = 0; j < n; ++j) {
            if (j != currCity) {
                maxPoints = max(maxPoints, travelScore[currCity][j] + f(n, k, day + 1, j, stayScore, travelScore, memo));
            }
        }

        return memo[day][currCity] = maxPoints;
    }
};
",1434323092
nemmy01,nemmy01,633,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        
     int cnt=0;
        int n=word.size();
        for(int i=0;i<n;i++){
          char ch=word[i];
            int times=0,flag=0;
            while(i<n and word[i]==ch){
                i++;times++;flag=1;
            }
            if(flag)i--;
            cnt+=times-1;
        }
        return cnt+1 ;
    }
};",1434277441
Hemant Patil,hemantpatil10125,634,3576,cpp,"class Solution {
public:
    vector<int> adj[100001];
    vector<int> adj1[100001];
    int sizz[100001];
    int prev[100001];
    int v[100001];
    void solve(int node,int par,vector<int> occ)
    {
        int ch = occ[v[node]];
        if(ch != -1 && par != -1 && par != ch)
        {
            prev[node] = ch;
        }
        occ[v[node]] = node;

        for(auto it:adj[node])
        {
            solve(it,node,occ);
        }
        return;
    }

    int solve1(int node)
    {
        int sum = 0;

        for(auto it:adj1[node])
        {
           sum += solve1(it);
        }

        sizz[node] = (sum + 1);
        return sum + 1;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) 
    {
            for(int i=0;i<parent.size();i++)
            {
                if(i > 0)
                adj[parent[i]].push_back(i);

                prev[i] = parent[i];
            }

            for(int i=0;i<s.size();i++)
            v[i] = s[i] - 'a';

             int m = 26;
             vector<int> occ(m);

            for(int i=0;i<26;i++)
            occ[i] = -1;
        
        solve(0,-1,occ);
        
        int n = parent.size();
        vector<int> ans(n,-1);

        for(int i=0;i<n;i++)
        {  
               if(i > 0)
                adj1[prev[i]].push_back(i);
        }
        solve1(0);

        for(int i=0;i<n;i++)
        ans[i] = sizz[i];

        return ans;
    }
};",1434311159
Hemant Patil,hemantpatil10125,634,3587,cpp,"class Solution {
public:
    int K , N;
    int dp[201][201];
    int solve(int in,int curr,vector<vector<int>>& stay,vector<vector<int>>& travel) 
    {
        if(in >= K)
        return 0;
        if(dp[in][curr] != -1)
        return dp[in][curr];
        int op1 = 0,op2 = 0;
        op1 = stay[in][curr] + solve(in + 1,curr,stay,travel);
        for(int i=0;i<N;i++)
        {
            if(i != curr && travel[curr][i] != -1)
            {
                // int temp = travel[curr][i];
                // travel[curr][i] = -1;
                op2 = max(op2 , travel[curr][i] + solve(in + 1,i,stay,travel));
                // travel[curr][i] = temp;
            }
        }

        return dp[in][curr] = max(op1,op2);
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) 
    {
        K = k;
        N = n;

        int mx = 0;
        memset(dp,-1,sizeof(dp));
        for(int i=0;i<N;i++)
        {
            mx = max(mx , solve(0,i,stayScore,travelScore));
        }

        return mx;
    }
};",1434336853
Hemant Patil,hemantpatil10125,634,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) 
    {
        int ans = 1;
        int i = 0;

            while(i < s.size())
            {
                char cur = s[i];
                int cnt = 0;
                   while(i < s.size() && s[i]==cur)
                    {
                        i++;
                        cnt++;
                    }

                if(cnt > 1)
                {
                    ans += (cnt - 1);
                }
            }

        return ans;
    }
};",1434267130
AlexShch,AlexShch,635,3576,python3,"class Node:
    def __init__(self):
        self.val = None
        self.children = set()
        self.parent = None
        self.idx = None

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        storage = {} # idx to node
        storage_2 = {} # node to idx
        
        root = Node()
        root.val = s[0]
        storage[0] = root
        root.idx = 0

        for i in range(1, len(parent)):
            par_number = parent[i]
            cur_number = i
            if cur_number in storage:
                cur_node = storage[cur_number]
            else:
                cur_node = Node()
                cur_node.val = s[cur_number]
                storage[cur_number] = cur_node
                cur_node.idx = cur_number
            if par_number in storage:
                par_node = storage[par_number]
            else:
                par_node = Node()
                par_node.val = s[par_number]
                storage[par_number] = par_node
                par_node.idx = par_number
            par_node.children.add(cur_node)
            cur_node.parent = par_node
                
   
        new_pairs = [] # (node, closest_ancestor_with_same_val)

        

        def dfs(node, closest_ancestor_with_same_val):
            if node.val in closest_ancestor_with_same_val:
                new_pairs.append((node, closest_ancestor_with_same_val[node.val]))
            for child in node.children:
                new_closest_ancestor_with_same_val = closest_ancestor_with_same_val.copy()
                new_closest_ancestor_with_same_val[node.val] = node
                dfs(child, new_closest_ancestor_with_same_val)

        dfs(root, {})
        q = collections.deque([root])
        
        for node, new_parent in new_pairs:
            old_parent = node.parent
            old_parent.children.remove(node)
            node.parent = new_parent
            new_parent.children.add(node)

        res = [None] * len(s)

        def get_result(node):
            cur_res = 1
            for child in node.children:
                cur_res += get_result(child)
            res[node.idx] = cur_res
            return cur_res
        
        get_result(root)
        return res
",1434324981
AlexShch,AlexShch,635,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        
        
        storage = [[None] * k for _ in range(n)]

        def get_res(cur_city_idx, cur_day_idx):
            if cur_day_idx == k:
                return 0
            if storage[cur_city_idx][cur_day_idx] is not None:
                return storage[cur_city_idx][cur_day_idx]

            cur_res = 0
            # stay
            cur_res = max(cur_res, stayScore[cur_day_idx][cur_city_idx] + get_res(cur_city_idx, cur_day_idx + 1))
            # travel
            for next_city_idx in range(n):
                if next_city_idx == cur_city_idx:
                    continue
                cur_res = max(cur_res, travelScore[cur_city_idx][next_city_idx] + get_res(next_city_idx, cur_day_idx + 1))
            storage[cur_city_idx][cur_day_idx] = cur_res
            return cur_res
        
        max_res = 0
        for start_city_idx in range(n):
            max_res = max(max_res, get_res(start_city_idx, 0))
        return max_res
        
        ",1434336884
AlexShch,AlexShch,635,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 1
        cur_amount = 1
        cur_letter = word[0]
        for el in word[1:]:
            if el == cur_letter:
                cur_amount += 1
            else:
                res += cur_amount - 1
                cur_amount = 1
                cur_letter = el
        res += cur_amount - 1
        return res",1434261901
AndyLead,AndyLead,636,3576,cpp,"class Solution {
    int n;
    vector<vector<int>> children, new_children;
    vector<int> result;
    vector<int> new_parents;
    map<char, int> seen;
    string s;

    void checkChildren(int node = 0) {
        if(seen.contains(s[node])) {
            new_parents[node] = seen[s[node]];
            int prev = seen[s[node]];
            seen[s[node]] = node;
            for(int child : children[node]) checkChildren(child);
            seen[s[node]] = prev;
        } else {
            seen[s[node]] = node;
            for(int child : children[node]) checkChildren(child);
            seen.erase(s[node]);
        }
    }

    int fillResult(int node = 0) {
        int size = 1;
        for(int child : new_children[node]) size += fillResult(child);
        return result[node] = size;
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = s.size();
        this->s = s;
        children.resize(n);
        new_children.resize(n);
        result.resize(n);
        new_parents = parent;
        
        for(int i = 1; i < n; i++) children[parent[i]].push_back(i);
        checkChildren();
        for(int i = 1; i < n; i++) new_children[new_parents[i]].push_back(i);
        fillResult();
        return result;
    }
};",1434308562
AndyLead,AndyLead,636,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> dp(n);
        for(int day = 0; day < k; day++) {
            vector<int> next(n);
            
            for(int city = 0; city < n; city++) next[city] = dp[city] + stayScore[day][city];
            for(int from = 0; from < n; from++) 
                for(int city = 0; city < n; city++)
                    if(from != city) next[city] = max(next[city], dp[from] + travelScore[from][city]);
            swap(next, dp);
        }

        return *max_element(dp.begin(), dp.end());
    }
};",1434330178
AndyLead,AndyLead,636,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int result = 1;
        int count = 1;
        for(int i = 1; i < word.size(); i++) {
            if(word[i] == word[i-1]) count++;
            else {
                result += count - 1; 
                count = 1;
            }
        }
        result += count - 1; 
        return result;
    }
};",1434262919
Shreyas Sanjay Patil,UpsilonY,637,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] par, String s) {
        int n = par.length;
        int[] ans = new int[n];
        ArrayList<Integer>[] G = new ArrayList[n];
        for(int i = 0; i < n; i++) G[i] = new ArrayList();
        for(int i = 1; i < par.length; i++){
            G[par[i]].add(i);
        }
        // Arrays.fill(ans, 1);
        solve(0, G, s, new HashMap(), ans, -1, par);
        for(int i = 0; i < n; i++) G[i] = new ArrayList();
        for(int i = 1; i < par.length; i++){
            G[par[i]].add(i);
        }
        rec(0, G, ans);
        return ans;
    }
    
    public void solve(int i, ArrayList<Integer>[] G, String s, HashMap<Character, Integer> M, int[] ans, int par, int[]parr){
        // System.out.println(M);
        char c = s.charAt(i);
        int ov = M.getOrDefault(c, -1);
        if(ov != -1){
            parr[i] = ov;
        }
        M.put(c, i);
        for(int nbr : G[i]){
            solve(nbr, G, s, M, ans, i, parr);
        }
        M.put(c, ov);
    }
    public int rec(int i, ArrayList<Integer>[] G, int[] ans){
        for(int nbr : G[i]){
            ans[i] += rec(nbr, G, ans);
        }
        return ++ans[i];
    }
}",1434325270
Shreyas Sanjay Patil,UpsilonY,637,3587,java,"class Solution {
    int[][] dp;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        dp = new int[k][n];
        int ans = 0;
        for(int i = 0; i < n; i++){
            ans = Math.max(ans, solve(0, i, stayScore, travelScore, k, n));
        }
        return ans;
    }
    
    public int solve(int day, int city, int[][] stayScore, int[][] travelScore, int k, int n){
        if(day == k) return 0;
        int ans = 0;
        if(dp[day][city] != 0) return dp[day][city];
        
        ans = Math.max(ans, stayScore[day][city] + solve(day + 1, city, stayScore, travelScore, k, n));
        for(int i = 0; i < n; i++){
            if(i != city){
                ans = Math.max(ans, travelScore[city][i] + solve(day + 1, i, stayScore, travelScore, k, n));
            }
        }
        dp[day][city] = ans;
        return ans;
    }
}",1434325066
Shreyas Sanjay Patil,UpsilonY,637,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int n = word.length();
        char[] s = word.toCharArray();
        char prev = '$';
        int ans = 0;
        int count = 0;
        for(int i = 0; i < n; i++){
            if(prev != s[i]){
                ans += Math.max(0, count - 1);
                count = 1;
            }
            else count++;
            prev = s[i];
            
        }
        ans += Math.max(0, count - 1);
        return ans + 1;
    }
}",1434330350
Piyush Kumar,piyushk1264,638,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        graph = defaultdict(set)

        for i, p in enumerate(parent):
            graph[p].add(i)
        
        res = [0]*n
        lookup = {}

        def get_tree_size(root):
            nonlocal res
            
            children = 0
            for nei in graph[root]:
                children += get_tree_size(nei)
            
            res[root] = children + 1
            return res[root]
        
        def solve(i, parent):
            nonlocal res, lookup

            if s[i] in lookup and parent is not None:
                nearest = lookup[s[i]]
                graph[parent].remove(i)
                graph[nearest].add(i)

            old = lookup.get(s[i], None)
            lookup[s[i]] = i

            children = graph[i].copy()
            for nei in children:
                solve(nei, i)

            if old is not None:
                lookup[s[i]] = old
            else:
                del lookup[s[i]]

        solve(0, None)
        get_tree_size(0)
        return res",1434327210
Piyush Kumar,piyushk1264,638,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @lru_cache(None)
        def solve(day, city):
            if day >= k:
                return 0

            # Stay
            stay = solve(day+1, city) + stayScore[day][city]

            # Move
            move_max = float('-inf')
            for dest in range(n):
                if dest == city: continue
                move = solve(day+1, dest) + travelScore[city][dest]
                move_max = max(move_max, move)

            return max(stay, move_max)

        ans = 0
        for city in range(n):
            ans = max(ans, solve(0, city))
        return ans",1434337156
Piyush Kumar,piyushk1264,638,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        counts = []
        chars = []
        for i, c in enumerate(word):
            if chars and chars[-1] == c:
                counts[-1] += 1
            else:
                counts.append(1)
                chars.append(c)

        res = set()
        def solve(i, curr, used):
            nonlocal res
            if i >= len(counts):
                res.add("""".join(curr))
                return

            for j in range(1, counts[i] + 1):
                curr.append(chars[i])
                if not used:
                    solve(i+1, curr, True)

            solve(i+1, curr, used)

            for j in range(1, counts[i]+1):
                curr.pop()

        solve(0, [], False)
        return len(res)",1434292616
yashie,yashwanthvs,639,3576,python3,"from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        n = len(s)
        tree = defaultdict(set)
        new_tree = defaultdict(set)

        for node in range(n):
            tree[parent[node]].add(node)
            new_tree[parent[node]].add(node)

        def dfs(node, seen):

            if s[node] in seen:
                new_parent = seen[s[node]][-1]
                new_tree[parent[node]].discard(node)
                new_tree[new_parent].add(node)

            seen[s[node]].append(node)
            for child in tree[node]:
                dfs(child, seen)
            seen[s[node]].pop()
            if not seen[s[node]]:
                del seen[s[node]]

        dfs(0, defaultdict(list))

        out = [0] * n
        def sizes(node):
            if node not in new_tree or not new_tree[node]:
                out[node] = 1
                return 1

            size = 1
            for child in new_tree[node]:
                size += sizes(child)

            out[node] = size
            return size

        sizes(0)
        return out",1434307066
yashie,yashwanthvs,639,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:


        memo = {}

        def topdown(city, day):

            if day < 0:
                return 0

            if (city, day) in memo:
                return memo[(city, day)]

            stay = stayScore[day][city] + topdown(city, day - 1)
            move = 0
            for c in range(n):
                move =  max(move, travelScore[c][city] + topdown(c, day - 1))

            memo[(city, day)] = max(stay, move)
            return memo[(city, day)]

        out = 0
        for c in range(n):
            out = max(out, topdown(c, k - 1))
            
        return out",1434330391
yashie,yashwanthvs,639,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:

        stack = []
        out = 1
        
        for ch in word:
            if not stack or stack[-1] != ch:
                stack.append(ch)
            else:
                out += 1

        return out",1434265858
Ashish Kumar,ashigup,640,3576,cpp,"class Solution {
public:
    vector<vector<int>> makeAdj(vector<int> &par){
        int n = par.size();
        vector<vector<int>> adj(n);
        
        for(int i=1;i<n;i++){
            adj[par[i]].push_back(i);
        }
        return adj;
    }
    
    void dfs(int node,string &s, vector<int> &par,vector<vector<int>> &adj,vector<vector<int>> &chartoNode){
        
        if(!chartoNode[s[node] - 'a'].empty()){
            par[node] = chartoNode[s[node] - 'a'].back();
        }
        chartoNode[s[node] - 'a'].push_back(node);
        
        for(auto child:adj[node]){
             dfs(child,s,par,adj,chartoNode);
        }
        chartoNode[s[node] - 'a'].pop_back();
    }
    
    int countSubtree(int node,vector<int> &ans,vector<vector<int>> &adj){
        int c = 1;
        
        for(auto child:adj[node]){
             c+= countSubtree(child,ans,adj);
        }
        ans[node] = c;
        return c;
    }
    
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        vector<vector<int>> adj = makeAdj(par);
        vector<vector<int>> charToNode(26);
        
        dfs(0,s,par,adj,charToNode);
        
        adj = makeAdj(par);
        
        vector<int> ans(s.size());
        countSubtree(0,ans,adj);
        return ans;
    }
};",1434319271
Ashish Kumar,ashigup,640,3587,cpp,"class Solution {
public:
    #define ll long long
    ll dp[201][201];
    
    ll dfs(int day,int city,int n,int k,vector<vector<int>>& stayScore, vector<vector<int>>& travelScore){
        if(day == k) return 0;
        
        if(dp[day][city] != -1) return dp[day][city];
        
        ll ans = dfs(day+1,city,n,k,stayScore,travelScore) + stayScore[day][city];
        
        for(int i=0;i<n;i++){
            ans = max(ans, dfs(day+1,i,n,k,stayScore,travelScore) + travelScore[city][i] );
        }
        return  dp[day][city] = ans;
        
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        
        ll ans = 0;
        memset(dp,-1,sizeof(dp));
        
        for(int i=0;i<n;i++){
            ans = max(ans, dfs(0,i,n,k,stayScore,travelScore));
        }
        return ans;
    }
};",1434337231
Ashish Kumar,ashigup,640,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 0;
        
        int c = 1;
        for(int i=1;i<word.size();i++){
            if(word[i] == word[i-1]){
                c++;
            }
            else{
               
              ans+=(c-1);
                c=1;
            }
        }
        ans+=c;
     
        return ans;
    }
};",1434289776
F007NewFlat,F007NewFlat,641,3576,cpp,"class Solution {
public:
    vector<int>adj[100001];
    vector<int>newadj[100001];
    void find(int node , vector<int>adj[] , string &s , vector<int>&updatedparent , vector<int>h)
    {
        if(h[s[node] - 'a'] != -1)
              updatedparent[node] = h[s[node] - 'a'];

         h[s[node] - 'a'] = node;
        for(int i=0 ;i<adj[node].size() ;i++)
            {
                int child = adj[node][i];
                find(child , adj ,s , updatedparent , h);
            }
    }

    int findsize(int node , vector<int>adj[] , vector<int>&size)
    {
        int cnt = 0;
        for(int i= 0 ;i<adj[node].size() ;i++)
            {
                int child = adj[node][i];
                cnt += findsize(child , adj , size);
            }
        
        size[node] = (cnt+1);
        return size[node];
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int>h(26 , -1);
        for(int i = 0 ; i<parent.size() ; i++)
          {
               if(parent[i] != -1) 
                adj[parent[i]].push_back(i);
          }
       
        vector<int>updatedparent = parent;
        find(0 , adj ,s , updatedparent , h);

        // for(int i = 0 ;i<parent.size();i++)
        //     {
        //         cout<<i<<"" ""<<updatedparent[i]<<endl;
        //     }
        vector<int>size(parent.size() , 0);

        for(int i = 0 ;i<updatedparent.size() ;i++)
        {
            if(updatedparent[i] != -1)
                  newadj[updatedparent[i]].push_back(i);
        }
        
        findsize( 0 , newadj , size);
        return size;
    }
};",1434310786
F007NewFlat,F007NewFlat,641,3587,cpp,"class Solution {
public:

 int find(vector<vector<int>>&dp , int city , int days , vector<vector<int>>&stay , vector<vector<int>>&travel ,int k)
 {
     if(days == 0)
           return 0;
     else if(dp[city][days] != -1)
          return dp[city][days];

     int curday = k-days;
     int s = stay[curday][city] + find(dp ,city , days-1 , stay , travel , k);

     int t = INT_MIN;
     for(int i=0 ; i<travel.size() ;i++)
     {
         if(i != city) 
           t = max(t , travel[city][i]+find(dp, i ,days-1,stay , travel , k));
     }

     return dp[city][days] = max(s , t);
 }

    int maxScore(int n, int k, vector<vector<int>>& stay, vector<vector<int>>& travel) {
        vector<vector<int>>dp(n , vector<int>(k+1 , -1));
        int imax = INT_MIN;
        for(int i = 0 ; i<travel.size() ;i++)
        {
                imax = max(imax , find(dp , i , k , stay , travel , k));
        }

        return imax;
    }
};",1434330522
F007NewFlat,F007NewFlat,641,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
      char ch = word[0];
      int cnt = 1;

      int sum = 0;
      for(int i=1 ; i<word.size() ;i++)
          {
              if(word[i] == ch)
                    cnt++;
              else
              {
                  sum +=cnt-1;
                  ch = word[i];
                  cnt = 1;
              }
          }

        return sum + (cnt-1)+1;
    }
};",1434266544
Hell,Vinayak_Gupta_20,642,3576,java,"class Solution {
    int[] ch;
    int[] ans;
    public int[] findSubtreeSizes(int[] par, String s) {
        int n = par.length;
        ch = new int[n];
        ans = new int[n];
        List<Integer>[] tree = new ArrayList[n];
        List<Integer>[] newTree = new ArrayList[n];
        for(int i=0;i<n;i++){
            tree[i] = new ArrayList<>();
            newTree[i] = new ArrayList<>();
        }
        for(int i=0;i<n;i++){
            if(par[i]!=-1) tree[par[i]].add(i);
        }
        int[] a = new int[26];
        Arrays.fill(a,-1);
        dfs(tree,s,a,0);
        return ans;
    }

    public int dfs(List<Integer>[] tree, String s, int[] a, int node){

        int c = 0;
        int cnt = 0;

        int prev = a[s.charAt(node)-'a'];
        a[s.charAt(node)-'a'] = node;

        for(int i=0;i<tree[node].size();i++){
            int x = tree[node].get(i);
            c += dfs(tree,s,a,x);
        }
        
        ans[node] = c + ch[node] + 1;
        a[s.charAt(node)-'a'] = prev;

        if(prev!=-1){
            ch[prev] += c + 1 + ch[node];
            return 0;
        }
        else return c+1+ch[node];
    }
}",1434319442
Hell,Vinayak_Gupta_20,642,3587,java,"class Solution {
    int[][] dp;
    public int maxScore(int n, int k, int[][] ss, int[][] ts) {
        int ans = 0;
        dp = new int[k+1][n+1];
        for(int[]d:dp) Arrays.fill(d,-1);
        for(int i=0;i<n;i++){
            ans = Math.max(ans, helper(n,k,0,i,ss,ts));
        }
        return ans;
    }

    public int helper(int n, int k, int day, int city, int[][] ss, int[][] ts){
        if(day==k) return 0;
        if(dp[day][city]!=-1) return dp[day][city];

        int ans = ss[day][city] + helper(n,k,day+1,city,ss,ts);

        for(int i=0;i<n;i++){
            if(i==city) continue;
            ans = Math.max(ans, ts[city][i] + helper(n,k,day+1,i,ss,ts));
        }

        return dp[day][city] = ans;
    }
}",1434330583
Hell,Vinayak_Gupta_20,642,3617,java,"class Solution {
    public int possibleStringCount(String s) {
        int n = s.length();
        int ans = 0;
        for(int i=1;i<n;i++){
            if(s.charAt(i)==s.charAt(i-1)) ans++;
        }
        return ans+1;
    }
}",1434260965
shristi267,shristi267,643,3576,python3,"from typing import List
from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        tree = defaultdict(list)  # Adjacency list for the original tree structure
        new_tree = defaultdict(list)  # New tree structure after re-parenting
        subtree_size = [0] * n  # Result array for subtree sizes
        
        # Build the original tree structure
        for i in range(1, n):
            tree[parent[i]].append(i)

        # To track the closest ancestors for each character
        char_stack = defaultdict(list)

        def dfs_reparent(node: int):
            # Reparenting logic based on closest ancestor with matching character
            if char_stack[s[node]]:
                new_parent = char_stack[s[node]][-1]
                new_tree[new_parent].append(node)  # Update new tree structure
            else:
                if parent[node] != -1:
                    new_tree[parent[node]].append(node)  # Keep the original parent if no match
            
            # Push the current node onto the stack for its character
            char_stack[s[node]].append(node)
            
            # Process all children in the original tree
            for child in tree[node]:
                dfs_reparent(child)
            
            # Pop from stack after processing this node's subtree
            char_stack[s[node]].pop()

        # Start DFS from the root (node 0) to build the new tree
        dfs_reparent(0)

        def dfs_subtree_size(node: int) -> int:
            size = 1  # Start with the current node itself
            for child in new_tree[node]:
                size += dfs_subtree_size(child)
            subtree_size[node] = size
            return size

        # Calculate subtree sizes starting from the root
        dfs_subtree_size(0)

        return subtree_size
",1434323885
shristi267,shristi267,643,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Initialize the DP table
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        // Fill the DP table for each day
        for (int day = 0; day < k; ++day) {
            for (int curr = 0; curr < n; ++curr) {
                // Earn points by staying in the current city
                dp[day + 1][curr] = dp[day][curr] + stayScore[day][curr];
                
                // Earn points by moving to another city
                for (int dest = 0; dest < n; ++dest) {
                    if (dest != curr) {
                        dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][dest] + travelScore[dest][curr]);
                    }
                }
            }
        }

        // The maximum points after k days
        return *max_element(dp[k].begin(), dp[k].end());
    }
};",1434290223
shristi267,shristi267,643,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        vector<int> runs;
        int count = 1;

        // Step 1: Identify lengths of consecutive character runs
        for (int i = 1; i < word.size(); i++) {
            if (word[i] == word[i - 1]) {
                count++;
            } else {
                runs.push_back(count);
                count = 1;
            }
        }
        runs.push_back(count); // Don't forget the last run

        // Step 2: Calculate the total number of possible original strings
        int totalPossibilities = 1; // Start with the original word as one possibility
        for (int len : runs) {
            if (len > 1) {
                totalPossibilities += len - 1; // Only add the number of ways to reduce this run
            }
        }
        
        return totalPossibilities;
    }
};
",1434263970
Jaeha Yi,jaehayi1,644,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(s)
        
        child = [[] for _ in range(n)]
        for i in range(1, n): 
            child[parent[i]].append(i)
        
        def dfs(u, last): 
            nonlocal parent
            
            # print(u, last)
            
            val = ord(s[u]) - ord('a')
            
            new_par = last[val]
            last[val] = u
            
            for v in child[u]: 
                dfs(v, last)
            
            last[val] = new_par
            
            if new_par != -1: 
                parent[u] = new_par
            
            
        dfs(0, [-1] * 26)
        
        
        child = [[] for _ in range(n)]
        for i in range(1, n): 
            child[parent[i]].append(i)
        
        
        sz = [1] * n
        
        def dfs2(u): 
            for v in child[u]: 
                dfs2(v)
                sz[u] += sz[v]
                
        dfs2(0)
        
        return sz",1434307520
Jaeha Yi,jaehayi1,644,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        '''
        (n * n - 1) // 2 edges
        
        BFS k times
        
        (40000) * 200
        '''
        
        maxScore = [0] * n
        prevMax = [0] * n
        
        # print(""====================="")
        
        for i in range(k): 
            for u in range(n): 
                for v in range(n): 
                    if u == v: 
                        maxScore[v] = max(maxScore[v], prevMax[u] + stayScore[i][u])
                    else: 
                        maxScore[v] = max(maxScore[v], prevMax[u] + travelScore[u][v])
            
            prevMax = maxScore
            # print(maxScore)
            maxScore = [0] * n
        
        res = 0
        for u in range(n): 
            res = max(res, prevMax[u])
        
        return res
        
            
        
        
        
        ",1434330701
Jaeha Yi,jaehayi1,644,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        '''
        abbccccdd
        
        -> 2 + 4 + 2
            - 1 (bbcccc)
            - 1 (bbccccdd)
        
        '''
        n = len(word)
        res = 0
        for i in range(1, n): 
            if word[i - 1] == word[i]: 
                res += 1
        
        return res + 1
                ",1434276002
Dk95_letsgo,Dk95_letsgo,645,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        
        c = defaultdict(list)
        
        for i,v in enumerate(parent):
            c[v].append(i)
        
        d = defaultdict(list)
        
        p = defaultdict(list)
        
        def dfs0(node):
            if p[s[node]]:
                d[p[s[node]][-1]].append(node)
            else:
                d[parent[node]].append(node)
            p[s[node]].append(node)
            for each in c[node]:
                dfs0(each)
            p[s[node]].pop()
            
        
        dfs0(0)
        
        ans = [0] * len(parent)
        
        def dfs(node):
            nonlocal ans
         
            s = 1

            for each in d[node]:
                s += dfs(each)
            ans[node] = s
            return s
    
        dfs(0)
        
        return ans
        
        ",1434319224
Dk95_letsgo,Dk95_letsgo,645,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, ss: List[List[int]], ts: List[List[int]]) -> int:
        
        
        
        d = [[0] * n for _ in range(k)]
        
        for i in range(n):
            d[0][i] = ss[0][i]
            for each in range(n):
                d[0][i] = max(d[0][i], ts[each][i])
        
        for i in range(1,k):
            v = d[::]
            
            for x in range(n):
                d[i][x] = d[i-1][x] + ss[i][x]
                for y in range(n):
                    d[i][x] = max(d[i][x], v[i-1][y] + ts[y][x])
    
            
            
            
        
        
        
        
        return max(d[-1])",1434337504
Dk95_letsgo,Dk95_letsgo,645,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        
        
        ans = set([word])
        
        
        l = 0
        
        p = word[0]
        
        
        for i, v in enumerate(word[1:],start=1):
            if v == p:
                ans.add(word[:l+1] + word[i+1:])
            else:
                l = i
            
            p = v
        
        return len(ans)
        
        
        
        
        
        ",1434284784
RegexRover,RegexRover,646,3576,cpp,"class Solution {
public:
    
    void dfs(int node,int p,string &s,vector<vector<int>> &adj,vector<vector<int>> &a,vector<int> &mp)
    {
        int par = mp[s[node] - 'a'] == -1 ? p : mp[s[node] - 'a'];
        if(par != -1)
        {
            a[par].push_back(node);
        }
        auto prev = mp[s[node] - 'a'];
        mp[s[node] - 'a'] = node;
        for(auto x : adj[node])
        {
            dfs(x,node,s,adj,a,mp);
        }
        mp[s[node] - 'a'] = prev;
    }
    int calc(int node,vector<vector<int>> &a,vector <int> &ans)
    {
        ans[node] = 1;
        for(auto x : a[node])
        {
            ans[node] += calc(x,a,ans);
        }
        return ans[node];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) 
    {
        int n = s.size(),i;
        vector <int> mp(26,-1);
        vector<vector<int>> adj(n),a(n);
        for(i=1;i<n;i++)
        {
            adj[parent[i]].push_back(i);
        }
        dfs(0,-1,s,adj,a,mp);
    
        vector <int> ans(n);
        calc(0,a,ans);
        return ans;
    }
};",1434310544
RegexRover,RegexRover,646,3587,cpp,"class Solution {
public:
    int dp[201][202];
    int calc(int idx,int city,int k,int n,vector<vector<int>>& s, vector<vector<int>>& t)
    {
        int ans = 0,i;
        if(idx == k)
        {
            return 0;
        }
        if(dp[idx][city] != -1)
        {
            return dp[idx][city];
        }
        ans = max(ans,s[idx][city] + calc(idx+1,city,k,n,s,t));
        for(i=0;i<n;i++)
        {
            if(i != city)
            {
                ans = max(ans,t[city][i] + calc(idx+1,i,k,n,s,t));
            }
        }
        return dp[idx][city] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& s, vector<vector<int>>& t) 
    {
        int i,ans = 0;
        memset(dp,-1,sizeof(dp));
        for(i=0;i<n;i++)
        {
            ans = max(ans,calc(0,i,k,n,s,t));
        }
        return ans;
    }
};",1434330882
RegexRover,RegexRover,646,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) 
    {
        int n = s.size(),i,j,cnt,ans;
        i = 0;
        ans = 1;
        while(i < n)
        {
            j = i;
            while(j < n && s[i] == s[j])
            {
                j++;
            }
            cnt = j - i - 1;
            ans += cnt;
            i = j;
        }
        return ans;
    }
};",1434264993
Ashutosh Kumar,Ashutoshkrh,647,3576,cpp,"class Solution {
    void dfs(int node, int par, map<char, int>& mp, vector<int>& parent, string& s, vector<int> adj[]) {
        int original_parent = parent[node];
        if (mp[s[node]] != -1) {
            parent[node] = mp[s[node]];
        }
        int prev_value = mp[s[node]];
        mp[s[node]] = node;

        for (auto it : adj[node]) {
            if (it != par) {
                dfs(it, node, mp, parent, s, adj);
            }
        }
        
        mp[s[node]] = prev_value; // Reset to previous value after backtracking
    }

    int calculateSubtreeSizes(int node, vector<int> adj[], vector<int>& subtreeSizes) {
        int size = 1;
        for (int child : adj[node]) {
            size += calculateSubtreeSizes(child, adj, subtreeSizes);
        }
        subtreeSizes[node] = size;
        return size;
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> adj[n];
        for (int i = 1; i < n; i++) {
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        
        map<char, int> mp;
        for (char c = 'a'; c <= 'z'; c++) mp[c] = -1;
        
        dfs(0, -1, mp, parent, s, adj);

        vector<vector<int>> newTree(n);
        for (int i = 1; i < n; i++) {
            newTree[parent[i]].push_back(i);
        }

        vector<int> subtreeSizes(n, 0);
        calculateSubtreeSizes(0, newTree.data(), subtreeSizes);
        
        return subtreeSizes;
    }
};",1434305022
Ashutosh Kumar,Ashutoshkrh,647,3587,cpp,"class Solution {
public:
    int solve(int curr, int day, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& dp) {
        if (day >= k) return 0;
        if (dp[curr][day] != -1) return dp[curr][day];

        int maxPoints = 0;
        
        if (day < stayScore.size() && curr < stayScore[day].size()) {
            maxPoints = stayScore[day][curr] + solve(curr, day + 1, k, stayScore, travelScore, dp);
        }

        for (int nextCity = 0; nextCity < travelScore.size(); nextCity++) {
            if (curr < travelScore.size() && nextCity < travelScore[curr].size()) {
                maxPoints = max(maxPoints, travelScore[curr][nextCity] + solve(nextCity, day + 1, k, stayScore, travelScore, dp));
            }
        }
        
        return dp[curr][day] = maxPoints;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(n, vector<int>(k, -1));
        int maxScore = 0;
        
        for (int startCity = 0; startCity < n; startCity++) {
            maxScore = max(maxScore, solve(startCity, 0, k, stayScore, travelScore, dp));
        }
        
        return maxScore;
    }
};
",1434330936
Ashutosh Kumar,Ashutoshkrh,647,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int cnt = 0;
        int prev = '1';
        for(auto it : word){
            if(it==prev)cnt++;
            prev = it;
        }
        return 1+cnt;
    }
};",1434265057
Sahil,sa_hilll94,648,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); 
        vector<int> answer(n, 1);   
        for (int i = 1; i < n; ++i) adj[parent[i]].push_back(i);
        vector<int> newParent = parent; 
        unordered_map<char, vector<int>> lastSeen; 
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];
            if (!lastSeen[c].empty()) newParent[node] = lastSeen[c].back();
            lastSeen[c].push_back(node);
            for (int child : adj[node]) reassignParents(child);
            lastSeen[c].pop_back();
        };
        reassignParents(0); 
        vector<vector<int>> newAdj(n); 
        for (int i = 1; i < n; ++i) newAdj[newParent[i]].push_back(i);
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1; 
            for (int child : newAdj[node]) size += computeSubtreeSizes(child);
            answer[node] = size;
            return size;
        };
        computeSubtreeSizes(0); 
        return answer;
    }
};
",1434336306
Sahil,sa_hilll94,648,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) { 
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }
        return maxPoints;
    }
};",1434337827
Sahil,sa_hilll94,648,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count = 1;

        int size = word.size();

        for(int i=0;i<size;){
            int j=i;

            while(j<size && word[j]==word[i]){
                j++;
            }

            int len = j-i;

            if(len>1){
                count += len-1;
            }

            i=j;
        }

        return count;
    }
};",1434304246
Road2Guardian,Road2Guardian,649,3576,python3,"class TreeNode:
    def __init__(self,val,up=None):
        self.val = val
        self.up = up
        self.children = set()
    
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        father = defaultdict(list)
        # root = TreeNode(0,None,None)
        node_val = {}
        for i in range(len(parent)):
            node_val[i] = TreeNode(i)
            
        for value, up in enumerate(parent):
            node = node_val[value]
            if up!=-1:
                node.up = node_val[up]
                node.up.children.add(value)
        node_val_copy = {}
        for i in range(len(parent)):
            node_val_copy[i] = TreeNode(i)
        
        def dfs(node,father):
            c = s[node.val] 
            if c in father and father[c]:
                new_up = father[c][-1]
                # up = node.up
                
                # up.children.remove(node.val)
                # node.up = father[c]
                # node.up.children.add(node.val)
            else:
                new_up = node.up
            if new_up:
                up_copy = node_val_copy[new_up.val]
                up_copy.children.add(node.val)
            father[c].append(node)
            for child in node.children:
                dfs(node_val[child],father)
            father[c].pop()
            return
        ans = [0]*len(parent)
        def dfs_ans(node):
            ans[node.val] = 1
            for child in node.children:
                ans[node.val]+=dfs_ans(node_val_copy[child])
            return ans[node.val]
        dfs(node_val[0],father)
        dfs_ans(node_val_copy[0])
        return ans
        ",1434320438
Road2Guardian,Road2Guardian,649,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(k_done,curr):
            if k_done==k:
                return 0
            ans = stayScore[k_done][curr] + dp(k_done+1,curr)
            for i in range(n):
                if i!=curr:
                    ans = max(ans,travelScore[curr][i]+dp(k_done+1,i))
            return ans
        ans = 0
        for i in range(n):
            ans = max(ans,dp(0,i))
        return ans",1434337828
Road2Guardian,Road2Guardian,649,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        last = word[0]
        count=1
        for c in word[1:]:
            if c==last:
                count+=1
            else:
                ans+=count-1
                count = 1
                last = c
        ans+=count-1
        return ans
                ",1434263328
Chethan J,Chet8n,650,3576,cpp,"/**
 *    author:  Chet8n
 *    created: 26.10.2024 20:08:42
 **/
#include <bits/stdc++.h>
using namespace std;

#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define all(x) (x).begin(), (x).end()
#define ceill(x, y) ((x + y - 1) / y)
#define setbits(x) __builtin_popcountll(x)

const int mod = 1e9 + 7;
const int inf = 2e9 + 5;
const long long infl = 2e18 + 5;
double PI = 3.14159265358979323846;

#ifdef LOCAL
#include ""algo/debug.h""
#else
#define db(...) 20
#define sout(...) 20
#endif

class Solution {
  public:
    vector<int> findSubtreeSizes(vector<int> &parent, string s) {

        int n = parent.size();
        set<int> g[n];
        for (int i = 1; i < n; i++) {
            int par = parent[i];
            int child = i;
            g[par].insert(child);
        }

        for (int i = 0; i < n; i++) {
            db(g[i]);
        }

        vector<pair<int, int>> toRemove, toAdd;
        vector<vector<int>> seen(26);

        function<void(int, int)> dfs = [&](int cur, int par) {
            int prev = ((seen[s[cur] - 'a'].size() == 0) ? -1 : seen[s[cur] - 'a'].back());
            if (prev != -1) {
                toRemove.push_back(make_pair(par, cur));
                toAdd.push_back(make_pair(prev, cur));
            }
            seen[s[cur] - 'a'].push_back(cur);
            for (auto child : g[cur]) {
                dfs(child, cur);
            }
            seen[s[cur] - 'a'].pop_back();
        };

        dfs(0, -1);

        db(toAdd, toRemove);

        for (auto [u, v] : toRemove) {
            g[u].erase(v);
        }
        for (auto [u, v] : toAdd) {
            g[u].insert(v);
        }

        for (int i = 0; i < n; i++) {
            db(g[i]);
        }

        vector<int> ans(n);
        function<int(int)> dfs2 = [&](int cur){
            int here = 1;
            for(auto child : g[cur]){
                here += dfs2(child);
            }
            ans[cur] = here;
            return here;
        };
        dfs2(0);

        return ans;
    }
};
#ifdef LOCAL
int32_t main() {
    fastio;
    int testCases = 1;
    // cin >> testCases;
    for (int i = 1; i <= testCases; i++) {
        Solution s;
        vector<int> parent = {-1, 0, 0, 1, 1, 1};
        string st = ""abaabc"";
        auto ans = s.findSubtreeSizes(parent, st);
        sout(ans);
    }
}
#endif",1434301044
Chethan J,Chet8n,650,3587,cpp,"/**
 *    author:  Chet8n
 *    created: 26.10.2024 20:29:32
 **/
#include <bits/stdc++.h>
using namespace std;

#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)
#define all(x) (x).begin(), (x).end()
#define ceill(x, y) ((x + y - 1) / y)
#define setbits(x) __builtin_popcountll(x)

const int mod = 1e9 + 7;
const int inf = 2e9 + 5;
const long long infl = 2e18 + 5;
double PI = 3.14159265358979323846;

#ifdef LOCAL
#include ""algo/debug.h""
#else
#define db(...) 20
#define sout(...) 20
#endif

class Solution {
  public:
    int maxScore(int n, int k, vector<vector<int>> &stayScore, vector<vector<int>> &travelScore) {

        vector<vector<int>> dp(n + 2, vector<int> (k + 2, -1));
        function<int(int, int)> go = [&](int curCity, int curTime) {
            if (curTime == k) {
                return 0;
            }

            if(dp[curCity][curTime] != -1){
                return dp[curCity][curTime];
            }

            int ansHere = 0;
            // choose to stay in the city
            ansHere = stayScore[curTime][curCity] + go(curCity, curTime + 1);
            // chose to move to different city
            for (int i = 0; i < n; i++) {
                if (curCity == i)
                    continue;
                ansHere = max(ansHere, travelScore[curCity][i] + go(i, curTime + 1));
            }
            return dp[curCity][curTime] = ansHere;
        };

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = max(ans, go(i, 0));
        }
        return ans;
    }
};

#ifdef LOCAL
int32_t main() {
    fastio;
    int testCases = 1;
    // cin >> testCases;
    for (int i = 1; i <= testCases; i++) {
        Solution s;
        int n = 2, k = 1;
        vector<vector<int>> stayScore = {{2, 3}};
        vector<vector<int>> travelScore = {{0, 2}, {1, 0}};
        auto ans = s.maxScore(n, k, stayScore, travelScore);
        sout(ans);
    }
}
#endif",1434331056
Chethan J,Chet8n,650,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {

        int n = word.length();
        int ans = 1;
        for(int i = 0,j = 0;i < n;i++){
            while(j < n && word[i] == word[j]){
                j++;
            }
            int len = j-i;
            ans += len - 1;
            i = j-1;
        }
        return ans;
        
    }
};",1434265022
xtBF3zTxLC,xtBF3zTxLC,651,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parentIndices, String characters) {
        int nodeCount = parentIndices.length;

        List<List<Integer>> initialTree = new ArrayList<>();
        for (int i = 0; i < nodeCount; i++) {
            initialTree.add(new ArrayList<>());
        }
        for (int i = 1; i < nodeCount; i++) {
            initialTree.get(parentIndices[i]).add(i);
        }

        List<List<Integer>> modifiedTree = new ArrayList<>();
        for (int i = 0; i < nodeCount; i++) {
            modifiedTree.add(new ArrayList<>());
        }

        Map<Character, Stack<Integer>> charToAncestorMap = new HashMap<>();
        updateNodeParents(0, initialTree, modifiedTree, parentIndices, characters, charToAncestorMap);

        int[] subtreeSizes = new int[nodeCount];
        calculateSubtreeSize(0, modifiedTree, subtreeSizes);

        return subtreeSizes;
    }

    private void updateNodeParents(int currentNode, List<List<Integer>> initialTree, 
                                   List<List<Integer>> modifiedTree, int[] parentIndices, 
                                   String characters, Map<Character, Stack<Integer>> charToAncestorMap) {
        char currentChar = characters.charAt(currentNode);

        if (charToAncestorMap.containsKey(currentChar) && !charToAncestorMap.get(currentChar).isEmpty()) {
            int nearestAncestor = charToAncestorMap.get(currentChar).peek();
            parentIndices[currentNode] = nearestAncestor;
        }

        if (parentIndices[currentNode] != -1) {
            modifiedTree.get(parentIndices[currentNode]).add(currentNode);
        }

        charToAncestorMap.putIfAbsent(currentChar, new Stack<>());
        charToAncestorMap.get(currentChar).push(currentNode);

        for (int childNode : initialTree.get(currentNode)) {
            updateNodeParents(childNode, initialTree, modifiedTree, parentIndices, characters, charToAncestorMap);
        }

        charToAncestorMap.get(currentChar).pop();
    }

    private int calculateSubtreeSize(int currentNode, List<List<Integer>> modifiedTree, int[] subtreeSizes) {
        int size = 1;

        for (int childNode : modifiedTree.get(currentNode)) {
            size += calculateSubtreeSize(childNode, modifiedTree, subtreeSizes);
        }

        subtreeSizes[currentNode] = size;
        return size;
    }
}    ",1434320588
xtBF3zTxLC,xtBF3zTxLC,651,3587,java,"class Solution {
    public int maxScore(int citiesCount, int daysCount, int[][] dailyStayPoints, int[][] dailyTravelPoints) {
        int[][] pointsDP = new int[daysCount][citiesCount];

        for (int city = 0; city < citiesCount; city++) {
            pointsDP[0][city] = dailyStayPoints[0][city];
            for (int destCity = 0; destCity < citiesCount; destCity++) {
                if (destCity != city) {
                    pointsDP[0][city] = Math.max(pointsDP[0][city], dailyTravelPoints[destCity][city]);
                }
            }
        }

        for (int day = 1; day < daysCount; day++) {
            for (int currentCity = 0; currentCity < citiesCount; currentCity++) {
                pointsDP[day][currentCity] = pointsDP[day - 1][currentCity] + dailyStayPoints[day][currentCity];

                for (int destinationCity = 0; destinationCity < citiesCount; destinationCity++) {
                    if (destinationCity != currentCity) {
                        pointsDP[day][currentCity] = Math.max(pointsDP[day][currentCity], 
                                pointsDP[day - 1][destinationCity] + dailyTravelPoints[destinationCity][currentCity]);
                    }
                }
            }
        }

        int maxPointsEarned = 0;
        for (int city = 0; city < citiesCount; city++) {
            maxPointsEarned = Math.max(maxPointsEarned, pointsDP[daysCount - 1][city]);
        }

        return maxPointsEarned;
    }
}",1434331070
xtBF3zTxLC,xtBF3zTxLC,651,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int size = word.length();
        Set<String> ans = new HashSet<>();
        ans.add(word);
        for(int ii=0;ii<size;ii++){
            int jj = ii;
            while (jj < size && word.charAt(jj) == word.charAt(ii)) {
                jj++;
            }
            int leng = jj - ii;
            for (int ik = 1; ik < leng; ik++) {
            String newWord = word.substring(0, ii) + word.substring(ii, ii + ik) + word.substring(jj);
                ans.add(newWord);
            }
            ii = jj - 1;
        }
        return ans.size();
    }
}",1434284498
adityasingh99,adityasingh99,652,3576,cpp,"class Solution {
public:
    void dfs(int node,vector<int> vec[],vector<int>& parent, string& s,vector<int>& alp){
        int pos=alp[s[node]-'a'];
        if(alp[s[node]-'a']!=-1)
            parent[node]=alp[s[node]-'a'];
        alp[s[node]-'a']=node;
        for(auto it:vec[node]){
            dfs(it,vec,parent,s,alp);
        }
        alp[s[node]-'a']=pos;
    }
    void dfs2(int node,vector<int> vec[],vector<int>& ans){
        ans[node]=1;
        for(auto it:vec[node]){
            dfs2(it,vec,ans);
            ans[node]+=ans[it];
        }
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=parent.size();
        vector<int> vec[n];
        for(int i=1;i<n;i++)
            vec[parent[i]].push_back(i);
        vector<int> alp(26,-1);
        dfs(0,vec,parent,s,alp);
        vector<int> tree[n];
        for(int i=1;i<n;i++)
            tree[parent[i]].push_back(i);
        vector<int> ans(n);
        dfs2(0,tree,ans);
        return ans;
    }
};",1434331094
adityasingh99,adityasingh99,652,3587,cpp,"class Solution {
public:
    int foo(int day,int city,int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& dp) {
        if(day==k)
            return 0;
        if(dp[day][city]!=-1)
            return dp[day][city];
        dp[day][city]=stayScore[day][city]+foo(day+1,city,n,k,stayScore,travelScore,dp);
        for(int dest=0;dest<n;dest++){
            if(city==dest)
                continue;
            dp[day][city]=max(dp[day][city],travelScore[city][dest]+foo(day+1,dest,n,k,stayScore,travelScore,dp));
        }
        return dp[day][city];
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k,vector<int>(n,-1));
        int ans=0;
        for(int i=0;i<n;i++)
            ans=max(ans,foo(0,i,n,k,stayScore,travelScore,dp));
        return ans;
    }
};",1434295674
adityasingh99,adityasingh99,652,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans=1;
        for(int i=0;i<word.size()-1;i++){
            if(word[i]==word[i+1])
                ans++;
        }
        return ans;
    }
};",1434260636
NILESH BAHETI,Nilesh1012,653,3576,cpp,"class Solution {
public:
int result1 =0;
int dfs1(vector<int>adj[], int n, int node, int prev, int depth, vector<int>&ans){
    int total_count=1;
    result1+=depth;
    for(auto it:adj[node]){
        if(it!=prev){
            total_count+=dfs1(adj,n,it,node,depth+1,ans);
        }
    }
    ans[node]=total_count;
    return total_count;
}
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        vector<int>ans(n);
        vector<int>npar(n,-1);
        for(int i=1;i<n;i++)
            {
                int p=parent[i];
                 while(p>=0)
                     {
                         if(s[p]==s[i])
                         {
                             npar[i]=p;
                             break;
                         }
                         p=parent[p];
                     }
            }
        vector<int>adj[n];
        for(int i=1;i<npar.size();i++)
            {
               if(npar[i]==-1){
                   adj[i].push_back(parent[i]);
                   adj[parent[i]].push_back(i);
                       }
                else
               {
                    adj[npar[i]].push_back(i);
                    adj[i].push_back(npar[i]);
                   
               }
            }
        dfs1(adj,n,0,-1,0,ans);
        return ans;
    }
};",1434322366
NILESH BAHETI,Nilesh1012,653,3587,cpp,"class Solution {
public:
    int solve(int city, int day, vector<vector<int>>& s, vector<vector<int>>& t, vector<vector<int>> & dp){
        if(day >= s.size()) return 0;
        if(dp[city][day] != -1) return dp[city][day];
        int st = s[day][city] + solve(city, day + 1, s, t, dp);
        int tr = 0;
        for(int i = 0;  i < t.size(); i++){
            if(i == city) continue;
            tr = max(tr, t[city][i] + solve(i, day + 1, s, t, dp));
        }
        return dp[city][day] = max(st, tr);
        
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int ans = 0;
        vector<vector<int>> dp(n, vector<int>(k, -1));
        for(int i = 0; i < n; i++){
            ans = max(ans, solve(i, 0, stayScore, travelScore, dp));
        }
        return ans;
    }
};",1434338174
NILESH BAHETI,Nilesh1012,653,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int cnt=1;
        for(int i=1;i<n;i++)
            {
                if(word[i]==word[i-1])
                {
                    cnt++;
                }
            }
        return cnt;
    }
};",1434260110
Guardian-or-nothing,Guardian-or-nothing,654,3576,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution {
public:
    vector<int> newpar,ans;
    void dfs(ll root, vector<vector<int>> &g, ll par, vector<int> idx, string &s){
        vector<int> newidx=idx;
        char ch=s[root];
        if(idx[ch-'a']!=-1)
        newpar[root]=idx[ch-'a'];
        newidx[ch-'a']=root;
    for(int j=0;j<g[root].size();j++){
        ll child=g[root][j];
        if(child==par) continue;
        dfs(child,g,root,newidx,s);
    }
}
    
    int dfssum(ll root, vector<vector<int>> &g, ll par){
        int cnt=1;
        for(int j=0;j<g[root].size();j++){
            ll child=g[root][j];
            if(child==par) continue;
            cnt+=dfssum(child,g,root);
        }   
        return ans[root]=cnt;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        ll n=s.size(); vector<vector<int>> g(n);
        for(int i=1;i<n;i++){
            int x=parent[i],y=i;
            g[x].push_back(y);
        }
        vector<int> idx(26,-1); newpar=parent; ans.resize(n,0);
        for(int i=0;i<n;i++){
            cout<<newpar[i]<<"" "";
            newpar[i]=parent[i];
        }
        dfs(0,g,-1,idx,s);
        vector<vector<int>> newg(n);
        for(int i=1;i<n;i++){
            int x=newpar[i],y=i;
            newg[x].push_back(y);
        }
        dfssum(0,newg,-1);
        return ans;
    }
};",1434319493
Guardian-or-nothing,Guardian-or-nothing,654,3587,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution {
public:
    vector<vector<ll>> dp;
    ll f(ll day, ll city, vector<vector<int>>& s, vector<vector<int>>& t){
        ll n = t.size(),k = s.size();
        if(day>=k) return 0;
        if(dp[day][city]!=-1) return dp[day][city];
        ll ans=0;
        ll samecity=s[day][city]+f(day+1,city,s,t);
        for(int j=0;j<n;j++){
            ll tans=t[city][j]+f(day+1,j,s,t);
            ans=max(ans,tans);
        }
        ans=max(ans,samecity);
        return dp[day][city]=ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        ll ans=0; dp.resize(k+1,vector<ll>(n+1,-1));
        for(int i=0;i<n;i++){
            ll tans=f(0,i,stayScore,travelScore);
            ans=max(ans,tans);
        }
        return ans;
    }
};",1434338247
Guardian-or-nothing,Guardian-or-nothing,654,3617,cpp,"class Solution {
public:
    int possibleStringCount(string w) {
        int ans=1; int n=w.size();
        int l=0,r=0; int cnt=0;
        while(r<n){
            if(l==r || w[r]==w[l]){
                r++; cnt++;
            }else{
                ans+=(max(0,cnt-1));
                cnt=0; l=r;
            }
        }
        ans+=(max(0,cnt-1));
        cnt=0; l=r;
        return ans;
    }
};",1434266703
Bedru Umer,heidenbrug,655,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        tree = defaultdict(set)
        parents = defaultdict(int)
        for i, p in enumerate(parent):
            if p != -1: 
                tree[p].add(i)
                parents[i] = p

        def dfs(node, ancestors):
            if s[node] in ancestors:
                new_parent = ancestors[s[node]]
                old_parent = parents[node]
                if old_parent != new_parent:
                    tree[new_parent].add(node)
                    tree[old_parent].discard(node)

            ancestors[s[node]] = node
            for child in list(tree[node]):
                dfs(child, ancestors.copy())

        dfs(0, {})
        ans = [0] * len(parent)
        def count(node):
            children = 1
            for child in tree[node]:
                children += count(child)
            ans[node] = children
            return ans[node]

        count(0)
        return ans",1434338277
Bedru Umer,heidenbrug,655,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(curr_city, day):
            if day >= k or curr_city == n: return 0

            # stay
            res = stayScore[day][curr_city] + dp(curr_city, day + 1)
            # travel
            for dest in range(n):
                res = max(res, travelScore[curr_city][dest] + dp(dest, day + 1))

            return res

        return max(dp(city, 0) for city in range(n))
            ",1434312408
Bedru Umer,heidenbrug,655,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = 0
        curr = word[0]
        count = 1
        
        for c in word[1:]:
            if c == curr:
                count += 1
            else:
                res += count - 1
                curr = c
                count = 1
                
        res += count

        return res",1434281684
Zebra,dinar,656,3576,python3,"class Node:
    def __init__(self, idx):
        self.idx = idx
        self.children = set()

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        root = Node(0)
        nodes = {0: root}
        
        for idx in range(1, len(parent)):
            par = parent[idx]
            if par not in nodes:
                nodes[par] = Node(par)
            if idx not in nodes:
                nodes[idx] = Node(idx)
            nodes[par].children.add(nodes[idx])

        def dfs_reconnect(node, ancestors=None):
            if ancestors is None:
                ancestors = [None] * 26
            
            char_idx = ord(s[node.idx]) - ord('a')
            if ancestors[char_idx] is not None:
                if parent[node.idx] != -1:
                    nodes[parent[node.idx]].children.remove(node)
                    ancestors[char_idx].children.add(node)
            previous_ancestor = ancestors[char_idx]
            ancestors[char_idx] = node
            
            for child in list(node.children):
                dfs_reconnect(child, ancestors)
            
            ancestors[char_idx] = previous_ancestor

        dfs_reconnect(root)

        ans = [0] * len(parent)
        
        def dfs_count(node):
            size = 1
            for child in node.children:
                size += dfs_count(child)
            ans[node.idx] = size
            return size
        
        dfs_count(root)
        return ans
",1434321529
Zebra,dinar,656,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(day, city):
            if day == k: return 0
            ans = stayScore[day][city] + dp(day + 1, city)
            for dest in range(n):
                if dest == city: continue
                ans = max(ans, dp(day + 1, dest) + travelScore[city][dest])
            return ans
        
        ans = 0
        for i in range(n):
            ans = max(ans, dp(0, i))
            
        return ans",1434338334
Zebra,dinar,656,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 0
        prev = """"
        for w in word:
            if w == prev:
                ans += 1
            prev = w
            
        return ans + 1",1434261006
Sajal Namdeo,Sajal0701,657,3576,cpp,"class Solution {
public:
    void findAncestors(int node, const vector<vector<int>>& adj, const string& s, vector<stack<int>>& st, vector<int>& np, const vector<int>& p) {
        int idx = s[node] - 'a';
        np[node] = !st[idx].empty() ? st[idx].top() : p[node];
        st[idx].push(node);
        for (int ch : adj[node]) findAncestors(ch, adj, s, st, np, p);
        st[idx].pop();
    }

    int calculateSubtreeSize(int node, const vector<vector<int>>& nadj, vector<int>& res) {
        int size = 1;
        for (int ch : nadj[node]) size += calculateSubtreeSize(ch, nadj, res);
        res[node] = size;
        return size;
    }

    vector<int> processTree(const vector<int>& p, const string& s) {
        int n = p.size();
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) adj[p[i]].push_back(i);

        vector<stack<int>> st(26);
        vector<int> np(n, -1);
        findAncestors(0, adj, s, st, np, p);

        vector<vector<int>> nadj(n);
        for (int i = 1; i < n; ++i) if (np[i] != -1) nadj[np[i]].push_back(i);

        vector<int> res(n, 0);
        calculateSubtreeSize(0, nadj, res);
        return res;
    }

    vector<int> findSubtreeSizes(vector<int>& p, string s) {
        return processTree(p, s);
    }
};
",1434277614
Sajal Namdeo,Sajal0701,657,3587,cpp,"#include <algorithm>
#include <vector>
using namespace std;

class Solution {
public:
    int dfs(int day, int city, int n, vector<vector<int>>& sS,
            vector<vector<int>>& tS, vector<vector<int>>& dp) {
        if (day < 0)
            return 0;
        if (dp[day][city] != -1)
            return dp[day][city];

        int stay = dfs(day - 1, city, n, sS, tS, dp) + sS[day][city];
        int travel = 0;

        for (int x = 0; x < n; ++x) {
            if (x != city) {
                travel =
                    max(travel, dfs(day - 1, x, n, sS, tS, dp) + tS[x][city]);
            }
        }

        return dp[day][city] = max(stay, travel);
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore,
                 vector<vector<int>>& travelS) {
        vector<vector<int>> dp(k, vector<int>(n, -1));
        int res = 0;
        for (int j = 0; j < n; ++j) {
            res = max(res, dfs(k - 1, j, n, stayScore, travelS, dp));
        }
        return res;
    }
};
",1434338475
Sajal Namdeo,Sajal0701,657,3617,cpp,"class Solution {
public:
    int possibleStringCount(string str) {
        int result = 0;
        int i = 0;
        while(i<str.size()){
            int temp = 1; 
            while(i<str.size() && str[i] == str[i+1]){
                temp++; i++;
            }
            result += temp - 1;
            i++;
        }
        return result + 1;
    }
};",1434270919
huci0062,huci0062,658,3576,cpp,"class Solution {
    vector<int> ret;
public:
    int cal_subtree(int cur, vector<vector<int>> &vi) {
        int ans = 0;
        for (auto &i: vi[cur]) {
            ans += cal_subtree(i, vi);
        }

        ret[cur] = ans + 1;

        return ans + 1;
    }

    int pa[30];
    void cal_new_tree(int cur, vector<int>& parent, vector<vector<int>> &vi, string &s) {
        if (pa[s[cur] - 'a'] != -1) {
            parent[cur] = pa[s[cur] - 'a'];
        }

        int old = pa[s[cur] - 'a'];

        pa[s[cur] - 'a'] = cur;
        for (auto &i : vi[cur]) {
            cal_new_tree(i, parent, vi, s);
        }
        pa[s[cur] - 'a'] = old;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        ret.resize(n);
        for (int i = 0; i < 30; i ++) pa[i] = -1;
        vector<vector<int>> vi(n);

        for (int i = 1; i < n; i ++) {
            vi[parent[i]].push_back(i);
        }

        cal_new_tree(0, parent, vi, s);

        for (int i = 0; i < n; i ++) {
            vi[i].clear();
        }

        
        for (int i = 1; i < n; i ++) {
            vi[parent[i]].push_back(i);
        }
        cal_subtree(0, vi);
        return ret;
    }
};",1434297114
huci0062,huci0062,658,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int dp[205][205][205] = {0};
        int max_val[205];
        for (int i = 0; i < 205; i ++) max_val[i] = 0;
        for (int i = 1; i <= k; i ++) {
            for (int j = 0; j < n; j ++) {
                for (int x = 0; x < n; x ++) {
                    if (j != x) {
                        dp[i][j][x] = max_val[j] + travelScore[j][x];
                    } else {
                        dp[i][j][x] = max_val[j] + stayScore[i - 1][j];
                    }
                }
            }
            for (int j = 0; j < n; j ++) {
                max_val[j] = 0;
                for (int x = 0; x < n; x ++) {
                    max_val[j] = max(max_val[j], dp[i][x][j]);
                }
            }
        }
        // for (int i = 1; i <= k; i ++) {
        //     cout << ""i == "" << i << ""==========="" << endl;
        //     for (int j = 0; j < n; j ++) {
        //         for (int x = 0; x < n; x ++) {
        //             cout << dp[i][j][x] << ' ';
        //         }
        //         cout << endl;
        //     }
        // }
        int ret = 0;
        for (int i = 0; i < n; i ++) {
            for (int j =0 ; j < n; j ++) {
                ret = max(ret, dp[k][i][j]);
            }
        }
        return ret;
    }
};",1434325025
huci0062,huci0062,658,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ret = 0;
        int n = word.size();
        for (int i = 1; i < n; i ++) {
            if (word[i] == word[i - 1]) {
                ret += 1;
            }
        }

        return ret + 1;
    }
};",1434261850
Sam Chen,SamChen856,659,3576,python3,"class Solution:
    # dfs, time O(n), space O(n)
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        def construct_tree(par):
            adj = [[] for _ in range(n)]
            for i in range(1, n):
                adj[par[i]].append(i)
            return adj

        G = construct_tree(parent)
        cur_parent = parent[:]
        char2node = [-1] * 26

        def dfs(node):
            ic = ord(s[node]) - ord('a')
            if char2node[ic] != -1:
                cur_parent[node] = char2node[ic]
            old_node = char2node[ic]
            char2node[ic] = node
            for child in G[node]:
                dfs(child)
            char2node[ic] = old_node
        
        dfs(0)

        G2 = construct_tree(cur_parent)
        answer = [0] * n
        
        def get_subtree_size(node):
            size = 1
            for child in G2[node]:
                size += get_subtree_size(child)
            answer[node] = size
            return size

        get_subtree_size(0)
        
        return answer",1434331815
Sam Chen,SamChen856,659,3587,python3,"class Solution:
    # DP, time O(n), space O(n^2*k)
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [0] * n
        for i in range(k):
            ndp = [0] * n
            for cur in range(n):
                stay = dp[cur] + stayScore[i][cur]
                move = max(dp[pre] + travelScore[pre][cur] for pre in range(n) if pre != cur) if n > 1 else 0
                ndp[cur] = max(stay, move)
            dp = ndp
        return max(dp)",1434308543
Sam Chen,SamChen856,659,3617,python3,"class Solution:
    # 1 pass, time O(n), space O(n)
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        res = cur = 0
        pre = ''
        for c in word:
            if c == pre:
                cur += 1
            else:
                if cur > 0:
                    res += cur - 1
                pre = c
                cur = 1
        res += cur - 1
        return res + 1",1434296806
Gaurav Biswas,GauravBiswas,660,3576,cpp,"using ll = long long;
const int mod = 1e9 + 7;
class Solution {
private:
    void change(int node, string& s, vector<int>&parent, vector<vector<int>>& adj, vector<int>& arr, map<char, vector<int>>& mp) {
        char ch = s[node];
        if (!mp[ch].empty())arr[node] = mp[ch].back();
        else arr[node] = parent[node];
        mp[ch].push_back(node);
        for (int child : adj[node]) {
            change(child, s, parent, adj, arr, mp);
        }
        mp[ch].pop_back();
    }
    int dfs(int node, vector<vector<int>>& adj, vector<int>& ans) {
        int res = 1;
        for (int child : adj[node]) {
            res += dfs(child, adj, ans);
        }
        ans[node] = res;
        return res;
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>>adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        vector<int>arr(n, -1) , ans(n, 0);
        map<char, vector<int>> mp;
        change(0, s, parent, adj, arr, mp);
        adj.assign(n, vector<int>());
        for (int i = 1; i < n; ++i) {
            adj[arr[i]].push_back(i);
        }
        dfs(0, adj, ans);
        return ans;
    }
};",1434331840
Gaurav Biswas,GauravBiswas,660,3587,cpp,"class Solution {
private:
    int f(int idx, int curr, int k, int n, vector<vector<int>>& arr, vector<vector<int>>& brr, vector<vector<int>>& dp) {
        if (idx == k) return 0;
        if (dp[idx][curr] != -1) return dp[idx][curr];
        int take = arr[idx][curr] + f(idx + 1, curr, k, n, arr, brr, dp);
        int notTake = INT_MIN;
        for (int i = 0; i < n; ++i) {
            if(i != curr) {
                notTake = max(notTake, brr[curr][i] + f(idx + 1, i, k, n, arr, brr, dp));
            }
        }
        return dp[idx][curr] = max(take, notTake);
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k, vector<int>(n, -1));
        int ans = INT_MIN;
        for (int city = 0; city < n; ++city) {
            ans = max(ans, f(0, city, k, n, stayScore, travelScore, dp));
        }
        return ans;
    }
};",1434286370
Gaurav Biswas,GauravBiswas,660,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int temp = 0 , n = word.size();
        for(int i = 1 ; i < n ; i++) {
            if(word[i] == word[i - 1]) temp ++;
            else {
                ans += (temp);
                temp = 0;
            }
        }
        ans += temp;
        return ans;
    }
};",1434264350
Prabal Pratap Singh,prabalpsingh7115,661,3576,cpp,"class Solution {
public:

    void rec(int node,const string &s,vector<vector<int>>&tree,vector<int>&latest,vector<vector<int>>&ans,vector<int>&parents)
    {
        int parent=latest[s[node]-'a'];
        if(parent!=-1)
        {
            ans[parent].push_back(node);
        }
        else
        {
            if(node)
            {
                ans[parents[node]].push_back(node);
            }
        }
        latest[s[node]-'a']=node;
        for(auto &child:tree[node])
        {
            rec(child,s,tree,latest,ans,parents);
        }
        latest[s[node]-'a']=parent;
    }

    int getSubTreeSize(int node,vector<vector<int>>&tree,vector<int>&sz)
    {
        int cur=1;
        for(auto &child:tree[node])
        {
            cur+=getSubTreeSize(child,tree,sz); 
        }
        return sz[node]=cur;
    
    }


    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<int>latest(26,-1);
        int n=parent.size();
        vector<vector<int>>tree(n);
        for(int i=1;i<n;i++)
        {
            tree[parent[i]].push_back(i);
        }    

        vector<vector<int>>ans(n);
        rec(0,s,tree,latest,ans,parent);


        // for(int i=0;i<n;i++)
        // {
        //     cout<<i<<""---"";
        //     for(auto &j:ans[i])
        //     {
        //         cout<<j<<"" "";
        //     }
        //     cout<<endl;
        // }


        vector<int>sz(n);
        getSubTreeSize(0,ans,sz);

        return sz;
        
    }
};",1434299437
Prabal Pratap Singh,prabalpsingh7115,661,3587,cpp,"class Solution {
public:

    int rec(int city,int day,const int &k,const int &n,vector<vector<int>>&stayScore,vector<vector<int>>&travelScore,vector<vector<int>>&dp)
    {
        if(day==k)
        {
            return 0;
        }

        if(dp[city][day]!=-1)
        {
            return dp[city][day];
        }

        int ans=stayScore[day][city]+rec(city,day+1,k,n,stayScore,travelScore,dp);

        for(int nextCity=0;nextCity<n;nextCity++)
        {
            if(nextCity==city)
            {
                continue;
            }
            ans=max(ans,travelScore[city][nextCity]+rec(nextCity,day+1,k,n,stayScore,travelScore,dp));
        }

        return dp[city][day]=ans;
    
    }


    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {

        int ans=0;
        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));
        for(int city=0;city<n;city++)
        {
            ans=max(ans,rec(city,0,k,n,stayScore,travelScore,dp));
        }
        return ans;
    }
};",1434331914
Prabal Pratap Singh,prabalpsingh7115,661,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int ans=1;
        while(s.size())
        {
            int cur=s.back();
            s.pop_back();
            int c=0;
            while(s.size()&&s.back()==cur)
            {
                ans++;
                s.pop_back();
            } 
        }
        return ans;
        
    }
};",1434262403
luck,chengchuanqiang,662,3576,java,"class Solution {
    List<Integer>[] g;
    int[] ansP;
    List<Integer>[] ng;
    int[] ans;

    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        g = new List[n];
        Arrays.setAll(g, e -> new ArrayList<>());

        for (int i = 1; i < n; i++) {
            g[i].add(parent[i]);
            g[parent[i]].add(i);
        }
        ansP = new int[n];
        Arrays.fill(ansP, -1);
        Map<Character, Integer> parentMap = new HashMap<>();
        parentMap.put(s.charAt(0), 0);

        dfs(0, -1, s, parentMap);

        ng = new List[n];
        Arrays.setAll(ng, e -> new ArrayList<>());
        for (int i = 1; i < n; i++) {
            ng[i].add(ansP[i]);
            ng[ansP[i]].add(i);
        }
        ans = new int[n];
        calc(0, -1);
        return ans;
    }

    public void dfs(int x, int fa, String s, Map<Character, Integer> parentMap) {
        for (int nx : g[x]) {
            if (nx == fa) {
                continue;
            }
            char c = s.charAt(nx);
            if (parentMap.containsKey(c)) {
                ansP[nx] = parentMap.get(c);
                int t = parentMap.get(c);
                parentMap.put(c, nx);
                dfs(nx, x, s, parentMap);
                parentMap.put(c, t);
            } else {
                ansP[nx] = x;
                parentMap.put(c, nx);
                dfs(nx, x, s, parentMap);
                parentMap.remove(c);
            }
        }
    }

    public void calc(int x, int fa) {
        ans[x] = 1;
        for (int nx : ng[x]) {
            if (nx == fa) {
                continue;
            }
            calc(nx, x);
            ans[x] += ans[nx];
        }

    }
}",1434338801
luck,chengchuanqiang,662,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        //  i  j 
        int[][] dp = new int[k + 1][n];

        for (int i = 1; i <= k; i++) {

            for (int j = 0; j < n; j++) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j] + stayScore[i - 1][j]);

                for (int p = 0; p < n; p++) {
                    if (j == p) {
                        dp[i][p] = Math.max(dp[i][p], dp[i - 1][j] + stayScore[i - 1][p]);
                    } else {
                        dp[i][p] = Math.max(dp[i][p], dp[i - 1][j] + travelScore[j][p]);
                    }
                }
            }
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, dp[k][i]);
        }
        return ans;
    }
}",1434303836
luck,chengchuanqiang,662,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        List<Integer> list = new ArrayList<>();
        int n = word.length();

        int i = 0;
        int j = 0;

        while (i < n) {

            while (j + 1 < n && word.charAt(i) == word.charAt(j + 1)) {
                j++;
            }

            if (j - i + 1 > 1) {
                list.add(j - i + 1);
            }
            i = j + 1;
            j++;
        }

        int ans = 1;
        for (int x : list) {
            ans += x - 1;
        }
        return ans;
    }
}",1434265809
TulasiRaj,TulasiRaj,663,3576,java,"class Solution {
    static List<List<Integer>> adj,adj2;
    static int ans[];
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = s.length();
        adj = new ArrayList<>();
        adj2 = new ArrayList<>();
        for(int i=0;i<n;i++) {
            adj.add(new ArrayList<>());
            adj2.add(new ArrayList<>());
        }
        ans = new int[n];
        int cnt[] = new int[26];
        int np[] = new int[n];
        for(int i=0;i<n;i++)
        {
            np[i] = parent[i];
        }
        Arrays.fill(cnt,-1);
        for(int i=1;i<n;i++)
        {
            int u = i; int v= parent[i];
            adj.get(u).add(v);
            adj.get(v).add(u);
        }
        dfs(0,s,cnt,parent,np);
        for(int i=1;i<n;i++)
        {
            // System.out.println(i+"" ""+np[i]);
            int u = i; int v = np[i];
            adj2.get(u).add(v);
            adj2.get(v).add(u);
        }
        dfs2(0,np);
        return ans;
        
    }
    public void dfs(int u,String s,int cnt[],int parent[],int np[])
    {
         int ind = s.charAt(u)-'a';
         if(cnt[ind]!=-1) {
             np[u] = cnt[ind];
         }
         int prev = cnt[ind];
        cnt[ind] = u;
        for(int v : adj.get(u))
        {
            if(v==parent[u]) continue;
            dfs(v,s,cnt,parent,np);
        }
        cnt[ind] = prev;
    }
    public void dfs2(int u,int np[])
    {
        for(int v : adj2.get(u))
        {
            if(v==np[u]) continue;
            dfs2(v,np);
            ans[u]+=ans[v];
        }
        ans[u]++;
    }
}",1434293954
TulasiRaj,TulasiRaj,663,3587,java,"class Solution {
    int dp[][];
    public int maxScore(int n, int k, int[][] s, int[][] t) {
         dp = new int[n][k+1];
        for(int i=0;i<n;i++) Arrays.fill(dp[i],-1);
        int ans =  f(s,t,n,k,0,0);
        return ans;
    }
    public int f(int s[][],int t[][],int n,int k,int day,int city)
    {
        if(day>k) return 0;
        if(dp[city][day]!=-1) return dp[city][day];
          int ans=  0;
            if(day!=0)
           {
              ans = f(s,t,n,k,day+1,city)+(day-1>=0?s[day-1][city]:0);
           }
        for(int i=0;i<n;i++)
        {
           int val = f(s,t,n,k,day+1,i)+(day-1>=0?t[city][i]:0);
            ans = Math.max(ans,val);
        }
        return dp[city][day] = ans;
    }
} ",1434332167
TulasiRaj,TulasiRaj,663,3617,java,"class Solution {
    public int possibleStringCount(String s) {
        int n = s.length();
        int ans = 1; int cnt = 1;
        for(int i=1;i<n;i++)
        {
            if(s.charAt(i)==s.charAt(i-1)) {
                cnt++;
            }
            else {
                ans = ans+cnt-1;
                cnt=1;
            }
        }
        ans = ans+cnt-1;
        return ans;
    }
}",1434261995
Abhay Pratap Singh,abhay_01,664,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        
     int n = parent.length;
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            tree.add(new ArrayList<>());
        }
        
        int[] subtreeSize = new int[n];
        Arrays.fill(subtreeSize, 1);
        int[] newParent = Arrays.copyOf(parent, n); // To keep track of new parents

        // Construct the tree from the parent array
        for (int i = 1; i < n; i++) {
            tree.get(parent[i]).add(i);
        }

        Map<Character, Integer> lastOccurrence = new HashMap<>();

        // Depth-First Search (DFS) for modifying tree structure
        dfs(tree, s, newParent, lastOccurrence, 0);

        // Build the modified tree based on newParent
        List<List<Integer>> newTree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            newTree.add(new ArrayList<>());
        }
        for (int i = 1; i < n; i++) {
            newTree.get(newParent[i]).add(i);
        }

        // Calculate subtree sizes
        calculateSizes(newTree, subtreeSize, 0);

        return subtreeSize;
    }

    private void dfs(List<List<Integer>> tree, String s, int[] newParent, 
                     Map<Character, Integer> lastOccurrence, int node) {
        char ch = s.charAt(node);
        int original = newParent[node];

        // If there's a last occurrence of the same character
        if (lastOccurrence.containsKey(ch)) {
            int ancestor = lastOccurrence.get(ch);
            if (ancestor != original) {
                newParent[node] = ancestor; // Update new parent
            }
        }

        int prev = lastOccurrence.containsKey(ch) ? lastOccurrence.get(ch) : -1;
        lastOccurrence.put(ch, node); // Update last occurrence of character

        // Process children
        for (int child : tree.get(node)) {
            dfs(tree, s, newParent, lastOccurrence, child);
        }

        // Restore last occurrence
        if (prev == -1) {
            lastOccurrence.remove(ch);
        } else {
            lastOccurrence.put(ch, prev); // Restore previous occurrence
        }
    }

    private int calculateSizes(List<List<Integer>> newTree, int[] subtreeSize, int node) {
        int size = 1; // Count the current node
        for (int child : newTree.get(node)) {
            size += calculateSizes(newTree, subtreeSize, child);
        }
        subtreeSize[node] = size; // Accumulate sizes
        return size;
    }
}
",1434328136
Abhay Pratap Singh,abhay_01,664,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        
         int[][] dp = new int[k + 1][n];

        // Initialize dp for the first day
        for (int j = 0; j < n; j++) {
            dp[0][j] = 0; // No points before the first day
        }

        // Fill the DP table
        for (int day = 1; day <= k; day++) {
            for (int curr = 0; curr < n; curr++) {
                // Staying in the current city
                dp[day][curr] = dp[day - 1][curr] + stayScore[day - 1][curr];
                
                // Moving to another city
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {
                        dp[day][curr] = Math.max(dp[day][curr], dp[day - 1][dest] + travelScore[dest][curr]);
                    }
                }
            }
        }

        // Find the maximum points after k days
        int maxPoints = 0;
        for (int j = 0; j < n; j++) {
            maxPoints = Math.max(maxPoints, dp[k][j]);
        }

        return maxPoints;
    }
}",1434332170
Abhay Pratap Singh,abhay_01,664,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        
        int len = word.length();
        int cout = 1;
        
        for(int i = 0;i<len-1;i++){
            if(word.charAt(i)==word.charAt(i+1)){
                cout++;
            }
        }
//         HashMap<Character,Integer> hm = new HashMap<>();
//         int cout = 1;
        
//         for(char c:word.toCharArray()){
//             hm.put(c,hm.getOrDefault(c,0)+1);
//         }
        
        
//         for(char key:hm.keySet()){
            
            
//             while(hm.get(key)>1){
//                 cout++;
//                 hm.put(key,hm.get(key)-1);
//             }
//         }
        
        
        return cout;
            
    }
}",1434274215
MOHAN SHARMA,mohan5050390,665,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)

        # Step 1: Build the original tree using an adjacency list.
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)

        # Step 2: Prepare a copy of the parent array for applying changes.
        new_parent = parent[:]

        # Step 3: DFS to update parents where needed.
        def dfs(node, char_stacks):
            char = s[node]
            # If there's an ancestor with the same character, update the parent.
            if char in char_stacks and char_stacks[char]:
                new_parent[node] = char_stacks[char][-1]

            # Add the current node to the stack for its character.
            char_stacks[char].append(node)

            # Explore all children of the current node.
            for child in tree[node]:
                dfs(child, char_stacks)

            # Backtrack: Remove the current node from the stack.
            char_stacks[char].pop()

        # Perform DFS from the root (node 0).
        dfs(0, defaultdict(list))

        # Step 4: Build the new tree based on the updated parent relationships.
        new_tree = defaultdict(list)
        for i in range(1, n):
            new_tree[new_parent[i]].append(i)

        # Step 5: DFS to calculate the size of each subtree.
        answer = [0] * n

        def calculate_subtree_size(node):
            size = 1  # Include the current node.
            for child in new_tree[node]:
                size += calculate_subtree_size(child)
            answer[node] = size
            return size

        # Calculate subtree sizes starting from the root (node 0).
        calculate_subtree_size(0)

        return answer
",1434287428
MOHAN SHARMA,mohan5050390,665,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Create a DP table to store the maximum points for each city on each day
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        // Fill the DP table
        for (int day = 0; day < k; ++day) {
            for (int curr = 0; curr < n; ++curr) {
                // If the tourist stays in the current city
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);
                
                // If the tourist travels to another city
                for (int dest = 0; dest < n; ++dest) {
                    if (curr != dest) {
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }

        // Find the maximum score after k days
        int maxPoints = 0;
        for (int city = 0; city < n; ++city) {
            maxPoints = max(maxPoints, dp[k][city]);
        }

        return maxPoints;
    }
};",1434303541
MOHAN SHARMA,mohan5050390,665,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        n = len(word)
        total_ways = 1  # At least one valid way: the original string itself.

        i = 0
        while i < n:
            # Find the end of the current group of identical characters.
            j = i
            while j < n and word[j] == word[i]:
                j += 1

            group_size = j - i  # Size of the current group.

            # If the group has more than 1 character, we can reduce it in (group_size - 1) ways.
            if group_size > 1:
                total_ways += (group_size - 1)

            # Move to the next group.
            i = j

        return total_ways",1434284438
lazyleeds1,lazyleeds1,666,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        ans = [0] * len(parent)

        children = defaultdict(list)
        
        for i, par in enumerate(parent):
            children[par].append(i)

        def update(node, last_seen):
            ls = last_seen.copy()
            ls[s[node]] = node
            
            for c in children[node]:
                if s[c] in ls:
                    parent[c] = ls[s[c]]
                update(c, ls)

        update(0, dict())

        children = defaultdict(list)

        for i, par in enumerate(parent):
            children[par].append(i)

        def dfs(node):
            size = 0
            
            for c in children[node]:
                size += dfs(c)

            ans[node] = 1 + size
            return 1 + size

        dfs(0)
        return ans
        
        
            ",1434323961
lazyleeds1,lazyleeds1,666,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        @cache
        def dfs(city, day):
            if day == k:
                return 0
                
            ans = 0

            for i in range(n):
                if i == city:
                    ans = max(ans, stayScore[day][city] + dfs(city, day+1))
                else:
                    ans = max(ans, travelScore[city][i] + dfs(i, day+1))

            return ans

        ans = 0

        for i in range(n):
            ans = max(ans, dfs(i, 0))

        return ans",1434332544
lazyleeds1,lazyleeds1,666,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:

        arr = []
        curr = 1
        
        for i in range(1, len(word)):
            if word[i] == word[i-1]:
                curr += 1
            else:
                arr.append(curr)
                curr = 1

        arr.append(curr)

        ans = 0

        for a in arr:
            ans += a-1

        return ans + 1",1434273436
Ayush Katre,AYUSH_KATRE,667,3576,cpp,"#include <vector>
#include <unordered_map>
#include <functional>

using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n); // Original tree structure
        vector<int> answer(n, 1);   // To store subtree sizes

        // Step 1: Build the adjacency list from the parent array
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }

        // Step 2: Reassign parents based on closest ancestor with same character
        vector<int> newParent = parent; // Initialize with original parents
        unordered_map<char, vector<int>> lastSeen; // Track last seen ancestor for each character

        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];

            // Check if there's a last seen ancestor with the same character
            if (!lastSeen[c].empty()) {
                newParent[node] = lastSeen[c].back();
            }

            // Save current node as the last seen for this character
            lastSeen[c].push_back(node);

            // Process children in the original tree
            for (int child : adj[node]) {
                reassignParents(child);
            }

            // Backtrack: Remove current node as last seen for this character
            lastSeen[c].pop_back();
        };

        reassignParents(0); // Start from the root node (0)

        // Step 3: Build the new tree based on reassigned parents
        vector<vector<int>> newAdj(n); // New adjacency list
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }

        // Step 4: DFS to calculate subtree sizes in the new tree
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1; // Start with 1 for itself
            for (int child : newAdj[node]) {
                size += computeSubtreeSizes(child);
            }
            answer[node] = size;
            return size;
        };

        computeSubtreeSizes(0); // Start DFS from root to calculate subtree sizes

        return answer;
    }
};
",1434273629
Ayush Katre,AYUSH_KATRE,667,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        // Step 1: Fill the DP table
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                // Stay in the current city
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);

                // Move to another city
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) { // Ensure not moving to the same city
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }

        // Step 2: Find the maximum score after k days
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }

        return maxPoints;
    }
};",1434318778
Ayush Katre,AYUSH_KATRE,667,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int totalCount = 1, n = word.length();
        for (int i = 0; i < n; ) {
            int j = i;
            while (j < n && word[j] == word[i]) j++;
            int idx = j-i;
            if (idx > 1) totalCount += (idx - 1); 
            i=j;
        }
        return totalCount; 
    }
};
",1434293620
Tagir Gumerov,TigProg,668,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        vs = defaultdict(list)
        for node, par in enumerate(parent):
            if par == -1:
                continue
            vs[par].append(node)
        
        swaps = []
        
        def dfs(node, state):
            if node is None:
                return
            
            char = s[node]
            if len(state[char]) > 0:
                swaps.append([node, state[char][-1]])
            state[char].append(node)
            
            for v in vs[node]:
                dfs(v, state)
            
            state[char].pop()

        dfs(0, defaultdict(list))
        print(swaps)

        if swaps:
            for child, par in swaps:
                parent[child] = par

            vs = defaultdict(list)
            for node, par in enumerate(parent):
                if par == -1:
                    continue
                vs[par].append(node)
        
        print(parent)
        
        result = [0] * len(parent)
        def dfs2(u):
            if u is None:
                return 0
            number = 1
            for v in vs[u]:
                number += dfs2(v)
            result[u] = number
            return number
        
        dfs2(0)
        return result
",1434332700
Tagir Gumerov,TigProg,668,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @cache
        def dp(day, city):
            if day == k:
                return 0
            
            result = stayScore[day][city] + dp(day + 1, city)
            
            for next_city in range(n):
                if next_city == city:
                    continue
                current = travelScore[city][next_city] + dp(day + 1, next_city)
                result = max(result, current)
            
            return result
        
        return max(
            dp(0, city)
            for city in range(n)
        )
    
# 2
# 1
# [[1,1]]
# [[0,1],[6,0]]
# 6        ",1434277823
Tagir Gumerov,TigProg,668,3617,python3,"import itertools

class Solution:
    def possibleStringCount(self, word: str) -> int:
        result = 1
        for _, it in itertools.groupby(word):
            l = sum(1 for _ in it)
            result += l - 1
        return result",1434261018
Adyant03,Adyant03,670,3576,cpp,"#include <vector>
#include <unordered_map>
#include <functional>
using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();

        // Adjacency list representation of the tree
        vector<vector<int>> adj(n);
        vector<int> answer(n, 1);  // Initialize all subtree sizes to 1

        // Build the tree from the parent array
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);  // Corrected line
        }

        // New parent array after reassignments based on the character string 's'
        vector<int> newParent = parent;
        unordered_map<char, vector<int>> lastSeen;

        // DFS function to reassign parents based on character matching
        function<void(int)> reassignParents = [&](int node) {
            char c = s[node];

            // If the character has been seen before, update the new parent
            if (!lastSeen[c].empty()) {
                newParent[node] = lastSeen[c].back();
            }
            lastSeen[c].push_back(node);

            // Recursively process children
            for (int child : adj[node]) {
                reassignParents(child);
            }

            // Backtrack to maintain DFS consistency
            lastSeen[c].pop_back();
        };

        // Start reassigning parents from the root node (0)
        reassignParents(0);

        // Build a new adjacency list using the reassigned parents
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);  // Corrected parenthesis here
        }

        // DFS function to compute subtree sizes
        function<int(int)> computeSubtreeSizes = [&](int node) {
            int size = 1;

            // Recursively calculate sizes of all child subtrees
            for (int child : newAdj[node]) {
                size += computeSubtreeSizes(child);
            }

            answer[node] = size;
            return size;
        };

        // Compute subtree sizes starting from the root node (0)
        computeSubtreeSizes(0);

        return answer;
    }
};
",1434334320
Adyant03,Adyant03,670,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Initialize the DP table with all zeros
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        // Fill the DP table for each day
        for (int day = 0; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                // Stay in the same city
                dp[day + 1][curr] = max(dp[day + 1][curr], dp[day][curr] + stayScore[day][curr]);

                // Travel to other cities
                for (int dest = 0; dest < n; dest++) {
                    if (curr != dest) {  // Only travel if not staying in the same city
                        dp[day + 1][dest] = max(dp[day + 1][dest], dp[day][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }

        // Find the maximum points on the last day
        int maxPoints = 0;
        for (int city = 0; city < n; city++) {
            maxPoints = max(maxPoints, dp[k][city]);
        }

        return maxPoints;
    }
};
",1434339557
Adyant03,Adyant03,670,3617,cpp,"class Solution {
public:

int possibleStringCount(string word) {


    int totalCount = 1, n = word.length();


    for (int i = 0; i < n;) {
        int j = i;

        while (j < n && word [j] == word [i]) j++;
        int idx = j-i;

        if (idx > 1) totalCount += (idx - 1); i=j;


}


return totalCount;


}


};",1434325831
Ayush Mukherjee,ayushrex007,672,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        N = len(parent)
        newParent = [parent[i] for i in range(N)]
        children = [[] for _ in range(N)]
        for i in range(1, N):
            chi = i
            par = parent[chi]
            children[par].append(chi)
        lastSeen = [-1] * 26
        # print(children)
        def recur(curr):
            char = s[curr]
            idx = ord(char) - ord('a')
            anc = -1
            if lastSeen[idx] != -1:
                # print(curr, lastSeen)
                anc = lastSeen[idx]
                newParent[curr] = anc
            lastSeen[idx] = curr
            for chi in children[curr]:
                recur(chi)
            lastSeen[idx] = anc
        recur(0)
        newChildren = [[] for _ in range(N)]
        for i in range(1, N):
            chi = i
            par = newParent[i]
            newChildren[par].append(chi)
        res = [0] * N
        # print(newChildren)
        def calc(curr):
            ans = 1
            for child in newChildren[curr]:
                ans += calc(child)
            res[curr] = ans
            return ans
        calc(0)
        return res
                
        ",1434321531
Ayush Mukherjee,ayushrex007,672,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        '''
        2 * 2 * 2...k times
        each time he can go to any city out of n cities
        n * n * n ...k times
        recur(day, city) = max(recur(day + 1, same city) + stayScore, recur(day + 1, diff city) + travelScore)
        '''
        dp = {}
        def recur(day, city):
            if (day, city) in dp:
                return dp[(day, city)]
            if day >= k:
                return 0
            op1 = recur(day + 1, city) + stayScore[day][city]
            op2 = 0
            for i in range(n):
                if i != city:
                    nxtCity = i
                    op2 = max(op2, recur(day + 1, nxtCity) + travelScore[city][nxtCity])
            ans = max(op1, op2)
            dp[(day, city)] = ans
            return ans
        for i in range(n):
            recur(0, i)
        return max(dp.values())
",1434339729
Ayush Mukherjee,ayushrex007,672,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        N = len(word)
        ans = 0
        for i in range(1, N):
            if word[i] == word[i - 1]:
                ans += 1
        return ans + 1
            
        ",1434270803
parthhmishra,parthhmishra,673,3576,python3,"from typing import List, Dict
from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        num_nodes = len(parent)
        
        # Step 1: Build initial adjacency list from the parent array
        initial_tree = defaultdict(list)
        for i in range(1, num_nodes):
            initial_tree[parent[i]].append(i)
        
        # Step 2: Ancestor map for each character
        nearest_ancestor = {}  # Stores the nearest ancestor with the same character for each node
        updated_parent = parent[:]  # Copy of parent to apply re-parenting changes

        def explore(node: int):
            # Track the previous ancestor with the current character
            node_char = s[node]
            prev_ancestor = nearest_ancestor.get(node_char, None)
            
            # Update the nearest ancestor for nodes with the same character
            if prev_ancestor is not None:
                updated_parent[node] = prev_ancestor  # Change parent to the nearest matching ancestor
            
            # Update the current node as the latest ancestor for its character
            nearest_ancestor[node_char] = node
            
            # Traverse all children in the initial tree
            for child in initial_tree[node]:
                explore(child)
            
            # Restore the previous ancestor after returning from the recursion
            if prev_ancestor is not None:
                nearest_ancestor[node_char] = prev_ancestor
            else:
                del nearest_ancestor[node_char]

        # Run DFS from the root (node 0)
        explore(0)

        # Step 3: Rebuild the tree with updated parent relationships
        modified_tree = defaultdict(list)
        for i in range(1, num_nodes):
            modified_tree[updated_parent[i]].append(i)
        
        # Step 4: Calculate subtree sizes using DFS
        result = [0] * num_nodes

        def compute_size(node: int) -> int:
            # Size of the subtree rooted at this node
            subtree_size = 1
            for child in modified_tree[node]:
                subtree_size += compute_size(child)
            result[node] = subtree_size
            return subtree_size

        compute_size(0)  # Start DFS from the root node

        return result",1434329251
parthhmishra,parthhmishra,673,3587,php,"<?php
class Solution {

    /**
     * @param Integer $n            Number of cities
     * @param Integer $k            Number of days
     * @param Integer[][] $stayScore 2D array with stay scores for each day and city
     * @param Integer[][] $travelScore 2D array with travel scores between cities
     * @return Integer               Maximum points achievable after k days
     */
    function maxScore($n, $k, $stayScore, $travelScore) {
        // Initialize a 2D array for dp with (k+1) rows and n columns, filled with zeros
        $dp = array_fill(0, $k + 1, array_fill(0, $n, 0));
        
        // Iterate through each day
        for ($day = 0; $day < $k; $day++) {
            for ($curr = 0; $curr < $n; $curr++) {
                // Calculate stay score
                $dp[$day + 1][$curr] = max($dp[$day + 1][$curr], $dp[$day][$curr] + $stayScore[$day][$curr]);
                
                // Calculate travel scores
                for ($dest = 0; $dest < $n; $dest++) {
                    if ($curr !== $dest) {
                        $dp[$day + 1][$dest] = max($dp[$day + 1][$dest], $dp[$day][$curr] + $travelScore[$curr][$dest]);
                    }
                }
            }
        }
        
        // Find the maximum points on the last day
        $maxPoints = 0;
        for ($city = 0; $city < $n; $city++) {
            $maxPoints = max($maxPoints, $dp[$k][$city]);
        }
        
        return $maxPoints;
    }
}

?>
",1434339815
parthhmishra,parthhmishra,673,3617,python3,"class Solution:
    def possibleStringCount(self, text: str) -> int:
        segments = []
        index = 0
        
        # Step 1: Create segments of consecutive characters
        while index < len(text):
            begin = index
            while index + 1 < len(text) and text[index] == text[index + 1]:
                index += 1
            segments.append(text[begin:index + 1])  # Append the entire segment
            index += 1
        
        # Step 2: Calculate the total variations
        total_variations = 1  # The original text itself
        for segment in segments:
            if len(segment) > 1:
                # Adding variations by removing one character from this segment
                total_variations += len(segment) - 1
        
        return total_variations",1434328893
Vipul Sharma,vipul19,675,3576,cpp,"class Solution {
private:
    vector<int> graph[100005];
    int hsh[26];
    vector<int> nparent;
    void dfs(int node, string& s) {
        int pos = s[node] - 'a';
        if (hsh[pos] != -1) { 
            nparent[node] = hsh[pos];
        }

        int prev = hsh[pos];
        hsh[pos] = node;
        for (auto x : graph[node]) {
            dfs(x, s);
        }
        hsh[pos] = prev;
    }

    vector<int> sb;

    void solve(int node) {
        sb[node] = 1;
        for (auto x : graph[node]) {
            solve(x);
            sb[node] += sb[x];
        }
    }
 
    
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        nparent.resize(n);
        for (int i = 0; i < n; ++i) {
            graph[i].clear();
            nparent[i] = parent[i];
        }

        memset(hsh, -1, sizeof hsh);

        for (int i = 1; i < n; ++i) {
            graph[parent[i]].push_back(i);
        }

        dfs (0, s);
        sb.clear();
        sb.resize(n, 0);
        for (int i = 0; i < n; ++i) {
            graph[i].clear();
        }
        for (int i = 1; i < n; ++i) {
            graph[nparent[i]].push_back(i);
        }

        solve(0);

        return sb;
    }
};",1434308211
Vipul Sharma,vipul19,675,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {

        int dp[k][n];
        memset(dp, 0, sizeof dp);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i == j) {
                    dp[0][j] = max (dp[0][j], stayScore[0][i]);
                } else {
                    dp[0][j] = max (dp[0][j], travelScore[i][j]);
                }
            }
        }

        for (int i = 1; i < k; ++i) {
            for (int p = 0; p < n; ++p) {
                for (int q = 0; q < n; ++q) {
                    if (p == q) {
                        dp[i][q] = max (dp[i][q], dp[i - 1][q] + stayScore[i][q]);
                    } else {
                        dp[i][q] = max (dp[i][q], dp[i - 1][p] + travelScore[p][q]);
                    }
                }
            }
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans = max (ans, dp[k - 1][i]);
        }
        return ans;
    }
};",1434339886
Vipul Sharma,vipul19,675,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        vector<pair<char, int>> v;
        for (int i = 0; i < n; ++i) {
            char c = word[i];
            if (!v.size() || v[v.size() - 1].first != c) {
                v.push_back({c, 1});
            } else {
                v[v.size() - 1].second += 1;
            }
        }
        set<string> ans;
        string x = """";
        for (int i = 0; i < v.size(); ++i) {
            int cnt = v[i].second;
            string y = """";
            for (int j = i + 1; j < v.size(); ++j) {
                int ncnt = v[j].second;
                while (ncnt--) {
                    y += v[j].first;
                }
            }
            while (cnt--) {
                x += v[i].first;
                ans.insert(x + y);
            }
        }
        return ans.size();
    }
};",1434278397
viditgupta7001,viditgupta7001,676,3576,cpp,"class Solution {
public:
    void dfs(int node,vector<vector<int>>&adj,string &s,vector<int>&x,vector<vector<int>>&new_adj){
        int prev = x[s[node]-'a'];
        x[s[node]-'a'] = node;
        for(auto i:adj[node]){
            if(x[s[i]-'a']!=-1 && s[i]!=s[node]){
                new_adj[x[s[i]-'a']].push_back(i);
            }
            else{
                new_adj[node].push_back(i);
            }
            dfs(i,adj,s,x,new_adj);
        }
        x[s[node]-'a'] = prev;
    }
    int dfs_calc(int node,vector<vector<int>>&new_adj,vector<int>&ans){
        ans[node] = 1;
        for(auto i:new_adj[node]){
            dfs_calc(i,new_adj,ans);
            ans[node]+=ans[i];
        }
        return ans[node];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int>ans(n);
        vector<vector<int>>adj(n),new_adj(n);
        for(int i=0;i<n;i++){
            if(parent[i]!=-1){
                adj[parent[i]].push_back(i);
            }
        }
        vector<int>x(26,-1);
        dfs(0,adj,s,x,new_adj);
        dfs_calc(0,new_adj,ans);
        return ans;
    }
};",1434307783
viditgupta7001,viditgupta7001,676,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));

        for (int day = 1; day <= k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day][curr] = max(dp[day][curr],dp[day - 1][curr] + stayScore[day - 1][curr]);
                for (int dest = 0; dest < n; dest++) {
                    if (dest != curr) {
                        dp[day][dest] = max(dp[day][dest], dp[day - 1][curr] + travelScore[curr][dest]);
                    }
                }
            }
        }

        int maxi = 0;
        for (int city = 0; city < n; city++) {
            maxi = max(maxi, dp[k][city]);
        }

        return maxi;
    }
};",1434333183
viditgupta7001,viditgupta7001,676,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int count = 0,i = 0;
        while(i<n){
            char c = word[i];
            int x = 0;
            while(c==word[i]){
                i++;
                x++;
            }
            count+=(x-1);
        }
        return count+1;
    }
};",1434261827
Mr Stark,MrStark8891,678,3576,cpp,"class Solution {
  
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
      int n = parent.size();
      vector<vector<int>> adjacent(n);
      vector<int> res(n, 1);
      
      for(int i = 1; i<n; i++) {
        adjacent[parent[i]].push_back(i);
      }
      
      vector<int> new_parent = parent;
      unordered_map<char, vector<int>> vis;
      function<void(int)> comp = [&](int node) {
        char ch = s[node];
        if(!vis[ch].empty()) 
          new_parent[node] = vis[ch].back();
        vis[ch].push_back(node);
        for(int child : adjacent[node]) {
          comp(child);
        }
        vis[ch].pop_back();
      };
      
      comp(0);
      vector<vector<int>> new_adjacent(n);
      
      for(int i = 1; i<n; i++) {
        new_adjacent[new_parent[i]].push_back(i);
      }
      function<int(int)> sub_tree_size = [&] (int node) {
        int sz = 1;
        for(int child : new_adjacent[node]) sz += sub_tree_size(child);
        res[node] = sz;
        return sz;
      };
      sub_tree_size(0);
      return res;
    }
};",1434327888
Mr Stark,MrStark8891,678,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
      vector<vector<int>> dp(k+1, vector<int>(n,0));
      for(int i = 0; i<k; i++) {
        for(int j = 0; j<n; j++) {
          dp[i+1][j] = max(dp[i+1][j], dp[i][j] + stayScore[i][j]);
          for(int l = 0; l<n; l++) {
            if(j != l) {
              dp[i+1][l] = max(dp[i+1][l], dp[i][j] + travelScore[j][l]);
            }
          }
        }
      }
      int max_points = 0;
      for(int i = 0; i<n; i++) {
        max_points = max(max_points, dp[k][i]);
      }
      return max_points;
    }
};",1434340065
Mr Stark,MrStark8891,678,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res = 0;
        for(int i = 1; i<word.size(); i++) {
            if(word[i] == word[i-1])
                res++;
        }
        return res+1;
    }
};",1434294647
Aniket Yadav,its_anii,679,3576,cpp,"

class Solution {
public:
    void dfs(int node, vector<vector<int>>& adj, vector<int>& vis, vector<int>& ch, vector<int>& parent, string& s) {
        vis[node] = 1;
        int prev_parent = ch[s[node] - 'a'];
        
        if (prev_parent != -1) {
            parent[node] = prev_parent;
        }
        
        ch[s[node] - 'a'] = node;

        for (auto it : adj[node]) {
            if (!vis[it]) {
                dfs(it, adj, vis, ch, parent, s);
            }
        }

        ch[s[node] - 'a'] = prev_parent;
    }
    
    int dfs2(int node, vector<vector<int>>& adj, vector<int>& vis, vector<int>& ans) {
        vis[node] = 1;
        int subtree_size = 1;
        
        for (auto it : adj[node]) {
            if (!vis[it]) {
                subtree_size += dfs2(it, adj, vis, ans);
            }
        }
        
        ans[node] = subtree_size;
        return subtree_size;
    }

    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        
        vector<vector<int>> adj(n);
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        
        vector<int> vis(n, 0), ch(26, -1);
        dfs(0, adj, vis, ch, parent, s);
        
        vector<vector<int>> modified_adj(n);
        for (int i = 1; i < n; ++i) {
            modified_adj[parent[i]].push_back(i);
        }
        
        vector<int> ans(n, 0), vis2(n, 0);
        dfs2(0, modified_adj, vis2, ans);
        
        return ans;
    }
};
",1434312606
Aniket Yadav,its_anii,679,3587,cpp,"class Solution {
public:
int N;
   int f(int sc, int d,int k,vector<vector<int>>&ss,vector<vector<int>>&ts,vector<vector<int>>&dp){
       if(d==k) return 0;
       if(dp[d][sc]==-1){
           int msc=ss[d][sc]+f(sc,d+1,k,ss,ts,dp);
           for(int i=0;i<N;i++){
               if(i!=sc){
                   msc=max(msc,ts[sc][i]+f(i,d+1,k,ss,ts,dp));
               }
           }
        dp[d][sc]=msc;
       }
       return dp[d][sc];
   }
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        vector<vector<int>>dp(k+1,vector<int>(n+1,-1));
        int ans=0;
        N=n;
        for(int i=0;i<n;i++){
            ans=max(ans,f(i,0,k,ss,ts,dp));
        }
        return ans;
    }
};",1434340096
Aniket Yadav,its_anii,679,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int n=word.size();
        int c=1;
        for(int i=1;i<n;i++){
            if(word[i]==word[i-1]){
                c++;
            }
        }
        return c;
    }
};",1434266509
Chou,a0920732333,680,3576,cpp,"class Solution 
{
public:
    vector<stack<int>> vs;
    vector<unordered_set<int>> child;
    vector<unordered_set<int>> newChild;
    string ss;
    vector<int> ans;
    void preorder(int ptr, int parent)
    {
        if(!vs[ss[ptr] - 'a'].empty())
        {
            newChild[parent].erase(ptr);
            newChild[vs[ss[ptr] - 'a'].top()].insert(ptr);
        }
        vs[ss[ptr] - 'a'].push(ptr);
        for(auto& it : child[ptr])
        {
            preorder(it, ptr);
        }
        vs[ss[ptr] - 'a'].pop();
    }
    int count(int ptr)
    {
        int cnt = 1;
        for(auto& it : newChild[ptr])
        {
            cnt += count(it);
        }
        return ans[ptr] = cnt;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) 
    {
        int n = parent.size();
        vs.resize(26);
        child.resize(n);
        newChild.resize(n);
        ans.resize(n);
        ss = s;
        for(int i = 1; i < n; i++)
        {
            child[parent[i]].insert(i);
            newChild[parent[i]].insert(i);
        }
        //dfs preorder
        preorder(0, -1);
        count(0);
        return ans;
    }
};",1434322095
Chou,a0920732333,680,3587,cpp,"class Solution 
{
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) 
    {
        //day x city x point
        vector<vector<int>> dp(k, vector<int>(n));
        for(int city = 0; city < n; city++)
        {
            for(int dest = 0; dest < n; dest++)
            {
                if(city == dest)
                {
                    dp[0][dest] = max(dp[0][dest], stayScore[0][dest]);
                }
                else
                {
                    dp[0][dest] = max(dp[0][dest], travelScore[city][dest]);
                }
            }
        }
        for(int day = 1; day < k; day++)
        {
            for(int city = 0; city < n; city++)
            {
                for(int dest = 0; dest < n; dest++)
                {
                    if(city == dest)
                    {
                        dp[day][dest] = max(dp[day][dest], dp[day - 1][dest] + stayScore[day][dest]);
                    }
                    else
                    {
                        dp[day][dest] = max(dp[day][dest], dp[day - 1][city] + travelScore[city][dest]);
                    }
                }
            }
        }
        int ans = 0;
        for(int city = 0; city < n; city++)
        {
            ans = max(ans, dp[k - 1][city]);
        }
        return ans;
    }
};",1434340170
Chou,a0920732333,680,3617,cpp,"class Solution 
{
public:
    int possibleStringCount(string word) 
    {
        int last = 0, n = word.length(), ans = 1;
        for(int i = 0; i < n; i++)
        {
            if(word[i] != word[last])
            {
                ans += i - last - 1;
                last = i;
            }
        }
        ans += n - last - 1;
        return ans;
    }
};",1434268660
Sachin Bulchandani,sbulchandani18,681,3576,cpp,"class Solution {
public:

    void dfs(int p,int q,vector<vector<int>> &u,vector<int> &ans){
          for(auto k: u[p]){
              dfs(k,p,u,ans);
              ans[p]+=ans[k];
          }
        ans[p]++;
    }

    void func(int p,int q,vector<vector<int>> &v,vector<vector<int>> &u,vector<int> &arr,string &s){
          int x=arr[s[p]-'a'];
         
          if(arr[s[p]-'a']!=-1){
              u[x].push_back(p);
          }
          else{
              if(q!=-1){
                  u[q].push_back(p);
              }
          }
           arr[s[p]-'a']=p;

        for(auto k: v[p]){
            func(k,p,v,u,arr,s);
        }

        arr[s[p]-'a']=x;
     
    }
    vector<int> findSubtreeSizes(vector<int>& par, string s) {
        int i,n=s.size();
        vector<vector<int>> v(n),u(n);
        
        for(i=1;i<n;i++){
            v[par[i]].push_back(i);
        }
        vector<int> arr(27,-1),ans(n,0);
        func(0,-1,v,u,arr,s);

        dfs(0,-1,u,ans);
        return ans;
    }
};",1434308895
Sachin Bulchandani,sbulchandani18,681,3587,cpp,"class Solution {
public:
     int dp[202][202];
     int func(int i,int k,vector<vector<int>>& a, vector<vector<int>>& b,int x){
         if(k==x) return 0;

         if(dp[i][k]!=-1) return dp[i][k];

         int ans=func(i,k+1,a,b,x)+a[k][i];

         for(int j=0;j<b[0].size();j++){
             ans=max(ans,func(j,k+1,a,b,x)+b[i][j]);
         }
         return dp[i][k]=ans;
     }
    int maxScore(int n, int k, vector<vector<int>>& a, vector<vector<int>>& b) {
        int i,ans=0;
        memset(dp,-1,sizeof(dp));
        for(i=0;i<n;i++){
            ans=max(ans,func(i,0,a,b,k));
        }
        return ans;
    }
};",1434340194
Sachin Bulchandani,sbulchandani18,681,3617,cpp,"class Solution {
public:
    int possibleStringCount(string s) {
        int i,ans=1,n=s.size();
        for(i=1;i<n;i++){
            if(s[i]==s[i-1]){
                int ct=0;
                while(i<n&&s[i]==s[i-1]){
                    i++;
                    ct++;
                }
                ans+=ct;
                i--;
            }
        }
        return ans;
    }
};",1434269725
Shaileshwaran,Shailesh714,682,3576,python3,"from typing import List, Dict

class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        chld = [[] for _ in range(n)]
        for i in range(1, n):
            chld[parent[i]].append(i)
        def update_parents(node: int, ansChar: Dict[str, int]):
            curr = s[node]
            if curr in ansChar:
                parent[node] = ansChar[curr]
            ansprev = ansChar.get(curr)
            ansChar[curr] = node

            for child in chld[node]:
                update_parents(child, ansChar)
            if ansprev is None:
                del ansChar[curr]
            else:
                ansChar[curr] = ansprev
        update_parents(0, {})
        new_chld = [[] for _ in range(n)]
        for i in range(1, n):
            new_chld[parent[i]].append(i)
        subsizes = [0] * n
        def calculate_subsizes(node: int) -> int:
            subsize = 1 
            for child in new_chld[node]:
                subsize += calculate_subsizes(child)
            subsizes[node] = subsize
            return subsize
        calculate_subsizes(0)
        return subsizes
",1434275416
Shaileshwaran,Shailesh714,682,3587,python3,"
class Solution:
    def maxScore(self, n: int, k: int, stayScore: list[list[int]], travelScore: list[list[int]]) -> int:
        dp = [[0] * n for _ in range(k + 1)]

        for dy in range(k):
            for x in range(n):
                dp[dy + 1][x] = max(dp[dy + 1][x], dp[dy][x] + stayScore[dy][x])
                for dest in range(n):
                    if x != dest:
                        dp[dy + 1][dest] = max(dp[dy + 1][dest], dp[dy][x] + travelScore[x][dest])

        maxPoints = 0
        for city in range(n):
            maxPoints = max(maxPoints, dp[k][city])

        return maxPoints",1434340250
Shaileshwaran,Shailesh714,682,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        grplen = []
        n = len(word)
        i = 0
        while i < n:
            j = i
            while j < n and word[j] == word[i]:
                j += 1
            grplen.append(j - i)
            i = j
        total = 1 
        for length in grplen:
            total += (length - 1) 

        return total
",1434266278
himabindu40,himabindu40,683,3576,cpp,"#include <vector>
#include <string>
#include <unordered_map>
#include <stack>

class Solution {
public:
    std::vector<int> findSubtreeSizes(std::vector<int>& parent, std::string s) {
        int n = parent.size();
        std::vector<std::vector<int>> adj(n); // Initial adjacency list
        std::vector<int> answer(n, 1); // Subtree sizes initialized to 1 for each node itself

        // Build initial adjacency list based on parent relationships
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }

        // Stack-based map to track latest ancestors by character
        std::unordered_map<char, std::stack<int>> latestAncestor;
        std::vector<int> newParent(n, -1); // Stores new parents after adjustments

        // DFS to set the new parent for each node based on character match
        std::function<void(int)> dfsAdjust = [&](int node) {
            char c = s[node];

            // If stack for this character is not empty, get the nearest ancestor
            if (!latestAncestor[c].empty()) {
                newParent[node] = latestAncestor[c].top();
            } else {
                newParent[node] = parent[node]; // Keep original parent if no matching ancestor
            }

            // Push this node as the latest ancestor for its character
            latestAncestor[c].push(node);

            // Traverse children
            for (int child : adj[node]) {
                dfsAdjust(child);
            }

            // Pop this node after backtracking
            latestAncestor[c].pop();
        };

        // Start DFS from root to set new parents
        dfsAdjust(0);

        // Construct new adjacency list based on adjusted parents in newParent
        std::vector<std::vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            int newParentNode = newParent[i];
            newAdj[newParentNode].push_back(i);
        }
        adj = std::move(newAdj);

        // DFS to calculate subtree sizes using the updated tree structure
        std::function<int(int)> dfsSize = [&](int node) {
            int size = 1;
            for (int child : adj[node]) {
                size += dfsSize(child);
            }
            answer[node] = size;
            return size;
        };

        // Calculate subtree sizes starting from the root
        dfsSize(0);

        return answer;
    }
};

",1434290728
himabindu40,himabindu40,683,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        std::vector<std::vector<int>> dp(k, std::vector<int>(n, 0));
        
        // Initialize dp for day 0, considering both stay and travel from any city
        for (int city = 0; city < n; ++city) {
            dp[0][city] = stayScore[0][city];
            for (int prevCity = 0; prevCity < n; ++prevCity) {
                if (prevCity != city) {
                    dp[0][city] = std::max(dp[0][city], travelScore[prevCity][city]);
                }
            }
        }
        
        // Dynamic programming transition for days 1 to k-1
        for (int day = 1; day < k; ++day) {
            for (int city = 0; city < n; ++city) {
                // Staying in the current city
                dp[day][city] = dp[day - 1][city] + stayScore[day][city];
                
                // Traveling from any previous city to the current city
                for (int prevCity = 0; prevCity < n; ++prevCity) {
                    if (prevCity != city) {
                        dp[day][city] = std::max(dp[day][city], dp[day - 1][prevCity] + travelScore[prevCity][city]);
                    }
                }
            }
        }
        
        // Find the maximum score on the last day across all cities
        int maxPoints = 0;
        for (int city = 0; city < n; ++city) {
            maxPoints = std::max(maxPoints, dp[k - 1][city]);
        }
        
        return maxPoints;
    }
};",1434304933
himabindu40,himabindu40,683,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
         int n = word.length();
        std::vector<int> groups;
        int i = 0;

        // Step 1: Group consecutive identical characters
        while (i < n) {
            int count = 1;
            while (i + 1 < n && word[i] == word[i + 1]) {
                count++;
                i++;
            }
            groups.push_back(count);
            i++;
        }

        // Step 2: Calculate possibilities
        int totalPossibilities = 1;  // The original string as it is
        for (int count : groups) {
            if (count > 1) {
                totalPossibilities += count - 1;  // Variations by reducing group size by 1
            }
        }

        return totalPossibilities;
    }
};
  ",1434296388
NormalMan,syc123,684,3576,java,"class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int[] result = new int[parent.length], newParent = Arrays.copyOf(parent, parent.length), prev = new int[26];
        Arrays.fill(prev, -1);
        List<List<Integer>> graph = buildGraph(parent);
        traverse(graph, 0, s, newParent, prev);

        int[] indegree = new int[parent.length];
        for (int i = 0; i < parent.length; i++) {
            int temp = newParent[i];
            if (temp != -1) {
                indegree[temp]++;
            }
        }
        LinkedList<Integer> l = new LinkedList<>();
        for (int i = 0; i < parent.length; i++) {
            if (indegree[i] == 0) {
                l.add(i);
            }
        }

        while (!l.isEmpty()) {
            int size = l.size();
            for (int i = 0; i < size; i++) {
                int top = l.removeFirst(), currentParent = newParent[top];
                result[top]++;

                if (currentParent != -1) {
                    indegree[currentParent]--;
                    result[currentParent] += result[top];
                    if (indegree[currentParent] == 0) {
                        l.add(currentParent);
                    }
                }
            }
        }
        return result;
    }

    private void traverse(List<List<Integer>> graph, int index, String s, int[] newParent, int[] prev) {
        int c = s.charAt(index) - 'a', prevChar = prev[c];
        if (prevChar != -1) {
            newParent[index] = prevChar;
        }
        
        prev[c] = index;
        for (int child : graph.get(index)) {
            traverse(graph, child, s, newParent, prev);
        }
        prev[c] = prevChar;
    }

    private List<List<Integer>> buildGraph(int[] parent) {
        int n = parent.length;
        List<List<Integer>> graph = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }

        for (int i = 1; i < n; i++) {
            int parentNode = parent[i], childNode = i;
            graph.get(parentNode).add(childNode);
        }
        return graph;
    }
}",1434326659
NormalMan,syc123,684,3587,java,"class Solution {
    int[][] memo;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        memo = new int[n + 1][k];
        for (int[] m : memo) {
            Arrays.fill(m, -1);
        }

        int result = 0;
        for (int i = 0; i < n; i++) {
            result = Math.max(result, dp(0, i, k, stayScore, travelScore));
        }
        return result;
    }

    private int dp(int day, int city, int k, int[][] stayScore, int[][] travelScore) {
        if (day >= k) {
            return 0;
        }

        if (memo[city][day] != -1) {
            return memo[city][day];
        }

        int result = stayScore[day][city] + dp(day + 1, city, k, stayScore, travelScore);
        for (int i = 0; i < travelScore.length; i++) {
            if (i == city) {
                continue;
            }
            result = Math.max(
                result,
                travelScore[city][i] + dp(day + 1, i, k, stayScore, travelScore)
            );
        }
        memo[city][day] = result;
        return result;
    }
}",1434340272
NormalMan,syc123,684,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int result = 1, left = 0, right = 0;
        while (right < word.length()) {
            char c = word.charAt(left);
            while (right < word.length() && word.charAt(right) == c) {
                right++;
            }
            result += (right - left - 1);
            left = right;
        }
        return result;
    }
}",1434293810
Md Adnan Khan,be_default,685,3576,java,"class Solution {
    public int [] findSubtreeSizes(int[] parent, String s ) {
        int n = parent.length;
        List<List<Integer>> adj = new ArrayList<>(n);
        int [] answer = new int[n];
        Arrays.fill(answer,1);
        
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }
        for (int i = 1; i < n; ++i) {
            adj.get(parent[i]).add(i);
        }

        List<Integer> newParent = new ArrayList<>();
        for(int i:parent)
            newParent.add(i);
        HashMap<Character, List<Integer>> lastSeen = new HashMap<>();

        reassignParents(0, s, adj, newParent, lastSeen);

        List<List<Integer>> newAdj = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            newAdj.add(new ArrayList<>());
        }
        for (int i = 1; i < n; ++i) {
            newAdj.get(newParent.get(i)).add(i);
        }

        computeSubtreeSizes(0, newAdj, answer);

        return answer;
    }

    private void reassignParents(int node, String s, List<List<Integer>> adj,
                                 List<Integer> newParent, Map<Character, List<Integer>> lastSeen) {
        char c = s.charAt(node);
        if (!lastSeen.containsKey(c)) {
            lastSeen.put(c, new ArrayList<>());
        }
        if (!lastSeen.get(c).isEmpty()) {
            newParent.set(node, lastSeen.get(c).get(lastSeen.get(c).size() - 1));
        }
        lastSeen.get(c).add(node);

        for (int child : adj.get(node)) {
            reassignParents(child, s, adj, newParent, lastSeen);
        }

        lastSeen.get(c).remove(lastSeen.get(c).size() - 1);
    }

    private int computeSubtreeSizes(int node, List<List<Integer>> newAdj, int [] answer) {
        int size = 1;
        for (int child : newAdj.get(node)) {
            size += computeSubtreeSizes(child, newAdj, answer);
        }
        answer[node]= size;
        return size;
    }
}",1434317917
Md Adnan Khan,be_default,685,3587,java,"class Solution {
    private int[][] memo;

    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        memo = new int[k + 1][n];
        for (int[] row : memo) Arrays.fill(row, -1);

        int maxPoints = 0;

        for (int city = 0; city < n; city++) {
            maxPoints = Math.max(maxPoints, maxScoreFrom(city, 0, k, n, stayScore, travelScore));
        }

        return maxPoints;
    }

    private int maxScoreFrom(int city, int day, int k, int n, int[][] stayScore, int[][] travelScore) {

        if (day == k) {
            return 0;
        }


        if (memo[day][city] != -1) {
            return memo[day][city];
        }


        int maxPoints = 0;


        maxPoints = maxScoreFrom(city, day + 1, k, n, stayScore, travelScore) + stayScore[day][city];

        for (int dest = 0; dest < n; dest++) {
            if (dest != city) {
                maxPoints = Math.max(maxPoints, maxScoreFrom(dest, day + 1, k, n, stayScore, travelScore) + travelScore[city][dest]);
            }
        }


        memo[day][city] = maxPoints;
        return maxPoints;
    }
    
}",1434340516
Md Adnan Khan,be_default,685,3617,java,"class Solution {
     public int possibleStringCount(String word) {

        int count =1;
        int n=word.length();
        for(int i=1;i<n;i++){
            if(word.charAt(i-1)==word.charAt(i)){
                count++;
            }
        }
        return count;
        
    }
}",1434268254
kesshb,kesshb,686,3576,java,"class Solution {

  public static void main(String... args) {
    Solution solution = new Solution();
    int[] parent = new int[]{-1,0,0,1,1,1};
    String s = ""abaabc"";
    int[] result = solution.findSubtreeSizes(parent, s);
    System.out.println(Arrays.toString(result));
  }

  public int[] findSubtreeSizes(int[] parent, String s) {
    int n = parent.length;
    int[] subtreeSizes = new int[n];
    int[] latest = new int[26];
    Arrays.fill(latest, -1);
    List<Set<Integer>> adj = new ArrayList<>();
    for (int i = 0; i < n; i++) {
      adj.add(new HashSet<>());
    }
    for (int i = 0; i < parent.length; i++) {
      if (parent[i] == -1) {
        continue;
      }
      adj.get(parent[i]).add(i);
    }
    dfs(adj, -1, 0, latest, s);
    subtrees(0, adj, subtreeSizes);
    return subtreeSizes;
  }

  private void dfs(List<Set<Integer>> adj, int p, int curr, int[] latest, String s) {
    char c = s.charAt(curr);
    if (latest[c - 'a'] != -1) {
      adj.get(p).remove(curr);
      adj.get(latest[c - 'a']).add(curr);
    }
    int tmp = latest[c - 'a'];
    latest[c - 'a'] = curr;
    Set<Integer> copy = new HashSet<>(adj.get(curr));
    for (int next : copy) {
      dfs(adj, curr, next, latest, s);
    }
    latest[c - 'a'] = tmp;
  }

  private void subtrees(int curr, List<Set<Integer>> adj, int[] subtreeSizes) {
    subtreeSizes[curr] = 1;
    for (int next : adj.get(curr)) {
      subtrees(next, adj, subtreeSizes);
      subtreeSizes[curr] += subtreeSizes[next];
    }
  }
}",1434298679
kesshb,kesshb,686,3587,java,"class Solution {

  public static void main(String... args) {
    Solution solution = new Solution();
    int n = 2;
    int k = 1;
    int[][] stayScore = new int[][]{{1, 1}};
    int[][] travelScore = new int[][]{{0, 1}, {6,0}};
    System.out.println(solution.maxScore(n, k, stayScore, travelScore));
  }

  int[][] stayScore;
  int[][] travelScore;
  int n;
  int k;
  int[][] dp;

  public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
    this.stayScore = stayScore;
    this.travelScore = travelScore;
    this.n = n;
    this.k = k;
    dp = new int[n][k+1];
    for (int i = 0; i < n; i++) {
      Arrays.fill(dp[i], -1);
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      ans = Math.max(ans, dp(i, 0));
    }
    return ans;
  }

  private int dp(int prev, int day) {
    if (day == k) {
      return 0;
    }
    if (dp[prev][day] != -1) {
      return dp[prev][day];
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
      if (i == prev) {
        ans = Math.max(ans, stayScore[day][i] + dp(i, day + 1));
      } else {
        ans = Math.max(ans, travelScore[prev][i] + dp(i, day + 1));
      }
    }
    return dp[prev][day] = ans;
  }
}",1434333809
kesshb,kesshb,686,3617,java,"
class Solution {

  public static void main(String... args) {

  }

  public int possibleStringCount(String word) {
    int res = 1;
    int curr = 0;
    char currC = ' ';
    for (char c : word.toCharArray()) {
      if (c == currC) {
        curr++;
      } else {
        res += curr - 1;
        curr = 1;
        currC = c;
      }
    }
    return res + curr;
  }
}",1434266540
Pranav V,user1396OP,687,3576,cpp,"class Solution {
    int n;
    vector<vector<int>> adj;
    vector<stack<int>> stak;
    vector<int> res;
    void dfs(vector<int> &parent, string &s, int i){
        stak[s[i]-'a'].push(i);
        for(int &j:adj[i])
            if(j!=parent[i])
                dfs(parent,s,j);
        stak[s[i]-'a'].pop();
        if(!stak[s[i]-'a'].empty())
            parent[i]=stak[s[i]-'a'].top();
    }
    int calc(int i,int j){
        int cnt=1;
        for(int &k:adj[i])
            if(k!=j)
                cnt+=calc(k,i);
        res[i]=cnt;
        return cnt;
    }
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n=s.length();
        adj.resize(n);
        stak.resize(26);
        res.resize(n);
        for(int i=1;i<n;i++){
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        dfs(parent,s,0);
        adj=vector<vector<int>> (n);
        for(int i=1;i<n;i++){
            adj[i].push_back(parent[i]);
            adj[parent[i]].push_back(i);
        }
        calc(0,-1);
        return res;
    }
};",1434303337
Pranav V,user1396OP,687,3587,cpp,"class Solution {
    vector<vector<int>> dp;//dp[i][j]->score when you're at city i and on day j
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        dp.resize(n,vector<int>(k--));
        for(int i=0;i<n;i++){
            int m=*max_element(travelScore[i].begin(),travelScore[i].end());
            dp[i][k]=max(m,stayScore[k][i]);
        }
        while(k-->0){
            for(int i=0;i<n;i++){
                int m=stayScore[k][i]+dp[i][k+1];
                for(int j=0;j<n;j++)
                    if(j!=i)
                        m=max(m,travelScore[i][j]+dp[j][k+1]);
                dp[i][k]=m;
            }
        }
        int res=0;
        for(int i=0;i<n;i++)
            res=max(res,dp[i][0]);
        return res;
    }
};",1434340619
Pranav V,user1396OP,687,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int count=1;
        for(int i=1;i<word.length();i++)
            if(word[i]==word[i-1])
                count++;
        return count;
    }
};",1434263769
Mohit Kanodia,yoda_codiyapa,688,3576,java,"class Solution {

    int INT_MAX = Integer.MAX_VALUE;

    public int[] findSubtreeSizes(int[] parent, String s) {

        int n = parent.length;

        int[] c = new int[26];
        Arrays.fill(c, -1);

        int[] pn = Arrays.copyOf(parent, n);
        List<List<Integer>> l = buildUndirAdjListParent(n, parent);
        dfs(0, -1, l, c, s, pn);
        // u.pa(parent);
        // u.pa(pn);

        // subtree sizes
        List<List<Integer>> l2 = buildUndirAdjListParent(n, pn);
        int[] subtree = new int[n];
        dfs_sub(0, -1, l2, subtree);
        return subtree;
    }

    void dfs(int c, int p, List<List<Integer>> l, int[] cn, String s, int[] pn) {
        if (cn[s.charAt(c) - 'a'] != -1) {
            pn[c] = cn[s.charAt(c) - 'a'];
        }

        int[] nx = Arrays.copyOf(cn, 26);
        nx[s.charAt(c) - 'a'] = c;

        for (int e : l.get(c)) {
            if (e == p) {
                continue;
            }
            dfs(e, c, l, nx, s, pn);
        }
    }

    void dfs_sub(int c, int parent, List<List<Integer>> map, int[] subtree) {
        int ans = 0;
        for (int neigh : map.get(c)) {
            if (neigh == parent) {
                continue;
            }

            dfs_sub(neigh, c, map, subtree);
            ans += subtree[neigh];
        }

        subtree[c] = ans + 1;
    }

    public List<List<Integer>> buildUndirAdjListParent(int n, int[] p) {
        List<List<Integer>> adjlist = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adjlist.add(new ArrayList<>());
        }

        for (int i = 1; i < n; i++) {
            int a = i;
            int b = p[i];

            adjlist.get(a).add(b);
            adjlist.get(b).add(a);
        }

        return adjlist;
    }
}",1434301857
Mohit Kanodia,yoda_codiyapa,688,3587,java,"class Solution {

    int n;
    int k;
    int[][] ss;
    int[][] ts;
    int[][] dp;
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.n = n;
        this.k = k;
        this.ss = stayScore;
        this.ts = travelScore;
        this.dp = new int[k+1][n+1];
        
        for(int[] arr : dp) {
            Arrays.fill(arr, -1);
        }
        
        int ans = 0;
        for(int i = 0; i < n; i++) {
            int curr = dp(0, i);
            ans = Math.max(curr, ans);
            // prln(""st: ""+i+"" ""+curr);
        }
        return ans;
    }

    int dp(int c, int p) {
        if(c == k) {
            return 0;
        }

        if(dp[c][p] != -1) {
            return dp[c][p];
        }

        int ans = ss[c][p] + dp(c+1, p);
        
        for(int i = 0; i < n; i++) {
            if(i == p) {
                continue;
            }
            // prln(p+"" ""+i);
            ans = Math.max(ans, ts[p][i] + dp(c+1, i));
        }
        dp[c][p]=ans;
        return ans;
    }

    void prln(Object o) {
        System.out.println(o);
    }
}",1434327130
Mohit Kanodia,yoda_codiyapa,688,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 1;
        int i = 0;
        char[] ch = word.toCharArray();
        int n = word.length();
        
        while(i < n) {
            char cc = word.charAt(i);
            int cnt = 0;
            while(i < n && word.charAt(i) == cc) {
                i++;
                cnt++;
            }
            ans += cnt-1;
        }
        return ans;
    }
}",1434266633
Joo-Won Jung,sanori,689,3576,javascript,"/**
 * @param {number[]} parent
 * @param {string} s
 * @return {number[]}
 */
var findSubtreeSizes = function(parent, s) {
  const n = parent.length;
  const children = Array(n).fill().map(() => []);
  for (let u = 1; u < n; u++) {
    children[parent[u]].push(u);
  }
  const traverse = (u = 0, ch2ans = {}, res = [-1]) => {
    const ch = s[u];
    if (ch in ch2ans) {
      res[u] = ch2ans[ch].at(-1);
      ch2ans[ch].push(u);
    } else {
      res[u] = parent[u];
      ch2ans[ch] = [u];
    }
    for (const v of children[u]) {
      traverse(v, ch2ans, res);
    }
    ch2ans[ch].pop();
    if (ch2ans[ch].length === 0) {
      delete ch2ans[ch];
    }
    return res;
  }
  const newParent = traverse(0);
  // console.log({newParent})
  const newChildren = Array(n).fill().map(() => []);
  for (let u = 1; u < n; u++) {
    newChildren[newParent[u]].push(u);
  }
  const dp = Array(n);
  const dfs = (u = 0) => {
    if (u in dp) {
      return dp[u];
    }
    let res = 1;
    for (const v of newChildren[u]) {
      res += dfs(v);
    }
    dp[u] = res;
    return res;
  }
  dfs(0);
  return dp;
};",1434317343
Joo-Won Jung,sanori,689,3587,javascript,"/**
 * @param {number} n
 * @param {number} k
 * @param {number[][]} stayScore
 * @param {number[][]} travelScore
 * @return {number}
 */
var maxScore = function(n, k, stayScore, travelScore) {
  let score = Array(n).fill(0);
  for (let d = 0; d < k; d++) {
    const next = [];
    for (let i = 0; i < n; i++) {
      next[i] = score[i] + stayScore[d][i];
      for (let j = 0; j < n; j++) {
        next[i] = Math.max(next[i], score[j] + travelScore[j][i]);
      }
    }
    score = next;
  }
  return Math.max(...score);
};",1434340862
Joo-Won Jung,sanori,689,3617,javascript,"/**
 * @param {string} word
 * @return {number}
 */
var possibleStringCount = function(word) {
  const n = word.length;
  let lastCh = word[0], lastLoc = 0, res = 0;
  for (let i = 1; i < n; i++) {
    const ch = word[i];
    if (ch !== lastCh) {
      const len = i - lastLoc;
      lastCh = ch;
      lastLoc = i;
      res += len - 1;
    }
  }
  res += n - lastLoc;
  return res;
};",1434277268
rony,rony9014,690,3576,cpp,"
class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
int n = parent.size();
        vector<vector<int>> adj(n); // Original tree adjacency list

        // Build the original tree
        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        
        vector<int> modifiedParent = parent; // Copy of the parent array to modify

        unordered_map<char, stack<int>> lastOccurrence; // Map to store the closest ancestor for each character type as a stack

        // Step 1: DFS to modify parent relationships
        function<void(int)> modifyParents = [&](int node) {
            char c = s[node];
            
            // If there's an ancestor with the same character, update the parent of this node
            if (!lastOccurrence[c].empty()) {
                modifiedParent[node] = lastOccurrence[c].top();
            }
            
            // Push the current node as the most recent occurrence of this character
            lastOccurrence[c].push(node);

            // Process all children
            for (int child : adj[node]) {
                modifyParents(child);
            }

            // Pop to backtrack, restoring the previous state for this character
            lastOccurrence[c].pop();
        };

        // Modify parents starting from the root node
        modifyParents(0);

        // Step 2: Build the new adjacency list based on modified parents
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[modifiedParent[i]].push_back(i);
        }
        
        // Step 3: Calculate subtree sizes
        vector<int> subtreeSize(n, 1);
        
        function<int(int)> calculateSizes = [&](int node) {
            for (int child : newAdj[node]) {
                subtreeSize[node] += calculateSizes(child);
            }
            return subtreeSize[node];
        };

        // Calculate subtree sizes starting from the root node
        calculateSizes(0);
        
        return subtreeSize;
    }
};
",1434275887
rony,rony9014,690,3587,cpp,"#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        // Initialize dp table with -1 values
        vector<vector<int>> dp(k + 1, vector<int>(n, -1));
        
        // Variable to store the maximum result
        int result = 0;

        // Iterate over each starting city
        for (int startCity = 0; startCity < n; ++startCity) {
            result = max(result, solve(0, startCity, k, dp, stayScore, travelScore,n));
        }
        
        return result;
    }

private:
    // Helper function for the recursive calculation
    int solve(int day, int curr, int k, vector<vector<int>>& dp, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore,int n) {
        // Base case: if we've reached the maximum number of days
        if (day == k) {
            return 0;
        }

        // Check if already computed
        if (dp[day][curr] != -1) {
            return dp[day][curr];
        }

        // Calculate points for staying in the current city
        int maxPoints = stayScore[day][curr] + solve(day + 1, curr, k, dp, stayScore, travelScore,n);

        // Consider traveling to other cities
        for (int nextCity = 0; nextCity < n; ++nextCity) {
            if (nextCity != curr) {
                maxPoints = max(maxPoints, travelScore[curr][nextCity] + solve(day + 1, nextCity, k, dp, stayScore, travelScore,n));
            }
        }

        // Store the computed result in the dp table
        dp[day][curr] = maxPoints;
        return maxPoints;
    }
};
",1434313083
rony,rony9014,690,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int c=0;
        for(int i=1;i<word.size();i++){
            if(word[i]==word[i-1]){
                c++;
            }
        }
        return c+1;
    }
};",1434266953
cartridge dog,user1031g,692,3576,cpp,"class Solution {
public:
    vector<vector<int>> adj;
    stack<int> st[26];
    void dfs(int v, vector<int>& parent, string& s) {
        int idx = s[v] - 'a';
        if (!st[idx].empty()) {
            int last = st[idx].top();
            parent[v] = last;
        }
        st[idx].push(v);
        for (int i = 0; i < adj[v].size(); ++i) {
            dfs(adj[v][i], parent, s);
        }
        st[idx].pop();
    }
    int get_size(int v, vector<int>& answer) {
        if (answer[v]) return answer[v];
        int ans = 1;
        for (const int& x: adj[v]) {
            ans += get_size(x, answer);
        }
        return answer[v] = ans;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        adj.resize(n);
        for (int i = 1; i < n; ++i) {
            int prev = parent[i];
            adj[prev].push_back(i);
        }
        dfs(0, parent, s);
        for (int i = 0; i < n; ++i) {
            adj[i].clear();
        }
        for (int i = 1; i < n; ++i) {
            int prev = parent[i];
            adj[prev].push_back(i);
        }
        vector<int> answer(n);
        get_size(0, answer);
        return answer;
    }
};",1434334338
cartridge dog,user1031g,692,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int d[202][202] = {0};
        for (int i = 0; i < n; ++i) {
            d[0][i] = stayScore[0][i];
            for (int j = 0; j < n; ++j) {
                if (i != j) {
                    d[0][i] = max(d[0][i], travelScore[j][i]);
                }
            }
        }
        for (int day = 1; day < k; ++day) {
            for (int i = 0; i < n; ++i) {
                d[day][i] = stayScore[day][i] + d[day - 1][i];
                for (int j = 0; j < n; ++j) {
                    if (i != j) {
                        d[day][i] = max(d[day][i], d[day - 1][j] + travelScore[j][i]);
                    }
                }
            }
        }
        int result = d[k - 1][0];
        for (int i = 1; i < n; ++i) {
            result = max(result, d[k - 1][i]);
        }
        return result;
    }
};",1434299410
cartridge dog,user1031g,692,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int result = 1;
        for (int i = 1; i < word.size(); ++i) {
            result += word[i] == word[i - 1];
        }
        return result;
    }
};",1434272461
6cdh,6cdh,693,3576,racket,"(define (find-subtree-sizes parent s)
  (vec! parent)
  (define n (slen s))
  (define new-parent (vector-copy parent))

  (define (build-tree parent)
    (define children (make-hash))
    (for ([(p x) (in-indexed parent)])
      (hash-update! children p ( (old) (cons x old)) '()))
    children)

  (define tree (build-tree parent))

  (define (reroot x closest)
    (define y (hash-ref closest (sref s x) -1))
    (when (not (= y -1))
      (aset! new-parent x y))
    (define new-closest (hash-set closest (sref s x) x))
    (for ([child (hash-ref tree x '())])
      (reroot child new-closest)))

  (reroot 0 (hash))

  (define new-tree (build-tree new-parent))

  (define (tree-size x)
    (add1
      (for/sum ([child (hash-ref new-tree x '())])
        (tree-size child))))

  (cachef-vec! tree-size (add1 n) -1)

  (for/list ([x n])
    (tree-size x)))


(require syntax/parse/define)

(define slen string-length)

(define sref string-ref)

(define-syntax make-array
  (syntax-rules ()
    [(_ n init)
     (build-vector n ( _ init))]
    [(_ n args ...)
     (build-vector n ( _ (make-array args ...)))]))

(define-syntax aref
  (syntax-rules ()
    [(_ arr) arr]
    [(_ arr i dims ...)
     (aref (vector-ref arr i) dims ...)]))

(define-syntax aset!
  (syntax-rules ()
    [(_ arr dim new-val)
     (vector-set! arr dim new-val)]
    [(_ arr dim1 dims ... new-val)
     (aset! (vector-ref arr dim1) dims ... new-val)]))

(define (scanl proc init lst)
  (cons init
        (for/list ([v lst])
          (set! init (proc v init))
          init)))

(define-syntax-parse-rule (cachef-vec! fn:id hints:expr ... init)
  (set! fn (cachef-vec fn hints ... init)))

(define-syntax-parser cachef-vec
  [(_ fn:id hints:expr ... init)
   (with-syntax ([(args ...) (generate-temporaries #'(hints ...))])
     #'(let* ([cache (make-array (* hints ...) init)]
              [ori-fn fn])
         (define hs (list hints ...))
         (define dims
           (cdr (reverse (scanl * 1 (reverse hs)))))

         (define (args->index . ps)
           (for/sum ([p ps]
                     [d dims])
             (* p d)))

         (lambda (args ...)
           (cond [(or (< args 0) ...
                      (>= args hints) ...)
                  (ori-fn args ...)]
                 [else
                  (define index (args->index args ...))
                  (when (equal? init (aref cache index))
                    (aset! cache index (ori-fn args ...)))
                  (aref cache index)]))))])

(define-syntax-parse-rule (vec! var:id ...)
  (let ()
    (vec1! var) ...))

(define-syntax-parse-rule (vec1! var:id)
  (set! var
        (cond [(string? var) (list->vector (string->list var))]
              [(list? var) (list->vector var)]
              [else var])))
",1434293624
6cdh,6cdh,693,3587,racket,"(define (max-score n k stayScore travelScore)
  (define stayScore1 (list2d->vector2d stayScore))
  (define travelScore1 (list2d->vector2d travelScore))
  (define cache (make-array n (add1 k) -1))

  (define (travel-from cur i)
    (if (= i k)
        0
        (for/max 0 ([dest n])
          (+ (if (= dest cur)
                 (aref stayScore1 i cur)
                 (aref travelScore1 cur dest))
             (dp dest (add1 i))))))

  (define (dp x y)
    (when (= -1 (aref cache x y))
      (aset! cache x y (travel-from x y)))
    (aref cache x y))

  (for/max 0 ([i n])
    (dp i 0)))


(define-syntax make-array
  (syntax-rules ()
    [(_ n init)
     (build-vector n ( _ init))]
    [(_ n args ...)
     (build-vector n ( _ (make-array args ...)))]))

(define-syntax aref
  (syntax-rules ()
    [(_ arr) arr]
    [(_ arr i dims ...)
     (aref (vector-ref arr i) dims ...)]))

(define-syntax aset!
  (syntax-rules ()
    [(_ arr dim new-val)
     (vector-set! arr dim new-val)]
    [(_ arr dim1 dims ... new-val)
     (aset! (vector-ref arr dim1) dims ... new-val)]))

(define (list2d->vector2d lst)
  (list->vector (map list->vector lst)))

(define-syntax-rule (for/max init-minimum-value args ... last-expr)
  (for/fold ([maxv init-minimum-value])
            args ...
    (max maxv last-expr)))

",1434320553
6cdh,6cdh,693,3617,racket,"(define (possible-string-count word)
  (define groups (group-by-sorted identity (string->list word)))
  (add1 (for/sum ([g groups])
          (sub1 (length g)))))


(define (group-by-sorted key lst [same? equal?])
  (match (length lst)
    [0 '()]
    [1 (list lst)]
    [_ (reverse
         (map reverse
              (for/fold ([res '()])
                        ([p lst]
                         [v (cdr lst)])
                (match* [res (same? (key p) (key v))]
                  [('() #t)
                   (list (list v p))]
                  [('() #f)
                   (list (list v) (list p))]
                  [((cons fst rem) #t)
                   (cons (cons v fst) rem)]
                  [(res #f)
                   (cons (list v) res)]))))]))

",1434268881
Manojkumar P,manojkumar2412,694,3576,cpp,"class Solution {
public:
    void helper(int root, vector<vector<int>>&adj, map<char,int> &closest, vector<int>&parent, string &s){
        int val=-1;
        if(closest.count(s[root]) !=0 ){
            val=closest[s[root]];
        }
        
        if( val != -1){
            parent[root]=closest[s[root]];
        }
        closest[s[root]]=root;
        for(int u: adj[root]){
            helper(u, adj, closest,parent, s);
        }
        closest[s[root]]=val;
    }
    
    int dfs(int root, vector<vector<int>> &adj, vector<int> &res){
        int children=0;
        
        for(int u: adj[root]){
            children+= dfs(u, adj, res);
        }
        children++;
        res[root]=children;
        return children;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n=s.size();
        vector<vector<int>> adj(n);
        for(int i=1;i<parent.size();i++){
            adj[parent[i]].push_back(i);
        }
        map<char,int>closest;
        
        helper(0, adj,closest, parent, s);
        adj.clear();
        adj.resize(n);
        for(int i=1;i<parent.size();i++){
            adj[parent[i]].push_back(i);
        }
        vector<int>res(n);
        
        dfs(0, adj, res);
        return res;
        
    }
};",1434299953
Manojkumar P,manojkumar2412,694,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        int dp[k+1][n+1][n+1]; // day, prev_city, curr_city
        vector<vector<int>> prev_city_max(k+1, vector<int>(n+1,0));
        memset(dp, 0, sizeof(dp));
        
        //day 1-based indexing
        for(int day=1; day<=k;day++){
            for(int prev_city=0;prev_city<n;prev_city++){
                for(int curr_city=0; curr_city<n;curr_city++){
                    int score= 0;
                    int stay_score=0;
                    int travel_score=0;
                    if(prev_city==curr_city){
                        stay_score= stayScore[day-1][prev_city];
                    }
                    else{
                        travel_score= travelScore[prev_city][curr_city];
                    }
                    score= prev_city_max[day-1][prev_city]+ stay_score + travel_score;
                    dp[day][prev_city][curr_city]= score;
                    prev_city_max[day][curr_city]= max(prev_city_max[day][curr_city], score);
                    // cout<<""day: ""<<day<<"" prev_city: ""<<prev_city<<"" curr_city: ""<<curr_city<<"" score: ""<<score<<endl;
                    // cout<<"" prev_city_max: ""<<prev_city_max[day-1][prev_city]<<"" stay_score: ""<<stay_score<<"" travel_score: ""<<travel_score<<endl;
                }
            }
        }
        
        // for(int i=1;i<=k;i++){
        //     cout<<""day: ""<<i<<endl;
        //     for(int v: prev_city_max[i]){
        //         cout<<v<<"" "";
        //     }
        //     cout<<endl;
        // }
        int res=0;
        
        for(auto i: prev_city_max){
            for(int val: i)res= max(res, val);
        }
        return res;
        
    }
};",1434334403
Manojkumar P,manojkumar2412,694,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int res=1;
        int n=word.size();
        char prev=word[0];
        for(int i=1;i<n;i++){
            if(prev==word[i])res++;
            prev=word[i];
        }
        return res;
    }
};",1434262176
Ayush Raj,_anmol_02,695,3576,cpp,"class Solution {
public:
    int n;
    vector<int> cnt,par,ans;
    vector<vector<int>> g;
    void dfs(int i,string &s) {
        if(cnt[s[i]-'a']!=-1) {
            par[i] = cnt[s[i]-'a'];
        }
        int x = cnt[s[i]-'a'];
        cnt[s[i]-'a'] = i;
        for(auto v:g[i]) {
            dfs(v,s);
        }
        cnt[s[i]-'a'] = x;
    }
    int subCount(int i) {
        ans[i]=1;
        for(auto v:g[i]) {
            ans[i]+=subCount(v);
        }
        return ans[i];
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        n = parent.size();
        par.resize(n,0);
        g.resize(n);
        ans.assign(n,1);
        for(int i=0;i<n;i++) par[i]=i;
        for(int i=0;i<n;i++) {
            par[i]=parent[i];
            if(i) g[parent[i]].push_back(i); 
        }
        par[0]=0;
        cnt.assign(26,-1);
        dfs(0,s);
        // for(int i=0;i<n;i++) {
        //     cout<<par[i]<<endl;
        // }
        g.clear();
        g.resize(n);
        for(int i=0;i<n;i++) {
            if(i) g[par[i]].push_back(i); 
        }
        subCount(0);
        return ans;
    }
};",1434314897
Ayush Raj,_anmol_02,695,3587,cpp,"class Solution {
public:
    int dp[205][205],K,n;
    int rec(int i,int k,vector<vector<int>>& stayScore,vector<vector<int>>& travelScore) {
        if(k==K) return 0;
        if(dp[i][k]!=-1) return dp[i][k];
        int ans = stayScore[k][i]+rec(i,k+1,stayScore,travelScore);
        for(int j=0;j<n;j++) {
            if(j!=i) ans = max(ans,travelScore[i][j]+rec(j,k+1,stayScore,travelScore));
        }
        return dp[i][k]=ans;
    }
    int maxScore(int m, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        K = k;
        n = m;
        int ans = 0;
        memset(dp,-1,sizeof(dp));
        for(int i=0;i<n;i++) {
            ans = max(ans,rec(i,0,stayScore,travelScore));
        }
        return ans;
    }
};",1434334440
Ayush Raj,_anmol_02,695,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        for(int i=0;i<word.length();i++) {
            char c = word[i];
            int cnt = 0;
            while(i<word.length() && word[i]==c) {
                i++;
                cnt++;
            }
            i--;
            // cout<<cnt-1<<endl;
            ans+=cnt-1;
        }
        return ans;
    }
};",1434267695
yashwanth73,yashwanth73,696,3576,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int[] findSubtreeSizes(int[] parent, String s) {
        int n = parent.length;
        char[] arr = s.toCharArray();
        int[] nums = new int[26];
        List<List<Integer>> list = new ArrayList<>();
        for(int i=0;i<n;i++) {
            list.add(new ArrayList<>());
        }
        for(int i=1;i<n;i++) {
            list.get(parent[i]).add(i);
        }
        Arrays.fill(nums,-1);
        check(list,arr,nums,0, parent);
        // for(int i=0;i<n;i++)
        //     System.out.print(parent[i]+"" "");
        int[] ans = new int[n];
        list = new ArrayList<>();
        for(int i=0;i<n;i++) {
            list.add(new ArrayList<>());
        }
        for(int i=1;i<n;i++) {
            list.get(parent[i]).add(i);
        }
        getAns(list,0,parent,ans);
        return ans;

    }

    private void check(List<List<Integer>> list, char[] arr, int[] nums, int curr, int[] parent) {
        int ind = (int)(arr[curr]-'a');
        if(nums[ind] != -1) {
            parent[curr] = nums[ind];
        }
        int temp = nums[ind];
        nums[ind] = curr;
        for(int num : list.get(curr)) {
            check(list,arr,nums,num,parent);
        }
        nums[ind] = temp;
    }

    private int getAns(List<List<Integer>> list, int curr, int[] parent, int[] ans) {
        int sum = 1;
        for(int num : list.get(curr)) {
            sum+=getAns(list, num, parent, ans);
        }
        return ans[curr] = sum;
    }
}",1434296590
yashwanth73,yashwanth73,696,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[][] dp = new int[k+1][n+1];
        for(int[] rows : dp)
            Arrays.fill(rows,-1);
        return check(-1,-1,stayScore,travelScore,dp);
    }

    private int check(int ind, int curr, int[][] stay, int[][] travel, int[][] dp) {
        int n = travel.length, k = stay.length;
        if(ind == k)
            return 0;
        if(dp[ind+1][curr+1] != -1)
            return dp[ind+1][curr+1];
        int ans = 0;
        if(ind == -1) {
            for(int i=0;i<n;i++) {
                ans = Math.max(ans, check(ind+1,i,stay,travel, dp));
            }
        }
        else {
            int stayScore = stay[ind][curr] + check(ind+1, curr, stay, travel, dp);
            int move = 0;
            for(int i=0;i<n;i++) {
                move = Math.max(move, travel[curr][i]+check(ind+1,i,stay,travel,dp));
            }
            ans = Math.max(stayScore, move);
        }
        return dp[ind+1][curr+1] = ans;
    }
}",1434341331
yashwanth73,yashwanth73,696,3617,java,"class Solution {
    public int possibleStringCount(String word) {
        int ans = 0;
        int n = word.length();
        int ind = 0;
        while(ind<n) {
            int count = 0;
            char ch = word.charAt(ind);
            while(ind<n && ch == word.charAt(ind)) {
                ind++;
                count++;
            }
            ans+=count-1;
        }
        return ans+1;
    }
}",1434263028
Abheelash Mishra,Abheelash,697,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        adj = defaultdict(list)
        n = len(s)

        for i in range(1, n):
            adj[parent[i]].append(i)

        last_seen = {}
        new_parent = [-1] * n

        def dfs(node):
            prev_ancestor = last_seen.get(s[node], -1)
            last_seen[s[node]] = node
            

            if prev_ancestor != -1:
                new_parent[node] = prev_ancestor
            else:
                new_parent[node] = parent[node]

            for child in adj[node]:
                dfs(child)
                
            last_seen[s[node]] = prev_ancestor

        dfs(0)

        def calculate_size(node):
            size = 1
            for child in new_adj[node]:
                size += calculate_size(child)
            sizes[node] = size
            
            return size
        
        new_adj = defaultdict(list)
        for i in range(1, n):
            new_adj[new_parent[i]].append(i)

        sizes = [0] * n
        calculate_size(0)
        
        return sizes",1434334535
Abheelash Mishra,Abheelash,697,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = [[float(""-inf"")] * n for i in range(k+1)]
        for j in range(n):
            dp[0][j] = 0

        for i in range(1, k+1):
            for curr in range(n):
                dp[i][curr] = max(dp[i][curr], dp[i-1][curr] + stayScore[i-1][curr])

                for dest in range(n):
                    if curr != dest:
                        dp[i][dest] = max(dp[i][dest], dp[i-1][curr] + travelScore[curr][dest])

        return max(dp[k])",1434297097
Abheelash Mishra,Abheelash,697,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        res = []
        res.append(word)

        for i in range(len(word) - 1):
            if word[i] == word[i+1]:
                res.append(word[:i] + word[i+1:])

        print(res)
        return len(res)",1434276278
Cavalier Poet,Cavalier_Poet,699,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        # Mine in a contest.
        tree = {0: set()}
        for i, val in enumerate(parent):
            if i:
                if val in tree:
                    tree[val].add(i)
                else:
                    tree[val] = set([i])
        process = deque([0])
        new_tree = {0: set()}

        def _find(node, last_seen):
            value = s[node]
            new_parent = last_seen[value] if value in last_seen else parent[node]
            if new_parent in new_tree:
                new_tree[new_parent].add(node)
            else:
                new_tree[new_parent] = set([node])
            last_seen[value] = node
            for kid in tree.get(node, set()):
                _find(kid, {k: v for k, v in last_seen.items()})
        _find(0, {})
        ans = [0 for _ in parent]

        def _populate_ans(curr):
            if curr not in new_tree:
                ans[curr] = 1
                return 1
            total = 1
            for child in new_tree[curr]:
                total += _populate_ans(child)
            ans[curr] = total
            return total
        _populate_ans(0)
        return ans
            ",1434334874
Cavalier Poet,Cavalier_Poet,699,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        # Mine in a contest
        dp = [[0 for _ in range(n)] for _ in range(k)]
        for day in range(k):
            for city in range(n):
                dp[day][city] = (dp[day-1][city] if day else 0) + stayScore[day][city]
                for other_city in range(n):
                    if city != other_city:
                        dp[day][city] = max(dp[day][city], (dp[day-1][other_city] if day else 0) + travelScore[other_city][city])
        # print(dp)
        return max(dp[-1])",1434287446
Cavalier Poet,Cavalier_Poet,699,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        # Mine in a contest
        ans = 1
        prev = A
        prev_cnt = 1
        for char in word + ""A"":
            if char == prev:
                prev_cnt += 1
            else:
                ans += prev_cnt - 1
                prev_cnt = 1
            prev = char
        return ans",1434264589
prince singh,prince_cingh,700,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& p, string s) {



        int n=p.size();
        vector<vector<int>> adj(n);
        vector<int> ans(n,1);
        for(int i=1;i<n;i++) adj[p[i]].push_back(i);
        vector<int> np=p;
        unordered_map<char,vector<int>> ls;
        function<void(int)> rp=[&](int node)
        {
            char c=s[node];
            if(!ls[c].empty()) np[node]=ls[c].back();
            ls[c].push_back(node);
            for(int child:adj[node]) rp(child);
            ls[c].pop_back();
        };
        rp(0);
        vector<vector<int>> na(n);
        for(int i=1;i<n;i++) na[np[i]].push_back(i);
        function<int(int)> css=[&](int node)
        {
            int size=1;
            for(int child:na[node]) size+=css(child);
            ans[node]=size;
            return size;
        };
        css(0);
        return ans;
    }
};",1434318379
prince singh,prince_cingh,700,3587,cpp,"class Solution {
public:
   int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
    // Create a 2D DP array to store the maximum points earned up to day i in city j
    vector<vector<int>> dp(k + 1, vector<int>(n, 0));

    // Iterate through each day
    for (int day = 0; day < k; ++day) {
        for (int currCity = 0; currCity < n; ++currCity) {
            // If the tourist stays in the current city
            dp[day + 1][currCity] = max(dp[day + 1][currCity], dp[day][currCity] + stayScore[day][currCity]);

            // If the tourist moves to another city
            for (int nextCity = 0; nextCity < n; ++nextCity) {
                if (nextCity != currCity) {
                    dp[day + 1][nextCity] = max(dp[day + 1][nextCity], dp[day][currCity] + travelScore[currCity][nextCity]);
                }
            }
        }
    }

    // The result is the maximum points earned on the last day in any city
    int maxPoints = 0;
    for (int city = 0; city < n; ++city) {
        maxPoints = max(maxPoints, dp[k][city]);
    }

    return maxPoints;
}
};",1434334951
prince singh,prince_cingh,700,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        map<char,int>m;
         int sum=1;
        int i=0;
        int j=0;
        int cnt=0;

            while(j<word.size())
            {
                       if(word[j]==word[i])
                       {
                            cnt++;
                           j++;
                       }
                      else
                       {    
                            i=j;
                            sum+=cnt-1; 
                           cnt=0;
                       }
            }

           sum+=cnt-1;
        

        return sum;
    }
};",1434288625
agakishy,agakishy,701,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        conn = defaultdict(list)
        for cur, par in enumerate(parent):
            conn[par].append(cur)
        
        n = len(parent)
        ans = [1] * n
        closet = [-1] * 26
        def get_ord(c):
            return (ord(c)-ord('a'))
        
        def dfs(cur, par):
            nonlocal ans, conn, closet
            
            recon = par
            if closet[get_ord(s[cur])] >= 0:
                recon = closet[get_ord(s[cur])]
            pre = closet[get_ord(s[cur])]
            for nxt in conn[cur]:
                closet[get_ord(s[cur])] = cur
                dfs(nxt, cur)
            closet[get_ord(s[cur])] = pre
            ans[recon] += ans[cur]

        closet[get_ord(s[0])] = 0
        for nxt in conn[0]:
            dfs(nxt, 0)
        return ans
                ",1434326497
agakishy,agakishy,701,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        ans = [0] * n
        for ik in range(k):
            nxt = [ans[i] + stayScore[ik][i] for i in range(n)]
            for i in range(n):
                for j in range(n):
                    nxt[j] = max(nxt[j], (ans[i] + travelScore[i][j]) )
            ans = nxt
        return max(ans)",1434341853
agakishy,agakishy,701,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        word = ""#@$"" + word
        ans = 1
        for i in range(3, len(word)):
            if word[i] == word[i-1]:
                ans += 1

        return ans",1434275473
judgeholden,mdsrrkhan,702,3576,java,"class Solution {

    public int[] findSubtreeSizes(int[] parent, String s) {
                int n = parent.length;
        int[] newParent = Arrays.copyOf(parent, n);
        Map<Character, Integer> charToNode = new HashMap<>();

        List<Integer>[] tree = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            tree[i] = new ArrayList<>();
        }
        for (int child = 1; child < n; child++) {
            tree[parent[child]].add(child);
        }

        dfsToUpdateParents(0, tree, s, charToNode, newParent);

        List<Integer>[] newTree = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            newTree[i] = new ArrayList<>();
        }
        for (int child = 1; child < n; child++) {
            newTree[newParent[child]].add(child);
        }

        int[] answer = new int[n];
        computeSubtreeSizesDFS(0, newTree, answer);
        return answer;
        
    }

    void dfsToUpdateParents(int node, List<Integer>[] tree, String s,
                                           Map<Character, Integer> charToNode, int[] newParent) {
        char c = s.charAt(node);
        Integer prev = charToNode.get(c);
        if (prev != null && prev != newParent[node]) {
            newParent[node] = prev;
        }
        charToNode.put(c, node);
        for (int child : tree[node]) {
            dfsToUpdateParents(child, tree, s, charToNode, newParent);
        }
        
        if (prev != null) {
            charToNode.put(c, prev);
        } else {
            charToNode.remove(c);
        }
    }

   int computeSubtreeSizesDFS(int node, List<Integer>[] tree, int[] answer) {
        int size = 1;
        for (int child : tree[node]) {
            size += computeSubtreeSizesDFS(child, tree, answer);
        }
        answer[node] = size;
        return size;
    }

}",1434322307
judgeholden,mdsrrkhan,702,3587,java,"class Solution {
    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
         int[][] dp = new int[k][n];

        for (int dest = 0; dest < n; dest++) {
            dp[0][dest] = stayScore[0][dest];
            for (int curr = 0; curr < n; curr++) {
                if (curr != dest) {
                    dp[0][dest] = Math.max(dp[0][dest], travelScore[curr][dest]);
                }
            }
        }

        for (int day = 1; day < k; day++) {
            for (int curr = 0; curr < n; curr++) {
                dp[day][curr] = dp[day - 1][curr] + stayScore[day][curr];

                for (int prev = 0; prev < n; prev++) {
                    if (prev != curr) {
                        dp[day][curr] = Math.max(dp[day][curr],
                                dp[day - 1][prev] + travelScore[prev][curr]);
                    }
                }
            }
        }

        int maxPoints = Integer.MIN_VALUE;
        for (int city = 0; city < n; city++) {
            maxPoints = Math.max(maxPoints, dp[k - 1][city]);
        }
        return maxPoints;
    }
}",1434341877
judgeholden,mdsrrkhan,702,3617,java,"class Solution {
    public int possibleStringCount(String s) {
        int count =0;
        for(int i = 1;i<s.length();i++){
            if(s.charAt(i) == s.charAt(i-1))
                count++;
        }
        return count+1;
    }
}",1434262618
Jacky Tsai,j10926jacky,703,3576,csharp,"public class Solution {
    public int[] FindSubtreeSizes(int[] parent, string s) {
        int n = parent.Length;
        var g = new HashSet<int>[n];
        for(int i = 0; i < n; i++) g[i] = new();
        for(int i = 1; i < n; i++){
            g[parent[i]].Add(i);
        }
        
        var chs = new int[26];
        Array.Fill(chs, -1);
        var nearestParent = new int[n];
        Array.Fill(nearestParent, -1);
        void Dfs(int node, int[] chs){
            int pa = chs[s[node] - 'a'];
            nearestParent[node] = pa;
            // Console.WriteLine(""nearestParent "" + node + "" "" + pa);
            chs[s[node] - 'a'] = node;
            foreach(var v in g[node]){
                Dfs(v, chs);
            }
            chs[s[node] - 'a'] = pa;
        }
        Dfs(0, chs);
        for(int i = 1; i < n; i++){
            if(nearestParent[i] != -1){
                g[parent[i]].Remove(i);
                g[nearestParent[i]].Add(i);
            }
        }
        var res = new int[n];
        int Dfs2(int node){
            int count = 1;
            foreach(var v in g[node]){
                count += Dfs2(v);
            }
            res[node] = count;
            // Console.WriteLine(""res "" + node + "" "" + count);
            return count;
        }
        Dfs2(0);
        // foreach(var cnt in res)
        //     Console.Write(cnt);
        // Console.WriteLine();
        return res;
    }
}",1434321093
Jacky Tsai,j10926jacky,703,3587,csharp,"public class Solution {
    public int MaxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        var dp = new int[k+1, n];
        for(int day = 1; day <= k; day++){
            for(int city = 0; city < n; city++){
                // stay in the currentCity
                dp[day, city] = dp[day-1, city] + stayScore[day-1][city];
                for(int otherCity = 0; otherCity < n; otherCity++){
                    dp[day, city] = Math.Max(
                        dp[day, city], 
                        dp[day-1, otherCity]+travelScore[otherCity][city]);
                }
            }
        }
        int max = 0;
        for(int city = 0; city < n; city++){
            max = Math.Max(max, dp[k, city]);
        }
        return max;
    }
}",1434341956
Jacky Tsai,j10926jacky,703,3617,csharp,"public class Solution {
    public int PossibleStringCount(string word) {
        int res = 0, count = 1;
        for(int i = 1; i < word.Length; i++){
            if(word[i-1] != word[i]){
                res += count - 1;
                count = 1;
            } else {
                count++;
            }
        }
        res += count-1;
        return res + 1;
    }
}",1434268990
harry30705,harry30705,704,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        mapp = defaultdict(list) 
        adj = list(set() for _ in range(n))
    
        for i in range(n):
            if parent[i]==-1:
                continue
            adj[parent[i]].add(i)

 
        def dfs(node, dad):

            if dad!=-1:
    
                if mapp[s[node]]:
                    adj[dad].remove(node)
                    adj[ mapp[s[node]][-1]  ].add(node)
            
            mapp[ s[node] ].append(node)
            a = adj[node].copy()
            for child in a:
                dfs(child, node)

            mapp[ s[node] ].pop()

        dfs(0, -1)

        def dfs2(node):
            if ans[node]!=-1:
                return ans[node]
            total = 1
            for child in adj[node]:
                total += dfs2(child)
            ans[node] = total
            return total

        ans = [-1]*n
        for i in range(n):
            if ans[i]==-1:
                dfs2(i)

        return ans






            

        ",1434322692
harry30705,harry30705,704,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        dp = list(list(0 for _ in range(n) ) for _ in range(k+1))
               
        for i in range(1, k+1):
            for j in range(n):
                for z in range(n):
                    if j==z:
                        dp[i][j] = max(dp[i][j], dp[i-1][z] + stayScore[i-1][z])

                    dp[i][j] = max(dp[i][j],  dp[i-1][z] +   travelScore[z][j] )


        return max(dp[-1])

                        
                        
            
            ",1434335192
harry30705,harry30705,704,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
      
        ans = 1
        n = len(word)
        for i in range(1, n):
            if word[i] == word[i-1]:
                ans+=1
            


        return ans",1434263865
Suyq,sysu17364057,705,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
    
        # Step 1: Build the initial tree from the parent array
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)

        path = defaultdict(list)
        new_tree = copy.deepcopy(tree)
        def dfs1(node, par):
            if path[s[node]]:
                new_tree[par].remove(node)
                new_tree[path[s[node]][-1]].append(node)

            for child in tree[node]:
                path[s[node]].append(node)
                dfs1(child, node)
                path[s[node]].pop()
        dfs1(0, -1)
        #print(new_tree)

        # Step 3: Calculate subtree sizes in the updated tree
        answer = [0] * n

        def dfs(node):
            subtree_size = 1
            for child in new_tree[node]:
                subtree_size += dfs(child)
            answer[node] = subtree_size
            return subtree_size

        # Start DFS from the root node (0)
        dfs(0)

        return answer
",1434335198
Suyq,sysu17364057,705,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @lru_cache(None)
        def dfs(day, city):
            if day==k:
                return 0
            res = stayScore[day][city]+dfs(day+1, city)
            
            for i in range(n):
                if i==city:
                    continue
                res = max(res, travelScore[city][i]+dfs(day+1, i))
                
            return res
        
        return max(dfs(0, i) for i in range(n))",1434295523
Suyq,sysu17364057,705,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 0
        cnt = 0
        n = len(word)
        idx = 0
        last = 0
        
        while idx+1<n:
            if word[idx]==word[idx+1]:
                last += 1
            else:
                if last:
                    ans += last+1
                    cnt += 1
                    last = 0
            idx += 1
        
        return ans-cnt+last+1",1434269113
Russ741,Russ741,706,3576,python3,"class Solution:
    def recurse(self, cur, ancestor_set) -> Counter:
        cur_c = self.s[cur]
        
        counts = Counter()
        counts[cur_c] += 1
        
        add_cur = False
        if cur_c not in ancestor_set:
            add_cur = True
            ancestor_set.add(cur_c)
            
        for child in self.children[cur]:
            child_c = self.s[child]
            descendants = self.recurse(child, ancestor_set)
            for d_chr, d_ct in descendants.items():
                if d_chr in ancestor_set:
                    counts[d_chr] += d_ct
                else:
                    counts[cur_c] += d_ct

        if add_cur:
            ancestor_set.remove(cur_c)
            
        self.results[cur] = counts[cur_c]
        
        return counts
    
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        self.s = s
        self.children = [[] for i in range(len(s))]
        # print(self.children)
        for i in range(1, len(s)):
            self.children[parent[i]].append(i)
        # print(self.children)
        
        self.results = [0] * len(s)
        self.recurse(0, set())
        return self.results",1434327292
Russ741,Russ741,706,3587,python3,"class Solution:

    @functools.cache
    def val(self, cur, date):
        if date == self.k:
            return 0
        
        best = self.stayScore[date][cur] + self.val(cur, date + 1)
        
        for nxt in range(self.n):
            best = max(best, self.travelScore[cur][nxt] + self.val(nxt, date + 1))
        
        return best
    
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        self.n = n
        self.k = k
        self.stayScore = stayScore
        self.travelScore = travelScore
        
        best = 0
        
        for cur in range(n):
            best = max(best, self.val(cur, 0))
        return best",1434342018
Russ741,Russ741,706,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        i = 0
        count = 1
        for i in range(len(word) - 1):
            if word[i+1] != word[i]:
                continue
            count += 1
        return count
                ",1434274212
Ritik Ranjan,ritikranjan009,707,3576,cpp,"class Solution {
public:
    int n;
    int f1(int node, vector<vector<int>>& t, vector<int>& sbsz) {
        sbsz[node] = 1;
        for (auto child : t[node]) sbsz[node] += f1(child,t,sbsz);
        return sbsz[node];
    }
    void f2(int node, vector<vector<int>>& t, vector<int>& newP, const string& s, unordered_map<char, stack<int>>& prev) {
        auto c = s[node];
        if (prev[c].size() > 0) {
            int near = prev[c].top();
            newP[node] = near;
        }
        
        prev[c].push(node);
        
        for (int child : t[node]) {
            f2(child, t, newP, s, prev);
        } 
        prev[c].pop();
    }

    int f3(int node,vector<vector<int>>& buildNew,vector<int>& ans){
        ans[node] = 1;
        for (auto child:buildNew[node]) {
            ans[node] += f3(child, buildNew, ans);
        }
        return ans[node];
    }

    vector<int> findSubtreeSizes(vector<int>& parent, const string& s) {
        n = parent.size();
        vector<vector<int>> t(n);
        vector<int> sbsz(n, 0);
        unordered_map<char, stack<int>> prev;;
        vector<int> newP = parent;
        
        for (int i=1;i<n;i++) t[parent[i]].push_back(i);
        
        f1(0, t, sbsz);
        f2(0, t, newP, s, prev);
        
        vector<vector<int>> buildNew(n);
        
        for (int i = 1; i < n; i++) buildNew[newP[i]].push_back(i);
        
        vector<int> ans(n, 0);
        f3(0, buildNew, ans);
        return ans;
    }
};
",1434314571
Ritik Ranjan,ritikranjan009,707,3587,cpp,"class Solution {
public:
    int dp[202][202];

    int func(int curr,int day,int city,int tot,vector<vector<int>>&wait, vector<vector<int>>&traverse) {
        if (day == tot) return 0;
        if (dp[day][curr]!=-1) return dp[day][curr];

        int maxi=wait[day][curr]+func(curr,day+1,city,tot,wait, traverse);

        for (int nxt=0; nxt<city; nxt++) {
            if (nxt !=curr) {
                maxi = max(maxi,traverse[curr][nxt]+func(nxt, day+1,city,tot,wait,traverse));
            }
        }
        dp[day][curr] = maxi;
        return maxi;
    }

    int maxScore(int n, int k, vector<vector<int>>stayScore, vector<vector<int>>travelScore) {
        memset(dp, -1, sizeof(dp));
        int ans=0;
        for (int i=0;i<n;i++) {
            ans =max(ans, func(i,0,n,k,stayScore,travelScore));
        }
        return ans;
    }
};
",1434335238
Ritik Ranjan,ritikranjan009,707,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int n = word.size();
        for(int i=1 ; i<n ; i++){
            if(word[i] == word[i-1]) ans++;
        }
        return ans;
    }
};",1434272710
apillai32,apillai32,708,3576,python3,"from collections import deque
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        stack = [0]

        # call dfs on a node map myself as the recent ancestor for that letter

        # remove it and do another
        children = [[] for i in range(len(parent)) ]

        for child, p in enumerate(parent):
            if not child:
                continue
            children[p].append(child)

        new_children = [[] for i in range(len(parent)) ]

        
        def dfs(ans_dic, i):

            # rewire the children
            tmp = ans_dic.get(s[i], -1)
            ans_dic[s[i]] = i
            for child in children[i]:

                if s[child] in ans_dic:
                    new_children[ans_dic[s[child]]].append(child)
                else:
                    new_children[i].append(child)

                dfs(ans_dic, child)                

            if tmp == -1:
                del ans_dic[s[i]]
            else:
                ans_dic[s[i]] = tmp

        dfs({}, 0)

        # get sizes of tree
        
        q = deque([0])
        bfs_order = []
        while q:

            
            curr = q.popleft()
            bfs_order.append(curr)

            for child in new_children[curr]:
                q.append(child)


        ret = len(parent) * [1]

        while bfs_order:
            curr = bfs_order.pop()

            for child in new_children[curr]:
                ret[curr] += ret[child]
            
        return ret
            
            
        ",1434327764
apillai32,apillai32,708,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        # dp 
        # O(nk)

        ans = {}
        for day in reversed(range(k + 1)):

            for starting_node in range(n):

                if day == k:
                    ans[day, starting_node] = 0
                    continue
                ans[day, starting_node] = 0
                for step in range(n):

                    if step == starting_node:
                        pts = stayScore[day][step]
                    else:
                        pts = travelScore[starting_node][step]

                    
                    total_score = pts + ans[day + 1, step]

                    ans[day, starting_node] = max(ans[day, starting_node], total_score)

        return max(ans[0, i] for i in range(n))

                
            

        
        
            
        ",1434342132
apillai32,apillai32,708,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:

        streak = 0
        # made 0 mistakes
        ret = 1
        for i, c in enumerate(word):
            if not i or c == word[i - 1]:
                streak += 1
            elif i:
                ret += streak - 1
                streak = 1

        ret += streak - 1
        
        return ret",1434272143
Souvik Sarkar,souviksarkar2k3,709,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        n = len(parent)
        graph = [set() for _ in range(n)]
        for i in range(n):
            if i == 0:
                continue
            graph[parent[i]].add(i)
        m = {s[0]: 0}
        add, rem = defaultdict(list), defaultdict(list)
        def dfs(node):
            for v in graph[node]:
                if s[v] not in m:
                    m[s[v]] = v   
                    dfs(v)
                    del m[s[v]]
                else:
                    cur, m[s[v]] = m[s[v]], v
                    if cur != node:
                        add[cur].append(v)
                        rem[node].append(v)
                    dfs(v)
                    m[s[v]] = cur
        dfs(0)
        for node in add:
            for cur in add[node]:
                graph[node].add(cur)
        for node in rem:
            for cur in rem[node]:
                graph[node].remove(cur)
        size = [0]*n
        def count(node):
            cur = 1
            for v in graph[node]:
                cur += count(v)
            size[node] = cur
            return cur
        count(0)
        return size
                    
                ",1434323081
Souvik Sarkar,souviksarkar2k3,709,3587,cpp,"#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    int dfs(int i, int cur, int k, int n, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, vector<vector<int>>& memo) {
        if (i == k) return 0;
        
        if (memo[i][cur] != -1) return memo[i][cur];

        int maxi = 0;
        for (int dest = 0; dest < n; ++dest) {
            if (cur == dest) {
                maxi = max(stayScore[i][cur] + dfs(i + 1, cur, k, n, stayScore, travelScore, memo), maxi);
            } else {
                maxi = max(travelScore[cur][dest] + dfs(i + 1, dest, k, n, stayScore, travelScore, memo), maxi);
            }
        }
        memo[i][cur] = maxi;
        return maxi;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<vector<int>> memo(k, vector<int>(n, -1));
        int maxScore = 0;

        for (int cur = 0; cur < n; ++cur) {
            maxScore = max(dfs(0, cur, k, n, stayScore, travelScore, memo), maxScore);
        }
        return maxScore;
    }
};
",1434342429
Souvik Sarkar,souviksarkar2k3,709,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        return 1 + sum(word[i] == word[i+1] for i in range(len(word)-1))",1434264776
ratzfatz,ratzfatz,710,3576,python3,"from collections import defaultdict
class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        class Node:
            def __init__(self, index, val):
                self.index = index
                self.val = val
                self.children = set()
                self.parent = None
                
        n = len(parent)
        nodes = {}
        for index, c in enumerate(s):
            nodes[index] = Node(index, c)
            
        for index, p in enumerate(parent):
            if p >= 0:
                nodes[p].children.add(index)
                nodes[index].parent = p
                
        last_seen = defaultdict(list)

        new_parents = {}
        def dfs(root):
            if last_seen[root.val]:
                new_parents[root.index] = last_seen[root.val][-1]
            last_seen[root.val].append(root.index)
            for child in root.children:
                dfs(nodes[child])
            last_seen[root.val].pop()
            
        dfs(nodes[0])
        
        for nodeind, newparent in new_parents.items():
            oldparent = nodes[nodeind].parent
            nodes[oldparent].children.remove(nodeind)
            nodes[newparent].children.add(nodeind)

        sizecount = defaultdict(int)
        def count(root):
            if root is None:
                return
            sizecount[root.index] += 1
            for child in root.children:
                count(nodes[child])
                sizecount[root.index] += sizecount[child]
                
        count(nodes[0])
        
        result = [sizecount[i] for i in range(n)]
        return result
            
                


            
            
        
",1434311116
ratzfatz,ratzfatz,710,3587,python3,"

class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:

        points = {i:0 for i in range(n)}
        # print('original', points)
        for day in range(k):
            new_points = {}
            # print('day', day)
            for city, current in points.items():
                # print('cc', city, current)
                for target in range(n):
                    if target == city:
                        add = stayScore[day][city]
                    else:
                        add = travelScore[city][target]
                    # print(current, add)
                    new_points[target] = max(new_points.get(target, 0), current + add)
        
            points = new_points
            # print(points)

        return max(points.values())
        ",1434342481
ratzfatz,ratzfatz,710,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        if len(word) == 1:
            return 1

        result = 1
        last = word[0]
        word = word + '*'
        count = 1
        for c in word[1:]:
            if c == last:
                count += 1
            else:
                last = c
                result += count - 1
                count = 1

        return result
        ",1434270290
Yaswanth Reddy,yaswanth_2874,711,3576,cpp,"#include <unordered_map>
#include <stack>
#include <vector>
#include <string>
using namespace std;

class Solution {
    unordered_map<char, stack<int>> recent;
    
    void update(int node, vector<vector<int>>& tree, string& s, vector<int>& updated, vector<int>& parent) {
        char ch = s[node];
        
        if(!recent[ch].empty()) {
            int anc = recent[ch].top();
            if(anc != parent[node]) {
                updated[node] = anc;
            } else {
                updated[node] = parent[node];
            }
        } else {
            updated[node] = parent[node];
        }
        
        recent[ch].push(node);
        for(int child : tree[node]) {
            update(child, tree, s, updated, parent);
        }
        recent[ch].pop();
    }
    int findSize(int node, vector<vector<int>>& treeAfterOperations, vector<int>& answer) {
        int size = 1;
        for(int child : treeAfterOperations[node]) {
            size += findSize(child, treeAfterOperations, answer);
        }
        answer[node] = size;
        return size;
    }

public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> tree(n);
        
        for(int i = 1; i < n; ++i) {
            tree[parent[i]].push_back(i);
        }
        
        vector<int> updated(n, -1);
        vector<int> answer(n, 1);
        
        update(0, tree, s, updated, parent);
        
        vector<vector<int>> treeAfterOperations(n);
        for(int i = 1; i < n; ++i) {
            if(updated[i] != -1) {
                treeAfterOperations[updated[i]].push_back(i);
            }
        }
        
        findSize(0, treeAfterOperations, answer);
        return answer;
    }
};
",1434324382
Yaswanth Reddy,yaswanth_2874,711,3587,cpp,"class Solution {
    // Dp
    // This should work ig, constraints are not too severe
    vector<vector<int>> memo;
    int findMax(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore, int day, int index) {
        if(day == k)
            return 0;
        if(memo[day][index] != -1)
            return memo[day][index];
        
        int stay = stayScore[day][index] + findMax(n, k, stayScore, travelScore, day + 1, index);
        int maxV = stay;
        
        for(int i = 0; i < n; i++) {
            if(i != index) {
                int dontStay = findMax(n, k, stayScore, travelScore, day + 1, i) + travelScore[index][i];
                maxV = max(maxV, dontStay);
            }
        }
        
        return memo[day][index] = maxV;
    }
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        memo = vector<vector<int>>(k, vector<int>(n, -1));
        int maxV = 0;
        
        for(int i = 0; i < n; i++) {
            maxV = max(maxV, findMax(n, k, stayScore, travelScore, 0, i));
        }
        
        return maxV;
    }
};",1434342566
Yaswanth Reddy,yaswanth_2874,711,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        char prev = '#';
        int currentFreq = 1;
        
        for(char ch : word) {
            if(prev == ch)
                currentFreq++;
            else {
                if(currentFreq > 1) {
                    ans += currentFreq - 1;
                    currentFreq = 1;
                }
            }
            prev = ch;
        }
        
        if(currentFreq > 1)
            ans += currentFreq - 1;
        return ans;
        
    }
};",1434271005
Sushil Kumar,Sushil_kumar,712,3576,cpp,"class Solution {
public:
    
    int dfs(int i, vector<int> graph[], vector<int> &ans){
        
        int cnt = 1;
        
        for(auto j:graph[i]){
            cnt += dfs(j, graph, ans);
        }
        
        // cout<<i<<"" ""<<cnt<<endl;
        ans[i] = cnt;
        return  cnt;
    }
    
    void dfs1(int i, vector<int> graph[], string &s, vector<int> &par, vector<int> &vs){
        
        
        int x = s[i]-'a';
        if(vs[x] != -1){
            par[i] = vs[x];
        }
        int p = vs[x];
        vs[x] = i;
        for(auto j: graph[i]){
            dfs1(j, graph,s, par, vs);
        }
        
        vs[x] = p;
        
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = s.size();
        vector<int> ans(n, 1);
        
        vector<int> graph[n];
        
        for(int i=0;i<n;i++){
            if(parent[i] != -1)
                 graph[parent[i]].push_back(i);
        }
        
        vector<int> vs(26, -1);
        
        dfs1(0, graph, s, parent, vs);
        
        vector<int> graph1[n];
        
        for(int i=0;i<n;i++){
            // cout<<i<<"" ""<<parent[i]<<endl;
            if(parent[i] != -1){
                 graph1[parent[i]].push_back(i);
            }
        }
        
        dfs(0, graph1, ans);
        
        return ans;
    }
};",1434326881
Sushil Kumar,Sushil_kumar,712,3587,cpp,"class Solution {
public:
    int help(int cC, int cD, int n, int k, vector<vector<int>> &st, vector<vector<int>> &ts, vector<vector<int>> &dp){
        
        if(cD>=k)
            return 0;
        
        if(dp[cC+1][cD+1] != -1)
            return dp[cC+1][cD+1];
        
        if(cC == -1){
            int mx = 0;
            
            for(int i=0;i<n;i++){
                mx = max(mx, help(i, cD, n, k, st, ts, dp));
            }
            
            return dp[cC+1][cD+1] = mx;
        }
        
        
        int mx = st[cD][cC] + help(cC, cD+1, n, k , st, ts, dp);
        
        for(int i=0;i<n;i++){
            mx = max(mx, ts[cC][i] + help(i, cD+1, n, k, st, ts, dp));
        }
        
        return dp[cC+1][cD+1] = mx;
    }
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        
        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));
        return help(-1, 0, n, k, stayScore, travelScore, dp);
    }
};",1434342636
Sushil Kumar,Sushil_kumar,712,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        
        int x = 1;
        
        int cnt = 0;
        int prv = '0';
        for(int i=0;i<word.size();i++){
            if(word[i] == prv){
                cnt++;
            }else{
                x += (cnt);
                cnt=0;
                prv = word[i];
            }
        }
        
        x += cnt;
        
        return x;
    }
};",1434266444
Pavel,Pavel_For_Sure,713,3576,csharp,"public class Solution 
{
    public int[] FindSubtreeSizes(int[] parent, string s) 
    {
        Dictionary<int, List<int>> edges = GenerateEdges();
        int[] prev = new int[26];
        Array.Fill(prev, -1);
        Next(0);
        int[] res = new int[parent.Length];
        edges = GenerateEdges();
        Count(0);
        return res;
        
        void Next(int node)
        {
            int cur = s[node] - 'a';
            int memo = prev[cur];
            if (memo != -1)
                parent[node] = memo;
        
            prev[cur] = node;
            if (edges.ContainsKey(node))
            {
                foreach (var next in edges[node])
                    Next(next);
            }
        
            prev[cur] = memo;
        }
        
        int Count(int node)
        {
            int sum = 1;
            if (edges.ContainsKey(node))
            {
                foreach (var item in edges[node])
                    sum += Count(item);
            }
        
            res[node] = sum;
            return sum;
        }
        
        Dictionary<int, List<int>> GenerateEdges()
        {
            Dictionary<int, List<int>> edges = new();
            for (int i = 1; i < parent.Length; i++)
            {
                if (edges.ContainsKey(parent[i]))
                    edges[parent[i]].Add(i);
                else
                    edges[parent[i]] = [i];
            }
        
            return edges;
        }
    }
}",1434304474
Pavel,Pavel_For_Sure,713,3587,csharp,"public class Solution 
{
    public int MaxScore(int n, int k, int[][] stayScore, int[][] travelScore) 
    {
        int[,] dp = new int[k + 1, n];
        int max = 0;
        
        for (int day = k - 1; day >= 0; day--)
        {
            for (int city = 0; city < n; city++)
            {
                int best = dp[day + 1, city] + stayScore[day][city];
                for (int nextCity = 0; nextCity < n; nextCity++)
                {
                    if (nextCity == city)
                        continue;
        
                    best = Math.Max(best, dp[day + 1, nextCity] + travelScore[city][nextCity]);
                }
        
                if (day == 0)
                    max = Math.Max(max, best);
        
                dp[day, city] = best;
            }
        }
        
        return max;
    }
}",1434335999
Pavel,Pavel_For_Sure,713,3617,csharp,"public class Solution {
    public int PossibleStringCount(string word) 
    {
        int res = 1;
        for (int i = 1; i < word.Length; i++)
        {
            if (word[i] != word[i - 1])
                continue;
            res++;
        }
        
        return res;
    }
}",1434262057
lucky negi,igennova,714,3576,python3,"from collections import defaultdict
from typing import List

class Solution:
    def is_prime(n):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    def findSubtreeSizes(self, lucky: List[int], s: str) -> List[int]:
        n = len(lucky)
        adj = defaultdict(list)
        answer = [1] * n
        new_lucky = lucky[:]
        last_seen = defaultdict(list)
    
        def reassign_lucky(node):
            char = s[node]
            if last_seen[char]:
                new_lucky[node] = last_seen[char][-1]
            last_seen[char].append(node)
            for child in adj[node]:
                reassign_lucky(child)
            last_seen[char].pop()
        
        for i in range(1, n):
            adj[lucky[i]].append(i)
        
        reassign_lucky(0)
        new_adj = defaultdict(list)
        for i in range(1, n):
            new_adj[new_lucky[i]].append(i)
        def compute_lucky_sizes(node):
            size = 1
            for child in new_adj[node]:
                size += compute_lucky_sizes(child)
            answer[node] = size
            return size
        compute_lucky_sizes(0)
        return answer
",1434304847
lucky negi,igennova,714,3587,python3,"from typing import List
from functools import lru_cache

class Solution:
    def maxScore(self, lucky: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        @lru_cache(None)
        def dfs(lucky_day: int, lucky_curr: int) -> int:
            if lucky_day == k:  
                return 0
            lucky_points = stayScore[lucky_day][lucky_curr] + dfs(lucky_day + 1, lucky_curr)
            for lucky_dest in range(lucky):
                if lucky_curr != lucky_dest: 
                    lucky_points = max(lucky_points, travelScore[lucky_curr][lucky_dest] + dfs(lucky_day + 1, lucky_dest))
            return lucky_points
        lucky_max_points = 0
        for lucky_city in range(lucky):
            lucky_max_points = max(lucky_max_points, dfs(0, lucky_city))
        
        return lucky_max_points
",1434336047
lucky negi,igennova,714,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ct=1
        for i in range(1,len(word)):
            if word[i]==word[i-1]:
                ct+=1
        return ct
        ",1434268168
Mayank Sharma,debugger18,715,3576,cpp,"class Solution {
public:
    void help(vector<int> adj[] , string & s , vector<int> & hash , int curr , vector<int> & ans , int par){
        int ch = s[curr]-'a';
        if(hash[ch] != -1){
            ans[curr] = hash[ch];
        }
        else{
            ans[curr] = par; 
        }
        int tmp = hash[ch];
        hash[ch] = curr;
        for(auto & child : adj[curr]){
            help(adj , s , hash , child , ans , curr);
        }
        hash[ch] = tmp;
    }
    int count(vector<int>  adj[] , int curr , vector<int> &ans){
        int cnt = 1;
        for(auto & i : adj[curr]){
            cnt += count(adj , i , ans);
        }
        return ans[curr] = cnt;
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> adj[n];
        for(int i = 1 ; i < n ; i++){
            adj[parent[i]].push_back(i);
        }
        vector<int> par(n , -1) , hash(26 , -1);
        help(adj , s , hash , 0 , par , -1);
        vector<int> adj2[n];
        for(int i = 1 ; i < n ; i++){
            adj2[par[i]].push_back(i);
        }
        count(adj2 , 0 , par);
        return par;
    }
};",1434309178
Mayank Sharma,debugger18,715,3587,cpp,"class Solution {
public:
    int help(int curr , int day , vector<vector<int>>& ss, vector<vector<int>>& ts , int k , int n , vector<vector<int>> & dp){
        if(day >= k) return 0;
        if(dp[curr][day] != -1) return dp[curr][day];
        int ans = ss[day][curr] +  help(curr , day+1 , ss , ts , k , n , dp);
        for(int i = 0 ; i < n ; i++){
            if(i != curr){
                ans = max(ans , ts[curr][i] + help(i , day+1 , ss , ts , k , n , dp));
            }
        }
        return dp[curr][day] = ans;
    }
    int maxScore(int n, int k, vector<vector<int>>& ss, vector<vector<int>>& ts) {
        int ans = INT_MIN;
        vector<vector<int>> dp(n+1 , vector<int> (k+1 , -1));
        for(int i = 0 ; i < n ; i++){
            ans = max(ans , help(i , 0 , ss , ts , k , n , dp));
        }
        return ans;
    }
};",1434329325
Mayank Sharma,debugger18,715,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 0;
        int cnt = 0;
        for(int i = 1 ; i < word.size() ; i++){
            if(word[i] == word[i-1]){
                cnt++;
            }
            else{
                ans += cnt;
                cnt = 0;
            }
        }
        ans += cnt+1;
        return ans;
    }
};",1434269776
harveylawsonY4d,harveylawsonY4d,716,3576,csharp,"public class Solution {
    public int[] FindSubtreeSizes(int[] parent, string s) {
        Dictionary<int, HashSet<int>> adj = [];
        
        for (int i = 1; i < parent.Length; i++)
        {           
            adj.TryAdd(parent[i], []);
            adj[parent[i]].Add(i);
        }
        
        int[] closestIndex = Enumerable.Repeat(-1, 26).ToArray();
        
        Dfs(0);        
        UpdateSubtreeSize(0);
        
        return parent;
        
        void Dfs(int n)
        {
            int c = s[n] - 'a';
            int ancestor = closestIndex[c];
            
            if (ancestor >= 0 && !adj[ancestor].Contains(n))
            {
                adj[ancestor].Add(n);
                adj[parent[n]].Remove(n);
            }
            
            if (!adj.ContainsKey(n))
            {
                return;
            }
            
            closestIndex[c] = n;
            
            foreach (int child in new HashSet<int>(adj[n]))
            {
                Dfs(child);
            }
            
            closestIndex[c] = ancestor;
        }
        
        int UpdateSubtreeSize(int n)
        {
            int subtreeSize = 1;
            
            if (adj.TryGetValue(n, out HashSet<int> children))
            {
                foreach (int child in children)
                {
                    subtreeSize += UpdateSubtreeSize(child);
                }
            }
            
            parent[n] = subtreeSize;
            return subtreeSize;
        }
    }
}",1434311680
harveylawsonY4d,harveylawsonY4d,716,3587,csharp,"public class Solution {
    public int MaxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        int[,] dp = new int[n, k];
        int maxScore = 0;
        
        for (int i = 0; i < n; i++)
        {
            maxScore = Math.Max(maxScore, CalcTravelScore(i, 0));
        }
        
        return maxScore;
        
        int CalcTravelScore(int city, int day)
        {
            if (day == k)
            {
                return 0;
            }
            
            if (dp[city, day] > 0)
            {
                return dp[city, day];
            }

            int travel = 0;

            for (int i = 0; i < n; i++)
            {
                if (i == city)
                {
                    continue;
                }

                travel = Math.Max(travel, travelScore[city][i] + CalcTravelScore(i, day + 1));
            }
            
            int score = stayScore[day][city] + CalcTravelScore(city, day + 1);
            dp[city, day] = Math.Max(score, travel);
            return dp[city, day];
        }
    }
}",1434343030
harveylawsonY4d,harveylawsonY4d,716,3617,csharp,"public class Solution {
    public int PossibleStringCount(string word) {
        int count = 1;
        int repeats = 0;
        
        for (int i = 1; i < word.Length; i++)
        {
            if (word[i] == word[i - 1])
            {
                repeats++;
            }
            else
            {
                count += repeats;
                repeats = 0;
            }
        }
        
        return count + repeats;
    }
}",1434263003
AntonMelnyk,AntonMelnyk,717,3576,cpp,"class Solution {
public:
    vector<int> v[100007];
    vector<int>res;
    int solve(int x)
    {
        int cur = 1;
        for (int i=0;i<v[x].size();i++)
        {
            cur += solve(v[x][i]);
        }
        res[x] = cur;
        return cur;
    }
    map<int,int> mp2;
    map<char,vector<int>> mp;
    string s;
    int solve2(int x)
    {
        mp[s[x]].push_back(x);
        int t = 0;
        for (int i=0;i<v[x].size();i++)
        {
            t += solve2(v[x][i]);
        }
        mp[s[x]].pop_back();
        t-=mp2[x];
        mp2[x]=0;
        res[x]-=t;
        if (mp[s[x]].size()!=0)
        {
            mp2[mp[s[x]][mp[s[x]].size()-1]] += res[x];
            t+=res[x];
        }
        return t;
        
    }
    vector<int> findSubtreeSizes(vector<int>& parent, string s1) {

        res.push_back(0);
        for (int i=1;i<parent.size();i++)
        {
            v[parent[i]].push_back(i);
            res.push_back(0);
        }
        s = s1;
        solve(0);
        solve2(0);
        return res;
        
    }
};",1434313265
AntonMelnyk,AntonMelnyk,717,3587,cpp,"class Solution {
public:
    int dp[201][201];
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {


        for (int i=0;i<k;i++)
            {
                for (int j=0;j<n;j++)
                    {
                        for (int a=0;a<n;a++)
                            {
                                if (j==a)
                                {
                                    dp[i+1][a] = max(dp[i+1][a],dp[i][a]+stayScore[i][a]);
                                }
                                else
                                {
                                    dp[i+1][a] = max(dp[i+1][a],dp[i][j] + travelScore[j][a]);
                            }
                        }
                }
        }
        int res = 0;
        for (int i=0;i<n;i++)
            {
                res = max(dp[k][i],res);
            }
        return res;
    }
        
        
};",1434322664
AntonMelnyk,AntonMelnyk,717,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:


        res = 1

        for i in range(len(word)-1):
            if (word[i]==word[i+1]):
                res+=1
        return res",1434259955
Hieu,hoanghonghieu,718,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        vector<unordered_set<int>> children(parent.size());
        for (int i = 1; i < parent.size(); i++) {
            children[parent[i]].insert(i);
        }
        vector<unordered_set<int>> newChildren(parent.size());
        vector<stack<int>> ancestor(26);
        restructure(0, -1, children, ancestor, s, newChildren);
        vector<int> ans(parent.size());
        getTreeSize(0, newChildren, ans);
        return ans;
    }

    int getTreeSize(int node, vector<unordered_set<int>>& children, vector<int>& sizes) {
        sizes[node] = 1;
        for (int child : children[node]) {
            sizes[node] += getTreeSize(child, children, sizes);
        }
        return sizes[node];
    }

    void restructure(int node, int parent, vector<unordered_set<int>>& children, vector<stack<int>>& ancestor, string& s, vector<unordered_set<int>>& newChildren) {
        // simultaneously, use the old tree structure.
        if (parent >= 0) newChildren[parent].insert(node);
        
        if (ancestor[s[node] - 'a'].size() > 0) {
            // Remove from current parent
            newChildren[parent].erase(node);
            // Insert to new parent
            newChildren[ancestor[s[node] - 'a'].top()].insert(node);
        }
        // Backtracking
        ancestor[s[node] - 'a'].push(node);

        // Recursion
        for (int child : children[node]) {
            restructure(child, node, children, ancestor, s, newChildren);
        }
        ancestor[s[node] - 'a'].pop();
    }
};",1434322678
Hieu,hoanghonghieu,718,3587,cpp,"class Solution {
public:
    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        vector<int> scores(n, 0);
        for (int d  = 0; d < k ; d++) {
            vector<int> new_scores(n);
            for (int c  = 0; c < n; c++) {
                for (int nc = 0; nc < n; nc++) {
                    if (nc == c) {
                        // Stay
                        new_scores[c] = max(new_scores[c], scores[c] + stayScore[d][c]);
                    } else {
                        // Move
                        new_scores[nc] = max(new_scores[nc], scores[c] + travelScore[c][nc]);
                    }
                }
            }
            scores = new_scores;
        }
        
        return *max_element(scores.begin(), scores.end());
    }
};",1434343164
Hieu,hoanghonghieu,718,3617,cpp,"class Solution {
public:
    int possibleStringCount(string word) {
        int ans = 1;
        int count = 1;
        for (int i = 1; i < word.size(); i++) {
            if (word[i - 1] != word[i]) {
                ans += count - 1;
                count = 1;
            } else if (i + 1 == word.size()) {
                count++;
                ans += count - 1;
            }
            else {
                count++;
            }
        }
        return ans;
    }
};",1434276244
SAHIL WALUNJ,user2636BW,719,3576,cpp,"#include <vector>
#include <unordered_map>
#include <stack>
using namespace std;

class Solution {
public:
    vector<int> findSubtreeSizes(vector<int>& parent, string s) {
        int n = parent.size();
        vector<vector<int>> adj(n);
        vector<int> newParent(n, -1);

        for (int i = 1; i < n; ++i) {
            adj[parent[i]].push_back(i);
        }
        unordered_map<char, stack<int>> ancestorMap;
        for (int i = 0; i < n; ++i) {
            if (newParent[i] == -1) {
                dfsUpdateParent(i, adj, parent, s, ancestorMap, newParent);
            }
        }
        vector<vector<int>> newAdj(n);
        for (int i = 1; i < n; ++i) {
            newAdj[newParent[i]].push_back(i);
        }
        vector<int> subtreeSize(n, 1);
        for (int i = 0; i < n; ++i) {
            if (subtreeSize[i] == 1) {
                computeSubtreeSize(i, newAdj, subtreeSize);
            }
        }

        return subtreeSize;
    }

private:
    void dfsUpdateParent(int node, const vector<vector<int>>& adj, const vector<int>& parent, const string& s, unordered_map<char, stack<int>>& ancestorMap, vector<int>& newParent) {
        ancestorMap[s[node]].push(node);

        for (int child : adj[node]) {
            dfsUpdateParent(child, adj, parent, s, ancestorMap, newParent);
        }

        ancestorMap[s[node]].pop();
        if (!ancestorMap[s[node]].empty()) {
            newParent[node] = ancestorMap[s[node]].top();
        } else {
            newParent[node] = parent[node];
        }
    }

    void computeSubtreeSize(int node, const vector<vector<int>>& adj, vector<int>& subtreeSize) {
        for (int child : adj[node]) {
            computeSubtreeSize(child, adj, subtreeSize);
            subtreeSize[node] += subtreeSize[child];
        }
    }
};
",1434303434
SAHIL WALUNJ,user2636BW,719,3587,cpp,"#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<vector<int>> dp;
    vector<vector<int>> stayScore;
    vector<vector<int>> travelScore;
    int n;
    int k;
    int solve(int day, int curr) {
        if (day == k) {
            return 0;  
        }
        if (dp[day][curr] != -1) {
            return dp[day][curr];  
        }

        int ans = stayScore[day][curr] + solve(day + 1, curr);

        for (int nextCity = 0; nextCity < n; nextCity++) {
            if (nextCity != curr) {
                ans = max(ans, travelScore[curr][nextCity] + solve(day + 1, nextCity));
            }
        }

        dp[day][curr] = ans; 
        return ans;
    }

    int maxScore(int n, int k, vector<vector<int>>& stayScore, vector<vector<int>>& travelScore) {
        this->n = n;
        this->k = k;
        this->stayScore = stayScore;
        this->travelScore = travelScore;

        dp.resize(k + 1, vector<int>(n, -1));  

        int result = 0;
        for (int startCity = 0; startCity < n; startCity++) {
            result = max(result, solve(0, startCity));
        }
        return result;
    }
};
",1434329670
SAHIL WALUNJ,user2636BW,719,3617,cpp,"#include <string>
using namespace std;

class Solution {
public:
    int possibleStringCount(string word) {
        int n = word.size();
        int count = 1;
        
        for (int i = 1; i < n; ++i) {
            if (word[i] == word[i - 1]) {
                int length = 2;
                while (i + 1 < n && word[i + 1] == word[i]) {
                    ++i;
                    ++length;
                }
                count += length - 1;
            }
        }
        
        return count;
    }
};
",1434286325
Anmol Sharma,Anmol0508,720,3576,cpp,"class Solution {
public:
    vector<int> findSubtreeSizes(std::vector<int>& parent, std::string labels) {
        int a = parent.size();
        vector<std::vector<int>> children(a);
        vector<int> subtreeSizes(a, 0);
        vector<int> d(a);

        // Construct the tree
        for (int b = 1; b < a; ++b) {
            children[parent[b]].push_back(b);
        }

        vector<int> labelPosition(26, -1); 
        function<void(int)> dfs = [&](int currentNode) {
            int c = labels[currentNode] - 'a';
            int parentLabel = parent[currentNode];

            // Track the last visited position of the current label
            if (labelPosition[c] != -1) {
                d[currentNode] = labelPosition[c];
            } else {
                d[currentNode] = parentLabel;
            }

            int tempPosition = labelPosition[c];
            labelPosition[c] = currentNode;

            for (int child : children[currentNode]) {
                dfs(child);
            }
            labelPosition[c] = tempPosition;
        };

        dfs(0);

        // Build the subtree
        vector<std::vector<int>> subtreeChildren(a);
        for (int childIndex = 1; childIndex < a; ++childIndex) {
            subtreeChildren[d[childIndex]].push_back(childIndex);
        }

        function<int(int)> countSubtreeSizes = [&](int node) {
            int totalSize = 1; 
            for (int child : subtreeChildren[node]) {
                totalSize += countSubtreeSizes(child);
            }
            subtreeSizes[node] = totalSize;
            return totalSize;
        };

        countSubtreeSizes(0);
        return subtreeSizes;
    }
};",1434336483
Anmol Sharma,Anmol0508,720,3587,cpp,"class Solution {
public:
    int maxScore(int days, int a, vector<vector<int>>& e, vector<vector<int>>& b) {
        vector<vector<int>> dp(a + 1, vector<int>(days, 0));

        for (int day = 1; day <= a; ++day) {
            for (int c = 0; c < days; ++c) {
                int d = dp[day - 1][c] + e[day - 1][c];
                int g = 0;

                for (int f = 0; f < days; ++f) {
                    if (f != c) {
                        g = max(g, dp[day - 1][f] + b[f][c]);
                    }
                }

                dp[day][c] = max(d, g);
            }
        }

        int maxScore = 0;
        for (int activity = 0; activity < days; ++activity) {
            maxScore = max(maxScore, dp[a][activity]);
        }

        return maxScore;
    }
};",1434323023
Anmol Sharma,Anmol0508,720,3617,ruby,"# @param {String} word
# @return {Integer}
def possible_string_count(word)
  a = 1  
  i = 0
  while i < word.length
    j = i + 1
    while j < word.length && word[j] == word[i]
      j += 1
    end
    a += j - i - 1  
    
    i = j  # Move to the next group of characters
  end
  
  a
end
",1434288838
garimadua2301,garimadua2301,721,3576,python,"from collections import defaultdict

class Solution:
    def findSubtreeSizes(self, parent, s):
        n = len(parent)
        # Step 1: Build the initial tree structure using adjacency list
        tree = defaultdict(list)
        for i in range(1, n):
            tree[parent[i]].append(i)
        
        # Step 2: Find the closest ancestors and adjust the tree
        closest_ancestor = {}
        new_parent = list(parent)  # Start with the original parent array
        
        def dfs(node):
            # Track the last occurrence of the current character
            char = s[node]
            if char in closest_ancestor:
                new_parent[node] = closest_ancestor[char]
            
            # Temporarily set this node as the closest ancestor for its character
            original_closest = closest_ancestor.get(char, None)
            closest_ancestor[char] = node
            
            # Traverse children
            for child in tree[node]:
                dfs(child)
            
            # Restore the original closest ancestor after backtracking
            if original_closest is None:
                del closest_ancestor[char]
            else:
                closest_ancestor[char] = original_closest
        
        # Start DFS from the root (node 0)
        dfs(0)
        
        # Step 3: Build the final tree based on new_parent
        final_tree = defaultdict(list)
        for i in range(1, n):
            final_tree[new_parent[i]].append(i)
        
        # Step 4: Calculate subtree sizes
        def calculate_sizes(node):
            size = 1  # Start with the current node
            for child in final_tree[node]:
                size += calculate_sizes(child)
            subtree_sizes[node] = size
            return size
        
        subtree_sizes = [0] * n
        calculate_sizes(0)
        
        return subtree_sizes
",1434280885
garimadua2301,garimadua2301,721,3587,java,"class Solution {
    private int[][] dp;
    private int[][] stayScore;
    private int[][] travelScore;
    private int n;
    private int k;

    public int maxScore(int n, int k, int[][] stayScore, int[][] travelScore) {
        this.n = n;
        this.k = k;
        this.stayScore = stayScore;
        this.travelScore = travelScore;

        dp = new int[k + 1][n];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }

        int result = 0;
        for (int startCity = 0; startCity < n; ++startCity) {
            result = Math.max(result, solve(0, startCity));
        }
        return result;
    }

    private int solve(int day, int curr) {
        if (day == k) {
            return 0;
        }
        if (dp[day][curr] != -1) {
            return dp[day][curr];
        }

        int maxPoints = stayScore[day][curr] + solve(day + 1, curr);

        for (int nextCity = 0; nextCity < n; ++nextCity) {
            if (nextCity != curr) {
                maxPoints = Math.max(maxPoints, travelScore[curr][nextCity] + solve(day + 1, nextCity));
            }
        }

        dp[day][curr] = maxPoints;
        return maxPoints;
    }
}",1434308341
garimadua2301,garimadua2301,721,3617,python,"class Solution:
    def possibleStringCount(self, word):
        n = len(word)
        count = 1  # At least the word itself is one of the possibilities
        
        i = 0
        while i < n:
            j = i
            # Find the length of consecutive repeated characters
            while j < n and word[j] == word[i]:
                j += 1
            
            # Calculate possible original strings if Alice had an extra keypress
            length_of_repeats = j - i
            if length_of_repeats > 1:
                count += length_of_repeats - 1  # Alice could have pressed one key extra
            
            # Move to the next group of characters
            i = j
        
        return count

# Example usage:
sol = Solution()
print(sol.possibleStringCount(""abbcccc""))  # Output: 5
print(sol.possibleStringCount(""abcd""))     # Output: 1
print(sol.possibleStringCount(""aaaa""))     # Output: 4
",1434290329
Dmitry,Dimed,723,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:

        parent2 = [c for c in parent]

        tree1 = defaultdict(list)

        for idx, p in enumerate(parent):
            tree1[p].append(idx)

        def traverse(tree, root, history, parent2):
            if s[root] in history:
                parent2[root] = history[s[root]]
            history2 = history.copy()
            history2[s[root]] = root
            for nextElem in tree[root]:
                traverse(tree, nextElem, history2, parent2)

        traverse(tree1, 0, {}, parent2)

        tree2 = defaultdict(list)

        for idx, p in enumerate(parent2):
            tree2[p].append(idx)
        
        ans = [i for i in parent]
        def traverse2(tree, root, ans):
            res = 1
            for nextE in tree[root]:
                res += traverse2(tree, nextE, ans)
            ans[root] = res
            return res
            
        traverse2(tree2, 0, ans)
        
        return ans",1434311924
Dmitry,Dimed,723,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        # on the evening of each day I have a vector of sities with max scores
        scores = [0 for i in range(n)]
        for day in range(k):
            scores2 = scores.copy()
            for idx, score in enumerate(scores):
                for nextC in range(n):
                    scores2[nextC] = max(scores2[nextC], score + travelScore[idx][nextC])

            for idx, score in enumerate(scores):
                scores2[idx] = max(scores2[idx], scores[idx] + stayScore[day][idx])

            scores = scores2

        return max(scores)
                ",1434343378
Dmitry,Dimed,723,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        prevC = 'X'
        localCnt = 1
        for c in word:
            if c == prevC:
                localCnt += 1
            else:
                ans += localCnt-1 if localCnt > 1 else 0
                prevC = c
                localCnt = 1

        ans += localCnt-1 if localCnt > 1 else 0
        
        return ans",1434265370
ykamo,ykamo,725,3576,python3,"class Solution:
    def findSubtreeSizes(self, parent: List[int], s: str) -> List[int]:
        def dfs(n, g, a):
            if n not in g:
                return {s[n]: set([n])}
            c = s[n]
            e = defaultdict(set)
            for m in g[n]:
                d = dfs(m, g, a)
                if c in d:
                    for k in d.pop(c):
                        if parent[k] != n:
                            a.append((k, n))
                for k, v in d.items():
                    e[k] |= v
            e[c].add(n)
            return e
        def dfs2(n, g, a):
            if n not in g:
                a[n] = 1
                return 1
            v = 1 + sum([dfs2(m, g, a) for m in g[n]])
            a[n] = v
            return v            
                
        g = defaultdict(set)
        for i, p in enumerate(parent):
            if i == 0:
                continue
            g[p].add(i)
        #print(g)
        ops = []
        dfs(0, g, ops)
        #print(ops)
        for a, b in ops:
            parent[a] = b
        #print(parent)
        ans = [0] * len(parent)
        g = defaultdict(set)
        for i, p in enumerate(parent):
            if i == 0:
                continue
            g[p].add(i)
        #print(g)
        dfs2(0, g, ans)
        return ans
            
        ",1434323766
ykamo,ykamo,725,3587,python3,"class Solution:
    def maxScore(self, n: int, k: int, stayScore: List[List[int]], travelScore: List[List[int]]) -> int:
        d = [0] * n
        for i in range(k):
            e = [0] * n
            for x in range(n):
                s = d[x] + stayScore[i][x]
                for y in range(n):
                    t = d[y] + travelScore[y][x]
                    s = max(s, t)
                e[x] = s
            d = e
        return max(d)
                
                    
            
        ",1434336747
ykamo,ykamo,725,3617,python3,"class Solution:
    def possibleStringCount(self, word: str) -> int:
        ans = 1
        run = 1
        prev = """"
        for c in word:
            if c == prev:
                run += 1
            else:
                ans += run - 1
                run = 1
            prev = c
        return ans + run - 1
            
        ",1434276672
