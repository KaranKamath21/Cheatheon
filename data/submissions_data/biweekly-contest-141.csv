username,userslug,contest_rank,question_id,language,code,submission_id
Konsept,konssept,1,3487,rust,"impl Solution {
    pub fn max_removals(source: String, pattern: String, target_indices: Vec<i32>) -> i32 {
        let n = source.len();
        let m = pattern.len();
        
        let l = target_indices.clone();
        
        let mut t = vec![false; n];
        for &i in &target_indices {
            t[i as usize] = true;
        }
        
        let mut d = vec![i32::MAX; m + 1];
        d[0] = 0;
        
        let s: Vec<char> = source.chars().collect();
        let p: Vec<char> = pattern.chars().collect();
        
        for i in 0..n {
            for j in (1..=m).rev() {
                if s[i] == p[j - 1] {
                    if d[j - 1] != i32::MAX {
                        let u = if t[i] { 1 } else { 0 };
                        d[j] = d[j].min(d[j - 1] + u);
                    }
                }
            }
        }
        
        if d[m] == i32::MAX {
            return 0;
        }
        
        target_indices.len() as i32 - d[m]
    }
}",1419997928
Konsept,konssept,1,3604,rust,"impl Solution {
    pub fn number_of_ways(n: i32, x: i32, y: i32) -> i32 {
        const MOD: i64 = 1_000_000_007;
        
        let mut f = vec![1; (x + 1) as usize];
        for i in 1..=x {
            f[i as usize] = f[(i - 1) as usize] * i as i64 % MOD;
        }
        
        let mut inv_f = vec![1; (x + 1) as usize];
        inv_f[x as usize] = Self::pow_mod(f[x as usize], MOD - 2, MOD);
        for i in (1..x).rev() {
            inv_f[i as usize] = inv_f[(i + 1) as usize] * (i + 1) as i64 % MOD;
        }
        
        let mut p_y = vec![1; (x + 1) as usize];
        for k in 1..=x {
            p_y[k as usize] = p_y[(k - 1) as usize] * y as i64 % MOD;
        }
        
        let mut s = vec![0; (x + 1) as usize];
        s[0] = 1;
        for i in 1..=n {
            let k_max = x.min(i);
            for k in (1..=k_max).rev() {
                s[k as usize] = (k as i64 * s[k as usize] + s[(k - 1) as usize]) % MOD;
            }
            s[0] = 0;
        }
        
        let mut sum = 0;
        let k_limit = n.min(x);
        for k in 1..=k_limit {
            let p = f[x as usize] * inv_f[(x - k) as usize] % MOD;
            let term = p * s[k as usize] % MOD * p_y[k as usize] % MOD;
            sum = (sum + term) % MOD;
        }
        
        sum as i32
    }
    
    fn pow_mod(mut a: i64, mut b: i64, m: i64) -> i64 {
        let mut res = 1;
        a %= m;
        while b > 0 {
            if b & 1 == 1 {
                res = res * a % m;
            }
            a = a * a % m;
            b >>= 1;
        }
        res
    }
}",1420000118
Konsept,konssept,1,3605,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![-1; n];
        
        for (i, &y) in nums.iter().enumerate() {
            let mut min_x = i32::MAX;
            
            for k in 0..=30 {
                if (y >> k) & 1 == 1 {
                    let x = y - (1 << k);
                    if x >= 0 && (x | (x + 1)) == y {
                        if x < min_x {
                            min_x = x;
                        }
                    }
                }
            }
            
            if min_x != i32::MAX {
                ans[i] = min_x;
            }
        }
        
        ans
    }
}",1419994888
Konsept,konssept,1,3611,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![-1; n];
        
        for (i, &y) in nums.iter().enumerate() {
            let mut min_x = i32::MAX;
            
            for k in 0..=30 {
                if (y >> k) & 1 == 1 {
                    let x = y - (1 << k);
                    if x >= 0 && (x | (x + 1)) == y {
                        if x < min_x {
                            min_x = x;
                        }
                    }
                }
            }
            
            if min_x != i32::MAX {
                ans[i] = min_x;
            }
        }
        
        ans
    }
}",1419994967
peace,shankardtu21,2,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& ti) {
        int n = s.size(), m = p.size();
        vector<bool> v(n, false);
        for(int idx : ti)
            v[idx] = true;
        vector<int> t(m + 1, INT_MAX / 2);
        t[0] = 0;
        for(int i = 0; i < n; ++i) {
            for(int j = min(i, m - 1); j >= 0; --j) {
                if(s[i] == p[j]) {
                    int cost = t[j] + v[i];
                    t[j + 1] = min(t[j + 1], cost);
                }
            }
        }
        int min_used = t[m];
        return ti.size() - min_used;
    }
};
",1419999188
peace,shankardtu21,2,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int MOD = 1e9+7;
        int N = max(n, x);
        vector<long long> f(N+1), inf(N+1);
        f[0] = inf[0] = 1;
        for(int i=1; i<=N; ++i)
            f[i] = f[i-1] * i % MOD;
        inf[N] = modpow(f[N], MOD-2, MOD);
        for(int i=N-1; i>=1; --i)
            inf[i] = inf[i+1] * (i+1) % MOD;
        auto comb = [&](int n, int k) {
            if(k<0 || k>n) return 0LL;
            return f[n] * inf[k] % MOD * inf[n-k] % MOD;
        };
        vector<vector<long long>> S(n+1, vector<long long>(n+1, 0));
        S[0][0] = 1;
        for(int i=1; i<=n; ++i){
            for(int j=1; j<=i; ++j){
                S[i][j] = (j*S[i-1][j]%MOD + S[i-1][j-1])%MOD;
            }
        }
        int ans = 0;
        for(int k=1; k<=min(n,x); ++k){
            long long c = comb(x,k) * f[k] % MOD;
            c = c * S[n][k] % MOD;
            c = c * modpow(y,k,MOD) % MOD;
            ans = (ans + c) % MOD;
        }
        return ans;
    }
private:
    long long modpow(long long a, long long b, long long mod){
        long long ans = 1;
        a %= mod;
        while(b){
            if(b&1) ans = ans * a % mod;
            a = a * a % mod;
            b >>=1;
        }
        return ans;
    }
};
",1420003171
peace,shankardtu21,2,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        for(int num:n){
            int ans=-1;
            for(int x=0;x<=num;++x){
                if((x|(x+1))==num){
                    ans=x;
                    break;
                }
            }
            a.push_back(ans);
        }
        return a;
    }
};
",1419994097
peace,shankardtu21,2,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int N : nums) {
            int min_x = -1;
            for(int k = 0; k < 31; ++k) {
                if(N & (1 << k)) {
                    int x = N - (1 << k);
                    if(x >= 0 && (x | (x + 1)) == N) {
                        if(min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};
",1419995478
Shivam,itshivam,3,3487,golang,"package main

import (
	""fmt""
	""math""
)

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func maxRemovals(s string, p string, t []int) int {
	l := len(s)
	k := len(p)

	g := make([]bool, l)
	for _, i := range t {
		g[i] = true
	}

	const I = math.MaxInt32
	d := make([]int, k+1)
	for i := 0; i <= k; i++ {
		d[i] = I
	}
	d[0] = 0

	for i := 0; i < l; i++ {
		for j := k - 1; j >= 0; j-- {
			if s[i] == p[j] {
				if d[j]+0 < d[j+1] {
					if g[i] {
						d[j+1] = min(d[j+1], d[j]+1)
					} else {
						d[j+1] = min(d[j+1], d[j])
					}
				} else {
					if g[i] {
						d[j+1] = min(d[j+1], d[j]+1)
					} else {
						d[j+1] = min(d[j+1], d[j])
					}
				}
			}
		}
	}

	if d[k] == I {
		return 0
	}
	r := len(t) - d[k]
	if r < 0 {
		return 0
	}
	return r
}
",1420004071
Shivam,itshivam,3,3604,golang,"const MOD int64 = 1_000_000_007

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func numberOfWays(n int, x int, y int) int {
	lS := make([][]int64, n+1)
	for i := 0; i <= n; i++ {
		lS[i] = make([]int64, x+1)
	}
	lS[0][0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= min(i, x); j++ {
			lS[i][j] = (int64(j)*lS[i-1][j] + lS[i-1][j-1]) % MOD
		}
	}
	lC := make([]int64, x+1)
	lC[0] = 1
	for i := 1; i <= x; i++ {
		for j := min(i, x); j >= 1; j-- {
			lC[j] = (lC[j] + lC[j-1]) % MOD
		}
	}
	lFactorial := make([]int64, x+1)
	lFactorial[0] = 1
	for i := 1; i <= x; i++ {
		lFactorial[i] = (lFactorial[i-1] * int64(i)) % MOD
	}
	lMaxK := min(x, n)
	lYPows := make([]int64, lMaxK+1)
	lYPows[0] = 1
	for k := 1; k <= lMaxK; k++ {
		lYPows[k] = (lYPows[k-1] * int64(y)) % MOD
	}
	var lResult int64 = 0
	for k := 1; k <= lMaxK; k++ {
		lTerm := (lC[k] * lFactorial[k]) % MOD
		lTerm = (lTerm * lS[n][k]) % MOD
		lTerm = (lTerm * lYPows[k]) % MOD
		lResult = (lResult + lTerm) % MOD
	}
	return int(lResult)
}
",1420009838
Shivam,itshivam,3,3605,golang,"func minBitwiseArray(nums []int) []int {
	r := make([]int, len(nums))
	for i, n := range nums {
		m := math.MaxInt32
		for j := 0; j <= 30; j++ {
			if (n & (1 << j)) != 0 {
				b := n &^ (1 << j)
				if b < 0 || b >= n {
					continue
				}
				c := b + 1
				if (b | c) == n {
					if b < m {
						m = b
					}
				}
			}
		}
		if m != math.MaxInt32 {
			r[i] = m
		} else {
			r[i] = -1
		}
	}
	return r
}
",1420013893
Shivam,itshivam,3,3611,golang,"func minBitwiseArray(nums []int) []int {
	r := make([]int, len(nums))
	for i, n := range nums {
		m := math.MaxInt32
		for j := 0; j <= 30; j++ {
			if (n & (1 << j)) != 0 {
				b := n &^ (1 << j)
				if b < 0 || b >= n {
					continue
				}
				c := b + 1
				if (b | c) == n {
					if b < m {
						m = b
					}
				}
			}
		}
		if m != math.MaxInt32 {
			r[i] = m
		} else {
			r[i] = -1
		}
	}
	return r
}
",1420013381
Shreyan Ray,Dominater069L,4,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector <bool> a(n, false);
        for (auto x : targetIndices) a[x] = true;
        
        vector<int> dp(m + 1, -(int)1e9);
        dp[0] = 0;
        for (int i = 0; i < n; i++){
            vector <int> ndp(m + 1, -(int)1e9);
            for (int j = 0; j <= m; j++){
                ndp[j] = max(ndp[j], dp[j] + (a[i]));
                if (j != m && source[i] == pattern[j]){
                    ndp[j + 1] = max(ndp[j + 1], dp[j]);
                }
            }
            
            dp = ndp;
        }
        
        int ans = dp[m];
        return ans;
    }
};",1420014602
Shreyan Ray,Dominater069L,4,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int mod = 1e9 + 7;
        vector <int> dp(x + 1, 0);
        dp[0] = 1;
        
        for (int i = 1; i <= n; i++){
            vector <int> ndp(x + 1, 0);
            for (int j = 1; j <= x; j++){
                // assign to one of the bands 
                ndp[j] = (ndp[j] + 1LL * dp[j] * j) % mod;
                ndp[j] = (ndp[j] + 1LL * dp[j - 1] * (x - j + 1)) % mod;
            }
            
            dp = ndp;
        }
        
        int ans = 0;
        int v = 1;
        for (int i = 1; i <= x; i++){
            v = (1LL * v * y) % mod;
            ans = (ans + 1LL * v * dp[i]) % mod;
        }
        return ans;
    }
};",1420010475
Shreyan Ray,Dominater069L,4,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto x : nums){
            if (x % 2 == 0){
                ans.push_back(-1);
            } else {
                int p = 0;
                while (x >> (p + 1) & 1){
                    p++;
                }
                ans.push_back(x - (1 << p));
            }
        }
        return ans;
    }
};",1419994497
Shreyan Ray,Dominater069L,4,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto x : nums){
            if (x % 2 == 0){
                ans.push_back(-1);
            } else {
                int p = 0;
                while (x >> (p + 1) & 1){
                    p++;
                }
                ans.push_back(x - (1 << p));
            }
        }
        return ans;
    }
};",1419994643
kmjp,kmjp,8,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

int from[3030];
int to[3030];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int C[3030]={};
        FORR(a,targetIndices) C[a]=1;
        int N=source.size(),M=pattern.size();
        int i,j;
        FOR(i,M+1) from[i]=-1010;
        from[0]=0;
        FOR(i,N) {
			FOR(j,M+1) to[j]=from[j];
			FOR(j,M+1) if(from[j]>=0) {
				if(j<M&&pattern[j]==source[i]) {
					to[j+1]=max(to[j+1],from[j]);
				}
				if(C[i]) {
					to[j]=max(to[j],from[j]+1);
				}
			}
			FOR(j,M+1) from[j]=to[j];
		}
		return from[M];
    }
};
",1420004373
kmjp,kmjp,8,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

const ll mo=1000000007;

ll from[1010],to[1010];

ll comb(ll N_, ll C_) {
	const int NUM_=400001;
	static ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];
	if (fact[0]==0) {
		inv[1]=fact[0]=factr[0]=1;
		for (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;
		for (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;
	}
	if(C_<0 || C_>N_) return 0;
	return factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;
}

ll modpow(ll a, ll n = mo-2) {
	ll r=1;a%=mo;
	while(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;
	return r;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        ZERO(from);
        from[0]=1;
        int i,j,k;
        FOR(i,n) {
			ZERO(to);
			FOR(j,x+1) {
				(to[j]+=from[j]*j)%=mo;
				(to[j+1]+=from[j]*(x-j)*y)%=mo;
			}
			swap(from,to);
		}
		ll ret=0;
		for(i=1;i<=x;i++) (ret+=from[i])%=mo;
		return ret;
		
    }
};
",1420019620
kmjp,kmjp,8,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
		vector<int> R;
		FORR(n,nums) {
			if(n%2==0) {
				R.push_back(-1);
			}
			else {
				int i;
				FOR(i,30) {
					if((n&(1<<i))==0) {
						n^=1<<(i-1);
						break;
					}
				}
				R.push_back(n);
			}
		}
        return R;
    }
};
",1419995103
kmjp,kmjp,8,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
		vector<int> R;
		FORR(n,nums) {
			if(n%2==0) {
				R.push_back(-1);
			}
			else {
				int i;
				FOR(i,30) {
					if((n&(1<<i))==0) {
						n^=1<<(i-1);
						break;
					}
				}
				R.push_back(n);
			}
		}
        return R;
    }
};
",1419995031
BarryBondsOfLC,BarryBondsOfLC,10,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        target_set = set(targetIndices)

        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0

        for i in range(1, n + 1):
            for j in range(0, m + 1):
                dp[i][j] = min(dp[i][j], dp[i-1][j])
                if j < m and source[i-1] == pattern[j]:
                    if i-1 not in target_set:
                        dp[i][j+1] = min(dp[i][j+1], dp[i-1][j])
                    else:
                        dp[i][j+1] = min(dp[i][j+1], dp[i-1][j] + 1)

        if dp[n][m] == float('inf'):
            return 0

        return len(targetIndices) - dp[n][m]",1420003411
BarryBondsOfLC,BarryBondsOfLC,10,3604,cpp,"const int MOD = 1e9 + 7;

using ll = long long;

ll powmod_func(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) {
            res = res * a % mod;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<ll> S(x + 1, 0);
        if (n >= 1) {
            S[1] = 1;
        }
        for (int i = 2; i <= n; ++i) {
            for (int k = min(i, x); k >= 1; --k) {
                S[k] = (S[k - 1] + k * S[k]) % MOD;
            }
        }
        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        ll sum = 0;
        for (int k = 1; k <= min(x, n); ++k) {
            ll P = fact[x] * powmod_func(fact[x - k], MOD - 2, MOD) % MOD;
            ll power_y = powmod_func(y, k, MOD);
            sum = (sum + P * S[k] % MOD * power_y % MOD) % MOD;
        }
        return sum;
    }
};",1420020152
BarryBondsOfLC,BarryBondsOfLC,10,3605,python3,"class Solution:
    def minBitwiseArray(self, A: List[int]) -> List[int]:
        ans = []
        for p in A:
            min_a = float('inf')
            for m in range(32):
                if p & (1 << m):
                    a = p & ~(1 << m)
                    if (a | (a + 1)) == p and a < min_a:
                        min_a = a
            ans.append(min_a if min_a != float('inf') else -1)
        return ans",1420023491
BarryBondsOfLC,BarryBondsOfLC,10,3611,python3,"class Solution:
    def minBitwiseArray(self, A: List[int]) -> List[int]:
        ans = []
        for p in A:
            min_a = float('inf')
            for m in range(32):
                if p & (1 << m):
                    a = p & ~(1 << m)
                    if (a | (a + 1)) == p and a < min_a:
                        min_a = a
            ans.append(min_a if min_a != float('inf') else -1)
        return ans",1420023791
Ethan,ethanrao,13,3487,cpp,"class Solution {
public:
    int f[3005][3005], vis[3005];
    const int M = 10000000;
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        for(auto v: targetIndices) vis[v] = 1;
        int n = source.size(), m = pattern.size();
        f[0][0] = 0;
        for(int i = 1; i <= m; ++i) f[0][i] = M;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j){
                f[i][j] = M;
                f[i][j] = f[i - 1][j];
                if(source[i - 1] == pattern[j - 1]){
                    if(vis[i - 1]) f[i][j] = std::min(f[i][j], f[i - 1][j - 1] + 1);
                    else f[i][j] = std::min(f[i][j], f[i - 1][j - 1]);
                }
            }
        return targetIndices.size() - f[n][m];
    }
};",1420014770
Ethan,ethanrao,13,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int minus(int x, int y){
        return x < y ? x - y + mod : x - y;
    }
    int fac[1005], ifac[1005], f[1005][1005];
    inline int C(int x, int y){
        if(y < 0 || x < y) return 0;
        return mul(mul(fac[x], ifac[y]), ifac[x - y]);
    }
    inline int Qpow(int x, int y){
        int r = 1;
        while(y){
            if(y & 1) r = mul(r, x);
            x = mul(x, x);
            y >>= 1;
        }
        return r;
    }
    int numberOfWays(int n, int x, int y) {
        fac[0] = 1;
        for(int i = 1; i <= 1000; ++i) fac[i] = mul(fac[i - 1], i);
        for(int i = 0; i <= 1000; ++i) ifac[i] = Qpow(fac[i], mod - 2);
        int ans = 0;
        f[1][1] = 1;
        for(int i = 2; i <= 1000; ++i)
            for(int j = 1; j <= i; ++j)
                f[i][j] = add(f[i - 1][j - 1], mul(j, f[i - 1][j]));
        for(int i = 1, r = y; i <= x; ++i, r = mul(r, y)){
            int tmp = mul(C(x, i), r);
            ans = add(ans, mul(tmp, mul(f[n][i], fac[i])));
        }
        return ans;
    }
};",1420005076
Ethan,ethanrao,13,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        std::vector <int> ans;
        ans.resize(nums.size());
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2){
                ans[i] = -1;
                continue;
            }
            int now = 0;
            for(int j = 29; j >= 0; --j){
                if(!(nums[i] & (1 << j))) continue;
                int tmp = now + (1 << j) - 1;
                if((tmp | (tmp + 1)) == nums[i]){
                    ans[i] = tmp;
                    break;
                }
                now += (1 << j);
            }
        }
        return ans;
    }
};",1420024880
Ethan,ethanrao,13,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        std::vector <int> ans;
        ans.resize(nums.size());
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2){
                ans[i] = -1;
                continue;
            }
            int now = 0;
            for(int j = 29; j >= 0; --j){
                if(!(nums[i] & (1 << j))) continue;
                int tmp = now + (1 << j) - 1;
                if((tmp | (tmp + 1)) == nums[i]){
                    ans[i] = tmp;
                    break;
                }
                now += (1 << j);
            }
        }
        return ans;
    }
};",1420024764
AntonRaichuk,AntonRaichuk,17,3487,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

int r[3033][3033];
bool u[3333];
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        CL(u,0);
        REP(i,t.size())u[t[i]]=1;
        int n = s.size();
        REP(i,n+1)REP(j,p.size()+1)r[i][j]=-1;
        r[0][0]=0;
        REP(i,n)REP(j,p.size()+1)if(r[i][j]!=-1){
            //cout<<i<<' '<<j<<' '<<r[i][j]<<endl;
            if(u[i]){
                r[i+1][j]=max(r[i+1][j],r[i][j]+1);
            }
            r[i+1][j]=max(r[i+1][j],r[i][j]);
            if(j<p.size() && s[i]==p[j]){
                r[i+1][j+1]=max(r[i+1][j+1],r[i][j]);
            }
        }
        return r[n][p.size()];
    }
};",1420009690
AntonRaichuk,AntonRaichuk,17,3604,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

const int mod = 1000000007;

int d[1001][1001];
ll yp[1001];

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        yp[0]=1;
        FOR(i,1,1001)yp[i]=(yp[i-1]*y)%mod;
        REP(i,n+1)REP(j,x+1)d[i][j]=0;
        d[0][0]=1;
        REP(i,n)REP(j,x+1){
            d[i+1][j]=(d[i+1][j]+d[i][j]*ll(j))%mod;
            if(j+1<=x)d[i+1][j+1]=(d[i+1][j+1]+d[i][j]*ll(x-j))%mod;
        }
        ll res=0;
        FOR(i,1,x+1){
            res = (res + d[n][i]*yp[i])%mod;

        }
        return res;
    }
};",1420018707
AntonRaichuk,AntonRaichuk,17,3605,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi r;
        REP(i,nums.size()){
            if(nums[i]==2)r.pb(-1);
            else{
                int x = 0;
                while(nums[i]&(1<<x))x++;
                r.pb(nums[i]^((1<<(x-1))));
            }
        }
        return r;
    }
};",1419997710
AntonRaichuk,AntonRaichuk,17,3611,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi r;
        REP(i,nums.size()){
            if(nums[i]==2)r.pb(-1);
            else{
                int x = 0;
                while(nums[i]&(1<<x))x++;
                r.pb(nums[i]^((1<<(x-1))));
            }
        }
        return r;
    }
};",1419997435
Mark,myselfshivams,18,3487,python3,"from typing import List
import math

class Solution:
    def maxRemovals(self, src: str, pat: str, trgIndices: List[int]) -> int:
        src_len = len(src)
        pat_len = len(pat)

        is_target = [False] * src_len
        for idx in trgIndices:
            is_target[idx] = True

        INF = math.inf
        dp = [INF] * (pat_len + 1)
        dp[0] = 0

        i = 0
        while i < src_len:
            j = pat_len - 1
            while j >= 0:
                if src[i] == pat[j]:
                    dp[j + 1] = min(dp[j + 1], dp[j] + (1 if is_target[i] else 0))
                j -= 1  
            i += 1  

        if dp[pat_len] == INF:
            return 0
        remaining = len(trgIndices) - dp[pat_len]
        return max(remaining, 0)
",1420028832
Mark,myselfshivams,18,3604,python3,"MOD = 1_000_000_007

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        s = [[0] * (x + 1) for _ in range(n + 1)]
        s[0][0] = 1
        
        i = 1
        while i <= n:
            j = 1
            while j <= min(i, x):
                s[i][j] = (j * s[i-1][j] + s[i-1][j-1]) % MOD
                j += 1
            i += 1

        c = [0] * (x + 1)
        c[0] = 1
        
        i = 1
        while i <= x:
            j = min(i, x)
            while j > 0:
                c[j] = (c[j] + c[j-1]) % MOD
                j -= 1
            i += 1

        f = [0] * (x + 1)
        f[0] = 1
        
        i = 1
        while i <= x:
            f[i] = (f[i-1] * i) % MOD
            i += 1

        m = min(x, n)
        
        p = [0] * (m + 1)
        p[0] = 1
        
        k = 1
        while k <= m:
            p[k] = (p[k-1] * y) % MOD
            k += 1

        r = 0
        k = 1
        while k <= m:
            t = (c[k] * f[k]) % MOD
            t = (t * s[n][k]) % MOD
            t = (t * p[k]) % MOD
            r = (r + t) % MOD
            k += 1

        return r
",1420025370
Mark,myselfshivams,18,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for number in nums:
            minimum = float('inf')
            for index in range(31):
                if number & (1 << index):
                    candidate = number & ~(1 << index)
                    if candidate < 0 or candidate >= number:
                        continue
                    next_candidate = candidate + 1
                    if (candidate | next_candidate) == number:
                        if candidate < minimum:
                            minimum = candidate
            if minimum != float('inf'):
                result.append(minimum)
            else:
                result.append(-1)
        return result
",1420020559
Mark,myselfshivams,18,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for number in nums:
            minimum = float('inf')
            for index in range(31):
                if number & (1 << index):
                    candidate = number & ~(1 << index)
                    if candidate < 0 or candidate >= number:
                        continue
                    next_candidate = candidate + 1
                    if (candidate | next_candidate) == number:
                        if candidate < minimum:
                            minimum = candidate
            if minimum != float('inf'):
                result.append(minimum)
            else:
                result.append(-1)
        return result
",1420020256
Kude,Kude,19,3487,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;



class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
      constexpr int INF = 1001001001;
      int n = source.size(), m = pattern.size();
      VI dp(m + 1, -INF), ndp;
      dp[0] = 0;
      reverse(all(targetIndices));
      for (int id = -1; char c : source) {
        id++;
        ndp.assign(m + 1, -INF);
        rep(i, m + 1) {
          if (i < m && pattern[i] == c) chmax(ndp[i+1], dp[i]);
          else chmax(ndp[i], dp[i]);
        }
        if (!targetIndices.empty() && targetIndices.back() == id) {
          targetIndices.pop_back();
          rep(i, m + 1) chmax(ndp[i], dp[i] + 1);
        }
        swap(dp, ndp);
      }
      return dp[m];
    }
};",1420011223
Kude,Kude,19,3604,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;

#include <cassert>
#include <numeric>
#include <type_traits>

#ifdef _MSC_VER
#include <intrin.h>
#endif


#include <utility>

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

constexpr long long safe_mod(long long x, long long m) {
    x %= m;
    if (x < 0) x += m;
    return x;
}

struct barrett {
    unsigned int _m;
    unsigned long long im;

    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

    unsigned int umod() const { return _m; }

    unsigned int mul(unsigned int a, unsigned int b) const {

        unsigned long long z = a;
        z *= b;
#ifdef _MSC_VER
        unsigned long long x;
        _umul128(z, im, &x);
#else
        unsigned long long x =
            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
        unsigned long long y = x * _m;
        return (unsigned int)(z - y + (z < y ? _m : 0));
    }
};

constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
    if (m == 1) return 0;
    unsigned int _m = (unsigned int)(m);
    unsigned long long r = 1;
    unsigned long long y = safe_mod(x, m);
    while (n) {
        if (n & 1) r = (r * y) % _m;
        y = (y * y) % _m;
        n >>= 1;
    }
    return r;
}

constexpr bool is_prime_constexpr(int n) {
    if (n <= 1) return false;
    if (n == 2 || n == 7 || n == 61) return true;
    if (n % 2 == 0) return false;
    long long d = n - 1;
    while (d % 2 == 0) d /= 2;
    constexpr long long bases[3] = {2, 7, 61};
    for (long long a : bases) {
        long long t = d;
        long long y = pow_mod_constexpr(a, t, n);
        while (t != n - 1 && y != 1 && y != n - 1) {
            y = y * y % n;
            t <<= 1;
        }
        if (y != n - 1 && t % 2 == 0) {
            return false;
        }
    }
    return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
    a = safe_mod(a, b);
    if (a == 0) return {b, 0};

    long long s = b, t = a;
    long long m0 = 0, m1 = 1;

    while (t) {
        long long u = s / t;
        s -= t * u;
        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b


        auto tmp = s;
        s = t;
        t = tmp;
        tmp = m0;
        m0 = m1;
        m1 = tmp;
    }
    if (m0 < 0) m0 += b / s;
    return {s, m0};
}

constexpr int primitive_root_constexpr(int m) {
    if (m == 2) return 1;
    if (m == 167772161) return 3;
    if (m == 469762049) return 3;
    if (m == 754974721) return 11;
    if (m == 998244353) return 3;
    int divs[20] = {};
    divs[0] = 2;
    int cnt = 1;
    int x = (m - 1) / 2;
    while (x % 2 == 0) x /= 2;
    for (int i = 3; (long long)(i)*i <= x; i += 2) {
        if (x % i == 0) {
            divs[cnt++] = i;
            while (x % i == 0) {
                x /= i;
            }
        }
    }
    if (x > 1) {
        divs[cnt++] = x;
    }
    for (int g = 2;; g++) {
        bool ok = true;
        for (int i = 0; i < cnt; i++) {
            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

unsigned long long floor_sum_unsigned(unsigned long long n,
                                      unsigned long long m,
                                      unsigned long long a,
                                      unsigned long long b) {
    unsigned long long ans = 0;
    while (true) {
        if (a >= m) {
            ans += n * (n - 1) / 2 * (a / m);
            a %= m;
        }
        if (b >= m) {
            ans += n * (b / m);
            b %= m;
        }

        unsigned long long y_max = a * n + b;
        if (y_max < m) break;
        n = (unsigned long long)(y_max / m);
        b = (unsigned long long)(y_max % m);
        std::swap(m, a);
    }
    return ans;
}

}  // namespace internal

}  // namespace atcoder


#include <cassert>
#include <numeric>
#include <type_traits>

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value ||
                                  std::is_same<T, __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int128 =
    typename std::conditional<std::is_same<T, __uint128_t>::value ||
                                  std::is_same<T, unsigned __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using make_unsigned_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value,
                              __uint128_t,
                              unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
                                                  is_signed_int128<T>::value ||
                                                  is_unsigned_int128<T>::value,
                                              std::true_type,
                                              std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
                                                 std::is_signed<T>::value) ||
                                                    is_signed_int128<T>::value,
                                                std::true_type,
                                                std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<(is_integral<T>::value &&
                               std::is_unsigned<T>::value) ||
                                  is_unsigned_int128<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
    is_signed_int128<T>::value,
    make_unsigned_int128<T>,
    typename std::conditional<std::is_signed<T>::value,
                              std::make_unsigned<T>,
                              std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<is_integral<T>::value &&
                                  std::is_unsigned<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
                                              std::make_unsigned<T>,
                                              std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
    using mint = static_modint;

  public:
    static constexpr int mod() { return m; }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    static_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    static_modint(T v) {
        long long x = (long long)(v % (long long)(umod()));
        if (x < 0) x += umod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    static_modint(T v) {
        _v = (unsigned int)(v % umod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v -= rhs._v;
        if (_v >= umod()) _v += umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        unsigned long long z = _v;
        z *= rhs._v;
        _v = (unsigned int)(z % umod());
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        if (prime) {
            assert(_v);
            return pow(umod() - 2);
        } else {
            auto eg = internal::inv_gcd(_v, m);
            assert(eg.first == 1);
            return eg.second;
        }
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
    static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
    using mint = dynamic_modint;

  public:
    static int mod() { return (int)(bt.umod()); }
    static void set_mod(int m) {
        assert(1 <= m);
        bt = internal::barrett(m);
    }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    dynamic_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        long long x = (long long)(v % (long long)(mod()));
        if (x < 0) x += mod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        _v = (unsigned int)(v % mod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v += mod() - rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        _v = bt.mul(_v, rhs._v);
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        auto eg = internal::inv_gcd(_v, mod());
        assert(eg.first == 1);
        return eg.second;
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static internal::barrett bt;
    static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder

using namespace atcoder;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using mint = modint1000000007;

constexpr int FACT_SIZE = 1000000;
mint Fact[FACT_SIZE + 1];
mint iFact[FACT_SIZE + 1];
const auto fact_init = [] {
    Fact[0] = mint::raw(1);
    for(int i = 1; i <= FACT_SIZE; ++i) {
        Fact[i] = Fact[i-1] * i;
    }
    iFact[FACT_SIZE] = Fact[FACT_SIZE].inv();
    for(int i = FACT_SIZE; i; --i) {
        iFact[i-1] = iFact[i] * i;
    }
    return false;
}();

mint comb(int n, int k) {
    if (k == 0) return mint::raw(1);
    assert(n >= 0 && k >= 0);
    if (k > n) return mint::raw(0);
    return Fact[n] * iFact[n - k] * iFact[k];
}

mint icomb(int n, int k) {
    return iFact[n] * Fact[n - k] * Fact[k];
}

mint fact(int n) {return Fact[n];}
mint perm(int n, int k) {
    assert(0 <= n);
    return Fact[n] * iFact[n - k];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
      vector<mint> d(x + 1);
      for (int i = 1; i <= x; i++) d[i] = mint(i).pow(n);
      for (int i = 2; i <= x; i++) {
        for (int j = 1; j < i; j++) d[i] -= d[j] * comb(i, j);
      }
      mint ans;
      for (int i = 1; i <= x; i++) ans += comb(x, i) * d[i] * mint(y).pow(i);
      return ans.val();
    }
};
",1420028874
Kude,Kude,19,3605,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;



class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for (int& x : nums) {
          if (x == 2) x = -1;
          else {
            int i = 0;
            while (x >> i & 1) i++;
            i--;
            x ^= 1 << i;
          }
        }
        return nums;
    }
};",1419996805
Kude,Kude,19,3611,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;



class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for (int& x : nums) {
          if (x == 2) x = -1;
          else {
            int i = 0;
            while (x >> i & 1) i++;
            i--;
            x ^= 1 << i;
          }
        }
        return nums;
    }
};",1419996683
Souvik Ghosh,Aluu097,22,3487,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    const int inf  = 1e9;
    void ckmax(int &a, int b){
        if(a < b)a = b;
    }
    int maxRemovals(string s, string p, vector<int>& target) {
        vt<vt<int>>dp(sz(s) + 10 ,vt<int>(sz(p) + 10, 0));
        vt<bool>ok(sz(s), 0);
        for(auto i: target)ok[i] = 1;
        for(int i = 0; i <= sz(s); i++){
            for(int j = 0; j <= sz(p); j++){
                dp[i][j] = -inf;
            }
        }
        dp[0][0] = 0;
        for(int i = 0; i < sz(s); i++){
            for(int j = 0; j <= sz(p); j++){
                if(dp[i][j] == -inf)continue;
                //cout << i << "" "" << j << ""\n"";
                if(ok[i]){
                    ckmax(dp[i + 1][j], dp[i][j] + 1);
                }
                    if(j == sz(p))ckmax(dp[i + 1][j], dp[i][j]);
                    else ckmax(dp[i + 1][j + (s[i] == p[j])], dp[i][j]);
                
            }
        }
        
        return(dp[sz(s)][sz(p)]);
    }
};",1420014519
Souvik Ghosh,Aluu097,22,3604,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
const ll mod = 1e9 + 7;
class Solution {
    void add(ll &a, ll b){
        a += b;
        if(a >= mod)a %= mod;
    }
public:
    int numberOfWays(int n, int x, int y) {
        vt<vt<ll>>dp(n + 5, vt<ll>(x + 5, 0));
        dp[0][0] = 1;
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= min(i, x); j++){
                add(dp[i + 1][j], dp[i][j] * j);
                add(dp[i + 1][j + 1], dp[i][j] * (x - j));
            }
        }
        
        ll pwy = 1, ans = 0;
        for(int i = 1; i <= x; i++){
            pwy = (pwy * y) % mod;
            ll ways = dp[n][i];
            ll sm = pwy;
            add(ans, ways * sm);
        }
        
        return(ans);
    }
};",1420027464
Souvik Ghosh,Aluu097,22,3605,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vt<int>res;
        for(auto i: nums){
            int ok = -1;
            for(int j = 1; j <= i; j++){
                if((j | (j + 1)) == i){
                    ok = j; break;
                }
            }
            res.pb(ok);
        }
        return(res);
    }
};",1419994126
Souvik Ghosh,Aluu097,22,3611,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vt<int>res;
        for(auto i: nums){
            if(i == 2)res.pb(-1);
            else{
                int ans = 0;
                for(int j = 0; j < 30; j++){
                    if((i >> j) & 1)ans = (1 << j);
                    else break;
                }
                res.pb(i - ans);
                
            }
        }
        return(res);
    }
};",1420001257
VIMALMOUNISH,vimal-mounish,23,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());        
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        
        for (int i = 0; i < n; ++i) {
            vector<int> tempDp = dp;
            for (int j = 0; j < m; ++j) {
                if (source[i] == pattern[j] && dp[j] != INT_MAX) {
                    int cost = dp[j];
                    if (targetSet.count(i)) {
                        if (cost < INT_MAX - 1) {
                            cost += 1;  
                        } else {
                            cost = INT_MAX; 
                        }
                    }
                    if (tempDp[j + 1] > cost) {
                        tempDp[j + 1] = cost;
                    }
                }
            }
            dp.swap(tempDp);
        }
        
        int minRequired = dp[m];
        int totalTargets = targetIndices.size();
        if (minRequired == INT_MAX) {
            return 0;
        }
        return totalTargets - minRequired;
    }
};
",1420024405
VIMALMOUNISH,vimal-mounish,23,3604,cpp,"class Solution {
public:
    #define ll long long
    static const int M = 1e9 + 7;

    void calcS(int n, vector<vector<ll>>& s) {
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            s[i][0] = 0;
            for (int j = 1; j <= i; ++j) {
                s[i][j] = (j * s[i - 1][j] % M + s[i - 1][j - 1]) % M;
            }
        }
    }

    void calcF(int n, vector<ll>& f) {
        f[0] = 1;
        for (int i = 1; i <= n; ++i) {
            f[i] = f[i - 1] * i % M;
        }
    }

    ll comb(int n, int k, const vector<ll>& f, const vector<ll>& invF) {
        if (k < 0 || k > n) return 0;
        return f[n] * invF[k] % M * invF[n - k] % M;
    }

    ll powMod(ll a, ll b) {
        ll res = 1;
        a %= M;
        while (b > 0) {
            if (b & 1) res = res * a % M;
            a = a * a % M;
            b >>= 1;
        }
        return res;
    }

    int numberOfWays(int n, int x, int y) {
        int mx = max(n, x);

        vector<vector<ll>> s(n + 1, vector<ll>(n + 1, 0));
        calcS(n, s);

        vector<ll> f(mx + 1, 1);
        calcF(mx, f);

        vector<ll> invF(mx + 1, 1);
        invF[mx] = powMod(f[mx], M - 2);
        for (int i = mx - 1; i >= 0; --i) {
            invF[i] = invF[i + 1] * (i + 1) % M;
        }

        ll total = 0;

        for (int k = 1; k <= min(n, x); ++k) {
            ll stageComb = comb(x, k, f, invF);
            ll perfWays = f[k] * s[n][k] % M;
            ll scoreWays = powMod(y, k);
            ll ways = stageComb * perfWays % M * scoreWays % M;

            total = (total + ways) % M;
        }

        return (int)total;
    }
};
",1420036523
VIMALMOUNISH,vimal-mounish,23,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  
        
        for (int i = 0; i < n; ++i) {
            for (int a = 0; a <= nums[i]; ++a) {  
                if ((a | (a + 1)) == nums[i]) {  
                    ans[i] = a;  
                    break;                       
                }
            }
        }
        
        return ans;
    }
};
",1419993570
VIMALMOUNISH,vimal-mounish,23,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            int min_x = -1;
            for (int k = 0; k < 31; ++k) {
                if (p & (1 << k)) {
                    int x = p - (1 << k);
                    if (x >= 0 && ((x | (x + 1)) == p)) {
                        if (min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};
",1420006098
Dheeraj,user0530o,24,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int k = targetIndices.size();
        std::unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());

      
        std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, n + 1));

       
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i)
            dp[i][0] = 0;

      
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
              
                dp[i][j] = dp[i - 1][j];
                if (j > 0 && source[i - 1] == pattern[j - 1]) {
                   
                    int cost = targetSet.count(i - 1) ? 1 : 0;
                    dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + cost);
                }
            }
        }

        int minKeep = dp[n][m];
        int maxRemovals = k - minKeep;
        return maxRemovals;
    }
};

",1420020395
Dheeraj,user0530o,24,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int mod = 1e9 + 7;
        int maxN = max(n, x);
        vector<long long> factorial(maxN + 1, 1), inv_factorial(maxN + 1, 1);
        for (int i = 1; i <= maxN; ++i) {
            factorial[i] = factorial[i - 1] * i % mod;
        }
        inv_factorial[maxN] = modInverse(factorial[maxN], mod);
        for (int i = maxN - 1; i >= 0; --i) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % mod;
        }

        int maxK = min(n, x);
        vector<vector<long long>> stirling(n + 1, vector<long long>(maxK + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            stirling[i][0] = 0;
            for (int j = 1; j <= maxK; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] % mod + stirling[i - 1][j - 1]) % mod;
            }
        }

        long long totalWays = 0;
        for (int k = 1; k <= maxK; ++k) {
            long long comb_x_k = factorial[x] * inv_factorial[k] % mod * inv_factorial[x - k] % mod;
            long long k_fact = factorial[k];
            long long s = stirling[n][k];
            long long y_pow_k = modPow(y, k, mod);
            long long term = comb_x_k * k_fact % mod * s % mod * y_pow_k % mod;
            totalWays = (totalWays + term) % mod;
        }
        return totalWays;
    }

private:
    long long modPow(long long base, long long exp, int mod) {
        long long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1)
                result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }

    long long modInverse(long long a, int mod) {
        return modPow(a, mod - 2, mod);
    }
};
",1420036628
Dheeraj,user0530o,24,3605,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int ans_i = -1;
            for (int k = 0; k < 31; ++k) {
                if (num & (1 << k)) {
                    int ans_candidate = num - (1 << k);
                    if (ans_candidate >= 0) {
                        if ((ans_candidate | (ans_candidate + 1)) == num) {
                            if (ans_i == -1 || ans_candidate < ans_i) {
                                ans_i = ans_candidate;
                            }
                        }
                    }
                }
            }
            ans[i] = ans_i;
        }
        return ans;
    }
};
",1419998768
Dheeraj,user0530o,24,3611,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int ans_i = -1;
            for (int k = 0; k < 31; ++k) {
                if (num & (1 << k)) {
                    int ans_candidate = num - (1 << k);
                    if (ans_candidate >= 0) {
                        if ((ans_candidate | (ans_candidate + 1)) == num) {
                            if (ans_i == -1 || ans_candidate < ans_i) {
                                ans_i = ans_candidate;
                            }
                        }
                    }
                }
            }
            ans[i] = ans_i;
        }
        return ans;
    }
};
",1420001137
ArpitVijay7,ArpitVijay7,27,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        unordered_map<char, vector<int>> ctp;
        for(int i=0; i<n; i++) {
            ctp[source[i]].pb(i);
        }
        unordered_set<int> target_set(targetIndices.begin(), targetIndices.end());


        vector<int> dp(m+1, INT_MAX);
        dp[0] = 0;


        for(int i=0; i<n; i++) {
            char current_char = source[i];

            for(int j = m; j >=1; j--){
                if(current_char == pattern[j-1]){
                    if(dp[j-1] != INT_MAX){
                        int cost = target_set.find(i) != target_set.end() ? 1 : 0;
                        dp[j] = min(dp[j], dp[j-1] + cost);
                    }
                }
            }
        }


        if(dp[m] == INT_MAX){
            return 0; 
        }

       
        return targetIndices.size() - dp[m];
    }
};",1420019514
ArpitVijay7,ArpitVijay7,27,3604,cpp,"#include <bits/stdc++.h>
using namespace std;


#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;


class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        
        vector<vector<ll>> S(n+1, vector<ll>(n+1, 0));
        S[0][0] = 1; 

        for(int i=1;i<=n;i++){
            for(int k=1;k<=i;k++){
                S[i][k] = ( (k * S[i-1][k]) % mod + S[i-1][k-1] ) % mod;
            }
        }

        
        vector<vector<ll>> C(x+1, vector<ll>(x+1, 0));
        C[0][0] = 1; 

        for(int i=1;i<=x;i++){
            C[i][0] = 1; 
            for(int k=1;k<=i;k++){
                C[i][k] = (C[i-1][k-1] + C[i-1][k]) % mod;
            }
        }

        int max_k = min(x, n);
        vector<ll> fact(max_k+1, 1);
        for(int k=1; k<=max_k; k++){
            fact[k] = (fact[k-1] * k) % mod;
        }

        vector<ll> y_powers(max_k+1, 1);
        for(int k=1; k<=max_k; k++){
            y_powers[k] = (y_powers[k-1] * y) % mod;
        }

        ll result = 0;
        for(int k=1; k<=max_k; k++){
            ll temp = C[x][k];        
            temp = (temp * fact[k]) % mod;    
            temp = (temp * S[n][k]) % mod;    
            temp = (temp * y_powers[k]) % mod; 
            result = (result + temp) % mod;   
        }
        return result;
    }
};
",1420030847
ArpitVijay7,ArpitVijay7,27,3605,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;


int find_min_a(int num){

    if(num ==1){
        return 0;
    }
    int min_a = INT_MAX;
    for(int bit=0; bit < 32; bit++){
        if(num & (1 << bit)){
            int a = num & (~(1 << bit));
            if((a | (a +1)) == num){
                min_a = min(min_a, a);
            }
        }
    }
    if(min_a != INT_MAX){
        return min_a;
    }
    return -1;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num: nums){
            if(num <1){
                ans.pb(-1);
                continue;
            }
            if(num ==1){
                ans.pb(0);
                continue;
            }
            int a = find_min_a(num);
            if(num ==2){
                ans.pb(-1);
                continue;
            }
            if(a != INT_MAX && a < num){
                ans.pb(a);
            }
            else{
                ans.pb(-1);
            }
        }
        return ans;
    }
};",1419998281
ArpitVijay7,ArpitVijay7,27,3611,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;


int find_min_a(int num){

    int min_a = INT_MAX;
    

    for(int bit=0; bit < 32; bit++){
        if(num & (1 << bit)){

            int a = num & (~(1 << bit));

            if( (a | (a +1)) == num ){
                min_a = min(min_a, a);
            }
        }
    }
    

    if(min_a != INT_MAX){
        return min_a;
    }
    return -1;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num: nums){

            if(num ==1){
                ans.pb(0);
                continue;
            }

            int a = find_min_a(num);
            if(a != -1 && a < num){
                ans.pb(a);
            }
            else{
                ans.pb(-1);
            }
        }
        return ans;
    }
};",1420002397
Soumyajit Chakraborty,soumyajitchakraborty23,29,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n = len(s)
        m = len(p)
        d = [float('inf')] * (m + 1)
        d[0] = 0
        a = [False] * n
        for x in t:
            a[x] = True
        for i in range(n):
            c = s[i]
            for j in range(m, 0, -1):
                if p[j - 1] == c:
                    if a[i]:
                        d[j] = min(d[j], d[j - 1] + 1)
                    else:
                        d[j] = min(d[j], d[j - 1])
        return 0 if d[m] == float('inf') else len(t) - d[m]",1420028997
Soumyajit Chakraborty,soumyajitchakraborty23,29,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        modulo = 10**9 + 7
        dp1 = [[0]*(x+2) for _ in range(n+2)]
        dp1[0][0] = 1
        for i in range(1, n+1):
            for j in range(1, min(i, x)+1):
                dp1[i][j] = (j * dp1[i-1][j] + dp1[i-1][j-1]) % modulo
        dp2 = [[0]*(x+2) for _ in range(x+2)]
        dp2[0][0] = 1
        for i in range(1, x+1):
            dp2[i][0] = 1
            for j in range(1, i+1):
                dp2[i][j] = (dp2[i-1][j-1] + dp2[i-1][j]) % modulo
        dp3 = [1]*(x+2)
        for i in range(1, x+1):
            dp3[i] = dp3[i-1] * i % modulo
        dp4 = [1]*(x+2)
        for i in range(1, x+1):
            dp4[i] = dp4[i-1] * y % modulo
        T = 0
        K = min(n, x)
        for k in range(1, K+1):
            temo = dp2[x][k]
            temo = temo * dp1[n][k] % modulo
            temo = temo * dp3[k] % modulo
            temo = temo * dp4[k] % modulo
            T = (T + temo) % modulo
        return T",1420039845
Soumyajit Chakraborty,soumyajitchakraborty23,29,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for B in nums:
            A = []
            if B == 0:
                res.append(-1)
                continue
            n = B
            c = 0
            while (n & 1) == 1:
                c += 1
                n >>= 1
                if c > B.bit_length():
                    break  
            if c == 0:
                res.append(-1)
                continue
            for i in range(c):
                m = ~(1 << i)
                a = B & m
                if (a | (a + 1)) == B:
                    A.append(a)
            if A:
                res.append(min(A))
            else:
                res.append(-1)
        return res",1420002541
Soumyajit Chakraborty,soumyajitchakraborty23,29,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for B in nums:
            A = []
            if B == 0:
                res.append(-1)
                continue
            n = B
            c = 0
            while (n & 1) == 1:
                c += 1
                n >>= 1
                if c > B.bit_length():
                    break  
            if c == 0:
                res.append(-1)
                continue
            for i in range(c):
                m = ~(1 << i)
                a = B & m
                if (a | (a + 1)) == B:
                    A.append(a)
            if A:
                res.append(min(A))
            else:
                res.append(-1)
        return res",1420003169
YouTube Aryan,youtube_aryanc403,30,3487,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/

#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const lli m=sz(pattern),n=sz(source);
        const lli INF = 1e12;
        vi dp(m+1,-INF);
        dp[0]=0;
        set<lli> ti;
        for(const auto &x:targetIndices)
            ti.insert(x);
        for(lli ci=0;ci<n;ci++){
            const auto cx = source[ci];
            vi ndp=dp;
            for(lli j=0;j<m;j++)
                if(cx==pattern[j])
                    ndp[j+1]=max(ndp[j+1],dp[j]);
            if(ti.count(ci)){
                for(lli j=0;j<=m;j++)
                    ndp[j]=max(ndp[j],1+dp[j]);
            }
            dp=ndp;
        }

        return dp[m];
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    // cout<<""Ans:""<<s.runSoln(20)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(100)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(1000)<<"":Fn""<<endl;
    return 0;
}
#endif
",1420031832
YouTube Aryan,youtube_aryanc403,30,3604,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/
#include <bits/stdc++.h>

#include <cassert>
#include <numeric>
#include <type_traits>

#ifdef _MSC_VER
#include <intrin.h>
#endif


#include <utility>

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

constexpr long long safe_mod(long long x, long long m) {
    x %= m;
    if (x < 0) x += m;
    return x;
}

struct barrett {
    unsigned int _m;
    unsigned long long im;

    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

    unsigned int umod() const { return _m; }

    unsigned int mul(unsigned int a, unsigned int b) const {

        unsigned long long z = a;
        z *= b;
#ifdef _MSC_VER
        unsigned long long x;
        _umul128(z, im, &x);
#else
        unsigned long long x =
            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
        unsigned long long y = x * _m;
        return (unsigned int)(z - y + (z < y ? _m : 0));
    }
};

constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
    if (m == 1) return 0;
    unsigned int _m = (unsigned int)(m);
    unsigned long long r = 1;
    unsigned long long y = safe_mod(x, m);
    while (n) {
        if (n & 1) r = (r * y) % _m;
        y = (y * y) % _m;
        n >>= 1;
    }
    return r;
}

constexpr bool is_prime_constexpr(int n) {
    if (n <= 1) return false;
    if (n == 2 || n == 7 || n == 61) return true;
    if (n % 2 == 0) return false;
    long long d = n - 1;
    while (d % 2 == 0) d /= 2;
    constexpr long long bases[3] = {2, 7, 61};
    for (long long a : bases) {
        long long t = d;
        long long y = pow_mod_constexpr(a, t, n);
        while (t != n - 1 && y != 1 && y != n - 1) {
            y = y * y % n;
            t <<= 1;
        }
        if (y != n - 1 && t % 2 == 0) {
            return false;
        }
    }
    return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
    a = safe_mod(a, b);
    if (a == 0) return {b, 0};

    long long s = b, t = a;
    long long m0 = 0, m1 = 1;

    while (t) {
        long long u = s / t;
        s -= t * u;
        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b


        auto tmp = s;
        s = t;
        t = tmp;
        tmp = m0;
        m0 = m1;
        m1 = tmp;
    }
    if (m0 < 0) m0 += b / s;
    return {s, m0};
}

constexpr int primitive_root_constexpr(int m) {
    if (m == 2) return 1;
    if (m == 167772161) return 3;
    if (m == 469762049) return 3;
    if (m == 754974721) return 11;
    if (m == 998244353) return 3;
    int divs[20] = {};
    divs[0] = 2;
    int cnt = 1;
    int x = (m - 1) / 2;
    while (x % 2 == 0) x /= 2;
    for (int i = 3; (long long)(i)*i <= x; i += 2) {
        if (x % i == 0) {
            divs[cnt++] = i;
            while (x % i == 0) {
                x /= i;
            }
        }
    }
    if (x > 1) {
        divs[cnt++] = x;
    }
    for (int g = 2;; g++) {
        bool ok = true;
        for (int i = 0; i < cnt; i++) {
            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

unsigned long long floor_sum_unsigned(unsigned long long n,
                                      unsigned long long m,
                                      unsigned long long a,
                                      unsigned long long b) {
    unsigned long long ans = 0;
    while (true) {
        if (a >= m) {
            ans += n * (n - 1) / 2 * (a / m);
            a %= m;
        }
        if (b >= m) {
            ans += n * (b / m);
            b %= m;
        }

        unsigned long long y_max = a * n + b;
        if (y_max < m) break;
        n = (unsigned long long)(y_max / m);
        b = (unsigned long long)(y_max % m);
        std::swap(m, a);
    }
    return ans;
}

}  // namespace internal

}  // namespace atcoder


#include <cassert>
#include <numeric>
#include <type_traits>

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value ||
                                  std::is_same<T, __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int128 =
    typename std::conditional<std::is_same<T, __uint128_t>::value ||
                                  std::is_same<T, unsigned __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using make_unsigned_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value,
                              __uint128_t,
                              unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
                                                  is_signed_int128<T>::value ||
                                                  is_unsigned_int128<T>::value,
                                              std::true_type,
                                              std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
                                                 std::is_signed<T>::value) ||
                                                    is_signed_int128<T>::value,
                                                std::true_type,
                                                std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<(is_integral<T>::value &&
                               std::is_unsigned<T>::value) ||
                                  is_unsigned_int128<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
    is_signed_int128<T>::value,
    make_unsigned_int128<T>,
    typename std::conditional<std::is_signed<T>::value,
                              std::make_unsigned<T>,
                              std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<is_integral<T>::value &&
                                  std::is_unsigned<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
                                              std::make_unsigned<T>,
                                              std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
    using mint = static_modint;

  public:
    static constexpr int mod() { return m; }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    static_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    static_modint(T v) {
        long long x = (long long)(v % (long long)(umod()));
        if (x < 0) x += umod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    static_modint(T v) {
        _v = (unsigned int)(v % umod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v -= rhs._v;
        if (_v >= umod()) _v += umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        unsigned long long z = _v;
        z *= rhs._v;
        _v = (unsigned int)(z % umod());
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        if (prime) {
            assert(_v);
            return pow(umod() - 2);
        } else {
            auto eg = internal::inv_gcd(_v, m);
            assert(eg.first == 1);
            return eg.second;
        }
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
    static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
    using mint = dynamic_modint;

  public:
    static int mod() { return (int)(bt.umod()); }
    static void set_mod(int m) {
        assert(1 <= m);
        bt = internal::barrett(m);
    }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    dynamic_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        long long x = (long long)(v % (long long)(mod()));
        if (x < 0) x += mod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        _v = (unsigned int)(v % mod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v += mod() - rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        _v = bt.mul(_v, rhs._v);
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        auto eg = internal::inv_gcd(_v, mod());
        assert(eg.first == 1);
        return eg.second;
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static internal::barrett bt;
    static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder

//using mint = atcoder::modint998244353;
using mint = atcoder::modint1000000007;
using vm = std::vector<mint>;
std::ostream& operator << (std::ostream& out, const mint& rhs) {
        return out<<rhs.val();
    }
#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

vector<vm> dp;
const lli MX = 1001;

// Ref - https://www.codechef.com/viewsolution/41909444 Line 827 - 850.
const int maxnCr=2e3+5;
array<mint,maxnCr+1> fac,inv;

mint nCr(lli n,lli r)
{
    if(n<0||r<0||r>n)
        return 0;
    return fac[n]*inv[r]*inv[n-r];
}

void prencr(lli n)
{
    fac[0]=1;
    for(int i=1;i<=n;++i)
        fac[i]=i*fac[i-1];
    inv[n]=fac[n].pow(mint(-2).val());
    for(int i=n;i>0;--i)
        inv[i-1]=i*inv[i];
    assert(inv[0]==mint(1));
}


void pre(){
    if(nCr(10,5)==0)
        prencr(maxnCr);
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        pre();
        mint ans = 0;
        for(lli t=1;t<=x;t++){
            mint cur = 0;

            for(lli i=0;i<=t;i++)
                cur+=mint(t-i).pow(n)*mint(-1).pow(i)*nCr(t,i);

            cur*=nCr(x,t);
            cur*=mint(y).pow(t);
            ans+=cur;
        }
        return ans.val();
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    cout<<""Ans:""<<s.numberOfWays(1,2,3)<<"":Fn""<<endl;
    cout<<""Ans:""<<s.numberOfWays(5,2,1)<<"":Fn""<<endl;
    cout<<""Ans:""<<s.numberOfWays(3,3,4)<<"":Fn""<<endl;
    return 0;
}
#endif",1420040518
YouTube Aryan,youtube_aryanc403,30,3605,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/

#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

const lli Lg = 30;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> res;
        const lli INF = 1e18;
        for(const auto &c:a){
            lli cur = INF;

            for(lli j=0;j<Lg;j++){
                if((c&(1LL<<j))==0)
                    break;
                cur=min(cur,c^(1LL<<j));
            }

            if(cur>=INF)
                cur=-1;
            res.push_back(cur);
        }
        return res;
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    // cout<<""Ans:""<<s.runSoln(20)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(100)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(1000)<<"":Fn""<<endl;
    return 0;
}
#endif
",1420020070
YouTube Aryan,youtube_aryanc403,30,3611,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/

#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

const lli Lg = 30;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> res;
        const lli INF = 1e18;
        for(const auto &c:a){
            lli cur = INF;

            for(lli j=0;j<Lg;j++){
                if((c&(1LL<<j))==0)
                    break;
                cur=min(cur,c^(1LL<<j));
            }

            if(cur>=INF)
                cur=-1;
            res.push_back(cur);
        }
        return res;
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    // cout<<""Ans:""<<s.runSoln(20)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(100)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(1000)<<"":Fn""<<endl;
    return 0;
}
#endif
",1420019411
Rakesh_Reddy7,Addula_Rakesh7,31,3487,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        m, n = len(pattern), len(source)
        st = set(targetIndices)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        ks = 0
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1]:
                    if i not in st:
                        dp[j] = min(dp[j], dp[j-1])
                    else:
                        dp[j] = min(dp[j], dp[j-1] + 1)
        ans = (source, pattern, targetIndices)
        if dp[m] <= len(targetIndices):
            return len(targetIndices) - dp[m]
            pass
        return 0
",1420032253
Rakesh_Reddy7,Addula_Rakesh7,31,3604,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod = 10**9 + 7
        l = [[0] * (x + 1) for _ in range(n + 1)]
        l[0][0] = 1

        for i in range(1, n + 1):
            for k in range(1, min(x, i) + 1):
                l[i][k] = (k * l[i - 1][k] + l[i - 1][k - 1]) % mod

        ans = 0
        P = 1
        for k in range(1, min(x, n) + 1):
            P = P * (x - k + 1) % mod
            pow2 = self.mod_pow(y, k, mod)
            ans = (ans + P * l[n][k] % mod * pow2 % mod) % mod

        return ans

    def mod_pow(self, base: int, exp: int, mod: int) -> int:
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = result * base % mod
            base = base * base % mod
            exp //= 2
        return result
",1420005977
Rakesh_Reddy7,Addula_Rakesh7,31,3605,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for j in nums:
            ok = False
            for i in range(j):
                if i | (i + 1) == j:
                    res.append(i)
                    ok = True
                    break
            if not ok:
                res.append(-1)
                pass

        return res",1420011932
Rakesh_Reddy7,Addula_Rakesh7,31,3611,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        d = 0
        for i in nums:
            if i == 2:
                res.append(-1)
                continue
                pass

            mini = -1
            powm = i.bit_length() 
            for k in reversed(range(powm)):
                c = 1 << k
                if c > i:
                    continue
                    pass
                a = i - c
                if a >= 0 and (a | (a + 1)) == i:
                    if mini == -1 or a < mini:
                        mini = a
                        d = 1
            res.append(mini)
            temp = (nums)
        return res",1420022568
Kseniia,kseniiastrelbytska,32,3487,cpp,"class Solution {
public:
    typedef long long ll;

    int maxRemovals(string a, string b, vector<int>& d) {
        ll n = a.size(), m = b.size();

        a = ""#"" + a, b = ""#"" + b;
        vector<vector<ll>> dp(n + 1, vector<ll> (m + 1, (ll)(1e9)));

        for(int i = 0; i <= n; i++)
            dp[i][0] = 0;

        vector<ll> c(n + 1);
        for(auto i: d)
            c[i + 1] = 1;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                dp[i][j] = dp[i - 1][j];

                if(a[i] == b[j])
                    dp[i][j] = min(dp[i][j], c[i] + dp[i - 1][j - 1]);
            }
        }

        return (ll)(d.size()) - dp[n][m];
    }
};",1420023271
Kseniia,kseniiastrelbytska,32,3604,cpp,"class Solution {
public:
    typedef long long ll;

    ll const mod = (ll)(1e9 + 7);

    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> dp(n + 1, vector<ll> (x + 1));

        dp[1][1] = x;

        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= x; j++){
                dp[i][j] = ((dp[i - 1][j] * (ll)j) % mod + (dp[i - 1][j - 1] * (x - j + 1)) % mod) % mod;
            }
        }

        ll cur = 1;
        ll ans = 0;

        for(int j = 1; j <= x; j++){
            cur = (cur * y) % mod;

            ans = (ans + (cur * dp[n][j]) % mod) % mod;
        }

        return ans;
    }
};",1420041347
Kseniia,kseniiastrelbytska,32,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i: nums){
            int c = -1;
            for(int j = 0; j <= 1024; j++){
                if((j | (j + 1)) == i){
                    c = j;
                    break;
                }
            }
            ans.push_back(c);
        }

        return ans;
    }
};",1419994580
Kseniia,kseniiastrelbytska,32,3611,cpp,"
class Solution {
public:
typedef long long ll;

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i: nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }

            for(ll j = 0; j <= 32; j++){
                if(((ll)i >> j) % 2 == 0){
                    ans.push_back((ll)i ^ (1ll << (j - 1)));
                    break;
                }
            }
        }

        return ans;
    }
};",1420003559
pereigroxshik,pereigroxshik,33,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& T) {
        int n = s.size();
        vector<int> c(n);
        for (int i : T)
        {
            c[i] = 1;
        }
        int m = t.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,(int)-1e9));
        dp[0][0] = 0;
        for (int i = 1;i<=n;i++)
        {
            dp[i] = dp[i-1];
            char ch = s[i-1];
            for (int j = 0;j<=m;j++)
            {
                if (j < m && t[j] == ch)
                {
                    dp[i][j+1] = max(dp[i][j+1],dp[i-1][j]);
                }
                if (c[i-1]) dp[i][j] = max(dp[i][j],dp[i-1][j]+1);
            }
        }
        return dp[n][m];
    }
};",1420029010
pereigroxshik,pereigroxshik,33,3604,cpp,"#define ll long long int
ll mod = 1e9+7;
ll binpow(ll n,ll k = mod-2,ll M = mod)
{
	bitset<31> o(k);
	ll curr = 1;
	for (ll e = 30;e>-1;e--)
	{
		curr *= curr;
		curr %= M;
		if (o[e])
		{
			curr *= n;
			curr %= M;
		}
	}
	return curr;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> dp(n+1,vector<ll>(x+2));
        dp[0][0] = 1;
        for (ll i = 1;i<=n;i++)
        {
            for (ll j = 0;j<=x;j++)
            {
                dp[i][j] += dp[i-1][j]*j;
                dp[i][j] %= mod;
                dp[i][j+1] += dp[i-1][j]*(x-j);
                dp[i][j+1] %= mod;
            }
        }
        ll answer = 0;
        for (ll j = 1;j<=x;j++)
        {
            answer += dp[n][j]*binpow(y,j);
            answer %= mod;
        }
        return answer;
    }
};",1420041977
pereigroxshik,pereigroxshik,33,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for (int i = 0;i<nums.size();i++)
        {
            for (int j = 0;j<=nums[i];j++)
            {
                if ((j|(j+1)) == nums[i])
                {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419997885
pereigroxshik,pereigroxshik,33,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for (int i = 0;i<nums.size();i++)
        {
            int x = nums[i];
            if (nums[i] == 2) continue;
            for (int j = 0;j<40;j++)
            {
                if (!((1ll << j)&x))
                {
                    ans[i] = x-(1ll << (j-1));
                    break;
                }
            }
        }
        return ans;
    }
};",1420008130
TimeGoGo,TimeGoGo,34,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        target_set = set(targetIndices)
        INF = float('inf')
        dp = [INF] * (m + 1)
        dp[0] = 0 

        for i in range(n):
            for j in range(min(i+1, m)-1, -1, -1):
                if source[i] == pattern[j]:
                    cost = dp[j] + (1 if i in target_set else 0)
                    if dp[j + 1] > cost:
                        dp[j + 1] = cost

        if dp[m] == INF:
            return 0  
        else:
            return len(targetIndices) - dp[m]",1420037586
TimeGoGo,TimeGoGo,34,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7
        MAX = n + x + 10
        fact = [1] * MAX
        inv_fact = [1] * MAX
        for i in range(1, MAX):
            fact[i] = (fact[i - 1] * i) % MOD

        inv_fact[MAX - 1] = pow(fact[MAX - 1], MOD - 2, MOD)
        for i in range(MAX - 2, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

        def comb(n, k):
            if k < 0 or k > n:
                return 0
            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD

        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
            for j in range(1, i + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD

        total = 0
        min_k = min(n, x)
        pow_y = [1] * (min_k + 2)
        for k in range(1, min_k + 1):
            pow_y[k] = pow(y, k, MOD)

        for k in range(1, min_k + 1):
            ways = comb(x, k)
            ways = (ways * S[n][k]) % MOD
            ways = (ways * fact[k]) % MOD
            ways = (ways * pow_y[k]) % MOD
            total = (total + ways) % MOD

        return total",1420042466
TimeGoGo,TimeGoGo,34,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        
        for num in nums:
            found = False
            for i in range(num):
                if (i | (i + 1)) == num:
                    ans.append(i)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans",1419993912
TimeGoGo,TimeGoGo,34,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            min_x = -1
            for k in range(31):
                x = N - (1 << k)
                if x >= 0 and (x | (x + 1)) == N:
                    if min_x == -1 or x < min_x:
                        min_x = x
            ans.append(min_x)
        return ans",1420023637
Farras Faddila,donbasta,38,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int m = source.length();
        int n = pattern.length();
        int dp[m][n], cnt[m];
        memset(dp, -1, sizeof(dp));
        memset(cnt, 0, sizeof(cnt));

        bool target[m];
        memset(target, false, sizeof(target));

        for (auto t : targetIndices) target[t] = true;
        for (int i = 0; i < m; i++) {
            cnt[i] = (i ? cnt[i - 1] : 0) + target[i];
        }
    
        for (int i = 0; i < m; i++) {
            if (i == 0) {
                if (source[0] == pattern[0]) dp[0][0] = 0;
            } else {
                for (int j = 0; j < n; j++) {
                    if (dp[i - 1][j] != -1) {
                        dp[i][j] = max(dp[i][j], dp[i - 1][j] + (target[i]));
                    }
                    if (source[i] == pattern[j]) {
                        if (j >= 1 && dp[i - 1][j - 1] != -1) {
                            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                        } else if (j == 0) {
                            dp[i][j] = max(dp[i][j], cnt[i - 1]);
                        }
                    }
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};",1420046634
Farras Faddila,donbasta,38,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int pw = 1;
        int ans = 0;

        const int MOD = 1e9 + 7;
        int C[1001][1001];
        memset(C, 0, sizeof(C));
        C[0][0] = 1;
        for (int i = 1; i <= 1000; i++) {
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (1ll * C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        auto fpow = [&](int a, int b) -> int {
            int ret = 1;
            while (b) {
                if (b & 1) ret = (1ll * ret * a) % MOD;
                a = (1ll * a * a) % MOD;
                b >>= 1;
            }
            return ret;
        };

        for (int k = 1; k <= x; k++) {
            if (k > n) break;
            int st = C[x][k];
            pw = (1ll * pw * y) % MOD;
            int sc = pw;
            int inex = 0;
            for (int l = 0; l <= k; l++) {
                int A = C[k][l];
                int B = fpow((k - l), n);
                int tmp = (1ll * A * B) % MOD;
                if (l & 1) {
                    inex = (inex - tmp) % MOD;
                } else {
                    inex = (inex + tmp) % MOD;
                }
            }
            int lmao = (1ll * st * sc) % MOD;
            lmao = (1ll * lmao * inex) % MOD;
            ans = (1ll * ans + lmao) % MOD;
        }
        ans %= MOD;
        if (ans < 0) ans += MOD;
        return ans;
    }
};",1420025633
Farras Faddila,donbasta,38,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                ans[i] = -1;
                continue;
            } 
            int pos = 0;
            for (int j = 0; j < 30; j++) {
                if (!((nums[i] >> j) & 1)) {
                    pos = j;
                    break;
                }
            }
            ans[i] = (nums[i] - (1 << (pos - 1)));
        }
        return ans;
    }
};",1419999245
Farras Faddila,donbasta,38,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                ans[i] = -1;
                continue;
            } 
            int pos = 0;
            for (int j = 0; j < 30; j++) {
                if (!((nums[i] >> j) & 1)) {
                    pos = j;
                    break;
                }
            }
            ans[i] = (nums[i] - (1 << (pos - 1)));
        }
        return ans;
    }
};",1419998849
penguinzzz,penguinzzz,39,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& a) {
        int n = s.size();
        int m = p.size();
        set<int> idx(a.begin(), a.end());
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        auto rec = [&](auto&& rec, int i, int j) -> int {
            if (j == m) return 0;
            if (i == n) return 1e6;
            if(dp[i][j]!=-1) return dp[i][j];
            int ans = INT_MAX;
            if (s[i] == p[j]) {
                ans = min(ans, rec(rec, i + 1, j + 1) + (int)(idx.find(i) != idx.end()));
            }
            ans = min(ans, rec(rec, i + 1, j));
            return dp[i][j]=ans;
        };
        return a.size() - rec(rec, 0, 0);
    }
};
",1420023031
penguinzzz,penguinzzz,39,3604,cpp,"const int MOD = 1000000007;
vector<long long> fact;


long long power(int a, int b, int m = MOD) {
    if (a == 0) return 0LL;
    if (b == 0) return 1LL;
    long long result = 1;
    long long base = a % m;
    while (b > 0) {
        if (b % 2 == 1) {
            result = (result * base) % m;
        }
        base = (base * base) % m;
        b /= 2;
    }
    return result;
}


void factorial(int n, int m = MOD) {
    fact.assign(n + 1, 0);
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (i * 1LL * fact[i - 1]) % m;
    }
}


long long inverse(int x, int m = MOD) {
    return power(x, m - 2, m);
}


long long nCr(long long n, long long r, int m = MOD) {
    if (r > n) return 0;
    long long x = (fact[r] * fact[n - r]) % m;
    long long y = fact[n];
    return (y * inverse(x, m)) % m;
}

long long count(int n, int x) {
    long long result = 0;
    
    for (int k = 0; k <= x; ++k) {
        long long sign = (k % 2 == 0) ? 1 : -1;
        long long term = (sign * nCr(x, k) % MOD) * power(x - k, n, MOD) % MOD;
        result = (result + term + MOD) % MOD;
    }
    
    return result;
}

class Solution {
public:

    int numberOfWays(int n, int x, int y) {
        factorial(1001);
        long long ans = 0;
        
        for (int i = 1; i <= x; i++) {
            // There are i bands
            long long term = (power(y, i, MOD) * count(n, i)) % MOD;
            term = (term * nCr(x, i)) % MOD;
            ans = (ans + term) % MOD;
        }
        
        return (int)ans;
    }
};
",1420038488
penguinzzz,penguinzzz,39,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            int x=nums[i];
            if(nums[i]==2){
                ans[i]=-1;
            }else{
                int curr=0;
                for(int j=0;j<31;j++){
                    if(x>>j&1) curr|=(1<<j);
                    else break;
                }
                ans[i]=(x^(curr))|(curr/2);
            }
        }
        return ans;
    }
};",1420006569
penguinzzz,penguinzzz,39,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            int x=nums[i];
            if(nums[i]==2){
                ans[i]=-1;
            }else{
                int curr=0;
                for(int j=0;j<31;j++){
                    if(x>>j&1) curr|=(1<<j);
                    else break;
                }
                ans[i]=(x^(curr))|(curr/2);
            }
        }
        return ans;
    }
};",1420006336
Turkhuu Batbayar,Turkhuu,43,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n = s.size(), m = t.size();
        vector<bool> f(n);
        for (auto i : a) {
            f[i] = 1;
        }
        vector dp(n + 1, vector<int>(m + 1, -1e9));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            dp[i + 1] = dp[i];
            if (f[i]) {
    for (int j = 0; j <= m; j++) {
        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
    }}
            for (int j = 0; j < m; j++) {
                if (s[i] == t[j]) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
            }
            
        }
        return dp[n][m];
    }
};",1420006935
Turkhuu Batbayar,Turkhuu,43,3604,cpp,"template<class T> T power(T a, long long b) {
    T s = 1; for (; b; a *= a, b >>= 1) if (b & 1) s *= a; return s;
}
template<int mod> struct modular {
    using mint = modular;
    int v;
    modular() : v(0) {}
    modular(long long x) {if ((v = x % mod) < 0) v += mod;}
    mint operator-() const {return -v;}
    mint inv() const {return power(*this, mod - 2);}
    mint &operator+=(const mint &a) {if ((v += a.v) >= mod) v -= mod; return *this;}
    mint &operator-=(const mint &a) {if ((v -= a.v) < 0) v += mod; return *this;}
    mint &operator*=(const mint &a) {v = (int)((long long)v * a.v % mod); return *this;}
    mint &operator/=(const mint &a) {return *this *= a.inv();}
    friend bool operator==(const mint &a, const mint &b){return a.v == b.v;}
    friend bool operator!=(const mint &a, const mint &b){return a.v != b.v;}
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend istream &operator>>(istream &is, mint &a) {return is >> a.v;}
    friend ostream &operator<<(ostream &os, const mint &a) {return os << a.v;}
};
const int mod = 1000000007;
using mint = modular<mod>;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector C(1001, vector<mint>(1001));
        for (int i = 0; i <= 1000; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
            }
        }
        vector dp(n + 1, vector<mint>(x + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= x; j++) {
                dp[i][j] += dp[i - 1][j] * j;
                if (j < x) {
                    dp[i][j + 1] += dp[i - 1][j] * (x - j);
                }
            }
        }
        mint ans = 0;
        for (int i = 1; i <= x; i++) {
            ans += dp[n][i] * power(mint(y), i);
        }
        return ans.v;
    }
};",1420039813
Turkhuu Batbayar,Turkhuu,43,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for (auto x : a) {
            if (x == 2) {
                ans.push_back(-1);
            } else {
                int i = 0;
                while ((((long long)x) >> (i + 1) & 1) == 1) {
                    i++;
                }
                ans.push_back(x - (1 << i));
            }
        }
        return ans;
    }
};",1419997353
Turkhuu Batbayar,Turkhuu,43,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for (auto x : a) {
            if (x == 2) {
                ans.push_back(-1);
            } else {
                int i = 0;
                while ((((long long)x) >> (i + 1) & 1) == 1) {
                    i++;
                }
                ans.push_back(x - (1 << i));
            }
        }
        return ans;
    }
};",1419997110
cuy21,cuy21,44,3487,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n=s.size(),m=p.size(),tt=t.size();
        vector<bool> isT(n,false);
        FORE(i,t)isT[i]=true;
        const int inf=1e9;
        vector<int> dp(m+1,inf);
        dp[0]=0;
        FOR(i,0,n){
            for(int j=min(m,i+1);j>=1;--j){
                if(s[i]==p[j-1]){
                    dp[j]=min(dp[j],dp[j-1]+(isT[i]?1:0));
                }
            }
        }
        if(dp[m]==inf)return 0;
        int k_max=tt-dp[m];
        return max(k_max,0);
    }
};",1420039833
cuy21,cuy21,44,3604,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int M = 1000000007;
        vector<vector<long>> c(x+1,vector<long>(x+1,0));
        c[0][0]=1;
        FOR(i,1,x+1){
            c[i][0]=1;
            FOR(j,1,i+1)c[i][j]=(c[i-1][j-1]+c[i-1][j])%M;
        }
        int mk=min(x,n);
        vector<vector<long>> s(n+1,vector<long>(mk+1,0));
        s[0][0]=1;
        FOR(i,1,n+1){
            FOR(j,1,min(i,mk)+1)s[i][j]=(s[i-1][j-1]+((long)j*s[i-1][j])%M)%M;
        }
        vector<long> f(mk+1,1);
        FOR(i,1,mk+1)f[i]=(f[i-1]*i)%M;
        vector<long> py(mk+1,1);
        FOR(i,1,mk+1)py[i]=(py[i-1]*y)%M;
        vector<int> l={n,x,y};
        long tw=0;
        FOR(k,1,mk+1){
            long t=(c[x][k]*s[n][k])%M;
            t=(t*f[k])%M;
            t=(t*py[k])%M;
            tw=(tw+t)%M;
        }
        return (int)tw;
    }
};",1420006753
cuy21,cuy21,44,3605,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
class Solution {
public:
    int solve(long p){
        int c=0;
        while((p&1)==1){c++;p>>=1;}
        return c;
    }
    
    vector<int> minBitwiseArray(vector<int>& n) {
        vi a;
        FORE(p,n){
            int c=solve(p);
            if(c==0)a.PB(-1);
            else{
                long x=(long)p-(1L<<(c-1));
                if((x|(x+1))==p)a.PB((int)x);
                else a.PB(-1);
            }
        }
        return a;
    }
};",1419996809
cuy21,cuy21,44,3611,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss
class Solution {
public:
    int solve(long p){
        int c=0;
        while((p&1)==1){c++;p>>=1;}
        return c;
    }
    
    vector<int> minBitwiseArray(vector<int>& n) {
        vi a;
        FORE(p,n){
            int c=solve(p);
            if(c==0)a.PB(-1);
            else{
                long x=(long)p-(1L<<(c-1));
                if((x|(x+1))==p)a.PB((int)x);
                else a.PB(-1);
            }
        }
        return a;
    }
};",1419996429
AADITYA BHARGAV,beunique_18,45,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        inTarget = [False] * n
        for idx in targetIndices:
            inTarget[idx] = True

        positions_in_S = [[] for _ in range(len(pattern))]
        char_positions = {}
        for idx, ch in enumerate(source):
            if ch not in char_positions:
                char_positions[ch] = []
            char_positions[ch].append(idx)

        for idx, ch in enumerate(pattern):
            if ch not in char_positions:
                return 0
            positions_in_S[idx] = char_positions[ch]

        dp_prev = {}
        for pos in positions_in_S[0]:
            dp_prev[pos] = int(inTarget[pos])

        for i in range(1, m):
            positions = positions_in_S[i]
            prev_positions = sorted(dp_prev.keys())
            dp_curr = {}
            min_dp_prev = float('inf')
            idx_prev = 0
            prev_positions_sorted = sorted(prev_positions)
            positions_sorted = sorted(positions)
            idx_prev = 0
            min_dp = [float('inf')] * len(positions_sorted)
            idx = 0
            min_dp_prev = float('inf')
            for pos in positions_sorted:
                while idx_prev < len(prev_positions_sorted) and prev_positions_sorted[idx_prev] < pos:
                    min_dp_prev = min(min_dp_prev, dp_prev[prev_positions_sorted[idx_prev]])
                    idx_prev += 1
                if min_dp_prev != float('inf'):
                    dp_curr[pos] = min_dp_prev + int(inTarget[pos])
            dp_prev = dp_curr
            if not dp_prev:
                return 0  

        if not dp_prev:
            return 0
        minimal_count = min(dp_prev.values())
        return len(targetIndices) - minimal_count
",1420025111
AADITYA BHARGAV,beunique_18,45,3604,python3,"from typing import List

MOD = 10**9 + 7
MAXN = 1005

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        factorial = [1] * (MAXN)
        inv_factorial = [1] * (MAXN)
        for i in range(1, MAXN):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_factorial[MAXN - 1] = pow(factorial[MAXN - 1], MOD - 2, MOD)
        for i in range(MAXN - 2, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

        def comb(n, k):
            if k < 0 or k > n:
                return 0
            return factorial[n] * inv_factorial[k] % MOD * inv_factorial[n - k] % MOD

        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
            for j in range(1, i + 1):
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD

        total = 0
        min_k = min(n, x)
        y_powers = [1] * (min_k + 2)
        for i in range(1, min_k + 2):
            y_powers[i - 1] = pow(y, i - 1, MOD)

        for k in range(1, min_k + 1):
            comb_xk = comb(x, k)
            perm_k = factorial[k]
            stirling = S[n][k]
            yk = y_powers[k]
            term = comb_xk * perm_k % MOD * stirling % MOD * yk % MOD
            total = (total + term) % MOD
        return total
",1420031819
AADITYA BHARGAV,beunique_18,45,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = False
            for i in range(num + 1):
                if i | (i + 1) == num:
                    ans.append(i)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans
",1419994056
AADITYA BHARGAV,beunique_18,45,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans_list = []
        for p in nums:
            ans = -1
            for r in range(32):  
                x = p - (1 << r)
                if x >= 0:
                    if (x | (x + 1)) == p:
                        if ans == -1 or x < ans:
                            ans = x
            ans_list.append(ans)
        return ans_list
",1420011460
nikatamliani1,nikatamliani1,46,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n = (int)s.size(), m = (int)a.size(), k = (int)t.size();
        vector<int> vis(n + 1);
        for (int i : a) {
            vis[i + 1] = 1;
        }
        s = ""#"" + s;
        t = ""#"" + t + ""#"";
        vector<vector<int>> dp(n + 1, vector<int>(m + 2, -(int)1e9));
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int p = 0; p <= m; ++p) {
                int v = dp[i - 1][p];
                if (v < 0) {
                    continue;
                }
                if (vis[i]) {
                    dp[i][p + 1] = max(dp[i][p + 1], v);
                }

                if (s[i] == t[v + 1]) {
                    dp[i][p] = max(dp[i][p], dp[i - 1][p] + 1);
                } else {
                    dp[i][p] = max(dp[i][p], dp[i - 1][p]);
                }
            }
            // cout << i << "": "";
            // for (int p = 0; p <= m; ++p) {
            //     cout << dp[i][p] << ' ';
            // }
            // cout << '\n';
        }

        int ans = 0;
        for (int i = 0; i <= m; ++i) {
            if (dp[n][i] == k) {
                ans = max(ans, i);
            }
        }
        return ans;
    }
};",1420013599
nikatamliani1,nikatamliani1,46,3604,cpp,"class Solution {
public:
    #define ll long long

    ll bpow(ll x, ll y, ll MOD) {
        ll ans = 1;
        while (y > 0) {
            if (y & 1) {
                ans = ans * x % MOD;
            }
            x = x * x % MOD;
            y >>= 1;
        }
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        const ll N = 1005, MOD = 1e9 + 7;
        ll c[N][N];

        c[0][0] = 1;
        for (int i = 1; i < N; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

        ll dp[N][N];
        dp[0][0] = 1;
        for (int n = 1; n < N; ++n) {
            for (int x = 1; x < N; ++x) {
                dp[n][x] = 1LL * (dp[n - 1][x - 1] + dp[n - 1][x]) * x % MOD;
            }

        }

        ll total = 0;
        for (int i = 1; i <= min(n, x); ++i) {
            ll a = c[x][i];
            ll b = dp[n][i];
            ll c = bpow(y, i, MOD);
            total += a * b % MOD * c % MOD;
            total %= MOD;
        }
        return total;
    }
};",1420049191
nikatamliani1,nikatamliani1,46,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
            } else {
                int v = i;
                int x = i;
                for (int bit = 0; bit < 31; ++bit) {
                    if (x >> bit & 1) {
                    } else {
                        if (bit > 0) {
                            v ^= 1LL << bit - 1;
                        }
                        break;
                    }
                }
                ans.push_back(v);
            }
        }
        return ans;
    }
};",1419996004
nikatamliani1,nikatamliani1,46,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
            } else {
                int v = i;
                int x = i;
                for (int bit = 0; bit < 31; ++bit) {
                    if (x >> bit & 1) {
                    } else {
                        if (bit > 0) {
                            v ^= 1LL << bit - 1;
                        }
                        break;
                    }
                }
                ans.push_back(v);
            }
        }
        return ans;
    }
};",1419995599
Mike Qi,mikeqiyh,51,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tar) {
        int n = len(s), m = len(p);
        vi bad(n+5, 0); for (int x: tar) bad[x+1] = 1;
        vvi dp(n+3, vi(m+3, INF));
        dp[0][0] = 0;
        s = '#'+s; p = '#'+p;
        for (int i = 1; i <= n; i++){
            for (int j = 0; j <= m; j++){
                dp[i][j] = dp[i-1][j];
                if (j && p[j] == s[i]){
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]+bad[i]);
                } 
            }
        }
        return siz(tar)-dp[n][m];
    }
};",1420042751
Mike Qi,mikeqiyh,51,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
const int MAX = 2e3+4;
mi fac[MAX], facI[MAX];
bool done;

mi nck(int n, int k){
    if (k > n) return 0;
    return fac[n]*facI[k]*facI[n-k];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if (!done){
            done = true;
            fac[0] = 1; facI[0] = 1;
            for (int i = 1; i < MAX; i++){
                fac[i] = fac[i-1]*i;
                facI[i] = inv(fac[i]);
            }
        }
        mi tot = 0;
        vector<mi> dp(min(n, x)+5, 0);
        for (int i = 1; i <= min(n, x); i++){
            mi a = i, b = y;
            dp[i] = pow(a, n);
            for (int j = 1; j < i; j++){
                dp[i] -= nck(i, j)*dp[j];
            }
            mi cur = dp[i]*nck(x, i)*pow(b, i);
            tot += cur;
            //deb((int)tot, (int)dp[i]);
        }
        return (int)tot;
    }
};",1420044062
Mike Qi,mikeqiyh,51,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi ret;
        for (int x: nums){
            if (x == 2){
                ret.pb(-1); continue;
            }
            for (int i = 0; i <= 30; i++){
                if (((1<<i)&x) == 0){
                    ret.pb(x^(1<<(i-1)));
                    break;
                }
            }
        }
        return ret;
    }
};",1420043275
Mike Qi,mikeqiyh,51,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi ret;
        for (int x: nums){
            if (x == 2){
                ret.pb(-1); continue;
            }
            for (int i = 0; i <= 30; i++){
                if (((1<<i)&x) == 0){
                    ret.pb(x^(1<<(i-1)));
                    break;
                }
            }
        }
        return ret;
    }
};",1420042973
Jingzhe Tang,skywalkert,52,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& p) {
        static const int maxn = (int)3e3 + 9;
        static int f[maxn];
        int n = s.size(), m = t.size();
        memset(f, -1, m * sizeof(int));
        f[m] = 0;
        for(int i = n - 1; i >= 0; --i) {
            bool sp = 0;
            if(!p.empty() && p.back() == i) {
                sp = 1;
                p.pop_back();
            }
            for(int j = 0; j <= m; ++j) {
                int tp = f[j];
                if(f[j] != -1)
                    f[j] += sp;
                if(j < m && s[i] == t[j] && f[j + 1] != -1)
                    f[j] = max(f[j], f[j + 1]);
            }
        }
        return f[0];
    }
};",1420048113
Jingzhe Tang,skywalkert,52,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        typedef long long LL;
        static const int maxn = (int)1e3 + 9, mod = (int)1e9 + 7;
        static int bin[maxn][maxn] = {}, pw[maxn][maxn], f[maxn];
        if(!bin[0][0]) {
            for(int i = 0; i < maxn; ++i) {
                bin[i][0] = bin[i][i] = 1;
                for(int j = 1; j < i; ++j)
                    (bin[i][j] = bin[i - 1][j - 1] + bin[i - 1][j]) >= mod && (bin[i][j] -= mod);
            }
            for(int i = 1; i < maxn; ++i) {
                pw[i][0] = 1;
                for(int j = 1; j < maxn; ++j)
                    pw[i][j] = (LL)pw[i][j - 1] * i % mod;
            }
        }
        int ans = 0;
        for(int i = 1; i <= x && i <= n; ++i) {
            f[i] = pw[i][n];
            for(int j = 1; j < i; ++j)
                f[i] = (f[i] - (LL)bin[i][j] * f[j]) % mod;
            f[i] < 0 && (f[i] += mod);
            // printf(""%d: %d\n"", i, f[i]);
        }
        for(int i = min(x, n); i >= 1; --i)
            ans = (ans + (LL)bin[x][i] * f[i]) % mod * y % mod;
        return ans;
    }
};",1420034097
Jingzhe Tang,skywalkert,52,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &x: nums) {
            if(~x & 1) {
                x = -1;
                continue;
            }
            x ^= ((x + 1) & -(x + 1)) >> 1;
        }
        return nums;
    }
};",1420052350
Jingzhe Tang,skywalkert,52,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &x: nums) {
            if(~x & 1) {
                x = -1;
                continue;
            }
            x ^= ((x + 1) & -(x + 1)) >> 1;
        }
        return nums;
    }
};",1420052116
Anuj Anand,coleworld223,56,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
      using i32 = int;
      i32 n = s.size();
      i32 m = p.size();
      vector <bool> imp (n);
      for (i32 x : t) {
        imp[x] = 1;
      }
      vector <vector <i32>> dp (n + 1, vector <i32> (m + 1, -1));
      dp[0][0] = 0;
      for (i32 i = 1; i <= n; ++i) {
        dp[i][0] = 0;
        for (i32 j = 0; j <= m; ++j) {
          if (imp[i - 1]) {
            dp[i][j] = max({dp[i][j], (dp[i - 1][j] != -1 ? dp[i - 1][j] + 1 : -1), (j > 0 ? dp[i - 1][j - (s[i - 1] == p[j - 1])] : -1)});
          }
          else {
            dp[i][j] = max({dp[i][j], dp[i - 1][j],(j > 0 ? dp[i - 1][j - (s[i - 1] == p[j - 1])] : -1)});
          }
        }
      }
      // cout << dp[1][0] << '\n';
      return dp[n][m];
    }
};",1420035694
Anuj Anand,coleworld223,56,3604,cpp,"using i32 = int;
using i64 = long long;
int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
      vector <vector <mi>> dp (n + 1, vector <mi> (x + 1));
      dp[0][0] = 1;
      for (i32 p = 1; p <= n; ++p) {
        for (i32 c = 1; c <= x; ++c) {
          dp[p][c] = (dp[p - 1][c] * c + dp[p - 1][c - 1] * (x - c + 1));
        }
      }
      
      mi ans = 0;
      for (i32 c = 1; c <= x; c++) {
        ans += dp[n][c] * pow((mi) y, c);
      }
      return ans.v;
    }
};",1420053809
Anuj Anand,coleworld223,56,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      using i32 = int;
      i32 n = nums.size();
      vector <int> ans (n, -1);
      for (i32 i = 0; i < n; ++i) {
        for (i32 bit = 0; bit < 31; bit ++) {
          if (!(nums[i] >> bit & 1)) {
            if (bit - 1 >= 0) {
              ans[i] = (nums[i] ^ (1 << (bit - 1)));
            }
            break;
          }
        }
      }
      return ans;
    }
};",1420000464
Anuj Anand,coleworld223,56,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      using i32 = int;
      i32 n = nums.size();
      vector <int> ans (n, -1);
      for (i32 i = 0; i < n; ++i) {
        for (i32 bit = 0; bit < 31; bit ++) {
          if (!(nums[i] >> bit & 1)) {
            if (bit - 1 >= 0) {
              ans[i] = (nums[i] ^ (1 << (bit - 1)));
            }
            break;
          }
        }
      }
      return ans;
    }
};",1420000042
Ryan,ryanwong0127,57,3487,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
// int dp[30005][30005]={0};
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& targetIndices) {
        int n = s.size(), m = p.size();
        int idxCnt = targetIndices.size();
        vi ht(n+1);
        for(auto &x:targetIndices){ht[x] = 1;}
        // set<int> ht(all(targetIndices));
        vvi dp(n+1, vi(m+1, inf));
        
        rep(i, 0, n + 1) dp[i][0] = 0;
        
        rep(i, 1, n+1) {
            rep(j, 0, min(i, m)+1) {
                chmin(dp[i][j], dp[i-1][j]);
                if (j >=1 && s[i-1]==p[j-1]){
                    int cost = dp[i-1][j-1];
                    if (ht[i-1]) {cost++;}
                    chmin(dp[i][j], cost);
                }
            }
        }
        int res = idxCnt - dp[n][m];
        return max(0, res);
    }
};",1420030497
Ryan,ryanwong0127,57,3604,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
bool INIT = false;
constexpr static int N = 1010;
ll a[N + 1] = {0}, b[N + 1] = {0}, inv[N + 1] = {0};
ll S[N + 1][N + 1] = {1, 0};
ll fact[N + 5] = {1};
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if (!INIT) {
            INIT = 1;
            combInit(N);
            BigInit();
        }
        
        ll res = 0;
        rep(s, 1, min(n, x) + 1) {
            ll cur = comb(x, s);
            cur = cur * fact[s] % mod;
            cur = cur * S[n][s] % mod;
            cur = cur * qpow(y, s) % mod;
            chsum(res, cur);
        }
        return res;
    }
private:
    ll qpow(ll a, int n){
        ll ans = 1;
        while(n) {
            if(n & 1)   {    //如果n的当前末位为1
                ans = (ans * a) % mod;  //ans乘上当前的a
            }
            a = (a * a) % mod;        //a自乘
            n >>= 1;       //n往右移一位
        }
        return ans;
    }
    void BigInit() {
        rep(i, 1, N + 1) {
            rep(j, 1, N + 1) {
                S[i][j] = ((j * S[i-1][j] % mod) + S[i-1][j-1])%mod;
            }
        }
        rep(i, 1, N + 1) {
            fact[i] = fact[i - 1] * i % mod;
        }
    }
    void combInit(int n) {
        inv[1] = 1;
        rep(i, 2, n+1) {
            inv[i] = (mod - mod / i) * (ll)inv[mod % i] % mod;
        }
        a[0] = 1;
        b[0] = 1;
        rep(i, 1, n+1) {
            a[i] = (ll)a[i - 1] * i % mod;
            b[i] = (ll)b[i - 1] * inv[i] % mod;
        }
    }
    ll comb(int n, int m) {
        if (n < m || m < 0) {
            return 0;
        }
        return a[n] * b[m] % mod * b[n - m] % mod;
    }
};",1420054009
Ryan,ryanwong0127,57,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        for x in a:
            min_n = -1
            for k in range(32):
                if (x >> k) & 1:
                    n = x & (~(1 << k))
                    r = (1 << k) - 1
                    cand = n | r
                    if cand >= 0 and (cand | (cand +1)) == x:
                        if min_n == -1 or cand < min_n:
                            min_n = cand
            ans.append(min_n)
        return ans",1419997838
Ryan,ryanwong0127,57,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        for x in a:
            min_n = -1
            for k in range(32):
                if (x >> k) & 1:
                    n = x & (~(1 << k))
                    r = (1 << k) - 1
                    cand = n | r
                    if cand >= 0 and (cand | (cand +1)) == x:
                        if min_n == -1 or cand < min_n:
                            min_n = cand
            ans.append(min_n)
        return ans",1419997426
BERNARD BRAHIMCHA,BERNARB01,58,3487,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int maxRemovals(string s, string t, vector<int>& p) {
    int n = int(s.length());
    int m = int(t.length());
    vector<int> cost(n);
    for (int i : p) {
      cost[i] = 1;
    }
    const int inf = int(1e9) + 9;
    vector<int> dp(m + 1, inf);
    dp[0] = 0;
    for (int i = 0; i < n; i++) {
      vector<int> new_dp(m + 1, inf);
      for (int j = 0; j <= min(i, m); j++) {
        new_dp[j] = min(new_dp[j], dp[j]);
        if (j < m && s[i] == t[j]) {
          new_dp[j + 1] = min(new_dp[j + 1], dp[j] + cost[i]);
        }
      }
      swap(dp, new_dp);
    }
    return int(p.size()) - dp[m];
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1420054081
BERNARD BRAHIMCHA,BERNARB01,58,3604,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

class Solution {
 public:
  int numberOfWays(int n, int x, int y) {
    vector<int> dp(x + 1);
    dp[1] = x;
    for (int i = 1; i < n; i++) {
      vector<int> new_dp(x + 1);
      for (int j = 1; j <= x; j++) {
        add(new_dp[j], mul(j, dp[j]));
        if (j < x) {
          add(new_dp[j + 1], mul(x - j, dp[j]));
        }
      }
      swap(dp, new_dp);
    }
    deb(dp);
    int ans = 0;
    for (int i = 1; i <= x; i++) {
      add(ans, mul(dp[i], po(y, i)));
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.numberOfWays(1, 2, 3));
  deb(sl.numberOfWays(5, 2, 1));
  deb(sl.numberOfWays(3, 3, 4));
}
#endif
",1420001700
BERNARD BRAHIMCHA,BERNARB01,58,3605,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& a) {
    int n = int(a.size());
    vector<int> ans(n);
    for (int i = 0; i < n; i++) {
      if (a[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int x = a[i], cnt = 0;
      while (x & 1) {
        x >>= 1;
        cnt++;
      }
      ans[i] = a[i] ^ (1 << (cnt - 1));
      assert((ans[i] | (ans[i] + 1)) == a[i]);
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1420031347
BERNARD BRAHIMCHA,BERNARB01,58,3611,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& a) {
    int n = int(a.size());
    vector<int> ans(n);
    for (int i = 0; i < n; i++) {
      if (a[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int x = a[i], cnt = 0;
      while (x & 1) {
        x >>= 1;
        cnt++;
      }
      ans[i] = a[i] ^ (1 << (cnt - 1));
      assert((ans[i] | (ans[i] + 1)) == a[i]);
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1420031157
user7338k,user7338k,59,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> can(n);
        for (int a : targetIndices) {
            can[a] = 1;
        }

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        dp[0][0] = 0;
        int ans = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (dp[i][j] == -1) {
                    continue;
                }
                if (j < m && source[i] == pattern[j]) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                if (can[i]) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
                }
            }
        }

        return dp[n][m];
    }
};",1420015064
user7338k,user7338k,59,3604,cpp,"class Solution {
public:
    constexpr static int kMod = 1e9 + 7;
    vector<long long> fact;
    vector<long long> inv;
    vector<vector<long long>> dp;

    int numberOfWays(int n, int x, int y) {
        prep();
        cout << ""prep"" << endl;
        long long ans = 0;
        for (int bn = 1; bn <= x && bn <= n; ++bn) {
            ans = (ans + getAns(n, x, bn) * modPow(y, bn, kMod)) % kMod;
            //cout << bn << "" pw "" << modPow(bn, y, kMod) << endl;
        }
        return ans;
    }

    void prep() {
        fact.resize(1005);
        inv.resize(1005);
        dp.resize(1005, vector<long long>(1005));
        dp[0][0] = 1;
        fact[0] = 1;
        inv[0] = 1;
        for (int i = 1; i < 1005; ++i) {
            fact[i] = (fact[i - 1] * i ) % kMod;
            inv[i] = modPow(fact[i], kMod - 2, kMod);
        }

        // i - people
        // j - groups
        for (int i = 1; i < 1005; ++i) {
            dp[i][0] = 0;
            for (int j = 1; j < 1005; ++j) {
                dp[i][j] = (dp[i - 1][j - 1] + 1LL * j * dp[i - 1][j]) % kMod;
            }
        }
    }

    long long getAns(int n, int x, int st) {
        //cout << ""people "" << n << "" scenes "" << x << "" bands "" << st << endl;
        long long cm = getComb(x, st);
        //cout << cm << "" "" << dp[n][st] << endl;
        long long ans = cm  * dp[n][st] % kMod * fact[st] % kMod;
        //cout << ans << endl;
        return ans;
    }

    long long getComb(long long n, long long k) {
        return fact[n] * inv[k] % kMod * inv[n - k] % kMod;
    }

    int modPow(long long a, long long pw, long long mod) {
        long long ans = 1;
        while (pw) {
            if (pw & 1) {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            pw /= 2;
        }
        return ans;
    }
};",1420054293
user7338k,user7338k,59,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> ans;
        for (int a : nums) {
            ans.push_back(solve(a));
        }
        return ans;
    }

    int solve(int a) {
        int ans = -1;
        for (int j = 0; j < 30; ++j) {
            int cur = 0;
            for (int k = 0; k < j; ++k) {
                cur |= (1 << k);
            }

            for (int k = j + 1; k < 30; ++k) {
                if (a & (1 << k)) {
                    cur |= (1 << k);
                }
            }

            //cout << j << "" "" << cur << "" "" << (cur |)
            if ((cur | (cur + 1)) == a) {
                if (ans == -1 || cur < ans) {
                    ans = cur;
                }
            }
        }
        return ans;
    }
};",1420003543
user7338k,user7338k,59,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int a : nums) {
            ans.push_back(solve(a));
        }
        return ans;
    }

    int solve(int a) {
        int ans = -1;
        for (int j = 0; j < 30; ++j) {
            int cur = 0;
            for (int k = 0; k < j; ++k) {
                cur |= (1 << k);
            }

            for (int k = j + 1; k < 30; ++k) {
                if (a & (1 << k)) {
                    cur |= (1 << k);
                }
            }

            //cout << j << "" "" << cur << "" "" << (cur |)
            if ((cur | (cur + 1)) == a) {
                if (ans == -1 || cur < ans) {
                    ans = cur;
                }
            }
        }
        return ans;
    }
};",1420002926
mastoori1234,mastoori1234,61,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        
        int ns = s.length();
        int np = p.length();
        int nt = t.size();
        
        vector<bool> valid( ns, false);
        for( int idx: t) {
            valid[idx] = true;
        }
        
        vector< vector<int> > dp( ns, vector<int>( np, -1)); // lcs with cost as targetIds
        
        function<int(int,int)> solve;
        
        solve = [&]( int si, int pi)->int {
            if(pi<0) {
                return 0;
            }
            if(si<0) {
                return 1e4;
            }
            if(dp[si][pi]==-1) {
                dp[si][pi] = np;
                dp[si][pi] = min( dp[si][pi], solve( si-1, pi));
                if(s[si]==p[pi]) {
                    dp[si][pi] = min(
                        dp[si][pi],
                        valid[si]+solve( si-1, pi-1)
                    );
                }
            }
            return dp[si][pi];
        };
        
        int ans = solve( ns-1, np-1);
        
        return nt-ans;
    }
};",1420034540
mastoori1234,mastoori1234,61,3604,cpp,"typedef long long int ll;

ll mod = 1e9+7;

ll ffe( ll a, ll b) {
    if(b==0) {
        return 1;
    } else {
        return (((b%2==1)?a:1)*ffe( (a*a)%mod, b/2))%mod;
    }
}

class Solution {
public:
    int numberOfWays(int N, int X, int Y) {
        
        ll n = N;
        ll x = X;
        ll y = Y;
        
        ll ans = 0;
        
        vector<ll> a(x+1, 0);
        a[0] = 1;
        
        for( ll i=1; i<=n; i++) {      // number of performers
            for( ll j=x; j>=0; j--) {  // number of stages
                if(j+1<=x) {
                    a[j+1] = (a[j+1]+a[j]*(x-j))%mod;
                }
                a[j] = (a[j]*j)%mod;
            }
        }
        
        for( ll i=0; i<=x; i++) {
            a[i] = (a[i]*ffe(y,i))%mod;
            ans = (ans+a[i])%mod;
        }
        
        return ans;
    }
};",1420011148
mastoori1234,mastoori1234,61,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> arr(n);
        
        for( int i=0; i<n; i++) {
            int val = nums[i];
            if(val%2==0) {
                arr[i] = -1;
                continue;
            }
            int t;
            // t = val&(val+1);
            // if(t==0) {
            //     arr[i] = val/2;
            //     continue;
            // }
            t = 0;
            while(val%2==1) {
                t = 2*t+1;
                val = val/2;
            }
            arr[i] = (nums[i]^t)^(t>>1);
        }
        
        return arr;
    }
};",1420055825
mastoori1234,mastoori1234,61,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> arr(n);
        
        for( int i=0; i<n; i++) {
            int val = nums[i];
            if(val%2==0) {
                arr[i] = -1;
                continue;
            }
            int t;
            // t = val&(val+1);
            // if(t==0) {
            //     arr[i] = val/2;
            //     continue;
            // }
            t = 0;
            while(val%2==1) {
                t = 2*t+1;
                val = val/2;
            }
            arr[i] = (nums[i]^t)^(t>>1);
        }
        
        return arr;
    }
};",1420055092
geng102810,geng102810,62,3487,cpp,"constexpr int inf=1e9;
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n=s.size(),m=p.size();
        std::vector<int> st(n+2,0);
        for(auto x:t) st[x+1]=1;
        std::vector<std::vector<int>> f(n+2,std::vector<int> (m+2,inf));
        f[0][0]=0;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=m;j++){
                f[i][j]=std::min(f[i][j],f[i-1][j]);
                if(j>=1){
                    char u=s[i-1],v=p[j-1];
                    if(u==v) f[i][j]=std::min(f[i-1][j-1]+st[i],f[i][j]);
                }
            }
            
        }
        int res=0;
        for(int i=0;i<=n;i++){
            if(f[i][m]!=inf) res=std::max(res,(int)t.size()-f[i][m]);
        }
        return res;
    }
};",1420031432
geng102810,geng102810,62,3604,cpp,"template <unsigned M_> struct ModInt {
  static constexpr unsigned M = M_;
  unsigned x;
  constexpr ModInt() : x(0U) {}
  constexpr ModInt(unsigned x_) : x(x_ % M) {}
  constexpr ModInt(unsigned long long x_) : x(x_ % M) {}
  constexpr ModInt(int x_) : x(((x_ %= static_cast<int>(M)) < 0) ? (x_ + static_cast<int>(M)) : x_) {}
  constexpr ModInt(long long x_) : x(((x_ %= static_cast<long long>(M)) < 0) ? (x_ + static_cast<long long>(M)) : x_) {}
  ModInt &operator+=(const ModInt &a) { x = ((x += a.x) >= M) ? (x - M) : x; return *this; }
  ModInt &operator-=(const ModInt &a) { x = ((x -= a.x) >= M) ? (x + M) : x; return *this; }
  ModInt &operator*=(const ModInt &a) { x = (static_cast<unsigned long long>(x) * a.x) % M; return *this; }
  ModInt &operator/=(const ModInt &a) { return (*this *= a.inv()); }
  ModInt pow(long long e) const {
    if (e < 0) return inv().pow(-e);
    ModInt a = *this, b = 1U; for (; e; e >>= 1) { if (e & 1) b *= a; a *= a; } return b;
  }
  ModInt inv() const {
    unsigned a = M, b = x; int y = 0, z = 1;
    for (; b; ) { const unsigned q = a / b; const unsigned c = a - q * b; a = b; b = c; const int w = y - static_cast<int>(q) * z; y = z; z = w; }
    assert(a == 1U); return ModInt(y);
  }
  ModInt operator+() const { return *this; }
  ModInt operator-() const { ModInt a; a.x = x ? (M - x) : 0U; return a; }
  ModInt operator+(const ModInt &a) const { return (ModInt(*this) += a); }
  ModInt operator-(const ModInt &a) const { return (ModInt(*this) -= a); }
  ModInt operator*(const ModInt &a) const { return (ModInt(*this) *= a); }
  ModInt operator/(const ModInt &a) const { return (ModInt(*this) /= a); }
  template <class T> friend ModInt operator+(T a, const ModInt &b) { return (ModInt(a) += b); }
  template <class T> friend ModInt operator-(T a, const ModInt &b) { return (ModInt(a) -= b); }
  template <class T> friend ModInt operator*(T a, const ModInt &b) { return (ModInt(a) *= b); }
  template <class T> friend ModInt operator/(T a, const ModInt &b) { return (ModInt(a) /= b); }
  explicit operator bool() const { return x; }
  bool operator==(const ModInt &a) const { return (x == a.x); }
  bool operator!=(const ModInt &a) const { return (x != a.x); }
  bool operator<(const ModInt &a) const { return (x < a.x); }
  bool operator>(const ModInt &a) const { return (x > a.x); }
  bool operator<=(const ModInt &a) const { return (x <= a.x); }
  bool operator>=(const ModInt &a) const { return (x >= a.x); }
  friend std::ostream &operator<<(std::ostream &os, const ModInt &a) { return os << a.x; }
  friend std::istream &operator>>(std::istream &is, ModInt &a) {int v;is >> v;a = ModInt(v);return is;}
};
constexpr unsigned MO = 1000000007;
using Mint = ModInt<MO>;

constexpr int N=1010,M=1000000007;

Mint aa[N],bb[N];
Mint inv[N];
bool flag=0;

Mint s[N][N];
 
void init(){
    inv[1] = 1;
    for(int i = 2;i < N;i++)  inv[i] = (M -  M / i) * inv[M % i];
    aa[0]=1,bb[0]=1;
    for(int i=1;i<N;i++) aa[i]=(i*aa[i-1]);
    for(int i=1;i<N;i++) bb[i]=(inv[i]*bb[i-1]);
    s[0][0]=1;
    for(int i=1;i<N;i++){
        for(int j=1;j<N;j++) s[i][j]=s[i-1][j-1]+s[i-1][j]*j;
    }
}
 
Mint C(int x, int y) {
    return x < y || y < 0 ? 0 : aa[x] * bb[y]  * bb[x - y] ;
}

Mint S(int x,int y){
    return s[x][y]*aa[y];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(!flag) init(),flag=1;
        int mi=std::max(0,x-n);
        Mint res=0;
        for(int i=mi;i<x;i++){
            res+=C(x,i)*Mint(y).pow(x-i)*S(n,x-i);
        }
        return res.x;
    }
};",1420055928
geng102810,geng102810,62,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        std::vector<int> res(n,-1);
        for(int i=0;i<n;i++){
            int x=nums[i];
            for(int j=0;j<=x;j++){
                if((j|(j+1))==x){
                    res[i]=j;
                    break;
                }
            }
        }
        return res;
    }
};",1419994687
geng102810,geng102810,62,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        std::vector<int> res(n,-1);
        for(int i=0;i<n;i++){
            int x=nums[i];
            if(x&1){
                int t=std::__lg(x);
                if((1<<t)==x) res[i]=x/2;
                else {
                    for(int j=0;j<32;j++){
                        if(!(x>>j&1)){
                            res[i]=x-(1<<(j-1));
                            break;
                        }
                    }
                }
            }
        }
        return res;
    }
};",1420011628
Rahul Kumar Yadav,user0434y,63,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int totalTarget = targetIndices.size();
        
        // Step 1: Mark target indices
        vector<bool> isTarget(n, false);
        for(auto idx : targetIndices){
            isTarget[idx] = true;
        }
        
        // Step 2: Initialize DP array
        // dp[j] = minimum number of target indices used to match first j characters of pattern
        vector<int> dp(m + 1, INT32_MAX);
        dp[0] = 0; // Matching empty pattern requires 0 target indices
        
        // Step 3: Populate DP array
        for(int i = 0; i < n; ++i){
            // Iterate backwards to prevent overwriting dp[j-1] needed for current j
            for(int j = m; j >=1; --j){
                if(source[i] == pattern[j-1]){
                    if(dp[j-1] != INT32_MAX){
                        // If current character is a target index, increment the count
                        int added = isTarget[i] ? 1 : 0;
                        dp[j] = min(dp[j], dp[j-1] + added);
                    }
                }
            }
        }
        
        // Step 4: Determine the result
        if(dp[m] == INT32_MAX){
            // Pattern cannot be formed even without removals
            return 0;
        }
        
        // Maximum number of removals is totalTarget minus the number of target indices used in matching
        // However, some targetIndices might not be used in the matching at all
        // Thus, we need to ensure that we only subtract the targetIndices that are used
        // To find the exact number used, we can trace back the matching
        // But for simplicity, since dp[m] gives the minimal number used, and all targetIndices can be removed except those used
        return totalTarget - dp[m];
    }
};
",1420030046
Rahul Kumar Yadav,user0434y,63,3604,cpp,"class Solution {
public:
    const int MOD = 1'000'000'007;
    
    // computes (base^power) % MOD
    long long powmod(long long base, long long power) {
        long long result = 1;
        base %= MOD;
        while(power > 0){
            if(power & 1){
                result = result * base % MOD;
            }
            base = base * base % MOD;
            power >>=1;
        }
        return result;
    }
    
    int numberOfWays(int n, int x, int y) {
        // Precompute factorial and inverse factorial up to x
        vector<long long> fact(x +1, 1);
        for(int i=1;i<=x;i++) {
            fact[i] = fact[i-1] * i % MOD;
        }
        
        // Precompute inverse factorial using Fermat's little theorem
        vector<long long> inv_fact(x +1, 1);
        inv_fact[x] = powmod(fact[x], MOD -2);
        for(int i=x-1;i>=0;i--){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
        
        // Compute y^k for k=0 to x
        vector<long long> power_y(x +1, 1);
        for(int k=1; k<=x; k++) {
            power_y[k] = power_y[k-1] * y % MOD;
        }
        
        // Compute Stirling numbers of the second kind for k=0 to x
        // Using 1D DP
        vector<long long> dp(x +1, 0);
        dp[0] = 1; // {0 \brace 0} =1
        for(int i=1;i<=n;i++){
            // Iterate k from min(i, x) downto1
            // to use previous dp[k] and dp[k-1]
            for(int k = min(i, x); k >=1; k--){
                dp[k] = (k * dp[k] % MOD + dp[k-1]) % MOD;
            }
            dp[0] =0;
        }
        
        // Compute the total number of ways
        long long total =0;
        for(int k=1; k<=x && k<=n; k++){
            // P(x,k) = fact[x] * inv_fact[x -k] % MOD
            long long P_x_k = fact[x] * inv_fact[x -k] % MOD;
            // Stirling number of second kind = dp[k]
            long long stirling = dp[k];
            // y^k = power_y[k]
            long long y_pow_k = power_y[k];
            // term = P(x,k) * dp[k] % MOD * y^k % MOD
            long long term = P_x_k * stirling % MOD;
            term = term * y_pow_k % MOD;
            // Add to total
            total = (total + term) % MOD;
        }
        
        return (int)total;
    }
};
",1420056390
Rahul Kumar Yadav,user0434y,63,3605,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> ans;
        
        for(auto p : nums){
            // Prime number 2 cannot be expressed as x OR (x + 1)
            if(p == 2){
                ans.push_back(-1);
                continue;
            }
            
            // Count the number of trailing 1's in the binary representation of p
            int t = 0;
            int temp = p;
            while((temp & 1) == 1){
                t++;
                temp >>=1;
            }
            
            // Calculate x based on the count of trailing 1's
            int x;
            if(t >=1){
                x = p - (1 << (t -1));
            }
            else{
                x = p -1;
            }
            
            // Validate if x OR (x + 1) equals p
            if(x >=0 && ((x | (x +1)) == p)){
                ans.push_back(x);
            }
            else{
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};
",1419999184
Rahul Kumar Yadav,user0434y,63,3611,cpp,"#include <vector>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> ans;
        
        for(auto p : nums){
            // Prime number 2 cannot be expressed as x OR (x + 1)
            if(p == 2){
                ans.push_back(-1);
                continue;
            }
            
            // Count the number of trailing 1's in the binary representation of p
            int t = 0;
            int temp = p;
            while((temp & 1) == 1){
                t++;
                temp >>=1;
            }
            
            // Calculate x based on the count of trailing 1's
            int x;
            if(t >=1){
                x = p - (1 << (t -1));
            }
            else{
                x = p -1;
            }
            
            // Validate if x OR (x + 1) equals p
            if(x >=0 && ((x | (x +1)) == p)){
                ans.push_back(x);
            }
            else{
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};
",1419999727
Jie Chen,JustJie,64,3487,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:51
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

constexpr int A = 26, inf = int(1e9) + 5;

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& choose) {
        int n = s.size();
        int m = t.size();

        vector<vector<int>> g(A);
        for (int i = 0; i < m; i++) {
            g[t[i] - 'a'].push_back(i);
        }

        for (int a = 0; a < A; a++) {
            ranges::reverse(g[a]);
        }

        vector<int> can_remove(n);
        for (int i : choose) {
            can_remove[i] = 1;
        }

        vector<int> dp(m + 1, -inf);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            auto ndp = dp;
            if (can_remove[i]) {
                for (int j = 0; j <= m; j++) {
                    if (ndp[j] != -inf) {
                        ndp[j] += 1;
                    }
                }
            }
            for (int j : g[s[i] - 'a']) {
                if (dp[j] != -inf) {
                    ndp[j + 1] = max(ndp[j + 1], dp[j]);
                }
            }
            dp = std::move(ndp);
        }

        return dp[m];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1420020321
Jie Chen,JustJie,64,3604,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:51
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector f(n + 1, vector<Z>(n + 1));
        f[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = (f[i - 1][j] * j + f[i - 1][j - 1]);
            }
        }

        Z ans = 0;
        int choice = min(n, x);
        for (int i = 1; i <= choice; i++) {
            Z t = comb.binom(x, i);
            Z bi = f[n][i];
            Z res = power(Z(y), i);
            res = t * comb.fac(i) * bi * res;
            ans += res;
        }
        return ans.val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1420048755
Jie Chen,JustJie,64,3605,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:32
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();

        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            for (int x = 1; x <= 1000; x++) {
                if ((x | (x + 1)) == a[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }

        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1419997329
Jie Chen,JustJie,64,3611,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:32
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

constexpr int B = 31;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();

        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            if (a[i] == 2) {
                ans[i] = -1;
            } else {
                int zero = -1;
                int lst = 0;
                for (int b = 0; b < B; b++) {
                    if ((1 << b) > a[i]) {
                        break;
                    }
                    if ((1 << b) & a[i]) {
                        lst = (1 << b);
                    } else {
                        zero = -1;
                        break;
                    }
                }
                if (zero == -1) {
                    ans[i] = a[i] - lst;
                } else {
                    ans[i] = a[i] - (1 << zero);
                }
            }
        }

        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1420006604
mo_atef,ScorpioDagger,65,3487,cpp,"class Solution {
public:
    typedef long long ll;
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int a((int)source.size()), b((int)pattern.size()), c((int)targetIndices.size());
        vector<bool> vis(a);
        for (int &i : targetIndices) 
            if(i >= 0 and i < a)
                vis[i] = 1;
        vector<bool> v2 = vis;
        vector<ll> pre(b+1, LLONG_MAX), cur(b+1, LLONG_MAX);
        pre[0] = 0;
        for (int i(1); i <= a; ++i){
            cur[0] = 0;
            for(int j(1); j <= b; ++j){
                if (source[i-1] == pattern[j-1]){
                    if (v2[i-1]){
                        if (pre[j-1] != LLONG_MAX)
                            cur[j] = min(cur[j], pre[j-1]+1);
                    } 
                    else 
                        if (pre[j-1] != LLONG_MAX)
                            cur[j] = min(cur[j], pre[j-1]);
                }
                if (pre[j] != LLONG_MAX) cur[j] = min(cur[j], pre[j]);
            }
            pre = cur;
            fill(cur.begin(), cur.end(), LLONG_MAX);
        }
        int mn(pre[b]);
    return (mn <= c) ? (c-(int)mn) : -1;    
    }
};",1420036923
mo_atef,ScorpioDagger,65,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        int a(n), b(x), c(y);
        ll ans(0);
        vector<vector<int>> C(b+1, vector<int>(b+1));
        vector<vector<ll>> st(a+1, vector<ll>(a+1));
        C[0][0] = 1;
        for (int i(1); i <= b; ++i){
            C[i][0] = 1;
            for (int j(1); j <= i; ++j)
                C[i][j] = (C[i-1][j-1] % MOD + C[i-1][j] % MOD) % MOD;
        }
        st[0][0] = 1;
        for (int i(1); i <= a; ++i){
            for (int j(1); j <= i; ++j)
                st[i][j] = (st[i-1][j-1] % MOD + ((ll)j % MOD * st[i-1][j] % MOD) % MOD) % MOD;
        }
        vector<ll> fac(a+1, 1), yp(a+1, 1);
        for (int i(1); i <= a; ++i)
            fac[i] = (fac[i-1] % MOD * i % MOD) % MOD;
        for(int i = 1; i <= a; ++i)
            yp[i] = (yp[i-1] % MOD * (ll)c % MOD) % MOD;
        int mx(min(a, b));
        for (int k(1), t; k <= mx; ++k){
            t = ((ll)C[b][k] % MOD * st[a][k] % MOD) % MOD;
            t = (t % MOD * fac[k] % MOD) % MOD, t = (t % MOD * yp[k] % MOD) % MOD;
            ans = (ans % MOD + t % MOD) % MOD;
        }
        return (int)ans;
    }
};",1420056848
mo_atef,ScorpioDagger,65,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            f = 0
            for a in range(num):
                if a | (a + 1) == num:
                    ans.append(a)
                    f = 1
                    break
            if not f:
                ans.append(-1)
        return ans",1419993705
mo_atef,ScorpioDagger,65,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            mn = -1
            for bit in range(31):
                if (num >> bit) & 1:
                    ca = num & ~(1 << bit)
                    if ca < num:
                        if (ca | (1+ca)) == num:
                            if mn == -1 or ca < mn:
                                mn = ca
            ans.append(mn)
        return ans",1419999253
Sarthak Pandey,SarthakPaandey,67,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
    int n = source.length();
    int m = pattern.length();
    boolean[] isTarget = new boolean[n];
    for (int idx : targetIndices) isTarget[idx] = true;
    int[] dp = new int[m + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int s = 0; s < n; s++) {
        for (int p = m; p >= 1; p--) {
            if (source.charAt(s) == pattern.charAt(p - 1) && dp[p - 1] != Integer.MAX_VALUE) {
                dp[p] = Math.min(dp[p], dp[p - 1] + (isTarget[s] ? 1 : 0));
            }
        }
    }
    if (dp[m] == Integer.MAX_VALUE) return 0;
    return targetIndices.length - dp[m];
    }
}",1420038565
Sarthak Pandey,SarthakPaandey,67,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        final int MOD = 1_000_000_007;
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= Math.min(i, x); j++) {
                S[i][j] = (S[i-1][j-1] + (j * S[i-1][j]) % MOD) % MOD;
            }
        }
        long[] powy = new long[x + 1];
        powy[0] = 1;
        for(int k = 1; k <= x; k++) {
            powy[k] = powy[k-1] * y % MOD;
        }
        long tot = 0;
        long P = 1;
        for(int k = 1; k <= Math.min(x, n); k++) {
            P = P * (x - k + 1) % MOD;
            long term = P * S[n][k] % MOD;
            term = term * powy[k] % MOD;
            tot = (tot + term) % MOD;
        }
        return (int) tot;
    }
}
",1420050038
Sarthak Pandey,SarthakPaandey,67,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] jaiho = new int[n];
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            int x = -1;
            for (int j = 0; j < p; j++) {
                if ((j | (j + 1)) == p) {
                    x = j;
                    break;
                }
            }
            jaiho[i] = x;
        }
        return jaiho;
    }
}
",1420012303
Sarthak Pandey,SarthakPaandey,67,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] jaihoji = new int[n];

        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            if (p == 2) {
                jaihoji[i] = -1;
                continue;
            }

            List<Integer> setBits = new ArrayList<>();
            for (int bit = 0; bit < 32; bit++) {
                if ((p >> bit & 1) == 1) {
                    setBits.add(bit);
                }
            }

            int minX = Integer.MAX_VALUE;
            for (int bit : setBits) {
                int x = p & ~(1 << bit);
                if ((x | (x + 1)) == p) {
                    minX = Math.min(minX, x);
                }
            }

            jaihoji[i] = (minX != Integer.MAX_VALUE) ? minX : -1;
        }

        return jaihoji;
    }
}
",1420025537
scanhex,scanhex,68,3487,cpp,"
using nagai = long long;
class Solution {
public:
  int maxRemovals(string source, string pattern, vector<int> &targetIndices) {
    int n = source.size();
    int m = pattern.size();
    vector<int> su(n + 1);
    su[n - 1] = source.back() == pattern.back();
    for (int i = n - 2; i >= 0; --i) {
      su[i] = su[i + 1] +
              (su[i + 1] < m && source[i] == pattern[m - su[i + 1] - 1]);
    }
    vector<vector<int>>dp(n + 1, vector<int>(m + 1, 1e9));
    dp[0][0] = 0;
    vector<bool> good(n, true);
    for (int x : targetIndices) {
      good[x] = false;
    }
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= m; ++j) {
            if (i + 1 <= n)
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
            if (i < n && j < m && source[i] == pattern[j])
                dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + !good[i]);
        }
    }
    return (targetIndices.size() - dp[n][m]);
  }
};
",1420020859
scanhex,scanhex,68,3604,cpp,"
using nagai = long long;
const int mod = 1e9 + 7;
int mu(int a, int b) { return (nagai)a * b % mod; }
void ad(int &x, int y) {
  if ((x += y) >= mod)
    x -= mod;
}
int pw(int a, int b, int c = 1) {
  for (; b; b >>= 1, a = mu(a, a))
    if (b & 1)
      c = mu(c, a);
  return c;
}
const int N = 1010;
int fact[N], rfact[N];
bool prec = false;
void precalc() {
  fact[0] = 1;
  for (int i = 0; i + 1 < N; ++i)
    fact[i + 1] = mu(i + 1, fact[i]);
  rfact[N - 1] = pw(fact[N - 1], mod - 2);
  for (int i = N - 2; i >= 0; --i)
    rfact[i] = mu(i + 1, rfact[i + 1]);
}
int c(int n, int k) { return mu(fact[n], mu(rfact[k], rfact[n - k])); }
class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    if (!prec)
      prec = true, precalc();
    vector<int> dp(min(n, x) + 1);
    dp[0] = 0;
    for (int i = 1; i <= min(n, x); ++i) {
      dp[i] = pw(i, n);
      for (int j = 1; j < i; ++j) {
        dp[i] -= mu(dp[j], c(i, j));
        if (dp[i] < 0)
          dp[i] += mod;
      }
    }
    int ans = 0;
    for (int i = 1; i <= min(n, x); ++i) {
      ad(ans, mu(pw(y, i), mu(c(x, i), dp[i])));
    }
    return ans;
  }
};
",1420051194
scanhex,scanhex,68,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [] 
        for i in nums:
            if i == 2: 
                ans.append(-1)
                continue
            x = i
            kk = 1
            while x % 2 == 1:
                kk *= 2
                x //= 2
            ans.append(x * kk + (kk // 2 - 1))
        return ans",1420034610
scanhex,scanhex,68,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [] 
        for i in nums:
            if i == 2: 
                ans.append(-1)
                continue
            x = i
            kk = 1
            while x % 2 == 1:
                kk *= 2
                x //= 2
            ans.append(x * kk + (kk // 2 - 1))
        return ans",1420034430
Mehul,p4n1c,69,3487,python3,"class Solution:
    def maxRemovals(self, source: str, p: str, ti: List[int]) -> int:
        m, src = len(p), len(source)
        SET = set(ti)
        dp1 = [float('inf')] * (src + 1)

        for idx in range(src + 1):
            dp1[idx] = 0
        
        for i in range(1, m + 1):
            dp_i = [float('inf')] * (src + 1)
            for j in range(1, src + 1):
                if p[i - 1] == source[j - 1]:
                    this = dp1[j - 1] + (1 if (j - 1) in SET else 0)
                    nope = dp_i[j - 1]
                    dp_i[j] = min(this, nope)
                else:
                    dp_i[j] = dp_i[j - 1]
            dp1 = dp_i
        
        mini = dp1[src]
        
        def helper(targetArray):
            ans = []

            for num in targetArray:
                ans.append(num)

            return ans
        
        return len(ti) - mini if mini != float('inf') else 0",1420016974
Mehul,p4n1c,69,3604,python3,"class Solution:
    def numberOfWays(self, performers: int, stages: int, scoreRange: int) -> int:
        mo = 10**9 + 7

        def helper(self, n, x, y):
            MOD = 10**9 + 7
            tempo = [0] * n
            SETu_ = set()
            ans = 0

            def check(curr_: int):
                nonlocal ans
                if curr_ == n:
                    uniq = len(SETu_)
                    scores = []
                    for _ in range(uniq):
                        scores.append(1)
                    combos = 1
                    for _ in range(uniq):
                        combos = (combos * y) % MOD
                    ans = (ans + combos) % MOD
                    return

                for stage in range(x):
                    tempo[curr_] = stage
                    flag_ = False
                    if stage not in SETu_:
                        SETu_.add(stage)
                        flag_ = True
                    check(curr_ + 1)
                    if flag_:
                        SETu_.remove(stage)
            check(0)

            return ans

        maxi = max(performers, stages)

        facto = [1] * (maxi + 3)
        for num in range(1, maxi + 1):
            facto[num] = (facto[num - 1] * num) % mo

        ifacto = [1] * (maxi + 3)
        ifacto[maxi] = pow(facto[maxi], mo - 2, mo)
        for num in range(maxi, 0, -1):
            ifacto[num - 1] = (ifacto[num] * num) % mo

        def ncr(numerator, denominator):
            if denominator < 0 or denominator > numerator:
                return 0
            return (facto[numerator] * ifacto[denominator] % mo) * ifacto[numerator - denominator] % mo

        prev_ = [0] * (performers + 3)
        prev_[0] = 1

        for curr_ in range(1, performers + 1):
            temp_ = [0] * (performers + 3)
            for stage_ in range(1, curr_ + 1):
                m1 = (stage_ * prev_[stage_]) % mo
                m2 = prev_[stage_ - 1]
                temp_[stage_] = (m1 + m2) % mo
            prev_ = temp_

        minis_ = min(stages, performers)

        pow_ = [1] * (minis_ + 3)
        for exp in range(1, minis_ + 1):
            pow_[exp] = (pow_[exp - 1] * scoreRange) % mo

        ans = 0

        def che(may):
            for num in may:
                num += 1
            return may

        for active_stages in range(1, minis_ + 1):
            sperm_ = facto[active_stages]
            snum_ = prev_[active_stages]

            options = ncr(stages, active_stages)
            
            ass_ = pow_[active_stages]
            t_ = (options * snum_) % mo
            t_ = (t_ * sperm_) % mo
            t_ = (t_ * ass_) % mo

            ans = (ans + t_) % mo

            checking = (options + snum_ + sperm_ + ass_) % mo
            _ = checking

        return ans",1420059134
Mehul,p4n1c,69,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def helper(find):
            for idx in range(find):
                if idx | (1 + idx) == find:
                    return idx
                    
            return -1

        ans = []

        for num in nums:
            ans.append(helper(num))

        return ans",1420009463
Mehul,p4n1c,69,3611,python3,"class Solution:
    def minBitwiseArray(self, arr: List[int]) -> List[int]:
        def helper(find):
            if find == 0:
                return -1
            t = 0
            curr = find
            while curr & 1:
                t += 1
                curr >>= 1
            if t == 0:
                return -1
            x = find - (1 << (t - 1))
            if x >= 0 and (x | (x + 1)) == find:
                return x
            else:
                return -1

        def bitwise(temp):
            ans = []

            for i in range(10, -1, -1):
                ans.append(temp^temp)

            return ans

        return [helper(number) for number in arr]",1420027608
colorfuldata,colorfuldata,70,3487,python3,"from typing import List
import sys

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        target_set = set(targetIndices)
        prev = [sys.maxsize] * (m + 1)
        curr = [sys.maxsize] * (m + 1)
        prev[0] = 0
        
        for i in range(n):
            curr = [sys.maxsize] * (m + 1)
            for j in range(m + 1):
                if prev[j] == sys.maxsize:
                    continue
                curr[j] = min(curr[j], prev[j])
                if j < m and source[i] == pattern[j]:
                    cost = prev[j] + (1 if i in target_set else 0)
                    curr[j + 1] = min(curr[j + 1], cost)
            prev = curr
        
        if prev[m] == sys.maxsize:
            return 0
        
        min_keep = prev[m]
        return len(targetIndices) - min_keep",1420007433
colorfuldata,colorfuldata,70,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        def compFact(mn):
            f = [1] * (mn + 1)
            for i in range(1, mn + 1):
                f[i] = f[i - 1] * i % MOD
            invF = [1] * (mn + 1)
            invF[mn] = pow(f[mn], MOD - 2, MOD)
            for i in range(mn - 1, -1, -1):
                invF[i] = invF[i + 1] * (i + 1) % MOD
            return f, invF

        def compStir(n):
            S = [[0] * (n + 1) for _ in range(n + 1)]
            S[0][0] = 1
            for i in range(1, n + 1):
                for j in range(1, i + 1):
                    S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
            return S

        def comb(n, k, f, invF):
            if k < 0 or k > n:
                return 0
            return f[n] * invF[k] % MOD * invF[n - k] % MOD
        
        f, invF = compFact(x)
        S = compStir(n)
  
        lem = x
        
        total = 0
        mx_k = min(n, x)
        
        for k in range(1, mx_k + 1):
            c = comb(x, k, f, invF)      
            stir = S[n][k]                                
            perms = f[k]                              
            y_pow = pow(y, k, MOD)                       
            ways = c * stir % MOD
            ways = ways * perms % MOD
            ways = ways * y_pow % MOD
            total = (total + ways) % MOD
        
        return total
",1420051520
colorfuldata,colorfuldata,70,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def find_min_x(num: int) -> int:
            for x in range(num):
                if (x | (x + 1)) == num:
                    return x
            return -1

        return [find_min_x(num) for num in nums]
",1419995592
colorfuldata,colorfuldata,70,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def findMinX(y: int) -> int:
            minX = float('inf')
            for bit in range(y.bit_length()):
                if y & (1 << bit):
                    xCandidate = y & ~(1 << bit)
                    if (xCandidate | (xCandidate + 1)) == y:
                        minX = min(minX, xCandidate)
            return minX if minX != float('inf') else -1

        return [findMinX(num) for num in nums]
",1420006443
Andrew,XAXAEBATb,72,3487,cpp,"class Solution {
public:
int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int a = source.size();
    int b = pattern.size();
        vector <int> cc(a+1);
        for (auto& i:targetIndices) {
            cc[i] = 1;
        }
        vector <int> can(a+1, -100);
        can[0] = 0;
        for (int i=0;i<a;i++) {
            for (int j=i;j>=0;j--) {
                if (can[j]>=0 && cc[i] == 1) {
                    can[j+1] = max(can[j+1], can[j]);
                }
                if (can[j]<b && can[j]>=0 && source[i] == pattern[can[j]]) {
                    can[j] = can[j] + 1;
                }
            }
        }
    int ans = -1;
    for (int i=0;i<a;i++) {
        // cout<<can[i]<<"" "";
        if (can[i]>=b) {ans=i;}
    }
    return ans;
    }
};",1420059983
Andrew,XAXAEBATb,72,3604,cpp,"class Solution {
public:
    long long powmod(long long a,long long b,long long mod) {
    if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }

    if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }
    else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }
}
    
    int numberOfWays(int n, int x, int y) {
        long long mod = 1000000007;
        vector<long long> cur(n+1);
        cur[0] = 1;
        for (long long i=1;i<=n;++i) {
            vector<long long> next(i+1);
            for (long long k=1;k<=i;++k) {
                next[k]=(cur[k-1]+k*cur[k])%mod;
            }
            for (long long j=0;j<=i;j++) {
                cur[j]=next[j];
            }
        }
        
        int max_k=min(n,x);
        long long ans=0;
        long long l=1;
        for (long long k=1;k<=max_k;++k) {
            if (k > 1) {
                l = (l*(x-k+1))%mod;
            } else {
                l=x%mod;
            }
            ans+=(((cur[k]*l)%mod)*powmod(y,k,mod))%mod;
            ans%=mod;
        }
        return ans;


    }
};",1420059809
Andrew,XAXAEBATb,72,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto& n:nums) {
            long long min_x = -1;
            for (int i=0;i<31;i++) {
                long long x = n - (1 << i);
                if (x >= 0) {
                    if ((x | (x + 1)) == n) {
                        if (min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                } else {
                    break;
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};",1420059536
Andrew,XAXAEBATb,72,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto& n:nums) {
            long long min_x = -1;
            for (int i=0;i<31;i++) {
                long long x = n - (1 << i);
                if (x >= 0) {
                    if ((x | (x + 1)) == n) {
                        if (min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                } else {
                    break;
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};",1420059285
Vasanth Reddy,vassu118,73,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& b) {
        int n = source.size(), m = pattern.size();
        vector<bool> mark(n, false);
        for(int i : b) mark[i] = true;
        vector<vector<int>> dp(n + 1, vector<int> (m + 1, -1e9));
        dp[0][0] = 0;
        for(int i = 1; i <= n; i++) {
            dp[i][0] = dp[i - 1][0] + (mark[i - 1]);
        }
        for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) {
            dp[i][j] = dp[i - 1][j];
            if(mark[i - 1]) dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j]);
            if(source[i - 1] == pattern[j - 1]) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
        }
        return dp[n][m];
    }
};",1420010230
Vasanth Reddy,vassu118,73,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int xx, int yy) {
        int mod = 1e9 + 7;
        auto power = [&](int x, int y) -> int {
            int ans = 1;
            for(; y; y >>= 1, x = 1LL * x * x % mod) if(y & 1) ans = 1LL * ans * x % mod;
            return ans;
        };
        vector<int> fact(xx + 1, 1), ifact(xx + 1, 1);
        for(int i = 1; i <= xx; i++) {
            fact[i] = 1LL * fact[i - 1] * i % mod;
        }
        ifact[xx] = power(fact[xx], mod - 2);
        for(int i = xx - 1; i >= 0; i--) ifact[i] = 1LL * ifact[i + 1] * (i + 1) % mod;
        
        auto ncr = [&](int x, int y) -> int {
            if(y < 0 || x < y || x < 0) return 0;
            int ans = 1LL * fact[x] * ifact[y] % mod * ifact[x - y] % mod;
            return ans;
        };
        
        vector<vector<int>> dp(n + 1, vector<int> (xx + 1));
        dp[0][0] = 1;
        for(int i = 1; i <= n; i++) for(int j = 1; j <= xx; j++) {
            dp[i][j] = (dp[i][j] + 1LL * dp[i - 1][j] * j % mod) % mod;
            dp[i][j] = (dp[i][j] + 1LL * (xx - j + 1) * dp[i - 1][j - 1] % mod) % mod;
        }
        
        // dp[i - 1][j] 
        
        vector<int> a(xx + 1, 0), ways(xx + 1, 0);
        
        for(int i = 1; i <= xx; i++) {
            int rem = n - i;
            a[i] = dp[n][i] % mod;
            
            // cout << a[i] << ' ';
        }
        // cout << '\n';
        
        int ans = 0;
        for(int i = 1; i <= xx; i++) {
            ans = (ans + 1LL * a[i] * power(yy, i) % mod) % mod;
        }
        return ans;
    }
};",1420059994
Vasanth Reddy,vassu118,73,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i : nums) {
            int done = 0;
            int mx = 2e9;
            for(int j = 29; j >= 0; j--) {
                int now = done;
                now += (1 << j) - 1;
                if((now | (now + 1)) == i) mx = min(mx, now);
                if(i >> j & 1) done += (1 << j);
            }
            if(mx == 2e9) mx = -1;
            ans.push_back(mx);
        }
        return ans;
    }
};",1419998362
Vasanth Reddy,vassu118,73,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i : nums) {
            int done = 0;
            int mx = 2e9;
            for(int j = 29; j >= 0; j--) {
                int now = done;
                now += (1 << j) - 1;
                if((now | (now + 1)) == i) mx = min(mx, now);
                if(i >> j & 1) done += (1 << j);
            }
            if(mx == 2e9) mx = -1;
            ans.push_back(mx);
        }
        return ans;
    }
};",1419998059
hxu10,hxu10,74,3487,python,"class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        """"""
        :type source: str
        :type pattern: str
        :type targetIndices: List[int]
        :rtype: int
        """"""
        m = len(pattern)
        inf = 10**9
        dp = [inf]*(m+1)
        
        sets = set(targetIndices)
        
        
        dp[0] = 0
        
        for i,c in enumerate(source):
            predp = dp[:]
            if i not in sets:
                for j in range(m+1):
                    dp[j] += 1
                    
            
                    
            
            for j in range(m,0,-1):
                if c==pattern[j-1]:
                    dp[j] = min(dp[j], predp[j-1] + 1)
                        
            #print(dp)
        
        return len(source) - dp[m]
    
            
            
                        
                    
                    
        ",1420039149
hxu10,hxu10,74,3604,python,"M = 10**9 + 7

class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        dp = [0]*(x+1)
        
        dp[0] = 1
        
        
        
        
        
        for _ in range(n):
            predp = dp[:]
            for i in range(x+1):
                dp[i] = predp[i] * i 
                if i > 0:
                    dp[i] += predp[i-1] * (x-i+1) * y
                    dp[i] %= M
                    
           # print(dp)
                    
            
        ans = sum(dp)%M
        return ans
        
                    
                
                    
                    
                
            
            ",1420060854
hxu10,hxu10,74,3605,python,"dic = {}

for i in range(3000,-1,-1):
    dic[i|(i+1)] = i
    
    
    

class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        for num in nums:
            if num not in dic:  
                ans.append(-1)
            else:
                ans.append(dic[num])
        return ans
    
            ",1419994383
hxu10,hxu10,74,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        
        
        
        def getnext(num):
            
            if num//2 % 2 == 0:
                return num // 2 * 2
            
            return getnext(num//2) * 2 + 1

    
            
            
        
        for num in nums:
            if num == 2:  
                ans.append(-1)
                continue 
                
                
            ans.append(getnext(num))
            
            
        return ans",1420014191
Yucheng Dai,Rainingcity,75,3487,cpp,"class Solution {
private:
    void update(int& x, int y) {
        if (x == -1) x = y;
        else x = max(x, y);
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        bool rem = false;
        dp[0][0] = 0;
        for(int i = 1, k = 0; i <= n; i++) {
            if (k < targetIndices.size() && targetIndices[k] == i - 1) {
                k++;
                rem = true;
            } else {
                rem = false;
            }
            dp[i][0] = k;
            for(int j = 1; j <= m; j++) {
                if (dp[i - 1][j] != -1) update(dp[i][j], dp[i - 1][j] + (int)rem);
                if (source[i - 1] == pattern[j - 1] && dp[i - 1][j - 1] != -1) update(dp[i][j], dp[i - 1][j - 1]);
            }
        }
        return dp[n][m];
    }
};",1420016972
Yucheng Dai,Rainingcity,75,3604,cpp,"typedef long long ll;
const ll MOD = 1000000007ll;

ll fpow(ll x, int a) {
    if (a == 0) return 1;
    if (a == 1) return x;
    ll res = fpow(x, a >> 1);
    res = (res * res) % MOD;
    if (a & 1) return (res * x) % MOD;
    else return res;
}

class Solution {
private:
    void buildC(vector<vector<ll>>& C, int n) {
        C[0][0] = C[1][0] = C[1][1] = 1;
        for(int i = 2; i <= n; i++) {
            C[i][0] = C[i][i] = 1;
            for(int j = 1; j < i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(1001, vector<ll>(1001, 0));
        buildC(C, x);
        int ans = 0;
        vector<ll> cnt(x + 1, 0);
        ll ypow = 1;
        for(int i = 1; i <= x; i++) {
            cnt[i] = fpow(i, n);
            for(int j = 1; j < i; j++) {
                cnt[i] -= (cnt[j] * C[i][j]) % MOD;
                cnt[i] = (cnt[i] + MOD) % MOD;
            }
            // cout << cnt[i] << endl;
            ypow = (ypow * y) % MOD;
            ll res = (cnt[i] * ypow) % MOD;
            res = (res * C[x][i]) % MOD;
            ans = (ans + res) % MOD;
        }
        return ans % MOD;
    }
};",1420061585
Yucheng Dai,Rainingcity,75,3605,cpp,"int lsb(int x) {
    return x & (-x);
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans{};
        for(int x: nums) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            int y = lsb(x + 1);
            int common = x - y + 1;
            ans.push_back(common + (y >> 1) - 1);
        }
        return ans;
    }
};",1419997514
Yucheng Dai,Rainingcity,75,3611,cpp,"int lsb(int x) {
    return x & (-x);
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans{};
        for(int x: nums) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            int y = lsb(x + 1);
            int common = x - y + 1;
            ans.push_back(common + (y >> 1) - 1);
        }
        return ans;
    }
};",1419997216
therealpratyushraman,therealpratyushraman,77,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
    int n = source.length(), m = pattern.length();
    Set<Integer> targetSet = new HashSet<>();
    for (int idx : targetIndices) targetSet.add(idx);
    int[] dp = new int[m + 1];
    Arrays.fill(dp, Integer.MAX_VALUE / 2);
    dp[0] = 0;
    for (int i = 0; i < n; i++) {
    for (int j = Math.min(i + 1, m); j >= 1; j--) {
    if (source.charAt(i) == pattern.charAt(j - 1)) {
    int cost = targetSet.contains(i) ? 1 : 0;
    dp[j] = Math.min(dp[j], dp[j - 1] + cost);
    }
    }
    }
    if (dp[m] >= Integer.MAX_VALUE / 2) return 0;
    return targetIndices.length - dp[m];
    }
    }
",1420055010
therealpratyushraman,therealpratyushraman,77,3604,java,"class Solution {
    static final int MOD = (int)1e9 + 7;
    public int numberOfWays(int n, int x, int y) {
    int maxN = 1000;
    long[] factorial = new long[maxN + 1];
    long[] invFactorial = new long[maxN + 1];
    factorial[0] = invFactorial[0] = 1;
    for (int i = 1; i <= maxN; i++) {
    factorial[i] = factorial[i - 1] * i % MOD;
    }
    invFactorial[maxN] = modInverse(factorial[maxN]);
    for (int i = maxN - 1; i >= 1; i--) {
    invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
    }
    long[][] stirling = new long[n + 1][n + 1];
    stirling[0][0] = 1;
    for (int i = 1; i <= n; i++) {
    stirling[i][0] = 0;
    for (int j = 1; j <= i; j++) {
    stirling[i][j] = (stirling[i - 1][j - 1] + stirling[i - 1][j] * j) % MOD;
    }
    }
    long[] powY = new long[x + 1];
    powY[0] = 1;
    for (int i = 1; i <= x; i++) {
    powY[i] = powY[i - 1] * y % MOD;
    }
    long result = 0;
    for (int k = 1; k <= Math.min(n, x); k++) {
    long ways = combination(x, k, factorial, invFactorial) * factorial[k] % MOD;
    ways = ways * stirling[n][k] % MOD;
    ways = ways * powY[k] % MOD;
    result = (result + ways) % MOD;
    }
    return (int)result;
    }
    long modInverse(long x) {
    return powMod(x, MOD - 2);
    }
    long powMod(long x, long n) {
    long result = 1;
    x %= MOD;
    while (n > 0) {
    if ((n & 1) == 1) result = result * x % MOD;
    x = x * x % MOD;
    n >>= 1;
    }
    return result;
    }
    long combination(int n, int k, long[] fact, long[] invFact) {
    if (k < 0 || k > n) return 0;
    return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;
    }
}",1419996447
therealpratyushraman,therealpratyushraman,77,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for (int i = 0; i < n; i++) {
    int S = nums.get(i), minX = -1;
    for (int x = 0; x <= S; x++) {
    if ((x | (x + 1)) == S) {
    minX = x;
    break;
    }
    }
    ans[i] = minX;
    }
    return ans;
    }
} ",1420025769
therealpratyushraman,therealpratyushraman,77,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for (int i = 0; i < n; i++) {
        int S = nums.get(i), minX = -1;
        for (int k = 0; k <= 30; k++) {
            int x = S - (1 << k);
            if (x >= 0 && (x | (x + 1)) == S) {
                if (minX == -1 || x < minX) minX = x;
                }
            }
        ans[i] = minX;
    }
    return ans;
    }
}",1420019918
NO_ONE,Timid_Tom,79,3487,cpp,"class Solution {
public:
    int solve(int i, int j, string &src, string &pattern, vector<int> &hsh, vector<vector<int>> &dp) {
        int n = src.size();
        int m = pattern.size();
        
        if (i == n) return (j == m) ? 0 : -1e5;
        
        if (dp[i][j] != -1) return dp[i][j];
        
        int ans = solve(i + 1, j, src, pattern, hsh, dp);
        
        if (hsh[i]) ans = max(ans, 1 + solve(i + 1, j, src, pattern, hsh, dp));
        
        if (j < m && src[i] == pattern[j]) ans = max(ans, solve(i + 1, j + 1, src, pattern, hsh, dp));
        
        return dp[i][j] = ans;
    }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        vector<int> hsh(n + 1, 0);
        for (auto it : targetIndices) hsh[it] = 1;
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
        return solve(0, 0, source, pattern, hsh, dp);
    }
};
",1420063765
NO_ONE,Timid_Tom,79,3604,cpp,"#include <vector>
using namespace std;

const int MOD = 1e9 + 7;
#define ll long long

class Solution {
public:
    
    ll mod_add(ll a, ll b, ll m) {return (a % m + b % m + m) % m;}
    ll mod_mul(ll a, ll b, ll m) {return (a % m * b % m + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b) {if (b & 1) res = mod_mul(res, a, m); a = mod_mul(a, a, m); b >>= 1;} return res;}
    ll comb(ll n, ll r, ll m, ll *fact, ll *ifact) {return mod_mul(mod_mul(fact[n], ifact[n - r], m), ifact[r], m);}
    
    int numberOfWays(int n, int x, int y) {
          vector<vector<ll>> sum(n + 1, vector<ll>(x + 1, 0));
        sum[0][0] = 1;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= x; ++j)
                sum[i][j] = mod_add(mod_mul(j, sum[i - 1][j], MOD), sum[i - 1][j - 1], MOD);
        
        vector<vector<ll>> dp(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; ++j)
                dp[i][j] = mod_add(dp[i - 1][j - 1], dp[i - 1][j], MOD);
        }

      

        vector<ll> fact(x + 1, 1), ifact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = mod_mul(fact[i - 1], i, MOD);
            ifact[i] = expo(fact[i], MOD - 2, MOD); 
        }

        ll res = 0;
        for (int k = 1; k <= x; ++k) {
            ll power = expo(y, k, MOD);
            res = mod_add(res, mod_mul(mod_mul(dp[x][k], sum[n][k], MOD), mod_mul(fact[k], power, MOD), MOD), MOD);
        }

        return res;
    }
};
",1420057170
NO_ONE,Timid_Tom,79,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
            int n = nums.size();
            vector<int>ans;
            for(auto it:nums){
                int a = it;
                if(a%2 == 0){
                    ans.push_back(-1);
                }
                else{
                    int ct = it-1;
                    int cnt = 1;
                    while(cnt*2<=it){
                        int val = it - 2*cnt;
                        
                        
                        if((val | (val+1)) == it){
                            ct = min(ct , val);
                        }
                        cnt *=2;
                    }
                    ans.push_back(ct);
                    
                }
            }
            return ans;
    }
};",1420021515
NO_ONE,Timid_Tom,79,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
            int n = nums.size();
            vector<int>ans;
            for(auto it:nums){
                int a = it;
                if(a%2 == 0){
                    ans.push_back(-1);
                }
                else{
                    int ct = it-1;
                    int cnt = 1;
                    while(cnt*2<=it){
                        int val = it - 2*cnt;
                        
                        
                        if((val | (val+1)) == it){
                            ct = min(ct , val);
                        }
                        cnt *=2;
                    }
                    ans.push_back(ct);
                    
                }
            }
            return ans;
    }
};",1420020918
moradiya84,moradiya84,80,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& z) {
        int n=s.size();
        vector<int>vis(n);
        for(int i=0;i<z.size();i++){
            vis[z[i]]=1;
        }
        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));
        int m=t.size();
        function<int(int,int)>ff=[&](int i,int j){
            if(i==n && j==m) return 0;
            if(dp[i][j]!=-1) return dp[i][j];
            if(i==n) return (int)-1e5;
            if(j==m) return dp[i][j]=vis[i]+ff(i+1,j);
            int ans=-1e5;
            ans=max(ans,vis[i]+ff(i+1,j));
            if(s[i]==t[j]) ans=max(ans,ff(i+1,j+1));
            return dp[i][j]=ans;
        };
        int ans=ff(0,0);
        if(ans<0) ans=0;
        return ans;
    }
};",1420026180
moradiya84,moradiya84,80,3604,cpp,"int mod=1e9+7;
// int p=99996821;
#define pb push_back
#define umii unordered_map<int,int>
#define umci unordered_map<char,int>
#define umcc unordered_map<char,char>
#define mii map<int,int>
#define mci map<char,int>
#define mcc map<char,char>
#define vi vector<int>
#define vvi vector<vector<int>>
#define vvpii vector<vector<pii>>
#define f(i,n) for(int i=0;i<n;i++)
#define f1(i,n) for(int i=1;i<=n;i++)
#define pii pair<int,int>
#define piii pair<int,pair<int,int>>
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
#define ff first
#define ss second
#define lb lower_bound
#define ub upper_bound
#define endl ""\n""
using ll=long long;
ll power(ll x,ll y){
    ll value = 0;
    if(y<0) return (int)0;
    else if(y==0) return (int)1;
    else if(y==1) return x;
    else if(y%2) value = (x*(power((x*x)%mod,y/2)%mod))%mod;
    else value = power((x*x)%mod,y/2)%mod;
    return value%mod;
}

ll inversemod(ll x) {
    return power(x,mod-2)%mod;
}
vector<ll> fact,ifact;

void FACT(int n){
    fact.resize(n+1);
    fact[0]=1;
    f1(i,n){
        fact[i]=fact[i-1]*i;
        fact[i]%=mod;
    }
}

void IFACT(int n){
    ifact.resize(n+1);
    ifact[n]=inversemod(fact[n]);
    for(int i=n-1;i>=0;i--){
        ifact[i]=(ifact[i+1]*(i+1))%mod;
    }
}

int NCR(int n,int r){
    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod;
}
class Solution {
public:
    // #include <bits/stdc++.h>
// using namespace std;
// #define int long long
    int numberOfWays(int n, int x, int y) {
        FACT(2001);
        IFACT(2001);
        vector<ll> z(2001);
        z[0]=1;
        for(int i=1;i<=2000;i++){
            z[i]=z[i-1]*y;
            z[i]%=mod;
        }
        ll ans=0;   
        vector<vector<ll>>dp(n+1,vector<ll>(x+1));
        dp[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x;j++){
                dp[i][j]=dp[i-1][j-1]+j*dp[i-1][j];
                dp[i][j]%=mod;
            }
        }
        
        for(int tot=1;tot<=x;tot++){
            if(tot>n) break;
            ll tans=dp[n][tot];
            tans*=fact[tot];
            tans%=mod;
            tans*=NCR(x,tot);
            tans%=mod;
            tans*=z[tot];
            tans%=mod;
            ans+=tans;
            ans%=mod;
        }
        return ans;
    }
};",1420064132
moradiya84,moradiya84,80,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if(v[i]%2){
                ans[i]=-1;
                for(int j=0;j<v[i];j++){
                    if((j|(j+1))==v[i]){
                        ans[i]=j;
                        break;
                    }
                }
            }
            else ans[i]=-1;
        }
        return ans;
    }
};",1419995904
moradiya84,moradiya84,80,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if((v[i]%2) == 0){
                ans[i]=-1;
            }
            else{
                ans[i]=v[i]-1;
                int num=v[i];
                vector<int>a(32);
                for(int j=0;j<32;j++){
                    a[j]=num%2;
                    num/=2;
                }
                int k=-1;
                for(int j=0;j<32;j++){
                    if(a[j]==0) break;
                    k=j;
                }
                if(k>0){
                    ans[i]=v[i]-pow(2,k);
                }
            }
        }
        return ans;
    }
};",1420006328
Ferrriccc,Ferrriccc,83,3487,cpp,"class Solution {
  public:
    int maxRemovals(string source, string pattern, vector<int> &targetIndices) {
        const int inf = 1e9;

        int n = source.size();
        source = '/' + source;
        pattern = '/' + pattern;
        int m = pattern.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));
        vector<int> bad(n + 1);
        for (int i : targetIndices) {
            bad[i + 1] = 1;
        }
        for (int i = 0; i <= n; ++i) {
            dp[i][0] = 0;
        }
        int mn = inf;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = min(dp[i - 1][j], dp[i][j]);
                if (source[i] != pattern[j]) {
                    continue;
                }
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + bad[i]);
            }
            mn = min(mn, dp[i][m - 1]);
        }
        return max(0, (int)targetIndices.size() - mn);
    }
};
",1420052130
Ferrriccc,Ferrriccc,83,3604,cpp,"class Solution {
    template <const int T> struct ModInt {
        const static int mod = T;
        int x;
        int val() { return x; }
        ModInt(int x = 0) : x(x % mod) {}
        ModInt(long long x) : x(int(x % mod)) {}
        ModInt operator+(const ModInt &a) const {
            int x0 = x + a.x;
            return ModInt(x0 < mod ? x0 : x0 - mod);
        }
        ModInt operator-(const ModInt &a) const {
            int x0 = x - a.x;
            return ModInt(x0 < 0 ? x0 + mod : x0);
        }
        ModInt operator*(const ModInt &a) const {
            return ModInt(1ll * x * a.x % mod);
        }
        ModInt operator/(const ModInt &a) const { return *this * a.inv(); }
        void operator+=(const ModInt &a) {
            x += a.x;
            if (x >= mod)
                x -= mod;
        }
        void operator-=(const ModInt &a) {
            x -= a.x;
            if (x < 0)
                x += mod;
        }
        void operator*=(const ModInt &a) { x = 1LL * x * a.x % mod; }
        void operator/=(const ModInt &a) { *this = *this / a; }
        ModInt pow(int64_t n) const {
            ModInt res(1), mul(x);
            while (n) {
                if (n & 1)
                    res *= mul;
                mul *= mul;
                n >>= 1;
            }
            return res;
        }
        ModInt inv() const {
            int a = x, b = mod, u = 1, v = 0;
            while (b) {
                int t = a / b;
                a -= t * b;
                swap(a, b);
                u -= t * v;
                swap(u, v);
            }
            if (u < 0)
                u += mod;
            return u;
        }
    };

    using mint = ModInt<(int)1e9 + 7>;

  public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<mint>> dp(n + 1, vector<mint>(x + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int b = 1; b <= x; ++b) {
                dp[i][b] +=
                    (dp[i - 1][b] * b + dp[i - 1][b - 1] * (x - (b - 1)));
            }
        }
        mint ans = 0;
        for (int b = 1; b <= x; ++b) {
            ans += dp[n][b] * mint(y).pow(b);
        }
        return ans.x;
    }
};
",1420031036
Ferrriccc,Ferrriccc,83,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
                continue;
            }
            int here = i;
            int base = 1;
            i >>= 1;
            while (i & 1) {
                i >>= 1;
                base *= 2;
            }
            ans.push_back(here - base);
        }
        return ans;
    }
};",1420065402
Ferrriccc,Ferrriccc,83,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
                continue;
            }
            int here = i;
            int base = 1;
            i >>= 1;
            while (i & 1) {
                i >>= 1;
                base *= 2;
            }
            ans.push_back(here - base);
        }
        return ans;
    }
};",1420064920
Min,IAFB358kMw,84,3487,java,"import java.util.HashSet;
import java.util.Set;

public class Solution {
    
    private Set<Integer> help(int[] t) {
        Set<Integer> ts = new HashSet<>();
        int idx = 0;
        while (idx < t.length) {
            ts.add(t[idx]);
            idx++;
        }
        return ts;
    }

    private void help2(int N, int[] prev, int[] curr) {
        int init = 0;
        while (init <= N) {
            prev[init] = Integer.MAX_VALUE;
            curr[init] = Integer.MAX_VALUE;
            init++;
        }
    }

    private void help3(int[] prev) {
        int set = 0;
        while (set < 1) {
            prev[0] = 0;
            set++;
        }
    }

    private void help4(int M, int N, String source, String p, Set<Integer> t, int[] prev, int[] curr, int i) {
        int current = i;
        while (current < M) {
            help8(curr, N);
            help7(N, source, p, t, prev, curr, current);
            help6(N, prev, curr);
            current++;
        }
    }

    private void help8(int[] curr, int N) {
        int res = 0;
        while (res <= N) {
            curr[res] = Integer.MAX_VALUE;
            res++;
        }
    }

    private void help7(int N, String source, String pattern, Set<Integer> targetSet, int[] prev, int[] curr, int i) {
        int j = 0;
        while (j <= N) {
            boolean condition = (prev[j] == Integer.MAX_VALUE);
            while (condition) {
                j++;
                if (j > N) {
                    break;
                }
                condition = (prev[j] == Integer.MAX_VALUE);
            }
            if (j > N) {
                break;
            }
            boolean minCondition = (curr[j] > prev[j]);
            while (minCondition) {
                curr[j] = prev[j];
                break;
            }
            boolean matchCondition = (j < N && source.charAt(i) == pattern.charAt(j));
            while (matchCondition) {
                int cost = prev[j];
                boolean contains = targetSet.contains(i);
                while (contains) {
                    cost += 1;
                    break;
                }
                boolean minCondition2 = (curr[j + 1] > cost);
                while (minCondition2) {
                    curr[j + 1] = cost;
                    break;
                }
                break;
            }
            j++;
        }
    }

    private void help6(int N, int[] prev, int[] curr) {
        int copyIdx = 0;
        while (copyIdx <= N) {
            prev[copyIdx] = curr[copyIdx];
            copyIdx++;
        }
    }

    private int help5(int N, int[] targetIndices, int[] prev) {
        int returnValue = 0;
        boolean finalCondition = (prev[N] == Integer.MAX_VALUE);
        while (finalCondition) {
            returnValue = 0;
            break;
        }
        boolean elseCondition = (prev[N] != Integer.MAX_VALUE);
        while (elseCondition) {
            int minKeep = prev[N];
            returnValue = targetIndices.length - minKeep;
            break;
        }
        return returnValue;
    }
    
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int M = source.length();
        int N = pattern.length();
        Set<Integer> targetSet = help(targetIndices);
        int[] prev = new int[N + 1];
        int[] curr = new int[N + 1];
        help2(N, prev, curr);
        help3(prev);
        int i = 0;
        help4(M, N, source, pattern, targetSet, prev, curr, i);
        return help5(N, targetIndices, prev);
    }

}
",1420043689
Min,IAFB358kMw,84,3604,java,"public class Solution {
    
    private void help2(int N) {
        f = new long[N + 1];
        ifac = new long[N + 1];
        f[0] = 1L;
        int i = 1;
        while (i <= N) {
            f[i] = (f[i - 1] * i) % M;
            i++;
        }
    }

    private void help3(int N) {
        ifac[N] = help(f[N], M - 2, M);
        int i = N - 1;
        while (i >= 0) {
            ifac[i] = (ifac[i + 1] * (i + 1)) % M;
            i--;
        }
    }

    private void help4(int n) {
        s = new long[n + 1][n + 1];
        s[0][0] = 1L;
        int i = 1;
        while (i <= n) {
            s[i][0] = 0L;
            help5(i);
            i++;
        }
    }
    
    private static final long M = 1000000007L;
    private long[] f;
    private long[] ifac;
    private long[][] s;

    private void help5(int i) {
        int j = 1;
        while (j <= i) {
            s[i][j] = ((j * s[i - 1][j]) % M + s[i - 1][j - 1]) % M;
            j++;
        }
    }

    private long help6(int x, int maxK, int n, int y) {
        long tw = 0L;
        int k = 1;
        while (k <= maxK) {
            long c = nCr(x, k);
            long p = f[k];
            long st = s[n][k];
            long py = help(y, k, M);
            long twk = (((c * p) % M) * st % M * py) % M;
            tw = (tw + twk) % M;
            k++;
        }
        return tw;
    }

    private long nCr(int n, int r) {
        return (r < 0 || r > n) ? 0L : (f[n] * ifac[r] % M) * ifac[n - r] % M;
    }

    public int numberOfWays(int n, int x, int y) {
        return (n == 0) ? 1 :
               ((x == 0) ? 0 :
               computeWays(n, x, y));
    }

    private int computeWays(int n, int x, int y) {
        int N = Math.max(n, x) + 5;
        help2(N);
        help3(N);
        help4(n);
        long tw = help6(x, Math.min(n, x), n, y);
        return (int) tw;
    }

    private long help(long a, long b, long m) {
        long r = 1L;
        a %= m;
        while (b > 0) {
            r = ((b & 1L) == 1L) ? (r * a) % m : r;
            a = (a * a) % m;
            b >>= 1L;
        }
        return r;
    }


    
}
",1420065421
Min,IAFB358kMw,84,3605,java,"import java.util.List;

class Solution {

    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            ans[i] = help(nums.get(i));
        }

        return ans;
    }

    private int help(int num) {
        int c = 0;

        while (c <= num && ((c | (c + 1)) != num)) {
            c++;
        }

        return (c <= num) ? c : -1;
    }
}
",1420008271
Min,IAFB358kMw,84,3611,java,"class Solution {
    
    private void help(List<Integer> nums, int[] ans, int n) {
        int i = 0;
        while (i < n) {
            ans[i] = help2(nums.get(i));
            i++;
        }
    }
    
    private int help2(int num) {
        int ans = Integer.MAX_VALUE;
        int k = 0;
        
        while (k <= 30) {
            int c = num & ~(1 << k);
            ans = (c >= 0 && (c | (c + 1)) == num && c < ans)
                     ? c 
                     : ans;
            k++;
        }
        
        return (ans == Integer.MAX_VALUE) ? -1 : ans;
    }
    
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        help(nums, ans, n);
        
        return ans;
    }
    
    
}
",1420021860
Gaurav Chaudhary,Technical_Guruji,87,3487,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
#define MOD             998244353
#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;





template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it




class Solution {

public:

    int maxRemovals(std::string inputString, std::string searchPattern, std::vector<int>& indexList) {

        int strLength = inputString.size();

        int patLength = searchPattern.size();

        std::vector<int> removalCounts(patLength + 1, std::numeric_limits<int>::max());

        removalCounts[0] = 0;
        std::vector<bool> isTarget(strLength, false);

        
        
        markTargetIndices(indexList, isTarget);
        
        fillRemovalCounts(inputString, searchPattern, removalCounts, strLength, patLength, isTarget);

        
        
        return calculateMaxRemovals(removalCounts, indexList.size());
    }
    


private:

    void markTargetIndices(const std::vector<int>& indices, std::vector<bool>& targetMarker) {

        int currentIndex = 0;

        while (currentIndex < indices.size()) {

            targetMarker[indices[currentIndex]] = true;

            currentIndex++;

        }

    }


    void fillRemovalCounts(const std::string& inputString, const std::string& searchPattern, std::vector<int>& removalCounts, int strLength, int patLength, const std::vector<bool>& targetMarker) {

        int i = 0;

        while (i < strLength) {

            int j = patLength;

            while (j > 0) {

                if (inputString[i] == searchPattern[j - 1] && removalCounts[j - 1] != std::numeric_limits<int>::max()) {

                    removalCounts[j] = std::min(removalCounts[j], removalCounts[j - 1] + (targetMarker[i] ? 1 : 0));

                }

                j--;

            }

            i++;

        }

    }


    int calculateMaxRemovals(const std::vector<int>& removalCounts, int targetCount) {

        if (removalCounts[removalCounts.size() - 1] == std::numeric_limits<int>::max()) {

            return targetCount;

        }

        return targetCount - removalCounts[removalCounts.size() - 1];

    }

};










#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420065728
Gaurav Chaudhary,Technical_Guruji,87,3604,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
//#define MOD             998244353
//#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;
const int MOD = 1e9 + 7;




template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it




class Solution {

public:

    int numberOfWays(int totalItems, int groupSize, int multiplier) {

        

        int maxValue = max(totalItems, groupSize) + 1;

        int groupLimit = groupSize;

        
        
        vector<long long> factorialArray(maxValue), invFactorialArray(maxValue);
        
        factorialArray[0] = invFactorialArray[0] = 1;

        
        
        int index = 1;
        
        while (index < maxValue) {
        
            factorialArray[index] = (factorialArray[index - 1] * index) % MOD;
            ++index;
        
        }

        
        
        invFactorialArray[maxValue - 1] = modInverse(factorialArray[maxValue - 1], MOD);
        
        index = maxValue - 2;
        
        while (index >= 1) {
        
            invFactorialArray[index] = (invFactorialArray[index + 1] * (index + 1)) % MOD;
        
            --index;
        
        }

        
        
        vector<vector<long long>> stirlingNumbers(totalItems + 1, vector<long long>(totalItems + 1, 0));
        
        stirlingNumbers[0][0] = 1;

        
        
        index = 1;
        
        
        while (index <= totalItems) {
            stirlingNumbers[index][0] = 0;
        
            int subgroup = 1;
        
            while (subgroup <= index) {
        
                stirlingNumbers[index][subgroup] = (stirlingNumbers[index - 1][subgroup - 1] + (subgroup * stirlingNumbers[index - 1][subgroup]) % MOD) % MOD;
        
                ++subgroup;
        
            }
        
            ++index;
        
        }

        
        
        long long totalWays = 0;
        
        for (int currentGroup = 1; currentGroup <= min(totalItems, groupLimit); ++currentGroup) {
        
            long long combinations = computeCombination(groupLimit, currentGroup, factorialArray, invFactorialArray, MOD);
        
            long long permutations = factorialArray[currentGroup];
        
            long long stirlingValue = stirlingNumbers[totalItems][currentGroup];
        
            long long scoreMultiplier = modPow(multiplier, currentGroup, MOD);

            
            
            long long ways = (((combinations * permutations) % MOD) * stirlingValue) % MOD;
            
            ways = (ways * scoreMultiplier) % MOD;
            
            totalWays = (totalWays + ways) % MOD;
        }
        
        
        return totalWays;
    }
    

    
private:
    
    long long modPow(long long base, long long exponent, long long mod) {
    
        long long result = 1;
    
        base %= mod;
    
        while (exponent > 0) {
    
            if (exponent & 1)
    
                result = (result * base) % mod;
    
            base = (base * base) % mod;
    
            exponent >>= 1;
    
        }
    
        return result;
    
    }

    
    
    long long modInverse(long long a, long long mod) {
    
        return modPow(a, mod - 2, mod);
    
    }

    
    long long computeCombination(int n, int k, const vector<long long>& factorialArray, const vector<long long>& invFactorialArray, long long mod) {
    
        if (k < 0 || k > n) return 0;
    
        return (((factorialArray[n] * invFactorialArray[k]) % mod) * invFactorialArray[n - k]) % mod;
    
    }
};















#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420065429
Gaurav Chaudhary,Technical_Guruji,87,3605,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
#define MOD             998244353
#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;





template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it



class Solution 

{ 

public: 

    vector<int> minBitwiseArray(vector<int> &arrInput) 

    { 

        vector<int> arrResult(arrInput.size(), -1); 
        processInputArray(arrInput, arrResult); 

        return arrResult; 

    } 

    
private:
    
    void processInputArray(const vector<int>& arrInput, vector<int>& arrResult) 
    
    { 
    
        int idx = 0;
    
        while (idx < arrInput.size()) 
    
        { 
    
            arrResult[idx] = computeMinBitwiseValue(arrInput[idx]); 
    
            ++idx; 
    
        } 
    
    } 

    
    int computeMinBitwiseValue(int valueCurrent) 
    
    { 
    
        int valueMin = -1; 
    
        int bitIndex = 0; 
    
        while (bitIndex <= 30) 
    
        { 
    
            if (valueCurrent & (1 << bitIndex)) 
    
            { 
    
                int valueNew = valueCurrent - (1 << bitIndex); 
    
                if (validateValue(valueNew, valueCurrent)) 
    
                { 
    
                    valueMin = updateMinValue(valueMin, valueNew); 
    
                } 
    
            } 
    
            ++bitIndex; 
    
        } 
    
        return valueMin; 
    
    } 

    
    
    bool validateValue(int valueNew, int valueOriginal) 
    { 
    
        return valueNew >= 0 && ((valueNew | (valueNew + 1)) == valueOriginal); 
    
    } 

    
    
    int updateMinValue(int valueCurrentMin, int valueNew) 
    
    { 
    
        return valueCurrentMin == -1 || valueNew < valueCurrentMin ? valueNew : valueCurrentMin; 
    
    } 
}; 








#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420066156
Gaurav Chaudhary,Technical_Guruji,87,3611,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
#define MOD             998244353
#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;





template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it



class Solution 

{ 

public: 

    vector<int> minBitwiseArray(vector<int> &arrInput) 

    { 

        vector<int> arrResult(arrInput.size(), -1); 
        processInputArray(arrInput, arrResult); 

        return arrResult; 

    } 

    
private:
    
    void processInputArray(const vector<int>& arrInput, vector<int>& arrResult) 
    
    { 
    
        int idx = 0;
    
        while (idx < arrInput.size()) 
    
        { 
    
            arrResult[idx] = computeMinBitwiseValue(arrInput[idx]); 
    
            ++idx; 
    
        } 
    
    } 

    
    int computeMinBitwiseValue(int valueCurrent) 
    
    { 
    
        int valueMin = -1; 
    
        int bitIndex = 0; 
    
        while (bitIndex <= 30) 
    
        { 
    
            if (valueCurrent & (1 << bitIndex)) 
    
            { 
    
                int valueNew = valueCurrent - (1 << bitIndex); 
    
                if (validateValue(valueNew, valueCurrent)) 
    
                { 
    
                    valueMin = updateMinValue(valueMin, valueNew); 
    
                } 
    
            } 
    
            ++bitIndex; 
    
        } 
    
        return valueMin; 
    
    } 

    
    
    bool validateValue(int valueNew, int valueOriginal) 
    { 
    
        return valueNew >= 0 && ((valueNew | (valueNew + 1)) == valueOriginal); 
    
    } 

    
    
    int updateMinValue(int valueCurrentMin, int valueNew) 
    
    { 
    
        return valueCurrentMin == -1 || valueNew < valueCurrentMin ? valueNew : valueCurrentMin; 
    
    } 
}; 








#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420065937
Maruzensky,Maruzensky,88,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        t = set(targetIndices)
        
        dp = [0]
        
        for i, c in enumerate(source):
            temp = []
            for idx in dp:
                if idx == m:
                    temp.append(m)
                elif c == pattern[idx]:
                    temp.append(idx + 1)
                else:
                    temp.append(idx)
            
            if i in t:
                temp.append(0)
                k = len(temp) - 2
                
                for j in range(k, -1, -1):
                    temp[j + 1] = max(temp[j + 1], dp[j])
                    
            dp = temp
        #     print(dp, t)
        # print('.')
            
        return max(i for i, v in enumerate(dp) if v == m)
                ",1420024118
Maruzensky,Maruzensky,88,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod = 10**9 + 7
        
        dp = [0, 1]
        
        for i in range(2, n + 1):
            temp = [0] * (i + 1)
            temp.append(0)
            for j in range(i - 1, 0, -1):
                temp[j + 1] += dp[j]
                temp[j] += dp[j] * j
                
            dp = [x % mod for x in temp]
            
        answer = 0
        p = y
        fact = x
        
        for dist in range(1, 1 + min(x, n)):
            answer = (answer + dp[dist] * fact * p) % mod
            fact = (fact * (x - dist)) % mod
            p = (p * y) % mod
            
        return answer",1420060336
Maruzensky,Maruzensky,88,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for x in nums:
            if x == 2:
                answer.append(-1)
                continue
                
            y = x + 1
            b = y & -y
            answer.append(x - (b >> 1))
            
        return answer",1419996972
Maruzensky,Maruzensky,88,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for x in nums:
            if x == 2:
                answer.append(-1)
                continue
                
            y = x + 1
            b = y & -y
            answer.append(x - (b >> 1))
            
        return answer",1419996479
Rahul Dev Sahoo,invictus__,89,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<bool> isTargetIndex(n, false);
        for (int idx : targetIndices) {
            isTargetIndex[idx] = true;
        }
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));
        for (int i = 0; i <= n; ++i)
            dp[i][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (dp[i - 1][j] != INT_MAX)
                    dp[i][j] = min(dp[i][j], dp[i - 1][j]);
                if (j > 0 && source[i - 1] == pattern[j - 1] && dp[i - 1][j - 1] != INT_MAX) {
                    int cost = isTargetIndex[i - 1] ? 1 : 0;
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + cost);
                }
            }
        }
        int minUsed = dp[n][m];
        int maxOperations = targetIndices.size() - minUsed;
        return maxOperations;
    }
};
",1420045377
Rahul Dev Sahoo,invictus__,89,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int M = 1e9+7;
        int mx = n + x + 5;
        vector<long long> f(mx), invf(mx);
        f[0] = invf[0] = 1;
        for (int i = 1; i < mx; ++i) {
            f[i] = f[i - 1] * i % M;
            invf[i] = modPow(f[i], M - 2, M);
        }

        vector<vector<long long>> S(n + 1, vector<long long>(n + 1));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % M;

        long long res = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            long long term = comb(x, k, f, invf, M);
            term = term * f[k] % M;
            term = term * S[n][k] % M;
            term = term * modPow(y, k, M) % M;
            res = (res + term) % M;
        }
        return res;
    }
private:
    long long modPow(long long a, long long b, int m) {
        long long r = 1;
        a %= m;
        while (b) {
            if (b & 1) r = r * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return r;
    }
    long long comb(int n, int k, vector<long long>& f, vector<long long>& invf, int m) {
        if (k < 0 || k > n) return 0;
        return f[n] * invf[k] % m * invf[n - k] % m;
    }
};
",1420069362
Rahul Dev Sahoo,invictus__,89,3605,cpp,"class Solution {
public:



    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; ++i) {
            int N = nums[i];
            for(int a = 0; a <= N; ++a) {
                if((a | (a + 1)) == N) {
                    ans[i] = a;
                    break;
                }
            }
        }
        return ans;
        }
};",1420019060
Rahul Dev Sahoo,invictus__,89,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; ++i) {
            int num = nums[i], res = -1;
            for(int k = 0; k <= 30; ++k) {
                int s = num - (1 << k);
                if(s >= 0) {
                    int t = s + 1;
                    if((s | t) == num) {
                        if(res == -1 || s < res)
                            res = s;
                    }
                }
            }
            ans[i] = res;
        }
        return ans;
    }
};
",1420060648
Meet Brahmbhatt,MeetBrahmbhatt,90,3487,cpp,"const int inf = 1e7;
class Solution {
public:
    int maxRemovals(string s, string pat, vector<int>& target) {
        int n = (int) s.size();
        int m = (int) pat.size();
        
        vector<int> rem(n);
        for (int i : target) {
            rem[i] = 1;
        }
        
        vector<int> dp(m + 1, inf);
        dp[0] = 0;
        
        for (int i = 0; i < n; i++) {
            auto ndp = dp;
            for (int j = 0; j < m; j++) {
                if (s[i] == pat[j] && dp[j] != inf) {
                    ndp[j + 1] = min(ndp[j + 1], dp[j] + rem[i]);
                }
            }
            dp = ndp;
        }
        
        return (int) target.size() - dp[m];
    }
};",1420010233
Meet Brahmbhatt,MeetBrahmbhatt,90,3604,cpp,"constexpr int32_t MOD = 1e9 + 7;
// constexpr int32_t MOD = 998244353;

struct Mint {
    int val;
    Mint(long long v = 0) {
        if (v < 0) {
            v = v % MOD + MOD;
        }
        if (v >= MOD) {
            v %= MOD;
        }
        val = v;
    }
    static int mod_inv(int a, int m = MOD) {
        int g = m, r = a, x = 0, y = 1;
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
        return x < 0 ? x + m : x;
    }
    explicit operator int() const {
        return val;
    }
    Mint& operator+=(const Mint &other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    Mint& operator-=(const Mint &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    typedef unsigned long long ull;
    ull fast_mod(ull a, ull b, ull M = MOD) {
        long long ret = a * b - M * ull(1.L / M * a * b);
        return ret + M * (ret < 0) - M * (ret >= (long long)M);
    }
    Mint& operator*=(const Mint &other) {
        val = fast_mod((ull) val, other.val);
        return *this;
    }
    Mint& operator/=(const Mint &other) {
        return *this *= other.inv();
    }
    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }
    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }
    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }
    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }
    Mint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
    Mint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }
    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }
    Mint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
    bool operator==(const Mint &other) const { return val == other.val; }
    bool operator!=(const Mint &other) const { return val != other.val; }
    Mint inv() const {
        return mod_inv(val);
    }
    Mint pow(long long p) const {
        assert(p >= 0);
        Mint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            a *= a;
            p >>= 1;
        }
        return result;
    }
    friend ostream& operator<<(ostream &stream, const Mint &m) {
        return stream << m.val;
    }
    friend istream& operator >> (istream &stream, Mint &m) {
        return stream >> m.val;
    }
};

const int32_t N = 3e3;

Mint FAC[N + 1], INV[N + 1];
bool done = false;

void calc() {
    if (done) {
        return;
    }
    done = true;
    FAC[0] = 1;
    for (int i = 1; i <= N; i++) {
        FAC[i] = (FAC[i - 1] * i);
    }
    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);
    for (int i = N - 1; i >= 0; i--) {
        INV[i] = (INV[i + 1] * (i + 1));
    }
}
Mint ncr(int n, int r) {
    if (r < 0) return 0;
    if (n < r) return 0;
    if (r == 0) return 1;
    Mint a = FAC[n] * INV[r] * INV[n - r];
    return a;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {        
        
        vector<Mint> dp(x + 1);
        for (int i = 1; i <= x; i++) {
            dp[i] = Mint(i).pow(n);
            for (int j = i - 1; j >= 1; j--) {
                dp[i] -= dp[j] * ncr(i, j);
            }
        }
            
        calc();
        
        Mint ans = 0;
        for (int i = 1; i <= min(n, x); i++) {
            ans += ncr(x, i) * Mint(y).pow(i) * dp[i];
        }
        return ans.val;
    }
};",1420070621
Meet Brahmbhatt,MeetBrahmbhatt,90,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = (int) v.size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            if (v[i] == 2) {
                continue;
            }
            for (int j = 0; j < 31; j++) {
                if (~v[i] >> j & 1) {
                    res[i] = v[i] ^ (1 << (j - 1));
                    assert(res[i] | (res[i] + 1) == v[i]);
                    break;
                }
            }
        }
        
        return res;
    }
};",1419998652
Meet Brahmbhatt,MeetBrahmbhatt,90,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = (int) v.size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            if (v[i] == 2) {
                continue;
            }
            for (int j = 0; j < 31; j++) {
                if (~v[i] >> j & 1) {
                    res[i] = v[i] ^ (1 << (j - 1));
                    assert(res[i] | (res[i] + 1) == v[i]);
                    break;
                }
            }
        }
        
        return res;
    }
};",1419998501
lqCKWBPxHc,lqCKWBPxHc,91,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        target_indices_set = set(targetIndices)

        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0

        for i in range(n):
            for j in range(m + 1):
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
            for j in range(m):
                if source[i] == pattern[j]:
                    cost = dp[i][j]
                    if i in target_indices_set:
                        cost += 1
                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], cost)

        min_required_kept = dp[n][m]
        max_removals = len(targetIndices) - min_required_kept if min_required_kept != float('inf') else 0
        return max_removals",1420070663
lqCKWBPxHc,lqCKWBPxHc,91,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        max_n = max(n, x) + 2
        fac = [1] * max_n
        inv_fac = [1] * max_n
        for i in range(1, max_n):
            fac[i] = fac[i - 1] * i % MOD
        inv_fac[max_n - 1] = pow(fac[max_n - 1], MOD - 2, MOD)
        for i in range(max_n - 2, -1, -1):
            inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD
        S = [[0] * max_n for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, min(i, x) + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
        ans = 0
        for k in range(1, min(n, x) + 1):
            term = fac[x] * inv_fac[k] % MOD * inv_fac[x - k] % MOD
            term = term * fac[k] % MOD
            term = term * S[n][k] % MOD
            term = term * pow(y, k, MOD) % MOD
            ans = (ans + term) % MOD
        return ans",1420006366
lqCKWBPxHc,lqCKWBPxHc,91,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def is_valid(ans, num):
            return (ans | (ans + 1)) == num

        ans = [-1] * len(nums)

        for i, num in enumerate(nums):
            candidate = num
            while candidate >= 0:
                if is_valid(candidate, num):
                    if ans[i] == -1 or candidate < ans[i]:
                        ans[i] = candidate
                candidate -= 1
                if candidate < 0 or (candidate | (candidate + 1)) > num:
                    break

        return ans",1420021226
lqCKWBPxHc,lqCKWBPxHc,91,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def is_valid(ans, num):
            return (ans | (ans + 1)) == num

        ans = [-1] * len(nums)

        for i, num in enumerate(nums):
            candidate = num
            while candidate >= 0:
                if is_valid(candidate, num):
                    if ans[i] == -1 or candidate < ans[i]:
                        ans[i] = candidate
                candidate -= 1
                if candidate < 0 or (candidate | (candidate + 1)) > num:
                    break

        return ans",1420020772
Temirlan,Tima_,92,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tg) {
        int n = s.size();
        int m = p.size();
        vector <int> used(n, 0);
        for(int i : tg) used[i] = 1;
        vector <vector<int> > dp(n + 1, vector <int> (m + 1, -int(1e9)));
        dp[0][0] = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= m; j++){
                if(s[i] == p[j]){
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + used[i]);
            }
        }
        //for(int i = 1; i <= n; i++){
        //    cout << dp[i][m] << "" "";
        //}
        int mx = dp[n][m];
        //for(int i = 1; i <= n; i++) mx = max(mx, dp[i][m] + (n - i));
        return mx;
    }
};",1420030352
Temirlan,Tima_,92,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector <vector <long long> > dp(n + 1, vector <long long> (n + 1, 0));
        dp[0][0] = 1;
        //vector <int> dp(n + 1, 0);
        vector <vector<int> > c(n + 1, vector<int> (n + 1, 0));
        int mod = (int)(1e9) + 7;
        for(int i = 0; i <= n; i++){
            c[i][0] = c[i][i] = 1;
            for(int j = 1; j < i; j++){
                c[i][j] = (c[i- 1][j - 1] + c[i - 1][j]) % mod; 
            }
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= min(i, x); j++){
                dp[i][j] = (dp[i - 1][j - 1] * (x - j + 1) + dp[i - 1][j] * j) % mod;
            }
        }
        long long res = 0, cur = 1;
        for(int i = 1; i <= min(x, n); i++){
            cur = cur * y % mod;
            res = (res + cur * dp[n][i]) % mod;
        }
        return res % mod;
    }
};",1420070704
Temirlan,Tima_,92,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans(1024, -1);
        for(int x = 0; x < 1023; x++){
            int y = (x | (x + 1));
            if(ans[y] == -1) ans[y] = x;
        }    
        vector <int> res;
        for(int x : nums) res.push_back(ans[x]);
        return res;
    }
};",1419994410
Temirlan,Tima_,92,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> res;
        for(int x : nums){
            if(x == 2){
                res.push_back(-1);
                continue;
            }
            int y = x, cnt = 0;
            while(y % 2 == 1){
                y /= 2;
                cnt++;
            }
            res.push_back((y<<cnt) + (1<<(cnt - 1)) - 1);
        }
        return res;
    }
};",1420003197
Abhishek,non_deterministic,93,3487,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

int dp[3005][3005];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> canBeRemoved(n + 1, 0);
        for(int i = 0; i < sz(targetIndices); i++) {
            canBeRemoved[targetIndices[i] + 1] = 1;
        }
        for(int i = 0; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                dp[i][j] = -1;
            }
            dp[i][0] = 0;
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j <= m; j++) {
                dp[i][j] = dp[i - 1][j];
                if(j > 0 && source[i - 1] == pattern[j - 1] && dp[i - 1][j - 1] != -1) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                }
                if(canBeRemoved[i] == 1 && dp[i - 1][j] != -1) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1);
                }
            }
        }
        return dp[n][m];
    }
};
",1420040018
Abhishek,non_deterministic,93,3604,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

using ll = long long;
using ull = unsigned long long;
typedef unsigned int uint;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}

const uint MOD = 1000000007;
template<uint mod = MOD> struct mint { // 1000000007  1000000009
    uint x;
 
    mint() : x(0) {}
    mint(ll _x) {
        _x %= mod;
        if (_x < 0) _x += mod;
        x = _x;
    }
 
    mint& operator += (const mint &a) {
        x += a.x;
        if (x >= mod) x -= mod;
        return *this;
    }
    mint& operator -= (const mint &a) {
        x += mod - a.x;
        if (x >= mod) x -= mod;
        return *this;
    }
    mint& operator *= (const mint &a) {
        x = (ull)x * a.x % mod;
        return *this;
    }
    mint pow(ll pw) const {
        mint res = 1;
        mint cur = *this;
        while(pw) {
            if (pw & 1) res *= cur;
            cur *= cur;
            pw >>= 1;
        }
        return res;
    }
    mint inv() const {
        assert(x != 0);
        uint t = x;
        uint res = 1;
        while(t != 1) {
            uint z = mod / t;
            res = (ull)res * (mod - z) % mod;
            t = mod - t * z;
        }
        return res;
    }
    mint& operator /= (const mint &a) {
        return *this *= a.inv();
    }
    mint operator + (const mint &a) const {
        return mint(*this) += a;
    }
    mint operator - (const mint &a) const {
        return mint(*this) -= a;
    }
    mint operator * (const mint &a) const {
        return mint(*this) *= a;
    }
    mint operator / (const mint &a) const {
        return mint(*this) /= a;
    }
 
    bool sqrt(mint &res) const {
        if (mod == 2 || x == 0) {
            res = *this;
            return true;
        }
        if (pow((mod - 1) / 2) != 1) return false;
        if (mod % 4 == 3) {
            res = pow((mod + 1) / 4);
            return true;
        }
        int pw = (mod - 1) / 2;
        int K = 30;
        while((1 << K) > pw) K--;
        while(true) {
            mint t = myRand(mod);
            mint a = 0, b = 0, c = 1;
            for (int k = K; k >= 0; k--) {
                a = b * b;
                b = b * c * 2;
                c = c * c + a * *this;
                if (((pw >> k) & 1) == 0) continue;
                a = b;
                b = b * t + c;
                c = c * t + a * *this;
            }
            if (b == 0) continue;
            c -= 1;
            c *= mint() - b.inv();
            if (c * c == *this) {
                res = c;
                return true;
            }
        }
        assert(false);
    }
 
    bool operator == (const mint &a) const {
        return x == a.x;
    }
    bool operator != (const mint &a) const {
        return x != a.x;
    }
    bool operator < (const mint &a) const {
        return x < a.x;
    }
};
using Mint = mint<>;

Mint dp[1005][1005];

template<uint mod = MOD> struct Factorials {
    using Mint = mint<mod>;
    vector<Mint> f, fi;
 
    Factorials() : f(), fi() {}
    Factorials(int n) {
        n += 10;
        f = vector<Mint>(n);
        fi = vector<Mint>(n);
        f[0] = 1;
        for (int i = 1; i < n; i++)
            f[i] = f[i - 1] * i;
        fi[n - 1] = f[n - 1].inv();
        for (int i = n - 1; i > 0; i--)
            fi[i - 1] = fi[i] * i;
    }
 
    Mint C(int n, int k) {
        if (k < 0 || k > n) return 0;
        return f[n] * fi[k] * fi[n - k];
    }
};

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        Factorials fact(1005);
        repI(i, 0, n) {
            repI(j, 0, x) {
                dp[i][j] = 0;
            }
        }
        dp[0][0] = 1;
        // dp[1][1] = 1;
        repI(i, 1, n) {
            repI(j, 1, x) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] * j;
                // Error(i, j, dp[i][j].x);
            }
        }
        Mint ans = 0;
        repI(i, 1, x) {
            ans += dp[n][i] * Mint(y).pow(i) * fact.f[x] * fact.fi[x - i];
        }
        return ans.x;
    }
};
",1420072085
Abhishek,non_deterministic,93,3605,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        rep(i, 0, n-1) {
            if(nums[i] == 2) {
                continue;
            }
            int firstZeroBit = 0;
            while((nums[i] & (1 << firstZeroBit)) != 0) {
                firstZeroBit++;
            }
            firstZeroBit--;
            ans[i] = nums[i] - (1 << firstZeroBit);
        }
        return ans;
    }
};",1420025330
Abhishek,non_deterministic,93,3611,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        rep(i, 0, n-1) {
            if(nums[i] == 2) {
                continue;
            }
            int firstZeroBit = 0;
            while((nums[i] & (1 << firstZeroBit)) != 0) {
                firstZeroBit++;
            }
            firstZeroBit--;
            ans[i] = nums[i] - (1 << firstZeroBit);
        }
        return ans;
    }
};",1420025023
seg_tree,_rajat_18_,94,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size();
        int m=pattern.size();
        vector<int>dp(m+1,INT_MAX);
        dp[0]=0;
        vector<bool>ndp(n,false);
        for(auto it=targetIndices.begin();it!=targetIndices.end();++it)
        {
            ndp[*it]=true;
        }
        for(int i=0;i<n;++i)
        {
            for(int j=m;j>0;--j)
            {
                if(source[i]==pattern[j-1] && dp[j-1]!=INT_MAX)
                {
                    dp[j]=min(dp[j],dp[j-1]+(ndp[i]?1:0));
                }
            }
        }
        return targetIndices.size()-(dp[m]==INT_MAX?0:dp[m]);
    }
};",1420064555
seg_tree,_rajat_18_,94,3604,cpp,"const int MOD=1000000007;
class Solution {
public:
    int numberOfWays(int n,int x,int y) {
        int maxi=max(n,x);
        vector<long long>fact(maxi+1,1);
        for(int i=1;i<=maxi;++i)
        {
            fact[i]=(fact[i-1]*i)%MOD;
        }
        vector<long long>inv_fact(maxi+1,1);
        inv_fact[maxi]=power(fact[maxi],MOD-2);
        for(int i=maxi-1;~i;--i)
        {
            inv_fact[i]=(inv_fact[i+1]*(i+1))%MOD;
        }
        vector<long long>precompute(x+1,0);
        vector<long long>iter(x+1,0);
        precompute[0]=1;
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=min(i,x);++j)
            {
                iter[j]=(precompute[j-1]+(j*precompute[j])%MOD)%MOD;
            }
            for(int j=0;j<=x;++j)
            {
                precompute[j]=iter[j];
                iter[j]=0;
            }
        }
        vector<long long>test=precompute;
        vector<long long>dp(x+1,1);
        for(int k=1;k<=x;++k)
        {
            dp[k]=(dp[k-1]*y)%MOD;
        }
        long long res=0;
        int K=min(x,n);
        for(int k=1;k<=K;++k)
        {
            long long P=(fact[x]*inv_fact[x-k])%MOD;
            long long S=test[k];
            long long recur=dp[k];
            long long term=((P*S)%MOD*recur)%MOD;
            res=(res+term)%MOD;
        }
        return (long long)res;
    }
private:
    long long power(long long a,long long b)
    {
        long long res=1;
        a%=MOD;
        while(b>0)
        {
            if(b&1)
            {
                res=(res*a)%MOD;
            }
            a=(a*a)%MOD;
            b>>=1;
        }
        return res;
    }
};",1420037140
seg_tree,_rajat_18_,94,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto& it:nums)
        {
            bool ok=false;
            for(int i=0;i<=it;++i)
            {
                if((i|(i+1))==it)
                {
                    ans.push_back(i);
                    ok=true;
                    break;
                }
            }
            if(!ok)ans.push_back(-1);
        }
        return ans;
    }
};",1419994897
seg_tree,_rajat_18_,94,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto& it:nums)
        {
            if(it<=1)
            {
                ans.push_back(-1);
                continue;
            }
            vector<int>add_;
            for(int i=0;i<32;++i)
            {
                if(it&(1<<i))
                {
                    int bits=it&~(1<<i);
                    if((bits|(bits+1))==it)
                    {
                        add_.push_back(bits);
                    }
                }
            }
            if(!add_.empty())
            {
                ans.push_back(*min_element(add_.begin(),add_.end()));
            }
            else
            {
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420000518
invertedwinger,invertedwinger,96,3487,cpp,"const int N = 3005;
int dp[N][N];
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& v) {
        int n = s.length(), m = p.length();
        for(int i=0; i<=n; i++) for(int j=0; j<=m; j++) dp[i][j] = -1;
        dp[0][0] = 0;
        vector<bool> c(n+1,false);
        for(int x:v) c[x+1] = true;
        for(int i=1; i<=n; i++){
            dp[i][0] = dp[i-1][0] + c[i];
            for(int j=1; j<=m; j++){
                dp[i][j] = dp[i-1][j];
                if(s[i-1] == p[j-1]) dp[i][j] = dp[i-1][j-1];
                if(!c[i]) continue;
                if(dp[i-1][j] != -1) dp[i][j] = max(dp[i][j], dp[i-1][j]+1);
            }
        }
        return dp[n][m];
    }
};",1420024366
invertedwinger,invertedwinger,96,3604,cpp,"typedef long long ll;
const ll mod = 1e9+7;
const ll N=1e3+5;
ll fct[N],inv[N],invfct[N], p[N][N];
class Solution {
public:
    ll ncr(ll n,ll r){
        if(n<0 || r<0 || n-r<0)return 0;
        ll ans = fct[n]*invfct[r];
        ans%=mod;
        ans = ans * invfct[n-r];
        ans%=mod;
        return ans;
    }
    ll get(ll n, ll m){
        if(m>n) return 0;
        ll sign = -1,ans=p[m][n];
        for(int i=1; i<=m; i++){
            ll x = (ncr(m,i)*p[m-i][n])%mod;
            ans = (ans + sign * (x))%mod;
            sign *= -1;
        }
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        fct[0]=fct[1]=1;
        inv[1]=1;
        invfct[0]=invfct[1]=1;
        for(ll i=2;i<N;i++){
            fct[i]=i*fct[i-1]%mod;
            inv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;
            invfct[i]=ll(inv[i])*invfct[i-1]%mod;
        }
        for(ll i=0; i<N; i++){
            p[i][0] = 1;
            if(i==0) p[i][0]=0;
            for(ll j=1; j<N; j++) p[i][j] = (p[i][j-1]*i)%mod;
        }

        ll ans = 0;
        for(int i=1; i<=x; i++){
            ll t = (ncr(x,i)*get(n,i))%mod;
            //cout<<get(n,i)<<endl;
            t = (t*p[y][i])%mod;
            ans = (ans+t)%mod;
        }
        if(ans<0) ans+=mod;
        return ans;
    }
};",1420074176
invertedwinger,invertedwinger,96,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int x = a[i];
            if(x&1){
                for(int j=1; j<15; j++){
                    if((x>>j)&1) continue;
                    int b = 1<<(j-1);
                    ans[i] = (x ^ b);
                    break;
                }
            }
            else ans[i] = -1;
        }
        return ans;
    }
};",1420002657
invertedwinger,invertedwinger,96,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int x = a[i];
            if(x&1){
                for(int j=1; j<15; j++){
                    if((x>>j)&1) continue;
                    int b = 1<<(j-1);
                    ans[i] = (x ^ b);
                    break;
                }
            }
            else ans[i] = -1;
        }
        return ans;
    }
};",1420003700
Aravind_001,aravind_1,97,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        a = len(source)
        b= len(pattern)
        dp = [float('inf')] * (b + 1)
        dp[0] = 0  
        isT = [False] * a
        for i in targetIndices:
            isT[i] = True
        for i in range(a):
            for j in range(b, 0, -1):  
                if source[i] == pattern[j - 1]:
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isT[i] else 0))
        r = len(targetIndices) - (0 if dp[b] == float('inf') else dp[b])
        
        return r",1420066989
Aravind_001,aravind_1,97,3604,java,"class Solution {
    private static final int MO = 1_000_000_007;

    public int numberOfWays(int n, int x, int y) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, x); j++) {
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MO;
            }
        }
        long[][] C = new long[x + 1][x + 1];
        C[0][0] = 1;
        for (int i = 1; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
            }
        }
        long[] ft = new long[x + 1];
        ft[0] = 1;
        for (int k = 1; k <= x; k++) {
            ft[k] = (ft[k - 1] * k) % MO;
        }
        long[] py = new long[x + 1];
        py[0] = 1;
        for (int k = 1; k <= x; k++) {
            py[k] = (py[k - 1] * y) % MO;
        }
        long res = 0;
        int mk = Math.min(n, x);
        for (int k = 1; k <= mk; k++) {
            long cb = C[x][k];
            long st = S[n][k];
            long fk = ft[k];
            long yp = py[k];
            long tmp = (((cb * st) % MO) * fk) % MO;
            tmp = (tmp * yp) % MO;
            res = (res + tmp) % MO;
        }

        return (int) res;
    }
}",1420042891
Aravind_001,aravind_1,97,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] a = new int[n];
        
        for (int i = 0; i < n; i++) {
            int b = nums.get(i);
            a[i] = -1; 
            
            for (int j = 0; j < b; j++) {
                if ((j | (j + 1)) == b) {
                    a[i] = j;
                    break; 
                }
            }
        }
        
        return a;
    }
}",1419996740
Aravind_001,aravind_1,97,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] rs = new int[n];
        
        for(int i = 0; i < n; i++) {
            int p = nums.get(i);
            int mx = Integer.MAX_VALUE;
            int t = p;
            int b = 0;
            
            while(t > 0) {
                if((t & 1) == 1) {
                    int x = p & (~(1 << b));
                    if((x | (x + 1)) == p) {
                        if(x < mx) {
                            mx = x;
                        }
                    }
                }
                t = t >>> 1;
                b++;
            }
            rs[i] = (mx != Integer.MAX_VALUE) ? mx : -1;
        }
        return rs;
    }
}",1420012213
Xiaomeng Yang,yangxm,98,3487,cpp,"constexpr int MAX = 3010;

int lcs[MAX][MAX], dp[MAX][MAX];
bool vis[MAX];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
      const string& s = source;
      const string& p = pattern;
      const auto& a = targetIndices;
      int n = s.length(), m = p.length();
      memset(vis, 0, sizeof(vis));
      for (int x : a) {
        vis[x + 1] = true;
      }
      for (int i = 0; i <= m; ++i) {
        lcs[i][0] = 0;
      }
      for (int i = 0; i <= n; ++i) {
        lcs[0][i] = 0;
      }
      for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
          lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1]);
          if (p[i - 1] == s[j - 1]) {
            lcs[i][j] = max(lcs[i][j], lcs[i - 1][j - 1] + 1);
          }
        }
      }
      dp[0][0] = 0;
      for (int i = 1; i <= n; ++i) {
        dp[0][i] = dp[0][i - 1] + vis[i];
      }
      for (int i = 1; i <= m; ++i) {
        dp[i][0] = -1;
        for (int j = 1; j <= n; ++j) {
          if (lcs[i][j] < i) {
            dp[i][j] = -1;
          } else {
            dp[i][j] = 0;
            if (lcs[i - 1][j - 1] == i - 1 && p[i - 1] == s[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1];
            }
            if (lcs[i][j - 1] == i) {
              dp[i][j] = max(dp[i][j], dp[i][j - 1] + vis[j]);
            }
          }
        }
      }
      return dp[m][n];
    }
};",1420052250
Xiaomeng Yang,yangxm,98,3604,cpp,"using i64 = long long;

constexpr int MAX = 1024;
constexpr int MOD = 1000000007;

i64 dp[MAX][MAX];

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
      int m = min(n, x);
      for (int i = 1; i <= n; ++i) {
        fill(dp[i], dp[i] + m + 1, 0);
        dp[i][1] = x;
        for (int j = 2; j <= m && j <= i; ++j) {
          i64 p = (i64)(x - j + 1) * dp[i - 1][j - 1] % MOD;
          i64 q = (i64)j * dp[i - 1][j] % MOD;
          dp[i][j] = (p + q) % MOD;
        }
      }
      i64 ret = 0, w = 1;
      for (int i = 1; i <= m; ++i) {
        w = w * y % MOD;
        i64 cur = dp[n][i] * w % MOD;
        ret = (ret + cur) % MOD;
      }
      return ret;
    }
};",1420074980
Xiaomeng Yang,yangxm,98,3605,cpp,"int Calc(int x) {
  if (x == 2) {
    return -1;
  }
  int cnt = 0;
  for (int i = x; i > 0 && (i & 1); i >>= 1) {
    ++cnt;
  }
  int v = (1 << (cnt - 1)) - 1;
  return x - ((1 << cnt) - 1) + v;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      int n = nums.size();
      vector<int> ret(n);
      for (int i = 0; i < n; ++i) {
        ret[i] = Calc(nums[i]);
      }
      return ret;
    }
};;",1420002462
Xiaomeng Yang,yangxm,98,3611,cpp,"int Calc(int x) {
  if (x == 2) {
    return -1;
  }
  int cnt = 0;
  for (int i = x; i > 0 && (i & 1); i >>= 1) {
    ++cnt;
  }
  int v = (1 << (cnt - 1)) - 1;
  return x - ((1 << cnt) - 1) + v;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      int n = nums.size();
      vector<int> ret(n);
      for (int i = 0; i < n; ++i) {
        ret[i] = Calc(nums[i]);
      }
      return ret;
    }
};",1420002005
LucasLyu,Lucas595,100,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        target_set = set(targetIndices)
        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        for i in range(n):
            for j in range(m + 1):
                if dp[i][j] < float('inf'):
                    if dp[i + 1][j] > dp[i][j]:
                        dp[i + 1][j] = dp[i][j]
                    if j < m and source[i] == pattern[j]:
                        cost = dp[i][j] + (1 if i in target_set else 0)
                        if dp[i + 1][j + 1] > cost:
                            dp[i + 1][j + 1] = cost
        min_used = dp[n][m]
        max_op = len(targetIndices) - min_used
        return max(0, max_op)",1420056583
LucasLyu,Lucas595,100,3604,python3,"MOD = 10**9 + 7
MAX_N = 1000

factorial = [1] * (2 * MAX_N + 1)
for i in range(1, len(factorial)):
    factorial[i] = factorial[i - 1] * i % MOD

inv_factorial = [1] * (2 * MAX_N + 1)
inv_factorial[-1] = pow(factorial[-1], MOD - 2, MOD)
for i in reversed(range(len(inv_factorial) - 1)):
    inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

S = [[0] * (MAX_N + 1) for _ in range(MAX_N + 1)]
S[0][0] = 1
for n in range(1, MAX_N + 1):
    for k in range(1, n + 1):
        S[n][k] = (k * S[n - 1][k] + S[n - 1][k - 1]) % MOD


class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        total_ways = 0
        min_k = min(n, x)
        for k in range(1, min_k + 1):
            C_xk = factorial[x] * inv_factorial[k] % MOD * inv_factorial[x - k] % MOD
            k_fact = factorial[k]
            S_nk = S[n][k]
            y_k = pow(y, k, MOD)
            term = C_xk * k_fact % MOD * S_nk % MOD * y_k % MOD
            total_ways = (total_ways + term) % MOD
        return total_ways
        ",1420060469
LucasLyu,Lucas595,100,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:

        @lru_cache()
        def map(num: int) -> int:
            for i in range(num >> 1, num):
                if (i | (i + 1)) == num:
                    return i
            return -1

        return [map(num) for num in nums]
        ",1420006899
LucasLyu,Lucas595,100,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            min_a = -1
            if N == 2:
                ans.append(-1)
                continue
            for k in range(N.bit_length()):
                if (N >> k) & 1:
                    a = N - (1 << k)
                    if a >= 0 and (a | (a + 1)) == N:
                        if min_a == -1 or a < min_a:
                            min_a = a
            ans.append(min_a)
        return ans
        ",1420047772
M Kawa,mkawa222,101,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        inf=10**16
        n=len(source)
        m=len(pattern)
        dp=[[-inf]*(m+1) for _ in range(n+1)]
        for i in range(n):dp[i][0]=0
        ok=[0]*n
        for i in targetIndices:ok[i]=1
        for i in range(n+1):
            for j in range(m+1):
                if i<n and j<m and source[i]==pattern[j]:dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j])
                if i<n:dp[i+1][j]=max(dp[i+1][j],dp[i][j]+ok[i])
        ans=dp[n][m]
        if ans<0:ans=-1
        return ans
",1420057334
M Kawa,mkawa222,101,3604,python3,"md=10**9+7

def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

def nPr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_n-com_r]%md

n_max = 2000
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md

dp=[[0]*1001 for _ in range(1001)]
dp[0][0]=1
for n in range(1,1001):
    for k in range(1,n+1):
        dp[n][k]=dp[n-1][k]*k%md
        if k:
            dp[n][k]+=dp[n-1][k-1]
            dp[n][k]%=md

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans=0
        for i in range(1,x+1):
            ans+=dp[n][i]*nPr(x,i)%md*pow(y,i,md)%md
            ans%=md
        return ans
",1420075682
M Kawa,mkawa222,101,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for a in nums:
            if a==2:
                ans.append(-1)
            else:
                k=0
                while a>>k&1:k+=1
                k-=1
                a^=1<<k
                ans.append(a)
        return ans
",1420006237
M Kawa,mkawa222,101,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for a in nums:
            if a==2:
                ans.append(-1)
            else:
                k=0
                while a>>k&1:k+=1
                k-=1
                a^=1<<k
                ans.append(a)
        return ans
",1420005570
Shango Xiao,i_love_xiaoshagua_cpp,102,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        """"""
        dp[i][j] stores the maximum characters k which can be removed, so that
        source[:i] - k characters still contains pattern[:j]
        dp[i][j] = (remove source[i], dp[i - 1][j] + 1; don't remove source[i] but can't use it, dp[i-1][j]; don't remove source[i] and use it because source[i] = pattern[j], dp[i - 1][j - 1] + 1)
        answer is dp[-1][-1]
        """"""
        m = len(source)
        n = len(pattern)
        dp = [[float('-inf')] * (n + 1) for _ in range(2)]
        ti = set(targetIndices)
        dp[-1][-1] = 0
        for i in range(m):
            curr = i % 2
            prev = 1 - curr
            for j in range(n + 1):
                dp[curr][j] = float('-inf')
            for j in range(n + 1):
                if j == n:
                    dp[curr][j] = dp[prev][j]
                    if i in ti:
                        dp[curr][j] += 1
                    break
                dp[curr][j] = max(dp[curr][j], (1 if i in ti else 0) + dp[prev][j])
                if source[i] == pattern[j]:
                    dp[curr][j] = max(dp[curr][j], dp[prev][j - 1])
            # print(i, dp[curr])
        return dp[1 - (m % 2)][n - 1]",1420048945
Shango Xiao,i_love_xiaoshagua_cpp,102,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        """"""
        For a given k, we can compute how many ways we can assign performers to exactly k stages.
        sum_k #{assign n performers to exactly 1, 2, ..., k} * choose(x, k) * (y ^ k)
        #{assign n performers to exactly 1-k} = k^n - k*assign exactly to 1-(k-1) - ...
        """"""
        mod = 1000000007
        fact = [1]
        for i in range(1, 1005):
            fact.append((fact[i-1] * i) % mod)
        def mi(x):
            return pow(x, mod - 2, mod)
        ifact = [mi(fact[i]) for i in range(1005)]
        prep = []
        prep.append(1)
        def choose(u, v):
            base = fact[u]
            base = (base * ifact[v]) % mod
            base = (base * ifact[u - v]) % mod
            return base
        for k in range(2, x + 1):
            ans = pow(k, n, mod)
            for i in range(1, k):
                ans += mod - ((choose(k, i) * prep[i - 1]) % mod)
                ans %= mod
            prep.append(ans)
        print(prep)
        rtn = 0
        for k in range(1, x+1):
            now = prep[k-1]
            now = (now * choose(x, k)) % mod
            now = (now * pow(y, k, mod)) % mod
            rtn += now
            rtn %= mod
        return rtn
            ",1420075702
Shango Xiao,i_love_xiaoshagua_cpp,102,3605,python3,"def f(x):
    if x == 2:
        return -1
    assert x % 2 == 1
    for k in range(36, -1, -1):
        if 2 ** k > x:
            continue
        cand = x - (2 ** k)
        if x == (cand | (cand + 1)):
            return cand
    assert False
    return None

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [f(x) for x in nums]",1420001319
Shango Xiao,i_love_xiaoshagua_cpp,102,3611,python3,"def f(x):
    if x == 2:
        return -1
    assert x % 2 == 1
    for k in range(36, -1, -1):
        if 2 ** k > x:
            continue
        cand = x - (2 ** k)
        if x == (cand | (cand + 1)):
            return cand
    assert False
    return None

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [f(x) for x in nums]",1420001039
Vikash Sangai,VS_Codes,103,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& v) {
        // int ans=0;
        unordered_map<int,bool> mp;
        for(auto &it:v)
            mp[it]=true;
        int n=s.size(),m=p.size();
        vector<vector<int>> dp(n+1,vector<int> (m+1,-1e9));
        dp[0][0]=0;
        for(int i=0;i<n;i++)
        {
            dp[i+1][0]=dp[i][0];
            if(mp[i])
                dp[i+1][0]++;
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                dp[i+1][j+1]=dp[i][j+1];
                if(mp[i])
                    dp[i+1][j+1]++;
                if(s[i]==p[j])
                    dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);
            }
        }
        return dp[n][m]>=0?dp[n][m]:0;
    }
};",1420076087
Vikash Sangai,VS_Codes,103,3604,cpp,"class Solution {
public:
    const int mod=1e9+7;
    long long binaryExp(long long a, long long b)
    {
        a%=mod;
        long long ans=1;
        while(b>0)
        {
            if(b&1)
            {
                ans*=a;
                ans%=mod;
            }
            a*=a;
            a%=mod;
            b>>=1;
        }
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> st(n+1, vector<long long>(n+1,0));
        int mx=max(x,n)+1;
        vector<long long> fact(mx),inv(mx);
        st[0][0] = 1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=i;j++)
            {
                st[i][j]=(st[i-1][j-1]+j*st[i-1][j]);
                st[i][j]%=mod;
            }
        }
        fact[0]=1;
        for(int i=1;i<mx;++i)
        {
            fact[i]=fact[i-1]*1LL*i;
            fact[i]%=mod;
        }
        inv[mx-1]=binaryExp(fact[mx-1],mod-2);
        for(int i=mx-2;i>=0;--i)
        {
            inv[i]=inv[i+1]*1LL*(i+1);
            inv[i]%=mod;
        }
        long long ans=0;
        for(int i=1;i<=min(n,x);i++)
        {
            long long temp=fact[i];
            temp*=fact[x];
            temp%=mod;
            temp*=inv[i];
            temp%=mod;
            temp*=inv[x-i];
            temp%=mod;
            temp*=st[n][i];
            temp%=mod;
            temp*=binaryExp(y,i);
            temp%=mod;
            ans+=temp;
            ans%=mod;
        }
        return ans;
    }
};",1420044867
Vikash Sangai,VS_Codes,103,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=nums[i];j++)
            {
                if((j|(j+1))==nums[i])
                {
                    ans[i]=j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419994206
Vikash Sangai,VS_Codes,103,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++)
        {
            for(int j=29;j>=0;j--)
            {
                int temp=(1<<j);
                int toadd=v[i]-temp;
                if((toadd|(toadd+1))==v[i])
                {
                    ans[i]=toadd;
                    break;
                }
            }
        }
        return ans;
    }
};",1420053407
Ayush,as_313,104,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        f = [False] * len(s)
        self.updateFlags(f, t)
        dp = self.initializeDP(len(p))
        
        for i in range(len(s)):
            self.updateDP(dp, s[i], p, f[i], len(p))
        
        return len(t) - (0 if dp[len(p)] == float('inf') else dp[len(p)])

    def updateFlags(self, f: List[bool], t: List[int]) -> None:
        for i in t:
            f[i] = True

    def initializeDP(self, m: int) -> List[int]:
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        return dp

    def updateDP(self, dp: List[int], char: str, p: str, isTarget: bool, m: int) -> None:
        for j in range(m, 0, -1):
            if char == p[j-1] and dp[j-1] != float('inf'):
                dp[j] = min(dp[j], dp[j-1] + (1 if isTarget else 0))
",1420052496
Ayush,as_313,104,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        def C(k: int) -> List[List[int]]:
            c = [[0] * (k + 1) for _ in range(k + 1)]
            for i in range(k + 1):
                c[i][0] = 1
                for j in range(1, i + 1): c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD
            return c
        
        def S(n: int, k: int) -> List[List[int]]:
            stir = [[0] * (k + 1) for _ in range(n + 1)]
            stir[0][0] = 1
            for i in range(1, n + 1):
                for j in range(1, k + 1): stir[i][j] = (j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD
            return stir

        c = C(x)
        stir = S(n, x)
        fact = [1] * (x + 1)
        for i in range(1, x + 1): fact[i] = fact[i - 1] * i % MOD

        return sum(c[x][k] * stir[n][k] * fact[k] * pow(y, k, MOD) for k in range(1, x + 1)) % MOD
",1420069282
Ayush,as_313,104,3605,python3,"class Solution(object):
    def findMinAns(self, p):
        for x in range(1, p + 1):
            if (x | (x + 1)) == p: return x
        return -1

    def minBitwiseArray(self, n):
        return [self.findMinAns(x) for x in n]
",1420003838
Ayush,as_313,104,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, n: List[int]) -> List[int]:
        a = []
        for x in n:
            m = float('inf')
            f = 0
            for b in range(31):
                if (x >> b) & 1:
                    c = x & ~(1 << b)
                    if c >= 0 and (c | (c + 1)) == x: m = min(m, c); f = 1
            a.append(m if f else -1)
        return a
",1420058998
Ashwanth K,ashwanthkannan,105,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {


        int n = s.length();
        int alloc[n];
        for(int i = 0 ; i < n ; i ++ ) alloc[i] = 0;
        for(int x : t) alloc[x] = 1;
        int m = p.length();

        int dp[n+1][m+1];

        for(int i = n ; i >= 0 ; i --)
        {
            for(int j = m ; j >= 0 ; j --)
            {
                if(i == n)
                {
                    if(j == m) {
                        dp[i][j] = 0;
                        continue;
                    }
                    dp[i][j] = -10000;
                    continue;
                }

                int ans = -10000;
                if(j < m && s[i] == p[j])
                {
                    ans = max(ans , dp[i+1][j+1]);
                }

                if(alloc[i])
                {
                    ans = max(ans , 1 + dp[i+1][j]);
                }

                ans = max(ans , dp[i+1][j]);

                dp[i][j] = ans;
            }
        }

        return dp[0][0];
    }
};",1420062361
Ashwanth K,ashwanthkannan,105,3604,cpp,"#define ll long long

ll mod = 1e9 + 7;
int sz = 1005;
ll fact[1005];
ll ifact[1005];
 
ll power(ll x, ll n)   //x base n exponent
{
    if(n==0) return 1;
    x = x%mod;
    if(x%mod==0) return 0;   //For large N,%mod- > mod is prime
    n = n%(mod-1);
    ll pow = 1;
    while (n)
    {
        if (n & 1)
            pow = (pow*x)%mod;
        n = n >> 1;
        x = (x*x)%mod;
    }
    return pow;
}
 
ll inv_mod(ll x)
{
	return power(x , mod - 2)%mod;
}
 
void factorial()
{
	fact[0] = 1;
	fact[1] = 1;
	ifact[0] = 1;
	ifact[1] = 1;
	
	for(int i = 2 ; i < sz ; i ++)
	{
		fact[i] = (fact[i-1]*i)%mod;	
	}
	ifact[sz-1] = inv_mod(fact[sz-1]);
 
	for(int i = sz-2 ; i > 0 ; i --)
	{
		ifact[i] = (ifact[i+1]*(i+1))%mod;
	}
}
 
ll ncr(ll n , ll r)
{
	if(n<r || r<0) return 0;
	if(r == 0) return 1;
	return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod;
}


ll dp[1005][1005];
int N , X , Y;
ll recur(int i , int j)
{
    ll ans = 0;
    if(i == N)
    {   
        ans = fact[j];
        ans *= ncr(X , j);
        ans %= mod;
        ans *= power(Y , j);
        ans %= mod;
        return ans;
    }

    if(dp[i][j] != -1) return dp[i][j];
    ans  += j*recur(i+1 , j);
    ans %= mod;
    ans  += recur(i+1 , j+1);
    ans %= mod;
    return dp[i][j] = ans;
}

class Solution {
public:
    
    int numberOfWays(int n, int x, int y) {
        factorial();
        N=  n;
        X = x;
        Y = y;

        for(int i = 0 ; i <= n ; i ++)
        {
            for(int j = 0 ; j <= n ; j ++)
            {
                dp[i][j] = -1;
            }
        }
        ll ans = recur(0 , 0);
        return ans;
    }
};",1420028204
Ashwanth K,ashwanthkannan,105,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);

        for(int i = 0 ; i < n ; i ++)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                for(int b = 0 ; b < 60 ; b ++)
                {
                    if( ((nums[i] >> b)&1) == 0)
                    {
                        ans[i] = nums[i] ^ (1ll << (b-1));
                        break;
                    }
                }
            }
        }

        return ans;
    }
};",1420076502
Ashwanth K,ashwanthkannan,105,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);

        for(int i = 0 ; i < n ; i ++)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                for(int b = 0 ; b < 60 ; b ++)
                {
                    if( ((nums[i] >> b)&1) == 0)
                    {
                        ans[i] = nums[i] ^ (1ll << (b-1));
                        break;
                    }
                }
            }
        }

        return ans;
    }
};",1420075648
NAVEEN KUMAR S,hornedfoe,106,3487,java,"class Solution{
    char[] s , t;
    boolean[] arr;
    int m , n , brr[];
    Integer[][] dp;
    public int maxRemovals(String str , String pat , int[] nums){
        s = str.toCharArray();
        t = pat.toCharArray();
        m = t.length;
        n = s.length;
        arr = new boolean[n];
        brr = new int[n + 1];
        for(int i : nums) arr[i] = true;
        for(int i = n - 1 ; i >= 0 ; i--) brr[i] += brr[i + 1] + (arr[i] ? 1 : 0);
        dp = new Integer[n][m];
        return finder(0 , 0);
    }
    private int finder(int x , int y){
        if(y == m) return brr[x];
        if(x == n) return - n;
        if(dp[x][y] != null) return dp[x][y];
        int ret = finder(x + 1 , y) + (arr[x] ? 1 : 0);
        if(s[x] == t[y]) ret = Math.max(finder(x + 1 , y + 1) , ret);
        return dp[x][y] = ret;
    }
}",1420060495
NAVEEN KUMAR S,hornedfoe,106,3604,java,"class Solution{
    int n , max;
    long arr[] , mod = (long) 1e9 + 7;
    Long[][] dp;
    public int numberOfWays(int n , int x , int y){
        this.n = n;
        max = x;
        arr = new long[max + 1];
        arr[0] = 1;
        for(int i = 1 ; i <= max ; i++){
            arr[i] = arr[i - 1] * y;
            arr[i] %= mod;
        }
        dp = new Long[n][max + 1];
        return (int) finder(0 , 0);
    }
    private long finder(int x , int y){
        if(x == n) return arr[y];
        if(dp[x][y] != null) return dp[x][y];
        long ret = finder(x + 1 , y) * y;
        if(y != max) ret += finder(x + 1 , y + 1) * (max - y);
        return dp[x][y] = ret % mod;
    }
}",1420076802
NAVEEN KUMAR S,hornedfoe,106,3605,java,"class Solution{
    public int[] minBitwiseArray(List<Integer> nums){
        int n = nums.size() , ret[] = new int[n];
        for(int i = 0 ; i < n ; i++){
            ret[i] = finder(nums.get(i));
        }
        return ret;
    }
    private int finder(int x){
        if(x == 2) return -1;
        for(int i = 0 , v = 1 ; i < 32 ; v = 1 << ++i){
            if((x & v) == 0){
                x ^= (1 << (i - 1));
                break;
            }
        }
        return x;
    }
}",1420031373
NAVEEN KUMAR S,hornedfoe,106,3611,java,"class Solution{
    public int[] minBitwiseArray(List<Integer> nums){
        int n = nums.size() , ret[] = new int[n];
        for(int i = 0 ; i < n ; i++){
            ret[i] = finder(nums.get(i));
        }
        return ret;
    }
    private int finder(int x){
        if(x == 2) return -1;
        for(int i = 0 , v = 1 ; i < 32 ; v = 1 << ++i){
            if((x & v) == 0){
                x ^= (1 << (i - 1));
                break;
            }
        }
        return x;
    }
}",1420031671
Sharaputdin Magomedov,LeetcodeKZ,107,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        set<int> targetSet(t.begin(), t.end());
        int m = p.size();
        int n = s.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = m - 1; j >= 0; --j) {
                if (s[i] == p[j] && dp[j] != INT_MAX) {
                    int cost = dp[j] + (targetSet.count(i) ? 1 : 0);
                    dp[j + 1] = min(dp[j + 1], cost);
                }
            }
        }

        if (dp[m] == INT_MAX) {
            return 0;
        }

        int essential = dp[m];
        int maxOps = t.size() - essential;
        return maxOps;
    }
};",1420056233
Sharaputdin Magomedov,LeetcodeKZ,107,3604,cpp,"const int MOD = 1e9 + 7;
const int MAX_N = 1005;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<int> fact(MAX_N), invFact(MAX_N);
        computeFactorials(fact, invFact);

        vector<vector<int>> askhat(n + 1, vector<int>(n + 1, 0));
        computeaskhat(n, askhat);

        int totalWays = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            int combos = calculateCombination(x, k, fact, invFact);
            int askhatNum = getaskhatNumber(n, k, askhat);
            int permuteStages = calculateFactorial(k, fact);
            int scoreWays = powerMod(y, k);

            int ways = ((1LL * combos * askhatNum) % MOD * permuteStages) % MOD;
            ways = (1LL * ways * scoreWays) % MOD;

            totalWays = (totalWays + ways) % MOD;
        }
        return totalWays;
    }

private:
    void computeFactorials(vector<int>& fact, vector<int>& invFact) {
        fact[0] = invFact[0] = 1;
        for (int i = 1; i < fact.size(); ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
            invFact[i] = inverseMod(fact[i]);
        }
    }

    void computeaskhat(int n, vector<vector<int>>& askhat) {
        askhat[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            askhat[i][0] = 0;
            for (int j = 1; j <= i; ++j) {
                askhat[i][j] = (1LL * j * askhat[i - 1][j] % MOD + askhat[i - 1][j - 1]) % MOD;
            }
        }
    }

    int calculateCombination(int n, int k, const vector<int>& fact, const vector<int>& invFact) {
        if (k < 0 || k > n) return 0;
        return (1LL * fact[n] * invFact[k] % MOD * invFact[n - k]) % MOD;
    }

    int getaskhatNumber(int n, int k, const vector<vector<int>>& askhat) {
        return askhat[n][k];
    }

    int calculateFactorial(int n, const vector<int>& fact) {
        return fact[n];
    }

    int powerMod(int base, int exp) {
        return modPow(base, exp);
    }

    int inverseMod(int a) {
        return modPow(a, MOD - 2);
    }

    int modPow(int base, int exp) {
        int result = 1;
        base %= MOD;
        while (exp > 0) {
            if (exp % 2) result = (1LL * result * base) % MOD;
            base = (1LL * base * base) % MOD;
            exp /= 2;
        }
        return result;
    }
};
",1420070014
Sharaputdin Magomedov,LeetcodeKZ,107,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res(nums.size(), -1);
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 1; j <= nums[i]; ++j) {
                int cur = j;
                cur |= (j + 1);
                if (cur == nums[i]) {
                    res[i] = j;
                    break;
                }
            }
        }
        return res;
    }
};",1419996238
Sharaputdin Magomedov,LeetcodeKZ,107,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            int minimal = INT_MAX;
            for (int j = 0; j < 31; j++) {
                if ((num >> j) & 1) {
                    int s = num - (1 << j);
                    if (s >= 0 && ((s | (s + 1)) == num)) {
                        minimal = min(minimal, s);
                    }
                }
            }
            result[i] = minimal == INT_MAX ? -1 : minimal;
        }
        return result;
    }
};",1420044496
skyinde2,skyinde2,108,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)

        r = [False] * n
        for i in targetIndices:
            r[i] = True

        dp = [0] * (n + 1)
        last = dp[:]
        for i in range(n):
            last[i + 1] = last[i] + 1 if r[i] else last[i]

        for ch in pattern:
            dp[0] = -100000
            for i in range(len(source)):
                dp[i + 1] = last[i] if source[i] == ch else dp[i]
                if r[i]:
                    dp[i + 1] = max(dp[i + 1], dp[i] + 1)

            dp, last = last, dp

        return last[-1]",1420036539
skyinde2,skyinde2,108,3604,python3,"
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7

        def po(a):
            ret = 1
            for _ in range(n):
                ret = ret * a % MOD
            return ret

        a = [1] * (x + 1)
        c = [1] * (x + 1)

        for i in range(2, x + 1):
            c[i] = 1
            s = 0
            for j in reversed(range(1, i)):
                c[j] = (c[j] + c[j - 1]) % MOD
                s = (s + a[j] * c[j]) % MOD

            a[i] = (po(i) - s) % MOD

        t = [1] * (x + 1)
        for i in range(1, x + 1):
            t[i] = (t[i - 1] * y) % MOD

        ret = 0
        for i in range(1, x + 1):
            ret = (ret + a[i] * c[i] * t[i]) % MOD
        return ret
",1420077801
skyinde2,skyinde2,108,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num % 2 == 1:
                k = (((num + 1) ^ num) + 1) >> 2 & num
                ans.append(num - k)
            else:
                ans.append(-1)
        return ans
",1420002768
skyinde2,skyinde2,108,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num % 2 == 1:
                k = (((num + 1) ^ num) + 1) >> 2 & num
                ans.append(num - k)
            else:
                ans.append(-1)
        return ans
",1420003117
SreehariC,SreehariC,110,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        string s=source;
        string t=pattern;
        int n=s.size();
        int m=t.size();
        s="" ""+s;
        t="" ""+t;

        set<int> st;
        for(auto it:targetIndices) st.insert(it+1);

        vector<vector<int>> dp(n+1,vector<int>(m+1,-1e9));
        dp[0][0]=0;
        for(int i=1;i<=n;i++){
            if(st.find(i)!=st.end()) dp[i][0]=dp[i-1][0]+1;
            else dp[i][0]=dp[i-1][0];
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(s[i]==t[j]){
                    if(st.find(i)!=st.end()){
                        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+1);
                    }
                    else{
                        dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);
                    }
                }
                else{
                    if(st.find(i)!=st.end())
                    dp[i][j]=(dp[i-1][j]+1);
                    else dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[n][m];
        
    }
};",1420078136
SreehariC,SreehariC,110,3604,cpp,"typedef long long ll;
const ll MOD=1e9+7;
long long binpow(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            {res = res * a;
            res%=MOD;
            }
        a = a * a;
        a%=MOD;

        b >>= 1;
    }
    return res%MOD;
}
ll inverse(ll a){
    return (binpow(a,MOD-2))%MOD;
}

ll fac[10001];
void cal(){
   fac[0]=1;
   fac[1]=1;
   for(int i=2;i<=10000;i++){
      fac[i]=fac[i-1]*i;
      fac[i]%=MOD;
   }     
}
long long bin(int n, int k) {
    if(k>n)return 0;
    else return (fac[n] * (inverse((fac[k] * fac[n - k]) % MOD) % MOD))%MOD;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        cal();
        ll ans=0;
        for(int p=1;p<=x;p++){
            ll temp=0;
            for(int j=0;j<=p;j++){
                if(j%2==0){
                    temp+=(bin(p,j)*binpow(p-j,n))%MOD;
                    temp%=MOD;
                }
                else{
                    temp=(temp-(bin(p,j)*binpow(p-j,n))%MOD+MOD)%MOD;
                }
                temp%=MOD;
            }
            temp=(temp*bin(x,p))%MOD;
            temp=(temp*(binpow(y,p)))%MOD;
            ans+=temp;
            ans%=MOD;
        }
        return ans;
    }
};",1420056147
SreehariC,SreehariC,110,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int j=0;
                while((1<<j)&(nums[i])) j++;
                j--;
                ans.push_back(nums[i]^((1<<j)));


            }



        }
        return ans;

    }
};",1420008663
SreehariC,SreehariC,110,3611,cpp,"typedef long long ll;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int j=0;
                while((1ll<<j)&(nums[i])) j++;
                j--;
                ans.push_back(nums[i]^((1ll<<j)));


            }



        }
        return ans;

    }
};",1420011559
parth gujral,parth_gujral_,111,3487,cpp,"class Solution {
public:
void gfhghg()
{
    int bb=78;
}
void b()
{
    int nh=90;
}
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
b();
         int n = source.size();
         b();b();
        int m = pattern.size();

gfhghg();
        // dp array where dp[j] represents the minimum cost to match the first j characters of the pattern
        b();b();b();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        gfhghg();gfhghg();
b();
        // isTarget array that marks if a position is in targetIndices
        vector<bool> isTarget(n, false);
        b();b();
        for (int idx : targetIndices) {

            gfhghg();gfhghg();gfhghg();b();
            isTarget[idx] = true;
            gfhghg();gfhghg();
        }

        // Iterate through the source string and pattern
        for (int i = 0; i < n; ++i) {

            gfhghg();gfhghg();gfhghg();
            b();
            // Traverse the pattern in reverse order
            for (int j = m; j > 0; --j) {
                b();b();
                gfhghg();
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    b();b();
                    gfhghg();
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));

                    b();b();b();b();
                }
            }
            b();b();
        }

        // If dp[m] is still INT_MAX, it means the pattern couldn't be matched
        gfhghg();gfhghg();
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    
    }
};",1420062568
parth gujral,parth_gujral_,111,3604,cpp,"class Solution {
public:
const int MOD = 1e9 + 7;
#define ll long long 
void cvh()
{
    int bh=87;
}
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            cvh();
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {


                cvh();cvh();cvh();
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;

                cvh();cvh();cvh();
            }
        }

        // Initialize the Stirling numbers of the second kind (S) array
        vector<vector<ll>> S(n + 1, vector<ll>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            cvh();cvh();
            for (int j = 1; j <= x; ++j) {
                cvh();cvh();
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
            cvh();cvh();
        }

        // Factorial array
        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            cvh();cvh();cvh();
            fact[i] = 1LL * fact[i - 1] * i % MOD;
            cvh();cvh();cvh();cvh();
        }

        ll result = 0;
        // Main computation loop
        for (int k = 1; k <= x; ++k) {

            cvh();cvh();cvh();
            ll power = 1;
            for (int p = 0; p < k; ++p) {
                cvh();cvh();cvh();
                power = power * y % MOD;
                cvh();cvh();
            }
            cvh();cvh();cvh();
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        cvh();cvh();

        return result;

    }
};",1420053359
parth gujral,parth_gujral_,111,3605,cpp,"class Solution {

    void hghty()
    {
        int jh=90;
    }
    void hg()
    {
        int gfb=97;
    }
    private:
    int yrsolvemin(int x)
    {
        for(int sq=1;sq<=x;sq++)
        {
            hghty();hghty();hghty();
            if( (sq | (sq+1))==x)
            {
                hghty();hghty();
                return sq;
            }
        }
        hghty();
        return -1;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();hghty();
        vector<int> answer(n,-1);
        for(int i=0;i<n;i++)
        {
            hghty();hg();
            answer[i] = yrsolvemin(nums[i]);
            hg();hg();hg();
        }

        return answer;
    }
};",1420021786
parth gujral,parth_gujral_,111,3611,cpp,"class Solution {
public:
void hfgf()
{
    int hg=908;
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result;
        
        hfgf();

        for (int num : nums) {
            hfgf();hfgf();hfgf();hfgf();

            vector<int> array;
            
            for (int i = 0; i < 32; ++i) {
                hfgf();hfgf();hfgf();hfgf();

                if (num & (1 << i)) {

                    hfgf();hfgf();hfgf();hfgf();
                    int element = num & ~(1 << i);
                    hfgf();hfgf();
                    if ((element | (element + 1)) == num) {
                        hfgf();hfgf();hfgf();
                        array.push_back(element);
                    }
                    hfgf();hfgf();
                }
            }
            
            if (array.empty()) {
                hfgf();hfgf();
                result.push_back(-1);
                hfgf();
            } else {
                hfgf();
                result.push_back(*min_element(array.begin(), array.end()));
                hfgf();hfgf();
            }
        }
        hfgf();hfgf();
        return result;
    }
};",1420071980
Said Abdulaev,said_v15,112,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& ti) {
        int n = (int) s.size(), m = (int) p.size();
        unordered_set<int> t;
        for (auto &x: ti) t.insert(x + 1);

        s = ""#"" + s; p = ""#"" + p; // for balance
        int sum = 0;
        vector<vector<int>> dp(n + 1, vector<int> (m + 1));
        vector<vector<int>> can(n + 1, vector<int> (m + 1));
        can[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            can[i][0] = 1;

            for (int j = 0; j <= m; j++) {
                // don't take the i-th element
                if (can[i - 1][j]) {
                    dp[i][j] = dp[i - 1][j] + t.count(i);
                    can[i][j] = 1;
                }
                // take the i-th element
                if (!j) continue;

                if (s[i] == p[j] && can[i - 1][j - 1]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                    can[i][j] = 1;
                }
            }
        }

        // for (int i = 1; i <= n; i++) {
        //     for (int j = 0; j <= m; j++) {
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout << ""\n"";
        // }

        return dp[n][m];
    }
};",1420079248
Said Abdulaev,said_v15,112,3604,cpp,"class Solution {
public:
    const int mod = int(1e9) + 7;
    const int sz = 1005;

    int fact[1005];
    int inv_fact[1005];

    int mul(int a, int b) {
        return (long long) a * b % mod;
    }

    int add(int a, int b) {
        int res = (long long) a + b;
        if (res < 0)
            res += mod;
        else if (res > mod)
            res -= mod;
        return res % mod;
    }
    int bpow(int x, int p) {
        int res = 1;
        while (p) {
            if (p & 1)
                res = mul(res, x);

            p >>= 1;

            if (p)
                x = mul(x, x);
        }
        return res;
    }

    int inv(int x) {
        return bpow(x, mod - 2);
    }

    void calc_fact() {
        fact[0] = inv_fact[0] = 1;
        for (int i = 1; i < sz; i++) {
            fact[i] = mul(fact[i - 1], i);
            inv_fact[i] = inv(fact[i]);
        }
    }

    int cnk(int n, int k) {
        if (k > n)
            return 0;
        return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));
    }

    int numberOfWays(int n, int x, int y) {
        calc_fact();

        vector<vector<int>> dp(n + 1, vector<int> (x + 1));
        dp[0][0] = 1;
        // dp[i][j] - number of ways to assign i people on j stages
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                // j places are used
                // don't use a new place
                dp[i][j] = mul(dp[i - 1][j], j);
                // use a new place
                dp[i][j] = add(dp[i][j], mul(dp[i - 1][j - 1], x - (j - 1)));
            }
        }
        // for (int i = 1; i <= n; i++) {
        //     for (int j = 0; j <= x; j++) {
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout << ""\n"";
        // }
        int ans = 0;
        for (int i = 0; i <= x; i++) {
            ans = add(ans, mul(dp[n][i], bpow(y, i)));
        }

        return ans;
    }
};",1420016775
Said Abdulaev,said_v15,112,3605,cpp,"class Solution {
public:
    int find_least(int n) {
        for (int i = 0; i < 31; i++) {
            if (n & (1 << i)) {
                return i;
            }
        }
        return 31;
    }
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        for (auto &x: v) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            long long num = x;
            long long idx = 0;
            for (long long i = 0; i < 31; i++) {
                if (num & (1LL << i)) continue;
                idx = i;
                break;
            }
            cout << x << "" "" << idx << ""\n"";
            long long left = (1LL << idx) - 1;
            long long a = num - left;
            idx--;
            a += (1LL << idx) - 1;
            ans.push_back((int) a);

        }
        return ans;
    }
};",1420055550
Said Abdulaev,said_v15,112,3611,cpp,"class Solution {
public:
    int find_least(int n) {
        for (int i = 0; i < 31; i++) {
            if (n & (1 << i)) {
                return i;
            }
        }
        return 31;
    }
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        for (auto &x: v) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            long long num = x;
            long long idx = 0;
            for (long long i = 0; i < 31; i++) {
                if (num & (1LL << i)) continue;
                idx = i;
                break;
            }
            cout << x << "" "" << idx << ""\n"";
            long long left = (1LL << idx) - 1;
            long long a = num - left;
            idx--;
            a += (1LL << idx) - 1;
            ans.push_back((int) a);

        }
        return ans;
    }
};",1420055327
Ritik Rathor,ritik_369,113,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        vector<int> cost(n, 0);
        for (int idx : targetIndices) {
            cost[idx] = 1;
        }

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));
        for (int i = 0; i <= n; ++i) dp[i][0] = 0;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = dp[i - 1][j];
                if (source[i - 1] == pattern[j - 1] and dp[i - 1][j - 1] != INT_MAX) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + cost[i - 1]);
                }
            }
        }
        int res = 0 ; 
        if(dp[n][m] != INT_MAX)
            res = targetIndices.size() - dp[n][m] ; 
        return res ; 
    }
};
",1420065249
Ritik Rathor,ritik_369,113,3604,cpp,"const int mod = 1000000007;

long long binpow(long long a, long long b, long long m = mod) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}

int n, x, y;
vector<vector<int>> dp;

int f(int idx, int xx) {
    if (idx >= n + 1)
        return binpow(y, xx, mod);
    if (dp[idx][xx] != -1)
        return dp[idx][xx];

    int here = 0;
    here = (1ll * here + 1ll * f(idx + 1, xx) * xx) % mod;
    if (xx + 1 <= x)
        here = (1ll * here + 1ll * f(idx + 1, xx + 1) * (x - xx)) % mod;

    return dp[idx][xx] = here;
}

class Solution {
public:
    int numberOfWays(int _n, int _x, int _y) {
        ::n = _n;
        ::x = _x;
        ::y = _y;
        dp = vector<vector<int>>(n + 1, vector<int>(x + 1, -1));  
        return f(1, 0);
    }
};
",1420064950
Ritik Rathor,ritik_369,113,3605,cpp,"int f(long long n)
{
    if(n == 2)return -1 ; 
    int x = n ^ 1 ; 
    long long a = 1 ; 
    for(int i = 0 ;  ; i += 1)
    {
        if(((n >> i) & 1) == 0)break ; 
        x = min(1ll*x , (n ^ (1ll << i))) ;
    }
    return x ; 
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>res;
        for(auto a:nums)
            res.push_back(f(a));
        return res;
    }
};",1420063107
Ritik Rathor,ritik_369,113,3611,cpp,"int f(long long n)
{
    if(n == 2)return -1 ; 
    int x = n ^ 1 ; 
    long long a = 1 ; 
    for(int i = 0 ;  ; i += 1)
    {
        if(((n >> i) & 1) == 0)break ; 
        x = min(1ll*x , (n ^ (1ll << i))) ;
    }
    return x ; 
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>res;
        for(auto a:nums)
            res.push_back(f(a));
        return res;
    }
};",1420063362
Ayush Singh,the_wiz,114,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tp) 
    {
        int n = s.size(), m = p.size(), dp[m + 1], fp[n + 1], lm = INT_MAX, ans = tp.size();
        for(int &x: dp) x = lm;
        memset(fp, 0, sizeof(fp));
        dp[0] = 0;
        for (int &x: tp) fp[x] = 1;
        for (int i = 0; i < n; i++) 
        {
            for (int j = m; j > 0; j--) 
            {
                if (s[i] == p[j - 1] && dp[j - 1] != lm)
                {
                    dp[j] = min(dp[j], dp[j - 1] + fp[i]);
                }
            }
        }
        if (dp[m] != lm) ans -= dp[m];
        return ans;
    }
};",1420065963
Ayush Singh,the_wiz,114,3604,cpp,"#define ll long long
const int MOD = 1e9 + 7;

class Solution {
public:

    ll bex(ll x, ll pow)
{
    if (x < 2) return x;
    ll ans = 1LL;
    while(pow != 0)
    { 
        if (pow & 1LL) ans = (ans * x) % MOD;
        x = (x * x) % MOD, pow >>= 1;
    }
    return ans;
}

ll s[1010][1010], f[1010], ivf[1010];

    int numberOfWays(int n, int x, int y) {

        ll mx = max(n, x);
         s[0][0] = 1;
         f[0] = 1;
         ivf[0] = 1;
    for (int i = 1; i <= 1000; ++i)
    {
        s[i][0] = 0;
        for (int j = 1; j <= i; ++j) 
        {
            s[i][j] = s[i - 1][j - 1];
            (s[i][j] += j * s[i - 1][j]);
            s[i][j] %= MOD;
        }
        f[i] = (f[i - 1] * i) % MOD;
        ivf[i] = bex(f[i], MOD - 2);
        // cout << ivf[i] << ' ';
    }
    ll ans = 0, mn = min(n, x);
    for(int i = 1; i <= mn; i++)
    {
        ll xp = s[n][i];
        // cout << xp << ' ';
        (xp *= f[x]) %= MOD;
        // cout << xp << ' ';
        (xp *= ivf[x - i]) %= MOD;
        // cout << xp << ' ';
        (xp *= bex(y, i)) %= MOD;
        // cout << xp << ' ';
        (ans += xp) %= MOD;
        // cout << '\n';
    }
    return (int) ans;
    }
};",1420054333
Ayush Singh,the_wiz,114,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) 
    {
        int n = a.size(), ans[1010];
        memset(ans, -1, sizeof(ans));
        for(int i = 0; i < 10000; i++)
        {
            int x = i | (i + 1);
            if (x <= 1000 && ans[x] == -1)
            {
                ans[x] = i;
            }
        }
        vector<int> r;
        for(int x: a) r.push_back(ans[x]);
        return r;
    }
};",1419996526
Ayush Singh,the_wiz,114,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) 
    {
        int n = a.size();
        vector<int> ans(n, -1);
        for(int j = 0; j < n; j++)
        {
            set<int> s;
            for(int i = 0; i < 32; i++)
            {
                if ((a[j] >> i) & 1)
                {
                    int y = a[j] & (~(1 << i));
                    y |= (y + 1);
                    if (a[j] == y)
                    {
                        s.insert(a[j] & (~(1 << i)));
                    }
                }
            }
            if (!s.empty()) ans[j] = *s.begin();
        }
        return ans;
    }
};",1420079985
tr1nity,tr1nity,115,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n, m, z = len(s), len(p), len(t)
        f = [0] * n
        for x in t: f[x] = 1
        dp = [n + 1] * (m + 1)
        dp[0] = 0
        for i in range(n):
            for j in range(m, 0, -1):
                if s[i] == p[j - 1]: 
                    if dp[j - 1] + f[i] < dp[j]:
                        dp[j] = dp[j - 1] + f[i]
        # print(dp)
        return z - dp[-1]",1420080140
tr1nity,tr1nity,115,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        M = 10 ** 9 + 7
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % M
        res = 0
        for i in range(1, min(x, n) + 1):
            w = math.comb(x, i)
            w = (w * pow(y, i, M)) % M
            w = (w * (math.factorial(i) % M)) % M
            w = (w * dp[n][i]) % M
            res = (res + w) % M
        return res",1420060978
tr1nity,tr1nity,115,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for x in nums:
            if x == 2 or x % 2 == 0: 
                res.append(-1)
                continue
            ones = 0
            p = x
            while p & 1:
                ones += 1
                p >>= 1
            if ones == 0: 
                res.append(-1)
                continue
            b = x - (1 << (ones - 1))
            res.append(b if b >= 0 and (b | (b + 1) == x) else -1)
        return res",1420007203
tr1nity,tr1nity,115,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for x in nums:
            if x == 2 or x % 2 == 0: 
                res.append(-1)
                continue
            ones = 0
            p = x
            while p & 1:
                ones += 1
                p >>= 1
            if ones == 0: 
                res.append(-1)
                continue
            b = x - (1 << (ones - 1))
            res.append(b if b >= 0 and (b | (b + 1) == x) else -1)
        return res",1420007110
Priyansh Kumar Singh,priyanshnikka,116,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        target_set = set(targetIndices)
        
        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(n):
            for j in range(m + 1):
                if dp[i][j] < dp[i + 1][j]:
                    dp[i + 1][j] = dp[i][j]
                if j < m and source[i] == pattern[j]:
                    cost = dp[i][j]
                    if i in target_set:
                        cost += 1
                    if cost < dp[i + 1][j + 1]:
                        dp[i + 1][j + 1] = cost
                        
        min_used = dp[n][m]
        total_target = len(targetIndices)
        max_ops = total_target - min_used
        return max_ops",1420072277
Priyansh Kumar Singh,priyanshnikka,116,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        S = [[0] * (x + 2) for _ in range(n + 2)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, min(i, x) + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD
        
        max_fact = max(n, x) + 1
        factorial = [1] * (max_fact + 1)
        for i in range(1, max_fact + 1):
            factorial[i] = (factorial[i - 1] * i) % MOD
        
        inv_fact = [1] * (max_fact + 1)
        inv_fact[max_fact] = pow(factorial[max_fact], MOD - 2, MOD)
        for i in range(max_fact - 1, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
        
        def binomial_coefficient(n, k):
            if k > n or k < 0:
                return 0
            return (factorial[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD
        
        result = 0
        for k in range(1, min(x, n) + 1):
            comb = binomial_coefficient(x, k)
            score = pow(y, k, MOD)
            perm = factorial[k]
            stir = S[n][k]
            term = comb * score % MOD
            term = term * perm % MOD
            term = term * stir % MOD
            result = (result + term) % MOD
        
        return result",1420080289
Priyansh Kumar Singh,priyanshnikka,116,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for num in nums:
            found = False
            for i in range(num):
                if (i | (i + 1)) == num:
                    answer.append(i)
                    found = True
                    break
            if not found:
                answer.append(-1)
        return answer",1420025612
Priyansh Kumar Singh,priyanshnikka,116,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            minin = float('inf')
            temp_num = num
            bit_pos = 0
            while temp_num > 0:
                if temp_num & 1:
                    x = num & ~(1 << bit_pos)
                    if (x | (x + 1)) == num:
                        if x < minin:
                            minin = x
                temp_num >>= 1
                bit_pos += 1
            if minin != float('inf'):
                ans.append(minin)
            else:
                ans.append(-1)
        return ans",1420030544
MrRobot,Noah_will,117,3487,java,"import java.util.*;

class Solution {
public int maxRemovals(String source, String pattern, int[] targetIndices) {
int n = source.length();
int m = pattern.length();
Set<Integer> targetSet = new HashSet<>();
for(int idx: targetIndices){
targetSet.add(idx);
}
long INF = Long.MAX_VALUE / 2;
long[] dp = new long[m + 1];
Arrays.fill(dp, INF);
dp[0] = 0;
for(int i =0;i<n;i++){
for(int j = m-1; j>=0; j--){
if(source.charAt(i)==pattern.charAt(j)){
long cost = dp[j] + (targetSet.contains(i)?1:0);
if(cost < dp[j+1]){
dp[j+1]=cost;
}
}
}
}
if(dp[m]==INF){
return 0;
}
return targetIndices.length - (int)dp[m];
}
}
",1420060587
MrRobot,Noah_will,117,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
    final int MOD = 1_000_000_007;
    long[][] S = new long[n + 1][n + 1];
    S[0][0] = 1;
    for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
    S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
    }
    }
    long[][] C = new long[x + 1][x + 1];
    for (int i = 0; i <= x; i++) {
    C[i][0] = 1;
    for (int j = 1; j <= i; j++) {
    C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
    }
    }
    long[] factorial = new long[x + 1];
    factorial[0] = 1;
    for (int k = 1; k <= x; k++) {
    factorial[k] = (factorial[k - 1] * k) % MOD;
    }
    int limit = Math.min(x, n);
    long[] y_pow = new long[limit + 1];
    y_pow[0] = 1;
    for (int k = 1; k <= limit; k++) {
    y_pow[k] = (y_pow[k - 1] * y) % MOD;
    }
    long sum = 0;
    for (int k = 1; k <= limit; k++) {
    long temp = C[x][k];
    temp = (temp * factorial[k]) % MOD;
    temp = (temp * S[n][k]) % MOD;
    temp = (temp * y_pow[k]) % MOD;
    sum = (sum + temp) % MOD;
    }
    return (int) sum;
    }
    }

",1420050868
MrRobot,Noah_will,117,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for(int i = 0; i < n; i++) {
    int x = nums.get(i);
    int min_a = Integer.MAX_VALUE;
    for(int bit = 0; bit < 32; bit++) {
    if((x & (1 << bit)) != 0) {
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)) {
    if(a < min_a) {
    min_a = a;
    }
    }
    }
    }
    ans[i] = (min_a == Integer.MAX_VALUE) ? -1 : min_a;
    }
    return ans;
    }
    }
",1420080292
MrRobot,Noah_will,117,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for(int i = 0; i < n; i++) {
    int x = nums.get(i);
    int min_a = Integer.MAX_VALUE;
    for(int bit = 0; bit < 32; bit++) {
    if((x & (1 << bit)) != 0) {
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)) {
    if(a < min_a) {
    min_a = a;
    }
    }
    }
    }
    ans[i] = (min_a == Integer.MAX_VALUE) ? -1 : min_a;
    }
    return ans;
    }
    }
",1420070679
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3487,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)



 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
        int left = 0, right = targetIndices.size();
        int n = source.size(), m = pattern.size();
        vector<long long> dp(m + 1, LLONG_MAX);
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != LLONG_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == LLONG_MAX ? 0 : dp[m]);
        
//         while (left <= right) {
//             int mid = left + (right - left) / 2;
//             vector<bool> removed(source.length(), false);
            
//             for (int i = 0; i < mid; i++) {
//                 removed[targetIndices[i]] = true;
//             }
            
//             if (isSubsequence(source, pattern, removed)) {
//                 left = mid + 1;
//             } else {
//                 right = mid - 1;
//             }
//         }
        
//         return right;
    }
    
private:
    bool isSubsequence(const string& source, const string& pattern, const vector<bool>& removed) {
        int i = 0, j = 0;
        while (i < source.length() && j < pattern.length()) {
            if (!removed[i] && source[i] == pattern[j]) {
                j++;
            }
            i++;
        }
        return j == pattern.length();
    }
};",1420054699
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3604,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)



 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}

template <class T>
T *lower_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return left;
}

template <class T>
T *upper_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (val < *middle)
            right = middle;
        else
            left = middle + 1;
    }
    return left;
}

template <class T>
T *binary_search(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle == val)
            return middle;
        else if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return nullptr; // If the element is not found, return nullptr
}

template<class T> T max(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result < data[i])
        {
            result = data[i];
        }
    }
    return result;
}

template<class T> T min(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result > data[i])
        {
            result = data[i];
        }
    }
    return result;
}
class Solution {
public:
    const int MOD = 1e9 + 7;

    ll mod_pow(ll a, ll b, int m) {
        ll r = 1; 
        a %= m; 
        while (b > 0) {
            if (b % 2) 
                r = (r * a) % m; 
            a = (a * a) % m; 
            b >>= 1; 
        }
        return r; 
    }

    ll mod_inv(ll a, int m) { 
        return mod_pow(a, m - 2, m); 
    }

    void precompute_factorials(int n, vector<ll>& f, vector<ll>& inv_f) { 
        f[0] = inv_f[0] = 1; 
        for (int i = 1; i <= n; i++) 
            f[i] = (f[i - 1] * i) % MOD; 
        inv_f[n] = mod_inv(f[n], MOD); 
        for (int i = n - 1; i >= 1; i--) 
            inv_f[i] = (inv_f[i + 1] * (i + 1)) % MOD; 
    }

    ll nCr(int n, int r, vector<ll>& f, vector<ll>& inv_f) { 
        if (r < 0 || r > n) 
            return 0; 
        return (((f[n] * inv_f[r]) % MOD) * inv_f[n - r]) % MOD; 
    }
    
    int numberOfWays(int n, int x, int y) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);  
        
        int m = max(n, x); 
        DBG(m);
        vector<ll> f(m + 1), inv_f(m + 1); 
        precompute_factorials(m, f, inv_f); 

        vector<ll> s(x + 1, 0), prev_s(x + 1, 0); 
        s[0] = 0; 
        s[1] = 1; 

        for (int i = 2; i <= n; i++) { 
            prev_s = s; 
            for (int k = 1; k <= min(i, x); k++) { 
                s[k] = (k * prev_s[k] % MOD + prev_s[k - 1]) % MOD; 
            } 
        }

        ll total = 0; 
        for (int k = 1; k <= min(n, x); k++) { 
            ll ways = nCr(x, k, f, inv_f);  
            ways = (ways * f[k]) % MOD;                   
            ways = (ways * s[k]) % MOD;                            
            ways = (ways * mod_pow(y, k, MOD)) % MOD;              
            total = (total + ways) % MOD; 
            cout << ways;
        } 
        DBG(total);
        return (int)total; 
    }
};",1420080390
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3605,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int x = 0;
            bool found = false;
            for (int i = 29; i >= 0; i--) {
                if ((num & (1 << i)) && !found) {
                    x |= (1 << i);
                    x--;
                    if ((x | (x + 1)) == num) {
                        found = true;
                    } else {
                        x++;
                    }
                }
            }
            ans.push_back(found ? x : -1);
        }
        return ans;
    }
};",1420000579
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3611,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int x = 0;
            bool found = false;
            for (int i = 29; i >= 0; i--) {
                if ((num & (1 << i)) && !found) {
                    x |= (1 << i);
                    x--;
                    if ((x | (x + 1)) == num) {
                        found = true;
                    } else {
                        x++;
                    }
                }
            }
            ans.push_back(found ? x : -1);
        }
        return ans;
    }
};",1420000320
leetgoat_dot_dev,leetgoat_dot_dev,121,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        idxSet = set(targetIndices)
        
        @cache
        def dp(i, j):
            # print(f'dp called on i={i} j={j}')
            # base case
            if i == len(source):
                # print(f'base case, end of source')
                # print(f'ret: {0 if j == len(pattern) else -inf} due to potential exhaustion of pattern')
                return 0 if j == len(pattern) else -inf
            if j == len(pattern):
                ifNoRemove = dp(i + 1, j)
                if i in idxSet:
                    ifRemove = 1 + dp(i + 1, j)
                else:
                    ifRemove = 0
                return max(ifNoRemove, ifRemove)
            
            if i in idxSet:
                ifRemove = 1 + dp(i + 1, j)
                ifNoRemove = dp(i + 1, j + (1 if source[i] == pattern[j] else 0))
                return max(ifRemove, ifNoRemove)
                
            if i not in idxSet:
                return dp(i + 1, j + (1 if source[i] == pattern[j] else 0))
            
        r = dp(0, 0)
        dp.cache_clear()
        return r
            ",1420013535
leetgoat_dot_dev,leetgoat_dot_dev,121,3604,python3,"class ModCalc:
    def __init__(self, n, mod):
        self.n = n
        self.mod = mod
        self.modFacts = self._buildModFacts()
        self.invModFacts = self._buildInvModFacts()
        self.stirling_numbers = self._buildStirlingNumbers()

    def _buildModFacts(self):
        modFacts = [1]  # 0!
        for i in range(1, self.n + 1):
            modFacts.append(self.modMul(modFacts[i - 1], i))
        return modFacts

    def _buildInvModFacts(self):
        invModFacts = [1] * (self.n + 1)
        invModFacts[self.n] = self.modInv(self.modFacts[self.n])
        for i in range(self.n, 0, -1):
            invModFacts[i - 1] = self.modMul(invModFacts[i], i)
        return invModFacts

    def _buildStirlingNumbers(self):
        n = self.n
        mod = self.mod
        stirling = [[0] * (n + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            stirling[i][0] = 0
            for k in range(1, i + 1):
                stirling[i][k] = (k * stirling[i - 1][k] + stirling[i - 1][k - 1]) % mod
        return stirling

    @cache
    def stirling2(self, n, k):
        if k < 0 or k > n:
            return 0
        return self.stirling_numbers[n][k]

    @cache
    def modInv(self, num):
        return self.modPow(num, self.mod - 2)

    def modMul(self, *args):
        result = 1
        for num in args:
            result = (result * num) % self.mod
        return result

    @cache
    def modPow(self, base, exponent):
        return pow(base, exponent, self.mod)

    @cache
    def modFact(self, n):
        return self.modFacts[n]

    @cache
    def modComb(self, n, k):
        if k < 0 or k > n:
            return 0
        return self.modMul(self.modFacts[n], self.invModFacts[k], self.invModFacts[n - k])

    def modPerm(self, n, k):
        if k < 0 or k > n:
            return 0
        return self.modMul(self.modFacts[n], self.invModFacts[n - k])

    def starsBars(self, balls, buckets):
        return self.modComb(balls + buckets - 1, buckets - 1)

MOD = 10**9 + 7
calc = ModCalc(1001, MOD)
    
    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        
        res = 0
        
          # find ways to distribute n performers into 1 band, then 2, then 3, etc
          # for each # of bands, find the # of ways to assign those bands 

        for bands in range(1, x + 1):
            partitions = calc.stirling2(n, bands)
            permutations = calc.modFact(bands)
            ways = calc.modComb(x, bands)
            scoreCombos = calc.modPow(y, bands)
            resHere = calc.modMul(partitions, permutations, ways, scoreCombos)
            res += resHere
        
        return res % MOD



    
# class Solution:
#     def numberOfWays(self, n: int, x: int, y: int) -> int:
#         # find ways to distribute n performers into 1 band, then 2, then 3, etc
#         # for each # of bands, find the # of ways to assign those bands 
        
#         calc = ModCalc(1001, 10**9 + 7)
        
#         res = 0
        
#         # partition people into `bands` non-empty bands
#         for bands in range(1, x + 1):
#             partitions = calc.stirling2(n, bands)
#             print(f'partitions: {partitions}')
            
#             # number of ways to get unique scores for all bands
            ",1420063679
leetgoat_dot_dev,leetgoat_dot_dev,121,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            added = False
            for lower in range(1, num):
                if lower | (lower + 1) == num:
                    res.append(lower)
                    added = True
                    break
            if not added:
                res.append(-1)
        return res",1420017033
leetgoat_dot_dev,leetgoat_dot_dev,121,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            resHere = inf
            
            for offset in range(32):
                if num >> offset & 1:
                    option = num - (2**offset)
                    if option < 0:
                        break
                    if option | (option + 1) == num:
                        resHere = min(resHere, option)
            res.append(resHere if resHere != inf else -1)
        return res
                        
        
#         # smallest bottom number we can take
#         @cache
#         def dp(numStr, hasCarry, i):
            
        
#         # 1 + 2 + 4 + 8 + 16 = 31
#         # 1 1 1 1 1
        
        
#         # 13
#         # 8 4 2 1
        
#         # 11 
#         # 8 2 1
#         # 1 0 1 1
#         # 
        
        
        
        
        
        
        
        
        
#         # binary search for smallest lower bound
#         def solve(target):
#             l = 1
#             r = 10
#             res = None
#             while l <= r:
#                 m = (r + l) // 2
#                 print(f'm is: {m}')
#                 tot = m | (m + 1)
#                 print(f'tot is: {tot}')
#                 if tot > target:
#                     print(f'tot too big, going down')
#                     r = m - 1
#                 elif tot == target:
#                     print(f'tot is good, going down')
#                     res = m
#                     r = m - 1
#                 else:
#                     print('tot too small, going up')
#                     l = m + 1
#             if res is None:
#                 return -1
#             return res
        
#         print(solve(5))
        
#         # return [solve(nums[i]) for i in range(len(nums))]
    
    
                    
            ",1420066942
Fatih,Qode_breaker,122,3487,python3,"from typing import List

class PatternMatcher:
    def __init__(self, source: str, pattern: str):
        self.source = source
        self.pattern = pattern
        self.source_length = len(source)
        self.pattern_length = len(pattern)
    
    def compute_dp(self, target_indices: List[int]) -> List[int]:
        dp = [float('inf')] * (self.pattern_length + 1)
        dp[0] = 0
        is_target = [False] * self.source_length
        
        for index in target_indices:
            is_target[index] = True
            
        for i in range(self.source_length):
            for j in range(self.pattern_length, 0, -1):
                if self.source[i] == self.pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if is_target[i] else 0))
        
        return dp

class Solution:
    def maxRemovals(self, source: str, pattern: str, target_indices: List[int]) -> int:
        matcher = PatternMatcher(source, pattern)
        dp = matcher.compute_dp(target_indices)
        
        return len(target_indices) - (0 if dp[matcher.pattern_length] == float('inf') else dp[matcher.pattern_length])

# Example usage:
# solution = Solution()
# print(solution.max_removals(""abcde"", ""ace"", [0, 2]))  # Example input
",1420055289
Fatih,Qode_breaker,122,3604,python3,"from typing import List

MOD = 10**9 + 7

class Combinatorics:
    def __init__(self, x: int):
        self.C = [[0] * (x + 1) for _ in range(x + 1)]
        self.fact = [1] * (x + 1)
        self._initialize_combinations(x)
        self._initialize_factorials(x)

    def _initialize_combinations(self, x: int):
        for i in range(x + 1):
            self.C[i][0] = 1
            for j in range(1, i + 1):
                self.C[i][j] = (self.C[i - 1][j - 1] + self.C[i - 1][j]) % MOD

    def _initialize_factorials(self, x: int):
        for i in range(1, x + 1):
            self.fact[i] = self.fact[i - 1] * i % MOD

class StirlingNumbers:
    def __init__(self, n: int, x: int):
        self.S = [[0] * (x + 1) for _ in range(n + 1)]
        self.S[0][0] = 1
        self._initialize_stirling(n, x)

    def _initialize_stirling(self, n: int, x: int):
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                self.S[i][j] = (j * self.S[i - 1][j] + self.S[i - 1][j - 1]) % MOD

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        comb = Combinatorics(x)
        stirling = StirlingNumbers(n, x)

        result = 0
        power_func = lambda k: pow(y, k, MOD)

        for k in range(1, x + 1):
            power = power_func(k)
            result = (result + comb.C[x][k] * stirling.S[n][k] % MOD * comb.fact[k] % MOD * power) % MOD

        return result
",1420081271
Fatih,Qode_breaker,122,3605,cpp,"class Solution {
public:
    int f(int p) {
        for (int x = 1; x <= p; ++x) {
            if ((x | (x + 1)) == p) {
                return x;
            }
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& n) {
        int s = n.size();
        vector<int> a(s, -1);
        for (int i = 0; i < s; ++i) {
            a[i] = f(n[i]);
        }
        return a;
    }
};",1420003271
Fatih,Qode_breaker,122,3611,cpp,"#include <vector>
#include <limits>

#define MAX_BITS 30
#define MAX_INT std::numeric_limits<int>::max()

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& input) {
        int size = input.size();
        std::vector<int> result(size);
        
        for (int idx = 0; idx < size; idx++) {
            result[idx] = findMinimalValue(input[idx]);
        }
        
        return result;
    }

private:
    int findMinimalValue(int currentNum) {
        int minResult = MAX_INT;
        bool isFound = false;
        
        for (int bitPos = 0; bitPos <= MAX_BITS; bitPos++) {
            if (isBitSet(currentNum, bitPos)) {
                int potentialCandidate = unsetBit(currentNum, bitPos);
                
                if (isValidCandidate(potentialCandidate, currentNum)) {
                    if (potentialCandidate < minResult) {
                        minResult = potentialCandidate;
                        isFound = true;
                    }
                }
            }
        }
        
        return isFound ? minResult : -1;
    }

    bool isBitSet(int number, int bitPos) {
        return ((number >> bitPos) & 1) == 1;
    }

    int unsetBit(int number, int bitPos) {
        return number & ~(1 << bitPos);
    }

    bool isValidCandidate(int candidate, int original) {
        return candidate >= 0 && (candidate | (candidate + 1)) == original;
    }
};
",1420049044
Akash,akash_y_codes,123,3487,java,"import java.util.*;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        int[] dp = initializeDP(patternLength);
        boolean[] isTargetIndex = markTargetIndices(sourceLength, targetIndices);

        for (int i = 0; i < sourceLength; i++) {
            updateDP(source, pattern, dp, isTargetIndex, i, patternLength);
        }

        return targetIndices.length - (dp[patternLength] == Integer.MAX_VALUE ? 0 : dp[patternLength]);
    }

    private int[] initializeDP(int patternLength) {
        int[] dp = new int[patternLength + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        return dp;
    }

    private boolean[] markTargetIndices(int sourceLength, int[] targetIndices) {
        boolean[] isTargetIndex = new boolean[sourceLength];
        for (int idx : targetIndices) {
            isTargetIndex[idx] = true;
        }
        return isTargetIndex;
    }

    private void updateDP(String source, String pattern, int[] dp, boolean[] isTargetIndex, int sourceIndex, int patternLength) {
        for (int j = patternLength; j > 0; j--) {
            if (source.charAt(sourceIndex) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTargetIndex[sourceIndex] ? 1 : 0));
            }
        }
    }
}
",1420081672
Akash,akash_y_codes,123,3604,java,"class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        long[][] C = computeCombinations(x);
        long[][] S = computeStirlingNumbers(n, x);
        long[] fact = computeFactorials(x);

        return computeResult(n, x, y, C, S, fact);
    }

    private long[][] computeCombinations(int x) {
        long[][] C = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }

    private long[][] computeStirlingNumbers(int n, int x) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    private long[] computeFactorials(int x) {
        long[] fact = new long[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    private int computeResult(int n, int x, int y, long[][] C, long[][] S, long[] fact) {
        long result = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return (int) result;
    }
}
",1420075108
Akash,akash_y_codes,123,3605,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            ans[i] = findMinimumAns(nums.get(i));
        }
        
        return ans;
    }

    private int findMinimumAns(int num) {
        for (int x = 0; x <= num; x++) {
            if ((x | (x + 1)) == num) {
                return x;
            }
        }
        return -1;
    }
}",1419993229
Akash,akash_y_codes,123,3611,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int length = nums.size();
        int[] result = new int[length];

        for (int index = 0; index < length; index++) {
            int currentNumber = nums.get(index);
            int minimalCandidate = Integer.MAX_VALUE;
            boolean candidateFound = false;

            for (int bitPosition = 0; bitPosition < 31; bitPosition++) {
                if ((currentNumber >> bitPosition & 1) == 1) {
                    int potentialCandidate = currentNumber & ~(1 << bitPosition);

                    if (potentialCandidate >= 0 && (potentialCandidate | (potentialCandidate + 1)) == currentNumber) {
                        if (potentialCandidate < minimalCandidate) {
                            minimalCandidate = potentialCandidate;
                            candidateFound = true;
                        }
                    }
                }
            }

            result[index] = candidateFound ? minimalCandidate : -1;
        }

        return result;
    }
}
",1420054863
toastedloaf,toastedloaf,124,3487,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;

int best[3030][3030];
int ok[3030];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int N = source.size();
        int M = pattern.size();
        FOR(i, N+1) {
            ok[i] = 0;
            FOR(j, M+1) {
                best[i][j] = -1;
            }
        }
        FOR(i, sz(targetIndices)) {
            ok[targetIndices[i]] = 1;
        }
        best[0][0] = 0;
        FOR(i, N) {
            FOR(j, min(M, i) + 1) {
                if(best[i][j] == -1) continue;
                best[i+1][j] = max(best[i+1][j], best[i][j]);
                if(source[i] == pattern[j]) {
                    best[i+1][j+1] = max(best[i+1][j+1], best[i][j]);
                }
                if(ok[i]) {
                    best[i+1][j] = max(best[i+1][j], best[i][j] + 1);
                }
            }
        }
        return best[N][M];
    }
};",1420060077
toastedloaf,toastedloaf,124,3604,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;

// N ~ 10^6
class Combinations {
public:
  vector<mint> inv, fact, ifact;

  Combinations() {}
    
  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};

mint pw(int x, int y) {
    if(!y) return mint(1);
    if(y%2) return pw(x, y-1) * x;
    mint z = pw(x, y/2);
    return z*z;
}

int ok = 0;
Combinations cb;

mint calc(int n, int k) {
    mint ret = 0;
    for(int i=0;i<=k;++i) {
        mint sgn = mint(1);
        if((k-i)%2) sgn *= -1;
        ret += sgn * cb.comb(k, i) * pw(i, n);
    }
    return ret;
    //return ret / cb.fact[k];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(!ok) {
            cb = Combinations(1000);
            ok = 1;
        }
        mint ret = 0;
        for(int k=1;k<=x;++k) {
            //cout<<calc(n, k) <<"" ""<<cb.comb(x, k)<<endl;
            ret += calc(n, k) * cb.comb(x, k) * pw(y, k);
        }
        return ret.x;
    }
};",1420038913
toastedloaf,toastedloaf,124,3605,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi v;
        FOR(i, sz(nums)) {
            int p = nums[i];
            if(p == 2) {
                v.pb(-1);
                continue;
            } else {
                int ret = 0;
                FOR(i, 30) {
                    if((p>>i)&1) {
                        ret += (1<<i);
                    } else {
                        ret += ((p>>i)<<i) - (1<<(i-1));
                        break;
                    }
                }
                v.pb(min(ret, p-1));
            }
        }
        return v;
    }
};",1420075951
toastedloaf,toastedloaf,124,3611,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi v;
        FOR(i, sz(nums)) {
            int p = nums[i];
            if(p == 2) {
                v.pb(-1);
                continue;
            } else {
                int ret = 0;
                FOR(i, 30) {
                    if((p>>i)&1) {
                        ret += (1<<i);
                    } else {
                        ret += ((p>>i)<<i) - (1<<(i-1));
                        break;
                    }
                }
                v.pb(min(ret, p-1));
            }
        }
        return v;
    }
};",1420075674
tyagimzn,tyagimzn,126,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        // Initialize dp array and target marking
        vector<int> dp = initializeDP(m);
        vector<bool> isTarget = markTargetIndices(targetIndices, n);

        // Update the dp array based on source and pattern
        updateDP(source, pattern, dp, isTarget, n, m);

        // Calculate and return the maximum removals
        return calculateMaxRemovals(dp, targetIndices.size());
    }

private:
    vector<int> initializeDP(int m) {
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // Base case
        return dp;
    }

    vector<bool> markTargetIndices(const vector<int>& targetIndices, int n) {
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    void updateDP(const string& source, const string& pattern, vector<int>& dp, const vector<bool>& isTarget, int n, int m) {
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
    }

    int calculateMaxRemovals(const vector<int>& dp, int targetCount) {
        return targetCount - (dp.back() == INT_MAX ? 0 : dp.back());
    }
};
",1420062372
tyagimzn,tyagimzn,126,3604,cpp,"#include <iostream>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

class Combinatorics {
public:
    vector<vector<int>> C;
    vector<int> fact;

    Combinatorics(int x) {
        C.resize(x + 1, vector<int>(x + 1, 0));
        fact.resize(x + 1, 1);
        initializeCombinations(x);
        initializeFactorials(x);
    }

private:
    void initializeCombinations(int x) {
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }

    void initializeFactorials(int x) {
        for (int i = 1; i <= x; i++) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
    }
};

class StirlingNumbers {
public:
    vector<vector<int>> S;

    StirlingNumbers(int n, int x) {
        S.resize(n + 1, vector<int>(x + 1, 0));
        S[0][0] = 1;
        initializeStirling(n, x);
    }

private:
    void initializeStirling(int n, int x) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
    }
};

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        Combinatorics comb(x);
        StirlingNumbers stirling(n, x);

        int result = 0;

        for (int k = 1; k <= x; k++) {
            int power = modPow(y, k);
            result = (result + (1LL * comb.C[x][k] * stirling.S[n][k] % MOD * comb.fact[k] % MOD * power) % MOD) % MOD;
        }

        return result;
    }

private:
    int modPow(int base, int exp) {
        int result = 1;
        while (exp) {
            if (exp % 2 == 1) {
                result = (1LL * result * base) % MOD;
            }
            base = (1LL * base * base) % MOD;
            exp /= 2;
        }
        return result;
    }
};

// Example usage
",1420083306
tyagimzn,tyagimzn,126,3605,python3,"class Solution:
    def findMinAns(self, prime):
        # Using a lambda to define the condition
        check = lambda x: (x | (x + 1)) == prime
        # Iterate over possible x values
        for x in range(1, prime + 1):
            if check(x):
                return x
        return -1  # If no such x exists, return -1

    def minBitwiseArray(self, nums):
        ans = [-1] * len(nums)  # Initialize ans array with -1 by default
        
        for i in range(len(nums)):
            ans[i] = self.findMinAns(nums[i])  # Find the minimum ans[i]
        
        return ans
",1420005407
tyagimzn,tyagimzn,126,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [self.find_minimal_ans(num) for num in nums]

    def find_minimal_ans(self, num: int) -> int:
        minimal_ans = float('inf')
        found = False
        
        for bit in range(31):
            if self.is_bit_set(num, bit):
                candidate = self.unset_bit(num, bit)
                
                if self.is_valid_candidate(candidate, num):
                    if candidate < minimal_ans:
                        minimal_ans = candidate
                        found = True
        
        return minimal_ans if found else -1

    def is_bit_set(self, num: int, bit: int) -> bool:
        return (num >> bit) & 1 == 1

    def unset_bit(self, num: int, bit: int) -> int:
        return num & ~(1 << bit)

    def is_valid_candidate(self, candidate: int, original: int) -> bool:
        return (candidate | (candidate + 1)) == original
",1420066124
Nguyễn Thảo,nguyenquocthao00,128,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        m,n = len(source), len(pattern)
        canremove = [False]*m
        for i in targetIndices: canremove[i]=True
        @lru_cache(None)
        def dp(i,j):
            if i==m:
                if j<n: return -m
                else: return 0
            if j==n:
                if canremove[i]: return 1 + dp(i+1,j)
                return dp(i+1,j)
            # keep
            if source[i]==pattern[j]: res=dp(i+1,j+1)
            else: res=dp(i+1,j)
            if canremove[i]: res=max(res, 1 + dp(i+1,j))
            return res
        return dp(0,0)


        ",1420030119
Nguyễn Thảo,nguyenquocthao00,128,3604,python3,"MOD = 10**9 + 7
@lru_cache(None)
def fac(v):
    if v==0: return 1
    return v*fac(v-1)%MOD
def mod_inverse(v):
    return pow(v, MOD-2, MOD)
@lru_cache(None)
def comb(x, i):
    return fac(x)*mod_inverse(fac(i) * fac(x-i))%MOD

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # for i,j in product(range(5),repeat=2):
        #     print(i+j, j, comb(i+j, j))
        # @lru_cache(None)
        # def combx(i):
        #     return comb(x, i)
        @lru_cache(None)
        def dp(x):
            res=0
            for i in range(1,x+1):
                res = (res + (-1)**(x-i)*comb(x,i) * pow(i,n,MOD))%MOD
            return res
        res=0
        for x2 in range(x+1):
            res += dp(x2)*comb(x,x2)*pow(y,x2,MOD)
            res = res%MOD
        return res
        
        ",1420076974
Nguyễn Thảo,nguyenquocthao00,128,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        m={}
        for i in range(1000):
            t = i|(i+1)
            if t not in m: m[t] = i
        def get(v):
            if v not in m: return -1
            return m[v]
        return [get(v) for v in nums]
        ",1419994791
Nguyễn Thảo,nguyenquocthao00,128,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # m={}
        # for i in range(1000):
        #     t = i|(i+1)
        #     if t not in m: 
        #         m[t] = i
        #         print(bin(i)[2:], bin(t)[2:])

        def get(v):
            if v==2: return -1
            nb = v.bit_length()
            # if (1<<nb)==v+1: return (1<<(nb-1))
            for i in range(nb+1):
                if v&(1<<i)==0:
                    return v - (1<<(i-1))
            


        # def get(v):
        #     if v not in m: return -1
        #     return m[v]
        return [get(v) for v in nums]
        ",1420010020
Ankit Kansal,ankitkansal173,129,3487,cpp,"class Solution {
public:
    int maxRemovals(string a, string b, vector<int>& v) {
        int n=a.size(),m=b.size();
        vector<vector<int>> dp(n+1,vector<int> (m+1,INT_MAX-n*5));
        vector<int> mp(n);
        for(auto i:v)mp[i]=1;
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                if(j==0){
                    dp[i][j]=0;
                    continue;
                }
                if(i==0)continue;
                dp[i][j]=dp[i-1][j];
                if(a[i-1]==b[j-1]){
                    dp[i][j]=min(dp[i][j],dp[i-1][j-1]+mp[i-1]);
                }
                // cout<<dp[i][j]<<"" "";
            }
            // cout<<""\n"";
            
        }
        int k=v.size();
        return k-dp[n][m];
        
    }
};",1420028771
Ankit Kansal,ankitkansal173,129,3604,cpp,"typedef long long ll;
long long power(long long x, long long y, long long p)
{
    long long res = 1;
    x=x%p; 
    while (y > 0) {
        if (y % 2 == 1) res = (res * x)%p;
        y = y >> 1;
        x = (x * x)%p;
    }
    return res % p;
}
const ll N=1e3+1;
ll factorialNumInverse[N + 1];
ll naturalNumInverse[N + 1];
ll fact[N + 1];
void InverseofNumber(ll p)
{
    naturalNumInverse[0] = naturalNumInverse[1] = 1;
    for (int i = 2; i <= N; i++)
        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
}
void InverseofFactorial(ll p)
{
    factorialNumInverse[0] = factorialNumInverse[1] = 1;
    for (int i = 2; i <= N; i++)
        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
}
void factorial(ll p)
{
    fact[0] = 1;
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % p;
    }
}
ll ncr(ll N, ll R, ll p)
{
    ll ans = ((fact[N] * factorialNumInverse[R])
              % p * factorialNumInverse[N - R])
             % p;
    return ans;
}


void start()
{
    ll p = 1000000007;
    InverseofNumber(p);
    InverseofFactorial(p);
    factorial(p);
} 

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        
        start();
        vector<long long> p(x+1);
        long long mod=1e9+7;
        for(long long i=1;i<=x;i++){
            p[i]=power(i,n,mod);
            for(ll j=0;j<i;j++){
                p[i]-=((ncr(i,j,mod)*p[j])%mod+mod)%mod;
                p[i]=(p[i]+mod)%mod;
            }
            cout<<p[i]<<"" "";
        }
        int h=0;
        for(long long i=1;i<=x;i++){
            h+=(((p[i]*power(y,i,mod))%mod)*ncr(x,i,mod))%mod;
            h%=mod;
        }
        return h;
    }
};",1420070372
Ankit Kansal,ankitkansal173,129,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        for(auto i:n){
            if(i%2==0){
                a.push_back(-1);
                continue;
            }
            int j=i;
            int k=1;
            while(j%2){
                j=j/2;
                k=k*2;
            }
            k=k/2;
            a.push_back(i-k);
        }
        return a;
        
    }
};",1420000637
Ankit Kansal,ankitkansal173,129,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        for(auto i:n){
            if(i%2==0){
                a.push_back(-1);
                continue;
            }
            int j=i;
            int k=1;
            while(j%2){
                j=j/2;
                k=k*2;
            }
            k=k/2;
            a.push_back(i-k);
        }
        return a;
        
    }
};",1420001943
Nihal,nsk_91,130,3487,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
#include <vector>
#include <string>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string var_200, string var_201, vector<int>& var_202) {
        int var_203 = var_200.size();
        int var_204 = var_201.size();
        vector<int> var_205(var_204 + 1, INT_MAX);
        var_205[0] = 0;
        vector<bool> var_206(var_203, false);

        int var_207 = 0;
        int var_208 = 1;
        int var_209 = 2;
        int var_210 = 3;
        int var_211 = var_207 + var_208 - var_209 + var_210;
        var_211 *= var_208;
        var_211 /= (var_210 + 1);
        var_211 -= var_209;
        var_211 = var_211 + var_209 - var_208;

        int var_212 = 0;
        while (var_212 < var_202.size()) {
            var_206[var_202[var_212]] = true;
            var_212++;
        }

        var_212 = 0;
        while (var_212 < var_203) {
            int var_213 = var_204;
            for (; var_213 > 0; --var_213) {
                switch (var_200[var_212] == var_201[var_213 - 1] && var_205[var_213 - 1] != INT_MAX) {
                    case true:
                        var_205[var_213] = min(var_205[var_213], var_205[var_213 - 1] + (var_206[var_212] ? 1 : 0));
                        break;
                    default:
                        break;
                }
            }
            var_212++;
        }

        switch (var_205[var_204] == INT_MAX) {
            case true:
                return var_202.size();
            default:
                return var_202.size() - var_205[var_204];
        }
    }
};
",1420060171
Nihal,nsk_91,130,3604,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
#include <vector>

class Solution {
private:
    const int var_200 = 1e9 + 7;
    
    std::vector<std::vector<long long>> var_201(int var_202) {
        std::vector<std::vector<long long>> var_203(var_202 + 1, std::vector<long long>(var_202 + 1, 0));
        
        int var_204 = 1, var_205 = 2, var_206 = 3, var_207 = 4;
        int var_208 = var_204 + var_205 - var_206;
        var_208 *= var_207;
        var_208 /= (var_204 + 1);
        var_208 += var_206 - var_205;
        var_208 -= var_207;

        int var_209 = 0;
        while (var_209 <= var_202) {
            var_203[var_209][0] = 1;
            int var_210 = 1;
            while (var_210 <= var_209) {
                var_203[var_209][var_210] = (var_203[var_209 - 1][var_210 - 1] + var_203[var_209 - 1][var_210]) % var_200;
                var_210++;
            }
            var_209++;
        }
        return var_203;
    }
    
    std::vector<std::vector<long long>> var_211(int var_212, int var_213) {
        std::vector<std::vector<long long>> var_214(var_212 + 1, std::vector<long long>(var_213 + 1, 0));
        var_214[0][0] = 1;

        int var_215 = 1;
        while (var_215 <= var_212) {
            int var_216 = 1;
            while (var_216 <= var_213) {
                var_214[var_215][var_216] = (var_216 * var_214[var_215 - 1][var_216] + var_214[var_215 - 1][var_216 - 1]) % var_200;
                var_216++;
            }
            var_215++;
        }
        return var_214;
    }
    
    std::vector<long long> var_217(int var_218) {
        std::vector<long long> var_219(var_218 + 1, 1);
        int var_220 = 1;
        while (var_220 <= var_218) {
            var_219[var_220] = (var_219[var_220 - 1] * var_220) % var_200;
            var_220++;
        }
        return var_219;
    }

public:
    int numberOfWays(int var_221, int var_222, int var_223) {
        auto var_224 = var_201(var_222);
        auto var_225 = var_211(var_221, var_222);
        auto var_226 = var_217(var_222);
        
        long long var_227 = 0;
        int var_228 = 1;
        while (var_228 <= var_222) {
            long long var_229 = 1;
            int var_230 = 0;
            while (var_230 < var_228) {
                var_229 = (var_229 * var_223) % var_200;
                var_230++;
            }
            long long var_231 = var_224[var_222][var_228];
            var_231 = (var_231 * var_225[var_221][var_228]) % var_200;
            var_231 = (var_231 * var_226[var_228]) % var_200;
            var_231 = (var_231 * var_229) % var_200;
            var_227 = (var_227 + var_231) % var_200;
            var_228++;
        }
        
        return static_cast<int>(var_227);
    }
};
",1420084393
Nihal,nsk_91,130,3605,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
class Solution {
public:
    int func_200(int var_200) {
        int var_201 = 1;
        while (var_201 <= var_200) {
            int var_202 = var_201 | (var_201 + 1);
            switch (var_202 == var_200) {
                case true:
                    return var_201;
            }
            ++var_201;
        }
        return -1;
    }

    vector<int> minBitwiseArray(vector<int>& var_203) {
        int var_204 = var_203.size();
        vector<int> var_205(var_204, -1);

        int var_206 = 0;
        while (var_206 < var_204) {
            var_205[var_206] = func_200(var_203[var_206]);
            ++var_206;
        }

        return var_205;
    }
};
",1420052249
Nihal,nsk_91,130,3611,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& var_200) {
        int var_201 = var_200.size();
        std::vector<int> var_202(var_201);
        
        int var_203 = 1, var_204 = 2, var_205 = 3, var_206 = 4;
        int var_207 = var_203 + var_204 - var_205;
        var_207 *= var_206;
        var_207 /= (var_203 + 1);
        var_207 += var_205 - var_204;
        var_207 -= var_206;

        int var_208 = 0;
        while (var_208 < var_201) {
            int var_209 = var_200[var_208];
            int var_210 = std::numeric_limits<int>::max();
            bool var_211 = false;
            
            int var_212 = 0;
            while (var_212 <= 30) {
                switch (((var_209 >> var_212) & 1) == 1) {
                    case true: {
                        int var_213 = var_209 & ~(1 << var_212);
                        switch (var_213 < 0) {
                            case true:
                                break;
                            default:
                                switch ((var_213 | (var_213 + 1)) == var_209) {
                                    case true:
                                        switch (var_213 < var_210) {
                                            case true:
                                                var_210 = var_213;
                                                var_211 = true;
                                                break;
                                            default:
                                                break;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                        }
                        break;
                    }
                    default:
                        break;
                }
                var_212++;
            }
            
            switch (var_211) {
                case true:
                    var_202[var_208] = var_210;
                    break;
                default:
                    var_202[var_208] = -1;
                    break;
            }
            var_208++;
        }
        
        return var_202;
    }
};
",1420065910
Varun Deep Saini,sojabhai,132,3487,cpp,"class Solution {
public:
    #define int long long
    vector<int> mp;
    int dp[3005][3005];
    vector<int> suffixSum;
    string s;
    string p;
    int n;
    int m;
    
    int rec(int indexS , int indexP){
        
        if(indexP == m) return suffixSum[indexS];
        
        if(indexS == n) return INT_MIN;
        
        int &ans = dp[indexS][indexP];
        
        if(ans != -1) return ans;
        
        ans = INT_MIN;
        
        if(s[indexS] == p[indexP]){
            
            int notTake = rec(indexS + 1 , indexP + 1);
            int take = INT_MIN;
            if(mp[indexS]){
                take = rec(indexS + 1 , indexP);
                take++;
            }
            
            ans = max(take , notTake);
            
        }else{
            ans = rec( indexS + 1 , indexP ) + mp[indexS]; 
        }
        
        return ans;
        
    }
    
    int maxRemovals(string source, string pattern, vector<int32_t> &targetIndices) {
        n = source.size();
        m = pattern.size();
        for(int i = 0 ;  i < n ; i++) for(int j = 0 ; j < m ; j++) dp[i][j] = -1;
        mp.assign(n , 0);
        suffixSum.assign(n + 1 , 0);
        s = source;
        p = pattern;
        for(auto &i : targetIndices) mp[i] = 1;
        for(int i = n - 1; i >= 0 ; i--){
            suffixSum[i] = suffixSum[i + 1] + mp[i];
        }
        
        int ans = rec( 0 , 0 );
        return max(ans , 0ll);
    }
    #undef int
};",1420077974
Varun Deep Saini,sojabhai,132,3604,cpp,"#define int long long
int z = 0;
const int N = 1000;
int dp[N + 1][N + 1];
int factorial[N + 1];
int invFactorial[N + 1];
    
const int MOD = 1e9 + 7;

class Solution {
public:
    int power(int x, int y) {
        int ans = 1;
        x %= MOD;
        while(y > 0){
            if(y & 1) ans = ans * x % MOD;
            x = x * x % MOD;
            y /= 2;
        }
        return ans;
    }
    
    void pre() {
        if(z) return;
        z = 1;
        memset(dp, -1, sizeof(dp));
        factorial[0] = 1;
        for(int i = 1; i <= N; ++i){
            factorial[i] = factorial[i-1] * i % MOD;
        }
        invFactorial[N] = power(factorial[N], MOD-2);
        for(int i=999; i>=0; --i){
            invFactorial[i] = invFactorial[i+1] * (i+1) % MOD;
        }
    }
    
    int rec(int n, int k){
        if(n == 0 && k == 0) return 1;
        if(n == 0 || k == 0) return 0;

        int &ans = dp[n][k];

        if(ans != -1){
            return ans;
        }

        ans = rec(n - 1 , k - 1);
        ans %= MOD;
        ans += (k * rec(n - 1, k)) % MOD;
        ans %= MOD;

        return ans % MOD;
    }
    
    int numberOfWays(int n, int x, int y) {
        pre();
        int ans = 0;
    
        for(int k = 1; k <= min(x, n); ++k){
            int a = factorial[x] * invFactorial[x - k];
            a %= MOD;
            
            int b = rec(n, k);
            b %+ MOD;
            
            int curr = (a * b);
            curr %= MOD;
            
            curr *= power(y, k);
            curr %= MOD;
            
            ans += curr;
            ans %= MOD;
        }
        
        return ans;
    }
};
#undef int
",1420028337
Varun Deep Saini,sojabhai,132,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto i : nums){
            int count = 0;
            int tmp = i;

            while(tmp & 1){
                count++;
                tmp/=2;
            }

            if(count == 0){
                ans.push_back(-1);
                continue;
            }

            long long sub = 1LL << (count -1);
            long long a = i - sub;
            if( (a | (a + 1)) == i ){
                ans.push_back(a);
            }else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};
",1419996083
Varun Deep Saini,sojabhai,132,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto i : nums){
            int count = 0;
            int tmp = i;

            while(tmp & 1){
                count++;
                tmp/=2;
            }

            if(count == 0){
                ans.push_back(-1);
                continue;
            }

            long long sub = 1LL << (count -1);
            long long a = i - sub;
            if( (a | (a + 1)) == i ){
                ans.push_back(a);
            }else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};
",1419995710
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        t = set(t)

        dp = [[-inf for _ in range(len(p)+1)] for _ in range(len(s)+1)]
        for j in range(len(p)+1):
            dp[len(s)][j] = -inf if j != len(p) else 0
        for i in range(len(s)-1, -1, -1):
            dp[i][len(p)] = int(i in t) + dp[i+1][len(p)]
        for i in range(len(s)-1, -1, -1):
            for j in range(len(p)-1, -1, -1):
                dp[i][j] = int(i in t) + dp[i+1][j]
                if s[i] == p[j]:
                    dp[i][j] = max(dp[i][j], dp[i+1][j+1])
        return dp[0][0]
",1420049672
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9+7
        dp = [[0 for _ in range(x+1)] for _ in range(n)]
        dp[0][1] = x
        for i in range(1, n):
            for j in range(1, x+1):
                dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (x - j + 1)
                dp[i][j] %= MOD
        # print(dp)
        ret = 0
        for j in range(1, x+1):
            ret += dp[n-1][j] * pow(y, j, MOD)
            ret %= MOD
        return ret",1420071252
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for x in nums:
            if x == 2:
                ret.append(-1)
                continue
            a = bin(x)[2:]
            c = 0
            f = 1
            for i in range(len(a)-1, -1, -1):
                t = int(a[i])
                if t:
                    if f:
                        if i != len(a) - 1:
                            c = 2 * c + 1
                    else:
                        c += 1 << (len(a) - 1 - i)
                else:
                    f = 0
            ret.append(c)
        return ret",1420012376
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for x in nums:
            if x == 2:
                ret.append(-1)
                continue
            a = bin(x)[2:]
            c = 0
            f = 1
            for i in range(len(a)-1, -1, -1):
                t = int(a[i])
                if t:
                    if f:
                        if i != len(a) - 1:
                            c = 2 * c + 1
                    else:
                        c += 1 << (len(a) - 1 - i)
                else:
                    f = 0
            ret.append(c)
        return ret
                

            ",1420011994
ritik6g,ritik6g,135,3487,php,"class Solution {

    /**
     * @param String $source
     * @param String $pattern
     * @param Integer[] $targetIndices
     * @return Integer
     */
  function maxRemovals($source, $pattern, $targetIndices) {
        $le = strlen($source);
        $pl = strlen($pattern);

        // $in = PHP_INT_MAX;
        // $dp = array_fill(0, $pl + 1, $in);
        // $dp[0] = 0;




        $ci = array_fill(0, $le, false);
        foreach ($targetIndices as $ix) {
            $ci[$ix] = true;
        }
        $in = PHP_INT_MAX;
        $dp = array_fill(0, $pl + 1, $in);
        $dp[0] = 0;




    //   $in = PHP_INT_MAX;
    //     $dp = array_fill(0, $pl + 1, $in);
    //     $dp[0] = 0;






        for ($i = 0; $i < $le; $i++) {
            for ($j = $pl - 1; $j >= 0; $j--) {
                if ($source[$i] === $pattern[$j]) {
                    $dp[$j + 1] = min($dp[$j + 1], $dp[$j] + ($ci[$i] ? 1 : 0));
                }
            }
        }


        // for ($i = 0; $i < $le; $i++) {
        //     for ($j = $pl - 1; $j >= 0; $j--) {
        //         if ($source[$i] === $pattern[$j]) {
        //             $dp[$j + 1] = min($dp[$j + 1], $dp[$j] + ($ci[$i] ? 1 : 0));
        //         }
        //     }
        // }






        if ($dp[$pl] === $in) {
            return 0;
        }
        $re = count($targetIndices) - $dp[$pl];
        return max($re, 0);
    }
}",1420078250
ritik6g,ritik6g,135,3604,php,"class Solution {
    public function numberOfWays($n, $x, $y) {
        $MOD = 1000000007;
        $cb = array_fill(0, $n + 1, array_fill(0, $x + 1, 0));
        $cb[0][0] = 1;

        for ($i = 1; $i <= $n; $i++) {
            for ($j = 1; $j <= min($i, $x); $j++) {
                $cb[$i][$j] = ($j * $cb[$i - 1][$j] + $cb[$i - 1][$j - 1]) % $MOD;
            }
        }


        // for ($i = 1; $i <= $n; $i++) {
        //     for ($j = 1; $j <= min($i, $x); $j++) {
        //         $cb[$i][$j] = ($j * $cb[$i - 1][$j] + $cb[$i - 1][$j - 1]) % $MOD;
        //     }
        // }





        $bn = array_fill(0, $x + 1, 0);
        $bn[0] = 1;

        for ($i = 1; $i <= $x; $i++) {
            for ($j = min($i, $x); $j >= 1; $j--) {
                $bn[$j] = ($bn[$j] + $bn[$j - 1]) % $MOD;
            }
        }


    //    for ($i = 1; $i <= $x; $i++) {
    //         for ($j = min($i, $x); $j >= 1; $j--) {
    //             $bn[$j] = ($bn[$j] + $bn[$j - 1]) % $MOD;
    //         }
    //     }




        $fc = array_fill(0, $x + 1, 0);
        $fc[0] = 1;

        for ($i = 1; $i <= $x; $i++) {
            $fc[$i] = ($fc[$i - 1] * $i) % $MOD;
        }

        $m = min($x, $n);
        $py = array_fill(0, $m + 1, 0);
        $py[0] = 1;


        // $m = min($x, $n);
        // $py = array_fill(0, $m + 1, 0);
        // $py[0] = 1;





        for ($k = 1; $k <= $m; $k++) {
            $py[$k] = ($py[$k - 1] * $y) % $MOD;
        }

        $rs = 0;

        for ($k = 1; $k <= $m; $k++) {
            $tp = ($bn[$k] * $fc[$k]) % $MOD;
            $tp = ($tp * $cb[$n][$k]) % $MOD;
            $tp = ($tp * $py[$k]) % $MOD;
            $rs = ($rs + $tp) % $MOD;
        }

        return (int) $rs;
    }
}
",1420068832
ritik6g,ritik6g,135,3605,kotlin,"class Solution {
    fun minBitwiseArray(ns: List<Int>): IntArray {
        val an = IntArray(ns.size)

        for (i in ns.indices) {
            val n = ns[i]
            var fd = false

            for (j in 0 until n) {
                if ((j or (j + 1)) == n) {
                    an[i] = j
                    fd = true
                    break
                }
            }


            //  for (j in 0 until n) {
            //     if ((j or (j + 1)) == n) {
            //         an[i] = j
            //         fd = true
            //         break
            //     }
            // }

            if (!fd) {
                an[i] = -1
            }
        }

        return an
    }
}
",1420064349
ritik6g,ritik6g,135,3611,php,"class Solution {
    function minBitwiseArray($ns) {
        $rs = array_fill(0, count($ns), 0);

        for ($i = 0; $i < count($ns); $i++) {
            $cn = $ns[$i];
            $mc = PHP_INT_MAX;

            for ($bi = 0; $bi < 31; $bi++) {
                if (($cn & (1 << $bi)) != 0) {
                    $ca = $cn & ~(1 << $bi);

                    if ($ca < 0 || $ca >= $cn) {
                        continue;
                    }

                    $nc = $ca + 1;

                    if (($ca | $nc) == $cn) {
                        if ($ca < $mc) {
                            $mc = $ca;
                        }
                    }
                }
            }

            $rs[$i] = ($mc != PHP_INT_MAX) ? $mc : -1;
        }

        return $rs;
    }
}
",1420063168
Ahmed_Ashraf,boAshraf,136,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> tar(n, 0);
        for (auto it : targetIndices) tar[it] = 1;

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1)); // DP table for memoization

        auto rec = [&](auto&& self, int i, int j) -> int {
            if (i == n) return (j==m?0:-1e9);

            int &ret = dp[i][j];
            if (~ret) return ret;

            ret = self(self, i + 1, j);

            if (tar[i]) {
                ret = max(ret, self(self, i + 1, j) + 1);
            }

            if (j<m&&source[i] == pattern[j]) {
                ret = max(ret, self(self, i + 1, j + 1));
            }

            return ret;
        };

        return rec(rec, 0, 0);
    }
};",1420020618
Ahmed_Ashraf,boAshraf,136,3604,cpp,"
class Solution {
public:
    const int MOD = 1e9 + 7;

    long long modPow(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));

        dp[0][0] = 1;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                dp[i][j] = (dp[i-1][j] * j) % MOD;

                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (x - (j-1))) % MOD;
            }
        }

        long long result = 0;
        for (int j = 1; j <= x; ++j) {
            result = (result + dp[n][j] * modPow(y, j, MOD)) % MOD;
        }

        return result;
    }
};",1420085441
Ahmed_Ashraf,boAshraf,136,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=nums[i];j++){
                if((j|(j+1))==nums[i]){ans[i]=j;break;}
            }
        }
        return ans;
    }
};",1419994216
Ahmed_Ashraf,boAshraf,136,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]==3)ans[i]=1;
            else if(nums[i]>3){
                int idx=-1;
                for(int b=0;b<30;b++){
                    if(!((nums[i]>>b)&1)){idx=b;break;}
                }
                ans[i]=(nums[i]^(1<<(idx-1)));
            }
        }
        return ans;
    }
};",1420000782
SR3mix,SR3mix,137,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& t) {
        int n = source.size();
        reverse(t.begin(), t.end());
        vector<vector<int>>dp(n+1, vector<int>(n+1,-1));
        dp[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            char c = source[i-1];
            if (t.size() && t.back() + 1 == i) {
                t.pop_back();
                dp[i][0] = 0;
                for (int j = 0; j <= n; j++) {
                    dp[i][j] = dp[i-1][j];
                    if (dp[i][j] > -1 && dp[i][j] < pattern.size() && pattern[dp[i][j]] == c) dp[i][j]++;
                    if (j > 0) dp[i][j] = max(dp[i][j], dp[i-1][j-1]);
                }
            }
            else {
                for (int j = 0; j <= n; j++) {
                    dp[i][j] = dp[i-1][j];
                    if (dp[i][j] > -1 && dp[i][j] < pattern.size() && pattern[dp[i][j]] == c) dp[i][j]++;
                }
            }
        }
        // for (auto i : dp) {
        //     for (auto j : i) {
        //         cout << j << "","";
        //     }
        //     cout << endl;
        // }
        // cout << endl;
        int ans = 0;
        for (int i = 0; i <= n; i++) if (dp[n][i] == pattern.size()) ans = i;
        return ans;
    }
};",1420078636
SR3mix,SR3mix,137,3604,cpp,"class Math {
    public:
    vector<long long> fact_vec,invfact_vec;
    vector<long long> fact_vec_pure;
    vector<long long> e10_vec;
    vector<int>primes,minp,isprime,phi;
    long long comb_M = -1;
    long long int powxy(long long int x, long long int y, long long M) {
        if (y == 0) return 1;
        if (y%2 == 1) return (x*powxy(x, y-1,M))%M;
        long long int t = powxy(x, y/2,M);
        return (t*t)%M;
    }
    void create_comb(long long maxChooseNumerator, long long M) {
        comb_M = M;
        if (fact_vec.size() > maxChooseNumerator) return;
        if (fact_vec.size() == 0) {
            fact_vec = {1,1};
            invfact_vec = {1,1};
        }
        long long startI = fact_vec.size();
        for (long long i = startI; i <= maxChooseNumerator+1; i++) {
            long long lastFact = fact_vec.back();
            long long currFact = (lastFact * i)%M;
            fact_vec.push_back(currFact);
        }
        invfact_vec.resize(fact_vec.size());
        invfact_vec[fact_vec.size()-1] = powxy(fact_vec.back(), M-2, M);
        for (long long i = maxChooseNumerator; i >= startI; i--) {
            long long lastInv = invfact_vec[i+1];
            long long currInv = (lastInv * (i+1))%M;
            invfact_vec[i] = currInv;
        }
    }
    long long factorial(long long n, long long M) {
        assert(comb_M == M);
        return fact_vec[n];
    }
    long long inv_factorial(long long n, long long M) {
        assert(comb_M == M);
        return invfact_vec[n];
    }
    long long comb(long long a, long long b, long long M) {
        assert(comb_M == M);
        return (((fact_vec[a] * invfact_vec[b])%comb_M) * invfact_vec[a-b])%comb_M;
    }
    long long mgcd(long long a, long long b, long long& x, long long& y) {
        if (b == 0) {x = 1; y = 0; return a;}
        long long x1, y1;
        long long d = mgcd(b, a % b, x1, y1);
        x = y1;
        y = x1 - y1 * (a / b);
        return d;
    }
    long long moddiv(long long a, long long  b, long long M) {
        a = a%M;
        long long x,y;
        long long g = mgcd(b,M,x,y);
        long long inv = (x%M + M)%M;
        return (inv * a)%M;
    }
    long long comb_pure(long long a, long long b) {
        long long numer = factorial_pure(a);
        long long denom1 = factorial_pure(b);
        long long denom2 = factorial_pure(a - b);
        return numer/(denom1 * denom2);
    }
    long long factorial_pure(long long n) {
        assert(n <= 20);
        if (fact_vec_pure.size() == 0) fact_vec_pure.push_back(1);
        while (fact_vec_pure.size() <= n) {
            long long val = fact_vec_pure.size();
            fact_vec_pure.push_back(fact_vec_pure.back() * val);
        }
        return fact_vec_pure[n];
    }
    long long exp10(int p) {
        assert(p <= 18);
        if (e10_vec.size() == 0) e10_vec.push_back(1);
        while (e10_vec.size() <= p) {
            e10_vec.push_back(e10_vec.back() * 10LL);
        }
        return e10_vec[p];
    }
    unsigned long long comb_2(unsigned long long num) {
        if (num%2 == 0) {return (num/2) * (num-1);}
        else {return ((num-1)/2) * num;}
    }
    long long safe_sqrt(long long x) {
        long long l = 0, r = x;
        while (l < r) {
            long long m = l + (r-l)/2 + (r-l)%2;
            long long allow = LLONG_MAX/m;
            if (m <= allow && m * m <= x) l = m;
            else r = m-1;
        }
        return l;
    }
    long long arith_seq_sum(long long first, long long last, long long diff) {
        long long endSum = first + last;
        long long nums = ((last - first)/diff) + 1;
        
        if (endSum%2 == 0) {return (endSum/2) * nums;}
        else {return (nums/2) * endSum;}
    }
    void SievePrimes(int n) {
        if (minp.size() == n+1) return;
        minp = vector<int>(n+1), isprime = minp;
        primes = {};
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {if (i * p > n) break; minp[i*p]=p;}
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    void SieveFull(int n) {
        if (phi.size() == n+1) return;
        phi = vector<int>(n+1);
        minp = vector<int>(n+1);
        isprime = phi;
        primes = {};
        phi[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                phi[i] = i - 1;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {
                if (i * p > n) {
                    break;
                }
                minp[i * p] = p;
                if (p == minp[i]) {
                    phi[i * p] = phi[i] * p;
                    break;
                }
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    vector<array<long long, 2>> prime_factorize(long long num) {
        vector<array<long long, 2>>res;
        for (auto p : primes) {
            if (p > num) break;
            int cnt = 0;
            while (num%p == 0) {
                num /= p;
                cnt++;
            }
            if (cnt) res.push_back({p,cnt});
        }
        if (num > 1) res.push_back({num,1});
        return res;
    }
    vector<int> get_factors(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        vector<int>res;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) res.push_back(i);
        }
        int start = res.size() - 1;
        for (int i = start; i >= 0; i--) {
            if ((num/res[i]) != res[i]) res.push_back(num/res[i]);
        }
        return res;
    }
    vector<int> get_factors_robust(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        set<int>s;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) {s.insert(i); s.insert(num/i);}
        }
        vector<int>res; for (auto i : s) res.push_back(i);
        return res;
    }
    vector<vector<long long>> matmul(vector<vector<long long>>&mat1, vector<vector<long long>>&mat2, long long M) {
        assert(mat1[0].size() == mat2.size());
        int m = mat1.size(), n = mat2[0].size();
        vector<vector<long long>>mat(m, vector<long long>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < mat1[0].size(); k++) {
                    long long add = mat1[i][k] * mat2[k][j];
                    if (M > 0) add %= M;
                    mat[i][j] += add;
                    if (M > 0) mat[i][j] %= M;
                }
            }
        }
        return mat;
    }
    vector<vector<long long>> mateye(int n) {
        vector<vector<long long>>res(n, vector<long long>(n));
        for (int i = 0; i < n; i++) res[i][i] = 1;
        return res;
    }
    vector<vector<long long>> matexp(vector<vector<long long>>&mat, long long p, long long M) {
        if (p == 0) return mateye(mat.size());
        if (p == 1) return mat;
        vector<vector<long long>>mat1 = matexp(mat, p/2, M);
        vector<vector<long long>>res = matmul(mat1, mat1, M);
        if (p%2) return matmul(res, mat, M);
        return res;
    }
    long long first_bit(long long num) {
        if (num == 0) return -1;
        if (num > INT_MAX) return 64 - __builtin_clzll(num) - 1;
        else return 32 - __builtin_clz(num) - 1;
    }
    long long log2(long long num) {
        return first_bit(num);
    }
    long long last_bit(long long num) {
        return __builtin_ctzll(num);
    }
    long long frombin(string &s) {
        long long res = 0;
        for (int shift = 0; shift < s.size(); shift++) {
            if (s[s.size() - shift - 1] == '1') {
                res += (1LL << shift);
            }
        }
        return res;
    }
    string tobin(long long num, int len) {
        string res = """"; for (int i = 0; i < len; i++) res += '0';
        for (int shift = 0; shift < 63; shift++) {
            if ((num & (1LL << shift)) != 0) res[len - shift - 1] = '1';
        }
        return res;
    }
    string toBase(long long n, long long b) {
        bool neg = false;
        if (n < 0) {neg = true;}
        n = abs(n);
        string ans = """";
        while (n > 0) {
            ans += to_string(n%b);
            n /= b;
        }
        if (ans.size() == 0) ans = ""0"";
        if (neg) ans += ""-"";
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
Math math;
typedef long long ll; 
ll M = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        math.create_comb(2500, M);
        ll run = 0;
        ll ans = 0;
        vector<ll>v(x+1);
        for (int use = 1; use <= x; use++) {
            ll ch = math.comb(x, use, M);
            ll ways = math.powxy(use,n,M);
    
            for (int i = use-1; i >= 1; i--) {
                ll sel = math.comb(use,i,M);
                if (true) {
                    ways = (ways + M - (sel * v[i])%M)%M;
                }
                else {
                    ways = (ways + (sel * v[i])%M)%M;
                }
            }
            ll get = (ch * ways)%M;
            v[use] = ways;
            ll scores = math.powxy(y,use,M);
            ll add = (get * scores)%M;
            //cout << use << "": "" << ch << "","" << ways << "","" << get << "","" << scores << "","" << add << endl;
            //run = (run + get)%M;
            ans = (ans + add)%M;
        }
        return ans;
    }
};",1420031806
SR3mix,SR3mix,137,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for (auto x : nums) {
            int use = log2(x) + 1;
            if (x == 2) {ans.push_back(-1); continue;}
            int d = 0;
            for (int b = 0; b < use; b++) {
                if (((1 << b) & x) != 0) {
                    x -= (1 << b);
                    d++;
                }
                else break;
            }
            x += ((1 << (d-1))-1);
            ans.push_back(x);
        }
        return ans;
    }
};",1420044258
SR3mix,SR3mix,137,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for (auto x : nums) {
            int use = log2(x) + 1;
            if (x == 2) {ans.push_back(-1); continue;}
            int d = 0;
            for (int b = 0; b < use; b++) {
                if (((1 << b) & x) != 0) {
                    x -= (1 << b);
                    d++;
                }
                else break;
            }
            x += ((1 << (d-1))-1);
            ans.push_back(x);
        }
        return ans;
    }
};",1420043806
Vitalii Nevidomyi,deadRabbit,139,3487,cpp,"int dp[3001][3001];

string S,P;
int C[3001];

int go(int x, int p) {
    if (p==P.size()) return 0;
    if (x==S.size()) return 1<<30;
    int &r = dp[x][p];
    if (r==-1) {
        r = go(x+1,p);
        // take:
        r = min(r, go(x+1,P[p]==S[x]?p+1:p) + C[x]);
    }
    return r;
}

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(C,0,sizeof(C)); 
        for (int x : targetIndices) C[x]=1;
        memset(dp,-1,sizeof(dp));
        S = source;
        P = pattern;
        return (int)targetIndices.size() - go(0,0);
    }
};",1420021585
Vitalii Nevidomyi,deadRabbit,139,3604,cpp,"const int mod = 1000 * 1000 * 1000 + 7;

int powmod(int x, int n) {
  int r = 1;
  while (n) {
    if (n & 1) {
      r = 1ll * r * x % mod;
    }
    n >>= 1;
    x = 1ll * x * x % mod;
  }
  return r;
}

int C[1001][1001];
int F[1001];

void pre() {
  C[0][0] = 1;
  F[0] = 1;
  for (int i = 1; i <= 1000; ++i) {
    F[i] = (1ll * F[i-1] * i) % mod;
    C[i][0] = C[i][i] = 1;
    for (int j = 1; j < i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
  }
}

class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    pre();

    long long res = 0;
    vector<long long> V(x+1,0);
    for (int m = 1; m <= x; ++m) {
      long long v = 0;
      if (n >= m) {
        v = powmod(m, n);
        for (int i = 1; i < m; ++i) {
          v = (v + mod - (V[i] * C[m][i] % mod)) % mod;
        }
      }
      V[m] = v;
      v = v * C[x][m] % mod;
      res = (res + v * powmod(y, m)) % mod;
    }
    return res;
  }
};",1420086344
Vitalii Nevidomyi,deadRabbit,139,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> r;
        for (int x : nums) {
            if (!(x&1)) r.push_back(-1);
            else {
                int c = 0;
                int y = x;
                while(y&1) {
                    ++c;
                    y/=2;
                }
                --c;
                r.push_back(x - (1<<c));
            }
        }
        return r;
    }
};",1420001552
Vitalii Nevidomyi,deadRabbit,139,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> r;
        for (int x : nums) {
            if (!(x&1)) r.push_back(-1);
            else {
                int c = 0;
                int y = x;
                while(y&1) {
                    ++c;
                    y/=2;
                }
                --c;
                r.push_back(x - (1<<c));
            }
        }
        return r;
    }
};",1420001897
Siddique13,Siddique13,142,3487,cpp,"class Solution {
    private:
    int tabuk(string s, string p, vector<int>& t) {
        int n = s.length();
        int m = p.length();
        vector<int> a(m + 1, INT_MAX);  
        a[0] = 0;
        vector<bool> x(n, false);  

        int k = 0;
        while (k < t.size()) {  
            x[t[k]] = true;
            k++;
        }

        int i = 0;
        while (i < n) {  
            int j = m;
            while (j > 0) {  
                if (s[i] == p[j - 1] && a[j - 1] != INT_MAX) {
                    a[j] = min(a[j], a[j - 1] + (x[i] ? 1 : 0));
                }
                j--;
            }
            i++;
        }

        return t.size() - (a[m] == INT_MAX ? 0 : a[m]);
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        return tabuk(source,pattern,targetIndices);
    }
};",1420056953
Siddique13,Siddique13,142,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, a: int, b: int, c: int) -> int:
        inputs = [a, b, c]
        comb = self.calc_comb(b)
        stirling = self.calc_stirling(a, b)
        fact = self.calc_fact(b)
        
        return self.compute_result(a, b, c, comb, stirling, fact)

    def calc_comb(self, x: int) -> List[List[int]]:
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        i = 0
        while i <= x:
            comb[i][0] = 1
            j = 1
            while j <= i:
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
                j += 1
            i += 1
        return comb

    def calc_stirling(self, n: int, x: int) -> List[List[int]]:
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        i = 1
        while i <= n:
            for j in range(1, x + 1):  # Used for-loop here
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
            i += 1
        return stirling

    def calc_fact(self, x: int) -> List[int]:
        fact = [1] * (x + 1)
        i = 1
        while i <= x:
            fact[i] = fact[i - 1] * i % MOD
            i += 1
        return fact

    def compute_result(self, n: int, x: int, y: int, comb: List[List[int]], stirling: List[List[int]], fact: List[int]) -> int:
        res = 0
        k = 1
        while k <= x:
            power = self.calc_power(y, k)
            res = (res + comb[x][k] * stirling[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
            k += 1
        return res

    def calc_power(self, base: int, exp: int) -> int:
        power = 1
        # Using a lambda function for exponentiation
        power_func = lambda b, e: (b * self.calc_power(b, e - 1)) % MOD if e > 0 else 1
        return power_func(base, exp)

",1420088375
Siddique13,Siddique13,142,3605,cpp,"class Solution {
    private:
    vector<int> irshad(std::vector<int>& p) {
        int n = p.size();
        std::vector<int> r(n, -1);  

        
        for (int i = 0; i < n; i++) {
            
            if (p[i] == 2) {
                continue; 
            }

            
            for (int x = 0; x <= p[i]; x++) {
                if ((x | (x + 1)) == p[i]) {
                    r[i] = x;
                    break;  
                }
            }
        }
        
        return r;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        return irshad(nums);

    }
};",1420021377
Siddique13,Siddique13,142,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        return self.irshad(nums)
    
    def irshad(self, w):
        x = len(w)
        z = [0] * x
        
        for y in range(x):
            m = w[y]
            r = float('inf')
            f = False
            
            for b in range(31):
                if ((m >> b) & 1) == 1:
                    c = m & ~(1 << b)
                    
                    if c < 0:
                        continue
                    
                    if (c | (c + 1)) == m:
                        if c < r:
                            r = c
                            f = True
            
            if f:
                z[y] = r
            else:
                z[y] = -1
        
        return z
        ",1420067213
Akuldeep,akuldeepj,143,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        fuckit = [False] * n
        for i in targetIndices:
            fuckit[i] = True

        befdp = [float('inf')] * (m + 1)
        currdp = [float('inf')] * (m + 1)
        befdp[0] = 0

        for i in range(n):
            currdp[0] = befdp[0]
            for j in range(m):
                currdp[j+1] = befdp[j+1]
                if source[i] == pattern[j]:
                    cost = befdp[j]
                    if fuckit[i]:
                        cost += 1
                    currdp[j+1] = min(currdp[j+1], cost)

            befdp, currdp = currdp, [float('inf')] * (m + 1)

        x = befdp[m]
        return len(targetIndices) - x",1420046058
Akuldeep,akuldeepj,143,3604,python3,"MOD = 10**9 + 7
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        maxk = min(n, x)
        hadd = n + x + 1
        
        fac = [1] * hadd
        inv = [1] * hadd

        for i in range(1, hadd):
            fac[i] = (fac[i - 1] * i) % MOD

        inv[hadd - 1] = pow(fac[hadd - 1], MOD - 2, MOD)
        for i in range(hadd - 2, -1, -1):
            inv[i] = (inv[i + 1] * (i + 1)) % MOD

        S = [[0] * (maxk + 2) for _ in range(n + 2)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, maxk + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD

        t = 0
        for k in range(1, maxk + 1):
            if x < k:
                continue
            comb = (fac[x] * inv[k] % MOD) * inv[x - k] % MOD

            perm = fac[k] % MOD
            a = S[n][k]
            num = pow(y, k, MOD)

            w = comb * perm % MOD
            w = w * a % MOD
            w = w * num % MOD

            t = (t + w) % MOD

        return t",1420068081
Akuldeep,akuldeepj,143,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        map = {}
        for i in range(2, 1001):
            f = all(i % j != 0 for j in range(2, int(i**0.5) + 1))
            if f:
                mila = False
                for x in range(i):
                    if (x | (x + 1)) == i:
                        map[i] = x
                        mila = True
                        break
                if not mila:
                    map[i] = -1
        return [map[i] for i in nums]",1419999820
Akuldeep,akuldeepj,143,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            minval = float('inf')
            f = False
            k = 0
            temp = i
            while temp > 0:
                if temp & 1:
                    x = i - (1 << k)
                    if x >= 0 and (x | (x + 1)) == i:
                        if x < minval:
                            minval = x
                            f = True
                temp >>= 1
                k += 1
            if f:
                ans.append(minval)
            else:
                ans.append(-1)
        return ans",1420030040
Thomas Draper,shaletome,144,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        ns=len(source)
        nt=len(targetIndices)
        dp=[0]
        sti=set(targetIndices)
        for i,c in enumerate(source):
            ndp=dp.copy()
            for j in range(len(dp)):
                v=dp[j]
                if v < len(pattern) and pattern[v]==c:
                    ndp[j]=max(ndp[j],v+1)
            if i in sti:
                ndp.append(0)
                for j in range(len(ndp)-1,0,-1):
                    ndp[j]=max(ndp[j],dp[j-1])
            dp = ndp
            # print(dp)
        return max([i for i in range(nt+1) if dp[i]==len(pattern)])",1420018634
Thomas Draper,shaletome,144,3604,python3,"combs=[[1]]
p=10**9+7
facs=[1]
for v in range(1,2050):
    facs.append((facs[-1]*v)%p)
for _ in range(2050):
    nf=[1]
    for a,b in zip(combs[-1],combs[-1][1:]):
        nf.append((a+b)%p)
    nf.append(1)
    combs.append(nf)
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # x^n assignments to stages
        # x assignments to 1 stage
        # (x choose 2) * (2^n) assignments to 2
        # (x choose 3) * (3^n) to 3
        # y^(numfilled) scores

        # x * y + (xc2)*(2^n)*(y^2) * ...
        global combs
        global p
        ans = 0
        ypow=1
        wayssf=[]
        for i in range(1,min(n,x)+1):
            ypow=(ypow*y)%p
            waysini = pow(i,n)-sum(combs[i][i-d]*wayssf[-d] for d in range(1,i))
            wayssf.append(waysini)
            v = waysini*combs[x][i]*ypow
            ans = (ans + v)%p
        return ans",1420089283
Thomas Draper,shaletome,144,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        
        ans=[]
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                v=0
                while n & (1<<(v+1)):
                    v += 1
                ans.append(n-(1<<v))
        return ans",1419997445
Thomas Draper,shaletome,144,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                v=0
                while n & (1<<(v+1)):
                    v += 1
                ans.append(n-(1<<v))
        return ans",1419996641
Pranav Raj,ThunderXGod,145,3487,cpp,"int zz;
class Solution {
public:
    int n, m, t;
    vector<int> ok;
    int maxRemovals(string s, string p, vector<int>& to) {
        n = (int)s.length();
        m = (int)p.length();
        t = (int)to.size();
        
        ok.resize(n);
        for(int &x: ok)
        {
            x -= x;
        }
        for(int &i: to)
        {
            ok[i]=1;
        }
        int dp[n + 5][m + 5];
        for(int i = 0; i < n + 1; i++)
        {
            for(int j = 0; j < m + 1; j++)
            {
                dp[i][j] = 2e9;
                if(!j)
                    dp[i][j] = 0;
            }
        }
        int i;
        i -= i;
        int j;
        i++;
        while(i < n + 1)
        {
            j -= j;
            j++;
            while(j - 1 < m)
            {
                int idx1 = i - 1;
                int idx2 = j - 1;
                char ch1 = s[idx1];
                char ch2 = p[idx2];
                int cnt = dp[idx1][j];
                if(!(ch1-ch2))
                {
                    int val = dp[idx1][idx2];
                    if(ok[idx1])
                    {
                        val += zz;
                        val++;
                    }
                    dp[i][j] = dp[idx1][j];
                    if(val <= dp[i][j])
                        dp[i][j] = val;
                }
                else
                {
                    dp[i][idx2+1] -= dp[i][j];
                    dp[idx1+1][idx2+1] += dp[idx1+zz][j<<zz];
                }
                j <<= zz;
                j++;
            }
            i++;
        }
        int left = dp[n][m];
        left <<= zz;
        if(t - left > zz)
            return t - zz - left;
        return 0;
    }
};",1420041711
Pranav Raj,ThunderXGod,145,3604,cpp,"const int M = 1e9 + 7;
int zz;
class Solution {
public:
    vector<long long> fac, pw;
    vector<vector<long long>> v1, v2;
    int numberOfWays(int &n, int &x, int &y) 
    {
        int mx = n;
        if(x >= mx)
            mx = x;
        fac.resize(n + 5);
        fac[0] = 1;
        func1(mx);
        int i = 1;
        pw.resize(n + 1);
        int chk = x + n;
        chk -= mx;
        pw[0] = 1;
        long long fans = 0, temp = 0;
        func2(n);
        while(i - 1 < n)
        {
            fac[i] = fac[i - 1];
            fac[i]*=i;
            fac[i]%=M;
            pw[i] = pw[i - 1];
            pw[i] *= y;
            pw[i] %= M;
            i++;
        }
        i-=i;
        while(i < chk)
        {
            temp += v1[x][i+1];
            temp %= M;
            if(!zz)
            temp *= v2[n][i+zz+1];
            temp %= M;
            temp *= pw[i-zz+1];
            temp += zz;
            temp %= M;
            if(!zz)
            temp *= fac[i+zz+1];
            temp %= M;
            fans += temp;
            fans %= M;
            temp -= temp;
            i++;
        }
        int ans = fans;
        return ans;
    }
    void func2(int &mx) 
    {
        int temp = mx;
        temp++;
        v2.resize(temp, vector<long long>(temp,zz));
        v2[zz][zz] -= v2[0][0];
        v2[zz][zz]++;
        int i;
        i -= i;
        i += zz;
        while(i - 1< mx)
        {
            int cur = zz;
            cur++;
            int idx = i - 1;
            while(cur < i + 1)
            {
                long long tt = 0;
                tt += v2[idx][-1+cur];
                tt += zz;
                long long val = v2[idx][cur];
                val *= (zz + 1);
                val *= cur;
                val %= M;
                val += (zz+tt);
                val %= M;
                v2[i][cur] = val;
                cur++;
            }
            i++;
        }
    }
    void func1(int &mx) 
    {
        int temp = mx;
        temp++;
        v1.resize(temp, vector<long long>(temp,zz));
        int i;
        i -= i;
        i += zz;
        while(i - 1< mx)
        {
            v1[i][0] -= v1[i][0];
            v1[i][zz]++;
            int cur = zz;
            cur++;
            while(cur < i + 1)
            {
                long long tt = v1[i-1][-1+cur];
                tt += v1[-1+i][cur+zz];
                tt %= M;
                v1[i][cur] = tt;
                cur++;
            }
            i++;
        }
    }
};
",1420089619
Pranav Raj,ThunderXGod,145,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        vector<int> ans;
        int mn;
        bool ok = 1;
        for(int &num: nums)
        {
            mn = ok - 2;
            int x = 0;
            while(x < num)
            {
                if(((x+1) | (x)) - num == 0)
                {
                    mn = x;
                    break;
                }
                x++;
            }
            ans.push_back(mn);
        }
        return ans;
    }
};",1419995749
Pranav Raj,ThunderXGod,145,3611,cpp,"const int neg = -1;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        vector<int> ans;
        int mn = 0;
        for(int &x: nums)
        {
            mn += neg;
            int i = neg;
            i++;
            while(i < 31)
            {
                if(x & (1 << i))
                {
                    int val = x;
                    int chk = (1ll<<i);
                    chk = ~chk;
                    val &= chk;
                    bool ok = true;
                    if(x <= val)
                        ok = false;
                    if(val < 0)
                        ok =false;
                    if(ok)
                    {
                        int mx = val;
                        mx |= (mx + 1);
                        if(!(mx-x))
                        {
                            if(neg - mn == 0)
                                mn = val;
                            else if(val < mn && neg)
                                mn = val;
                        }
                    }
                }
                i++;
            }
            if(neg)
            ans.push_back(mn);
            mn -= mn;
        }
        return ans;
    }
};",1420012917
Peter Lin,inversionpeter,148,3487,cpp,"int DP[3001][3001];
bool removable[3001];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(DP, 128, sizeof(DP));
        memset(removable, false, sizeof(removable));
        int maximum = 0;
        for (int i : targetIndices) {
            removable[i] = true;
        }
        DP[0][0] = 0;
        for (int i = 0; i != source.size(); ++i) {
            DP[i + 1][0] = DP[i][0] + removable[i];
            for (int j = 0; j < min((int)pattern.size(), i + 1); ++j) {
                DP[i + 1][j + 1] = DP[i][j + 1];
                if (source[i] == pattern[j]) {
                    DP[i + 1][j + 1] = max(DP[i + 1][j + 1], DP[i][j]);
                }
                if (removable[i]) {
                    DP[i + 1][j + 1] = max(DP[i + 1][j + 1], DP[i][j + 1] + 1);
                }
            }
            maximum = max(maximum, DP[i + 1][pattern.size()]);
        }
        /*for (int i = 0; i != source.size(); ++i) {
            for (int j = 0; j <= pattern.size(); ++j) {
                cout << DP[i + 1][j] << ' ';
            }
            cout << '\n';
        }
        cout << '\n';*/
        return maximum;
    }
};",1420043271
Peter Lin,inversionpeter,148,3604,cpp,"#define MOD 1000000007
int combination[1001][1001], factorials[1001], bands[1001][1001];

static const auto Initialize = [] {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    combination[0][0] = factorials[0] = bands[0][0] = 1;
    for (int i = 1; i <= 1000; ++i) {
        combination[i][0] = combination[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            combination[i][j] = combination[i - 1][j - 1] + combination[i - 1][j];
            if (combination[i][j] >= MOD) {
                combination[i][j] -= MOD;
            }
        }
        factorials[i] = ((long long)factorials[i - 1] * i) % MOD;
        bands[i][1] = bands[i][i] = 1;
        for (int j = 2; j < i; ++j) {
            bands[i][j] = (bands[i - 1][j - 1] + (long long)bands[i - 1][j] * j) % MOD;
        }
    }
    return nullptr;
}();

int FastPower(int base, int power) {
    int answer = 1, buffer = base;
    while (power) {
        if (power & 1) {
            answer = ((long long)answer * buffer) % MOD;
        }
        buffer = ((long long)buffer * buffer) % MOD;
        power >>= 1;
    }
    return answer;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int ways = 0, contribution;
        for (int i = 1; i <= x; ++i) {
            contribution = ((long long)combination[x][i] * FastPower(y, i)) % MOD;
            contribution = ((long long)contribution * factorials[i]) % MOD;
            contribution = ((long long)contribution * bands[n][i]) % MOD;
            ways += contribution;
            if (ways >= MOD) {
                ways -= MOD;
            }
        }
        return ways;
    }
};",1420089866
Peter Lin,inversionpeter,148,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> answer;
        for (int i : nums) {
            int ends = 0, buffer = i;
            while (buffer & 1) {
                ++ends;
                buffer >>= 1;
            }
            if (!ends) {
                answer.push_back(-1);
            }
            else {
                answer.push_back(i - (1 << ends) + 1);
                answer.back() += ((1 << (ends - 1)) - 1);
            }
        }
        return answer;
    }
};",1420002139
Peter Lin,inversionpeter,148,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> answer;
        for (int i : nums) {
            int ends = 0, buffer = i;
            while (buffer & 1) {
                ++ends;
                buffer >>= 1;
            }
            if (!ends) {
                answer.push_back(-1);
            }
            else {
                answer.push_back(i - (1 << ends) + 1);
                answer.back() += ((1 << (ends - 1)) - 1);
            }
        }
        return answer;
    }
};",1420002436
mxrush,littlemxrush,149,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, op_pos: List[int]) -> int:
        n, m = len(s), len(p)
        can_remove = [False] * n
        for pos in op_pos:
            can_remove[pos] = True
        inf = float(""inf"")
        f = [[-inf] * (m + 1) for _ in range(n+1)]
        f[0][0] = 0
        s = '@' + s
        p = '@' + p
        for i in range(1, n+1):
            f[i][0] = f[i-1][0]
            for j in range(0, m+1):
                f[i][j] = max(f[i-1][j] + (1 if can_remove[i-1] else 0), f[i][j])
                if s[i] == p[j] and j:
                    f[i][j] = max(f[i][j], f[i-1][j-1])
                # print(f""f[{i}][{j}] = {f[i][j]}"")
        return f[n][m]
        ",1420048883
mxrush,littlemxrush,149,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        f = [[0] * (x+1) for _ in range(n+1)]
        mod = 10**9 + 7
        f[0][0] = 1
        for i in range(1, n+1):
            # f[i][0] = 1
            for j in range(1, x+1):
                f[i][j] += f[i-1][j] * j
                f[i][j] %= mod
                f[i][j] += f[i-1][j-1] * (x - j + 1) * y
                f[i][j] %= mod
                # print(f""f[{i}][{j}] = {f[i][j]}"")
        ans = 0
        for i in range(1, x+1):
            ans = (ans + f[n][i]) % mod
        
        return ans",1420083421
mxrush,littlemxrush,149,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        # 111  11 | 100
        for x in a:
            for i in range(1, x+1):
                if i | (i + 1) == x:
                    ans.append(i)
                    break
            else:
                ans.append(-1)
                
        return ans",1420003943
mxrush,littlemxrush,149,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        # 111  11 | 100
        for x in a:
            if x == 2:
                ans.append(-1)
                continue
                
            y = x
            cnt = 0
            while y & 1:
                y >>= 1
                cnt += 1
            y = (y << cnt) | (1 << cnt - 1)
            print(x, y)            
            if y | (y - 1) == x:
                
                ans.append(min(y-1, x-1))
            else:
                ans.append(x-1)
        return ans",1420016605
turneja,turneja,152,3487,cpp,"int dp[3005][3005];
class Solution {
public:
    int suf[3005];
    
    bool rem[3005];
    
    int maxRemovals(string a, string b, vector<int>& targetIndices) {
        for (int i : targetIndices) {
            rem[i] = true;
        }
        int n = a.size(), m = b.size(); int j = m - 1;
        for (int i = n - 1; i >= 0; i--) {
            if (j >= 0 && a[i] == b[j]) {
                j--;
            }
            suf[i] = j;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = -1;
            }
        }
        
        int ans = 0;
        dp[0][0] = a[0] == b[0];
        if (rem[0]) {
            dp[0][1] = 0;
            if (n > 1 && suf[1] == -1) {
                ans = 1;
            }
        }
        
        for (int i = 1; i < n; i++) {
            if (dp[i - 1][0] == m) {
                dp[i][0] = m;
            } else {
                dp[i][0] = dp[i - 1][0] + (a[i] == b[dp[i - 1][0]]);
            }
            for (int j = 1; j <= n; j++) {
                if (dp[i - 1][j] == m) {
                    dp[i][j] = m;
                } else if (dp[i - 1][j] != -1) {
                    dp[i][j] = dp[i - 1][j] + (a[i] == b[dp[i - 1][j]]);
                }
                if (dp[i - 1][j - 1] != -1 && rem[i]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                }
                if (i == n - 1) {
                    if (dp[i][j] == m) {
                        ans = max(ans, j);
                    }
                } else {
                    if (dp[i][j] > suf[i + 1]) {
                        ans = max(ans, j);
                    }
                    
                }
                
            }
            //cout << dp[i][1] << "" "" << dp[i][2] << endl;
        }
        return ans;
    }
};",1420062733
turneja,turneja,152,3604,cpp,"const int M = 1e9 + 7;
const int N = 1005;
long long part[N][N];
long long inv[N];
long long fact[N];
long long factinv[N];
class Solution {
public:


    long long binomial(long long n, long long k) {
        return fact[n] * factinv[k] % M * factinv[n - k] % M;
    }
    
    
    long long modPow(long long a, long long y) {
        long long res = 1;
        while(y > 0) {
            if(y % 2 != 0) {
                res = (res * a) % M;
            }
            y /= 2;
            a = (a * a) % M;
        }
        return res;
    }
    
    void precalc() {
        fact[0] = 1, fact[1] = 1;
        factinv[0] = 1, factinv[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < N; i++) {
            inv[i] = M - (M / i) * inv[M % i] % M;
            fact[i] = fact[i - 1] * i % M;
            factinv[i] = factinv[i - 1] * inv[i] % M;
        }
        part[0][0] = 1;
        for (int i = 1; i < N; i++) {
            for (int j = 1; j < i; j++) {
                part[i][j] = (part[i - 1][j] * j +  part[i - 1][j - 1]) % M;
            }
            part[i][i] = 1;
        }
    }
    
    int numberOfWays(int n, int x, int y) {
        if (part[5][2] == 0) {
            precalc();
        }
        /*for (int i = 0; i <= 5; i++) {
            cout << part[5][i] << "" "";
        }
        cout << endl;*/
        long long ans = 0;
        for (int i = 1; i <= x; i++) {
            ans += part[n][i] * modPow(y, i) % M * binomial(x, i) % M * fact[i] % M;
        }
        return ans % M;
        
    }
};",1420083532
turneja,turneja,152,3605,cpp,"int par[1005];

class Solution {
public:
    void precalc() {
        for (int i = 2; i <= 1000; i++) {
            for (int j = 1; j <= i; j++) {
                int k = j | (j + 1);
                if (k == i) {
                    par[i] = j;
                    break;
                }
            }
            if (par[i] == 0) {
                par[i] = -1;
            }
        }
        
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        if (par[2] == 0) {
            precalc();
        }
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            ans.push_back(par[nums[i]]);
        }
        return ans;
        
    }
};",1419995742
turneja,turneja,152,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 2) {
                ans.push_back(-1);
                continue;
            }
            int cur = nums[i] - 1;
            int x = nums[i] / 2, p = x | (x + 1);
            if (p == nums[i]) {
                cur = nums[i] / 2;
            }
            int k = 2;
            while (k < cur) {
                int c = nums[i] & k;
                if (!c) {
                    k /= 2;
                    break;
                }
                k *= 2;
            }
            cur = min(cur, nums[i] - k);
            ans.push_back(cur);
        }
        return ans;
    }
};",1420014287
blackPanda890,adam_smith22,155,3487,cpp,"class Solution {
    public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    int n = source.size();
    int m = pattern.size();
    vector<bool> isTarget(n, false);
    for(auto idx : targetIndices){
    isTarget[idx] = true;
    }
    const long INF = 1e18;
    vector<long> dp(m + 1, INF);
    dp[0] = 0;
    for(int i = 0; i < n; i++) {
    for(int j = m - 1; j >= 0; j--){
    if(source[i] == pattern[j]){
    dp[j + 1] = min(dp[j + 1], dp[j] + (isTarget[i] ? 1 : 0));
    }
    }
    }
    if(dp[m] == INF){
    return 0;
    }
    return targetIndices.size() - static_cast<int>(dp[m]);
    }
    };
",1420063928
blackPanda890,adam_smith22,155,3604,cpp,"class Solution {
    public:
    const int MOD = 1000000007;

    int numberOfWays(int n, int x, int y) {
    
    vector<vector<long long>> S(n+1, vector<long long>(n+1, 0));
    S[0][0] = 1;
    for(int i=1;i<=n;i++){
    for(int j=1;j<=i;j++){
    S[i][j] = ( (j * S[i-1][j])%MOD + S[i-1][j-1] )%MOD;
    }
    }

    
    vector<vector<long long>> C(x+1, vector<long long>(x+1, 0));
    for(int i=0;i<=x;i++){
    C[i][0] = 1;
    for(int j=1;j<=i;j++){
    C[i][j] = ( (C[i-1][j] + C[i-1][j-1]) % MOD );
    }
    }

    
    vector<long long> factorial(x+1, 1);
    for(int k=1;k<=x;k++){
    factorial[k] = (factorial[k-1] * k) % MOD;
    }

    
    int limit = min(x, n);
    vector<long long> y_pow(limit+1, 1);
    for(int k=1;k<=limit;k++){
    y_pow[k] = (y_pow[k-1] * (long long)y) % MOD;
    }

    
    long long sum = 0;
    for(int k=1;k<=limit;k++){
    long long temp = (C[x][k] * factorial[k]) % MOD;
    temp = (temp * S[n][k]) % MOD;
    temp = (temp * y_pow[k]) % MOD;
    sum = (sum + temp) % MOD;
    }

    return (int)sum;
    }
    };
",1420045199
blackPanda890,adam_smith22,155,3605,cpp,"class Solution {
    public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
    std::vector<int> ans;
    for(auto x : nums){
    std::vector<int> candidates;
    for(int bit = 0; bit < 32; bit++){
    if(x & (1 << bit)){
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)){
    candidates.push_back(a);
    }
    }
    }
    if(candidates.empty()){
    ans.push_back(-1);
    }
    else{
    int min_a = *std::min_element(candidates.begin(), candidates.end());
    ans.push_back(min_a);
    }
    }
    return ans;
    }
    };
",1420077384
blackPanda890,adam_smith22,155,3611,cpp,"class Solution {
    public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
    std::vector<int> ans;
    for(auto x : nums){
    std::vector<int> candidates;
    for(int bit = 0; bit < 32; bit++){
    if(x & (1 << bit)){
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)){
    candidates.push_back(a);
    }
    }
    }
    if(candidates.empty()){
    ans.push_back(-1);
    }
    else{
    int min_a = *std::min_element(candidates.begin(), candidates.end());
    ans.push_back(min_a);
    }
    }
    return ans;
    }
    };
",1420067102
Teemu Ryyti,delivery,156,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(), m = p.size();
        vector<int> b(n);
        for (auto x: t) {
            b[x] = 1;
        }
        vector<vector<int>> d(n + 1, vector<int> (m + 1, -2 * n - 100));
        d[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                d[i+1][j] = d[i][j];
                if (b[i]) {
                    d[i+1][j] = d[i][j] + 1;
                }
            }
            for (int j = 0; j < m; ++j) {
                if (s[i] == p[j]) {
                    d[i+1][j+1] = max(d[i+1][j+1], d[i][j]);
                }
            }
        }
        return d[n][m];
    }
};",1420032110
Teemu Ryyti,delivery,156,3604,cpp,"using ll = long long;
class Solution {
public:
    ll fast(ll x, ll d) {
        if (d == 0) {
            return 1;
        }
        ll y = fast(x, d / 2);
        y = (y * y) % mod;
        if (d % 2 == 1) {
            y = (y * x) % mod;
        }
        return y;
    }
    
    ll b(int n, int k) {
        if (k > n) {
            return 0;
        }
        ll res = (f[n] * fi[n-k]) % mod;
        res = (res * fi[k]) % mod;
        return res;
    }
    
    int numberOfWays(int n, int x, int y) {
        f.assign(x + 1, 1);
        fi.assign(x + 1, 1);
        for (int  i = 1; i <= x; ++i) {
            f[i] = (f[i-1] * i) % mod;
            fi[i] = fast(f[i], mod-2);
        }
        vector<vector<ll>> d(n+1, vector<ll> (x+1));
        d[1][1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= min(i, x); ++j) {
                d[i][j] = (d[i-1][j-1] + j * d[i-1][j]) % mod;
            }
        }
        
        ll ans = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            ll cur = b(x, k) * f[k];
            cur %= mod;
            cur = (cur * d[n][k]) % mod;
            cur = (cur * fast(y, k));
            ans = (ans + cur) % mod;
        }
        return (ans + mod) % mod;
    }
    ll mod = 1000 * 1000 * 1000 + 7;
    vector<ll> f, fi;
};",1420091589
Teemu Ryyti,delivery,156,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            if (nums[i] % 2 == 1) {
                int k = 0;
                for (int j = 0; j < 31; ++j) {
                    if (!((nums[i] >> j) & 1)) {
                        k = j;
                        break;
                    }
                }
                int res = nums[i];
                res -= (1 << (k - 1));
                ans[i] = res;
            }
        }
        return ans;
    }
};",1420000892
Teemu Ryyti,delivery,156,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            if (nums[i] % 2 == 1) {
                int k = 0;
                for (int j = 0; j < 31; ++j) {
                    if (!((nums[i] >> j) & 1)) {
                        k = j;
                        break;
                    }
                }
                int res = nums[i];
                res -= (1 << (k - 1));
                ans[i] = res;
            }
        }
        return ans;
    }
};",1420001209
Arpit Rastogi,arpitras,159,3487,cpp,"class Solution {
public:
#define nl '\n'
#define ld long double
#define endl '\n'
#define vi vector<int>
#define pii pair<int, int>
#define fr first
#define sc second
#define sp "" ""
#define mkpr make_pair
#define sz(x) x.size()
#define all(x) (x).begin(), (x).end()
#define gcd(a, b) __gcd(a, b)
#define vpi vector<pii>
#define vvi vector<vi>
#define vvpi vector<vpi>
    bool check(string &s, string &p)
    {
        int idx=0;
        for(int i=0;i<s.size();i+=1)
        {
            if(idx==p.size())
              return 1;
            if(s[i]==p[idx])
                 idx++;
        }
        if(idx==p.size())
        return 1;
        return 0;
    }
    int maxRemovals(string s, string p, 
    vector<int>& targetIndices) 
    {
        int n = s.length();
        int m = p.length();

        vi dp(m + 1,1e9);
        dp[0] = 0;

        vi ok(n, 0);
        for (int i : targetIndices) 
        {
            ok[i] = true;
        }

        for (int i = 0; i < n; ++i) 
        {
            for (int j = m; j > 0; --j) 
            {
                if (s[i] == p[j - 1] && dp[j - 1] != 1e9) 
                {
                    dp[j] = min(dp[j],
                   dp[j - 1] + (ok[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] ==1e9? 0 : dp[m]);
       
    }
};",1420092304
Arpit Rastogi,arpitras,159,3604,cpp,"class Solution {
public:
#define int long long
int modu= 1e9+7;
long long bin_exponent(int a, int b, int c = 1e9 + 7)
{
    int ans = 1;
    while (b)
    {
        if (b % 2 == 1)
        {
            ans = (1LL * ans * a) % c;
        }
        a = (1LL * a * a) % c;
        b /= 2;
    }
    ans += c; ans %= c;
    return ans;
}
int nn,xxx, yy;
int dp[1005][1005];
    int rec(int idx, int xx)
{
    if(idx==nn)
    {
        int cost= bin_exponent(yy,xxx-xx,modu) ;
        return cost;
    }
    if(dp[idx][xx]!=-1)
     return dp[idx][xx];
    int ans=0;
    // used
    int temp = (xxx-xx)* rec(idx+1,xx);
    ans += temp;
    ans += modu;
    ans %= modu;
    // unused
    if(xx>0)
   { int temp = xx * rec(idx+1,xx-1);
   ans += temp;
    ans += modu;
    ans %= modu;}
    return  dp[idx][xx]= ans;

}

    int numberOfWays(int n, int x, int y) {
        nn=n; xxx=x; yy=y;
        memset(dp,-1,sizeof(dp));
        return rec(0,x);
    }
    #undef int 
};",1420080379
Arpit Rastogi,arpitras,159,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n= nums.size();
        vector<int> ans;
        for(auto p: nums)
        {
            if(p==2)
              {  ans.push_back(-1); continue;}
            int mn=1e9;
            for(int i=1;i<=p-1;i+=1)
            {
                if((i|(i+1)) == p )
                mn= min(mn,i);
            }
            ans.push_back(mn);
        }
        return ans;
    }
};",1420007207
Arpit Rastogi,arpitras,159,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums)
     {
        int n= nums.size();
        vector<int> ans;
        for(int i=0;i<n;i+=1)
        {
            if(nums[i]==2)
            {
                ans.push_back(-1);
                continue;
            }
            int mxp=0;
            for(int j=0; j<32;j+=1)
            {
                if((nums[i]&(1LL<<j)))
                {
                    mxp= max(mxp,j);
                }
                else
                 break;
            }
            ans.push_back(nums[i]-(1LL<<mxp));
        }
        return ans;
    }
};",1420016482
育志 林,ttthetravelerrr,162,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& t) {
        int n = source.size();
        int m = t.size();
        int p = pattern.size();
        vector<vector<int>> v(n , vector<int>(m+1, -1));
        int res = 0;
        int idx = 0;
        if(source[0] == pattern[0])
            v[0][0] = 1;
        else
            v[0][0] = 0;
        if(t[0] == 0)
        {
            v[0][1] = 0;
            ++idx;
        }
        for(int i = 1 ; i < n ; ++i)
        {
            int l = v[i-1][0];
            if(l == p)
                v[i][0] = p;
            else if(pattern[l] == source[i])
                v[i][0] = l + 1;
            else
                v[i][0] = l;
            if(idx < m && t[idx] == i)
            {
                // neglectable
                for(int j = 1 ; j <= m ; ++j)
                {
                    v[i][j] = v[i-1][j-1];
                    if(v[i][j] == p)
                        res = max(res, j);
                }
                ++idx;
            }
            for(int j = 1 ; j <= m ; ++j)
            {
                int last = v[i-1][j];
                if(last == -1)
                    break;
                if(last != p && pattern[last] == source[i])
                {
                    v[i][j] = max(v[i][j], v[i-1][j] + 1);
                }
                else
                {
                    v[i][j] = max(v[i][j], v[i-1][j]);
                }
                if(v[i][j] == p)
                    res = max(res, j);
            }
        }
/*
        for(int i = 0 ; i < n ; ++i)
        {
            for(int j = 0 ; j < m ; ++j)
                cout << v[i][j] << ' ';
            cout << endl;
        }*/
        return res;
    }
};",1420093237
育志 林,ttthetravelerrr,162,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        // [existing players][existing stages]
        vector<vector<long long>> v(n + 1, vector<long long>(x + 1, 0));
        v[1][1] = y * x;
        for(int i = 2 ; i <= n ; ++i)
        {
            v[i][1] = y * x;
            for(int j = 2 ; j <= x ; ++j)
            {
                v[i][j] += v[i-1][j] * j;
                v[i][j] += v[i-1][j-1] * y * (x - j + 1);
                v[i][j] %= mod;
            }
        }
        long long res = 0;
        for(auto ll : v[n])
        {
            res += ll;
        }

        return res % mod;
    }
};",1420050789
育志 林,ttthetravelerrr,162,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int& i : nums)
        {
            if(i == 2)
                i = -1;
            else
            {
                int t = 1;
                while((i & t) > 0)
                    t <<= 1;
                t >>= 1;
                i = i - t;
            }
        }
        return nums;
    }
};",1419997060
育志 林,ttthetravelerrr,162,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int& i : nums)
        {
            if(i == 2)
                i = -1;
            else
            {
                unsigned int t = 1;
                while(((2 * t) & i) == (2 * t))
                    t <<= 1;
                i = i - t;
            }
        }
        return nums;
        
    }
};",1420000395
Shubham Baban Shinde,shubham6762,163,3487,cpp,"class Solution
{
    vector<vector<int>> dp;
    vector<bool> isT;
    int solve(int i, int j, string &src, string &pat, int m, int n)
    {
        if (j == m)
            return 0;
        if (i == n)
            return n + 1;

        if (dp[i][j] != -1)
            return dp[i][j];

        int res = n + 1;

        if (src[i] == pat[j])
            res = min(solve(i + 1, j + 1, src, pat, m, n) + (isT[i] ? 1 : 0), solve(i + 1, j, src, pat, m, n));
        else
            res = solve(i + 1, j, src, pat, m, n);

        return dp[i][j] = res;
    }

public:

    int maxRemovals(string src, string pat, vector<int> &ti)
    {
        int n = src.size(), m = pat.size();
        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));
        isT = vector<bool>(n);

        for (auto &it : ti)
            isT[it] = true;

        solve(0, 0, src, pat, m, n);

        return dp[0][0] > ti.size() ? 0 : (ti.size() - dp[0][0]);
    }
};
",1420058716
Shubham Baban Shinde,shubham6762,163,3604,cpp,"class Solution
{
#define ll long long

public:
    const ll MOD = 1e9 + 7;
    vector<vector<ll>> dp;
    int n, x;

    ll powerMOD(int a, int b)
    {
        ll ans = 1, base = a % MOD;

        while (b > 0)
        {
            if (b % 2 == 1)
                ans = ans * base % MOD;
            b /= 2;
            base = base * base % MOD;
        }
        return ans;
    }

    int solve(int i, int k)
    {
        if (i == 0)
            return k == 0;
        if (k < 0 || k > x || k > i)
            return 0;

        if (dp[i][k] != -1)
            return dp[i][k];

        return dp[i][k] = ((ll)solve(i - 1, k) * k % MOD + (ll)solve(i - 1, k - 1) * (x - (k - 1)) % MOD) % MOD;
    }

    int numberOfWays(int n, int x, int y)
    {
        this->n = n, this->x = x;
        dp.assign(n + 1, vector<ll>(x + 1, -1));

        int cnt = 0;
        for (int k = 1; k <= x; ++k)
            cnt = (cnt + (ll)solve(n, k) * powerMOD(y, k) % MOD) % MOD;

        return cnt;
    }
};",1420086280
Shubham Baban Shinde,shubham6762,163,3605,cpp,"class Solution {
    #define ll long long
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = nums.size();
        vector<int> ans;

        
        for(auto &p : nums)
        {
            bool f = true;
            for(ll it = 0; it < p; ++it)
            {
                if( (it | (it + 1)) != p )
                    continue;
                f = false;
                ans.push_back(it);
                break; 
            }
            
            if (f)
                ans.push_back(-1);
        }
        
        return ans;
    }
};
",1420001930
Shubham Baban Shinde,shubham6762,163,3611,cpp,"class Solution
{
    #define ll long long
public:
    vector<int> minBitwiseArray(vector<int> &nums)
    {
        vector<int> ans;
        ll val = INT32_MAX;

        for (auto &p : nums)
        {
            val = INT32_MAX;
            
            if ((p & (p - 1)) == 0)
            {
                ans.push_back(-1);
                continue;
            }

            for (int b = 0; b < 31; ++b)
            {
                if ((p >> b) & 1)
                {
                    ll temp = p - (1 << b);
                    if (temp >= 0 && ((temp | (temp + 1)) == p))
                        val = min(val, temp);
                }
            }

            ans.push_back((int)((val != INT32_MAX) ? val : -1));
        }

        return ans;
    }
};",1420019699
Upayan De,twoplusthree,165,3487,cpp,"class Solution {
public:
  int maxRemovals(string s, string p, vector<int> &tar) {
    const int INF = 1e6 + 5;
    int n = (int)s.size();
    int m = (int)p.size();
    set<int> tars(tar.begin(), tar.end());
    int dp[n + 1][m + 1];
    dp[n][m] = 0;
    for(int i = n - 1; i >= 0; i--) {
      dp[i][m] = (tars.find(i) != tars.end() ? 1 : 0) + dp[i + 1][m];
    }
    for(int j = 0; j < m; j++) {
      dp[n][j] = -INF;
    }
    for(int i = n - 1; i >= 0; i--) {
      for(int j = m - 1; j >= 0; j--) {
        dp[i][j] = (tars.find(i) != tars.end() ? 1 : 0) + dp[i + 1][j];
        if(s[i] == p[j]) {
          dp[i][j] = max(dp[i][j], dp[i + 1][j + 1]);
        }
      }
    }
    return dp[0][0];
  }
};",1420093889
Upayan De,twoplusthree,165,3604,cpp,"using ll = long long;
const int _ = 1005;
const ll MOD = 1e9 + 7;
ll fct[_], invfct[_];
ll modexp(ll b, ll e) {
  ll res = 1;
  while(e > 0) {
    if(e & 1) {
      res *= b; res %= MOD;
    }
    b *= b; b %= MOD;
    e >>= 1;
  }
  res %= MOD;
  return res;
}
void pre() {
  fct[0] = 1;
  for(ll i = 1; i < _; i++) {
    fct[i] = i * fct[i - 1]; fct[i] %= MOD;
  }
  invfct[_ - 1] = modexp(fct[_ - 1], MOD - 2);
  for(int i = _ - 2; i >= 0; i--) {
    invfct[i] = (i + 1) * invfct[i + 1]; invfct[i] %= MOD;
  }
  return;
}
ll C(ll n, ll r) {
  if(r < 0 || n - r < 0) {
    return 0;
  }
  ll res = fct[n];
  res *= invfct[n - r]; res %= MOD;
  res *= invfct[r]; res %= MOD;
  return res;
}
class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    pre();
    ll ans = 0;
    for(int i = 1; i <= x; i++) {
      ll foo = 0;
      for(int j = 0; j <= i; j++) {
        ll bar = C(i, j);
        bar *= modexp(i - j, n); bar %= MOD;
        if(j & 1) {
          foo -= bar; foo %= MOD; foo += MOD; foo %= MOD;
        } else {
          foo += bar; foo %= MOD;
        }
      }
      foo *= C(x, i); foo %= MOD;
      foo *= modexp(y, i); foo %= MOD;
      ans += foo; ans %= MOD;
    }
    return ans;
  }
};",1420078780
Upayan De,twoplusthree,165,3605,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int> &nums) {
    int n = (int)nums.size();
    vector<int> ans(n);
    for(int i = 0; i < n; i++) {
      if(nums[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int cnt = 0, foo = nums[i];
      while(foo & 1) {
        cnt++;
        foo >>= 1;
      }
      ans[i] = (foo << cnt) + ((1 << cnt - 1) - 1);
    }
    return ans;
  }
};",1420006558
Upayan De,twoplusthree,165,3611,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int> &nums) {
    int n = (int)nums.size();
    vector<int> ans(n);
    for(int i = 0; i < n; i++) {
      if(nums[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int cnt = 0, foo = nums[i];
      while(foo & 1) {
        cnt++;
        foo >>= 1;
      }
      ans[i] = (foo << cnt) + ((1 << cnt - 1) - 1);
    }
    return ans;
  }
};",1420006812
Rajdeep Das,Rajdeep432,166,3487,cpp,"#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        std::unordered_set<int> target_set(targetIndices.begin(), targetIndices.end());
        const int INF = INT_MAX / 2;  // Prevent integer overflow

        // Initialize DP array
        std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, INF));
        dp[0][0] = 0;  // Starting condition

        for (int i = 1; i <= n; ++i) {
            dp[i][0] = 0;  // Can always match zero characters
            for (int j = 0; j <= m; ++j) {
                // Option 1: Do not match source[i-1] with pattern[j-1]
                if (dp[i - 1][j] < dp[i][j]) {
                    dp[i][j] = dp[i - 1][j];
                }
                // Option 2: Match source[i-1] with pattern[j-1]
                if (j > 0 && source[i - 1] == pattern[j - 1]) {
                    int cost = dp[i - 1][j - 1];
                    if (target_set.count(i - 1)) {
                        cost += 1;  // Need to use an index we're trying to remove
                    }
                    if (cost < dp[i][j]) {
                        dp[i][j] = cost;
                    }
                }
            }
        }

        int min_required = dp[n][m];
        int max_removable = static_cast<int>(targetIndices.size()) - min_required;
        return std::max(0, max_removable);
    }
};
",1420084828
Rajdeep Das,Rajdeep432,166,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int MOD = 1000000007;
        int max_n = std::max(n, x);
        
        // Precompute factorials and inverse factorials
        std::vector<long long> factorial(max_n + 1, 1);
        std::vector<long long> inv_factorial(max_n + 1, 1);
        
        for (int i = 1; i <= max_n; ++i) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        
        inv_factorial[max_n] = modpow(factorial[max_n], MOD - 2, MOD);
        for (int i = max_n - 1; i >= 0; --i) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
        }
        
        // Function to compute C(n, k)
        auto comb = [&](int n, int k) -> long long {
            if (k < 0 || k > n) return 0;
            return factorial[n] * inv_factorial[k] % MOD * inv_factorial[n - k] % MOD;
        };
        
        long long total = 0;
        for (int k = 1; k <= x; ++k) {
            long long c1 = comb(x, k);  // Choose k stages out of x
            // Inclusion-Exclusion to ensure all k stages are non-empty
            long long sum_i = 0;
            for (int i = 0; i <= k; ++i) {
                long long c2 = comb(k, i);
                long long term = modpow(k - i, n, MOD);
                if (i % 2 == 0) {
                    sum_i = (sum_i + c2 * term % MOD) % MOD;
                } else {
                    sum_i = (sum_i - c2 * term % MOD + MOD) % MOD;
                }
            }
            // Total ways for this k
            long long total_k = c1 * sum_i % MOD;
            total_k = total_k * modpow(y, k, MOD) % MOD;
            total = (total + total_k) % MOD;
        }
        
        return static_cast<int>(total);
    }
    
private:
    // Function to compute (base^exp) % mod
    long long modpow(long long base, long long exp, long long mod) {
        long long result = 1;
        base = base % mod;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = result * base % mod;
            }
            base = base * base % mod;
            exp /= 2;
        }
        return result;
    }
};
",1420073239
Rajdeep Das,Rajdeep432,166,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int min_a = -1;
            for (int s = 0; s <= 30; ++s) {  // 30 bits are sufficient for nums up to 1e9
                int a = num - (1 << s);
                if (a < 0) continue;
                if ((a | (a + 1)) == num) {
                    if (min_a == -1 || a < min_a) {
                        min_a = a;
                    }
                }
            }
            ans.push_back(min_a);
        }
        return ans;
    }
};
",1420093962
Rajdeep Das,Rajdeep432,166,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int min_a = -1;
            for (int s = 0; s <= 30; ++s) {  // 30 bits are sufficient for nums up to 1e9
                int a = num - (1 << s);
                if (a < 0) continue;
                if ((a | (a + 1)) == num) {
                    if (min_a == -1 || a < min_a) {
                        min_a = a;
                    }
                }
            }
            ans.push_back(min_a);
        }
        return ans;
    }
};
",1420093745
Anmol Agarwal,Anmolllll,169,3487,java,"class Solution {
    public int maxRemovals(String s, String p, int[] t) {
        int n=s.length(),m=p.length();int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        int a[]=new int[m+1];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<=m;i++)
        a[i]=Integer.MAX_VALUE;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        a[0]=0;
        boolean[]b=new boolean[n];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i:t)
        b[i]=true;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<n;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=m;j>0;j--)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                if(s.charAt(i)==p.charAt(j-1) && a[j-1]!=Integer.MAX_VALUE)
                {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    a[j]=Math.min(a[j],a[j-1]+(b[i]?1:0));  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                }
            }
        }  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        return t.length-(a[m]==Integer.MAX_VALUE?0:a[m]);
    }
}",1420073512
Anmol Agarwal,Anmolllll,169,3604,java,"class Solution {
    private static final int m=1000000007;
    public int numberOfWays(int n, int x, int y) {
        int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        long a[][]=new long[x+1][x+1];
          yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<=x;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            a[i][0]=1;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=1;j<=i;j++)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                a[i][j]=(a[i-1][j-1]+a[i-1][j])%m;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }

        }
        long b[][]=new long[n+1][x+1];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        b[0][0]=1;
        for(int i=1;i<=n;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=1;j<=x;j++)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                b[i][j]=(j*b[i-1][j]+b[i-1][j-1])%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
        }
        long c[]=new long[x+1];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        c[0]=1;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=1;i<=x;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            c[i]=c[i-1]*i%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        }
        long r=0;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int k=1;k<=x;k++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            long pp=1;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int p=0;p<k;p++)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                pp=(pp*y)%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            r=(r+a[x][k]*b[n][k]%m*c[k]%m*pp%m)%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;

        }
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
      return (int)r;  
    }
}",1420094238
Anmol Agarwal,Anmolllll,169,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int a[]=new int[nums.size()];int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        Arrays.fill(a,-1); yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<nums.size();i++)
        { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=0;j<=nums.get(i);j++)
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                if((j|(j+1))==nums.get(i))
                { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    a[i]=j; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    break;
                } yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
        } yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        return a;
        
    }
}",1420013247
Anmol Agarwal,Anmolllll,169,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int a[]=new int[nums.size()];int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<nums.size();i++)
        { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            int b=nums.get(i); yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            int c=Integer.MAX_VALUE; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            boolean d=false; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int e=0;e<=30;e++)
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                if(((b>>e)&1)==1)
                { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    int f=b&~(1<<e); yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    if(f<0)
                    { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                        continue;
                    }
                    if((f|(f+1))==b)
                    { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                        if(f<c)
                        { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                            c=f; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                            d=true; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                        }
                    }
                }
            }
            if(d)
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                a[i]=c; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
            else
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                a[i]=-1; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
        } yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        return a;
    }
}",1420059277
Manan Rathod,Manan04,171,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n = len(s)
        m = len(p)
        seen = [0] * n
        for idx in t:
            seen[idx] = 1
        dp = [[-1 for i in range(m)] for i in range(n)]
        def sol(i, j):
            if(j == m):
                return 0
            if(i == n):
                return len(t)
            if(dp[i][j] != -1):
                return dp[i][j]
            ans = sol(i + 1, j)
            if(s[i] == p[j]):
                ans = min(ans, seen[i] + sol(i + 1, j + 1))
            dp[i][j] = ans
            return dp[i][j]
        return len(t) - sol(0, 0)
            ",1420007594
Manan Rathod,Manan04,171,3604,python3,"def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
    max_n = min(max_n, mod - 1)

    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
    fact[0] = 1
    for i in range(max_n):
        fact[i + 1] = fact[i] * (i + 1) % mod

    inv_fact[-1] = pow(fact[-1], mod - 2, mod)
    for i in reversed(range(max_n)):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

    def nCr_mod(n, r):
        res = 1
        while n or r:
            a, b = n % mod, r % mod
            if a < b:
                return 0
            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
            n //= mod
            r //= mod
        return res

    return nCr_mod

choose = make_nCr_mod(max_n = 1005)
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0
        mod = 10 ** 9 + 7
        mn = min(n, x)
        mx = n
        for i in range(1, mn + 1):
            # C(mx, i)
            sgn = 1
            c = 0
            for j in range(i):
                extra = 1
                if(j):
                    extra = choose(i, j)
                c += sgn * pow(i - j, mx, mod) * extra
                # if(i == 2):
                #     print(j, i, i - j, mx, extra)
                c %= mod
                sgn *= -1
            c *= pow(y, i, mod)
            c %= mod
            c *= choose(x, i)
            c %= mod
            ans += c
            ans %= mod
        return ans",1420088760
Manan Rathod,Manan04,171,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        n = len(a)
        ans = []
        for val in a:
            if(val == 2):
                ans.append(-1)
                continue
            ze = 0
            b = bin(val)[2: ]
            c = []
            for i in range(len(b) - 1, -1, -1):
                if(b[i] == '1'):
                    c.append('1')
                else:
                    if(ze == 0):
                        ze = 1
                        c[-1] = '0'
                    c.append('0')
            if(ze == 0):
                c[-1] = '0'
            c.reverse()
            tmp = int(''.join(map(str, c)), 2)
            ans.append(tmp)
        return ans",1419998476
Manan Rathod,Manan04,171,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        n = len(a)
        ans = []
        for val in a:
            if(val == 2):
                ans.append(-1)
                continue
            ze = 0
            b = bin(val)[2: ]
            c = []
            for i in range(len(b) - 1, -1, -1):
                if(b[i] == '1'):
                    c.append('1')
                else:
                    if(ze == 0):
                        ze = 1
                        c[-1] = '0'
                    c.append('0')
            if(ze == 0):
                c[-1] = '0'
            c.reverse()
            tmp = int(''.join(map(str, c)), 2)
            ans.append(tmp)
        return ans",1419998207
Brijesh Siwach,Dhongee,173,3487,cpp,"#include<bits/stdc++.h>
//#include <sys/resource.h>
using namespace std;

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
#define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n=size(s);
        int m=size(t);
        vi h(n);
        for(auto x: a){
        	h[x]=1;
        }
        const int inf=1e9;
        vector<vi>dp(n,vi(m+1,-1));
        function<int(int,int)>go=[&](int i,int j){
        	if(i==n) {
        		if(j<m) {
        			return -inf;
        		}
        		return 0;
        	}
        	if(dp[i][j]==-1){
        		int ans=-inf;
        		if(j==m) {
        			ans=max(ans,go(i+1,j)+h[i]);
        		}
        		else {
	        		if(!h[i]) {
	        			if(s[i]==t[j]) {
	        				ans=max(ans,go(i+1,j+1));
	        			}
	        			else{
	        				ans=max(ans,go(i+1,j));
	        			}
	        		}
	        		else{
	        			if(s[i]==t[j]) {
	        				ans=max(ans,go(i+1,j)+1);
	        				ans=max(ans,go(i+1,j+1));
	        			}
	        			else{
	        				ans=max(ans,go(i+1,j)+1);
	        			}
	        		}
        		}
        		dp[i][j]=ans;
        	}
        	return dp[i][j];
        };
        int ans=go(0,0);
        return max(0,ans);
    }
};",1420026330
Brijesh Siwach,Dhongee,173,3604,cpp,"#include<bits/stdc++.h>
//#include <sys/resource.h>
using namespace std;

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
#define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
    	swap(x,n);
        const int mod=1e9+7;
        const int N=1e3;
        auto mul=[&](ll a,ll b){
        	return (a%mod*b%mod)%mod;
        };
        auto add=[&](ll a,ll b){
        	return (a%mod+b%mod)%mod;
        };
        auto binpow=[&](ll a,ll b){
        	if(b<0) return 0ll;
        	ll res=1;
        	a%=mod;
        	while(b>0) {
        		if(b&1) res=res*a%mod;
        		b>>=1;
        		a=a*a%mod;
        	}
        	return res%mod;
        };
        vl fact(N+1,1),inv(N+1);
        fr(i,2,N+1){
        	fact[i]=fact[i-1]*i%mod;
        }
        fr(i,0,N+1){
        	inv[i]=binpow(fact[i],mod-2);
        }
        auto ncr=[&](ll a,ll b){
        	if(b>a) return 0ll;
        	ll num=fact[a];
        	ll den=mul(inv[b],inv[a-b]);
        	num=mul(num,den);
        	return num;
        };
        vector<vl> dp(N+1,vl(N+1,0));
        dp[1][1]=1;
        fr(i,2,N+1){
        	fr(j,1,i+1){
        		dp[i][j]=add(dp[i-1][j-1],mul(j,dp[i-1][j]));
        	}
        }
        ll ans=0;
        fr(i,1,n+1){
        	// ll v1=ncr(x,i);
        	ll v1=dp[x][i];
        	ll v2=ncr(n,i);
        	ll v3=fact[i];
        	// ll v3=1;
        	// ll v4=binpow(i,x-i);
        	ll v4=1;
        	ll v5=binpow(y,i);
        	ll val=mul(v1,v2);
        	dbg(v1,v2,v3,v4,v5);
        	val=mul(val,v3);
        	val=mul(val,v4);
        	val=mul(val,v5);
        	ans=add(ans,val);
        	dbg(ans);
        }
        return ans;
    }
};",1420096233
Brijesh Siwach,Dhongee,173,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if(a[i] == 2) ans[i]=-1;
            else {
                int val=0,l=0;
                for(int j=0;j<30;j++){
                    if((1<<j)&a[i]) {
                        val|=(1<<j);
                        l=j;
                    }
                    else {
                        break;
                    }
                }
                val|=a[i];
                val^=(1<<l);
                ans[i]=val;

            }
        }
        return ans;
    }
};",1420005210
Brijesh Siwach,Dhongee,173,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if(a[i] == 2) ans[i]=-1;
            else {
                int val=0,l=0;
                for(int j=0;j<30;j++){
                    if((1<<j)&a[i]) {
                        val|=(1<<j);
                        l=j;
                    }
                    else {
                        break;
                    }
                }
                val|=a[i];
                val^=(1<<l);
                ans[i]=val;

            }
        }
        return ans;
    }
};",1420004247
Gautam Agarwal,gaut_2003,175,3487,cpp,"class Solution {
public:
    int solve(int i, int j, set<int>& st, string& source, string& pattern, int n, int m, vector<vector<int>>& dp){
        if(i == n){
            if(j != m) return -1e9;
            return 0;
        }
        if(dp[i][j] != -1) return dp[i][j];
        int ans = solve(i+1,j,st,source,pattern,n,m,dp);
        if(j<m && source[i] == pattern[j]){
            ans = max(ans,solve(i+1,j+1,st,source,pattern,n,m,dp));
        }
        if(st.find(i) != st.end()){
            ans = max(ans,1+solve(i+1,j,st,source,pattern,n,m,dp));
        }
        return dp[i][j] = ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        set<int> st;
        for(auto val:targetIndices){
            st.insert(val);
        }
        vector<vector<int>> dp(n+1, vector<int>(m+1,-1));
        int ans = solve(0,0,st,source,pattern,n,m,dp);
        return ans;
    }
};",1420025334
Gautam Agarwal,gaut_2003,175,3604,cpp,"class Solution {
public:
    int mod = 1e9+7;
    int power(int x, int y){
        if(y == 0) return 1;
        int temp = power(x,y/2);
        temp = (temp*1ll*temp)%mod;
        if(y%2 == 1) temp = (temp*1ll*x)%mod;
        return temp;
    }
    int numberOfWays(int n, int x, int y) {
        int ans = 0;
        vector<vector<long long>> preCompute(n+1, vector<long long>(x+1, 0));
        preCompute[0][0] = 1;

        for(int j=1;j<=n;j++){
            for(int k=1;k<=x;k++){
                preCompute[j][k] = (k * preCompute[j-1][k] + preCompute[j-1][k-1]) % mod;
            }
        }
        
        long long yy = 1, bc = 1, fact = 1;
        for(int i=1;i<=min(n,x);i++){
            yy = (yy*y) % mod;
            bc = (bc * ((x-i+1) % mod)) % mod;
            bc = (bc * (power(i,mod-2) % mod)) % mod;
            fact = (fact * i) % mod;
            long long temp1 = preCompute[n][i];
            long long result = (yy * (bc % mod)) % mod;
            result = (result  * (fact % mod)) % mod;
            result = (result * (temp1 % mod)) % mod;
            ans = (ans + result)%mod;
        }
        return ans;
    }
};",1420089502
Gautam Agarwal,gaut_2003,175,3605,cpp,"class Solution {
public:
    int solve(int num){
        int ind = -1;
        int temp = num;
        while(temp > 0){
            int rem = temp%2;
            if(rem == 0){
                break;
            }else{
                ind++;
            }
            temp /= 2;
        }
        int ans = num^(1<<ind);
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2 == 0) ans[i] = -1;
            else ans[i] = solve(nums[i]);
        }
        return ans;
    }
};",1420004201
Gautam Agarwal,gaut_2003,175,3611,cpp,"class Solution {
public:
    int solve(int num){
        int ind = -1;
        int temp = num;
        while(temp > 0){
            int rem = temp%2;
            if(rem == 0){
                break;
            }else{
                ind++;
            }
            temp /= 2;
        }
        int ans = num^(1<<ind);
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2 == 0) ans[i] = -1;
            else ans[i] = solve(nums[i]);
        }
        return ans;
    }
};",1420003627
Titas,ads3k,176,3487,python3,"from typing import List

class Solution:
    # Dummy variables
    dummy_var1 = 123
    dummy_var2 = 3.14159
    dummy_var3 = ""dummyString""
    dummy_var4 = [1, 2, 3]
    dummy_var5 = False

    # Dummy functions
    def dummy_function1(self):
        return self.dummy_var1 + 1
    
    def dummy_function2(self):
        return self.dummy_var2 * 2
    
    def dummy_function3(self):
        return len(self.dummy_var3)
    
    def dummy_function4(self):
        return sum(self.dummy_var4)
    
    def dummy_function5(self):
        return not self.dummy_var5

    def maxRemovals(self, source: str, pattern: str, indices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        
        is_target = [False] * n
        i = 0
        while i < len(indices):
            is_target[indices[i]] = True
            i += 1

        i = 0
        while i < n:
            j = m
            while j > 0:
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if is_target[i] else 0))
                j -= 1
            i += 1
        
        return len(indices) - (0 if dp[m] == float('inf') else dp[m])
",1420047418
Titas,ads3k,176,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    # Dummy variables
    dummy_var1 = 101
    dummy_var2 = ""dummy""
    dummy_var3 = [0, 1, 2]
    dummy_var4 = 7.89
    dummy_var5 = False

    # Dummy functions
    def dummy_function1(self):
        return self.dummy_var1 + 1

    def dummy_function2(self):
        return len(self.dummy_var2)

    def dummy_function3(self):
        return sum(self.dummy_var3)

    def dummy_function4(self, val):
        return val * self.dummy_var1

    def dummy_function5(self):
        return not self.dummy_var5

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        
        # Initialize the combination (C) array
        C = [[0] * (x + 1) for _ in range(x + 1)]
        i = 0
        while i <= x:
            C[i][0] = 1
            j = 1
            while j <= i:
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
                j += 1
            i += 1
        
        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1
        i = 1
        while i <= n:
            j = 1
            while j <= x:
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
                j += 1
            i += 1
        
        # Factorial array
        fact = [1] * (x + 1)
        i = 1
        while i <= x:
            fact[i] = fact[i - 1] * i % MOD
            i += 1
        
        result = 0
        # Main computation loop
        k = 1
        while k <= x:
            power = 1
            p = 0
            while p < k:
                power = (power * y) % MOD
                p += 1
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
            k += 1
        
        return result
",1420082550
Titas,ads3k,176,3605,python3,"class Solution:
    # Dummy variables
    dummy_var1 = 42
    dummy_var2 = 123
    dummy_var3 = ""example""
    dummy_var4 = [1, 2, 3]
    dummy_var5 = 3.14
    
    # Dummy functions
    def dummy_func1(self):
        pass
    
    def dummy_func2(self):
        return self.dummy_var1
    
    def dummy_func3(self):
        return self.dummy_var3
    
    def dummy_func4(self):
        return len(self.dummy_var4)
    
    def dummy_func5(self):
        return self.dummy_var5 * 2
    
    def minBitwiseArray(self, numbers: List[int]) -> List[int]:
        result = []
        idx = 0
        
        while idx < len(numbers):
            prime_num = numbers[idx]
            found_ans = False
            check_value = 0
            
            while check_value < prime_num:
                if (check_value | (check_value + 1)) == prime_num:
                    result.append(check_value)
                    found_ans = True
                    break
                check_value += 1
            
            if not found_ans:
                result.append(-1)
            
            idx += 1
        
        return result
",1420018489
Titas,ads3k,176,3611,python3,"from typing import List

class Solution:
    # Dummy variables
    dummy_var1 = 42
    dummy_var2 = ""unused""
    dummy_var3 = 3.14
    dummy_var4 = [1, 2, 3]
    dummy_var5 = True

    # Dummy functions
    def dummy_function1(self):
        return self.dummy_var1 * 2

    def dummy_function2(self):
        return len(self.dummy_var2)

    def dummy_function3(self):
        return sum(self.dummy_var4)

    def dummy_function4(self, val):
        return val + self.dummy_var1

    def dummy_function5(self):
        return not self.dummy_var5

    def minBitwiseArray(self, numbers: List[int]) -> List[int]:
        results = []
        i = 0
        while i < len(numbers):
            current_num = numbers[i]
            candidates = []
            j = 0
            
            while j < 32:
                if current_num & (1 << j):
                    x = current_num & ~(1 << j)
                    if (x | (x + 1)) == current_num:
                        candidates.append(x)
                j += 1
            
            if not candidates:
                results.append(-1)
            else:
                results.append(min(candidates))
            i += 1
        
        return results
",1420082128
Md Abedin,MdAbedin,178,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        s = set(targetIndices)

        @cache
        def solve(i1,i2):
            if [i1,i2] == [len(source),len(pattern)]: return 0
            if i2 == len(pattern): return solve(i1+1,i2) + (i1 in s)
            if i1 == len(source): return -1

            if i1 in s:
                if (x := solve(i1+1,i2)) != -1:
                    return max(x+1,solve(i1+1,i2+(source[i1] == pattern[i2])))
                else:
                    return solve(i1+1,i2+(source[i1] == pattern[i2]))
            else:
                return solve(i1+1,i2+(source[i1] == pattern[i2]))

        return solve(0,0)",1420041040
Md Abedin,MdAbedin,178,3604,python3,"mod = 10**9+7

facts = [1]
for x2 in range(1,1001): facts.append((facts[-1]*x2)%mod)

@cache
def stirling(n,k):
    if n == k: return 1
    if 0 in [n,k]: return 0
    return (k*stirling(n-1,k)+stirling(n-1,k-1))%mod

@cache
def comb(n,k): return (facts[n]*pow((facts[k]*facts[n-k])%mod,-1,mod))%mod

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0

        for x2 in range(1,min(n,x)+1):
            ways = comb(x,x2)%mod
            ways = (ways*facts[x2]*stirling(n,x2))%mod
            ways = (ways*pow(y,x2,mod))%mod
            ans = (ans+ways)%mod

        return ans",1420089634
Md Abedin,MdAbedin,178,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [min((num2 for num2 in range(2*num+1) if num2|(num2+1) == num),default=-1) for num in nums]",1419993850
Md Abedin,MdAbedin,178,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                b = list(bin(num)[2:])
                i = -1
                for k,g in groupby(b): i = len(list(g))
                b[-i] = ""0""
                ans.append(int("""".join(b),2))

        return ans",1420011792
parthDOOM,parthDOOM,179,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

#define ll long long  
#define vl vector<ll> 
#define vlll vector<vector<ll>> 
#define vb vector<bool> 
#define pb push_back 
#define ub upper_bound 
#define all(a) a.begin(),a.end() 
#define per(i,a,b) for(int i=b;i>a;i--) 
#define rep(i,a,b) for(int i=a;i<b;i++) 
#define loop(x,a) for(auto x : a)
#define inf LLONG_MAX
class Solution {
public:
    int maxRemovals(string src, string pat, vector<int>& trgind) {
        ll n = src.length(),m = pat.length();
        vl dp(m+1,inf);
        dp[0] = 0;
        vb isT(n,false);
        loop(idx, trgind) isT[idx] = true;
        rep(i,0,n) per(j,0,m+1) if(j > 0 && !(src[i] != pat[j-1]) && !(dp[j-1] == LLONG_MAX)) dp[j] = min(dp[j],dp[j-1]+(isT[i] ? 1 : 0));      
        return trgind.size()-(dp[m] == LLONG_MAX ? 0 : dp[m]);
    }
};",1420041669
parthDOOM,parthDOOM,179,3604,cpp,"#include <vector>
using namespace std;

#define ll long long  
#define vl vector<ll> 
#define vlll vector<vector<ll>> 
#define vb vector<bool> 
#define pb push_back 
#define ub upper_bound 
#define all(a) a.begin(),a.end() 
#define per(i,a,b) for(int i=b;i>a;i--) 
#define rep(i,a,b) for(int i=a;i<b;i++) 
#define loop(x,a) for(auto x : a)
#define inf LLONG_MAX
#define MOD 1000000007

class Solution {
public:
    ll numberOfWays(ll n,ll x,ll y){
        vlll C(x+1,vl(x+1,0));
        rep(i,0,x+1){
            C[i][0] = 1;
            rep(j,1,i+1) C[i][j] = (C[i-1][j-1]+C[i-1][j])%MOD; 
        }
        vlll S(n+1,vl(x+1,0));
        S[0][0] = 1;
        rep(i,1,n+1) rep(j,1,x+1) S[i][j] = (j * S[i-1][j] + S[i-1][j-1])%MOD;
        vl ft(x+1,1);
        rep(i,1,x+1) ft[i] = ft[i-1] * i % MOD;
        ll ans = 0;
        rep(k,1,x+1){
            ll pow = 1;
            rep(p,0,k) pow = pow * y % MOD;
            ans = (ans + C[x][k] * S[n][k] % MOD * ft[k] % MOD * pow % MOD) % MOD;
        }
        return ans;
    }
};
",1420096774
parthDOOM,parthDOOM,179,3605,cpp,"#define ll long long 
#define vl vector<ll>
#define vlll vector<vector<ll>>
#define vb vector<bool>
#define pb push_back
#define ub upper_bound
#define all(a) a.begin(),a.end()
#define per(i,a,b) for(int i=b;i>a;i--)
#define rep(i,a,b) for(int i=a;i<b;i++)
#define loop(x,a) for(auto x : a)
class Solution {
public:

    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans(nums.size(), -1); 
    rep(i, 0, nums.size()) {
        rep(j, 0, nums[i]) { 
            if((j | (j + 1)) == nums[i]) {
                ans[i] = j;
                break;  
            }
        }
    }
    
    return ans;      
    }
};",1419996135
parthDOOM,parthDOOM,179,3611,cpp,"#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define vl vector<int>
#define vlll vector<vector<ll>>
#define vb vector<bool>
#define pb push_back
#define ub upper_bound
#define all(a) a.begin(),a.end()
#define per(i,a,b) for(int i=b;i>a;i--)
#define rep(i,a,b) for(int i=a;i<b;i++)
#define loop(x,a) for(auto x : a)
#define inf LLONG_MAX
#define cnt continue
#define sz(a) (int)a.size()
class Solution {
public:
    vl minBitwiseArray(vl& v) {
        ll n = sz(v);
        vl a(n);
        rep(i,0,n){
            ll x = v[i],m = inf;
            bool f = 0;
            rep(b,0,31){
                if(!(((x>>b)&1) != 1)){
                    ll c = x&~(1ll<<b);
                    if(!(c >= 0)) cnt;
                    if(!((c|(c+1)) != x)){
                        if(!(c >= m)){
                            m = c;f = 1;
                        }
                    }
                }
            }
            if(f) a[i]=m;
            else a[i]=-1;
        }
        
        return a;
    }
};",1420061861
Rohith Peddi,rohithpeddi,180,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& a) {
        int n = s.size(), mn = p.size();
        map<int,int> m;
        for (auto x: a) m[x]++;
        vector<vector<int>> dp(n+3, vector<int>(mn+3, -1));
        auto v = dp;
        function<int(int,int)> f = [&](int x, int y)->int{
            if (x>=n) return y>=mn?0:INT_MIN;
            if (v[x][y]!=-1) return dp[x][y];
            v[x][y] = 0;
            if (y>=mn) return dp[x][y] = m[x] + f(x+1, y);
            dp[x][y] = m[x] + f(x+1, y);
            if (s[x]==p[y]) dp[x][y] = max(dp[x][y], f(x+1, y+1));
            return dp[x][y];
        };
        return f(0,0);
    }
};",1420030501
Rohith Peddi,rohithpeddi,180,3604,cpp,"using ll = long long;

const ll N=1e3+3, mod = 1000000007;
ll factorialNumInverse[N + 1];
ll naturalNumInverse[N + 1];
ll fact[N + 1];

class Solution {
public:
    ll binmul(ll a, ll b, ll mod) // ll max+1
{
    if (a<=2000000000&&b<=2000000000)
        return (a*b)%mod;
    //used if a*b>10e18
    ll p=0,x=a%mod;
    while(b!=0)
    {
        if (b&1) p=(p+x)%mod;
        b>>=1;
        x=(x*2)%mod;
    }
    return p;
}

// max comp is O((log(n))^2)
ll binexp(ll a, ll b , ll mod=1000000007)
{
    a%=mod;
    ll c=a,ans=1;
    while(b!=0)
    {
        if (b&1) ans=(binmul(ans,c,mod))%mod;
        b>>=1;
        c=(binmul(c,c,mod))%mod;
    }
    return ans;
}



// Maybe only works for prime p. We have to check.
void InverseofNumber(ll p)
{
    naturalNumInverse[0] = naturalNumInverse[1] = 1;
    for (ll i = 2; i <= N; i++)
        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
}

void InverseofFactorial(ll p)
{
    factorialNumInverse[0] = factorialNumInverse[1] = 1;
    for (ll i = 2; i <= N; i++)
        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
}

void factorial(ll p)
{
    fact[0] = 1;
    for (ll i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % p;
    }
}

ll Binomial(ll N, ll R, ll p = 1000000007)
{
    ll ans = ((fact[N] * factorialNumInverse[R])
              % p * factorialNumInverse[N - R])
             % p;
    return ans;
}

void start()
{
    ll p = mod;
    InverseofNumber(p);
    InverseofFactorial(p);
    factorial(p);
}

    int numberOfWays(int n, int x, int y) {
        start();
        ll M = 1000000007, ans = 0, f = 1, ys = y, me = x;
        for (int s=1;s<=min(n,x);s++){
            // ans = (ans + binexp(s, n-s, M)*f%M*ys%M*me%M)%M, f = (f*(s+1))%M, y = ys*y%M, me = (me*(x-s))%M;
            ll f1 = 0;
            for (int i=0;i<=s;i++)
                f1 = (f1 + (i%2==0?1:-1)*Binomial(s, i)%M*binexp(s-i, n)%M  + 2*M)%M;
    
            ans = (ans + ((Binomial(x, s)%M)*f1%M)*ys%M)%M;
            ys = (ys*y)%M;
        }
        return ans;
    }
};",1420075937
Rohith Peddi,rohithpeddi,180,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto x: nums)
            for (int i=0;i<31;i++)
                if ((x&(1<<i)) == 0){
                    if (x==2) ans.push_back(-1);
                    else ans.push_back(x&~(1<<(i-1)));
                    break;
                }
        return ans;
    }
};",1420008702
Rohith Peddi,rohithpeddi,180,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto x: nums)
            for (int i=0;i<31;i++)
                if ((x&(1<<i)) == 0){
                    if (x==2) ans.push_back(-1);
                    else ans.push_back(x&~(1<<(i-1)));
                    break;
                }
        return ans;
    }
};",1420009722
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3487,csharp,"using System;
using System.Collections.Generic;

public class Solution {
    public int MaxRemovals(string source, string pattern, int[] targetIndices) {
        int n = source.Length;
        int m = pattern.Length;
        int[] dp = new int[m + 1];
        Array.Fill(dp, int.MaxValue);
        dp[0] = 0;

        HashSet<int> targetSet = new HashSet<int>(targetIndices);

        for (int i = 0; i < n; i++) {
            int current = dp[0]; // Store the value of dp[0] to use later
            for (int j = 1; j <= m; j++) {
                int temp = dp[j]; // Store the current dp[j] value
                if (source[i] == pattern[j - 1] && current != int.MaxValue) {
                    dp[j] = Math.Min(dp[j], current + (targetSet.Contains(i) ? 1 : 0));
                }
                current = temp; // Update current to the stored dp[j] for the next iteration
            }
        }

        return targetIndices.Length - (dp[m] == int.MaxValue ? 0 : dp[m]);
    }
}
",1420064127
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3604,csharp,"public class Solution {
    private const int MODULO = 1000000007;

    public int NumberOfWays(int itemsCount, int groupsCount, int multiplier) {
        long[,] combinations = GenerateCombinations(groupsCount);
        long[,] stirlingNumbers = GenerateStirlingNumbers(itemsCount, groupsCount);
        long[] factorials = GenerateFactorials(groupsCount);
        
        long totalWays = 0;

        for (int k = 1; k <= groupsCount; k++) {
            long currentMultiplier = CalculatePower(multiplier, k);
            totalWays = (totalWays + (combinations[groupsCount, k] * stirlingNumbers[itemsCount, k] % MODULO * factorials[k] % MODULO * currentMultiplier % MODULO) % MODULO) % MODULO;
        }

        return (int)totalWays;
    }

    private long[,] GenerateCombinations(int maxGroups) {
        long[,] comb = new long[maxGroups + 1, maxGroups + 1];
        for (int i = 0; i <= maxGroups; i++) {
            comb[i, 0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i, j] = (comb[i - 1, j - 1] + comb[i - 1, j]) % MODULO;
            }
        }
        return comb;
    }

    private long[,] GenerateStirlingNumbers(int itemsCount, int groupsCount) {
        long[,] stirling = new long[itemsCount + 1, groupsCount + 1];
        stirling[0, 0] = 1;

        for (int i = 1; i <= itemsCount; i++) {
            for (int j = 1; j <= groupsCount; j++) {
                stirling[i, j] = (j * stirling[i - 1, j] + stirling[i - 1, j - 1]) % MODULO;
            }
        }
        return stirling;
    }

    private long[] GenerateFactorials(int groupsCount) {
        long[] fact = new long[groupsCount + 1];
        fact[0] = 1;

        for (int i = 1; i <= groupsCount; i++) {
            fact[i] = (fact[i - 1] * i) % MODULO;
        }
        return fact;
    }

    private long CalculatePower(int baseValue, int exponent) {
        long result = 1;
        while (exponent > 0) {
            result = (result * baseValue) % MODULO;
            exponent--;
        }
        return result;
    }
}
",1420083951
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3605,csharp,"public class Solution {
    public int[] MinBitwiseArray(IList<int> nums) {
        int[] ans = new int[nums.Count];
        
        for (int i = 0; i < nums.Count; i++) {
            bool found = false;
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1419998337
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3611,csharp,"public class Solution {
    public int[] MinBitwiseArray(IList<int> nums) {
        int length = nums.Count;
        int[] result = new int[length];
        
        for (int index = 0; index < length; index++) {
            int currentValue = nums[index];
            int bestCandidate = -1;
            
            // Loop over bit positions from 0 to 30 (since nums[i] <= 10^9)
            for (int bitPos = 30; bitPos >= 0; bitPos--) {
                if (IsBitSet(currentValue, bitPos)) {
                    // Try clearing the bit at bitPos
                    int modifiedValue = ClearBit(currentValue, bitPos);
                    
                    if (IsValidCandidate(modifiedValue, currentValue)) {
                        // Update the best candidate if found
                        if (bestCandidate == -1 || modifiedValue < bestCandidate) {
                            bestCandidate = modifiedValue;
                        }
                    }
                }
            }
            // Store the result, -1 if no valid candidate found
            result[index] = bestCandidate;
        }
        
        return result;
    }

    // Helper method to check if the bit at 'position' is set in 'num'
    private bool IsBitSet(int num, int position) {
        return ((num >> position) & 1) == 1;
    }

    // Helper method to clear the bit at 'position' in 'num'
    private int ClearBit(int num, int position) {
        return num & ~(1 << position);
    }

    // Helper method to verify if 'candidate' OR (candidate + 1) equals 'original'
    private bool IsValidCandidate(int candidate, int original) {
        return (candidate | (candidate + 1)) == original;
    }
}
",1420040299
Aakarsh Jain,aakarsh_11235,183,3487,cpp,"class Solution {
public:

    bool check(int x, int n, vector<int>& arr){
        int idx = lower_bound(arr.begin(), arr.end(), x) - arr.begin();
        if(idx == n) return false;
        return arr[idx] == x;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size(), k = targetIndices.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        dp[0][0] = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= m; j++){
                // MATCH
                if((j > 0) && (source[i] == pattern[j - 1]) && (dp[i][j - 1] != -1)){
                    dp[i + 1][j] = max(dp[i][j], dp[i][j - 1]);
                }
                // REMOVE
                if(check(i, k, targetIndices) && (dp[i][j] != -1)){
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
                }
                // DO NOTHING
                if(dp[i][j] != -1) dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
            }
        }
        int ans = 0;
        for(int i = 0; i<= n; i++) ans = max(ans, dp[i][m]);
        return ans;
    }
};",1420078495
Aakarsh Jain,aakarsh_11235,183,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long int>> dp(n + 1, vector<long long int>(x + 1, 0));
        dp[0][0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= x; j++){
                dp[i][j] = j*dp[i - 1][j] + (x - j + 1)*dp[i - 1][j - 1];
                dp[i][j] %= mod;
            }
        }
        long long int ans = 0, curr = y;
        for(int k = 1; k <= x; k++){
            ans += dp[n][k]*curr;
            ans %= mod;
            curr *= y;
            curr %= mod;
        }
        return (int)ans;
    }
};",1420097741
Aakarsh Jain,aakarsh_11235,183,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            if(nums[i] == 2) ans[i] = -1;
            else{
                ans[i] = nums[i]^(1<<__builtin_ctz((nums[i] + 1)>>1));
            }
        }
        return ans;
    }
};",1420002502
Aakarsh Jain,aakarsh_11235,183,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            if(nums[i] == 2) ans[i] = -1;
            else{
                ans[i] = nums[i]^(1<<__builtin_ctz((nums[i] + 1)>>1));
            }
        }
        return ans;
    }
};",1420004489
Pranav,ypranav,184,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        u = set(targetIndices)
    
        d = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        d[0][0] = 0
        for i in range(n):
            for j in range(m + 1):
                if d[i][j] == float('inf'):
                    continue

                if j < m and source[i] == pattern[j]:
                    c = d[i][j] + (i in u)
                    if d[i + 1][j + 1] > c:
                        d[i + 1][j + 1] = c

                if d[i + 1][j] > d[i][j]:
                    d[i + 1][j] = d[i][j]
                    
        return len(targetIndices) - d[n][m]
",1420040310
Pranav,ypranav,184,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        M = 10**9 + 7
        f = [1] * (n + x + 2)

        for i in range(1, n + x + 2):
            f[i] = f[i - 1] * i % M

        v = [1] * (n + x + 2)
        v[-1] = pow(f[-1], M - 2, M)
        for i in range(n + x, -1, -1):
            v[i] = v[i + 1] * (i + 1) % M

        def C(a, b):
            if b < 0 or b > a:
                return 0
            return f[a] * v[b] % M * v[a - b] % M
            
        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for k in range(1, i + 1):
                S[i][k] = (S[i - 1][k - 1] + k * S[i - 1][k]) % M
   
        r = 0
        for k in range(1, min(n, x) + 1):
            tmp = C(x, k) * f[k] % M * S[n][k] % M * pow(y, k, M) % M
            r = (r + tmp) % M
        return r",1420097841
Pranav,ypranav,184,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def f(n):
            for i in range(1000):
                if i | (i + 1) == n:
                    return i
            return -1

        return [f(n) for n in nums]",1419993576
Pranav,ypranav,184,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            temp = []
            for j in range(32):
                if num & (1<<j):
                    a = num ^ (1<<j)
                    if (a | (a+1)) == num:
                        temp.append(a)
            if temp:
                ans.append(min(temp))
            else:
                ans.append(-1)
        return ans",1420006349
Anjali_sharma1,Anjali_sharma1,185,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: list[int]) -> int:
        source_length = len(source)
        pattern_length = len(pattern)
        dp = self.initialize_dp(pattern_length)
        is_target_index = self.mark_target_indices(source_length, targetIndices)

        for i in range(source_length):
            self.update_dp(source, pattern, dp, is_target_index, i, pattern_length)

        return len(targetIndices) - (0 if dp[pattern_length] == float('inf') else dp[pattern_length])

    def initialize_dp(self, pattern_length: int) -> list[int]:
        dp = [float('inf')] * (pattern_length + 1)
        dp[0] = 0
        return dp

    def mark_target_indices(self, source_length: int, targetIndices: list[int]) -> list[bool]:
        is_target_index = [False] * source_length
        for idx in targetIndices:
            is_target_index[idx] = True
        return is_target_index

    def update_dp(self, source: str, pattern: str, dp: list[int],
                  is_target_index: list[bool], source_index: int, pattern_length: int):
        for j in range(pattern_length, 0, -1):
            if source[source_index] == pattern[j - 1] and dp[j - 1] != float('inf'):
                dp[j] = min(dp[j], dp[j - 1] + (1 if is_target_index[source_index] else 0))


",1420084143
Anjali_sharma1,Anjali_sharma1,185,3604,python3,"class Solution:
    MOD = 1000000007

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        C = self.computeCombinations(x)
        S = self.computeStirlingNumbers(n, x)
        fact = self.computeFactorials(x)

        return self.computeResult(n, x, y, C, S, fact)

    def computeCombinations(self, x: int) -> list[list[int]]:
        C = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % self.MOD
        return C

    def computeStirlingNumbers(self, n: int, x: int) -> list[list[int]]:
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % self.MOD
        return S

    def computeFactorials(self, x: int) -> list[int]:
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = (fact[i - 1] * i) % self.MOD
        return fact

    def computeResult(self, n: int, x: int, y: int, C: list[list[int]], 
                      S: list[list[int]], fact: list[int]) -> int:
        result = 0
        for k in range(1, x + 1):
            power = pow(y, k, self.MOD)  # y^k % MOD
            result = (result + C[x][k] * S[n][k] % self.MOD * fact[k] % self.MOD * power % self.MOD) % self.MOD
        return result


",1420077821
Anjali_sharma1,Anjali_sharma1,185,3605,python3,"class Solution:
    def minBitwiseArray(self, nums):
        n = len(nums)
        ans = [0] * n

        for i in range(n):
            ans[i] = self.findMinimumAns(nums[i])

        return ans

    def findMinimumAns(self, num):
        for x in range(num + 1):
            if (x | (x + 1)) == num:
                return x
        return -1



",1419997943
Anjali_sharma1,Anjali_sharma1,185,3611,python3,"class Solution:
    def minBitwiseArray(self, numbers):
        length = len(numbers)
        result = [0] * length
        
        for index in range(length):
            current_number = numbers[index]
            minimal_candidate = float('inf')
            candidate_found = False
            
            for bit_position in range(31):
                if (current_number >> bit_position) & 1:
                    potential_candidate = current_number & ~(1 << bit_position)
                    
                    if potential_candidate >= 0 and (potential_candidate | (potential_candidate + 1)) == current_number:
                        if potential_candidate < minimal_candidate:
                            minimal_candidate = potential_candidate
                            candidate_found = True
            
            result[index] = minimal_candidate if candidate_found else -1
        
        return result


",1420047059
Atharv Paliwal,dryice,186,3487,cpp,"class Solution {
public:
    int dp[3000][3000];
    int solve(int spos1, int spos2, string& s, string& p, int n, int m, map<int,int>& m1)
    {
        if (spos2==m)
            return 0;
        if (spos1==n)
            return 1e9;
        if(dp[spos1][spos2]!=-1)
            return dp[spos1][spos2];
        if (m1.find(spos1)==m1.end())
        {
            int op1=solve(spos1+1,spos2,s,p,n,m,m1);
            int op2=1e9;
            if (s[spos1]==p[spos2])
                op2=solve(spos1+1,spos2+1,s,p,n,m,m1);
            return dp[spos1][spos2]=min(op1,op2);
        }
        else
        {
            int op1=solve(spos1+1,spos2,s,p,n,m,m1);
            int op2=1e9;
            if (s[spos1]==p[spos2])
                op2=1+solve(spos1+1,spos2+1,s,p,n,m,m1);
            return dp[spos1][spos2]=min(op1,op2);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(dp,-1,sizeof(dp));
        map<int,int> m1;
        for(auto &x:targetIndices)
            m1[x]=1;
        int val=solve(0,0,source,pattern,source.length(),pattern.length(),m1);
        // cout<<val<<""\n"";
        return targetIndices.size()-val;
    }
};",1420062261
Atharv Paliwal,dryice,186,3604,cpp,"class Solution {
public:
    int mod=1e9+7;
    long long dp[1000][1001];
    long long pw(long long a, long long n)
    {
        if (n==0)
            return 1;
        long long sm=pw(a,n/2);
        sm=sm*sm%mod;
        if (n%2)
            return sm*a%mod;
        return sm;
    }
    long long solve(long long spos, long long bandCount, long long n, long long x, long long y)
    {
        if (spos==n)
            return pw(y, bandCount);
        if (dp[spos][bandCount]!=-1)
            return dp[spos][bandCount];
        if (bandCount==x)
            return dp[spos][bandCount]=(solve(spos+1,bandCount,n,x,y)*x)%mod;
        long long op1=0;
        if (bandCount>0)
            op1=(solve(spos+1,bandCount,n,x,y)*bandCount)%mod;
        long long op2=(solve(spos+1,bandCount+1,n,x,y)*(x-bandCount))%mod;
        // cout<<spos<<"" ""<<bandCount<<"" ""<<op1<<"" ""<<op2<<""\n"";
        return dp[spos][bandCount]=(op1+op2)%mod;
    }
    int numberOfWays(int n, int x, int y) {
        memset(dp,-1,sizeof(dp));
        return solve(0,0,n,x,y);
    }
};",1420091166
Atharv Paliwal,dryice,186,3605,cpp,"class Solution {
public:
    int pw(int x)
    {
        return x && (!(x & (x - 1)));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,1e9);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=10;j++)
            {
                int val=nums[i]-(1<<j);
                if(val<=0)
                    continue;
                if ((val|(val+1))==nums[i])
                    ans[i]=min(ans[i],val);
            }
            if(ans[i]==1e9)
                ans[i]=-1;
        }
        return ans;
    }
};",1420002472
Atharv Paliwal,dryice,186,3611,cpp,"class Solution {
public:
    int pw(int x)
    {
        return x && (!(x & (x - 1)));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,2e9);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=30;j++)
            {
                int val=nums[i]-(1<<j);
                if(val<=0)
                    continue;
                if ((val|(val+1))==nums[i])
                    ans[i]=min(ans[i],val);
            }
            if(ans[i]==2e9)
                ans[i]=-1;
        }
        return ans;
    }
};",1420004618
Noushil Sharma,noushilll,187,3487,cpp,"class Solution {
public:
    
    int solve(int i, int j,string &s, string &p,vector<int>&tar,vector<vector<int>>&dp){
        
        if(i>=s.size()){
            if(j>=p.size()){
                return 0;
            }
            return INT_MIN;
        }

        if(dp[i][j]!=-1) return dp[i][j];
        int take = INT_MIN;
        int nottake = INT_MIN;

        if(tar[i]){
            take = 1 + solve(i+1,j,s,p,tar,dp);
            nottake = INT_MIN;
            if(s[i]==p[j]){
                nottake = solve(i+1,j+1,s,p,tar,dp);
            }
            else{
                nottake = solve(i+1,j,s,p,tar,dp);
            }
        }
        else{
            nottake = INT_MIN;
            if(s[i]==p[j]){
                nottake = solve(i+1,j+1,s,p,tar,dp);
            }
            else{
                nottake = solve(i+1,j,s,p,tar,dp);
            }
            
        }
        return dp[i][j] = max(take,nottake);
    }
    int maxRemovals(string s, string p, vector<int>& v) {
        int n = s.size();
        vector<int>tar(n+1,0);
        for(auto it: v){
            tar[it]++;
        }
        vector<vector<int>>dp(n+1,vector<int>(p.size()+1,-1));
        return solve(0,0,s,p,tar,dp);
    }
};",1420098282
Noushil Sharma,noushilll,187,3604,cpp,"#include <iostream>
#include <vector>
using namespace std;

#define ll long long  // Define ll as long long
const int MOD = 1e9 + 7;

class Solution {
public:
    // Function to compute the power of x raised to y modulo mod
    ll power(ll x, ll y) {
        ll res = 1; // Initialize result
        x = x % MOD; // Update x if it is more than or equal to mod
        if (x == 0) return 0; // In case x is divisible by mod

        while (y > 0) {
            // If y is odd, multiply x with result
            if (y & 1) {
                res = (res * x) % MOD;
            }
            // y must be even now
            y = y >> 1; // y = y / 2
            x = (x * x) % MOD;
        }
        return res;
    }

    // Function to compute factorial values modulo mod
    vector<ll> factorial(int x) {
        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    ll numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        vector<vector<ll>> S(n + 1, vector<ll>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
            }
        }
        vector<ll> fact = factorial(x);

        ll result = 0;
        for (int k = 1; k <= x; k++) {
            ll powY = power(y, k);
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * powY % MOD) % MOD;
        }

        return result;
    }
};
",1420073899
Noushil Sharma,noushilll,187,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    // Main function to construct the min bitwise array
    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size, -1);  // Initialize result with -1
        
        // Iterate over each number in the nums array
        for (int index = 0; index < size; index++) {
            result[index] = findMinimumBitwiseValue(nums[index]);
        }
        
        return result;
    }

private:
    // Function to find the minimum bitwise value for a given number
    int findMinimumBitwiseValue(int num) {
        for (int candidate = 0; candidate <= num; candidate++) {
            if ((candidate | (candidate + 1)) == num) {
                return candidate;  // Return the first valid candidate
            }
        }
        return -1;  // This case should not occur with valid input
    }
};
",1420044683
Noushil Sharma,noushilll,187,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0; i<n; i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                int h = nums[i];
                int c = 0;
                while(h%2!=0){
                    h = h/2;
                    c++;
                }
                ans.push_back(nums[i] - pow(2,c-1));
            }
        }
        return ans;
    }
};",1420044235
Sam Chen,SamChen856,188,3487,python3,"# similar: LC1898 https://leetcode.com/problems/maximum-number-of-removable-characters/

class Solution:
    # dp, time O(SP+T), space O(SP+T), S = source size, P = pattern size, T = targetIndices size
    def maxRemovals(self, s: str, p: str, targetIndices: List[int]) -> int:
        S, P = len(s), len(p)
        remove_indices_set = set(targetIndices)

        # dp[i][j] = minimum removals in s using indices from targetIndices to have p[:j] as a subsequence of s[:i]
        dp = [[inf] * (P + 1) for _ in range(S + 1)]
        dp[0][0] = 0

        for i in range(S):
            for j in range(P + 1):
                if dp[i][j] == inf:
                    continue
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
                if j < P and s[i] == p[j]:
                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + (i in remove_indices_set))

        return len(targetIndices) - dp[S][P]",1420098537
Sam Chen,SamChen856,188,3604,python3,"MOD = 10**9 + 7
M = 1001

fact = [1] * M
for i in range(1, M):
    fact[i] = fact[i - 1] * i % MOD

inv_fact = [1] * M
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for i in range(M - 2, -1, -1):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

@cache
def comb(n: int, k: int) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD

@cache
def stirling_2(n: int, k: int) -> int:
    if k == 1 or n == k:
        return 1
    res = stirling_2(n - 1, k - 1) + k * stirling_2(n - 1, k)
    return res % MOD

class Solution:
    # math, time O(M), space O(M), M = max(n, x, y)
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        y_pow = [1] * (x + 1)
        for i in range(1, x + 1):
            y_pow[i] = y_pow[i - 1] * y % MOD

        return sum(comb(x, i) * fact[i] * stirling_2(n, i) * y_pow[i] % MOD for i in range(1, min(n, x) + 1)) % MOD
",1420069662
Sam Chen,SamChen856,188,3605,python3,"class Solution:
    # brute, time O(nM), space O(1), n = nums.length, M = max(nums)
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        for i, num in enumerate(nums):
            for x in range(num + 1):
                if x | (x + 1) == num:
                    ans[i] = x
                    break
        return ans",1420017793
Sam Chen,SamChen856,188,3611,python3,"class Solution:
    # bit, time O(nlogM), space O(1)
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        for i, num in enumerate(nums):
            if num == 2:
                continue
            x = num
            j = 0
            while x >> (j + 1) & 1:
                x ^= (1 << j)
                j += 1
            ans[i] = x - 1
        return ans",1420029588
Nandy_Tragic,Nandy_Tragic,189,3487,cpp,"class Solution {
public:
    
    vector<int>dp;
    vector<int>pos;
    const int INF = INT_MAX;
    
    void calculateDP(string &s, string &p, int n, int m){
        for(int i=0;i<n;i++){
            for(int j=m;j>=1;j--){
                if(s[i] == p[j-1]){
                    if(dp[j-1] != INF){
                        int curr = dp[j];
                        curr = min(curr, dp[j-1] + (pos[i] == 1 ? 1 : 0));
                        dp[j] = curr;
                    }
                }
            }
        }
    }
    
    int maxRemovals(string s, string p, vector<int>& nums) {
        
        pos.clear();
        dp.clear();
        int n = s.length();
        int m = p.length();
        
        pos = vector<int>(n, 0);
        for(int i=0;i<nums.size();i++){
            pos[nums[i]] = 1;
        }
        dp = vector<int>(m+1, INF);
        dp[0] = 0;
        
        calculateDP(s, p, n, m);
        
        int answer = nums.size();
        answer -= (dp[m] != INF ? dp[m] : 0);
        return answer;
    }
};",1420068375
Nandy_Tragic,Nandy_Tragic,189,3604,cpp,"class Solution {
public:
    
    typedef long long ll;
    const ll M = 1e9 + 7;
    
    vector<ll>fact;
    vector<vector<ll>>first_array,second_array;
    
    ll mod(ll a){
        return ((a % M) + M) % M;
    }
    ll mul(ll a, ll b){
        return mod(mod(a) * mod(b));
    }
    ll add(ll a, ll b){
        return mod(mod(a) + mod(b));
    }
    
    void calculateFirstDP(int n, int x, int y){
        for (int i = 0; i<=x; i++) {
            first_array[i][0] = 1LL;
            for (int j = 1; j < i+1; j++) {
                ll currsum = add(first_array[i-1][j-1], first_array[i-1][j]);
                first_array[i][j] = currsum;
            }
        }
    }
    
    void calculateSecondDP(int n, int x, int y){
        for (int i=1; i<=n; i++) {
            for (int j=1; j<x+1; j++) {
                ll currsum = mul((ll)j, second_array[i-1][j]);
                currsum = add(currsum, second_array[i-1][j-1]);
                second_array[i][j] = currsum;
            }
        }
    }
    
    ll calculateValue(int n, int x, int y, ll &answer){
        for (int k = 1; k <= x; ++k) {
            ll currPow = 1LL;
            for (int p=1; p<=k; p++) {
                currPow = mul(currPow, (ll)y);
            }
            ll addsum = mul(mul(first_array[x][k], second_array[n][k]), mul(fact[k], currPow));
            answer = add(answer, addsum);
        }
        return answer;
    }
    
    int numberOfWays(int n, int x, int y) {
        first_array.clear();
        second_array.clear();
        fact.clear();
        
        fact = vector<ll>(x+5, 1LL);
        first_array = vector<vector<ll>>(x+2, vector<ll>(x+2, 0LL));
        second_array = vector<vector<ll>>(n+2, vector<ll>(x+2, 0LL));
        
        second_array[0][0] = 1LL;
        
        for(int i=1;i<=x;i++){
            fact[i] = mul(fact[i-1], (ll)i);
        }
        
        calculateFirstDP(n, x, y);
        
        calculateSecondDP(n, x, y);
        
        ll answer = 0LL;
        
        return calculateValue(n, x, y, answer);
        
    }
};",1420092080
Nandy_Tragic,Nandy_Tragic,189,3605,cpp,"class Solution {
public:
    
    int func(int ele){
        int cnt = 0;
        int temp = ele;
        while(ele > 0){
            int rem = (ele%2);
            if(rem == 0) break;
            cnt++;
            ele /= 2;
        }
        int curr = temp;
        curr ^= (int)(pow(2, cnt) - 1);
        curr |= (int)(pow(2, cnt-1) - 1);
        return curr;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>answer(n, -1);
        for(int i=0;i<n;i++){
            int ele = nums[i];
            int msb = log2(ele);
            if(ele == 2){
                answer[i] = -1; 
                continue;
            }
            if((ele & (ele + 1)) == 0){
                answer[i] = pow(2, msb) - 1;
                continue;
            }
            answer[i] = func(ele);
        }
        return answer;
    }
};

// 2 3 5 7 11 13 17 19
    
// 11 -> 1 0 1 1
    
// if num == pow(2, msb + 1) - 1
    
//     pow(2, msb) - 1 
    
// else 
    
//     1 0 0 1 0 1 0 1 1 1 0 1
    
//     9 ->  1 0 0 1
//     10 -> 1 0 1 0
    
    
//     47 -> 1 0 1 1 1 1
    
    
    
    ",1420031293
Nandy_Tragic,Nandy_Tragic,189,3611,cpp,"class Solution {
public:
    
    int func(int ele){
        int cnt = 0;
        int temp = ele;
        while(ele > 0){
            int rem = (ele%2);
            if(rem == 0) break;
            cnt++;
            ele /= 2;
        }
        int curr = temp;
        curr ^= (int)(pow(2, cnt) - 1);
        curr |= (int)(pow(2, cnt-1) - 1);
        return curr;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>answer(n, -1);
        for(int i=0;i<n;i++){
            int ele = nums[i];
            int msb = log2(ele);
            if(ele == 2){
                answer[i] = -1; 
                continue;
            }
            if((ele & (ele + 1)) == 0){
                answer[i] = pow(2, msb) - 1;
                continue;
            }
            answer[i] = func(ele);
        }
        return answer;
    }
};

// 2 3 5 7 11 13 17 19
    
// 11 -> 1 0 1 1
    
// if num == pow(2, msb + 1) - 1
    
//     pow(2, msb) - 1 
    
// else 
    
//     1 0 0 1 0 1 0 1 1 1 0 1
    
//     9 ->  1 0 0 1
//     10 -> 1 0 1 0
    
    
//     47 -> 1 0 1 1 1 1
    
    
    
    ",1420030680
Rushikesh Kulkarni,The_2nd_Derivative,190,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e11;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    int n,m;
    string src, pat;
    vector<int> sc;
    vector<vector<ll>> dp;
    
    ll dfs(int idx1, int idx2){
                
        if(idx1 == n){
            if(idx2 == m){
                return 0;
            }
            else{
                return -INF;
            }
        }
        
        if(dp[idx1][idx2] != -1){
            return dp[idx1][idx2];
        }
        
        if(idx2 == m){
            return dp[idx1][idx2] = sc[idx1] + dfs(idx1 + 1, idx2);
        }
        
        
        ll ans = -INF;
        
        // don't remove current
        if(src[idx1] == pat[idx2]){
            ans = max(ans, dfs(idx1 + 1, idx2 + 1));
        } 
        else{
            ans = max(ans, dfs(idx1 + 1, idx2));            
        }
        
        // remove
        ans = max(ans, sc[idx1] + dfs(idx1 + 1, idx2));
        return dp[idx1][idx2] = ans;
    }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        src = source;
        pat = pattern;
        
        n = sz(src), m = sz(pat);
        
        dp = vector<vector<ll>> (n + 1, vector<ll> (m + 1, -1));
        sc.clear();
        sc.resize(n, 0);
        
        for (auto x: targetIndices)
        {
            sc[x] = 1;
        }
        
        ll ans = dfs(0, 0);
        return max(0ll, ans);
    }
};",1420064389
Rushikesh Kulkarni,The_2nd_Derivative,190,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }



// -MODULAR-
template<int P>
struct Modular {
    Modular() : x{} {}
    Modular(long long x) : x{norm(x % P)} {}
    
    int norm(int x) { if (x < 0) { x += P;} if (x >= P) { x -= P;} return x; }
    int val() const { return x; }
    Modular inv() const { assert(x != 0); return pwr(*this, P - 2); }
    explicit operator long long () { return x; }  //** Warning : Explicit **
    
    // unary
    Modular operator - () const { return Modular(-x); }
    Modular operator ++ ()  { x = norm(++x); return *this; }
    Modular operator -- () { x = norm(--x); return *this; }
    Modular operator ++ (int) { Modular result = *this; ++*this; return result; }
    Modular operator -- (int) { Modular result = *this; --*this; return result; }
    Modular &operator*=(const Modular &rhs) { x = 1LL * x * rhs.val() % P; return *this; }
    Modular &operator+=(const Modular &rhs) { x = norm(x + rhs.val()); return *this;}
    Modular &operator-=(const Modular &rhs) { x = norm(x - rhs.val()); return *this; }  
    Modular &operator/=(const Modular &rhs) { return *this *= rhs.inv(); }
 
    // equality
    friend bool operator == (const Modular &lhs, const Modular &rhs) { return lhs.val() == rhs.val(); }
    friend bool operator <  (const Modular &lhs, const Modular &rhs) { return lhs.val() < rhs.val(); }
    friend bool operator >  (const Modular &lhs, const Modular &rhs) { return lhs.val() > rhs.val(); }
    friend bool operator >= (const Modular &lhs, const Modular &rhs) { return lhs.val() >= rhs.val(); }
    friend bool operator <= (const Modular &lhs, const Modular &rhs) { return lhs.val() <= rhs.val(); }
 
    // binary
    friend Modular operator*(const Modular &lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }
    friend Modular operator+(const Modular &lhs, const Modular &rhs) { return Modular(lhs) += rhs; }
    friend Modular operator-(const Modular &lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }
    friend Modular operator/(const Modular &lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }
    
    // stream
    friend std::istream &operator>>(std::istream &is, Modular &a) { long long v; is >> v; a = Modular(v); return is; }
    friend std::ostream &operator<<(std::ostream &os, const Modular &a) { return os << a.val(); }
 
private:
    int x;
};
 
const int M = 1000000007; 
using mi = Modular<M>;

mi pwr(mi a, ll b) { mi res = 1; while (b>0) { if (b&1) res *= a; a *= a; b >>= 1; } return res; } 
 
vector<mi> fact(1, 1);
vector<mi> inv_fact(1, 1);

mi F(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n];
}

mi I(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return inv_fact[n];
}

mi C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    int numberOfWays(ll n, ll g, ll y) {
        vector<vector<mi>> dp(n + 1, vector<mi>(g + 1, 0));
        dp[0][0] = 1;
        
         for (int i = 1; i <= n; ++i) 
         {
            for (int j = 1; j <= g; ++j) 
            {
                dp[i][j] = mi(j) * dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
        
        mi ans = 0;
        for (ll i = 1; i <= g; i++)
        {
            ans += C(g, i) * F(i) * dp[n][i] * pwr(mi(y), i);
        }
        
        return ans.val();
    }
};",1420098838
Rushikesh Kulkarni,The_2nd_Derivative,190,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = sz(nums);
        vi ans(n, -1);
        
        for (int i = 0; i < n; i++)
        {
            for(int j = 1; j <= 1000; j++)
            {
                if((j | (j+1)) == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        
        return ans;
    }
};",1420001985
Rushikesh Kulkarni,The_2nd_Derivative,190,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = sz(nums);
        vi ans(n, -1);
        
        for (int i = 0; i < n; i++)
        {
            int j = 0;
            while(j < 32 && (nums[i] >> j & 1)){
                j++;
            }
            j--;
            if(j >= 0){
                ans[i] = nums[i] & ~(1 << j);
            }
        }
        
        return ans;
    }
};",1420025239
Swarup_1719,Swarup_1719,191,3487,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vi dp(m + 1, inf);
        dp[0] = 0;
        vi isTarget(n, 0);
        for (int idx : targetIndices) {
            isTarget[idx] = 1;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != inf) {
                    dp[j] = fmin(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        if (dp[m] == inf) {
            return targetIndices.size();
        } else {
            return targetIndices.size() - dp[m];
        }
    }
};",1420057372
Swarup_1719,Swarup_1719,191,3604,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
class Solution {
public:
    ll numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
            }
        }

        vector<vector<ll>> S(n + 1, vector<ll>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % mod;
            }
        }

        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = 1LL * fact[i - 1] * i % mod;
        }

        ll ans = 0;
        for (int k = 1; k <= x; ++k) {
            ll power = 1;
            for (int p = 0; p < k; ++p) {
                power = 1LL * power * y % mod;
            }
            ans = (ans + 1LL * C[x][k] * S[n][k] % mod * fact[k] % mod * power % mod) % mod;
        }

        return ans;
    }
};",1420043900
Swarup_1719,Swarup_1719,191,3605,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
#define pqas priority_queue<int, vector<int> , greater<int> >
#define mi map<ll,ll>
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = nums.size();
        vector<int> A(n, -1); 
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            for (int a = 0; a <= num; ++a) 
            { 
                if ((a | (a + 1)) == num) 
                { 
                    A[i] = a; 
                    break; 
                }
            }
        }
        
        return A;
    }
};",1420019732
Swarup_1719,Swarup_1719,191,3611,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
#define pqas priority_queue<int, vector<int> , greater<int> >
#define mi map<ll,ll>
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = nums.size();
        vector<int> v(n,-1);
        for(int i=0;i<n;i++)
        {
            ll num = nums[i];
            ll ans = inf;
            int fl=0;
            forn(j,32)
            {
                if(((num>>j)&1)==1)
                {
                    ll y = 1<<j;
                    ll x = num & ~y;
                    if(x>=0)
                    {
                        if((x|(x+1)) == num)
                        {
                            if(x<ans) ans=x;
                            fl=1;
                        }
                    }
                }
            }
            if(fl)
            {
                v[i] = ans;
            }
        }
        return v;
    }
};",1420078804
Tanvir Tareq,tanvirtareq,193,3487,cpp,"class Solution {
public:
    int dp[3010][3010];
    int cst[3010];
    string s, p;
    int dpf(int i, int j) {
        if(j>=p.size()) return 0;
        if(i>=s.size()) {
            return s.size()+1000;
        }
        int &rt=dp[i][j];
        // cout<<""ad ""<<rt<<endl;
        if(rt!=-1) return rt;
        rt=s.size()+1000;
        // cout<<""b ""<<rt<<endl;
        if(s[i]==p[j]) rt=min(rt, dpf(i+1, j+1)+cst[i]);
        // cout<<""c ""<<
        rt=min(rt, dpf(i+1, j));
        // cout<<i<<' '<<j<<"" ""<<rt<<endl;
        return rt;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(dp, -1, sizeof(dp));
        s=source;
        p=pattern;
        for(auto it:targetIndices) {
            cst[it]=1;
        }

        return targetIndices.size() - dpf(0, 0);
    }
};",1420039769
Tanvir Tareq,tanvirtareq,193,3604,cpp,"class Solution {
public:
    long long MD = 1000000007LL;
    long long fct[1010];
    long long s[1010][1010];
    long long powr(long long b, long long p) {
        if(p==0) return 1;
        long long x=powr(b, p/2);
        x=(x*x)%MD;
        if(p%2) {
            x=(x*b)%MD;
        }
        return x;
    }

    long long p(long long n, long long r) {
        long long rt=fct[n];
        rt=(rt*powr(fct[n-r], MD-2))%MD;
        return rt;
    }
    long long sf(int n, int k) {
        if (n == 0 && k == 0) return 1;
        if (n == 0 || k == 0) return 0;
        if (n == k) return 1;

        long long &rt = s[n][k];
        if(rt!=-1) return rt;

        return rt=((k*sf(n-1, k))%MD+sf(n-1, k-1))%MD;
    }

    long long cal(int n, int x, int y, int i) {
        long long rt=p(x, i);
        rt=(rt*sf(n, i))%MD;
        rt =(rt*powr(y, i));
        return rt;
    }
    int numberOfWays(int n, int x, int y) {
        
        memset(s, -1, sizeof(s));
        // cout<<sf(5, 2)<<endl;
        fct[0]=1;
        for(long long i=1;i<=max(n, x);i++) {
            fct[i]=(fct[i-1]*i)%MD;
        }
        long long ans=0;
        for(long long i=1;i<=min(n, x);i++) {
            ans=(ans+cal(n, x, y, i))%MD;
            // cout<<ans<<endl;
        }
        return ans;
    }
};",1420099842
Tanvir Tareq,tanvirtareq,193,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto it:nums) {
            int x=it;
            int y=-1;
            for(int i=0;i<=x;i++) {
                if((i|(i+1))==x) {
                    y=i;
                    break;
                }
            }
            ans.push_back(y);
        }
        return ans;
    }
};",1420003439
Tanvir Tareq,tanvirtareq,193,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto it:nums) {
            if(__builtin_popcount(it)==1) {
                ans.push_back(-1);
                continue;
            }
            vector<int> v;
            int x=it;
            while(x) {
                v.push_back(x%2);
                x/=2;
            }
            v.push_back(0);
            for(int i=1;i<v.size();i++) {
                if(v[i]==0 and v[i-1]==1) {
                    v[i-1]=0;
                    break;
                }
            }
            int y=0;
            for(int i=(int)v.size()-1;i>=0;i--) {
                y*=2;
                y+=v[i];
            }
            ans.push_back(y);
        }
        return ans;
    }
};",1420013361
Roman Derkach,derkach,194,3487,cpp,"class Solution {
public:

    int dp[3005][3005];
    bool used[3005][3005];
    int mp[3005];

    int maxRemovals(string a, string b, vector<int>& c) {
        for(int i = 0; i <= 3000; ++i)mp[i] = 0;
            for(auto x : c) mp[x] = 1;
            int n = (int)a.size();
            int m = (int)b.size();
            for(int i = 0; i <= n; ++i){
                for(int j = 0; j <= m; ++j){
                    used[i][j] = false;
                    dp[i][j] = 0;
                }
            }
            used[0][0] = true;
            for(int i = 0; i < n; ++i){
                for(int j = 0; j <= i; ++j){
                    if(used[i][j]){
                        if(a[i] == b[j]){
                            if(mp[i])dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1),used[i + 1][j] = true;
                            dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                            used[i + 1][j + 1] = true;
                        }else{
                            if(mp[i]) dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1), used[i + 1][j] = true;
                            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                            used[i + 1][j] = true;
                        }
                    }
                }
            }

            return dp[n][m];
      }
};",1420072604
Roman Derkach,derkach,194,3604,cpp,"class Solution {
public:

    int dp[2000][2000];
    int md = 1e9 + 7;

    void add(int &a,int b){
        a += b;
        if(a >= md)a -= md;
    }

    int numberOfWays(int n, int x, int y) {
        for(int i = 0; i <= n; ++i){
            for(int j = 0; j <= x; ++j){
                dp[i][j] = 0;
            }
        }
        dp[0][0] = 1;
        for(int i = 0; i < n; ++i){
            for(int j = 0; j <= x; ++j){
                add(dp[i + 1][j], dp[i][j] * 1ll * j % md);
                add(dp[i + 1][j + 1], dp[i][j] * 1ll *(x - j) % md *1ll* y % md);
            }
        }
        int ans = 0;
        for(int j = 1; j <= x; ++j){
            add(ans, dp[n][j]);
        }
        return ans;
    }
};",1420034892
Roman Derkach,derkach,194,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2)ans.push_back(-1);
            for(int j = -1000; j <= 1000; ++j){
                if((j | (j + 1)) == nums[i]){
                    ans.push_back(j);
                    break;
                }
            }
        }
        return ans;
    }
};",1419996759
Roman Derkach,derkach,194,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2){
                ans.push_back(-1);
            }else{
                int val = nums[i];
                val /= 2;
                bool f = false;
                for(int j = val - 12000; j <= val + 12000; ++j){
                    if((j | (j + 1)) == nums[i]){
                        ans.push_back(j);
                        f = 1;
                        break;
                    }
                }
                if(!f){
                    for(int j = nums[i] - 12000; i <= nums[i] + 12000; ++j){
                        if((j | (j + 1)) == nums[i]){
                        ans.push_back(j);
                        f = 1;
                        break;
                    }
                    }
                }
            }
        }
        return ans;
    }
};",1420010699
Geek_Guy_0808,Geek_Guy_0808,195,3487,cpp,"class Solution {
public:

int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFall(int lambai) {
    return vector<int>(lambai, -1);
}


bool isBitSet(int sankhya, int bit) {
    return ((sankhya >> bit) & 1) == 1;
}

int unsetBit(int sankhya, int bit) {
    return sankhya & ~(1 << bit);
}

bool isValidCandidate(int pratyashi, int sankhya) {
    return pratyashi >= 0 && ((pratyashi | (pratyashi + 1)) == sankhya);
}

int khojLagbhagChhota(int sankhya) {
    int lagbhagChhota = INT_MAX;
    bool paayaGaya = false;

    for (int bit = 0; bit <= 30; ++bit) {
        if (isBitSet(sankhya, bit)) {
            int pratyashi = unsetBit(sankhya, bit);

            if (isValidCandidate(pratyashi, sankhya) && pratyashi < lagbhagChhota) {
                lagbhagChhota = pratyashi;
                paayaGaya = true;
            }
        }
    }
    return paayaGaya ? lagbhagChhota : -1;
}

int dhoondhChhotaUttar(int sankhya) {
    return khojLagbhagChhota(sankhya);
}

std::vector<int> prarambhFal(int lambai) {
    return std::vector<int>(lambai, -1);
}

std::vector<int> minBitwiseArray(std::vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    std::vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = dhoondhChhotaUttar(sankhyaSuchi[i]);
    }

    return fal;
}

std::vector<bool> nayaSuchak(int n) {
    return std::vector<bool>(n, false);
}

std::vector<int> shuruAarambhikSuchi(int m) {
    std::vector<int> dp(m + 1, INT_MAX);
    dp[0] = 0;
    return dp;
}

void chinhanSuchi(std::vector<bool>& suchak, const std::vector<int>& lakshyaSuchi) {
    for (int idx : lakshyaSuchi) {
        suchak[idx] = true;
    }
}

void sthanakSuchak(const std::string& strot, const std::string& prarup, std::vector<int>& dp, const std::vector<bool>& suchak) {
    int n = strot.size();
    int m = prarup.size();

    for (int i = 0; i < n; ++i) {
        for (int j = m; j > 0; --j) {
            if (strot[i] == prarup[j-1] && dp[j-1] != INT_MAX) {
                dp[j] = std::min(dp[j], dp[j-1] + (suchak[i] ? 1 : 0));
            }
        }
    }
}

int maxRemovals(const std::string& strot, const std::string& prarup, const std::vector<int>& lakshyaSuchi) {
    int n = strot.size();
    int m = prarup.size();

    std::vector<bool> suchak = nayaSuchak(n);
    chinhanSuchi(suchak, lakshyaSuchi);
    
    std::vector<int> dp = shuruAarambhikSuchi(m);

    sthanakSuchak(strot, prarup, dp, suchak);

    return lakshyaSuchi.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
}
};

",1420058548
Geek_Guy_0808,Geek_Guy_0808,195,3604,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:


int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFall(int lambai) {
    return vector<int>(lambai, -1);
}


bool isBitSet(int sankhya, int bit) {
    return ((sankhya >> bit) & 1) == 1;
}

int unsetBit(int sankhya, int bit) {
    return sankhya & ~(1 << bit);
}

bool isValidCandidate(int pratyashi, int sankhya) {
    return pratyashi >= 0 && ((pratyashi | (pratyashi + 1)) == sankhya);
}

int khojLagbhagChhota(int sankhya) {
    int lagbhagChhota = INT_MAX;
    bool paayaGaya = false;

    for (int bit = 0; bit <= 30; ++bit) {
        if (isBitSet(sankhya, bit)) {
            int pratyashi = unsetBit(sankhya, bit);

            if (isValidCandidate(pratyashi, sankhya) && pratyashi < lagbhagChhota) {
                lagbhagChhota = pratyashi;
                paayaGaya = true;
            }
        }
    }
    return paayaGaya ? lagbhagChhota : -1;
}

int dhoondhChhotaUttar(int sankhya) {
    return khojLagbhagChhota(sankhya);
}

std::vector<int> prarambhFal(int lambai) {
    return std::vector<int>(lambai, -1);
}

std::vector<int> minBitwiseArray(std::vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    std::vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = dhoondhChhotaUttar(sankhyaSuchi[i]);
    }

    return fal;
}

std::vector<bool> nayaSuchak(int n) {
    return std::vector<bool>(n, false);
}

std::vector<int> shuruAarambhikSuchi(int m) {
    std::vector<int> dp(m + 1, INT_MAX);
    dp[0] = 0;
    return dp;
}

void chinhanSuchi(std::vector<bool>& suchak, const std::vector<int>& lakshyaSuchi) {
    for (int idx : lakshyaSuchi) {
        suchak[idx] = true;
    }
}

void sthanakSuchak(const std::string& strot, const std::string& prarup, std::vector<int>& dp, const std::vector<bool>& suchak) {
    int n = strot.size();
    int m = prarup.size();

    for (int i = 0; i < n; ++i) {
        for (int j = m; j > 0; --j) {
            if (strot[i] == prarup[j-1] && dp[j-1] != INT_MAX) {
                dp[j] = std::min(dp[j], dp[j-1] + (suchak[i] ? 1 : 0));
            }
        }
    }
}

int maxRemovals(const std::string& strot, const std::string& prarup, const std::vector<int>& lakshyaSuchi) {
    int n = strot.size();
    int m = prarup.size();

    std::vector<bool> suchak = nayaSuchak(n);
    chinhanSuchi(suchak, lakshyaSuchi);
    
    std::vector<int> dp = shuruAarambhikSuchi(m);

    sthanakSuchak(strot, prarup, dp, suchak);

    return lakshyaSuchi.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
}


    int numberOfWays(int n, int x, int y) {
        std::vector<int> paramenter = {n, x, y};
        std::vector<std::vector<int>> C = ghanakSanjha(x);
        std::vector<std::vector<int>> S = ghanakStirling(n, x);
        std::vector<int> fact = ghanakFactorial(x);
        return ghanakParinaam(x, n, C, S, fact, y);
    }

private:
    std::vector<std::vector<int>> ghanakSanjha(int x) {
        std::vector<std::vector<int>> C = initializeSanjha(x);
        computeSanjha(C, x);
        return C;
    }

    std::vector<std::vector<int>> initializeSanjha(int x) {
        std::vector<std::vector<int>> C(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
        }
        return C;
    }

    void computeSanjha(std::vector<std::vector<int>>& C, int x) {
        for (int i = 1; i <= x; ++i) {
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }

    std::vector<std::vector<int>> ghanakStirling(int n, int x) {
        std::vector<std::vector<int>> S = initializeStirling(n, x);
        computeStirling(S, n, x);
        return S;
    }

    std::vector<std::vector<int>> initializeStirling(int n, int x) {
        std::vector<std::vector<int>> S(n + 1, std::vector<int>(x + 1, 0));
        S[0][0] = 1;
        return S;
    }

    void computeStirling(std::vector<std::vector<int>>& S, int n, int x) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (static_cast<long long>(j) * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
    }

    std::vector<int> ghanakFactorial(int x) {
        std::vector<int> fact = initializeFactorial(x);
        computeFactorial(fact, x);
        return fact;
    }

    std::vector<int> initializeFactorial(int x) {
        std::vector<int> fact(x + 1, 1);
        return fact;
    }

    void computeFactorial(std::vector<int>& fact, int x) {
        for (int i = 1; i <= x; ++i) {
            fact[i] = static_cast<long long>(fact[i - 1]) * i % MOD;
        }
    }

    long long ghanakPowers(int y, int k) {
        long long power = 1;
        for (int p = 0; p < k; ++p) {
            power = (power * y) % MOD;
        }
        return power;
    }

    int ghanakParinaam(int x, int n, const std::vector<std::vector<int>>& C, 
                       const std::vector<std::vector<int>>& S, 
                       const std::vector<int>& fact, int y) {
        int parinaam = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = ghanakPowers(y, k);
            parinaam = (parinaam + static_cast<long long>(C[x][k]) * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return parinaam;
    }
};
",1420100183
Geek_Guy_0808,Geek_Guy_0808,195,3605,cpp,"class Solution {
public:

int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFal(int lambai) {
    return vector<int>(lambai, -1);
}

vector<int> minBitwiseArray(vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = paoFal(sankhyaSuchi[i]);
    }

    return fal;
}



};",1420003803
Geek_Guy_0808,Geek_Guy_0808,195,3611,cpp,"class Solution {
public:

int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFall(int lambai) {
    return vector<int>(lambai, -1);
}


bool isBitSet(int sankhya, int bit) {
    return ((sankhya >> bit) & 1) == 1;
}

int unsetBit(int sankhya, int bit) {
    return sankhya & ~(1 << bit);
}

bool isValidCandidate(int pratyashi, int sankhya) {
    return pratyashi >= 0 && ((pratyashi | (pratyashi + 1)) == sankhya);
}

int khojLagbhagChhota(int sankhya) {
    int lagbhagChhota = INT_MAX;
    bool paayaGaya = false;

    for (int bit = 0; bit <= 30; ++bit) {
        if (isBitSet(sankhya, bit)) {
            int pratyashi = unsetBit(sankhya, bit);

            if (isValidCandidate(pratyashi, sankhya) && pratyashi < lagbhagChhota) {
                lagbhagChhota = pratyashi;
                paayaGaya = true;
            }
        }
    }
    return paayaGaya ? lagbhagChhota : -1;
}

int dhoondhChhotaUttar(int sankhya) {
    return khojLagbhagChhota(sankhya);
}

std::vector<int> prarambhFal(int lambai) {
    return std::vector<int>(lambai, -1);
}

std::vector<int> minBitwiseArray(std::vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    std::vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = dhoondhChhotaUttar(sankhyaSuchi[i]);
    }

    return fal;
}
};




",1420048411
Ian Wong,ianwong1999,196,3487,cpp,"class Solution {
public:
    int dp[3055][3055];
    int target[3055];
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                dp[i][j] = -1;
            }
            
            target[i] = false;
        }
        
        for (auto x : targetIndices) target[x] = true;
        
        dp[0][0] = 0;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= m; j++) {
                if (dp[i][j] == -1) continue;
                
                if (j < m && source[i] == pattern[j]) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
                
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                
                if (target[i]) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
                }
            }
        }
        
        int res = -1;
        
        for (int i = 0; i <= n; i++) {
            res = max(res, dp[i][m]);
        }
        
        return res;
    }
};",1420008168
Ian Wong,ianwong1999,196,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int fact[2055];
    int inv[2055];
    int dp[2055];
    
    int mod_pow(int n, int k) {
        if (k == 0) return 1;
        int res = mod_pow(n, k >> 1);
        res = 1ll * res * res % MOD;
        if (k & 1) res = 1ll * res * n % MOD;
        return res;
    }
    int comb(int n, int k) {
        if (k > n) return 0;
        return 1ll * fact[n] * inv[k] % MOD * inv[n - k] % MOD;
    }
    int npr(int n, int k) {
        if (k > n) return 0;
        return 1ll * fact[n] * inv[n - k] % MOD;
    }
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        
        for (int i = 1; i <= n + x; i++) {
            fact[i] = 1ll * fact[i - 1] * i % MOD;
        }
        
        for (int i = 0; i <= n + x; i++) {
            inv[i] = mod_pow(fact[i], MOD - 2);
        }
        
        dp[1] = 1;
        dp[0] = 1;
        
        for (int i = 2; i <= min(n, x); i++) {
            dp[i] = mod_pow(i, n);
            for (int j = 1; j < i; j++) {
                dp[i] = (1ll * dp[i] - 1ll * dp[j] * comb(i, j) % MOD) % MOD;
                dp[i] %= MOD;
                dp[i] = (dp[i] + MOD) % MOD;
            }
        }
        
        int res = 0;
        int was = 0;
        for (int i = 1; i <= min(n, x); i++) {
            int stage_ways = 1ll * dp[i] * comb(x, i) % MOD;
            int score_ways = mod_pow(y, i);
            res = (1ll * res + 1ll * stage_ways * score_ways % MOD) % MOD;
        }
        return res;
    }
};",1420094064
Ian Wong,ianwong1999,196,3605,cpp,"class Solution {
public:
    int f(int x) {
        if (x == 2) return -1;
        int pt = 0;
        
        while (x & (1 << pt)) pt++;
        
        int res = x - (1 << (pt - 1));
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for (auto x : nums) {
            res.push_back(f(x));
        }
        
        return res;
    }
};",1419998947
Ian Wong,ianwong1999,196,3611,cpp,"class Solution {
public:
    int f(int x) {
        if (x == 2) return -1;
        int pt = 0;
        
        while (x & (1 << pt)) pt++;
        
        int res = x - (1 << (pt - 1));
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for (auto x : nums) {
            res.push_back(f(x));
        }
        
        return res;
    }
};",1419999187
ConstantineJin,ConstantineJin,198,3487,python3,"class Solution:
    def maxRemovals(self, source, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        is_target = [False] * n
        for idx in targetIndices:
            is_target[idx] = True
        prev = [0] * (n + 1)
        current = [0] * (n + 1)
        for i in range(1, m + 1):
            for j in range(n + 1):
                if j < i:
                    current[j] = inf
                elif j == 0:
                    current[j] = inf
                else:
                    if source[j - 1] == pattern[i - 1]:
                        use_it = prev[j - 1]
                        if is_target[j - 1]:
                            use_it += 1
                        not_use_it = current[j - 1]
                        current[j] = min(use_it, not_use_it)
                    else:
                        current[j] = current[j - 1]
            prev, current = current, prev
        return len(targetIndices) - prev[n]",1420099608
ConstantineJin,ConstantineJin,198,3604,python3,"MOD = int(1e9 + 7)


def comb_mod(n, k, fact, inv_fact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD


def pow_mod(a, b) -> int:
    result = 1
    a = a % MOD
    while b > 0:
        if b % 2 == 1:
            result = result * a % MOD
        a = a * a % MOD
        b //= 2
    return result


class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mx = n + x
        fact = [1] * (mx + 1)
        inv_fact = [1] * (mx + 1)

        for i in range(1, mx + 1):
            fact[i] = fact[i - 1] * i % MOD
        inv_fact[mx] = pow_mod(fact[mx], MOD - 2)
        for i in range(mx - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        s = [[0] * (n + 1) for _ in range(n + 1)]
        s[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                s[i][j] = (s[i - 1][j - 1] + s[i - 1][j] * j) % MOD

        min_k = min(n, x)
        y_pow = [1] * (min_k + 2)
        for i in range(1, min_k + 2):
            y_pow[i] = y_pow[i - 1] * y % MOD

        ans = 0
        for k in range(1, min_k + 1):
            comb_xk = comb_mod(x, k, fact, inv_fact)
            stirling_nk = s[n][k]
            fact_k = fact[k]
            y_k = y_pow[k]
            term = comb_xk * stirling_nk % MOD
            term = term * fact_k % MOD
            term = term * y_k % MOD
            ans = (ans + term) % MOD

        return ans
",1420097011
ConstantineJin,ConstantineJin,198,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i, num in enumerate(nums):
            mn = -1
            for p in range(32):
                if (num & (1 << p)) != 0:
                    candidate = num & ~(1 << p)
                    if candidate >= 0 and (candidate | (candidate + 1)) == num:
                        if mn == -1 or candidate < mn:
                            mn = candidate
            ans[i] = mn
        return ans",1420101082
ConstantineJin,ConstantineJin,198,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i, num in enumerate(nums):
            mn = -1
            for p in range(32):
                if (num & (1 << p)) != 0:
                    candidate = num & ~(1 << p)
                    if candidate >= 0 and (candidate | (candidate + 1)) == num:
                        if mn == -1 or candidate < mn:
                            mn = candidate
            ans[i] = mn
        return ans",1420100938
Yohannes Degefa,ResilientWarrior,199,3487,python3,"
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
      
        table = [float('inf')] * (len(pattern) + 1)
        table[0] = 0
        targets = [False] * len(source)
        
        for i in targetIndices:
            targets[i] = True
        # print(targets)
        for i in range(len(source)):
            for j in range(len(pattern), 0, -1):
                if source[i] == pattern[j-1] and table[j-1] != float('inf'):
                    table[j] = min(table[j], table[j-1] + (1 if targets[i] else 0))
        #print(table)  
        return len(targetIndices) - (0 if table[len(pattern)] == float('inf') else table[len(pattern)])
",1420067968
Yohannes Degefa,ResilientWarrior,199,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:

     
     
        M = 10**9 + 7;C = [[0] * (x + 1) for _ in range(x + 1)];fring = [1] * (x + 1)
        
        for i in range(x + 1):
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % M
            C[i][0] = 1
        
        #print(C)
      
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        #print(S)
        for i in range(1, x + 1):
            fring[i] = fring[i - 1] * i % M

        for i in range(1, n + 1):
            for j in range(1, x + 1):
                #print(i, j, s[i][j])
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % M
        
    
        answer = 0
        for k in range(1, x + 1):
            pwr = 1
            for p in range(k):
                pwr = (pwr * y) % M

           
            answer = (answer + C[x][k] * S[n][k] % M * fring[k] % M * pwr % M) % M

        return answer",1420101528
Yohannes Degefa,ResilientWarrior,199,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            flag = False
           
            for i in range(num):
                if i | (i + 1) == num:
                    ans.append(i)
                    flag = True
                    break
                    
            if not flag:
                ans.append(-1)
        return ans",1419995186
Yohannes Degefa,ResilientWarrior,199,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        
        for i in range(n):
            num = nums[i];ss = float('inf');flag = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    zs = num & ~(1 << bit)
                    
                    if zs < 0:
                        continue
                    
                    if zs | (zs + 1) == num:
                        if zs < ss:
                            ss = zs
                            flag = True
            
            if flag:
                result[i] = ss
            else:
                result[i] = -1
        
        return result",1420058862
homeless_man,homeless_man,200,3487,cpp,"int dp[4000][4000];
class Solution {
    
public:
    
    map<int,int> f;
    
    int dfs(int pdx,int idx,string& p,string& s){
        if(idx == s.size())
            return (pdx == p.size()) ? 0 : -1e9;
        if(dp[pdx][idx] != -1)
            return dp[pdx][idx];
        int res = dfs(pdx,idx+1,p,s);
        if(f[idx])
            res = max(res,dfs(pdx,idx+1,p,s) + 1);
        
        if((pdx < p.size()) && (p[pdx] == s[idx]))
            res = max(res,dfs(pdx + 1,idx+1,p,s));
        
        return dp[pdx][idx] = res;
    }
    
    int maxRemovals(string s, string p, vector<int>& t) {
        for(int i = 0;i<=max(p.size(),s.size());i++)
            for(int j = 0;j<=max(p.size(),s.size());j++)
                dp[i][j] = -1;
        for(int i : t)
            f[i]++;
        return dfs(0,0,p,s);
    }
};",1420026461
homeless_man,homeless_man,200,3604,cpp,"class Solution {
public:
    
    long long stages;
    long long ys;
    long long mod = 1e9 + 7;
    
    long long dp[1001][1001];
    
    long long mypow(long long base, long long exp){
        if(exp <= 1)
            return exp ? base : 1;
        long long mid = mypow(base, exp/2);
        return ((mid * mid)%mod * (exp%2 ? base : 1))%mod;
    }
    
    long long dfs(long long n, long long stagesleft){
        long long taken = stages - stagesleft;
        if(n == 0){
            return mypow(ys, taken);
        }
        if(dp[n][stagesleft] != -1)
            return dp[n][stagesleft];
        // go to existing stage
        long long res = 0;
        if(taken > 0)
           res = (res + (taken * dfs(n-1, stagesleft)) % mod) % mod;
        if(stagesleft > 0)
            res = (res + (stagesleft * dfs(n-1, stagesleft-1) % mod)) % mod;
        return dp[n][stagesleft] = res;
    }
    
    int numberOfWays(int n, int x, int y) {
        memset(dp, -1, sizeof(dp));
        stages = x;
        ys = y;
        return dfs(n, x);
    }
};
",1420059244
homeless_man,homeless_man,200,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(int i : nums){
            if(i%2 == 0){
                res.push_back(-1);
            }
            else{
                for(int j = 0;j<=i;j++){
                    if((j | (j + 1)) == i){
                        res.push_back(j);
                        break;
                    }
                }
            }
        }
        return res;
    }
};",1420006686
homeless_man,homeless_man,200,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        //the 0th bit must be active
        vector<int> res;
        for(int i : nums){
            if(i%2 == 0){
                res.push_back(-1);
            }
            else{
                //you can take i - 1 as an answer always
                //case smaller number is even
                //then you have to go with i - 1
                //so try making the smaller number odd
                //we get (x + 1) | x = i
                //where x is odd
                //look at the carry over bit
                int msb = 0;
                for(int j = 0;j<30;j++){
                    if((1 << j) & i)
                        msb = j;
                    else
                        break;
                }
                msb++;
                if(msb == 1){
                    res.push_back(i-1);
                }
                else{
                    //these bist cannot be affected by adding one
                    int curr = 0;
                    for(int j = msb;j<30;j++){
                        curr |= (1 << j) & i;
                    }
                    for(int j = 0;j<msb-1;j++){
                        curr |= (1 << j);
                    }
                    res.push_back(curr);
                }
            }
        }
        return res;
    }
};",1420088179
i_will_beat_my_iq,i_will_beat_my_iq,202,3487,cpp,"class Solution {
public:
    int helper(string& s, string& t, unordered_map<int, int>& mp, int i, int j, vector<vector<int>>& dp) {
        if (i == t.length()) {
            return 0;
        }
        if (j == s.size()) {
            return s.length() + 1;
        }
        
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        
        int ans = helper(s, t, mp, i, j + 1, dp);
        
        if (t[i] == s[j]) {
            ans = min(ans, helper(s, t, mp, i + 1, j + 1, dp) + mp[j]);
        }
        
        return dp[i][j] = ans;
    }
    
    int maxRemovals(string s, string t, vector<int>& v) {
        unordered_map<int, int> mp;
        for (int i: v) 
        {
            mp[i] = 1;
        }
        
        vector<vector<int>> dp(t.length()+1, vector<int>(s.length()+1, -1));
        
        return v.size() - helper(s, t, mp, 0, 0, dp);
    }
};
",1420095669
i_will_beat_my_iq,i_will_beat_my_iq,202,3604,cpp,"class Solution {
public:
#define mod 1000000007
#define ll long long
vector<ll> p, v, b;

    void f1(int y, int x) {
        p[0] = 1;
        int j = 1;
        while (j <= x) {
            ll temp = p[j - 1] * y;
            p[j] = temp % mod;
            j++;
        }
    }

    void f2(int n, int x) {
        v[0] = 1;
        int i = 1;
        while (i <= n) {
            int j = (i < x) ? i : x;
            while (j >= 1) {
                ll temp1 = v[j] * j;
                v[j] = temp1 % mod;
                ll temp2 = v[j] + v[j - 1];
                v[j] = temp2 % mod;
                j--;
            }
            v[0] = 0;
            i++;
        }
    }

    void f3(int x) {
        b[0] = 1;
        int i = 1;
        while (i <= x) {
            ll temp = b[i - 1] * (x - i + 1);
            b[i] = temp % mod;
            i++;
        }
    }

    int numberOfWays(int n, int x, int y) {
        p.resize(1002, 0);
        v.resize(1002, 0);
        b.resize(1002, 0);

        f1(y, x);
        f2(n, x);
        f3(x);

        ll ct = 0;
        int j = 1;
        while (j <= min(x, n)) {
            ll temp1 = (b[j] * v[j]) % mod;   
            ll temp2 = (temp1 * p[j]) % mod;  
            ct = (ct + temp2) % mod;          
            j++;
        }

        return ct;
    }
};

",1420062866
i_will_beat_my_iq,i_will_beat_my_iq,202,3605,cpp,"class Solution {
public:
int func(int x){
    for(int i=1;i<=x;i++){
        if((i|(i+1)) == x){
            return i;
        }
    }
    return -1;
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            ret[i]=func(nums[i]);
        }
        return ret;
    }
};",1420011934
i_will_beat_my_iq,i_will_beat_my_iq,202,3611,cpp,"class Solution {
public:
int func(int x) {
        vector<int> candidates;
        int y = x;
        while (y > 0) {
            int lsb = y & -y;
            int bitPos = __builtin_ctz(lsb); 
            int candidate = x & (~(1 << bitPos));
            if ((candidate | (candidate + 1)) == x) {
                candidates.push_back(candidate);
            }
            y &= (y - 1);
        }     
        if (candidates.empty()) {
            return -1;
        }
        return *std::min_element(candidates.begin(), candidates.end());
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            ret[i]=func(nums[i]);
        }
        return ret;
    }
};",1420029040
atharv23456x,atharv23456x,204,3487,cpp,"#define ll long long
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n1 = source.size(), n2=pattern.size(), n3 = targetIndices.size();
        vector<ll> dp(n2+1, LLONG_MAX);
        dp[0]=0;
        unordered_map<ll ,ll> mp;
        for(ll i=0; i<n1; i++) mp[i]=0;
        for(ll i=0;i<n3;i++) mp[targetIndices[i]]=1;
        ll ans=n3;
        for(ll i=0; i<n1;i++){
            for(ll j=n2; j>=1; j--){
                if(dp[j-1]!=LLONG_MAX && pattern[j-1]==source[i]){
                    dp[j] = min(dp[j-1]+mp[i], dp[j]);
                }
            }
        }  
        if(dp[n2]!=LLONG_MAX) ans-=dp[n2];
        int finalans = ans;
        return finalans;

    }
};",1420082401
atharv23456x,atharv23456x,204,3604,cpp,"#define ll long long
#define MOD 1000000007
class Solution {
public:


int numberOfWays(int n, int x, int y) {
    vector<vector<long long>> ff(x + 1, vector<long long>(x + 1, 0));
    vector<vector<long long>> sa(n + 1, vector<long long>(x + 1, 0));
    vector<long long> fact(x + 1, 1);
    long long ans = 0;
    sa[0][0] = 1;
    for (int i = 1; i <= x; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    
    for (int i = 0; i <= x; ++i) {
        ff[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            ff[i][j] = (ff[i - 1][j - 1] + ff[i - 1][j]) % MOD;
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= x; ++j) {
            sa[i][j] = (j * sa[i - 1][j] + sa[i - 1][j - 1]) % MOD;
        }
    }
    

    for (int k = 1; k <= x; ++k) {
        long long power = 1;
        for (int p = 0; p < k; ++p) {
            power = (power * y) % MOD;
        }
        long long term = (ff[x][k] * sa[n][k] % MOD * fact[k] % MOD * power) % MOD;
        ans = (ans + term) % MOD;
    }
    int finalans = ans;
    
    return finalans;
}


};",1420062521
atharv23456x,atharv23456x,204,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int currans;
        bool milala;
        for(int i = 0; i < n; i++) {
            currans = INT_MAX;
            milala = false;
            
            for(int j = 0; j < 31; j++) {
                if (1 & (nums[i] >> j)) {
                    int cc = (~(1 << j)) & nums[i];
                    
                    if (cc > 0 && cc < currans && nums[i] == ((cc + 1) | cc)) {
                        milala = true;
                        currans = cc;
                    }
                }
            }
            
            if (milala==false) {
                ans[i] = -1;
            } else {
                ans[i] = currans;
            }
        }
        
        return ans;
    }
};",1420096037
atharv23456x,atharv23456x,204,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int currans;
        bool milala;
        for(int i = 0; i < n; i++) {
            currans = INT_MAX;
            milala = false;
            
            for(int j = 0; j < 31; j++) {
                if (1 & (nums[i] >> j)) {
                    int cc = (~(1 << j)) & nums[i];
                    
                    if (cc > 0 && cc < currans && nums[i] == ((cc + 1) | cc)) {
                        milala = true;
                        currans = cc;
                    }
                }
            }
            
            if (milala==false) {
                ans[i] = -1;
            } else {
                ans[i] = currans;
            }
        }
        
        return ans;
    }
};",1420095504
Frank Rodriguez,whynot4,205,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] inx) {
        dp = new int[source.length()][pattern.length()+1];
        for (int[] d : dp) {
            Arrays.fill(d, -1);
        }
        var set = new HashSet<Integer>();
        for (int i : inx) {
            set.add(i);
        }


        return solve(source.toCharArray(), pattern.toCharArray(), 0, 0, set);
    }

    int INVALID = -1000000;
    int[][] dp;

    int solve(char[] s, char[] p, int i, int j, HashSet<Integer> inx) {
        if (i == s.length) {
            if (j != p.length) {
                return INVALID;
            }
            return 0;
        }
        
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int ans = INVALID;
        if (inx.contains(i)) { // delete it
            ans = Math.max(ans, 1 + solve(s, p, i+1, j, inx));
        }

        ans = Math.max(ans, solve(s, p, i+1, j, inx)); // do nothing
        if (j < p.length && s[i] == p[j]) {
            ans = Math.max(ans, solve(s, p, i+1, j+1, inx));
        }
        return dp[i][j] = ans;
    }
}",1420042401
Frank Rodriguez,whynot4,205,3604,java,"class Solution {
    boolean debug = false;

    public int numberOfWays(int n, int x, int y) {
        long MOD = (int)1e9+7;
        long[][] C = buildPascalsTriangle(1001, MOD);
        long ans = 0;
        var dp = new long[n+1][x+1];
        dp[0][0] = 0;
        for (int i=1; i<dp.length; i++) {
            dp[i][1] = 1;
        }
        Arrays.fill(dp[0], 1);

        for (int i=1; i<=n; i++) {
            for (int j=2; j<=x; j++) {
                if (i < j) {
                    continue;
                }
                dp[i][j] = j * dp[i-1][j] % MOD;
                if (j > 0) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;    
                } else {
                    dp[i][j] = (dp[i][j] + (x - j) ) % MOD;
                }
            }
        }

        if (debug) {
            for (long[] d : dp) {
                System.out.println(Arrays.toString(d));
            }
        }

        long[] f = new long[1001];
        f[0] = 1;
        for (int i=1; i<f.length; i++) {
            f[i] = f[i-1] * i % MOD;
        }

        for (int i=1; i<=x; i++) { // num stages used
            long c = C[x][i] * f[i] % MOD;
            long people = dp[n][i];
            long score = modpow(y, i, MOD);
            if (debug) {
                System.out.println(""trying "" + i + "" stages: "");
                System.out.println("". chosing stages: "" + c);
                System.out.println("". people arrangements: "" + people);
                System.out.println("". score arrangements: "" + score);
            }
            ans = (ans + c * people % MOD * score % MOD) % MOD;
        }
        
        return (int)ans;
    }

    public static long modpow(long a, long b, long mod) {
        if (a == 0) {
            return 0;
        }
        if (a == 1) {
            return mod == 1 ? 0 : 1;
        }
        a %= mod;
        long ans = 1;
        while (b > 0) {
            if ((b & 1) == 1) {
                ans = (ans * a) % mod;
            }
            b >>= 1;
            a = a * a % mod; 
        }

        return ans;
    } 

    public static long[][] buildPascalsTriangle(int n, long MOD) {
        long[][] C = new long[n+1][n+1];
        for (int i=0; i<=n; i++) {
            C[i][0] = 1;
            for (int j=1; j<=i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }

        return C;
    }
}",1420102762
Frank Rodriguez,whynot4,205,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        var ans = new int[n];
        for (int i=0; i<n; i++) {
            if (nums.get(i) == 2) {
                ans[i] = -1;
                continue;
            }
            long val = nums.get(i);
            int j = 0;
            while (((val>>j)&1)==1) {
                j++;
            }
            j--;
            val ^= (1<<j);
            ans[i] = (int)val;
        }
        
        return ans;
    }
}",1420014321
Frank Rodriguez,whynot4,205,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        var ans = new int[n];
        for (int i=0; i<n; i++) {
            if (nums.get(i) == 2) {
                ans[i] = -1;
                continue;
            }
            long val = nums.get(i);
            int j = 0;
            while (((val>>j)&1)==1) {
                j++;
            }
            j--;
            val ^= (1<<j);
            ans[i] = (int)val;
        }
        
        return ans;
    }
}",1420013827
seryp,seryp,206,3487,cpp,"class Solution {
public:
    int cal(string &s, string &p, int a,int b,vector<vector<int>> &dp,vector<int> &vis){
        if(dp[a][b] != -1){
            return dp[a][b];
        }
        if(b > a){
            return dp[a][b] = -2;
        }
        if(a == 0){
            return dp[a][b] = 0;
        }
        if(b == 0){
            int ans = 0;
            if(vis[a-1]){
                ans++;
            }
            dp[a][b]= cal(s,p,a-1,0,dp,vis) + ans;
            return dp[a][b];
        }
        if(s[a-1] == p[b-1]){
            int x = cal(s,p,a-1,b-1,dp,vis);
            if(x != -2){
                if(dp[a][b] == -1 || x > dp[a][b]){
                    dp[a][b] = x;
                }
            }
        }

           int x = cal(s,p,a-1,b,dp,vis); 
           int y = vis[a-1];
           if(x !=-2){
                 if(dp[a][b] == -1 || x + y > dp[a][b]){
                     dp[a][b] = x + y;
                 }
           }
        if(dp[a][b] == -1){
            dp[a][b] = -2;
        }
        return dp[a][b];
    }
    int maxRemovals(string s, string p, vector<int>& tar) {
        int n = s.size(),m = p.size();
        vector<int> vis(n,0);
        for(auto x:tar){
            vis[x] = 1;
        }
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        int ans = cal(s,p,n,m,dp,vis);
        return ans;
        
    }
};",1420096339
seryp,seryp,206,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
       const int mod = 1e9 + 7;
       vector<vector<long long>> dp(n+1,vector<long long>(n+1,0));
       dp[1][1] = x; 
       long long ans = 0;
       for(int i = 2;i <=n;i++){
          dp[i][1] = x;
          for(int j = 2;j <= n && j <= x;j++){
             dp[i][j] = (dp[i-1][j-1] * (x -j + 1) + dp[i-1][j]*j) % mod;
          }
       }
       long long u = 1;
       for(int i = 1;i <= x && i <= n;i++){
          u *= y;
          u = u % mod;
          ans = (ans + dp[n][i] * u) % mod;
          
       }
       return ans;
    }
};",1420055236
seryp,seryp,206,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x:nums){
            if(x % 2 == 0){
                res.push_back(-1);
                continue;
            }
            long long tmp = x;
            long long key = 0;
            long long bit = 1;
            while(tmp & bit){
                bit *=2;
            }
            bit/=2;
            res.push_back(tmp-bit);
        }
        return res;       
    }
};",1420006598
seryp,seryp,206,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x:nums){
            if(x % 2 == 0){
                res.push_back(-1);
                continue;
            }
            long long tmp = x;
            long long key = 0;
            long long bit = 1;
            while(tmp & bit){
                bit *=2;
            }
            bit/=2;
            res.push_back(tmp-bit);
        }
        return res;
    }
};",1420005882
aminjonshermatov,aminjonshermatov,209,3487,cpp,"class Solution {
public:
  int maxRemovals(string s, string t, vector<int>& ids) {
    const auto n = int(ids.size());
    std::vector<bool> may(s.size(), false);
    for (auto id : ids) {
      may[id] = true;
    }
    std::vector<int> sf(s.size() + 1, 0);
    for (auto i = std::ssize(s) - 1, j = std::ssize(t) - 1; i >= 0; --i) {
      if (j >= 0 && s[i] == t[j]) {
        --j;
      }
      sf[i] = std::ssize(t) - j - 1;
    }
    std::vector cache(s.size(), std::vector(t.size() + 1, -1));
    auto dp = [&](auto&& self, int i, int len) -> int {
      if (i >= std::ssize(s)) {
        return 0;
      }
      auto& loc = cache[i][len];
      if (loc != -1) {
        return loc;
      }
      loc = 0;
      if (may[i] && len + sf[i + 1] >= std::ssize(t)) {
        loc = std::max(loc, self(self, i + 1, len) + 1);
      }
      if (len < std::ssize(t) && s[i] == t[len]) {
        loc = std::max(loc, self(self, i + 1, len + 1));
      } else {
        loc = std::max(loc, self(self, i + 1, len));
      }
      return loc;
    };
    return dp(dp, 0, 0);
  }
};",1420103554
aminjonshermatov,aminjonshermatov,209,3604,cpp,"template <int P> class Z {
  int x = 0;
  public:
  static_assert(P <= std::numeric_limits<int>::max() / 2);

  constexpr Z() noexcept = default;
  constexpr Z(long long y) noexcept : x(norm(y)) { }

  static constexpr int getMod() noexcept { return P; }
  [[nodiscard]] constexpr static int norm(long long y) noexcept {
    if (y < -getMod() || y >= getMod()) {
      y %= getMod();
    }
    if (y < 0) {
      y += getMod();
    }
    return static_cast<int>(y);
  }

  [[nodiscard]] constexpr int val() const noexcept { return x; }
  constexpr explicit operator int() const noexcept { return x; }

  constexpr Z operator-() const noexcept {
    return {getMod() - x};
  }
  [[nodiscard]] constexpr Z inverse() const noexcept {
    return pow(getMod() - 2);
  }

  constexpr Z& operator+=(Z other) noexcept {
    x = norm(x + other.val());
    return *this;
  }
  constexpr Z& operator-=(Z other) noexcept {
    x = norm(x - other.val());
    return *this;
  }
  constexpr Z& operator*=(Z other) noexcept {
    x = norm(x * 1LL * other.val());
    return *this;
  }
  constexpr Z& operator/=(Z other) noexcept {
    return *this *= other.inverse();
  }

  constexpr Z& operator++() noexcept {
    operator+=(1);
    return *this;
  }
  constexpr Z operator++(int) const noexcept {
    auto z = *this;
    ++(*this);
    return z;
  }
  constexpr Z& operator--() noexcept {
    operator-=(1);
    return *this;
  }
  constexpr Z operator--(int) const noexcept {
    auto z = *this;
    --(*this);
    return z;
  }

  constexpr Z operator+(Z other) const noexcept {
    return {x + other.val()};
  }
  constexpr Z operator-(Z other) const noexcept {
    return {x - other.val()};
  }
  constexpr Z operator*(Z other) const noexcept {
    return {x * 1LL * other.val()};
  }
  constexpr Z operator/(Z other) const noexcept {
    return other.inverse() * x;
  }

  constexpr bool operator==(Z other) const noexcept {
    return val() == other.val();
  }
  constexpr bool operator!=(Z other) const noexcept {
    return val() != other.val();
  }

  [[nodiscard]] Z pow(long long n) const {
    auto ret = Z(*this);
    Z res = 1;
    for (; n > 0; n >>= 1, ret *= ret) {
      if (n % 2 == 1) {
        res *= ret;
      }
    }
    return res;
  }

  friend std::istream& operator>>(std::istream& in, Z& z) {
    long long y;
    in >> y;
    z = Z{y};
    return in;
  }
  friend std::ostream& operator<<(std::ostream& out, const Z& z) {
    return out << z.val();
  }
};

constexpr int Mod = 1e9 + 7;
using Mint = Z<Mod>;

class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    std::vector<Mint> dp(x + 1);
    dp[0] = 1;
    for (int i = 1; i <= x; ++i) {
      dp[i] = dp[i - 1] * y;
    }
    for (int i = n - 1; i >= 0; --i) {
      std::vector<Mint> ndp(x + 1);
      for (int j = 0; j <= x; ++j) {
        ndp[j] += dp[j] * j;
        if (j + 1 <= x) {
          ndp[j] += dp[j + 1] * (x - j);
        }
      }
      std::swap(dp, ndp);
    }
    return dp[0].val();
  }
};",1420057413
aminjonshermatov,aminjonshermatov,209,3605,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int>& as) {
    const auto n = int(as.size());
    std::vector<int> ret(n, 0);
    for (int i = 0; i < n; ++i) {
      bool f = false;
      for (int j = 0; j < 30; ++j) {
        if (as[i] >> j & 1) {
          ret[i] |= 1 << j;
        } else if (!f) {
          if (j > 0) {
            ret[i] ^= 1 << (j - 1);
          }
          f = true;
        }
      }
      if ((ret[i] | (ret[i] + 1)) != as[i]) {
        ret[i] = -1;
      }
    }
    return ret;
  }
};",1420077702
aminjonshermatov,aminjonshermatov,209,3611,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int>& as) {
    const auto n = int(as.size());
    std::vector<int> ret(n, 0);
    for (int i = 0; i < n; ++i) {
      bool f = false;
      for (int j = 0; j < 30; ++j) {
        if (as[i] >> j & 1) {
          ret[i] |= 1 << j;
        } else if (!f) {
          if (j > 0) {
            ret[i] ^= 1 << (j - 1);
          }
          f = true;
        }
      }
      if ((ret[i] | (ret[i] + 1)) != as[i]) {
        ret[i] = -1;
      }
    }
    return ret;
  }
};",1420078056
Abhishek Choudhary,theabbie,210,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        v = [0] * n
        for i in targetIndices:
            v[i] = 1
        dp = [float('-inf')] * (m + 1)
        ndp = [float('-inf')] * (m + 1)
        dp[m] = 0
        for i in range(n - 1, -1, -1):
            for j in range(m + 1):
                if j < m and source[i] == pattern[j]:
                    ndp[j] = dp[j + 1]
                ndp[j] = max(ndp[j], v[i] + dp[j])
            dp, ndp = ndp, dp
        return dp[0]",1420022791
Abhishek Choudhary,theabbie,210,3604,python3,"M = 10 ** 9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        k = min(n, x)
        dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]
        for i in range(k + 1):
            dp[i][i] = 1
        for i in range(1, k + 1):
            for j in range(i + 1, n + 1):
                dp[i][j] = (i * dp[i][j - 1] + dp[i - 1][j - 1]) % M
        res = 0
        v = x * y
        for choose in range(1, k + 1):
            res += dp[choose][n] * v
            v *= y * (x - choose)
            v %= M
            res %= M
        return res",1420097076
Abhishek Choudhary,theabbie,210,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            x = nums[i]
            b = 0
            while nums[i] & (1 << b):
                b += 1
            if b:
                x &= ~(1 << (b - 1))
            if x | (x + 1) == nums[i]:
                nums[i] = x
            else:
                nums[i] = -1
        return nums",1420039641
Abhishek Choudhary,theabbie,210,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            x = nums[i]
            b = 0
            while nums[i] & (1 << b):
                b += 1
            if b:
                x &= ~(1 << (b - 1))
            if x | (x + 1) == nums[i]:
                nums[i] = x
            else:
                nums[i] = -1
        return nums",1420039188
hero777,hero777,212,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> x(pattern.length() + 1, -1);
        x[0] = 0;
        int index = 0;
        for(int i = 0; i < source.length(); i++){
            // cout << i << ""x\n"";
            // for(int j = 0; j < pattern.length() + 1; j++)
            //     cout << x[j] << '\n';
            if(index < targetIndices.size() && targetIndices[index] == i){
                vector<int> xx(pattern.length()+1, 0);
                xx[0] = x[0] + 1;
                for(int j = 1; j < pattern.length() + 1; j++){
                    if(x[j] == -1){
                        if(pattern[j-1] == source[i]){
                            xx[j] = x[j-1];
                        }
                        else{
                            xx[j] = x[j];
                        }
                    }
                    else{
                        if(pattern[j-1] == source[i]){
                            xx[j] = max(x[j-1], x[j] + 1);
                        }
                        else{
                            xx[j] = x[j] + 1;
                        }
                    }
                }
                x = xx;
                index++;
                continue;
            }
            else{
                vector<int> xx(pattern.length()+1, 0);
                xx[0] = x[0];
                for(int j = 1; j < pattern.length() + 1; j++){
                    if(pattern[j-1] == source[i]){
                        xx[j] = x[j-1];
                    }
                    else{
                        xx[j] = x[j];
                    }
                }
                x = xx;
            }
        }
        return x.back();
    }
};",1420103756
hero777,hero777,212,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        long long mod = 1e9 + 7;
        vector<long long> z(x+1, 0);
        z[1] = x;
        for(int i = 1; i < n; i++){
            vector<long long> zz(x+1, 0);
            zz[1] = x;
            for(int j = 2; j <= x; j++){
                zz[j] = z[j-1]*(x-j+1) + z[j]*j;
                zz[j] %= mod;
            }
            z = zz;
        }
        long long yy = y;
        long long ans = 0LL;
        for(int i = 1; i <= x; i++){
            ans += z[i]*yy;
            ans %= mod;
            yy *= y;
            yy %= mod;
        }
        return ans;
    }
};",1420055486
hero777,hero777,212,3605,cpp,"class Solution {
public:
    int foo(int x){
        int y = x;
        int r = 1;
        while(true){
            if(y % 2 == 0){
                x -= r/2;
                break;
            }
            y /= 2;
            r *= 2;
        }
        return x;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i: nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(foo(i));
        }
        return ans;
    }
};",1420014812
hero777,hero777,212,3611,cpp,"class Solution {
public:
    int foo(int x){
        int y = x;
        int r = 1;
        while(true){
            if(y % 2 == 0){
                x -= r/2;
                break;
            }
            y /= 2;
            r *= 2;
        }
        return x;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i: nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(foo(i));
        }
        return ans;
    }
};",1420013944
QzjkuhhQ17,QzjkuhhQ17,213,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int m = s.size(),n=p.size();
        vector<int> tt(m);
        for(int i:t) tt[i]=true;
        vector<int> skip(n+1,-1);
        skip[0]=0;
        for(int i=0;i<m;i++){
            for(int j=n-1;j>=0;j--) {
                if(skip[j]!=-1 && p[j]==s[i]) skip[j+1]=max(skip[j],skip[j+1] + tt[i]);
                else if(skip[j+1]!=-1) skip[j+1]+=tt[i];
            }
            skip[0]+=tt[i];
            // for(int j:skip) cout << j << ' ';
            // cout << '\n';
        }
        return skip[n];
    }
};",1420103840
QzjkuhhQ17,QzjkuhhQ17,213,3604,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        //1 band -> 3 -> 4
        //2 band -> 3C2 * 2^3 - 3 - 3= 18-> 4^2
        //3 band -> 3C3 * 3^3 - 3C2 * 2^3 = 6 -> 4^3
        const int mod = 1'000'000'007;
        using num=modnum<mod>;
        vector<vector<num>> s(n+1,vector<num>(x+1));
        s[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x;j++) s[i][j]=s[i-1][j-1]+j*s[i-1][j];
        }
        // for(int i=1;i<=n;i++){
        //     for(int j=1;j<=x;j++) cout << (int)s[i][j]<< ' ';
        //     cout << '\n';
        // }
        vector<num> fact(1001);
        fact[0]=1;
        for(int i=1;i<1001;i++)fact[i]=fact[i-1]*i;
        num py=y,re=0;
        for(int i=1;i<=x;i++){
            re+=s[n][i] *fact[i]*fact[x]/fact[i]/fact[x-i] * py;
            py*=y;
        }
        return (int)re;
    }
};",1420069313
QzjkuhhQ17,QzjkuhhQ17,213,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> re;
        for(int i:nums){
            if(i==2){
                re.push_back(-1);
                continue;
            }
            int b=0;
            while(i&1){
                b++;i/=2;
            }
            if(!i) re.push_back((1<<(b-1))-1);
            else re.push_back((i<<b) + (1<<(b-1)) - 1);
            
        }
        return re;
    }
};",1420010726
QzjkuhhQ17,QzjkuhhQ17,213,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> re;
        for(int i:nums){
            if(i==2){
                re.push_back(-1);
                continue;
            }
            int b=0;
            while(i&1){
                b++;i/=2;
            }
            if(!i) re.push_back((1<<(b-1))-1);
            else re.push_back((i<<b) + (1<<(b-1)) - 1);
            
        }
        return re;
    }
};",1420010961
yc-li,yc-li,214,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        unordered_set<int> ts(t.begin(), t.end());
        auto n = s.size(), m = p.size();  
        // cout << n << m;      
        vector<vector<int>> d(n + 1, vector<int>(m + 1, -99999));

        // for (auto j = 0; j < m; ++j)
        // {
        //     d[n][j] = -99999;
        // }
        d[n][m] = 0;

        for (int i = n; i --> 0; )
        {
            for (int j = m + 1; j --> 0; )
            {
                if (j < m && s[i] == p[j])
                    d[i][j] = max(d[i][j], d[i + 1][j + 1]);
                
                d[i][j] = max(d[i][j], d[i + 1][j]);

                if (ts.contains(i))
                    d[i][j] = max(d[i][j], d[i + 1][j] + 1);
            
                // cout << i << "" "" << j << "" "" << d[i][j] << ""\n"";
            }
        }

        return d[0][0];

    }
};",1420046107
yc-li,yc-li,214,3604,python3,"C = [[1 for j in range(i + 1)] for i in range(1001)]
MOD = 10**9 + 7

for i in range(1, 1001):
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

class Solution:
    
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        ans = 0
        prev = [0] * 1001
        coef = 1
        grps = 0


        for i in range(1, x + 1):
            # ans += binomial
            coef = (coef * y) % MOD
            grps = pow(i, n, MOD)

            for j in range(1, i):
                # print(i, j, C[i][j], grps)
                grps -= ((C[i][j] * prev[j]) % MOD)
                # print(i, j, C[i][j], prev[j], grps)

            prev[i] = grps
            grps = (grps * C[x][i]) % MOD
            ans += ((coef * grps) % MOD)
            ans %= MOD

            # print(prev[:i + 1], coef, grps)
        return ans
",1420104015
yc-li,yc-li,214,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        ans = []

        for i in nums:
            s = list(bin(i)[2:])
            if s[-1] == ""0"":
                ans.append(-1)
                continue
            
            k = len(s) - 1
            while k >= 0 and s[k] == ""1"":
                k -= 1
            
            s[k + 1] = ""0""
            # print(s)
            ans.append(int("""".join(s), 2))

        return ans

",1420007984
yc-li,yc-li,214,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        ans = []

        for i in nums:
            s = list(bin(i)[2:])
            if s[-1] == ""0"":
                ans.append(-1)
                continue
            
            k = len(s) - 1
            while k >= 0 and s[k] == ""1"":
                k -= 1
            
            s[k + 1] = ""0""
            # print(s)
            ans.append(int("""".join(s), 2))

        return ans

",1420007657
Amandeep Verma,aman_2005,215,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    string a,b;
    int n,m;
    int vis[3001];
    
    int help(int i,int j){
        if(i==n){
            return (j==m ? 0 : 1e4);
        }
        if(j==m){
            return 0;
        }
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        int ans=1e4;
        if(a[i]==b[j]){
            ans=vis[i]+help(i+1,j+1);
        }
        ans=min(ans,help(i+1,j));
        return dp[i][j]=ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& target) {
        a=source,b=pattern;
        n=a.size(),m=b.size();
        for(int i=0;i<n;i++){
            vis[i]=0;
            for(int j=0;j<m;j++){
                dp[i][j]=-1;
            }
        }
        for(auto x:target){
            vis[x]=1;
        }
        int ans=help(0,0);
        int sz=target.size();
        return sz-ans;
    }
};",1420030286
Amandeep Verma,aman_2005,215,3604,cpp,"#define ll long long
#define mod 1000000007
class Solution {
public:
    ll mul(ll a, ll b)
    {
        return ((a % mod) * (b % mod)) % mod;
    }

    ll add(ll a, ll b)
    {
        return ((a % mod) + (b % mod)) % mod;
    }
    
    ll sub(ll a, ll b)
    {
        return (a - b + mod) % mod;
    }
    
    ll fastpow(ll a, ll p){
        ll res = 1;
        while (p){
            if (p % 2 == 0){
                a = a * 1ll * a % mod;
                p /= 2;
            }
            else{
                res = res * 1ll * a % mod;
                p--;  
            }
        }
        return res;
    }
    
    ll fac[1001];
    void fact(ll n)
    {
        ll res = 1;
        fac[0]=1;
        for (ll i = 1; i <= n; i++)
        {
            res = res * 1ll * i % mod;
            fac[i]=res;
        }
    }
    
    ll comb(ll n, ll k)
    {
        if(k>n){
            return 0;
        }
        return fac[n] * 1ll * fastpow(fac[k], mod - 2) % mod * 1ll * fastpow(fac[n - k], mod - 2) % mod;
    }
    
    ll help(ll i,ll left,ll x){
        if(i==x){
            return (left==0);
        }
        // if(dp[i][left]!=-1){
        //     return dp[i][left];
        // }
        if(left==0){
            return 0;
        }
        ll ans=0;
        for(ll j=1;j<=left;j++){
            ans=add(ans,mul(comb(left,j),help(i+1,left-j,x)));
        }
        return ans;
    }
    
    ll help(ll n,ll k){
        ll ans = 0;
        for(ll i=k;i>=0;i--){
            if(i%2==k%2){
                ans=add(ans,mul(fastpow(i,n),comb(k,i)));
            }
            else{
                ans=sub(ans,mul(fastpow(i,n),comb(k,i)));
            }
        }
        return ans;
    }
 
    int numberOfWays(int n, int x, int y) {
        fact(max(x,n));
        ll ans=0;
        for(ll i=1;i<=x;i++){
            if(n<i){
                continue;
            }
            ll choose=comb(x,i);
            ll score_ways=fastpow(y,i);
            ll ways=help(n,i);
            // cout<<choose<<"" ""<<score_ways<<"" ""<<ways<<""\n"";
            ans=add(ans,mul(mul(1,choose),mul(score_ways,ways)));
        }
        return ans;
    }
};",1420097540
Amandeep Verma,aman_2005,215,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x:nums){
            if(x%2){
                int bit=0;
                for(int i=0;i<=30;i++){
                    if((x & (1<<i))>0){
                        bit=i;
                    }
                    else{
                        break;
                    }
                }
                int tmp=0;
                for(int i=0;i<bit;i++){
                    tmp+=(1<<i);
                }
                for(int i=bit+1;i<=30;i++){
                    if((x & (1<<i))>0){
                        tmp+=(1<<i);
                    }
                }
                ans.push_back(tmp);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420006185
Amandeep Verma,aman_2005,215,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x:nums){
            if(x%2){
                int bit=0;
                for(int i=0;i<=30;i++){
                    if((x & (1<<i))>0){
                        bit=i;
                    }
                    else{
                        break;
                    }
                }
                int tmp=0;
                for(int i=0;i<bit;i++){
                    tmp+=(1<<i);
                }
                for(int i=bit+1;i<=30;i++){
                    if((x & (1<<i))>0){
                        tmp+=(1<<i);
                    }
                }
                ans.push_back(tmp);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420006682
AKJ003,AKJ003,216,3487,cpp,"class Solution {
public:
     long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    int findMinimalX(int target) {
       if (target == 2) return -1;

        int candidate = (1 << (31 - __builtin_clz(target))) - 1;

        if (candidate < target) {
            return candidate;
        }

        // If not valid, return -1
        return -1;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420075347
AKJ003,AKJ003,216,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
     long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    int findMinimalX(int target) {
       if (target == 2) return -1;

        int candidate = (1 << (31 - __builtin_clz(target))) - 1;

        if (candidate < target) {
            return candidate;
        }

        // If not valid, return -1
        return -1;
    }


    int numberOfWays(int n, int x, int y) {
        
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420104145
AKJ003,AKJ003,216,3605,cpp,"class Solution {
public:
    long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) { // If exp is odd
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); 
        for (int i = 0; i < nums.size(); ++i) {
            int target = nums[i];
            for (int x = 0; x < target; ++x) {
                if ((x | (x + 1)) == target) {
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};",1419995493
AKJ003,AKJ003,216,3611,cpp,"#include <vector>
#include <cmath>

class Solution {
public:
    long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    int findMinimalX(int target) {
       if (target == 2) return -1;

        int candidate = (1 << (31 - __builtin_clz(target))) - 1;

        if (candidate < target) {
            return candidate;
        }

        // If not valid, return -1
        return -1;
    }

    vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; ++bit) {
                if ((num >> bit) & 1) { 
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};
",1420041260
Huzaifa Khilawala,RedHeadphone,217,3487,python3,"

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        suffix_dp = [0] * n
        
        pattern_stack = list(pattern)
        for i in range(n-2, -1, -1):
            to_add = 0
            if len(pattern_stack) > 0 and source[i+1] == pattern_stack[-1]:
                to_add = 1
                pattern_stack.pop()
            suffix_dp[i] = suffix_dp[i+1]+to_add

        dp = [[-math.inf]*(m +1)
              for _ in range(2)]
        dp[0][0] = 0
        dp[1][0] = 0
        ans = 0

        targetIndices_set = set(targetIndices)

        for i in range(n):

            for j in range(m,-1,-1):
                if j + suffix_dp[i] >= m and dp[0][j] != -math.inf and i in targetIndices_set:
                    dp[1][j] = max(dp[1][j], dp[0][j] + 1)
                    ans = max(ans, dp[1][j])
                if j < m:
                    if source[i]==pattern[j]:
                        dp[1][j+1] = max(dp[1][j+1], dp[0][j])
            dp[0], dp[1] = dp[1], dp[0]
            for j in range(m+1):
                dp[1][j] = max(dp[1][j],-math.inf,dp[0][j])
        return ans ",1420055496
Huzaifa Khilawala,RedHeadphone,217,3604,python3,"
class Combinatorics:
    def __init__(self, pre_compute_limit=0):
        self.fact = [1] * pre_compute_limit
        self.invfact = [1] * pre_compute_limit
        for i in range(1, pre_compute_limit):
            self.fact[i] = (self.fact[i - 1] * i) % MOD
            self.invfact[i] = (self.invfact[i - 1] * pow(i, MOD - 2, MOD)) % MOD

    def ncr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[r] * self.invfact[n - r]) % MOD

    def npr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[n - r]) % MOD

    def ncr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = den = 1
        for i in range(r):
            num = (num * (n - i)) % MOD
            den = (den * (i + 1)) % MOD
        return (num * pow(den, MOD - 2, MOD)) % MOD

    def npr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = 1
        for i in range(n, n - r, -1):
            num = (num * i) % MOD
        return num


MOD = 10**9 + 7
comb = Combinatorics(1000 + 50)

fact = [1] * (1000 + 50)
for i in range(1, 1000 + 50):
    fact[i] = (fact[i - 1] * i) % MOD

def stirling_second_kind(n, k):
    stirling_num = 0
    for i in range(k+1):
        stirling_num += (pow(-1,k-i,MOD) * comb.ncr(k, i) * pow(i,n,MOD)) % MOD
    # stirling_num //= fact[k]
    return stirling_num

def distributions_non_empty_buckets(n, x):
    if x > n:
        return 0 
    return ( stirling_second_kind(n, x)) %  MOD

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0

        for stage_sel in range(1, x+1):
            curr = distributions_non_empty_buckets(n, stage_sel) 
            ans += curr * pow(y, stage_sel, MOD) * comb.ncr(x, stage_sel)
            ans %= MOD

        return ans",1420090804
Huzaifa Khilawala,RedHeadphone,217,3605,python3,"
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            if i == 2:
                ans.append(-1)
            else:
                binn = list(bin(i)[2:])
                last_ones = 0
                for i in range(len(binn)):
                    if binn[-i - 1] == ""1"":
                        last_ones +=1
                    else:
                        break
                
                if last_ones != 0:
                    binn[-(last_ones-1)-1] = ""0""
                
                ans.append(int("""".join(binn), 2))
        return ans",1420003600
Huzaifa Khilawala,RedHeadphone,217,3611,python3,"
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            if i == 2:
                ans.append(-1)
            else:
                binn = list(bin(i)[2:])
                last_ones = 0
                for i in range(len(binn)):
                    if binn[-i - 1] == ""1"":
                        last_ones +=1
                    else:
                        break
                
                if last_ones != 0:
                    binn[-(last_ones-1)-1] = ""0""
                
                ans.append(int("""".join(binn), 2))
        return ans",1420004062
Ankit Anand,ankitanand2125,218,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const int n = source.size();
        const int m = pattern.size();
        const int K = n + 1;
        
        vector<bool> result(n, false);
        for(auto i: targetIndices){
            result[i] = true;
        }
        
        vector<int> dp(m + 1, K);
        dp[0] = 0; 
        
        for(int s = 0; s < n; s++){
            for(int p = min(m, s + 1); p >= 1; p--){
                if(source[s] == pattern[p - 1]){
                    if(result[s]){
                        dp[p] = min(dp[p], dp[p - 1] + 1);
                    }
                    else{
                        dp[p] = min(dp[p], dp[p - 1]);
                    }
                }
            }
        }
        
        if(dp[m] > targetIndices.size()){
            return 0;
        }
    
        return targetIndices.size() - dp[m];
    }
};
",1420084743
Ankit Anand,ankitanand2125,218,3604,cpp,"const int MOD = 1e9 + 7;

long long pw(long long a, long long b) {
    long long res = 1;
    a %= MOD;
    while(b > 0){
        if(b & 1){
            res = res * a % MOD;
        }
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int mx = 1000;
        vector<long long> fact(mx + 1, 1);
        for(int i = 1; i <= mx; i++) fact[i] = fact[i-1] * i % MOD;
        

        vector<long long> inv_f(mx + 1, 1);
        inv_f[mx] = pw(fact[mx], MOD - 2);
        for(int i = mx - 1; i >= 0; i--) inv_f[i] = inv_f[i+1] * (i + 1) % MOD;
        

        vector<int> inp = {n, x, y};
        

        vector<long long> S_prev(x + 1, 0), S_curr(x + 1, 0);
        S_prev[0] = 1; 
        for(int i = 1; i <= n; i++) {
            S_curr.assign(x + 1, 0);
            for(int k = 1; k <= min(i, x); k++) {
                S_curr[k] = (S_prev[k-1] + k * S_prev[k]) % MOD;
            }
            S_prev = S_curr;
        }
        

        vector<long long> y_p(x + 1, 1);
        for(int k = 1; k <= x; k++) y_p[k] = y_p[k-1] * y % MOD;
        

        long long res = 0;
        for(int k = 1; k <= min(x, n); k++) {
            long long C = fact[x] * inv_f[k] % MOD;
            C = C * inv_f[x - k] % MOD;
            
            long long S = S_prev[k];
            long long kf = fact[k];
            long long yp = y_p[k];
            
            long long tmp = C * S % MOD;
            tmp = tmp * kf % MOD;
            tmp = tmp * yp % MOD;
            res = (res + tmp) % MOD;
        }
        
        return (int) res;
    }
};
",1420090983
Ankit Anand,ankitanand2125,218,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        const int N = 1000;
        const int n = nums.size();
        map<int, pair<int, int>> record;
        
        for(int i = 1; i <= N; ++i) {
            int val = i | (i + 1);
            if(record.find(val) == record.end()) {
                record[val] = {i, i + 1};
            }
        }
        
        vector<int> result;
        for(int i = 0; i < n; ++i) {
            if(record.find(nums[i]) != record.end()) {
                pair<int, int> rec = record[nums[i]];
                
                result.push_back(rec.first);
            }
            else {
                result.push_back(-1);
            }
        }
        
        return result;
    }
};",1420016250
Ankit Anand,ankitanand2125,218,3611,cpp,"class Solution {
    
public:
    std::string decimalToBinary(int decimal) {
        if (decimal == 0) {
            return ""0"";
        }

        std::string binary = """"; 
        while (decimal > 0) {
            binary = std::to_string(decimal % 2) + binary;
            decimal /= 2; 
        }

        return binary; 
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> result(n);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            if(num % 2 == 0) {
                result[i] = -1;
                continue;
            }
            
            string curr = decimalToBinary(num);
            reverse(curr.begin(), curr.end());
            int index = 0;
            while(index < curr.size() && curr[index] == '1') index++;
            
            int maxVal = (1 << index) - 1;
            int val = nums[i] - maxVal + (maxVal / 2);
            
            // cout << val << "" "" << maxVal << endl;
            
            for(int j = -5; j < 5; ++j) {
                int prev = val + j, next = prev | (prev + 1);
                if(next == num) {
                    result[i] = prev;
                    break;
                }
            }
        }
        
        return result;
    }
};",1420061979
zsq007,zsq007,219,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m, tar = len(source), len(pattern), set(targetIndices)

        dp = [0] + [-inf]*m 
        for i,c in enumerate(source):
            if i in tar:
                for j in range(m, 0, -1):
                    if pattern[j-1] == c:
                        dp[j] = max(dp[j]+1, dp[j-1])
                    else:
                        dp[j] += 1
                dp[0] += 1
            else:
                for j in range(m, 0, -1):
                    if pattern[j-1] == c:
                        dp[j] = max(dp[j], dp[j-1])
            # print(dp)
        return dp[-1]",1420027023
zsq007,zsq007,219,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        res, mod = 0, 10**9+7

        combs = [[1]+[0]*x for _ in range(x+1)]

        for i in range(1, x+1):
            for j in range(1, i+1):
                combs[i][j] = (combs[i-1][j-1] + combs[i-1][j]) % mod

        dp = [0]*(x+1)

        for stage in range(1, x+1):
            dp[stage] = (pow(stage, n, mod) - sum(dp[i] * combs[stage][i] % mod for i in range(stage))) % mod

        # print(dp)
        p = 1
        for stage in range(1, min(n, x)+1):
            cur = (combs[x][stage] * dp[stage]) % mod
            p = p * y % mod
            # print(empty, cur, grades, res)
            res += cur * p % mod
            # res += (comb(x, empty) % mod) * (pow(x-empty, n, mod) % mod) * pow(y, x-empty, mod) % mod
        
        return res % mod",1420091014
zsq007,zsq007,219,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if num == 2:
                res.append(-1)
            else:
                i = 0
                while num & 1<<i:
                    i += 1
                num ^= 1 << i-1
                res.append(num)
        return res",1419998007
zsq007,zsq007,219,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if num == 2:
                res.append(-1)
            else:
                i = 0
                while num & 1<<i:
                    i += 1
                num ^= 1 << i-1
                res.append(num)
        return res",1419998463
xymabinogi,xymabinogi,221,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& idx) {
         int n = s.length(), m = p.length();
        vector<int> suf(n + 2, 0);
        
//         for (int i = n - 1, j = m - 1; i >= 0; i--){
//             if (j >= 0 and s[i] == p[j]){
//                 j--;
//             }
//             suf[i + 1] = max(suf[i + 2], m - 1 - j);
//         }
        
        unordered_set<int> seen(idx.begin(), idx.end());
        
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));
        
        dp[0][0] = 0;
        
        for (int i = 0; i <= m; i++){
            for (int j = 0; j < n; j++){
                if (dp[i][j] == -1) continue;
                
                if (i < m and p[i] == s[j]){
                    //don't remove
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                    
                    // if (suf[j + 1] >= m - j){ //ok to remove
                    //     dp[i][j + 1] = dp[i][j] + (seen.count(j) ? 1 : 0);
                    // }
                    // else dp[i][j + 1] = dp[i][j];
                }
                dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + (seen.count(j) ? 1 : 0));
                // else {
                //     dp[i][j + 1] = dp[i][j] + (seen.count(j) ? 1 : 0);
                // }
                
            }
        }
//         for (int i = 0; i <= m; i++){
//             for (int j = 0; j < n; j++){
//                 cout << dp[i][j] << "" \n""[j == n - 1];       
//             }
//         }
        
        
        
        return dp[m][n];
        
        
    }
};",1420096618
xymabinogi,xymabinogi,221,3604,cpp,"using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1E9 + 7;
using Z = MInt<P>;
 
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<Z>> S(n + 1, vector<Z>(x + 1, Z(0)));
        S[0][0] = Z(1);
        for(int i = 1; i <= n; ++i){
            for(int k = 1; k <= min(i, x); ++k){
                S[i][k] = Z(k) * S[i-1][k] + S[i-1][k-1];
            }
        }
        Z res = Z(0);
        int max_k = min(x, n);
        for(int k = 1; k <= max_k; ++k){
            Z term = comb.binom(x, k) * S[n][k] * comb.fac(k) * power(Z(y), k);
            res += term;
        }
        return res.val();
    }
};",1420104426
xymabinogi,xymabinogi,221,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> res;
        for (auto v : nums){
            if (v == 2) {
                res.push_back(-1);
                continue;
            }
            int left = 0;
            for (int i = 0; i <= 30; i++){
                if (1 & (v >> i)) left = i;
                else break;
            }
            //cout << left << ""\n"";
            if (left == 0){
                res.push_back(v - 1);
            }
            else {
                int x = (v >> (left + 1)) << (left + 1);
                x += (1 << left) - 1;
                res.push_back(x);
                
            }

        }
        return res;
    }
};",1420022909
xymabinogi,xymabinogi,221,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> res;
        for (auto v : nums){
            if (v == 2) {
                res.push_back(-1);
                continue;
            }
            int left = 0;
            for (int i = 0; i <= 30; i++){
                if (1 & (v >> i)) left = i;
                else break;
            }
            //cout << left << ""\n"";
            if (left == 0){
                res.push_back(v - 1);
            }
            else {
                int x = (v >> (left + 1)) << (left + 1);
                x += (1 << left) - 1;
                res.push_back(x);
                
            }

        }
        return res;
    }
};",1420022637
JeffreyLC,JeffreyLC,222,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const int n = source.length();
        const int m = pattern.length();
        vector<bool> target(n);
        for (int idx : targetIndices) {
            target[idx] = true;
        }
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));
        dp[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (dp[i][j] != INT_MIN) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + (target[i] ? 1 : 0));
                }
            }
            for (int j = 0; j < m; ++j) {
                if (source[i] == pattern[j] && dp[i][j] != INT_MIN) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
            }
        }
        return dp[n][m];
    }
};",1420062960
JeffreyLC,JeffreyLC,222,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        constexpr int MOD = 1e9 + 7;
        vector<vector<int>> pascal = PascalTriangle(x, MOD);
        vector<long long> cnt(x + 1);
        for (int i = 1; i <= x; ++i) {
            cnt[i] = BigMod(i, n, MOD);
            for (int r = i - 1; r >= 1; --r) {
                cnt[i] -= cnt[r] * pascal[i][r];
                cnt[i] %= MOD;
                cnt[i] += MOD;
                cnt[i] %= MOD;
            }
        }
        long long ans = 0;
        for (int i = 1; i <= x; ++i) {
            ans += cnt[i] * pascal[x][i] % MOD * BigMod(y, i, MOD);
            ans %= MOD;
        }
        return ans;
        
    }
private:
    vector<vector<int>> PascalTriangle(int n, int mod) {
        vector<vector<int>> pascal_triangle;
        vector<int> row;
        for (int i = 0; i <= n; ++i) {
            row.push_back(1 % mod);
            for (int j = i - 1; j > 0; --j) {
                row[j] = (row[j - 1] + row[j]) % mod;
            }
            pascal_triangle.push_back(row);
        }
        return pascal_triangle;
    }
    
    int BigMod(long long a, long long p, int mod) {
        if (p == 0) return 1 % mod;
        long long t = BigMod(a % mod, p >> 1, mod);
        t = t * t % mod;
        if (p & 1) {
            t = t * (a % mod) % mod;
        }
        return t;
    }
};",1420098074
JeffreyLC,JeffreyLC,222,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 2) {
                ans[i] = -1;
            } else {
                int lsb = LowSignificantBit(~nums[i]);
                if (lsb == nums[i] + 1) {
                    ans[i] = nums[i] / 2;
                } else {
                    ans[i] = nums[i] - lsb / 2;
                }
            }
        }
        return ans;
    }
private:
    int LowSignificantBit(int num) {
        return num & (-num);
    }
};",1419999679
JeffreyLC,JeffreyLC,222,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 2) {
                ans[i] = -1;
            } else {
                int lsb = LowSignificantBit(~nums[i]);
                if (lsb == nums[i] + 1) {
                    ans[i] = nums[i] / 2;
                } else {
                    ans[i] = nums[i] - lsb / 2;
                }
            }
        }
        return ans;
    }
private:
    int LowSignificantBit(int num) {
        return num & (-num);
    }
};",1419999463
fpeterfalvi,fpeterfalvi,223,3487,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int p = pattern.length();
        int t = targetIndices.length;
        List<List<Integer>> letterOccurrences = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            letterOccurrences.add(new ArrayList<>());
        }
        for (int i = 0; i < p; i++) {
            letterOccurrences.get(pattern.charAt(i) - 'a').add(i);
        }
        int[] addedMaxReached = new int[t + 1];
        int i = 0;
        for (int k = 0; k < targetIndices[0]; k++) {
            char c = source.charAt(k);
            if (i == p) {
                break;
            }
            if (c == pattern.charAt(i)) {
                i++;
            }
        }
        addedMaxReached[0] = i;
        for (int l = 0; l < t; l++) {
            int targetIndex = targetIndices[l];
            int[] newAddedMaxReached = new int[t + 1];
            for (int j = 0; j <= l; j++) {
                i = addedMaxReached[j];
                for (int k = targetIndex + 1; k < (l < t - 1 ? targetIndices[l + 1] : n); k++) {
                    char c = source.charAt(k);
                    if (i == p) {
                        break;
                    }
                    if (c == pattern.charAt(i)) {
                        i++;
                    }
                }
                newAddedMaxReached[j] = Math.max(newAddedMaxReached[j], i);
                i = addedMaxReached[j];
                for (int k = targetIndex; k < (l < t - 1 ? targetIndices[l + 1] : n); k++) {
                    char c = source.charAt(k);
                    if (i == p) {
                        break;
                    }
                    if (c == pattern.charAt(i)) {
                        i++;
                    }
                }
                newAddedMaxReached[j + 1] = Math.max(newAddedMaxReached[j + 1], i);
            }
            addedMaxReached = newAddedMaxReached;
        }
        for (int j = 0; j <= t; j++) {
            if (addedMaxReached[j] == p) {
                return t - j;
            }
        }
        return -1;
    }
}",1420057559
fpeterfalvi,fpeterfalvi,223,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        long MOD = (long)1e9 + 7;
        calculate_factorial(Math.max(n, x), MOD);
        long ways = 0;
        for (int bands = 1; bands <= Math.min(n, x); bands++) {
            long possibilities = 0;
            for (int i = 0; i < bands; i++) {
                possibilities = ((possibilities + ((i % 2 == 0) ? 1 : -1) * choose(bands, i, MOD) * power(bands - i, n, MOD) % MOD) % MOD + MOD) % MOD;
            }
            ways = (ways + possibilities * choose(x, bands, MOD) % MOD * power(y, bands, MOD) % MOD) % MOD;
        }
        return (int)ways;
    }

    long[] factorial;

    void calculate_factorial(int N, long p) {
        factorial = new long[N + 1];
        factorial[0] = 1;
        for (int i = 1; i <= N; i++) {
            factorial[i] = factorial[i - 1] * i % p;
        }
    }

    long choose(int n, int k, long p) {
        return factorial[n] * inverse(factorial[k] * factorial[n - k] % p, p) % p;
    }

    public static long inverse(long a, long n) {
        long t = 0;
        long newt = 1;
        long r = n;
        long newr = a;
        while (newr != 0) {
            long quotient = r / newr;
            long newt_temp = newt;
            newt = t - quotient * newt;
            t = newt_temp;
            long newr_temp = newr;
            newr = r - quotient * newr;
            r = newr_temp;
        }
        if (r > 1) {
            // a is not invertible
            return -1;
        }
        if (t < 0) {
            t += n;
        }
        return t;
    }

    public static long power(long x, long y, long p) {
        long res = 1;
        x = x % p;
        while (y > 0) {
            if ((y & 1) != 0) {
                res = (res * x) % p;
            }
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }
}",1420098110
fpeterfalvi,fpeterfalvi,223,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            if (p == 2) {
                result[i] = -1;
                continue;
            }
            if (Integer.bitCount(p + 1) == 1) {
                result[i] = (p + 1) / 2 - 1;
                continue;
            }
            int last0 = 0;
            while ((1 << last0 & p) != 0) {
                last0++;
            }
            result[i] = p - (1 << (last0 - 1));
        }
        return result;
    }
}",1420003695
fpeterfalvi,fpeterfalvi,223,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            if (p == 2) {
                result[i] = -1;
                continue;
            }
            if (Integer.bitCount(p + 1) == 1) {
                result[i] = (p + 1) / 2 - 1;
                continue;
            }
            int last0 = 0;
            while ((1 << last0 & p) != 0) {
                last0++;
            }
            result[i] = p - (1 << (last0 - 1));
        }
        return result;
    }
}",1420002680
Anshul Agarwal,anshulagarwal3131,224,3487,cpp,"int dp[3001][3001];
class Solution {
public:
    vector<int> ind,v;
    int n,m;
    int solve(int i,int j,string &src,string &pat){
        if(j==m)
            return v[i];
        if(i==n)
            return -1e6;
        if(dp[i][j]!=-1)
            return dp[i][j];
        if(ind[i]){
            if(src[i]==pat[j])
                return dp[i][j] = max(solve(i+1,j+1,src,pat),1+solve(i+1,j,src,pat));
            return dp[i][j] = 1+solve(i+1,j,src,pat);
        }
        else{
            if(src[i]==pat[j])
                return dp[i][j] = solve(i+1,j+1,src,pat);
            return dp[i][j] = solve(i+1,j,src,pat);
        }
        return 0;
    }
    int maxRemovals(string source, string pattern, vector<int>& ti) {
        n = source.size(),m = pattern.size();
        ind.resize(n);
        v.resize(n+1);
        for(auto i : ti)
            ind[i] = 1;
        v[n-1] = ind[n-1];
        for(int i = n-2;i>=0;i--)
            v[i] = v[i+1]+ind[i];
        memset(dp,-1,sizeof(dp));
        return solve(0,0,source,pattern);
        
    }
};",1420027523
Anshul Agarwal,anshulagarwal3131,224,3604,cpp,"
long long dp[1001][1001];
class Solution {
public:
    int mod = 1e9+7;
    long long solve(int i,int j,int n,int x,int y){
       if(!i)
           return 1;
        if(dp[i][j]!=-1)
            return dp[i][j];
        if(j==x)
            return dp[i][j] = (j*solve(i-1,j,n,x,y))%mod;
        return dp[i][j] = ((x-j)*y*solve(i-1,j+1,n,x,y)+j*solve(i-1,j,n,x,y))%mod;
        
    }
    int numberOfWays(int n, int x, int y) {
        memset(dp,-1,sizeof(dp));
        return solve(n,0,n,x,y);
       
    }
};",1420104686
Anshul Agarwal,anshulagarwal3131,224,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto i : nums){
            if(!(i%2)){
                res.push_back(-1);
                continue;
            }
            int j = 0,x = i;
            while(x%2){
                x/=2;
                j++;
            }
            res.push_back((1<<(j-1))^i);
        }
        return res;
    }
};",1420001143
Anshul Agarwal,anshulagarwal3131,224,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto i : nums){
            if(!(i%2)){
                res.push_back(-1);
                continue;
            }
            int j = 0,x = i;
            while(x%2){
                x/=2;
                j++;
            }
            res.push_back((1<<(j-1))^i);
        }
        return res;
    }
};",1420000732
InfiniteLoops,ShriyamThor,226,3487,cpp,"#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());
        vector<int> dp(m + 1, INT32_MAX);
        dp[0] = 0;
        for(int i = 0; i < n; ++i){
            for(int j = min(m, (int)(m)); j >=1; --j){
                if(source[i] == pattern[j-1] && dp[j-1] != INT32_MAX){
                    int cost = targetSet.find(i) != targetSet.end() ? 1 : 0;
                    dp[j] = min(dp[j], dp[j-1] + cost);
                }
            }
        }
        if(dp[m] == INT32_MAX) return 0;
        return targetIndices.size() - dp[m];
    }
};
",1420051255
InfiniteLoops,ShriyamThor,226,3604,cpp,"#include <vector>
#include <string>
using namespace std;

const int MOD = 1'000'000'007;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
    
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= x; ++j){
                S[i][j] = (S[i-1][j-1] + j * S[i-1][j]) % MOD;
            }
        }
        
 
        vector<long long> fact(x + 1, 1);
        for(int i = 1; i <= x; ++i){
            fact[i] = fact[i-1] * i % MOD;
        }
        

        vector<long long> y_pows(x + 1, 1);
        for(int i = 1; i <= x; ++i){
            y_pows[i] = y_pows[i-1] * y % MOD;
        }
        
     
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        C[0][0] = 1;
        for(int i = 1; i <= x; ++i){
            C[i][0] = 1;
            for(int j = 1; j <= i; ++j){
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        
        long long res = 0;
        int max_k = min(x, n);
        for(int k = 1; k <= max_k; ++k){
        
            long long comb = C[x][k];
            long long ways = comb * fact[k] % MOD;
         
            ways = ways * S[n][k] % MOD;
            ways = ways * y_pows[k] % MOD;
            res = (res + ways) % MOD;
        }
        return (int)res;
    }
};
",1420105078
InfiniteLoops,ShriyamThor,226,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num : nums){
            bool found = false;
            int candidate = -1;
            for(int a = 0; a < num; ++a){
                if( (a | (a + 1)) == num ){
                    candidate = a;
                    found = true;
                    break; 
                }
            }
            if(found){
                ans.push_back(candidate);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};
",1419994676
InfiniteLoops,ShriyamThor,226,3611,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x : nums){
            int min_a = -1;
      
            for(int bit = 0; bit < 30; bit++){
        
                if(x & (1 << bit)){
                
                    int a = x & (~(1 << bit));
             
                    if(a < 0 || a >= x){
                        continue;
                    }
                
                    if( (a | (a +1)) == x ){
                        if(min_a == -1 || a < min_a){
                            min_a = a;
                        }
                    }
                }
            }
            ans.push_back(min_a);
        }
        return ans;
    }
};
",1420005038
achintya7567,achintya7567,227,3487,cpp,"class Solution {
public:
    int rec(int i, int j, vector<vector<int>> &dp, string &s, string &p, set<int>& v){
        if(dp[i][j]!=-1)return dp[i][j];
        if(i==s.size()&&j==p.size()){
            return dp[i][j]=0;
        }
        else if(i==s.size()&&j<p.size())return dp[i][j]=-1000000;
        else if(j==p.size()){
            return dp[i][j]=v.count(i)+rec(i+1,j,dp,s,p,v);
        }
        int ans=0;
        ans=rec(i+1,j,dp,s,p,v);
        if(s[i]==p[j])ans=max(ans,rec(i+1,j+1,dp,s,p,v));
        if(v.count(i))ans=max(ans,1+rec(i+1,j,dp,s,p,v));
        return dp[i][j]=ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<vector<int>> dp(source.size()+1,vector<int>(pattern.size()+1,-1));
        set<int> t(targetIndices.begin(),targetIndices.end());
        rec(0,0,dp,source,pattern,t);

        return dp[0][0];
    }
};",1420079397
achintya7567,achintya7567,227,3604,cpp,"class Solution {
public:
    long long exp(long long a,long long b, long long mod){
        if(b==0)return 1;
        long long x=exp(a,b/2,mod);
        long long y=(x*x)%mod;
        if(b%2){
            return (a*y)%mod;
        }
        else return y;
    }
    int numberOfWays(int n, int x, int y) {
        long long s[1001][1001]; 
        long long mod=1e9+7;
        for(int i=0;i<1001;i++){ 
            for(int j=0;j<1001;j++){ 
                if(j>i) s[i][j]=0; 
                else if(i==j) s[i][j]=1; 
                else if(i==0 || j==0) s[i][j]=0; 
                else{     
                    s[i][j]= (j*s[i-1][j])%mod + s[i-1][j-1]; 
                } 
                s[i][j]%=mod;
                
            } 
        }
        long long z=y;
        long long sum=0;
        long long xf=1;
        vector<long long> fact(x+1);
        fact[0]=1;
        for(long long i=1;i<=x;i++){
            fact[i]=fact[i-1]*i;
            fact[i]%=mod;
        }
        for(long long i=1;i<=x;i++){
            long long xci=(((fact[x]*exp(fact[i],mod-2,mod))%mod)*exp(fact[x-i],mod-2,mod))%mod;
            sum+=(((((z*s[n][i])%mod)*xci)%mod)*fact[i])%mod;
            sum%=mod;
            z*=y;
            z%=mod;
        }
        return sum;
        

    }
};",1420098850
achintya7567,achintya7567,227,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for x in nums:
            if x%2==0:
                ans.append(-1)
            else:

                y=x//2
                if y|(y+1)==x:
                    ans.append(y)
                else:
                    cnt=0
                    z=x
                    while int(x)&int(1)>0:
                        cnt+=1
                        x/=2
                    ans.append(min(z-1,z-2**(cnt-1)))

        return ans
        ",1420008719
achintya7567,achintya7567,227,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for x in nums:
            if x%2==0:
                ans.append(-1)
            else:

                y=x//2
                if y|(y+1)==x:
                    ans.append(y)
                else:
                    cnt=0
                    z=x
                    while int(x)&int(1)>0:
                        cnt+=1
                        x/=2
                    ans.append(min(z-1,z-2**(cnt-1)))

        return ans
        ",1420010225
varous,sourav_suku,228,3487,cpp,"const int INF=(int)1e9;
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size(),m=pattern.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-INF));
        vector<int> dict(n);    for(auto &e:targetIndices)dict[e]=1;
        dp[n][m]=0;
        for(int i=n-1;i>=0;--i){
            dp[i][m]=0;
            for(int j=i;j<n;++j)dp[i][m]+=dict[j];
            for(int j=m-1;j>=0;--j){
                if(dict[i]){
                    dp[i][j]=max(1+dp[i+1][j],dp[i][j]);
                }
                if(source[i]==pattern[j]){
                    dp[i][j]=max(dp[i+1][j+1],dp[i][j]);
                }
                dp[i][j]=max(dp[i][j],dp[i+1][j]);
            }
        }
        return dp[0][0];
    }
};",1420045346
varous,sourav_suku,228,3604,cpp,"const long long int M=(int)1e9+7;
const int N=1005;
#define ll long long 
ll dp[N][N];
ll fact[N],inv[N];
ll power(ll a,ll b){
    ll res=1;
    ll pro=a;
    while(b){
        if(b&1){
            res*=pro;
            res%=M;
        }
        pro*=pro;       pro%=M;
        b>>=1;
    }
    return res;
}
void pre(){
    fact[0]=fact[1]=1;
    inv[0]=inv[1]=1;
    for(int i=2;i<N;++i){
        fact[i]=(fact[i-1]*i);      fact[i]%=M;
        inv[i]=power(fact[i],M-2);
    }
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i=1;i<N;++i){
        for(int j=1;j<N;++j){
            dp[i][j]=dp[i-1][j]*j;      dp[i][j]%=M;
            dp[i][j]+=dp[i-1][j-1];     dp[i][j]%=M;
        }
    }
}
ll choose(ll a,ll b){
    ll ret=fact[a];
    ret*=inv[b];        ret%=M;
    ret*=inv[a-b];      ret%=M;
    return ret;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        pre();
        ll res=0;
        for(int i=1;i<=x;++i){
            ll cur=choose(x,i);     cur*=power(y,i);    cur%=M;
            cur*=dp[n][i];      cur%=M;     cur*=fact[i];       cur%=M;
            res+=cur;       res%=M;
        }
        return res;
    }
};",1420105470
varous,sourav_suku,228,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> res(n,-1);
        for(int i=0;i<n;++i){
            for(int j=1;j<=nums[i];++j){
                if((j|(j+1))==nums[i]){
                    res[i]=j;
                    break;
                }
            }
        }
        return res;
    }
};",1420003179
varous,sourav_suku,228,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> res(n,-1);
        for(int i=0;i<n;++i){
            if(nums[i]==2)continue;
            else{
                int ind=0;
                for(int j=0;j<30;++j){
                    if((1<<j)&nums[i]){
                        ind=j;
                    }else{
                        break;
                    }
                }
                res[i]=(nums[i]^(1<<ind));
            }
        }
        return res;
    }
};",1420018850
shlok agrawal,111shlokagrawal,229,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<float> dp(m + 1, float('behencho'));
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != float('behencho')) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        int sub = 0;
        if(dp[m]!= float('behencho'))sub = dp[m];
        return targetIndices.size() - sub;

    }
};",1420090323
shlok agrawal,111shlokagrawal,229,3604,cpp,"#define ll long long
class Solution {
public:
    const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {

        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (long long)fact[i - 1] * i % MOD;
        }


        vector<ll> main;
        main.push_back(n);main.push_back(x);main.push_back(y);


        vector<vector<ll>> sp(n + 1, vector<ll>(x + 1, 0));
        sp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                sp[i][j] = (j * sp[i - 1][j] + sp[i - 1][j - 1]) % MOD;
            }
        }


        vector<vector<ll>> dp(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;
            }
        }

        ll result = 0;

        for (int k = 1; k <= x; ++k) {
            ll power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }

            result = (result + (long long)dp[x][k] * sp[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};",1420099087
shlok agrawal,111shlokagrawal,229,3605,cpp,"class Solution {
public:
    bool check(int nums){
        int sz = log2(nums)+1;
        for(int i=0;i<sz-1;i++){
            int bit = nums & (1<<i);
            if(bit==0)return false;
        }
        return true;
    }
    long long int highest(int nums){
        int sz = log2(nums);
        long long int ans = nums - 1LL*pow(2,sz);
        return ans;
    }
    int make(int nums){
        int ans = nums;
        for(int i=0;i<31;i++){
            int bit = nums & (1<<i);
            if(bit)continue;
            else{
                cout << i << endl;
                ans -= (1<<(i-1));
                break;
            }
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(make(nums[i]));
        }
        return ans;
    }
};",1420020267
shlok agrawal,111shlokagrawal,229,3611,cpp,"class Solution {
public:
    int make(int nums){
        int ans = nums;
        for(int i=0;i<31;i++){
            int bit = nums & (1<<i);
            if(bit)continue;
            else{
                //cout << i << endl;
                ans -= (1<<(i-1));
                break;
            }
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(make(nums[i]));
        }
        return ans;
    }
};",1420023199
Yoshi_mitsu,Yoshi_mitsu,230,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        int[] dp = new int[patternLength + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        TargetIndexChecker checker = new TargetIndexChecker(sourceLength);
        checker.markTargetIndices(targetIndices);

        for (int i = 0; i < sourceLength; i++) {
            for (int j = patternLength; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (checker.isTarget(i) ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[patternLength] == Integer.MAX_VALUE ? 0 : dp[patternLength]);
    }
}

class TargetIndexChecker {
    private boolean[] targetIndices;

    public TargetIndexChecker(int length) {
        targetIndices = new boolean[length];
    }

    public void markTargetIndices(int[] indices) {
        for (int index : indices) {
            targetIndices[index] = true;
        }
    }

    public boolean isTarget(int index) {
        return targetIndices[index];
    }
}



",1420072544
Yoshi_mitsu,Yoshi_mitsu,230,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    // Function to calculate combinations and factorials
    private int[][] comb;
    private int[] fact;

    public int numberOfWays(int n, int x, int y) {
        initComb(x);
        initFact(x);
        int[][] stir = initStirling(n, x);

        int res = 0;

        for (int k = 1; k <= x; k++) {
            int pow = modPow(y, k);
            res = (int) ((res + (1L * comb[x][k] * stir[n][k] % MOD * fact[k] % MOD * pow) % MOD) % MOD);
        }

        return res;
    }

    private void initComb(int x) {
        comb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
    }

    private void initFact(int x) {
        fact = new int[x + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = (int) ((1L * fact[i - 1] * i) % MOD);
        }
    }

    private int[][] initStirling(int n, int x) {
        int[][] stir = new int[n + 1][x + 1];
        stir[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stir[i][j] = (int) ((1L * j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD);
            }
        }
        return stir;
    }

    private int modPow(int b, int e) {
        int res = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                res = (int) ((1L * res * b) % MOD);
            }
            b = (int) ((1L * b * b) % MOD);
            e >>= 1;
        }
        return res;
    }

    // Example usage
    
}
",1420085375
Yoshi_mitsu,Yoshi_mitsu,230,3605,java,"import java.util.List;

class Solution {
    
    // Method to find the minimum x such that (x | (x + 1)) == prime
    private int findMinAns(int prime) {
        int x = 1; // Start with x = 1
        while (x <= prime) {
            if ((x | (x + 1)) == prime) {
                return x; // Return x if the condition is met
            }
            x++; // Increment x
        }
        return -1; // If no such x exists, return -1
    }

    // Method to process each number in the list
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n]; // Initialize the answer array
        
        // Fill the answer array using findMinAns
        for (int i = 0; i < n; i++) {
            ans[i] = findMinAns(nums.get(i));
        }
        
        return ans; // Return the answer array
    }
}
",1420010179
Yoshi_mitsu,Yoshi_mitsu,230,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # Helper functions as lambda functions
        is_bit_set = lambda num, bit: (num >> bit) & 1 == 1
        unset_bit = lambda num, bit: num & ~(1 << bit)
        is_valid_candidate = lambda candidate, original: (candidate | (candidate + 1)) == original
        
        return [
            self.find_minimal_ans(num, is_bit_set, unset_bit, is_valid_candidate) for num in nums
        ]

    def find_minimal_ans(self, num: int, is_bit_set, unset_bit, is_valid_candidate) -> int:
        minimal_ans = float('inf')
        found = False
        
        for bit in range(31):
            if is_bit_set(num, bit):
                candidate = unset_bit(num, bit)
                
                if candidate >= 0 and is_valid_candidate(candidate, num):
                    if candidate < minimal_ans:
                        minimal_ans = candidate
                        found = True
        
        return minimal_ans if found else -1
",1420069149
codebuster,codebuster420,231,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        std::vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        std::vector<std::vector<int>> memo(n, std::vector<int>(m, -1));
        
        auto minRemovals = [&](auto& self, int i, int j) -> int {
            if (j == m) return 0;
            if (i == n) return INT_MAX;
            
            if (memo[i][j] != -1) return memo[i][j];
            
            int result = self(self, i + 1, j);
            if (source[i] == pattern[j]) {
                int withChar = self(self, i + 1, j + 1);
                if (withChar != INT_MAX) {
                    result = std::min(result, withChar + (isTarget[i] ? 1 : 0));
                }
            }
            
            return memo[i][j] = result;
        };
        
        int removalCount = minRemovals(minRemovals, 0, 0);
        return targetIndices.size() - (removalCount == INT_MAX ? 0 : removalCount);
    }
};",1420074481
codebuster,codebuster420,231,3604,cpp,"class Solution {
public:
    static const int MODULO = 1e9 + 7;

    vector<vector<int>> computeCombinations(int maxGroups) {
        vector<std::vector<int>> combination(maxGroups + 1, std::vector<int>(maxGroups + 1, 0));
        for (int i = 0; i <= maxGroups; ++i) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MODULO;
            }
        }
        return combination;
    }

    vector<vector<int>> computeStirlingNumbers(int totalSteps, int maxGroups) {
        vector<std::vector<int>> stirlingNumbers(totalSteps + 1, std::vector<int>(maxGroups + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalSteps; ++i) {
            for (int j = 1; j <= maxGroups; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MODULO;
            }
        }
        return stirlingNumbers;
    }

    vector<int> computeFactorials(int maxGroups) {
        vector<int> factorial(maxGroups + 1, 1);
        for (int i = 1; i <= maxGroups; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MODULO;
        }
        return factorial;
    }

    long long computeTotalWays(int totalSteps, int maxGroups, int multiplier, 
                               const vector<std::vector<int>>& combination, 
                               const vector<std::vector<int>>& stirlingNumbers, 
                               const vector<int>& factorial) {
        long long totalCount = 0;
        for (int currentGroups = 1; currentGroups <= maxGroups; ++currentGroups) {
            long long multiplierPower = 1;
            for (int i = 0; i < currentGroups; ++i) {
                multiplierPower = (multiplierPower * multiplier) % MODULO;
            }
            totalCount = (totalCount + (1LL * combination[maxGroups][currentGroups] * stirlingNumbers[totalSteps][currentGroups] % MODULO * factorial[currentGroups] % MODULO * multiplierPower % MODULO)) % MODULO;
        }
        return totalCount;
    }
    int numberOfWays(int totalSteps, int maxGroups, int multiplier) {
        auto combination = computeCombinations(maxGroups);
        auto stirlingNumbers = computeStirlingNumbers(totalSteps, maxGroups);
        auto factorial = computeFactorials(maxGroups);
        return computeTotalWays(totalSteps, maxGroups, multiplier, combination, stirlingNumbers, factorial);
    }
};",1420105720
codebuster,codebuster420,231,3605,cpp,"class Solution {
public:
    int helper(int x){
        for(int i=1; i<=x; i++){
            if((i |(i+1))==x){
                return i;
            }
        }

        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n= nums.size();
        vector<int> ans(n,-1);

        int idx=0;
        for(int i: nums){
            if(i%2==0) {
                idx++;
                continue;
            }
            int a= helper(i);
            cout<<a<<"" "";
            ans[idx]= a;
            idx++;
            
        }

        return ans;
    }
};",1420011164
codebuster,codebuster420,231,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, -1);
        
        int idx=0;
        for (auto i: nums) {

            int mini = INT_MAX;
            bool flag = false;
            
            for (int x = 0; x <= 30; x++) {
                if ((i >> x) & 1) {
                    int c = i & ~(1 << x);
                
                    if (c < 0) continue; 
                    if ((c | (c + 1)) == i) {
                        if (c < mini) {
                            mini = c;
                            flag = true;
                        }
                    }
                }
            }
            
            if (flag) {
                res[idx] = mini;
            }
            idx++;
        }
        
        return res;
    }
};",1420049160
Anurag Singh Thakur,clarocroma,232,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.length(), m = p.length();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isT(n, false);
        for (int idx : t) isT[idx] = true;

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isT[i] ? 1 : 0));
                }
            }
        }
        return t.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }

private:
    void helperA(const vector<int>& t) {
        int b = 0;
        while (b < t.size()) {
            
            b |= (1 << t[b]);
        }
    }

    int helperB(string& s) {
        int c = 0;
        while (c < s.length()) {
            c++;
            
            s[c % s.length()] ^= 1; 
        }
        return c;
    }

    bool helperC(int x) {
        while (x > 0) {
            x &= (x - 1);  
        }
        return x == 0;  
    }
};
",1420079752
Anurag Singh Thakur,clarocroma,232,3604,cpp,"#include <vector>
#include <iostream>

using namespace std;

class Solution {
public:
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> comb = a(x);
        vector<vector<int>> stir = b(n, x);
        vector<int> fact = f(x);

        int res = 0;
        for (int k = 1; k <= x; ++k) {
            long long p = d(y, k);
            long long temp = (1LL * comb[x][k] * stir[n][k]) % MOD;
            temp = (temp * fact[k]) % MOD;
            temp = (temp * p) % MOD;
            res = (res + temp) % MOD;
        }

        return res;
    }

private:
    vector<vector<int>> a(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> b(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                long long firstPart = (1LL * j * s[i - 1][j]) % MOD;
                long long secondPart = s[i - 1][j - 1];
                s[i][j] = (firstPart + secondPart) % MOD;
            }
        }
        return s;
    }

    vector<int> f(int x) { // Renamed from c to f to avoid conflict
        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    long long d(int b, int e) {
        long long r = 1;
        long long base = b;
        while (e > 0) {
            if (e & 1) {
                r = (r * base) % MOD;
            }
            base = (base * base) % MOD;
            e >>= 1; // Divide e by 2
        }
        return r;
    }
};
",1420098241
Anurag Singh Thakur,clarocroma,232,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        int tmp=n.size();
        vector<int> a(tmp, -1);   
        
        for (int i = 0; i <tmp; i++) {
            int x = n[i];
            int c = 0;
            
            while (c <= x) {
                if ((c | (c + 1)) == x) {
                    a[i] = c;
                    break;
                }
                c++;
            }
        }
        
        return a;


        
    }
};",1419999857
Anurag Singh Thakur,clarocroma,232,3611,cpp,"#include <vector>
#include <set>
#include <algorithm>
using namespace std;

class Solution {
private:
    bool b(int n, int p) {
        return (n & (1 << p)) != 0;
    }

    int c(int n, int p) {
        return n & ~(1 << p);
    }

    int m(const set<int>& s) {
        return s.empty() ? -1 : *s.begin();
    }

public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        
        for (int x : n) {
            set<int> s;
            int i = 0;

            while (i < 32) {
                if (b(x, i)) {
                    int y = c(x, i);
                    if ((y | (y + 1)) == x) {
                        s.insert(y);
                    }
                }
                i++;
            }

            a.push_back(m(s));
        }

        return a;
    }
};

",1420105779
Vijay Katari,vijaykatari23,233,3487,cpp,"class Solution {
public:
    int maxRemovals(string S, string P, vector<int>& t) {
        int N = S.length();
        int M = P.length();
        vector<int> can(N + 1);
        for (auto x : t)
            can[x + 1] = 1;
        vector<vector<int>> dp(N + 1, vector<int>(M + 1, -1));
        dp[0][0] = 0;
        for (int i = 1; i <= N; ++i) {
            if (dp[i - 1][0] != -1)
                dp[i][0] = max(dp[i][0], dp[i - 1][0] + can[i]);
            for (int j = 1; j <= M; ++j) {
                if (S[i - 1] == P[j - 1]) {
                    if (dp[i - 1][j - 1] != -1)
                        dp[i][j] = dp[i - 1][j - 1];
                }
                if (dp[i - 1][j] != -1)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + can[i]);
            }
        }
        int ans = 0;
        for (int i = 1; i <= N; ++i) ans = max(ans, dp[i][M]);
        return ans;
    }
};",1420028052
Vijay Katari,vijaykatari23,233,3604,cpp,"#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using ld = long double;
using ull = unsigned long long;

#define FOR(i, n)           for(ll (i) = 0; (i) < (n); ++(i))
#define REV(i, n)           for(ll (i) = (n) - 1; ~(i); --(i))
#define READ(x)             cin >> x;
#define O(x)                cout << x << '\n';
#define PLL                 pair<ll, ll>
#define VL                  vector<ll>
#define all(x)              (x).begin(), (x).end()
#define allr(x)             (x).rbegin(), (x).rend()
#define YES                 cout << ""YES\n"";
#define NO                  cout << ""NO\n"";
#define STOP                cout << ""-1\n"";

constexpr ll INF0  = 2e18 + 10;
constexpr ld EPS   = 1e-9 + 00;

template<const int &MOD>
struct ModularInt {
    int val;
 
    ModularInt(ll v = 0) {
        if (v < 0) v = v % MOD + MOD;
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    ModularInt(ull v) {
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    ModularInt(int v) : ModularInt(ll(v)) {}
    ModularInt(unsigned v) : ModularInt(ull(v)) {}
 
    explicit operator int() const { return val; }
    explicit operator unsigned() const { return val; }
    explicit operator ll() const { return val; }
    explicit operator ull() const { return val; }
    explicit operator double() const { return val; }
    explicit operator long double() const { return val; }
 
    ModularInt& operator+=(const ModularInt &other) {
        val -= MOD - other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    ModularInt& operator-=(const ModularInt &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    ModularInt& operator*=(const ModularInt &other) {
        val = unsigned(ull(ull(val) * other.val) % ull(MOD));
        return *this;
    }
 
    ModularInt& operator/=(const ModularInt &other) {
        return *this *= other.inv();
    }
 
    friend ModularInt operator+(const ModularInt &a, const ModularInt &b) { return ModularInt(a) += b; }
    friend ModularInt operator-(const ModularInt &a, const ModularInt &b) { return ModularInt(a) -= b; }
    friend ModularInt operator*(const ModularInt &a, const ModularInt &b) { return ModularInt(a) *= b; }
    friend ModularInt operator/(const ModularInt &a, const ModularInt &b) { return ModularInt(a) /= b; }
 
    ModularInt& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
 
    ModularInt& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
 
    ModularInt operator++(int) { ModularInt before = *this; ++*this; return before; }
    ModularInt operator--(int) { ModularInt before = *this; --*this; return before; }
 
    ModularInt operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
 
    friend bool operator==(const ModularInt &a, const ModularInt &b) { return a.val == b.val; }
    friend bool operator!=(const ModularInt &a, const ModularInt &b) { return a.val != b.val; }
    friend bool operator<(const ModularInt &a, const ModularInt &b) { return a.val < b.val; }
    friend bool operator>(const ModularInt &a, const ModularInt &b) { return a.val > b.val; }
    friend bool operator<=(const ModularInt &a, const ModularInt &b) { return a.val <= b.val; }
    friend bool operator>=(const ModularInt &a, const ModularInt &b) { return a.val >= b.val; }
 
    static const int SAVE_INV = int(1e6) + 5;
    static ModularInt save_inv[SAVE_INV];
 
    static void prepare_inv() {
        for (ll p = 2; p * p <= MOD; p += p % 2 + 1)
            assert(MOD % p != 0);
 
        save_inv[0] = 0;
        save_inv[1] = 1;
 
        for (int i = 2; i < SAVE_INV; i++)
            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);
    }
 
    ModularInt inv() const {
        if (save_inv[1] == 0)
            prepare_inv();
 
        if (val < SAVE_INV)
            return save_inv[val];
 
        ModularInt product = 1;
        int v = val;
 
        do {
            product *= MOD - MOD / v;
            v = MOD % v;
        } while (v >= SAVE_INV);
 
        return product * save_inv[v];
    }
 
    ModularInt pow(ll p) const {
        if (p < 0)
            return inv().pow(-p);
 
        ModularInt a = *this, result = 1;
 
        while (p > 0) {
            if (p & 1)
                result *= a;
 
            p >>= 1;
 
            if (p > 0)
                a *= a;
        }
 
        return result;
    }
 
    friend ostream& operator<<(ostream &os, const ModularInt &m) {
        return os << m.val;
    }
};
 
template<const int &MOD> ModularInt<MOD> ModularInt<MOD>::save_inv[ModularInt<MOD>::SAVE_INV];
 
const int MOD = int(1e9) + 7;
using Mint = ModularInt<MOD>;
 
 
template<const int &MOD>
struct Combinatorics {
    using CombinatoricsInt = ModularInt<MOD>;
 
    vector<CombinatoricsInt> Factorial = {1}, InvFactorial = {1};
 
    void prepareFactorials(ll maximum) {
        static ll prepared_maximum = 0;
 
        if (maximum <= prepared_maximum)
            return;
 
        // Prevent increasing prepared_maximum by only 1 each time.
        maximum = max(maximum, ll(1.01L * prepared_maximum));
        Factorial.resize(maximum + 1);
        InvFactorial.resize(maximum + 1);
 
        for (ll i = prepared_maximum + 1; i <= maximum; i++)
            Factorial[i] = i * Factorial[i - 1];
 
        InvFactorial[maximum] = Factorial[maximum].inv();
 
        for (ll i = maximum - 1; i > prepared_maximum; i--)
            InvFactorial[i] = (i + 1) * InvFactorial[i + 1];
 
        prepared_maximum = maximum;
    }
 
    CombinatoricsInt factorial(ll n) {
        if (n < 0) return 0;
        prepareFactorials(n);
        return Factorial[n];
    }
 
    CombinatoricsInt invFactorial(ll n) {
        if (n < 0) return 0;
        prepareFactorials(n);
        return InvFactorial[n];
    }
 
    CombinatoricsInt choose(ll n, ll r) {
        if (r < 0 || r > n) return 0;
        prepareFactorials(n);
        return Factorial[n] * InvFactorial[r] * InvFactorial[n - r];
    }
 
    CombinatoricsInt permute(ll n, ll r) {
        if (r < 0 || r > n) return 0;
        prepareFactorials(n);
        return Factorial[n] * InvFactorial[n - r];
    }
 
    CombinatoricsInt inv_choose(ll n, ll r) {
        assert(0 <= r && r <= n);
        prepareFactorials(n);
        return InvFactorial[n] * Factorial[r] * Factorial[n - r];
    }
 
    CombinatoricsInt inv_permute(ll n, ll r) {
        assert(0 <= r && r <= n);
        prepareFactorials(n);
        return InvFactorial[n] * Factorial[n - r];
    }
};
 
Combinatorics<MOD> Cint;

class Solution {
public:
    int numberOfWays(int N, int X, int Y) {
        vector<vector<Mint>> dp(N + 1, vector<Mint>(X + 1));
        dp[0][0] = 1;
        
        for (int i = 1; i <= N; ++i)
            for (int j = 1; j <= X; ++j) 
                dp[i][j] = Mint(j) * dp[i - 1][j] + dp[i - 1][j - 1];
        
        Mint ans = 0;
        for (int i = 1; i <= min(X, N); ++i) 
            ans += dp[N][i] * Cint.factorial(i) * Mint(Y).pow(i) * Cint.choose(X, i);
        
        return ans.val;
    }
};",1420105826
Vijay Katari,vijaykatari23,233,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& A) {
        int N = A.size();
        vector<int> ans(N, -1);
        for (int i = 0; i < N; ++i) {
            bool done = false;
            for (int bit = 32; bit > 0; --bit) if ((((1LL << bit) - 1LL) & A[i]) == ((1LL << bit) - 1LL)) {
                ans[i] = A[i] ^ (1LL << (bit - 1));
                done = true;
                break;
            }
            if (!done) {
                if (A[i] ^ 2)
                    ans[i] = A[i] ^ 1;
            }
        }
        return ans;
    }
};",1420007707
Vijay Katari,vijaykatari23,233,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& A) {
        int N = A.size();
        vector<int> ans(N, -1);
        for (int i = 0; i < N; ++i) {
            bool done = false;
            for (int bit = 32; bit > 0; --bit) if ((((1LL << bit) - 1LL) & A[i]) == ((1LL << bit) - 1LL)) {
                ans[i] = A[i] ^ (1LL << (bit - 1));
                done = true;
                break;
            }
            if (!done) {
                if (A[i] ^ 2)
                    ans[i] = A[i] ^ 1;
            }
        }
        return ans;
    }
};",1420007398
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3487,cpp,"#define ll long long int
ll dp[3001][3001];
class Solution {
public:
    ll find(string &str,string &pattern,ll x,ll y,map<ll,ll> &store,ll count[]){
        if(y==pattern.length()){
            return count[x];   
        }
        if(x==str.length()){
            return -1e6;
        }
        if(dp[x][y]!=-1e9){
            return dp[x][y];
        }
        if(str[x]==pattern[y]){
            ll one=find(str,pattern,x+1,y+1,store,count);
            ll see=0;
            if(store.count(x)){
                see=1;
            }
            ll two=see+find(str,pattern,x+1,y,store,count);
            return dp[x][y]=max(one,two);
        }else{
            ll see=0;
            if(store.count(x)){
                see=1;
            }
            return dp[x][y]=see+find(str,pattern,x+1,y,store,count);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& indices) {
        ll n=source.length();
        ll m=pattern.length();
        map<ll,ll> store;
        for(ll i=0;i<indices.size();i++){
            store[indices[i]]++;
        }
        ll count[n+1];
        for(ll i=0;i<=n;i++){
            count[i]=0;
        }
        ll cur=0;
        for(ll j=n;j>=0;j--){
            if(store.count(j)){
                cur++;
            }
            count[j]=cur;
        }
        for(ll i=0;i<=3000;i++){
            for(ll j=0;j<=3000;j++){
                dp[i][j]=-1e9;
            }
        }
        ll ans=find(source,pattern,0,0,store,count);
        return ans;
    }
};",1420050218
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3604,cpp,"#define ll long long int
class Solution {
public:
    ll ncr(ll n, ll r, ll mod) {
        if (r > n) return 0;
        ll num = 1, den = 1;
        for (ll i = 0; i < r; i++) {
            num = (num * (n - i)) % mod;
            den = (den * (i + 1)) % mod;
        }
        return (num * modInverse(den, mod)) % mod;
    }

    ll factorial(ll n) {
        ll mod=1e9+7;
        ll result = 1;
        for (ll i = 2; i <= n; i++) {
            result = (result * i) % mod;
        }
        return result;
    }


    ll pow(ll base, ll exp, ll mod) {
        ll result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }


    ll modInverse(ll a, ll mod) {
        return pow(a, mod - 2, mod);
    }
   

    int numberOfWays(int n, int x, int y) {
        ll mod=1e9+7;
        ll ans=0;
        vector<vector<ll>> dp(n + 1, vector<ll>(x + 1, 0));
        dp[0][0] = 1;

        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; j++) {
                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]) % mod;
            }
        }
        for(ll i=1;i<=x;i++){
            ll select1=ncr(x,i,mod);
            if(n>=i){
                ll select2=(dp[n][i]*factorial(i))%mod;
                ll left=(n-i);
                ll select4=pow(y,i,mod);
                select1=(select1*select2)%mod;
                select1=(select1*select4)%mod;
                ans=(ans+select1)%mod;
            }else{
                break;
            }
        }      
        return ans;
    }
};",1420106169
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3605,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            int cur=-1;
            for(int j=0;j<=1000;j++){
                int see=j|(j+1);
                if(see==nums[i]){
                    cur=j;
                    break;
                }
            }
            ans.push_back(cur);
        }
        return ans;
    }
};",1420030003
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3611,cpp,"#define ll long long int
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n=nums.size();
        vector<int> ans;
        for(ll i=0;i<n;i++){
            ll num=nums[i];
            if(num==2){
                ans.push_back(-1);
                continue;
            }
            string str="""";
            for(ll j=29;j>=0;j--){
                ll mask=1<<j;
                if(mask&num){
                    str.push_back('1');
                }else{
                    str.push_back('0');
                }
            }
            ll ind=-1;
            for(ll j=0;j<str.length();j++){
                if(str[j]=='1'){
                    ind=j;
                    break;
                }
            }
          
            ll ind2=-1;
            for(ll j=str.length()-1;j>ind;j--){
                if(str[j]=='0'){
                    ind2=j;
                    break;
                }
            }
         
            if(ind2==-1){
                int xy=1<<(30-ind-1);
                int xy2=xy-1;
                ans.push_back(xy2);
            }else{
                int xy=0;
                for(int j=0;j<str.length();j++){
                    if(j!=ind2){
                        if(str[j]=='1'){
                            xy=xy+pow(2,30-j-1);
                        }
                    }else{
                        for(int k=ind2+2;k<str.length();k++){
                            if(str[k]=='1'){
                                xy=xy+pow(2,30-k-1);
                            }
                        }
                        break;
                    }
                }
                ans.push_back(xy);
            }
            
        }
        return ans;
    }
};",1420029640
kritikmodi,kritikmodi,236,3487,cpp,"class Solution {
public:
    unordered_set<int> hs;
    string s1, s2;
    vector<vector<long long>> dp;
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        hs.clear();
        s1 = source;
        s2 = pattern;
        for (int idx : targetIndices) {
            hs.insert(idx);
        }
        dp.resize(source.length() + 1, vector<long long>(pattern.length() + 1, LLONG_MIN));
        return (int)getAns(0, 0);
    }

private:
    long long getAns(int curr1, int curr2) {
        if (curr1 == s1.length()) {
            if (curr2 == s2.length()) {
                return 0;
            } else {
                return INT_MIN;
            }
        }
        if (dp[curr1][curr2] != LLONG_MIN) {
            return dp[curr1][curr2];
        }
        if (curr2 == s2.length()) {
            long long currans = getAns(curr1 + 1, curr2);
            if (hs.find(curr1) != hs.end()) {
                currans++;
            }
            return dp[curr1][curr2] = currans;
        } else {
            if (s1[curr1] == s2[curr2]) {
                long long case1 = getAns(curr1 + 1, curr2 + 1);
                long long case2 = INT_MIN;
                if (hs.find(curr1) != hs.end()) {
                    case2 = 1 + getAns(curr1 + 1, curr2);
                }
                return dp[curr1][curr2] = max(case1, case2);
            } else {
                long long case1 = getAns(curr1 + 1, curr2);
                long long case2 = INT_MIN;
                if (hs.find(curr1) != hs.end()) {
                    case2 = 1 + getAns(curr1 + 1, curr2);
                }
                return dp[curr1][curr2] = max(case1, case2);
            }
        }
    }
};
",1420058070
kritikmodi,kritikmodi,236,3604,java,"class Solution {
    static int MOD=(int)1e9+7;
    static int N = 10001;  
 
    static long[] factorialNumInverse = new long[N + 1]; 

    static long[] naturalNumInverse = new long[N + 1];

    static long[] fact = new long[N + 1]; 
 
    public static void InverseofNumber(int p) 
    { 
        naturalNumInverse[0] = naturalNumInverse[1] = 1; 

        for(int i = 2; i <= N; i++) 
            naturalNumInverse[i] = naturalNumInverse[p % i] *
                                     (long)(p - p / i) % p; 
    } 

    public static void InverseofFactorial(int p) 
    { 
        factorialNumInverse[0] = factorialNumInverse[1] = 1; 
        for(int i = 2; i <= N; i++) 
            factorialNumInverse[i] = (naturalNumInverse[i] * 
                               factorialNumInverse[i - 1]) % p; 
    } 

    public static void factorial(int p) 
    { 
        fact[0] = 1; 
        for(int i = 1; i <= N; i++)
        { 
            fact[i] = (fact[i - 1] * (long)i) % p; 
        } 
    } 

    public static long Binomial(int N, int R, int p) 
    { 
        long ans = ((fact[N] * factorialNumInverse[R]) % 
                           p * factorialNumInverse[N - R]) % p; 
        return ans; 
    }
    
    public int numberOfWays(int n, int x, int y) {
        InverseofNumber(MOD); 
        InverseofFactorial(MOD); 
        factorial(MOD); 
        long ans=0;
        long[][] S = new long[n + 1][Math.min(n, x) + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, Math.min(n, x)); j++) {
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
            }
        }
        long facts[]=new long[1005];
        facts[0]=1;
        for(int j=1;j<=1004;j++)
            facts[j]=(facts[j-1]*j)%MOD;
        for (int s = 1; s <= Math.min(n, x); s++) {
            long stirling = S[n][s];
            long combinations = Binomial(x,s,MOD);
            long permutations = facts[s];
            long extra=1;
            for(int j=0;j<s;j++)
                extra=(extra*y)%MOD;
            long currans = (((stirling * combinations) % MOD * permutations) % MOD * extra) % MOD;
            ans = (ans + currans) % MOD;
        }
        return (int)ans;
    }

}",1420106204
kritikmodi,kritikmodi,236,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int ans[]=new int[nums.size()];
        for(int j=0;j<nums.size();j++)
        {
            int curr=nums.get(j);
            if(curr==2)
            {
                ans[j]=-1;
                continue;
            }
            int minus=1;
            int check=-1;
            inner :
            while(curr!=0)
            {
                if(curr%2==0)
                {
                    check=minus/2;
                    break inner;
                }
                minus*=2;
                curr/=2;
            }
            if(check==-1)
                check=minus/2;
            ans[j]=nums.get(j)-check;
        }
        return ans;
    }
}",1420014883
kritikmodi,kritikmodi,236,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int ans[]=new int[nums.size()];
        for(int j=0;j<nums.size();j++)
        {
            int curr=nums.get(j);
            if(curr==2)
            {
                ans[j]=-1;
                continue;
            }
            int minus=1;
            int check=-1;
            inner :
            while(curr!=0)
            {
                if(curr%2==0)
                {
                    check=minus/2;
                    break inner;
                }
                minus*=2;
                curr/=2;
            }
            if(check==-1)
                check=minus/2;
            ans[j]=nums.get(j)-check;
        }
        return ans;
    }
}",1420014580
Larry,LarryNY,238,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        INF = 10 ** 9
        S = len(source)
        P = len(pattern)
        f = set(targetIndices)
        
        pdp = [-INF] * (P + 1)
        dp = [-INF] * (P + 1)
        pdp[P] = 0
        dp[P] = 0
        
        for sindex in range(S - 1, -1, -1):
            dp[P] = pdp[P]
            if sindex in f:
                dp[P] += 1
            
            for pindex in range(P - 1, -1, -1):
                dp[pindex] = pdp[pindex]
                
                if source[sindex] == pattern[pindex]:
                    if pdp[pindex + 1] > dp[pindex]:
                        dp[pindex] = pdp[pindex + 1]
                        
                if sindex in f:
                    if pdp[pindex] + 1 > dp[pindex]:
                        dp[pindex] = pdp[pindex] + 1

            pdp = dp[:]
        return dp[0]
",1420037203
Larry,LarryNY,238,3604,python3,"MX = 1005
MOD = 10 ** 9 + 7

@cache
def choose(x, i):
    if i == 0:
        return 1
    if x == i:
        return 1
    if x == 0:
        return 0
    return (choose(x - 1, i - 1) + choose(x - 1, i)) % MOD

@cache
def go(n, i):
    if n == 0 and i == 0:
        return 1
    if n == 0 or i == 0:
        return 0

    return (go(n - 1, i - 1) + i * go(n - 1, i)) % MOD

@cache
def fact(i):
    if i == 0:
        return 1
    return (fact(i - 1) * i) % MOD
        
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0
        for i in range(1, x + 1):
            # x choose i number of groups
            groups = choose(x, i) * fact(i)
            scoring = pow(y, i, MOD)
            g = go(n, i)
            
            ans += (groups * scoring * g) % MOD
            ans %= MOD
        return ans % MOD",1420099805
Larry,LarryNY,238,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        lookup = {}
        mx = max(nums)
        
        for i in range(mx + 5):
            x = i | (i + 1)
            if x not in lookup:
                lookup[x] = i

        ans = []
        for x in nums:
            if x not in lookup:
                ans.append(-1)
            else:
                ans.append(lookup[x])
        return ans",1419994334
Larry,LarryNY,238,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def go(x):
            if x == 2:
                return -1
            
            best = x
            for i in range(32):
                if ((x - (1 << i)) | ((x - (1 << i)) + 1)) == x:
                    best = min(best, x - (1 << i))
            return best
        
        ans = []
        for x in nums:
            ans.append(go(x))
        return ans",1420006070
Meet Patel,_Meet_Patel_,239,3487,cpp,"class Solution {
private: 
    int calc(int i, int j, string &s, string &p, vector<int> &suf, unordered_set<int> &idx, vector<vector<int>> &dp) {
        int n = s.size(), m = p.size(); 

        if (i == n) return j == m ? 0 : INT_MIN; 
        if (j == m) {
            int ret = calc(i + 1, j, s, p, suf, idx, dp); 
            if (idx.count(i)) ret++; 
            return ret; 
        }
        if (dp[i][j] != -1) return dp[i][j]; 

        int ret = 0; 
        if (idx.count(i)) {
            if (suf[i + 1] >= m - j) {
                ret = 1 + calc(i + 1, j, s, p, suf, idx, dp); 
            }
        }

        // ret = max(ret, calc(i + 1, j, s, p, suf, idx, dp)); 
        if (s[i] == p[j]) {
            ret = max(ret, calc(i + 1, j + 1, s, p, suf, idx, dp)); 
        } else {
            ret = max(ret, calc(i + 1, j, s, p, suf, idx, dp)); 
        }

        // cout << i << ' ' << j << ' ' << ret << endl; 

        return dp[i][j] = ret; 
    }

public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(); 
        int m = pattern.size(); 

        vector<int> suf(n + 1); 
        for (int i = n - 1, j = m - 1 ; i >= 0 ; i--) {
            if (j >= 0 && source[i] == pattern[j]) {
                j--; 
            }
            suf[i] = (m - j - 1); 
        }

        for (int i : suf) cout << i << ' '; cout << endl; 

        unordered_set<int> idx(targetIndices.begin(), targetIndices.end()); 
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1)); 
        return calc(0, 0, source, pattern, suf, idx, dp); 

        // int rem = m, j = 0, res = 0; 
        // for (int i = 0 ; i < n ; i++) {
        //     bool removed = false; 
        //     if (idx.count(i)) {
        //         if (j == m || suf[i + 1] >= m - j) {
        //             cout << i << endl; 
        //             res++; 
        //             removed = true; 
        //         }
        //     }
        //     if (!removed && j < m) {
        //         if (source[i] == pattern[j]) {
        //             j++; 
        //         }
        //     }
        // }
        // return res; 
    }
};",1420085519
Meet Patel,_Meet_Patel_,239,3604,cpp,"class Solution {
private: 
    const int MOD = 1e9 + 7; 

    int64_t pw(int64_t b, int64_t p){
        b %= MOD;
        int res = 1;
        
        while(p > 0){
            if(p & 1)
                res = res * b % MOD;
            b = b * b % MOD;
            p >>= 1;
        }
        return res;
    }
public:
    int numberOfWays(int n, int maxParts, int multiplier) {
        vector<vector<int>> binomial(maxParts + 1, vector<int>(maxParts + 1, 0));
        for (int i = 0; i <= maxParts; ++i) {
            binomial[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stirlingNumbers(n + 1, vector<int>(maxParts + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= maxParts; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> factorial(maxParts + 1, 1);
        for (int i = 1; i <= maxParts; ++i) {
            factorial[i] = 1LL * factorial[i - 1] * i % MOD;
        }

        long long result = 0;
        for (int k = 1; k <= maxParts; ++k) {
            long long powerMultiplier = pw(multiplier, k);
            result = (result + 1LL * binomial[maxParts][k] * stirlingNumbers[n][k] % MOD * factorial[k] % MOD * powerMultiplier % MOD) % MOD;
        }

        return result;
    }
};",1420099834
Meet Patel,_Meet_Patel_,239,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size(); 
        vector<int> ans(n, -1); 
        for (int i = 0 ; i < n ; i++) {
            for (int j = 1 ; j <= nums[i] ; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j; 
                    break; 
                }
            }
        }
        return ans; 
    }
};",1419997909
Meet Patel,_Meet_Patel_,239,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size(); 
        vector<int> ans(n, -1); 
        for (int i = 0 ; i < n ; i++) {
            if (nums[i] == 2) {
                continue; 
            }
            int j = 0; 
            while (nums[i] >> j & 1) {
                j++; 
            } 
            int cur = 1 << (j - 1); 
            while (j <= 30) {
                if (nums[i] >> j & 1) {
                    cur |= (1 << j); 
                }
                j++; 
            }
            ans[i] = cur - 1; 
        }
        return ans; 
    }
};",1420031704
Aviral Katiyar,maskboy,240,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int m = pattern.size();
        int n = source.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> isTarget(n, false);

        int sz = targetIndices.size();
        for(int i=0;i<sz;i++){
            int idx = targetIndices[i];
            isTarget[idx] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j-1] && dp[j-1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j-1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420077434
Aviral Katiyar,maskboy,240,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define vl vector<ll>
#define vvl vector<vector<ll>>
#define pb push_back

ll MOD = 1e9+7;

class Solution {
public:
    string strBinary(int n, int l){string s;for(int i=l-1;i>=0;i--){s.push_back((n&(1<<i))?'1':'0');}return s;}
bool isPalindrome(string str){string rev = str;reverse(str.begin(),str.end());return str==rev;}
bool isPrime(ll n){if(n<=1)return false;for(ll i=2;i*i<=n;i++)if(n%i==0)return false;return true;}
vector<bool> seive(ll n = 1e6+7){vector<bool> prime(n+1,true);prime[1] = false;for(ll i=2;i*i<=n;i++){if(prime[i]){for (ll j = i*i; j <= n; j+=i){prime[j] = false;}}}return prime;}
void check(){string name = ""aviral Katiyar"";int rank = 7;string bin = strBinary(rank,5);bool isp = isPrime(rank);bool ispal = isPalindrome(name);}
void fastIO(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    check();
}
    void combinat(vector<vector<ll>>& comb, int limit) {
        for (int i = 0; i <= limit; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;
            }
        }
    }

    void computeStir(vector<vector<ll>>& stirling, int n, int x) {
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i-1][j] + stirling[i-1][j-1]) % MOD;
            }
        }
    }

    void facto(vector<ll>& fact, int limit) {
        fact[0] = 1;
        for (int i = 1; i <= limit; ++i) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
    }

    ll numberOfWays(int n, int x, int y) {
        fastIO();
        vector<vector<ll>> comb(x + 1, vector<ll>(x + 1, 0));
        combinat(comb, x);
        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        computeStir(stirling, n, x);
        vector<ll> fact(x + 1, 1);
        facto(fact, x);

        ll result = 0;
        for (int k = 1; k <= x; ++k) {
            ll power_y = 1;
            for (int p = 0; p < k; ++p) {
                power_y = (power_y * y) % MOD;
            }

            result = (result + comb[x][k] * stirling[n][k] % MOD * fact[k] % MOD * power_y % MOD) % MOD;
        }

        return result;
    }
};
",1420099952
Aviral Katiyar,maskboy,240,3605,cpp,"class Solution {
public:
    string toBinary(int n){
        string ans = """";
        while(n>0){
            int rem = n%2;
            if(rem) ans ='1' + ans;
            else ans = '0' + ans;
            n /= 2;
        }
        return ans;
    }
    int binToint(string bin){
        int n = bin.size();
        int con=0;
        int ans = 0;
        for(int i=n-1;i>=0;i--){
            if(bin[i]=='1'){
                ans += pow(2,con);
            }
            con++;
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]%2==0) continue;
            string bin = toBinary(nums[i]);
            bin = '0' + bin;
            int sz = bin.size();
            for(int j=sz-2;j>=0;j--){
                if(bin[j]=='0'){
                    bin[j+1] = '0';
                    break;
                }
            }
            int num = binToint(bin);
            ans[i] = num;
        }
        return ans;
    }
};",1420029857
Aviral Katiyar,maskboy,240,3611,cpp,"class Solution {
public:
    string toBinary(int n){
        string ans = """";
        while(n>0){
            int rem = n%2;
            if(rem) ans ='1' + ans;
            else ans = '0' + ans;
            n /= 2;
        }
        return ans;
    }
    int binToint(string bin){
        int n = bin.size();
        int con=0;
        int ans = 0;
        for(int i=n-1;i>=0;i--){
            if(bin[i]=='1'){
                ans += pow(2,con);
            }
            con++;
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]%2==0) continue;
            string bin = toBinary(nums[i]);
            bin = '0' + bin;
            int sz = bin.size();
            for(int j=sz-2;j>=0;j--){
                if(bin[j]=='0'){
                    bin[j+1] = '0';
                    break;
                }
            }
            int num = binToint(bin);
            ans[i] = num;
        }
        return ans;
    }
};",1420035067
Shashwat Tripathi,Fkaiser7,241,3487,cpp,"#define lli long long
class Solution {
public:
    lli fuc(lli i,lli j,vector<vector<lli>>&dp,vector<lli>&check,
    string &s1,string &s2){
        lli n=s1.length();
        lli m=s2.length();
        if(i==n){
            if(j==m){
                return 0;
            }
            return -1e18;
        }
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        lli ans=fuc(i+1,j,dp,check,s1,s2);
        if(j==m&&check[i]){
            ans=max(ans,1+fuc(i+1,j,dp,check,s1,s2));
        }
        if(j<m){
            if(s1[i]==s2[j]){
                ans=max(ans,fuc(i+1,j+1,dp,check,s1,s2));
            }
            if(check[i]){
                ans=max(ans,1+fuc(i+1,j,dp,check,s1,s2));
            }
        }
        return dp[i][j]=ans;
    }
    int maxRemovals(string s1, string s2, vector<int>& v) {
        lli n=s1.length();
        lli m=s2.length();
        vector<lli>check(n);
        for(lli i=0;i<v.size();i++){
            check[v[i]]++;
        }
        vector<vector<lli>>dp(n,vector<lli>(m+1,-1));
        return (int)(fuc(0,0,dp,check,s1,s2));
    }
};",1420106557
Shashwat Tripathi,Fkaiser7,241,3604,cpp,"#define lli long long
lli mod=1e9+7;
lli MOD=1e9+7;
vector<lli>fact(1001);
class Solution {
public:
    long long power(long long i, lli j) { return j ? j & 1 ? power(i * i % mod, j >> 1) * i % mod : power(i * i % mod, j >> 1) : 1; }
    void perm(){
        lli t=1;
        fact[0]=1;
        for(lli i=1;i<=1000;i++){
            t=(t%mod*i%mod)%mod;
            fact[i]=t;
        }
    }
    lli comb(lli n,lli r){
        lli t=fact[n];
        lli p=(fact[r]%mod*fact[n-r]%mod)%mod;
        p=power(p,mod-2);
        t=(t%mod*p%mod)%mod;
        return t;
    }
    lli count(lli n,lli r){
        lli ans=0;
        lli k=0;
        for(lli i=0;i<=r-1;i++){
            lli t=power(r-i,n);
            t=(t%mod*comb(r,i)%mod)%mod;
            if(k==0){
                ans+=t;
            }
            else{
                ans-=t;
                ans+=mod;
            }
            k=1-k;
            ans=ans%mod;
        }
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        perm();
        lli ans=0;
        n=(lli)(n);
        x=(lli)(x);
        y=(lli)(y);
        //cout<<comb(4,2)<<endl;
        for(int i=1;i<=min(n,x);i++){
            lli t=count(n,i);
            //cout<<t<<endl;
            t=(t%mod*comb(x,i)%mod)%mod;
            t=(t%mod*power(y,i)%mod)%mod;
            ans+=t;
            ans=ans%mod;
        }
        return (int)(ans);
    }
};",1420084926
Shashwat Tripathi,Fkaiser7,241,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                int t=nums[i]-1;
                vector<int>v;
                for(int j=0;j<=30;j++){
                    int k=1<<j;
                    if(nums[i]&k){
                        v.push_back(k);
                    }
                }
                int ind=-1;
                for(int i=0;i<v.size()-1;i++){
                    if(v[i+1]==2*v[i]){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                if(ind!=-1){
                    int t1=0;
                    for(int j=0;j<v.size();j++){
                        if(j!=ind+1){
                            t1+=v[j];
                        }
                    }
                    t=min(t,t1);
                }
                ans.push_back(t);
            }
        }
        return ans;
    }
};",1420021406
Shashwat Tripathi,Fkaiser7,241,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                int t=nums[i]-1;
                vector<int>v;
                for(int j=0;j<=30;j++){
                    int k=1<<j;
                    if(nums[i]&k){
                        v.push_back(k);
                    }
                }
                int ind=-1;
                for(int i=0;i<v.size()-1;i++){
                    if(v[i+1]==2*v[i]){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                if(ind!=-1){
                    int t1=0;
                    for(int j=0;j<v.size();j++){
                        if(j!=ind+1){
                            t1+=v[j];
                        }
                    }
                    t=min(t,t1);
                }
                ans.push_back(t);
            }
        }
        return ans;
    }
};",1420020686
Nelson,Nelson84,243,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> can_remove(targetIndices.begin(), targetIndices.end());

        /*
            s: xxxx i
            p: oooooo j

            0bcda
            0d

            dp[i][j] = dp[i-1][j]
            if(dp[i][j] && can_remove.find(i)!=can_remove.end()) max_oper[i][j] = max_oper[i-1][j] + 1;

            if s[i]==p[j]
                dp[i][j] |= dp[i-1][j-1]
                if(dp[i-1][j-1]) max_oper[i][j] = max(max_oper[i][j], max_oper[i-1][j-1]);
        */
        vector<vector<bool>> dp(n+1, vector<bool>(m+1, false));
        vector<vector<int>> max_oper(n+1, vector<int>(m+1, 0));
        for(int i=0; i<=n; i++){
            dp[i][0] = true;
            max_oper[i][0] = (i>0 ?max_oper[i-1][0] :0);
            if(can_remove.find(i-1)!=can_remove.end()) max_oper[i][0] = (i>0 ?max_oper[i-1][0] :0) + 1;
        }
        for(int i=1; i<=n; i++){
            for(int j=1; j<=m; j++){
                dp[i][j] = dp[i-1][j];
                max_oper[i][j] = max_oper[i-1][j];
                if(dp[i-1][j] && can_remove.find(i-1)!=can_remove.end()) max_oper[i][j] = max_oper[i-1][j] + 1;

                if(source[i-1]==pattern[j-1]){
                    dp[i][j] = dp[i][j] | dp[i-1][j-1];
                    if(dp[i-1][j-1]) max_oper[i][j] = max(max_oper[i][j], max_oper[i-1][j-1]);
                }
            }
        }
        return max_oper[n][m];
    }
};",1420075121
Nelson,Nelson84,243,3604,cpp,"using LL = long long;
class Solution {
    int mod = 1e9+7;
public:
    int numberOfWays(int n, int x, int y) {
        /*
            n performers
            x stages
            [1 y] score

            dp[i][j] = number of ways i performers split to j stages

            still j group which means the i performer is assigned to the original j groups
            dp[i][j] = dp[i-1][j] * j 

            the i performer is assigned to the new groups
            dp[i][j] = dp[i-1][j-1] * y * (x-j+1)        
        */
        LL dp[n+1][x+1];
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        for(int i=1; i<=n; i++){
            for(int j=1; j<=x; j++){
                dp[i][j] = (dp[i-1][j]*j%mod + dp[i-1][j-1]*y*(x-j+1)%mod)%mod;
                //printf(""%d "", dp[i][j]);
            }
            //printf(""\n"");
        }

        int res = 0;
        for(int group=0; group<=x; group++) res = (res + dp[n][group])%mod;
        return res;
    }
};",1420106893
Nelson,Nelson84,243,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        /*
            0001 | 0010 = 0011
            0010 | 0011 = 0011
            0011 | 0100 = 0111
            0100 | 0101 = 0101
            0101 | 0110 = 0111
            0110 | 0111 = 0111
            0111 | 1000 = 1111
        */
        int n = nums.size();
        vector<int> res(n, -1);
        for(int i=0; i<n; i++){
            int num = nums[i];
            for(int cur=1; cur<=num; cur++){
                if((cur|(cur+1))==num){
                    res[i] = cur;
                    break;
                }
            }
        }
        return res;
    }
};",1420007270
Nelson,Nelson84,243,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        /*
            0001 | 0010 = 0011
            0010 | 0011 = 0011
            0011 | 0100 = 0111
            0100 | 0101 = 0101
            0101 | 0110 = 0111
            0110 | 0111 = 0111
            0111 | 1000 = 1111

            0000[1111111] | 0001[0000000] => 0001[1111111]

            987654 3210
            000100 1111
            000100 0111
        */
        int n = nums.size();
        vector<int> res(n, -1);
        for(int i=0; i<n; i++){
            int num = nums[i];
            if(num%2==0) continue;

            int consectuive_one = 0;
            for(int shift=0; shift<32; shift++){
                if((num>>shift)&1) consectuive_one = shift;
                else break;
            }
            res[i] = num - (1<<consectuive_one);
        }
        return res;
    }
};",1420016811
avienn_x,avienn_x,244,3487,cpp,"class Solution {
public:
    vector<int> computeZ(const string& str) {
        int n = str.size();
        vector<int> Z(n, 0);
        int l = 0, r = 0;
        for(int i = 1; i < n; ++i){
            if(i <= r){
                Z[i] = min(r - i + 1, Z[i - l]);
            }
            while(i + Z[i] < n && str[Z[i]] == str[i + Z[i]]){
                Z[i]++;
            }
            if(i + Z[i] - 1 > r){
                l = i;
                r = i + Z[i] - 1;
            }
        }
        return Z;
    }
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(), m = p.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> match(n, false);
        int ans = t.size();
        vector<int> z_match = computeZ(s + ""$"" + p);
        for(int i : t)
            match[i] = true;
        for(int i = 0; i < n; ++i){
            for(int j = m; j > 0; --j){
                if(s[i] != p[j - 1])
                    continue;
                if(dp[j - 1] == INT_MAX)
                    continue;
                int curr = dp[j - 1];
                if(match[i])
                    curr++;
                dp[j] = min(dp[j], curr);
            }
        }
        ans -= dp[m];
        if(dp[m] == INT_MAX)
            return 0;
        return ans;
    }
};",1420107045
avienn_x,avienn_x,244,3604,cpp,"const long long MOD = 1000000007;
const int MAX_N = 1000; 
const int MAX_X = 1000; 
long long Cpre[MAX_X + 1][MAX_X + 1];
long long Spre[MAX_N + 1][MAX_X + 1];
long long factpre[MAX_X + 1];
long long yp[MAX_X + 1];

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        factpre[0] = 1;
        yp[0] = 1;
        Spre[0][0] = 1;
        for(int i = 0; i <= x; ++i){
            if(i){
                factpre[i] = (factpre[i-1] * i) % MOD;
                yp[i] = (yp[i-1] * y) % MOD;
            }
            Cpre[i][0] = 1;
            for(int j = 1; j <= i; ++j)
                Cpre[i][j] = (Cpre[i-1][j-1] + Cpre[i-1][j]) % MOD;
        }
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= x; ++j)
                Spre[i][j] = (j * Spre[i-1][j] + Spre[i-1][j-1]) % MOD;
        }
        long long ans = 0;
        for(int k = 1; k <= x; ++k){
            if(k > x || k > n)
                continue;
            long long curr = (Cpre[x][k] * Spre[n][k]) % MOD;
            curr = (curr * factpre[k]) % MOD;
            curr = (curr * yp[k]) % MOD;
            curr %= MOD;
            ans = (ans + curr) % MOD;
            ans %= MOD;
        }
        return (int)(ans);
    }
};
",1420091460
avienn_x,avienn_x,244,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        int n = arr.size();
        map<int,int> freq;
        for(int i : arr)
            freq[i]++;
        vector<int> ans;
        for (int i : arr) {
            int minv = INT_MAX;
            for (int k = 0; k <= log2(i) + 1; k++) {
                int x = i ;
                int curr_bit = (1 << k);
                x -= curr_bit ;
                if(x < 0 || (((x | (x + 1)) != i)))
                    continue;
                if (x < minv)
                    minv = x;
            }
            if(minv != INT_MAX)
                ans.push_back(minv);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};",1420024725
avienn_x,avienn_x,244,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        int n = arr.size();
        map<int,int> freq;
        for(int i : arr)
            freq[i]++;
        vector<int> ans;
        for (int i : arr) {
            int minv = INT_MAX;
            for (int k = 0; k <= log2(i) + 1; k++) {
                int x = i ;
                int curr_bit = (1 << k);
                x -= curr_bit ;
                if(x < 0 || (((x | (x + 1)) != i)))
                    continue;
                if (x < minv)
                    minv = x;
            }
            if(minv != INT_MAX)
                ans.push_back(minv);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};",1420024086
Lt Simon Riley,simon-riley,245,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        is_t = [False] * n
        
        for idx in targetIndices:
            is_t[idx] = True
        
        i = 0
        while i < n:
            j = m
            while j > 0:
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if is_t[i] else 0))
                j -= 1
            i += 1
        
        return len(targetIndices) - (dp[m] if dp[m] != float('inf') else 0)
",1420103719
Lt Simon Riley,simon-riley,245,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        l = [n, x, y]
        
        C = [[0] * (x + 1) for _ in range(x + 1)]
        i = 0
        while i <= x:
            C[i][0] = 1
            j = 1
            while j <= i:
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
                j += 1
            i += 1
        
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1
        i = 1
        while i <= n:
            j = 1
            while j <= x:
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
                j += 1
            i += 1
        
        fact = [1] * (x + 1)
        i = 1
        while i <= x:
            fact[i] = fact[i - 1] * i % MOD
            i += 1
        
        r = 0
        k = 1
        while k <= x:
            pwr = pow(y, k, MOD)
            r = (r + C[x][k] * S[n][k] % MOD * fact[k] % MOD * pwr % MOD) % MOD
            k += 1
        
        return r
",1420107323
Lt Simon Riley,simon-riley,245,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n
        i = 0
        
        while i < n:
            num = nums[i]
            min_ans = float('inf')
            found = False
            bit = 0
            
            while bit < 31:
                if (num >> bit) & 1:
                    cand = num & ~(1 << bit)
                    
                    if cand < 0:
                        bit += 1
                        continue
                    
                    if (cand | (cand + 1)) == num:
                        if cand < min_ans:
                            min_ans = cand
                            found = True
                
                bit += 1
            
            if found:
                res[i] = min_ans
            else:
                res[i] = -1

            i += 1
            
        return res
",1420099067
Lt Simon Riley,simon-riley,245,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n
        i = 0
        
        while i < n:
            num = nums[i]
            min_ans = float('inf')
            found = False
            bit = 0
            
            while bit < 31:
                if (num >> bit) & 1:
                    cand = num & ~(1 << bit)
                    
                    if cand < 0:
                        bit += 1
                        continue
                    
                    if (cand | (cand + 1)) == num:
                        if cand < min_ans:
                            min_ans = cand
                            found = True
                
                bit += 1
            
            if found:
                res[i] = min_ans
            else:
                res[i] = -1

            i += 1
            
        return res
",1420100201
Sarthak Tirpude,sarthak_tirpude,248,3487,cpp,"class Solution {
public:
    int dp[3005][3005];
    int help(int i,int j,string &a,string &b,set<int> &st){
        if(j==b.size()){
            // i se lekar n-1 jitne bhi st mei 
            int ans=0;
            for(int k=i;k<a.size();++k){
                if(st.count(k)) ++ans;
            }
            return ans;
        }
        if(i==a.size()){
            return -1000006;
        }
        if(dp[i][j]!=-1) return dp[i][j];
        if(a[i]==b[j]){
            // pick , not pick
            if(st.count(i)){
                int c1 = help(i+1,j+1,a,b,st);
                int c2 = 1 + help(i+1,j,a,b,st);
                return dp[i][j]=max(c1,c2);
            }
            else{
                return dp[i][j]=help(i+1,j+1,a,b,st);
            }
        }
        else{
            int cnt=0;
            if(st.count(i)) cnt++;
            return dp[i][j]=cnt + help(i+1,j,a,b,st);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        set<int> st(targetIndices.begin(),targetIndices.end());
        int n=source.size();
        for(int i=0;i<n+3;++i){
            for(int j=0;j<n+3;++j) dp[i][j]=-1;
        }
        return help(0,0,source,pattern,st);
    }
};",1420038585
Sarthak Tirpude,sarthak_tirpude,248,3604,cpp,"long long int mod = 1e9 + 7;
long long int binary_exponentiation(long long int a,long long int b){
    a%=mod;
    long long int result = 1,base = a, exp = b;
    while (exp > 0) {
        if (exp & 1){
            result = result * base;
            result %= mod;
        }
        base = base * base;
        base %= mod;
        exp >>= 1;
    }
    return result%mod;
}
long long int modularInv(long long int a){
    return binary_exponentiation(a,mod-2);
}
class Solution {
public:
    long long int dp[1101][1101];
    long long int fact[1101];
    long long int nCr(int n,int r){
        long long temp = fact[n];
        // cout<<""n: ""<<n<<"" fact[n]: ""<<fact[n]<<endl;
        temp = (modularInv(fact[n-r])%mod * temp%mod)%mod;
        // cout<<""n-r: ""<<fact[n-r]<<endl;
        temp = (modularInv(fact[r])%mod * temp%mod)%mod;
        // cout<<""r: ""<<fact[r]<<endl;
        return temp;
    }
    int numberOfWays(int n, int x, int y) {
        long long mod = 1e9 + 7;
        for(int i=1;i<=n;++i) dp[i][1]=1;
        for(int i=1;i<=n;++i) dp[i][i]=1;
        for(int i=1;i<=n;++i){
            for(int k=1;k<i;++k){
                dp[i][k] = ((k%mod * dp[i-1][k]%mod)%mod + dp[i-1][k-1]%mod)%mod;
            }
        }
        fact[0]=1;
        fact[1]=1;
        for(long long int i = 2;i<=max(n,x)+10;++i){
            fact[i] = (i%mod * fact[i-1]%mod) % mod;
        }
        long long ans=0ll;
        for(int i=1;i<=min(x,n);++i){
            long long res = dp[n][i];
            // cout<<""s n i: ""<<dp[n][i]<<endl;
            res = (res% mod * nCr(x,i)% mod)% mod;
            // cout<<""ncr: "" << nCr(x,i)<<endl;
            res = (res % mod * fact[i]% mod)% mod;
            // cout<<""fact: ""<<fact[i]<<endl;
            res = (res % mod * binary_exponentiation(y,i) % mod)% mod;
            // cout<<""y^i: ""<<binary_exponentiation(y,i)<<endl;
            // cout<<res<<endl;
            ans = (ans% mod + res% mod)% mod;
        }
        return ans%mod;
        
        
        
        return 0;
    }
};",1420107537
Sarthak Tirpude,sarthak_tirpude,248,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;++i){
            bool p=false;
            for(int temp=0;temp<1101;++temp){
                if((temp | (temp + 1)) == nums[i]){
                    p=true;
                    ans.push_back(temp);
                    break;
                }
            }
            if(!p) ans.push_back(-1);
        }
        return ans;
    }
};",1419995080
Sarthak Tirpude,sarthak_tirpude,248,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;++i){
            if(nums[i]==2){
                ans.push_back(-1);
                continue;
            }
            vector<int> bit(33);
            for(int j=0;j<31;++j){
                int tc=(1<<j);
                if(tc & nums[i]) ++bit[j];
            }
            int cont=0;
            int j=0;
            while(j<31 and bit[j]==1) ++j;
            if(j==1){
                ans.push_back(nums[i]-1);
                continue;
            }
            else{
                --j;
                bit[j]=0;
            }
            int res=0;
            for(int j=0;j<31;++j){
                int tc=(1<<j);
                if(bit[j]) res|=tc;
            }
            ans.push_back(res);
        }
        return ans;
    }
};",1420021078
E22CSEU0420,MCNHWOyhJd,249,3487,golang,"func maxRemovals(source string, pattern string, targetIndices []int) int {
    n := len(source)
    m := len(pattern)

    // Initialize dp array with 'infinity' (max int value)
    dp := make([]int, m+1)
    for i := 1; i <= m; i++ {
        dp[i] = math.MaxInt32
    }
    dp[0] = 0

    // Initialize isTarget array to track the removable indices
    isTarget := make([]bool, n)
    for _, idx := range targetIndices {
        isTarget[idx] = true
    }

    // Dynamic Programming process
    for i := 0; i < n; i++ {
        for j := m; j > 0; j-- {
            if source[i] == pattern[j-1] && dp[j-1] != math.MaxInt32 {
                if isTarget[i] {
                    dp[j] = min(dp[j], dp[j-1]+1)
                } else {
                    dp[j] = min(dp[j], dp[j-1])
                }
            }
        }
    }

    // Calculate the result
    if dp[m] == math.MaxInt32 {
        return 0
    }
    return len(targetIndices) - dp[m]
}",1420070580
E22CSEU0420,MCNHWOyhJd,249,3604,golang,"const MOD = 1000000007

func numberOfWays(n int, x int, y int) int {
    // Initialize combination array
    comb := make([][]int, x+1)
    for i := range comb {
        comb[i] = make([]int, x+1)
    }

    // Fill combination array using Pascal's triangle logic
    for i := 0; i <= x; i++ {
        comb[i][0] = 1
        for j := 1; j <= i; j++ {
            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
        }
    }

    // Initialize Stirling numbers of the second kind
    stirling := make([][]int, n+1)
    for i := range stirling {
        stirling[i] = make([]int, x+1)
    }
    stirling[0][0] = 1
    for i := 1; i <= n; i++ {
        for j := 1; j <= x; j++ {
            stirling[i][j] = (j*stirling[i-1][j] + stirling[i-1][j-1]) % MOD
        }
    }

    // Factorial array initialization
    factorial := make([]int, x+1)
    factorial[0] = 1
    for i := 1; i <= x; i++ {
        factorial[i] = factorial[i-1] * i % MOD
    }

    // Calculate the result using the precomputed arrays
    totalWays := 0
    for k := 1; k <= x; k++ {
        yPow := modPow(y, k, MOD)
        totalWays = (totalWays + comb[x][k]*stirling[n][k]%MOD*factorial[k]%MOD*yPow%MOD) % MOD
    }

    return totalWays
}

// Helper function to calculate (base^exp) % mod
func modPow(base, exp, mod int) int {
    result := 1
    for exp > 0 {
        if exp%2 == 1 {
            result = result * base % mod
        }
        base = base * base % mod
        exp /= 2
    }
    return result
}
",1420094832
E22CSEU0420,MCNHWOyhJd,249,3605,golang,"func minBitwiseArray(nums []int) []int {
    // Initialize the result array with -1
    result := make([]int, len(nums))
    for i := range result {
        result[i] = -1
    }

    // Iterate over the indices of the input array
    for i := 0; i < len(nums); i++ {
        // Iterate over possible values of result[i]
        for j := 0; j < nums[i]; j++ {
            // Check if the condition is satisfied
            if j|(j+1) == nums[i] {
                // Update the result array with the minimum possible value
                result[i] = j
                break
            }
        }
    }

    // Return the result array
    return result
}
",1420018519
E22CSEU0420,MCNHWOyhJd,249,3611,golang,"func minBitwiseArray(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)

    // Iterate over the input array
    for i := 0; i < n; i++ {
        num := nums[i]
        minimalAns := int(^uint(0) >> 1) // Set to maximum integer value (like Integer.MAX_VALUE in Java)
        found := false

        // Iterate through each bit position (0 to 30)
        for bit := 0; bit <= 30; bit++ {
            if (num>>bit)&1 == 1 {
                // Unset the current bit
                candidate := num & ^(1 << bit)

                // Ensure candidate is non-negative
                if candidate < 0 {
                    continue
                }

                // Check if candidate OR (candidate + 1) equals num
                if (candidate | (candidate + 1)) == num {
                    if candidate < minimalAns {
                        minimalAns = candidate
                        found = true
                    }
                }
            }
        }

        if found {
            ans[i] = minimalAns
        } else {
            ans[i] = -1
        }
    }

    return ans
}
",1420049755
Aasirikram,Aasirikram,251,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, removable_indices: List[int]) -> int:
        source_length = len(source)
        pattern_length = len(pattern)
        
        # dp array to track minimum removals needed to match pattern
        min_removals = [float('inf')] * (pattern_length + 1)
        min_removals[0] = 0  # No removals needed to match empty pattern
        
        # Array to mark which indices in source can be removed
        can_remove = [False] * source_length
        for index in removable_indices:
            can_remove[index] = True
        
        # Dynamic programming to find the minimum removals needed
        for i in range(source_length):
            for j in range(pattern_length, 0, -1):
                if source[i] == pattern[j - 1] and min_removals[j - 1] != float('inf'):
                    min_removals[j] = min(min_removals[j], min_removals[j - 1] + (1 if can_remove[i] else 0))
        
        # Calculate the maximum number of removable characters
        if min_removals[pattern_length] == float('inf'):
            return len(removable_indices)  # If pattern can't be formed, return total removals
        return len(removable_indices) - min_removals[pattern_length]
          ",1420097323
Aasirikram,Aasirikram,251,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, total: int, groups: int, y_value: int) -> int:
        # Initialize arrays for combinations, Stirling numbers, and factorials
        combination = [[0] * (groups + 1) for _ in range(groups + 1)]
        stirling = [[0] * (groups + 1) for _ in range(total + 1)]
        factorial = [1] * (groups + 1)

        # Precompute combinations (C)
        for i in range(groups + 1):
            combination[i][0] = 1
            for j in range(1, i + 1):
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD

        # Precompute Stirling numbers of the second kind (S)
        stirling[0][0] = 1
        for i in range(1, total + 1):
            for j in range(1, groups + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD

        # Precompute factorials
        for i in range(1, groups + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        result = 0
        # Main computation loop
        for k in range(1, groups + 1):
            # Calculate y_value^k
            power = pow(y_value, k, MOD)
            result = (result + combination[groups][k] * stirling[total][k] % MOD * factorial[k] % MOD * power % MOD) % MOD

        return result
        ",1420099553
Aasirikram,Aasirikram,251,3605,cpp,"#include <vector>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> result;
        
        for (int number : nums) {
            int smallestValue = findSmallestValue(number);
            result.push_back(smallestValue);
        }
        
        return result;
    }

private:
    int findSmallestValue(int target) {
        for (int candidate = 0; candidate <= target; ++candidate) {
            if ((candidate | (candidate + 1)) == target) {
                return candidate;  // Return the smallest valid candidate
            }
        }
        return -1;  // Return -1 if no valid candidate found
    }
};",1420101993
Aasirikram,Aasirikram,251,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> a) {
        int n = a.size();
        int[] b = new int[n];
        
        for (int i = 0; i < n; i++) {
            int x = a.get(i);
            int y = Integer.MAX_VALUE;
            boolean f = false;
            
            // Iterate through each bit position (0 to 30)
            for (int j = 0; j <= 30; j++) {
                if (((x >> j) & 1) == 1) {
                    // Unset the current bit
                    int z = x & ~(1 << j);
                    
                    // Ensure z is non-negative
                    if (z < 0) continue;
                    
                    // Check if z OR (z + 1) equals x
                    if ((z | (z + 1)) == x) {
                        if (z < y) {
                            y = z;
                            f = true;
                        }
                    }
                }
            }
            
            if (f) {
                b[i] = y;
            } else {
                b[i] = -1;
            }
        }
        
        return b;
    }
}",1420094615
Amay Singh,Amay12,253,3487,python3,"def bpm(u, seen, match_r,adj):        
        for v in adj[u]:
            if not seen[v]:
                seen[v] = True
                if match_r[v] == -1 or bpm(match_r[v], seen, match_r,adj):
                    match_r[v] = u
                    return True
        return False
def fsubs(s, p, removed_set):
        j= 0
        for i, char in enumerate(s):
            if i in removed_set:
                continue
            if char == p[j]:
                j+= 1
                if j== len(p):
                    return True
        return j== len(p)
import math
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:      
        n = len(source)
        m = len(pattern)
        t = len(targetIndices)
        ts = set(targetIndices)        
        INF = math.inf
        dp = [ [INF]*(n+1) for _ in range(m+1)]
        pn=pattern        
        for j in range(n+1):
            dp[0][j] = 0
        
        for j in range(1, m+1):
            for jj in range(1, n+1):
                if source[jj-1] == pn[j-1]:                    
                    dp[j][jj] = min(
                        dp[j][jj-1],
                        dp[j-1][jj-1] + (1 if (jj-1) in ts else 0)
                    )
                else:                    
                    dp[j][jj] = dp[j][jj-1]
        
        
        if dp[m][n] == INF:
            return 0        
        p = dp[m][n]  
        ans= t - p   
        return ans",1420103080
Amay Singh,Amay12,253,3604,python3,"MOD=10**9+7

def compute_factorials(max_n):
    factorial = [1] * (max_n + 1)
    for i in range(1, max_n + 1):
        factorial[i] = (factorial[i-1] * (i % MOD))%MOD
    return factorial

def compute_inverse_factorials(factorial):
    max_n = len(factorial) -1
    inv_fact = [1] * (max_n +1)
    inv_fact[max_n] = pow(factorial[max_n], MOD-2, MOD)
    for i in range(max_n-1, -1, -1):
        inv_fact[i] = (inv_fact[i+1] * ((i+1) % MOD))%MOD
    return inv_fact

def binomial_coefficient(n, k, factorial, inv_fact):
    if k <0 or k >n:
        return 0
    else:
        return ((factorial[n]%MOD) *inv_fact[k] % MOD* inv_fact[n -k] % MOD)%MOD

def csn(n, k_max):
    
    S = [ [0]*(k_max+1) for _ in range(n+1) ]
    S[0][0] =1
    for i in range(1, n+1):
        for j in range(1, min(k_max, i)+1):
            S[i][j] = (j * S[i-1][j] + S[i-1][j-1]) % MOD
    return S

    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:        
        m_fact = max(x, n)
        factorial = compute_factorials(m_fact)
        i_fact = compute_inverse_factorials(factorial)
        
        k_max = min(n, x)
        S = csn(n, k_max)        
        ans=0
        for k in range(1, k_max +1):
            comb = binomial_coefficient(x, k, factorial, i_fact)
            stir = S[n][k]           
            fact_k = factorial[k]            
            y_pow_k = pow(y,k,MOD)
            
            xx= ((comb%MOD) * (stir%MOD)) % MOD
            xx= xx * fact_k % MOD
            xx = xx * y_pow_k % MOD
            ans= (ans%MOD+ xx%MOD) % MOD
        return ans
        ",1420048572
Amay Singh,Amay12,253,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            x = 0
            temp = i            
            while (temp & 1):
                x+=1
                temp >>=1
            if x==0:
                ans.append(-1)
            else:
                y= i - (1 << (x-1))                
                if (y | (y +1)) == i:
                    ans.append(y)
                else:
                    ans.append(-1)
        return ans
        ",1420000172
Amay Singh,Amay12,253,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            x = 0
            temp = i            
            while (temp & 1):
                x+=1
                temp >>=1
            if x==0:
                ans.append(-1)
            else:
                y= i - (1 << (x-1))                
                if (y | (y +1)) == i:
                    ans.append(y)
                else:
                    ans.append(-1)
        return ans
        ",1419999147
Imadra,Imadra,254,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int k = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());

        const int INF = INT_MAX / 2;
        vector<vector<int>> dp(k + 1, vector<int>(n + 1, INF));

        for (int j = 0; j <= n; ++j) {
            dp[0][j] = 0;
        }

        for (int i = 0; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                if (dp[i][j] < INF) {
                    dp[i][j + 1] = min(dp[i][j + 1], dp[i][j]);
                    if (pattern[i] == source[j]) {
                        int cost = dp[i][j] + (targetSet.count(j) ? 1 : 0);
                        dp[i + 1][j + 1] = min(dp[i + 1][j + 1], cost);
                    }
                }
            }
        }

        int minCost = INF;
        for (int j = 0; j <= n; ++j) {
            minCost = min(minCost, dp[k][j]);
        }

        if (minCost >= INF) {
            return 0;
        }

        int m = targetIndices.size();
        return m - minCost;
    }
};",1420065617
Imadra,Imadra,254,3604,cpp,"typedef long long ll;
const ll MOD = 1000000007;
const int MAX_N = 1000;
class Solution {
public:
    ll modPow(ll base, ll exponent, ll mod) {
        ll result = 1;
        base %= mod;  // Ensure base is within mod
        while (exponent > 0) {
            if (exponent % 2 == 1) {  // If exponent is odd
                result = (result * base) % mod;
            }
            base = (base * base) % mod;  // Square the base
            exponent /= 2;
        }
        return result;
    }

    // Function to compute factorial modulo MOD
    std::vector<ll> computeFactorials(int max_n, ll mod) {
        std::vector<ll> factorial(max_n + 1, 1);
        for (int i = 1; i <= max_n; ++i) {
            factorial[i] = (factorial[i - 1] * i) % mod;
        }
        return factorial;
    }

    // Function to compute inverse factorials modulo MOD
    std::vector<ll> computeInverseFactorials(const std::vector<ll>& factorial, ll mod) {
        int max_n = factorial.size() - 1;
        std::vector<ll> inv_factorial(max_n + 1, 1);
        inv_factorial[max_n] = modPow(factorial[max_n], mod - 2, mod);
        for (int i = max_n - 1; i >= 0; --i) {
            inv_factorial[i] = (inv_factorial[i + 1] * (i + 1)) % mod;
        }
        return inv_factorial;
    }

    // Function to compute nCr modulo MOD
    ll modComb(int n, int r, const std::vector<ll>& factorial, const std::vector<ll>& inv_factorial, ll mod) {
        if (r < 0 || r > n) return 0;
        return (((factorial[n] * inv_factorial[r]) % mod) * inv_factorial[n - r]) % mod;
    }

    // Function to compute Stirling numbers of the second kind modulo MOD
    std::vector<std::vector<ll>> computeStirlingNumbers(int n, int k_max, ll mod) {
        std::vector<std::vector<ll>> S(n + 1, std::vector<ll>(k_max + 1, 0));
        S[0][0] = 1;
        for (int N = 1; N <= n; ++N) {
            for (int K = 1; K <= std::min(N, k_max); ++K) {  // Corrected loop condition
                S[N][K] = (K * S[N - 1][K] % mod + S[N - 1][K - 1]) % mod;
            }
        }
        return S;
    }

    int numberOfWays(int n, int x, int y) {
        int max_n = std::max(n, x);
        std::vector<ll> factorial = computeFactorials(max_n, MOD);
        std::vector<ll> inv_factorial = computeInverseFactorials(factorial, MOD);
        
        // Compute Stirling numbers of the second kind
        std::vector<std::vector<ll>> S = computeStirlingNumbers(n, x, MOD);
        
        ll total_sum = 0;
        int k_max = std::min(n, x);
        
        for (int k = 1; k <= k_max; ++k) {
            // Compute combination C(x, k)
            ll comb = modComb(x, k, factorial, inv_factorial, MOD);
            
            // Compute k!
            ll k_fact = factorial[k];
            
            // Get S(n, k)
            ll S_nk = S[n][k];
            
            // Compute y^k % MOD
            ll y_pow_k = modPow(y % MOD, k, MOD);
            
            // Compute term: comb * k_fact * S_nk * y_pow_k % MOD
            ll term = (((((comb * k_fact) % MOD) * S_nk) % MOD) * y_pow_k) % MOD;  // Adjusted order to prevent overflow
            
            // Add to total sum
            total_sum = (total_sum + term) % MOD;
        }

        return total_sum;
    }
};",1420103135
Imadra,Imadra,254,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto el : nums) {
            bool f = 0;
            for(int i=1;i<=el+1;i++) {
                if((i | (i + 1)) == el) {
                    // cout<<i<<"" ""<<i+1<<"" ""<<i|(i + 1)<<"" ""<<el<<endl;
                    ans.push_back(i);
                    f = 1;
                    break;
                }
            }
            if(f == 0)
                ans.push_back(-1);
        }
        return ans;
    }
};",1419998792
Imadra,Imadra,254,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto n : nums) {
            if(n == 2) {
                ans.push_back(-1);
                continue;
            }
            unsigned int current_length = 0;  // Length of consecutive 1's starting from LSB
            unsigned int position = 0;        // Current bit position
            unsigned int seq_end_pos = 0;     // Position of the most significant bit in the sequence

            unsigned int temp_n = n;

            // Find the longest sequence of consecutive 1's starting from LSB
            while ((temp_n & 1) == 1) {
                current_length++;
                temp_n >>= 1;
                position++;
            }

            if (current_length > 0) {
                seq_end_pos = position - 1;       // Position of the most significant bit in the sequence
                n ^= (1U << seq_end_pos);         // Flip the most significant bit of the sequence
            }


            ans.push_back(n);
        }
        return ans;
    }
};",1420020731
john0312acc223,john0312acc223,256,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        vector<int> cbest(pattern.size()+1, -10*n);
        vector<int> nbest(pattern.size()+1, -10*n);
        int ti_idx = 0;
        for (int i = 0; i < n; i++) {
            if (source[i] == pattern[0]) {
                nbest[0] = ti_idx;
            } else {
                nbest[0] = -10*n;
            }
            if (ti_idx < targetIndices.size() && targetIndices[ti_idx] == i) {
                // Removable
                nbest[0] = max(nbest[0], cbest[0]+1);
                for (int j = 1; j < pattern.size(); j++) {
                    nbest[j] = cbest[j]+1;
                    if (pattern[j] == source[i]) {
                        nbest[j] = max(cbest[j-1], nbest[j]);
                    }
                }
                ti_idx++;
            } else {
                // Non-removable
                nbest[0] = max(nbest[0], cbest[0]);
                for (int j = 1; j < pattern.size(); j++) {
                    if (pattern[j] == source[i]) {
                        nbest[j] = max(cbest[j-1], cbest[j]);
                    } else {
                        nbest[j] = cbest[j];
                    }
                }
            }
            cbest.swap(nbest);
        }
        return cbest[pattern.size()-1];
    }
};",1420051876
john0312acc223,john0312acc223,256,3604,cpp,"constexpr long long MOD = 1000000007LL;

class Solution {
public:
    long long Cnk_cache[1024][1024];
    long long Cnk(long long n, long long k) {
        if (Cnk_cache[n][k] != -1) return Cnk_cache[n][k];
        if (k == 0 || k == n) {
            Cnk_cache[n][k] = 1;
            return 1;
        }
        Cnk_cache[n][k] = (Cnk(n-1, k-1) + Cnk(n-1, k))%MOD;
        return Cnk_cache[n][k];
    }

    long long Exp_cache[1024][1024];
    long long Exp(long long base, long long pow) {
        if (Exp_cache[base][pow] != -1) return Exp_cache[base][pow];
        if (pow == 1) {
            Exp_cache[base][pow] = base%MOD;
            return Exp_cache[base][pow];
        }
        if (pow == 0) {
            Exp_cache[base][pow] = 1;
            return 1;
        }
        Exp_cache[base][pow] = (Exp(base, pow-1)*base)%MOD;
        return Exp_cache[base][pow];
    }

    long long F_cache[1024][1024];
    long long F(long long x, long long n) {
        if (F_cache[x][n] != -1) return F_cache[x][n];
        if (x == 1) return 1;

        long long cval = Exp(x, n);
        for (int i = 1; i < x; i++) {
            long long itm_val = (F(i, n)*Cnk(x, i))%MOD;
            cval += (MOD - itm_val);
            cval = cval % MOD;
        }

        F_cache[x][n] = cval;
        return cval;
    }

    int numberOfWays(int n, int x, int y) {
        memset(Cnk_cache, -1, sizeof(Cnk_cache));
        memset(F_cache, -1, sizeof(F_cache));
        memset(Exp_cache, -1, sizeof(Exp_cache));

        long long res = 0;
        for (int i = 1; i <= min(x, n); i++) {
            long long citm = F(i, n) % MOD;
            //printf(""F(%d, %d) = %d\n"", i, n, citm);
            //printf(""Exp(%d, %d) = %d\n"", y, i, Exp(y, i));
            citm = (citm * Cnk(x, i))%MOD;
            citm = (citm * Exp(y, i))%MOD;
            res += citm;
            res = res % MOD;
        }

        return res;
    }
};",1420110291
john0312acc223,john0312acc223,256,3605,cpp,"class Solution {
public:
    bool testOK(long long tval, long long x) {
        return (tval | (tval + 1)) == x;
    }
    long long solve(long long x) {
        if (x == 2) return -1;
        long long res = x-1;
        for (int i = 1; i < 32; i++) {
            if (((1LL<<i) & x) == 0) {
                // Not going to work.
                continue;
            }
            long long tval = (x & (~((1LL<<i)-1)))-1;
            if (testOK(tval, x)) {
                res = min(res, tval);
            }
        }
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            long long ans = solve(nums[i]);
            res.push_back(static_cast<int>(ans));
        }
        return res;
    }
};",1420012974
john0312acc223,john0312acc223,256,3611,cpp,"class Solution {
public:
    bool testOK(long long tval, long long x) {
        return (tval | (tval + 1)) == x;
    }
    long long solve(long long x) {
        if (x == 2) return -1;
        long long res = x-1;
        for (int i = 1; i < 32; i++) {
            if (((1LL<<i) & x) == 0) {
                // Not going to work.
                continue;
            }
            long long tval = (x & (~((1LL<<i)-1)))-1;
            if (testOK(tval, x)) {
                res = min(res, tval);
            }
        }
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            long long ans = solve(nums[i]);
            res.push_back(static_cast<int>(ans));
        }
        return res;
    }
};",1420012506
Nikhil Gupta,user4367Y,257,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& idx) {
        int n = s.size();
        int m = t.size();
        int dp[m+1];
        int vis[n];
        memset(vis,0,sizeof(vis));
        for(int i=0;i<m+1;i++){
            dp[i] = 1e9;
        }
        dp[0]=0;
        for(auto i:idx)vis[i]=1;
        for(int i=0;i<n;i++){
            for(int j=m;j>0;j--){
                if(s[i]==t[j-1] && dp[j-1]!=1e9){
                    dp[j] = min(dp[j],dp[j-1]+vis[i]);
                }
            }
        }
        int ans = (int)idx.size();
        if(dp[m]!=1e9)ans-=dp[m];
        return ans;
    }
};",1420110387
Nikhil Gupta,user4367Y,257,3604,cpp,"class Solution {
public:
    using ll = long long;
    ll mod = 1e9+7;
    ll fact[1001];
    ll power(ll a,ll b){
        ll ans = 1;
        while(b>0){
            if(b%2){
                ans = (ans*a)%mod;
            }
            a = (a*a)%mod;
            b/=2;
        }
        return ans;
    }
    ll nCr(int n,int r){
        ll num = fact[n];
        ll den = (fact[r]*fact[n-r])%mod;
        den = power(den,mod-2);
        num = (num*den)%mod;
        return num;
    }
    int numberOfWays(int n, int x, int y) {
        fact[0]=1;
        fact[1]=1;
        for(int i=2;i<=x;i++){
            fact[i] = (1LL*fact[i-1]*i)%mod;
        }
        ll ans = 0;
        // ll a[x+1][x+1];
        // memset(a,0,sizeof(a));
        // a[0][0]=1;
        // for(int i=1;i<=x;i++){
        //     for(int j=0;j<=i;j++){
        //         a[i][j] = a[i-1][j];
        //         if(j-1>=0)a[i][j] = (a[i][j]+a[i-1][j-1])%mod;
        //     }
        // }
        ll py[x+1];
        py[0]=1;
        for(int i=1;i<=x;i++){
            py[i] = (1LL*py[i-1]*y)%mod;
        }
        for(ll i=1;i<=x;i++){
            ll sum = 0;
            for(ll j=0;j<=i;j++){
                ll cur = (nCr(i,j)*power(i-j,n))%mod;
                if(j%2){
                    cur*=(-1);
                }
                sum += cur;
                if(sum<0){
                    sum+=mod;
                }
                sum%=mod;
            }
            ll temp = (((nCr(x,i)*sum)%mod)*py[i])%mod;
            ans = (ans+temp)%mod;
        }
        return ans;
    }
};",1420100398
Nikhil Gupta,user4367Y,257,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            int j=0;
            while(j<31 && ((nums[i]>>j)&1)){
                j++;
            }
            j--;
            if(j>=0){
                int cur = 0;
                for(int k=0;k<j;k++){
                    cur |= (1<<k);
                }
                for(int k=j+1;k<31;k++){
                    if((nums[i]>>k)&1){
                        cur |= (1<<k);
                    }
                }
                ans[i]=cur;
            }
        }
        return ans;
    }
};",1420004303
Nikhil Gupta,user4367Y,257,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            int j=0;
            while(j<32 && ((nums[i]>>j)&1)){
                j++;
            }
            j--;
            if(j>=0){
                int cur = 0;
                for(int k=0;k<j;k++){
                    cur |= (1<<k);
                }
                for(int k=j+1;k<32;k++){
                    if((nums[i]>>k)&1){
                        cur |= (1<<k);
                    }
                }
                ans[i]=cur;
            }
        }
        return ans;
    }
};",1420005758
Ashu,_Ashu1729,258,3487,cpp,"#pragma GCC optimize(""O3"")
class Solution {
public:
    long long dp(int i, int j, const std::string& s, const std::string& p, const std::vector<bool>& t, std::vector<std::vector<long long>>& memo) {
        if (j == p.size()) return 0;
        if (i == s.size()) return INT_MAX;

        if (memo[i][j] != -1) return memo[i][j];

        long long x = dp(i + 1, j, s, p, t, memo);
        long long y = INT_MAX;

        if (s[i] == p[j]) {
            y = dp(i + 1, j + 1, s, p, t, memo);
            if (t[i]) {
                y += 1;
            }
        }

        return memo[i][j] = std::min(x, y);
    }

    int maxRemovals(std::string s, std::string p, std::vector<int>& idx) {
        std::vector<bool> t(s.size(), false);
        for (int i : idx) {
            t[i] = true;
        }

        std::vector<std::vector<long long>> memo(s.size() + 1, std::vector<long long>(p.size() + 1, -1));
        long long r = dp(0, 0, s, p, t, memo);

        return r == INT_MAX ? 0 : idx.size() - r;
    }
};",1420083692
Ashu,_Ashu1729,258,3604,cpp,"#pragma GCC optimize(""O3"")
const int MOD = 1e9 + 7;

class Solution {
public:
    void computeDP(int n, int x, std::vector<std::vector<int>>& c, std::vector<std::vector<int>>& s, std::vector<long long>& f) {
        int a = 0;
        while (a <= x) {
            c[a][0] = 1;
            int b = 1;
            while (b <= a) {
                c[a][b] = (c[a - 1][b - 1] + c[a - 1][b]) % MOD;
                b++;
            }
            a++;
        }
        
        s[0][0] = 1;
        a = 1;
        while (a <= n) {
            int b = 1;
            while (b <= x) {
                s[a][b] = (1LL * b * s[a - 1][b] + s[a - 1][b - 1]) % MOD;
                b++;
            }
            a++;
        }
        
        f[0] = 1;
        a = 1;
        while (a <= x) {
            f[a] = (1LL * f[a - 1] * a) % MOD;
            a++;
        }
    }

    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> c(x + 1, std::vector<int>(x + 1, 0));
        std::vector<std::vector<int>> s(n + 1, std::vector<int>(x + 1, 0));
        std::vector<long long> f(x + 1);
        
        computeDP(n, x, c, s, f);
        
        long long res = 0;
        int k = 1;  
        while (k <= x) {
            long long pwr = 1;
            int d = 0;
            while (d < k) {
                pwr = (pwr * y) % MOD;
                d++;
            }
            res = (res + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * pwr % MOD)) % MOD;
            k++;
        }
        
        return res;
    }
};",1420071058
Ashu,_Ashu1729,258,3605,cpp,"#pragma GCC optimize(""O3"")
class Solution {
public:
 int solve(int p) {
    for (int i = 1; i <= p; ++i) {
        if ((i | (i + 1)) == p) {
            return i;
        }
    }
    return -1;
}

vector<int> minBitwiseArray(vector<int>& nums) {
    int n = nums.size();
    vector<int> ans(n, -1);
    for (int i = 0; i < n; ++i) {
        ans[i] = solve(nums[i]);
    }
    return ans;
}

};",1420013479
Ashu,_Ashu1729,258,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
      int m = n.size();
    std::vector<int> a(m);
    
    for (int i = 0; i < m; i++) {
        int x = n[i];
        int y = std::numeric_limits<int>::max();
        bool z = false;
        int b = 0;

        while (b <= 30) {
            if ((x & static_cast<int>(1 * std::pow(2, b))) != 0) {
                int c = x & ~(static_cast<int>(1 * std::pow(2, b)));
                if (c >= 0 && (c | (c + 1)) == x) {
                    y = std::min(y, c);
                    z = true;
                }
            }
            b++;
        }
        
        a[i] = z ? y : -1;
    }
    
    return a;
    }
};",1420052668
uday,uday5747,260,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val n = source.length
        val m = pattern.length
        val dp = MutableList(m + 1) { Int.MAX_VALUE }
        dp[0] = 0
        val isTarget = BooleanArray(n)
        for (idx in targetIndices) {
            isTarget[idx] = true
        }

        for (i in 0 until n) {
            for (j in m downTo 1) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != Int.MAX_VALUE) {
                    dp[j] = minOf(dp[j], dp[j - 1] + if (isTarget[i]) 1 else 0)
                }
            }
        }

        return targetIndices.size - if (dp[m] == Int.MAX_VALUE) 0 else dp[m]
    }
}
",1420047407
uday,uday5747,260,3604,kotlin,"class Solution {
    private val MOD = 1_000_000_007

    private fun computeCombinations(size: Int): Array<LongArray> {
        val combination = Array(size + 1) { LongArray(size + 1) { 0L } }
        for (i in 0..size) {
            combination[i][0] = 1L
            for (j in 1..i) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD
            }
        }
        return combination
    }

    private fun computePartitions(n: Int, x: Int): Array<LongArray> {
        val partition = Array(n + 1) { LongArray(x + 1) { 0L } }
        partition[0][0] = 1L
        for (i in 1..n) {
            for (j in 1..x) {
                partition[i][j] = (j * partition[i - 1][j] + partition[i - 1][j - 1]) % MOD
            }
        }
        return partition
    }

    private fun computeFactorials(size: Int): LongArray {
        val factorial = LongArray(size + 1) { 1L }
        for (i in 1..size) {
            factorial[i] = (factorial[i - 1] * i) % MOD
        }
        return factorial
    }

    fun numberOfWays(n: Int, x: Int, y: Int): Int {
        val combination = computeCombinations(x)
        val partition = computePartitions(n, x)
        val factorial = computeFactorials(x)

        var result = 0L
        for (k in 1..x) {
            var power = 1L
            repeat(k) {
                power = (power * y) % MOD
            }
            var term = combination[x][k]
            term = (term * partition[n][k]) % MOD
            term = (term * factorial[k]) % MOD
            term = (term * power) % MOD
            result = (result + term) % MOD
        }

        return result.toInt()
    }
}
",1420084031
uday,uday5747,260,3605,kotlin,"class Solution {
    fun findMinAns(prime: Int): Int {
        for (x in 1..prime) {
            if ((x or (x + 1)) == prime) {
                return x
            }
        }
        return -1
    }

    fun minBitwiseArray(nums: List<Int>): IntArray {
        val ans = IntArray(nums.size) { -1 }
        for (i in nums.indices) {
            ans[i] = findMinAns(nums[i])
        }
        return ans
    }
}
",1419996471
uday,uday5747,260,3611,kotlin,"class Solution {

    private fun computeResult(num: Int): Int {
        var lastSetBit = 0
        for (i in 0 until 32) {
            if (num and (1 shl i) != 0) {
                lastSetBit = i
            } else {
                break
            }
        }
        return num - (1 shl lastSetBit)
    }

    fun minBitwiseArray(nums: List<Int>): IntArray {
        val result = IntArray(nums.size) { -1 }
        for (i in nums.indices) {
            if (nums[i] != 2) {
                result[i] = computeResult(nums[i])
            }
        }
        return result
    }
}
",1420066135
Sreesh Maheshwar,sreeshmaheshwar,261,3487,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }  

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& is) {
        // I swear to god if N^2 passess....
        int n = sz(s), m = sz(t);
        vt<bool> in(n);
        for (int i : is) {
            in[i] = true;
        }
        vt<int> dp(m + 1, sz(is) + 100); 
        dp[0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = m - 1; j >= 0; --j) {
                // Take character if matches:
                if (s[i] == t[j]) {
                    umin(dp[j + 1], dp[j] + in[i]);
                }
            }
        }
        return sz(is) - dp[m];
    }
};",1420092666
Sreesh Maheshwar,sreeshmaheshwar,261,3604,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }  

template<const int MOD> struct mod_int {
    int val; mod_int() : val(0) {} mod_int(long long _val) : val(((_val % MOD) + MOD) % MOD) {}
    mod_int pow(int64_t b) const { mod_int r = 1, a = *this; while (b) { if (b & 1) r *= a; a *= a; b >>= 1; } return r; }
    mod_int& operator+=(const mod_int& other) { val += other.val; if (val >= MOD) val -= MOD; return *this; }
    mod_int& operator-=(const mod_int& other) { val -= other.val; if (val < 0) val += MOD; return *this; }
    mod_int& operator*=(const mod_int& other) { val = 1LL * val * other.val % MOD; return *this; }
    mod_int& operator/=(const mod_int& other) { return *this *= other.pow(MOD - 2); }
    friend mod_int operator+(const mod_int& x, const mod_int& y) { return mod_int(x) += y; }
    friend mod_int operator-(const mod_int& x, const mod_int& y) { return mod_int(x) -= y; }
    friend mod_int operator*(const mod_int& x, const mod_int& y) { return mod_int(x) *= y; }
    friend mod_int operator/(const mod_int& x, const mod_int& y) { return mod_int(x) /= y; }
};  
using mint = mod_int<1000000007>;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vt<mint> dp(x+1); // dp[i] is count for i stages taken.
        dp[0] = 1;
        forn(n) {
            vt<mint> ndp(x+1); // dp[i] is count for i stages taken.
            forn(j, x+1) {
                ndp[j]+=dp[j]*j;
                if(j+1<=x)ndp[j+1]+=dp[j]*(x-j);
            }
            dp = ndp;
        }
        mint ans = 0;
        forn(x+1){
            ans += dp[i] * mint(y).pow(i);
        }
        return ans.val;
    }
};",1419997413
Sreesh Maheshwar,sreeshmaheshwar,261,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> ret;
       for (int x : nums) {
            if (x == 2) ret.push_back(-1);
            else {
            int c = 0;
            while (x & 1) {
                x /= 2;
                c++;
            }
            ret.push_back((x << c) + (1 << (c - 1)) - 1);
            }
       }
       return ret;
    }
};",1420104882
Sreesh Maheshwar,sreeshmaheshwar,261,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> ret;
       for (int x : nums) {
            if (x == 2) ret.push_back(-1);
            else {
            int c = 0;
            while (x & 1) {
                x /= 2;
                c++;
            }
            ret.push_back((x << c) + (1 << (c - 1)) - 1);
            }
       }
       return ret;
    }
};",1420104232
Yagnik Dhameliya,dhameliyayagnik28,262,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& idx) {
        int n = s.size(), m = t.size(), k = idx.size();
        vector<int> vis(n);
        for(int i = 0; i < k; i++) vis[idx[i]] = 1;
        vector<int> dp(m + 1, 1e9);
        dp[0] = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = m - 1; j >= 0; j--)
            {
                if(s[i] == t[j]) dp[j + 1] = min(dp[j + 1], dp[j] + vis[i]);
            }
        }
        if(dp[m] == 1e9) return k;
        return k - dp[m];
    }
};",1420104199
Yagnik Dhameliya,dhameliyayagnik28,262,3604,cpp,"int binExp(int a, int b, int p) 
{
    if(b == 0) return 1;
    a %= p;
    int ans = binExp(a, b >> 1, p) % p;
    ans = (ans * 1LL * ans) % p;
    if(b & 1) return (a * 1LL * ans) % p;
    return ans;
}

class factm {
    public:
    vector<long long> fact, inv;
    int n, mod;
    factm(int size, int M) 
    {
        n = size; 
        mod = M;
        fact.resize(n + 1);
        inv.resize(n + 1);
        fact[0] = 1;
        for(int i = 1; i <= n; i++) 
        {
            fact[i] = (fact[i - 1] * 1LL * i) % mod;
        }

        inv[n] = binExp(fact[n], mod - 2, mod);
        for(int i = n - 1; i >= 0; i--) 
        {
            inv[i] = (inv[i + 1] * (i + 1)) % mod;
        }
    }

    int ncr(int a, int b)
    {
        if(a < b || a < 0 || b < 0) return 0;
        return (((fact[a] * inv[b]) % mod) * (inv[a - b])) % mod;
    }
};

class Solution {
public:
    const int N = 1005;
    const int M = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        factm f(2005, M);
        vector<long long> dp1(N + 1), ndp1(N + 1);
        for(int i = 0; i <= x; i++)
        {
            dp1[0] = 1;
            for(int j = 1; j <= i; j++) ndp1[j] = (dp1[j] + dp1[j - 1]) % M;
            dp1 = ndp1;
        }
        vector<long long> dp2(N + 1), ndp2(N + 1);
        dp2[0] = 1;
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= x; j++) ndp2[j] = (dp2[j] * j + dp2[j - 1]) % M;
            dp2 = ndp2;
        }
        int ans = 0;
        for(int i = 1; i <= x; i++)
        {
            long long cur = (f.fact[i] * 1LL * binExp(y, i, M)) % M;
            cur = (cur * dp1[i]) % M;
            cur = (cur * dp2[i]) % M;
            ans = (ans + cur) % M;
        }
        return ans;
    }
};",1420105258
Yagnik Dhameliya,dhameliyayagnik28,262,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j <= nums[i] - 1; j++)
            {
                if((j | (j + 1)) == nums[i])
                {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420104592
Yagnik Dhameliya,dhameliyayagnik28,262,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++)
        {
            long long mn = 1e18;
            for(int j = 0; j <= 31; j++)
            {
                if(nums[i] & (1 << j))
                {
                    int cur = nums[i] ^ (1 << j);
                    if((cur | (cur + 1)) == nums[i]) mn = min(mn, (long long)cur);
                }
            }
            if(mn != 1e18) ans[i] = (int)mn;
        }
        return ans;
    }
};",1420104517
Kirti Kumar,kirtikumarkk21,263,3487,cpp,"class Solution {
public:
string s,t;
map<int,int>mp;
// string ans;
vector<int>p;
int dp[3002][3002];
int sol(int i,int j)
{

    if(i==s.size())
    {
        if(j==t.size())
        {
            // for(auto it:p)
            // {
            //     cout<<it<<"" "";
            // }
            // cout<<endl;
            return 0;
        }
        return -1e8;
    }
    if(dp[i][j]!=-1)
    {
        return dp[i][j];
    }

    int ans=-1e8;
    if(j==t.size())
    {
        ans=max(ans,mp[i]+sol(i+1,j));
    }
    else
    {
        if(s[i]==t[j])
        {
            // p.push_back(i);
            ans=max(ans,sol(i+1,j+1));
            // p.pop_back();
            
            ans=max(ans,mp[i]+sol(i+1,j));

        }
        else
        {
            ans=max(ans,mp[i]+sol(i+1,j));
        }

    }
    return dp[i][j]=ans;

}
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {

        s=source;
        t=pattern;
        for(auto it:targetIndices)
        {
            mp[it]++;
        }
        memset(dp,-1,sizeof(dp));        
        return sol(0,0);
        
    }
};",1420077275
Kirti Kumar,kirtikumarkk21,263,3604,cpp,"#define MOD 1000000007
typedef int64_t ll;
ll binpow(ll a, ll b, ll m = MOD) {
	a %= m;
	ll res = 1;
	while (b > 0) {
		if (b & 1)
			res = res * a % m;
		a = a * a % m;
		b >>= 1;
	}
	return res % m;
}
ll invmd(ll n)
{
	return (binpow(n, MOD - 2));
}
const int N = 1e3 + 5;
ll fact[N + 2];
ll invfact[N + 2];
ll mul(ll a, ll b)
{
    a=a%MOD;
    b=b%MOD;
    return (a * b) % MOD;
}
ll add(ll a, ll b)
{
    a += b;
    if (a >= MOD)
    {
        a = a - MOD;
    }
    return a;
}
ll sub(ll a, ll b)
{
    a -= b;
    if (a < 0)
    {
        a += MOD;
    }
    return a;
}
ll divid(ll a, ll b)
{
    return mul(a, invmd(b));
}
vector<vector<unsigned long long>> S(N+3, vector<unsigned long long>(N+3, 0));
void calcfactorial()
{
    fact[0] = 1;
    for (int i = 1; i < N - 1; i++)
    {
        fact[i] = mul(i, fact[i - 1]);
    }
    invfact[N - 2] = invmd(fact[N - 2]);
    for (int i = N - 3; i >= 0; i--)
    {
        invfact[i] = mul(invfact[i + 1], i + 1);
    }


 

    // Base cases
    S[0][0] = 1;

    // Fill the DP table
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            S[i][j] = ((j * S[i - 1][j])%MOD + S[i - 1][j - 1]%MOD)%MOD;
        }
    }
    // return S[x][n];
}
ll ncr(ll n, ll k)
{
    return ((fact[n] * invfact[n - k]) % MOD * invfact[k]) % MOD;
}

ll calc(ll n,ll x)
{
    return (fact[n]*S[x][n])%MOD;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        swap(n,x);
        vector<ll>dp(n+1,0);
        ll ans=0;
        calcfactorial();

        for(int i=1;i<n+1;i++)
        {
            ll val=ncr(n,i)%MOD;
            ll val1=calc(i,x)%MOD;
            dp[i]=(val*val1)%MOD;
        }
        for(int i=1;i<n+1;i++)
        {
            ll val=(dp[i]*binpow(y,i))%MOD;
            ans=(ans+val)%MOD;
        }
        return ans%MOD;
        
    }
};",1420111748
Kirti Kumar,kirtikumarkk21,263,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        int n=nums.size();

        vector<int>ans(n,-1);
        int j=0;
        for(auto it:nums)
        {
            for(int i=1;i<1025;i++)
            {
                if((i|(i+1))==it)
                {
                    ans[j]=i;
                    break;
                }
            }
            j++;
        }
        return ans;
    }
};",1419997062
Kirti Kumar,kirtikumarkk21,263,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        int n=nums.size();
        vector<int>ans(n,-1);
        int j=0;
        for(auto it:nums)
        {
            for(int i=30;i>=0;i--)
            {
                int val=(1<<i);
                // cout<<val<<endl;
                if(it-val>=0)
                {
                    val=it-val;
                    if((val|(val+1))==it)
                    {
                        ans[j]=val;
                        break;
                    }
                }
            }
            j++;
        }
        return ans;
        
    }
};",1420021160
Last_Of_UsOO,Last_Of_UsOO,264,3487,cpp,"
#include <bits/stdc++.h>
using namespace std;

#define sz(x) int(x.size());

#define PT(value)                                                              \
    for (auto& ii : value)                                                     \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char* x) { cerr << '\""' << x << '\""'; }
void __print(const string& x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V> void __print(const pair<T, V>& x) {
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T> void __print(const T& x) {
    int f = 0;
    cerr << '{';
    for (auto& i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V> void _print(T t, V... v) {
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)                                                            \
    cerr << ""["" << #x << ""] = ["";                                              \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
};

class Solution {
public:
    const int maxValue = INT_MAX;
    void maximumRemoval(int n, int m, string& source, string& pattern,
                        vector<int>& nums, vector<int>& dpValue,
                        vector<bool>& valueTarget) {
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dpValue[j - 1] != maxValue)
                    dpValue[j] = min(dpValue[j],
                                     dpValue[j - 1] + (valueTarget[i] ? 1 : 0));
            }
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        fastio();
        int n = source.size();
        int m = pattern.size();
        int siz = targetIndices.size();

        vector<int> dpValue(m + 1, maxValue);
        dpValue[0] = 0;

        vector<bool> valueTarget(n, false);
        for (auto& ii : targetIndices)
            valueTarget[ii] = true;

        maximumRemoval(n, m, source, pattern, targetIndices, dpValue,
                       valueTarget);

        return siz - (dpValue[m] == maxValue ? 0 : dpValue[m]);
    }
};",1420063009
Last_Of_UsOO,Last_Of_UsOO,264,3604,cpp,"
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
#define sz(x) int(x.size());

#define PT(value)                                                              \
    for (auto& ii : value)                                                     \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char* x) { cerr << '\""' << x << '\""'; }
void __print(const string& x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V> void __print(const pair<T, V>& x) {
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T> void __print(const T& x) {
    int f = 0;
    cerr << '{';
    for (auto& i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V> void _print(T t, V... v) {
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)                                                            \
    cerr << ""["" << #x << ""] = ["";                                              \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
};

class Solution {
public:
    ll numberPossibleWay(int n, int x, int y, vvi& DpValue) {
        vvi DpMaxValue(n + 1, vi(x + 1, 0));
        DpMaxValue[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= x; j++)
                DpMaxValue[i][j] = (j * 1ll * DpMaxValue[i - 1][j] +
                                    DpMaxValue[i - 1][j - 1]) %
                                   MOD;

        vi value(x + 1, 1);
        for (int i = 1; i <= x; ++i)
            value[i] = (ll)value[i - 1] * i % MOD;

        function<ll(ll, ll)> powerValueClc = [&](ll a, ll b) {
            long long result = 1;
            result = a * b;
            return result;
        };
        int ansWerValue = 0;

        for (int i = 1; i <= x; i++) {
            ll power = 1;
            for (int p = 0; p < i; ++p)
                power = (powerValueClc(power, y)) % MOD;
            ll pVal = (ll)DpValue[x][i] * DpMaxValue[n][i] % MOD;
            ll qVal = (ll)value[i] % MOD * power % MOD;
            ansWerValue = ansWerValue + (pVal * qVal) % MOD;
            ansWerValue %= MOD;

        }
        return ansWerValue;
    }
    int numberOfWays(int n, int x, int y) {
        fastio();
        vi numsValue;
        numsValue.push_back(n);
        numsValue.push_back(x);
        numsValue.push_back(y);

        vvi DpValue(x + 1, vi(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            DpValue[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                DpValue[i][j] =
                    (DpValue[i - 1][j - 1] + DpValue[i - 1][j]) % MOD;
            }
        }

        return numberPossibleWay(n, x, y, DpValue);
    }
};",1420105393
Last_Of_UsOO,Last_Of_UsOO,264,3605,cpp,"
#include <bits/stdc++.h>
using namespace std;

#define sz(x) int(x.size());

#define PT(value)          \
    for (auto &ii : value) \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char *x) { cerr << '\""' << x << '\""'; }
void __print(const string &x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V>
void __print(const pair<T, V> &x)
{
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T>
void __print(const T &x)
{
    int f = 0;
    cerr << '{';
    for (auto &i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V>
void _print(T t, V... v)
{
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)               \
    cerr << ""["" << #x << ""] = [""; \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
};



class Solution
{
public:
    int findMinimumValue(int prime)
    {
        for (int x = 1; x <= prime; ++x)
        {
            if ((x | (x + 1)) == prime)
            {
                return x;
            }
        }
        return -1; 
    }

    vector<int> minBitwiseArray(vector<int> &nums)
    {
        fastio();
        int n = nums.size();
        vector<int> ans(n, -1); 
        for (int i = 0; i < n; ++i)
            ans[i] = findMinimumValue(nums[i]);

        return ans;
    }
};",1420006471
Last_Of_UsOO,Last_Of_UsOO,264,3611,cpp,"
#include <bits/stdc++.h>
using namespace std;

#define sz(x) int(x.size());

#define PT(value)                                                              \
    for (auto& ii : value)                                                     \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char* x) { cerr << '\""' << x << '\""'; }
void __print(const string& x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V> void __print(const pair<T, V>& x) {
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T> void __print(const T& x) {
    int f = 0;
    cerr << '{';
    for (auto& i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V> void _print(T t, V... v) {
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)                                                            \
    cerr << ""["" << #x << ""] = ["";                                              \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
};

class Solution {
public:
    void bitOperation(vector<int>& result, vector<int>& nums, int n) {
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int ansSwerValue = INT_MAX;
            bool BitValueFound = false;

            for (int i = 0; i <= 30; i++) {
                if (((num >> i) & 1) == 1) {
                    int bitValue = num & ~(1 << i);

                    if (bitValue < 0)
                        continue;
                    if ((bitValue | (bitValue + 1)) == num) {
                        if (bitValue < ansSwerValue) {
                            ansSwerValue = bitValue;
                            BitValueFound = true;
                        }
                    }
                }
            }

            if (BitValueFound)
                result[i] = ansSwerValue;
            else
                result[i] = -1;
        }
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        fastio();
        int n = nums.size();
        vector<int> result(n);
        bitOperation(result, nums, n);

        return result;
    }
};",1420052724
Sarthak Jha,SarthakkJha,265,3487,cpp,"class Solution {
public:
    int recur(string& source, string& pattern, vector<int>& tar, int i, int j, vector<int>& target, vector<vector<int>>& dp) {

        if (j == pattern.size()) {
            return 0;
        }
        if (i == source.size()) {
            return INT_MAX;
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int notake = recur(source, pattern, tar, i + 1, j, target, dp);

        if (source[i] == pattern[j]) {
            int cost = target[i] ? 1 : 0;
            int ans = recur(source, pattern, tar, i + 1, j + 1, target, dp);
            if (ans != INT_MAX) {
                notake = min(notake, cost + ans);
            }
        }

        return dp[i][j] = notake;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {

        int n = source.size();
        int m = pattern.size();

        vector<vector<int>> dp(n, vector<int>(m, -1));

        vector<int> target(n, 0);

        for (auto it : targetIndices) {
            target[it] = 1;
        }

        int ans = recur(source, pattern, targetIndices, 0, 0, target, dp);

        if(ans == 1e9)
        {
            return 0;
        }
        else
        {
            return targetIndices.size() - ans;
        }

    }
};
",1420084245
Sarthak Jha,SarthakkJha,265,3604,cpp,"class Solution {
public:
    long long MOD = 1e9 + 7;

    long long combination(long long n, long long k, vector<vector<long long>>& comb) {
        if (k == 0 || k == n) return 1;
        if (comb[n][k] != -1) return comb[n][k];
        return comb[n][k] = (combination(n - 1, k - 1, comb) + combination(n - 1, k, comb)) % MOD;
    }

    long long sterling(long long n, long long k, vector<vector<long long>>& strlng) {
        if (n == 0 && k == 0) return 1;
        if (n == 0 || k == 0) return 0;
        if (strlng[n][k] != -1) return strlng[n][k];
        return strlng[n][k] = (k * sterling(n - 1, k, strlng) % MOD + sterling(n - 1, k - 1, strlng)) % MOD;
    }

    long long power(long long x, long long y, long long p = 1e9 + 7) {
        unsigned long long res = 1;
        x = x % p;
        while (y > 0) {
            if (y & 1)
                res = (res * x) % p;
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }

    int numberOfWays(int n, int x, int y) {

        vector<vector<long long>> comb(1001, vector<long long>(1001, -1));
        vector<vector<long long>> snum(1001, vector<long long>(1001, -1));

        vector<long long> fact(x + 1, 1);
        for (int i = 2; i <= x; i++) {
            fact[i] = (long long)fact[i - 1] * i % MOD;
        }

        long long ans = 0;

        for (long long k = 1; k <= x; k++) {
            long long cc = combination(x, k, comb);
            long long stir = sterling(n, k, snum);
            long long val = power(y, k);
            ans = (ans + ((long long)cc * stir % MOD * fact[k] % MOD * val % MOD)) % MOD;
        }

        return ans;
    }
};
",1420111956
Sarthak Jha,SarthakkJha,265,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] % 2 == 0) {
                ans[i] = -1;  
            } else {
                int num = 0;
                int idx = -1;
                
                for(int j = 0; j < 32; j++) {
                    if(((1 << j) & nums[i]) == 0) {
                        idx = j - 1;
                        break;
                    }
                }

                for(int j = 0; j < 32; j++) {
                    if(j == idx) {
                        continue;
                    } else {
                        if((1 << j) & nums[i]) {
                            num += (1 << j);
                        }
                    }
                }

                ans[i] = num; 
            }
        }

        return ans;
    }
};
",1420022691
Sarthak Jha,SarthakkJha,265,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] % 2 == 0) {
                ans[i] = -1;  
            } else {
                int num = 0;
                int idx = -1;
                
                for(int j = 0; j < 32; j++) {
                    if(((1 << j) & nums[i]) == 0) {
                        idx = j - 1;
                        break;
                    }
                }

                for(int j = 0; j < 32; j++) {
                    if(j == idx) {
                        continue;
                    } else {
                        if((1 << j) & nums[i]) {
                            num += (1 << j);
                        }
                    }
                }

                ans[i] = num; 
            }
        }

        return ans;
    }
};
",1420022318
transcend_2002,transcend_2002,268,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size(),m=pattern.size();
        vector<int> good(n,0);
        for(int i:targetIndices){
            good[i]=1;
        }
        vector<int> dp(m+1,INT_MIN);
        dp[0]=0;
        for(int i=0;i<n;i++){
            vector<int> temp=dp;
            for(int j=0;j<=m;j++){
                if(dp[j]==INT_MIN)continue;
                if(j==m){
                    temp[m]=max(temp[m],dp[m]+good[i]);
                }else {
                    if(source[i]==pattern[j]){
                        temp[j]=max(temp[j],dp[j]+good[i]);
                        temp[j+1]=max(temp[j+1],dp[j]);
                    }else {
                           temp[j]=max(temp[j],dp[j]+good[i]);
                    }
                }
                
            }
            dp=temp;
        }
        return dp[m];
        
        
    }
};",1420105839
transcend_2002,transcend_2002,268,3604,cpp,"template <long long int mod>
struct modular {
    long long int value;
    modular(long long int x = 0) {
        value = x % mod;
        if (value < 0) value += mod;
    }
    modular &operator+=(const modular &other) {
        if ((value += other.value) >= mod) value -= mod;
        return *this;
    }
    modular &operator-=(const modular &other) {
        if ((value -= other.value) < 0) value += mod;
        return *this;
    }
    modular &operator*=(const modular &other) {
        value = value * other.value % mod;
        return *this;
    }
    modular &operator/=(const modular &other) {
        long long int a = 0, b = 1, c = other.value, m = mod;
        while (c != 0) {
            long long int t = m / c;
            m -= t * c;
            swap(c, m);
            a -= t * b;
            swap(a, b);
        }
        a %= mod;
        if (a < 0) a += mod;
        value = value * a % mod;
        return *this;
    }
    friend modular operator+(const modular &lhs, const modular &rhs) {
        return modular(lhs) += rhs;
    }
    friend modular operator-(const modular &lhs, const modular &rhs) {
        return modular(lhs) -= rhs;
    }
    friend modular operator*(const modular &lhs, const modular &rhs) {
        return modular(lhs) *= rhs;
    }
    friend modular operator/(const modular &lhs, const modular &rhs) {
        return modular(lhs) /= rhs;
    }
    modular &operator++() { return *this += 1; }
    modular &operator--() { return *this -= 1; }
    modular operator++(int) {
        modular res(*this);
        *this += 1;
        return res;
    }
    modular operator--(int) {
        modular res(*this);
        *this -= 1;
        return res;
    }
    modular operator-() const { return modular(-value); }
    bool operator==(const modular &rhs) const { return value == rhs.value; }
    bool operator!=(const modular &rhs) const { return value != rhs.value; }
    bool operator<(const modular &rhs) const { return value < rhs.value; }
};
template <typename U, typename V>
U power(const U &a, const V &b) {
    assert(b >= 0);
    U x = a, res = 1;
    V p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}
template <long long int mod>
ostream &operator<<(ostream &stream, const modular<mod> &x) {
    return stream << x.value;
}
template <long long int mod>
istream &operator>>(istream &stream, modular<mod> &x) {
    stream >> x.value;
    x.value %= mod;
    if (x.value < 0) x.value += mod;
    return stream;
}
constexpr long long int mod = 1e9 + 7;
using Mint = modular<mod>;
vector<Mint> fact, inv_fact;
class COMBINATORICS {
    size_t sz = 250010;
    void precompute() {
        fact.resize(sz + 1, 1);
        inv_fact.resize(sz + 1, 1);
        for (int i = 2; i <= sz; i++) fact[i] = fact[i - 1] * i;
        inv_fact[sz] /= fact[sz];
        for (int i = sz - 1; i >= 0; i--)
            inv_fact[i] = inv_fact[i + 1] * (i + 1);
    }

   public:
    COMBINATORICS() { precompute(); }
    inline Mint NCR(int n, int r) {
        if (r < 0 or r > n) return 0;
        Mint numerator = fact[n];
        Mint denominator = inv_fact[r] * inv_fact[n - r];
        Mint answer = numerator * denominator;
        return answer;
    }
    inline Mint NPR(int n, int r) {
        Mint answer = NCR(n, r) * fact[r];
        return answer;
    }
    inline Mint Derangements(int n, int r) {
        Mint answer = 0;
        for (int i = 0; i <= n; i++) {
            Mint ans = fact[n];
            ans /= fact[i];
            if (i & 1) ans *= -1;
            answer += ans;
        }
        return answer;
    }
};
COMBINATORICS obj;





class Solution {
public:
   int numberOfWays(int n, int x, int y) {
    // fix number of empty groups
    // n -> performers x -> stages y -> score
    Mint answer = 0;
    for (int r = 1; r <= x; r++) {
        Mint z = obj.NCR(x, r);
        z *= power((Mint)y, r);
        Mint ans = 0;
        for (int i = 0; i <= r; i++) {
            Mint u = obj.NCR(r, i);
            u *= power((Mint)r - i, n);
            if (i & 1)
                ans -= u;
            else
                ans += u;
        }
        z *= ans;

        answer += z;
    }
    int ans = answer.value;
    return ans;
}
};",1420077148
transcend_2002,transcend_2002,268,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> answer(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=1000;j++){
                if((j|(j+1))==nums[i]){
                    answer[i]=j;
                    break;
                }
            }
        }
        return answer;
    }
};",1419997073
transcend_2002,transcend_2002,268,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> answer;
        for(int i:nums){
            if(i==2){
                answer.push_back(-1);
                continue;
            }
            vector<int> b;
            int x=i;
            while(x){
                b.push_back(x&1);
                x>>=1;
            }
            b.push_back(0);
            for(int j=0;j<b.size();j++){
                if(b[j]==1)continue;
                else {
                    b[j-1]=0;
                    break;
                    
                }
            }
            int ans=0;
            for(int j=0;j<b.size();j++){
                if(b[j]==1){
                    ans|=(1<<j);
                }
            }
            answer.push_back(ans);
            
        }
        return answer;
    }
};",1420024772
Arjun Kshirsagar,Arjun-Kshirsagar,269,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        boolean[] isTarget = new boolean[n];
        for(int idx : targetIndices) isTarget[idx] = true;
        
        int[] previous = new int[n + 1];
        int INF = n + 1;
        for(int j = 0; j <= n; j++) previous[j] = INF;

        previous[0] = 0;
        
        for(int i = 1; i <= m; i++){
            int[] current = new int[n + 1];
            for(int j = 0; j <= n; j++) current[j] = INF;

            int minPrev = INF;
            for(int j = 1; j <= n; j++){
                minPrev = Math.min(minPrev, previous[j - 1]);
                
                if(source.charAt(j - 1) == pattern.charAt(i - 1)){
                    current[j] = Math.min(current[j], minPrev + (isTarget[j - 1] ? 1 : 0));
                }
            }
            previous = current;
        }
        
        int minUsedTargets = INF;
        for(int j = 1; j <= n; j++){
            minUsedTargets = Math.min(minUsedTargets, previous[j]);
        }
        
        if(minUsedTargets == INF) return 0;

        return targetIndices.length - minUsedTargets;
    }
}",1420070269
Arjun Kshirsagar,Arjun-Kshirsagar,269,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        final int MOD = 1_000_000_007;


        long[] perm = new long[x + 1];
        perm[0] = 1;
        for (int k = 1; k <= x; k++) {
            perm[k] = (perm[k - 1] * (x - k + 1)) % MOD;
        }


        long[][] dp = new long[n + 1][x + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int k = 1; k <= x; k++) {
                dp[i][k] = (dp[i - 1][k - 1] + k * dp[i - 1][k]) % MOD;
            }
        }

        long[] powerY = new long[x + 1];
        powerY[0] = 1;
        for (int k = 1; k <= x; k++) {
            powerY[k] = (powerY[k - 1] * y) % MOD;
        }

        long result = 0;

        for (int k = 1; k <= Math.min(n, x); k++) {
            long p = perm[k];
            long s = dp[n][k];
            long yPow = powerY[k];
            result = (result + p * s % MOD * yPow % MOD) % MOD;
        }

        return (int) result;
    }
}",1420086036
Arjun Kshirsagar,Arjun-Kshirsagar,269,3605,java,"public class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int temp = nums.get(i);
            
            if (temp == 2)  ans[i] = -1;
            else {
                int x = 0;
                while ((x | (x + 1)) != temp)  x++;
                ans[i] = x;
            }
        }
        
        return ans;
    }
}",1419997349
Arjun Kshirsagar,Arjun-Kshirsagar,269,3611,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for(int i = 0; i < n; i++) {
            int p = nums.get(i);
            
            if(p < 3) { // Only p=2 is possible here, set to -1
                ans[i] = -1;
                continue;
            }
            
            int min_x = -1;
            
            // Determine the number of bits in p
            int numBits = Integer.SIZE - Integer.numberOfLeadingZeros(p);
            
            // Iterate from the highest bit to the lowest
            for(int bit = numBits - 1; bit >= 0; bit--) {
                if((p & (1 << bit)) != 0) { // If the bit is set
                    // Flip the current bit to 0 and set all lower bits to 1
                    int mask = ~(1 << bit);
                    int lowerBits = (1 << bit) - 1;
                    int candidate = (p & mask) | lowerBits;
                    
                    // Validate the condition
                    if( (candidate | (candidate +1)) == p ) {
                        if(min_x == -1 || candidate < min_x) {
                            min_x = candidate;
                        }
                    }
                }
            }
            
            ans[i] = min_x;
        }
        
        return ans;
    }
}",1420059303
Elis__2003,Elis__2003,270,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> dp(pattern.length()+1,1e9);
        vector<bool> tar(source.length(),false);
        for(auto &i:targetIndices) tar[i]=true;
        dp[0]=0;
        for(int i=0;i<source.size();i++){
            for(int j=pattern.size();j>0;j--){
                if(source[i]==pattern[j-1]){
                    if(dp[j-1]!=1e9){
                        dp[j]=min(dp[j],dp[j-1]+tar[i]);
                        //cout<<dp[j]<<endl;
                    }
                }
            }
        }
        return targetIndices.size()-(dp.back()==1e9?0:dp.back());
    }
};",1420066461
Elis__2003,Elis__2003,270,3604,cpp,"#define ll long long
int mod=1e9+7;
long long binpow(long long x,ll y)
{
    ll p=mod;
	unsigned long long res = 1; 
	x = x % p; 
	while (y > 0) 
	{
		if (y & 1)
			res = (res * x) % p;
 	y = y >> 1;		x = (x * x) % p;
	}
	return res;
}


class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp1(x+1,vector<ll>(x+1,0));
        for(int i=0;i<=x;i++){
            dp1[i][0]=1;
            for(int j=1;j<=i;j++){
                dp1[i][j]=(dp1[i-1][j]+dp1[i-1][j-1])%mod;
            }
        }
 vector<vector<long long>> dp2(n+1,vector<ll>(x+1,0));
        dp2[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x;j++){
                dp2[i][j]=(j*1LL*dp2[i-1][j]+dp2[i-1][j-1])%mod;
            }
        }
        vector<long long> fact(x+1,1);
        for(int i=1;i<=x;i++) fact[i]=(fact[i-1]*i)%mod;
        long long ways=0;
        for(int i=1;i<=x;i++){
            ways=(ways+(dp1[x][i]*dp2[n][i]%mod)*fact[i]%mod*binpow(y,i)%mod)%mod;
            //cout<<ways<<endl;
        }
        //cout<<ways;
        return ways;



    }
};",1420112796
Elis__2003,Elis__2003,270,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            for(int j=0;j<=1000;j++){
                if(j<0) j=-(j+1);
                if((j|(j+1))==nums[i]) {ans[i]=j;break;}
            }
        }
        return ans;
    }
};",1420012062
Elis__2003,Elis__2003,270,3611,cpp,"class Solution {
public:
//11000011111
//11000100000
//31-->11111
//15-->01111
//11-->1011 9-->1001 
//13-->1101 12-->1100
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            int as=0;
            if(nums[i]==2) continue;
            for(int j=0;j<31;j++){
                if(((nums[i]>>j)&1)!=1){as=j; break;}
            }
         cout<<as<<endl;
            as=nums[i]^(1<<(as-1));
        
            ans[i]=as;
        }
        return ans;
    }
};",1420045676
Mythresh7,Mythresh7,271,3487,cpp,"class Solution {
    void markTargets( vector<int>& tikavmy, vector<int>& isTargetmykav, int index) {
        if (index >= tikavmy.size()) return;
        isTargetmykav[tikavmy[index]] = 1; // Mark as target
        markTargets(tikavmy, isTargetmykav, index + 1);
    }

public:
    int maxRemovals(string sourcemykav, string patternmykav, vector<int>& tikavmy) {
        int nmykav = sourcemykav.size();
        int mmykav = patternmykav.size();
        vector<int> dmkp(mmykav + 1, INT_MAX);
        dmkp[0] = 0;
        vector<int> isTargetmykav(nmykav, 0);
        markTargets(tikavmy, isTargetmykav, 0);

        int imyKav = 0;
        while (imyKav < nmykav) {
            int jmykav = mmykav;
            while (jmykav > 0) {
                if (sourcemykav[imyKav] == patternmykav[jmykav - 1] && dmkp[jmykav - 1] != INT_MAX) {
                    dmkp[jmykav] = min(dmkp[jmykav], dmkp[jmykav - 1] + (isTargetmykav[imyKav] ? 1 : 0));
                }
                jmykav--;
            }
            imyKav++;
        }
        
        return tikavmy.size() - (dmkp[mmykav] == INT_MAX ? 0 : dmkp[mmykav]);
    }
};
",1420089842
Mythresh7,Mythresh7,271,3604,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int numberOfWays(int nmykav, int xmykav, int ymykav) {
        const int MODmykav = 1e9 + 7;
        const int MAXmykav = 1001;

        vector<long long> factmykav = computeFact(MAXmykav, MODmykav);
        vector<long long> invFactmykav = computeInvFact(factmykav, MODmykav);
        vector<vector<long long>> Smykav = computeS(nmykav, MODmykav);

        long long total_waysmykav = 0;
        for (int kmykav = 1; kmykav <= min(nmykav, xmykav); kmykav++) {
            long long cmykav = comb(xmykav, kmykav, factmykav, invFactmykav, MODmykav);
            long long smykav = Smykav[nmykav][kmykav];
            long long k_factmykav = factmykav[kmykav];
            long long y_pow_kmykav = powmod(ymykav, kmykav, MODmykav);
            long long waysmykav = cmykav * smykav % MODmykav * k_factmykav % MODmykav * y_pow_kmykav % MODmykav;
            total_waysmykav = (total_waysmykav + waysmykav) % MODmykav;
        }

        return total_waysmykav;
    }

private:
    vector<long long> computeFact(int maxmykav, int modmykav) {
        vector<long long> factmykav(maxmykav);
        factmykav[0] = 1;
        for (int imyKav = 1; imyKav < maxmykav; imyKav++) {
            factmykav[imyKav] = factmykav[imyKav - 1] * imyKav % modmykav;
        }
        return factmykav;
    }

    vector<long long> computeInvFact(const vector<long long>& factmykav, int modmykav) {
        int maxmykav = factmykav.size();
        vector<long long> invFactmykav(maxmykav);
        invFactmykav[0] = 1;
        for (int imyKav = 1; imyKav < maxmykav; imyKav++) {
            invFactmykav[imyKav] = modinv(factmykav[imyKav], modmykav);
        }
        return invFactmykav;
    }

    long long modinv(long long amyKav, int modmykav) {
        return powmod(amyKav, modmykav - 2, modmykav);
    }

    long long powmod(long long amyKav, long long bmyKav, int modmykav) {
        long long resultmykav = 1;
        amyKav %= modmykav;
        while (bmyKav) {
            if (bmyKav & 1) resultmykav = resultmykav * amyKav % modmykav;
            amyKav = amyKav * amyKav % modmykav;
            bmyKav >>= 1;
        }
        return resultmykav;
    }

    long long comb(int nmykav, int kmykav, const vector<long long>& factmykav, const vector<long long>& invFactmykav, int modmykav) {
        if (kmykav < 0 || kmykav > nmykav) return 0LL;
        return factmykav[nmykav] * invFactmykav[kmykav] % modmykav * invFactmykav[nmykav - kmykav] % modmykav;
    }

    vector<vector<long long>> computeS(int nmykav, int modmykav) {
        vector<vector<long long>> Smykav(nmykav + 1, vector<long long>(nmykav + 1, 0));
        Smykav[0][0] = 1;
        for (int imyKav = 1; imyKav <= nmykav; imyKav++) {
            Smykav[imyKav][0] = 0;
            for (int jmykav = 1; jmykav <= imyKav; jmykav++) {
                Smykav[imyKav][jmykav] = (jmykav * Smykav[imyKav - 1][jmykav] % modmykav + Smykav[imyKav - 1][jmykav - 1]) % modmykav;
            }
        }
        return Smykav;
    }
};
",1420106862
Mythresh7,Mythresh7,271,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++)
        {
            int num=nums[i];
            int j;
            for( j=0;j<=num;j++)
            {
                if((j  | (j+1))==num)
                {
                    ans[i]=j;
                    break;
                }
            }
            if(j==num+1)
            ans[i]=-1;
        }
        return ans;
    }
};",1420005809
Mythresh7,Mythresh7,271,3611,cpp,"
class Solution {
private:
    int findMinReslt(int currNum, int bitPosishun, int minReslt) {
        if (bitPosishun >= 31) {
            return minReslt;
        }
        if ((currNum >> bitPosishun) & 1) {
            int modifideNum = currNum ^ (1 << bitPosishun);
            if ((modifideNum | (modifideNum + 1)) == currNum) {
                if (minReslt == -1 || modifideNum < minReslt) {
                    minReslt = modifideNum;
                }
            }
        }
        return findMinReslt(currNum, bitPosishun + 1, minReslt);
    }

public:
    vector<int> minBitwiseArray(vector<int>& numbs) {
        int nummberOfItems = numbs.size();
        vector<int> anss(nummberOfItems, -1);

        int idx = 0;
        while (idx < nummberOfItems) {
            int currNum = numbs[idx];
            int minReslt = findMinReslt(currNum, 0, -1);
            anss[idx] = minReslt;
            idx++;
        }
        return anss;
    }
};
",1420041998
Salyu,salyu,272,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& indices) {
        int n = source.size(), m = pattern.size();
        constexpr int INV = 1e9;
        vector<int> flag(n);
        for (int i : indices) {
            flag[i] = 1;
        }
        auto memo = vector(n + 1, vector<int>(m + 1, INV));
        for (int i = 0; i <= n; ++i) {
            memo[i][0] = 0;
        }
        int prv, cur;
        for (int j = 0; j < m; ++j) {
            prv = cur = INV;
            for (int i = 0; i < n; ++i) {
                prv = min(prv, memo[i][j]);
                if (prv != INV && source[i] == pattern[j]) {
                    memo[i + 1][j + 1] = cur = min(cur, flag[i] ? prv + 1 : prv);
                }
            }
        }
        return indices.size() - cur;
    }
};",1420039162
Salyu,salyu,272,3604,cpp,"using ll = long long;
constexpr ll base = 1e9 + 7;
inline ll pow_mod(ll a, ll b) {
    ll r = a, t = 1;
    while (b > 1) {
        if (b & 1) {
            t = t * r % base;
        }
        b >>= 1;
        r = r * r % base;
    }
    return r * t % base;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {

        int plim = max(x, n);
        vector<ll> inv(plim + 1);
        inv[1] = 1;
        for (int i = 2; i <= plim; ++i) {
            inv[i] = (base - base / i) * inv[base % i] % base;
        }

        vector<ll> vs(x + 1), cs(x + 1);

        cs[0] = 1;

        for (int i = 1, j = x; i <= x; ++i, --j) {
            cs[i] = cs[i - 1] * j % base * inv[i] % base;
        }

        ll rej = 0, res = 0, xs = 1, ys = 1;
        for (ll t = 1; t <= x; ++t) {
            xs = xs * x % base;
            ll v = pow_mod(t, n);
            ll c = 1;
            for (int i = 1, j = t; i < t; ++i, --j) {
                c = c * j % base * inv[i] % base;
                v = (v - c * vs[i] % base + base) % base;
            }
            vs[t] = v;
            res = (res + cs[t] * v % base * pow_mod(y, t)) % base;
        }
        return res;
    }
};",1420106938
Salyu,salyu,272,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int n : nums) {
            if (n == 2) {
                res.push_back(-1);
            }
            else {
                int i = 0;
                while (i < 32 && (1 << i) & n) {
                    ++i;
                }
                res.push_back(n - (1 << (i - 1)));
            }
        }
        return res;
    }
};",1420006104
Salyu,salyu,272,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int n : nums) {
            if (n == 2) {
                res.push_back(-1);
            }
            else {
                int i = 0;
                while (i < 32 && (1 << i) & n) {
                    ++i;
                }
                res.push_back(n - (1 << (i - 1)));
            }
        }
        return res;
    }
};",1420005816
Sai nadh,sainadhsn,273,3487,cpp,"class Solution {
public:
    vector<int> ok;
    vector<vector<int>> dp;
    int fun(int i, int j, string &s, string &t){
        int n = s.size(), m = t.size();
        if(i == n){
            if(j == m) return 0;
            else return -1;
        }
        if(dp[i][j] != -2) return dp[i][j];
        bool r = 0;
        if(j<m and t[j] == s[i]) r = 1;
        int ans = fun(i+1, j + r, s, t);
        if(ok[i]){
            int cc = 1 + fun(i+1, j, s, t);
            if(cc == 0) cc = -1;
            ans = max(cc, ans);
        }
        return dp[i][j] = ans;
    }
    int maxRemovals(string s, string t, vector<int>& ind) {
        int n = s.size(), m = t.size();
        ok.resize(n+1, 0);
        dp = vector<vector<int>>(n, vector<int>(m+1, -2));
        for(auto i: ind) ok[i] = 1;
        int ans = fun(0, 0, s, t);
        if(ans == -1) ans = 0;
        return ans;
    }
};",1420030212
Sai nadh,sainadhsn,273,3604,cpp,"const int M = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int ncr[1001][1001];
        ncr[1][1] = ncr[1][0] = 1;
        ncr[0][0] = 1;
        for(int i=2; i<=1000; i++){
            for(int j=0; j<=i; j++){
                if(j == 0 or j == i) ncr[i][j] = 1;
                else ncr[i][j] = (ncr[i-1][j] + ncr[i-1][j-1])%M;
            }
        }
        int S[1001][1001];
        memset(S, 0, sizeof(S));
        S[0][0] = 1;
        for (int i = 1; i <= 1000; ++i) {
            S[i][0] = 0;
        }
        for (int j = 1; j <= 1000; ++j) {
            S[0][j] = 0;
        }
        for (int i = 1; i <= 1000; ++i) {
            for (int j = 1; j <= 1000; ++j) {
                S[i][j] = (j *1ll* S[i - 1][j] + S[i - 1][j - 1])%M;
            }
        }

        int yk[x+1];
        for(int i=0; i<=x; i++){
            if(i == 0) yk[i] = 1;
            else {
                yk[i] = (y*1ll*yk[i-1])%M;
            }
        }
        int ans = 0;
        int fact[1001];
        fact[0] = 1;
        for(int i=1; i<=1000; i++){
            fact[i] = (fact[i-1]*1ll*i)%M;
        }
        for(int k=1; k<=x; k++){
            int temp = (S[n][k]*1ll*fact[k])%M;
            temp = (temp*1ll*ncr[x][k])%M;
            if(k>x or k>n) temp = 0;
            temp = (temp*1ll*yk[k])%M;
            ans = (ans + temp)%M;
        }
        return ans;
    }
};",1420113479
Sai nadh,sainadhsn,273,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto &x: nums){
            int y = -1;
            for(int i=1; i<=x; i++){
                if((i|(i+1)) == x){
                    y = i;break;
                }
            }
            ans.push_back(y);
        }
        return ans;
    }
};",1419996505
Sai nadh,sainadhsn,273,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x: nums){
            if(x == 2)ans.push_back(-1);
            else{
                int j = 0;
                for(int k = 0; j<31; k++){
                    if(x>>k&1)j=k;
                    else break;
                }
                ans.push_back(x - (1<<j));
            }
        }
        return ans;
    }
};",1420004876
Ankit Pandey,Laid-back,274,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> dp(pattern.size()+1, INT_MAX);
        dp[0]=0;
        vector<int> target(source.size(), 0);
        for(auto &it: targetIndices) target[it]=1;
        for(int i=0; i<source.size(); i++)
            for(int j=pattern.size(); j>0; j--)
                if(source[i]==pattern[j-1] && dp[j-1]!=INT_MAX)
                    dp[j]=min(dp[j], dp[j-1]+target[i]);
        return targetIndices.size()-(dp[pattern.size()]==INT_MAX?0:dp[pattern.size()]);
    }
};",1420060672
Ankit Pandey,Laid-back,274,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int MOD=1e9+7;
        vector<vector<long long>> dp(x+1, vector<long long> (x+1, 0));
        for(int i=0; i<=x; i++){
            dp[i][0]=1;
            for(int j=1; j<=i; j++)
                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%MOD;
        } vector<vector<long long>> dp2(n+1, vector<long long> (x+1, 0));
        dp2[0][0]=1;
        for(int i=1; i<=n; i++)
            for(int j=1; j<=x; j++)
                dp2[i][j]=((j*dp2[i-1][j])%MOD+dp2[i-1][j-1])%MOD;
        vector<long long> fact(x+1, 1);
        for(int i=1; i<=x; i++)
            fact[i]=(1LL*fact[i-1]*i)%MOD;
        long long ans=0;
        for (int i=1; i<=x; i++){
            long long power=1;
            for(int j=0; j<i; j++)
                power=(power*y)%MOD;
            long long val=(((1LL*dp[x][i]*dp2[n][i])%MOD)*((1LL*fact[i]*power)%MOD))%MOD;
            ans=(ans+val)%MOD;
        } return (int)ans;
    }
};",1420107035
Ankit Pandey,Laid-back,274,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(nums.size(), -1);
        for(int i=0; i<nums.size(); i++){
            for(int j=1; j<=nums[i]; j++){
                if((j|(j+1))==nums[i])
                    {ans[i]=j; break;}
            }
        } return ans;
    }
};",1420002060
Ankit Pandey,Laid-back,274,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for(int i=0; i<nums.size(); i++){
            if(nums[i]!=2){
                int idx=0;
                for(int j=0; j<32; j++){
                    if(nums[i]&(1<<j)) idx=j;
                    else break;
                } ans[i]=nums[i]-(1<<idx);
            }
        } return ans;
    }
};",1420073295
ABHAY GUPTA,abhayg_07,275,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int p = pattern.size();
        int dp[n+1][p+1];
        const int inf = -1000000;
        for( int i = 0 ; i < n+1 ; i++ ){
            for( int j = 0 ; j < p+1 ; j++ ){
                dp[i][j] = inf; 
            }
            dp[i][0] = 0;
        }
        int ptr = 0;
        int m = targetIndices.size();

        for( int i = 1 ; i <= n ; i++ ){
            if( ptr < m && targetIndices[ptr] == i-1 ){
                dp[i][0] = dp[i-1][0] + 1;
            }
            else dp[i][0] = dp[i-1][0];
            for( int l = 1 ; l <= p ; l++ ){
                dp[i][l] = dp[i-1][l];
                if( source[i-1] == pattern[l-1] ){
                    dp[i][l] = max( dp[i][l] , dp[i-1][l-1] );
                }
                if( ptr < m && targetIndices[ptr] == i-1 ){
                    dp[i][l] = max( dp[i][l] , dp[i-1][l] + 1 );
                }
            }
            if( ptr < m && targetIndices[ptr] == i-1 ) ptr++;
        }
        // for( int i = 1 ; i <= n ; i++ ){
        //     for( int j = 1 ; j <= p ; j++ ){
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout << endl;
        // }
        return max(0,dp[n][p]);
    }
};",1420045863
ABHAY GUPTA,abhayg_07,275,3604,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    vector<long long> fact , ifact;

    long long expo(long long a, long long b, long long m)
    {
        long long res = 1;
        while (b > 0)
        {
            if (b & 1)
                res = (res * a) % m;
            a = (a * a) % m;
            b = b >> 1;
        }
        return res % m;
    }

    long long modinv(long long a, long long m) { return expo(a, m - 2, m) % m; } // m is prime


    void init(long long  n){
        fact.resize(n);
        ifact.resize(n);
        fact[0]=1;
        for( int i = 1 ; i < n ; i++ ) fact[i]=(fact[i-1]%mod*i)%mod;
        ifact[n-1]=modinv(fact[n-1],mod)%mod;
        for(int i=n-2 ; i>=1 ; i--){
            ifact[i]=(ifact[i+1]%mod*(i+1))%mod;
        }
        ifact[0]=1;
    }

    long long  ncr(long long n , long long r){
        if(r>n) return 0;
        return (fact[n]*(ifact[r]%mod*ifact[n-r]%mod)%mod)%mod;
    }

    int numberOfWays(int n, int x, int y) {
        init(1001);

        vector<long long> z(x+1);
        z[1] = 1;

        long long ans = 0;

        ans = ( ncr(x,1)%mod * y%mod )%mod;

        for( int i = 2 ; i <= x ; i++ ){
            long long cnt = expo(i,n,mod)%mod;
            for( int j = 1 ; j < i ; j++ ){
                cnt = ( cnt%mod - ( ncr(i,j)%mod * z[j]%mod )%mod + mod )%mod;
            }
            z[i] = cnt;
            long long V = ( ncr(x,i)%mod * z[i]%mod )%mod;
            V = ( V%mod * expo(y,i,mod)%mod )%mod;
            ans = ( ans%mod + V%mod )%mod;
        }
        return ans;
    }
};",1420100681
ABHAY GUPTA,abhayg_07,275,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for( int i = 0 ; i < n ; i++ ){
            for( int j = 1 ; j < nums[i] ; j++ ){
                if( (j|(j+1)) == nums[i] ){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419994654
ABHAY GUPTA,abhayg_07,275,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for( int i = 0 ; i < n ; i++ ){
            if( nums[i] == 2 ) continue;
            ans[i] = nums[i];
            long long x = nums[i];
            for( int j = 0 ; j < 40 ; j++ ){
                if( (x>>j&1) == 1 && (x>>(j+1)&1) == 0 ){
                    x -= (1<<j);
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};",1420001580
Shidong Zhang,dongdozizi,276,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n=s.size(),m=t.size();
        vector<bool> hav(n+1,0);
        for(int i=0;i<a.size();i++){
            hav[a[i]+1]=1;
        }
        vector<vector<int>> dp(n+1,vector<int>(m+1,100000000));
        for(int i=0;i<=n;i++){
            dp[i][0]=0;
        }
        for(int i=1;i<=n;i++){
            char sc=s[i-1];
            for(int j=1;j<=m;j++){
                char tc=t[j-1];
                if(hav[i]){
                    if(sc==tc){
                        dp[i][j]=min(dp[i-1][j],dp[i-1][j-1]+1);
                    }
                    else{
                        dp[i][j]=dp[i-1][j];
                    }
                }
                else{
                    if(sc==tc){
                        dp[i][j]=dp[i-1][j-1];
                    }
                    else{
                        dp[i][j]=dp[i-1][j];
                    }
                }
            }
        }
        // for(int i=0;i<=n;i++){
        //     for(int j=0;j<=m;j++){
        //         cout<<dp[i][j]<<"" "";
        //     }cout<<""\n"";
        // }
        return a.size()-dp[n][m];
    }
};",1420040197
Shidong Zhang,dongdozizi,276,3604,cpp,"class Solution {
public:
    typedef long long ll;
    ll mod=1e9+7;
    ll yw[1003]={0};
    ll fen[1003]={0};
    ll njie[2003]={0},ninv[2003]={0};
    ll qpow(ll a,ll b,ll mod){
        if(b==0) return 1;
        ll c=qpow(a,b/2,mod);
        if(b%2==0) return c*c%mod;
        else return c*c%mod*a%mod;
    }
    ll cnm(ll n,ll m){
        return njie[n]*ninv[m]%mod*ninv[n-m]%mod;
    }
    /*
    dp i,j,k=i find j form k
    dp[i][j][k]=dp[i][j-1][k]*k
    */
    ll numberOfWays(ll n, ll x, ll y) {
        yw[0]=1;
        for(int i=1;i<=1001;i++){
            yw[i]=yw[i-1]*y%mod;
        }
        njie[0]=1;
        for(int i=1;i<=2000;i++){
            njie[i]=njie[i-1]*i%mod;
        }
        for(int i=0;i<=2000;i++){
            ninv[i]=qpow(njie[i],mod-2,mod);
        }

        vector<vector<int>> dp(max(n,x)+1,vector<int>(max(x,n)+1,0));
        for(int i=0;i<=n;i++){
            dp[i][0]=0;
            dp[i][1]=1;
        }
        for(int i=0;i<=x;i++){
            dp[0][i]=0;
            dp[i][i]=1;
        }
        for(ll i=2;i<=n;i++){
            for(ll j=2;j<=x;j++){
                dp[i][j]=(dp[i-1][j-1]+j*dp[i-1][j])%mod;
            }
        }
        
        for(ll i=1;i<=x;i++){
            //cout<<dp[n][i]<<"" ""<<cnm(x,i)<<"" ""<<yw[i]<<""\n"";
            fen[i]=cnm(x,i)*njie[i]%mod*dp[n][i]%mod;
        }

        ll ans=0;
        for(int i=1;i<=x;i++){
            ans=(ans+fen[i]*yw[i])%mod;
        }
        return ans;
    }
};
/*
3*4+
*/",1420113852
Shidong Zhang,dongdozizi,276,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ret;
        for(int i=0;i<a.size();i++){
            bool fd=0;
            for(int j=-2;j<=3000;j++){
                if((j|(j+1))==a[i]){
                    ret.push_back(j);
                    fd=1;
                    break;
                }
            }
            if(!fd) ret.push_back(-1);
        }
        return ret;
    }
};",1419998264
Shidong Zhang,dongdozizi,276,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ret;
        for(int i=0;i<a.size();i++){
            if(a[i]==2) ret.push_back(-1);
            else{
                int lb=a[i]+1;
                lb=lb&(-lb);
               // cout<<lb<<"" - "";
                int tmp=a[i]-lb+1;
               // cout<<tmp<<"" - "";
                tmp=tmp+lb/2-1;
                //cout<<tmp<<"" "";
                ret.push_back(tmp);

            }
        }
        return ret;
    }
};
/*
101

1111111
0111111
1000001
1000000
1011111
1001111
1010000
*/",1420018062
raj,Ranjan_22,277,3487,cpp,"#include <vector>
#include <string>
#include <climits>  // For INT_MAX
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int sourceLength = source.size();
        int patternLength = pattern.size();
        
        // dp array to store minimum removals
        vector<int> minRemovals(patternLength + 1, INT_MAX);
        minRemovals[0] = 0;

        // isTarget array to mark target indices
        vector<bool> isRemovalTarget(sourceLength, false);
        for (int index : targetIndices) {
            isRemovalTarget[index] = true;
        }

        // Lambda function to update the dp array
        auto updateMinRemovals = [&](int sourceIdx, int patternIdx) {
            if (source[sourceIdx] == pattern[patternIdx - 1] && minRemovals[patternIdx - 1] != INT_MAX) {
                minRemovals[patternIdx] = min(minRemovals[patternIdx], minRemovals[patternIdx - 1] + (isRemovalTarget[sourceIdx] ? 1 : 0));
            }
        };

        // Traverse through the original string
        for (int sourceIdx = 0; sourceIdx < sourceLength; sourceIdx++) {
            // Traverse through the pattern string in reverse order
            for (int patternIdx = patternLength; patternIdx > 0; patternIdx--) {
                updateMinRemovals(sourceIdx, patternIdx);
            }
        }

        return targetIndices.size() - (minRemovals[patternLength] == INT_MAX ? 0 : minRemovals[patternLength]);
    }
};
",1420064956
raj,Ranjan_22,277,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        // Lambda function to compute combinations
        auto computeCombination = [&](int size) {
            std::vector<std::vector<int>> combination(size + 1, std::vector<int>(size + 1, 0));
            for (int outerIdx = 0; outerIdx <= size; ++outerIdx) {
                combination[outerIdx][0] = 1;
                for (int innerIdx = 1; innerIdx <= outerIdx; ++innerIdx) {
                    combination[outerIdx][innerIdx] = (combination[outerIdx - 1][innerIdx - 1] + combination[outerIdx - 1][innerIdx]) % MOD;
                }
            }
            return combination;
        };

        // Lambda function to compute Stirling numbers
        auto computeStirlingNumbers = [&](int nSize, int xSize) {
            std::vector<std::vector<int>> stirlingNumbers(nSize + 1, std::vector<int>(xSize + 1, 0));
            stirlingNumbers[0][0] = 1;
            for (int outerIdx = 1; outerIdx <= nSize; ++outerIdx) {
                for (int innerIdx = 1; innerIdx <= xSize; ++innerIdx) {
                    stirlingNumbers[outerIdx][innerIdx] = (1LL * innerIdx * stirlingNumbers[outerIdx - 1][innerIdx] + stirlingNumbers[outerIdx - 1][innerIdx - 1]) % MOD;
                }
            }
            return stirlingNumbers;
        };

        // Lambda function to compute factorials
        auto computeFactorials = [&](int size) {
            std::vector<int> factorialArray(size + 1, 1);
            for (int factorialIdx = 1; factorialIdx <= size; ++factorialIdx) {
                factorialArray[factorialIdx] = (1LL * factorialArray[factorialIdx - 1] * factorialIdx) % MOD;
            }
            return factorialArray;
        };

        // Compute the combination, Stirling numbers, and factorials
        auto combination = computeCombination(x);
        auto stirlingNumbers = computeStirlingNumbers(n, x);
        auto factorialArray = computeFactorials(x);

        // Calculate total number of ways
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPower = 1;
            for (int powerIdx = 0; powerIdx < k; ++powerIdx) {
                yPower = (yPower * y) % MOD;
            }
            totalWays = (totalWays + (1LL * combination[x][k] * stirlingNumbers[n][k] % MOD * factorialArray[k] % MOD * yPower % MOD)) % MOD;
        }
        return totalWays;
    }
};
",1420107781
raj,Ranjan_22,277,3605,cpp,"#include <vector>
#include <functional>
using namespace std;

class Solution {
public:
      vector<int> minBitwiseArray(vector<int>& nums){
        int arraySize = nums.size();
        vector<int> resultArray(arraySize, -1);  // Initialize resultArray with -1
        
        // Lambda function to find the minimum bitwise number for a given target
        auto computeMinBitwise = [](int target) -> int {
            for (int candidate = 0; candidate <= target; candidate++) {
                if ((candidate | (candidate + 1)) == target) {
                    return candidate;
                }
            }
            return -1;  // Return -1 if no valid candidate is found (shouldn't happen for valid input)
        };
        
        // Iterate over each number in the inputArray
        for (int index = 0; index < arraySize; index++) {
            resultArray[index] = computeMinBitwise(nums[index]);
        }
        
        return resultArray;
    }
};
",1420013010
raj,Ranjan_22,277,3611,cpp,"#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int arraySize = nums.size();
        vector<int> resultArray(arraySize, -1);  // Initialize resultArray with -1
        
        // Lambda function to calculate the minimum candidate for each number
        auto findMinCandidate = [](int currentNum) -> int {
            int minCandidate = INT_MAX;
            bool candidateFound = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (((currentNum >> bitPosition) & 1) == 1) {
                    // Unset the current bit
                    int candidate = currentNum & ~(1 << bitPosition);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals currentNum
                    if ((candidate | (candidate + 1)) == currentNum) {
                        if (candidate < minCandidate) {
                            minCandidate = candidate;
                            candidateFound = true;
                        }
                    }
                }
            }
            return candidateFound ? minCandidate : -1;
        };
        
        // Iterate over each number in the inputArray and apply the lambda function
        for (int index = 0; index < arraySize; index++) {
            resultArray[index] = findMinCandidate(nums[index]);
        }
        
        return resultArray;
    }
};
",1420047192
Paramish,Paramish,278,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int c=0;
        c++;
        int k=0;
        k--;

        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        unordered_map<int,int>mp;
        for (int idx : targetIndices) {
            c++;
            if(c>=1 && k<=0)
            isTarget[idx] = true;
            mp[idx]=c;
        }
        
        for (int i = 0; i < n; i++) {
            c++;k--;
            if(c){
            for (int j = m; j > 0; j--) {
                if(!c) c++; 
                else if (c>=1 && source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                    c++;
                    mp[j]--;
                }
            }
            }
            else c++;
        }
        c++;
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420064411
Paramish,Paramish,278,3604,cpp,"const int MOD = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> C(x + 1, vector<int>(x + 1, 0));
        int k=0;
        k++;
        int l=0;
        l--;
        for (int i = 0; i <= x; ++i) {
            if(k>=1 && l<=0)
            C[i][0] = 1;
            
            for (int j = 1; j <= i; ++j) {
                if(l<=0)
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
                else k++;
                l--;
            }
        }

        vector<vector<int>> S(n + 1, vector<int>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            k++;
            l--;
            for (int j = 1; j <= x; ++j) {
                if(k>=1 && l<=0)
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            k++;l--;
            if(k>=0 && l<=0)
            fact[i] = 1LL * fact[i - 1] * i % MOD;
            else l--;
        }

        int result = 0;
        l--;
       
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            if(l<=0){
            for (int p = 0; p < k; ++p) {
                if(l<=0)
                power = (power * y) % MOD;
                else l--;
            }
            }
            else l--;
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};
",1420094720
Paramish,Paramish,278,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        int c=0;
        c++;
        for (int i = 0; i < n; i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if (c>=1 && (x | (x + 1)) == nums[i]) {
                    c++;
                    if(c)
                    ans[i] = x;
                    break;
                }
                c++;
            }
        }
        
        return ans;
    }
};",1420014996
Paramish,Paramish,278,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
         int c=0;
         c++;
         int k=0;
         k--;
        for (int i = 0; i < n; i++) {
            if(c>=1) c++;
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            c++;
             
            for (int bit = 0; bit <= 30; bit++) {
                if (k<=0 && c>=1 && ((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (c && candidate < minimalAns) {
                            if(c>=1 && k<=0)
                            minimalAns = candidate;
                            else c++;
                            found = true;
                        }
                    }
                }
            }

            if (c>=1 && found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
            if(!c) c++;
            else c+=2;
        }

        return ans;
    }
};
",1420050891
Harsh kriplani,Harshkriplani,279,3487,cpp,"string a,b;
    vector<int>h;
    int n;
    int dp[3001][3001];
class Solution {
public:
    
    int make(int i,int j)
    {
        if(i==a.size())
        {
            if(j==b.size())
                return 0;
            return -1e9;
        }
        if(dp[i][j]==-1)
        {
            if(h[i]==1)
            {
                int ans=1+make(i+1,j);
                if(j!=b.size())
                {
                if(a[i]==b[j])
                {
                    ans=max(ans,make(i+1,j+1));
                    
                }
                else
                {
                    ans=max(ans,make(i+1,j));
                }
                }
                dp[i][j]=ans;
                
                
            }
            else
            {
                if(j!=b.size())
                {
                if(a[i]==b[j])
                {
                    dp[i][j]=make(i+1,j+1);
                    
                }
                else
                {
                    dp[i][j]=make(i+1,j);
                }
                }
                else
                {
                    dp[i][j]=make(i+1,j);
                    
                }
                
                
            }

        }
                    return dp[i][j];
    }
    int maxRemovals(string source, string pattern, vector<int>& in) {
        a=source;
        b=pattern;
        h=vector<int>(a.size()+1,0);
        for(int i=0;i<in.size();i++)
        {
            h[in[i]]=1;
        }
        for(int i=0;i<=a.size();i++)
        {
            for(int j=0;j<=a.size();j++)
            {
                dp[i][j]=-1;
            }
        }
        return make(0,0);
        
    }
};",1420029517
Harsh kriplani,Harshkriplani,279,3604,cpp,"
vector<vector<long long>> dp(1001 + 1, vector<long long>(1001 + 1, 0));
vector<long long> factorial(1001 + 1, 1);  // To store factorials modulo MOD

#define ll long long
ll facts[3002];
ll invfacts[3002];
const ll N_ = 2001;
class Solution {
public:
    const int MOD = 1e9 + 7;
    const int mod = 1e9 + 7;
const int MAX_N = 1001;  // Set a limit for n and m (you can increase if needed)


// Precompute Stirling numbers and factorials
void precompute() {
    // Base cases
    for (int i = 0; i <= MAX_N; ++i) {
        dp[i][i] = 1;        // Exactly i balls in i boxes (1 way)
        dp[i][0] = 0;        // 0 boxes can't have any balls
    }

    // Precompute factorials modulo MOD
    for (long long i = 2; i <= MAX_N; ++i) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }

    // Fill the DP table using the recurrence relation: S(n, m) = S(n-1, m-1) + m * S(n-1, m) (mod MOD)
    for (long long n = 2; n <= MAX_N; ++n) {
        for (long long m = 1; m < n; ++m) {
            dp[n][m] = (dp[n - 1][m - 1] + (m * dp[n - 1][m]) % MOD) % MOD;
        }
    }
}

// Function to return the number of ways for a specific n and m
long long numberOfWays1(int n, int m) {
    if (m > n) return 0; // Impossible to put n balls in more than n boxes
    return (factorial[m] * dp[n][m]) % MOD;
}
    
    
    
    ll mul(ll a, ll b) {
	return ((a % mod) * (b % mod)) % mod;
}

ll add(ll a, ll b) {
	return (a % mod + b % mod) % mod;
}
ll sub(ll a, ll b)
{
	return (mod + a % mod - b % mod) % mod;
}

ll expo(ll base, ll pow) {
	if (pow == 0) return 1;
	ll half = expo(base, pow / 2);
	if (pow % 2 == 0) return mul(half, half);
	return mul(half, mul(half, base));
}
ll divi(ll a, ll b)
{
	return mul(a, expo(b, mod - 2));
}
void makef() {
	facts[0] = 1;
	for (ll i = 1; i < N_ - 1; i++)
		facts[i] = mul(facts[i - 1], i);

	invfacts[N_ - 2] = divi(1ll, facts[N_ - 2]);
	for (ll i = N_ - 3; i >= 0; i--)
		invfacts[i] = mul(invfacts[i + 1], i + 1);
}
    ll nCk(ll n, ll k) {
	if (n < k)
		return 0;
	if (n == k)
		return 1;
	return mul(facts[n], mul(invfacts[k], invfacts[n - k]));
}

    int numberOfWays(int n, int x, int y) {
        precompute();
        long long ans=0;
       
        makef();
        
        for(int i=1;i<=min(n,x);i++)
        {
           // cout<<numberOfWays1(n, i)<<endl;
            long long stagesway=mul(nCk(x,i),numberOfWays1(n, i));
           // cout<<stagesway<<endl;
            ans=add(ans,mul(stagesway,expo(y,i)));
            
            
            
        }
        return ans;
        
    }
};",1420094953
Harsh kriplani,Harshkriplani,279,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int>ans;
        for(int i=0;i<a.size();i++)
        {
            int ma=0;
            if(a[i]&1)
            {
               for(int j=0;j<=30;j++)
               {
                   if(a[i]&(1<<j))
                   {
                       ma=j;
                   }
                   else
                   {
                       break;
                   }
               }
                ans.push_back(a[i]-(1<<ma));
            }
            else
                ans.push_back(-1);
        }
        return ans;
        
    }
};",1420006731
Harsh kriplani,Harshkriplani,279,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
         vector<int>ans;
        for(int i=0;i<a.size();i++)
        {
            int ma=0;
            if(a[i]&1)
            {
               for(int j=0;j<=30;j++)
               {
                   if(a[i]&(1<<j))
                   {
                       ma=j;
                   }
                   else
                   {
                       break;
                   }
               }
                ans.push_back(a[i]-(1<<ma));
            }
            else
                ans.push_back(-1);
        }
        return ans;
        
    }
};",1420007388
chh9976,chh9976,280,3487,cpp,"
#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))

const ints2 _8dirs[8] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
const ints2 _4dirs[4] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; 

template<typename U, std::size_t T> array<U, T> operator+(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) result[i] = arr1[i] + arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator-(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) result[i] = arr1[i] - arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator*(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) result[i] = arr1[i] * arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator/(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) assert(arr2[i] != 0), result[i] = arr1[i] / arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator+=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) arr1[i] += arr2[i]; return arr1;}
template<typename U, std::size_t T> array<U, T> operator-=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) arr1[i] -= arr2[i]; return arr1;}
template<typename U, std::size_t T> array<U, T> operator*=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) arr1[i] *= arr2[i]; return arr1;}
template<typename U, std::size_t T> array<U, T> operator/=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) assert(arr2[i] != 0), arr1[i] /= arr2[i]; return arr1;}
template<typename U, std::size_t T> ostream& operator<<(ostream& a, array<U, T>& arr){if(T == 0) {a<<""{}""; return a;} a<<""{""<<arr[0]; for(int i=1;i<T;i++) a<<"", ""<<arr[i]; a<<""}""; return a;}

template<typename T> void print(vector<T>& c, int a=-1, int b=-1){if(a == -1) a = 0; if(b == -1) b = c.size(); for(int i=a;i<b;i++) cout<<c[i]<<"" \n""[i==b-1];}
template<typename T> void print(T t, char c='\n'){cout<<t<<c;}
template<typename T> void print(T* a, T* b){while(a < b) print(*a, ' '), a++; cout<<endl;}
template<typename T> void print(T* a, int b, int c){for(int i=b;i<c;i++) cout<<a[i]<<"" ""; cout<<endl;}
template<typename T> void printmat(vc<vc<T>> a){trav(a) print(a);}
template<typename T> ostream& operator<<(ostream& a, vector<T>& arr){for(int i=0;i<arr.size();i++) a<<arr[i]<<"" ""; return a;}
ostream& operator<<(ostream& a, __int128 out){if(out < 0) {a<<""-""; a << -out;} else {if(out > 9) a<<out/10; a<< int(out%10);} return a;}


int strcmp(string& a, string& b, int& ia, int& ib){auto res = memcmp(&a[ia], &b[ib], min(a.size()-ia, b.size()-ib));if(res != 0) return res;return (a.size() - ia > b.size() - ib) - (b.size() - ib > a.size() - ia);}
template<typename U, std::size_t T> ll get(array<U, T>& a, ll u){ll x=0; for(int i=0;i<T;i++) x *= u, x += a[i]; return x;}
template<typename T> void gmin(T& a, T b){a = min(a, b);}
template<typename T> void gmax(T& a, T b){a = max(a, b);}
mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<ll> rnd(0,LLONG_MAX); //usage: long long xx = rnd(gen);
template<int k> array<int, k> getints(){array<int, k> res; rep(i, 0, k) cin>>res[i]; return res;} 
template<int k> array<ll, k> getlls(){array<ll, k> res; rep(i, 0, k) cin>>res[i]; return res;}
template<typename T, std::size_t N> istream& operator>>(istream& a, array<T, N>& in){rep(i, 0, N) a>>in[i]; return a;}
template<typename T> istream& operator>>(istream& a, vector<T>& in){for(auto& gin:in) a>>gin; return a;}
ll triangle(ll up, ll down, ll step){assert((up-down) % step == 0); if(up > down) return 0; return (up+down) * ((down - up) / step + 1) / 2;}
vc<int> getints(int n){vc<int> res(n); trav(res) cin>>res; return res;}
vc<ll> getlls(int n){vc<ll> res(n); trav(res) cin>>res; return res;}
ll getint(){ll a; cin>>a; return a;}
ll pow(ll a, ll b){ll res = 1; while(b){if(b&1) res *= a; a *= a; b>>=1;} return res;}
ll pow(int a, int b){ll res = 1; while(b){if(b&1) res *= a; a *= a; b>>=1;} return res;}
void YES(){print(""Yes"");}
void NO(){print(""No"");}
#define ee9 1000000000
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& ti) {
        int n = source.size(), m = pattern.size();
        set<int> s(all(ti));
        vc dp(n+1, vc<int>(m+1, -ee9));
        dp[0][0] = 0;
        rep(i, 0, n){
            int check = s.count(i);
            rep(j, 0, m) if(dp[i][j] >= 0) {
                if(source[i] == pattern[j]){
                    dp[i+1][j+1] = max(dp[i][j], dp[i+1][j+1]);
                }
            }
            rep(j, 0, m + 1) if(dp[i][j] >= 0) {
                if(check) dp[i+1][j] = max(dp[i+1][j], dp[i][j] + 1);
                else dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            }
        }
        return dp[n][m];
    }
};",1420029766
chh9976,chh9976,280,3604,cpp,"
#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;

vc<mint17> fact;
vc<mint17> ifact;
vc<mint17> py(1001);
mint17 dp[1001][1001];
int havedp[1001][1001];
class Solution {
public:
    Solution(){
        if(fact.size() == 0){
            fact.pb(mint17(1));
            ifact.pb(mint17(1));
            rep(i, 1, 1001) fact.pb(fact.back() * i), ifact.pb(ifact.back() / i);
        }
    }
    mint17 nw(int n, int x, int y, int nowsize) {
        if(havedp[n][nowsize]) return dp[n][nowsize];
        mint17 ans = 0;
        if(n == 0) {
            dp[n][nowsize] = py[nowsize] * fact[x] * ifact[x - nowsize];
            havedp[n][nowsize] = 1;
            return dp[n][nowsize];
        }
            
        if(nowsize == x) ans += nw(n-1, x, y, x) * x;
        else ans += nw(n-1, x, y, nowsize) * nowsize + nw(n-1, x, y, nowsize+1);
        dp[n][nowsize] = ans;
        havedp[n][nowsize] = 1;
        return ans;
    }
    int numberOfWays(int n, int x, int y, int nowsize = 0){
        py[0] = 1; rep(i, 1, x+1) py[i] = py[i-1] * y; rep(i, 0, max(n, nowsize) + 1) rep(j, 0, max(n, nowsize) + 1) havedp[i][j] = 0;
        return nw(n, x, y, 0).get();
    }
};",1420074232
chh9976,chh9976,280,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            if n == 2:
                res.append(-1)
                continue
            g = list(bin(n)[2:])[::-1]
            try:
                ind = g.index('0')
                g[ind-1] = '0'
            except Exception as e:
                g.pop()
            g = int(''.join(reversed(g)), 2)
            res.append(g)
        return res
                
            
                    
                
        ",1420008637
chh9976,chh9976,280,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            if n == 2:
                res.append(-1)
                continue
            g = list(bin(n)[2:])[::-1]
            try:
                ind = g.index('0')
                g[ind-1] = '0'
            except Exception as e:
                g.pop()
            g = int(''.join(reversed(g)), 2)
            res.append(g)
        return res
                
            ",1420008349
Zaheer Khan,oyezaheer,281,3487,golang,"package main

import (
	""fmt""
	""math""
)

// Function to find the maximum number of removals such that pattern is still a subsequence
func maxRemovals(source string, pattern string, targetIndices []int) int {
	n := len(source)
	m := len(pattern)

	// Initialize the dp array with infinity values
	dp := make([]int, m+1)
	for i := range dp {
		dp[i] = math.MaxInt32
	}
	dp[0] = 0

	// Initialize the isTarget array
	isTarget := make([]bool, n)
	for _, idx := range targetIndices {
		isTarget[idx] = true
	}

	// Dynamic Programming to check the number of possible removals
	for i := 0; i < n; i++ {
		for j := m; j > 0; j-- {
			if source[i] == pattern[j-1] && dp[j-1] != math.MaxInt32 {
				if isTarget[i] {
					dp[j] = min(dp[j], dp[j-1]+1)
				} else {
					dp[j] = min(dp[j], dp[j-1])
				}
			}
		}
	}

	if dp[m] == math.MaxInt32 {
		return 0
	}
	return len(targetIndices) - dp[m]
}

// Utility function to find the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}",1420067353
Zaheer Khan,oyezaheer,281,3604,golang,"package main

import ""fmt""

const MOD = 1000000007

func numberOfWays(n int, x int, y int) int {
    // Calculate combination (nCr)
    comb := make([][]int, x+1)
    for i := range comb {
        comb[i] = make([]int, x+1)
    }

    for i := 0; i <= x; i++ {
        comb[i][0] = 1
        for j := 1; j <= i; j++ {
            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
        }
    }

    // Calculate Stirling numbers of the second kind
    stirling := make([][]int, n+1)
    for i := range stirling {
        stirling[i] = make([]int, x+1)
    }
    stirling[0][0] = 1

    for i := 1; i <= n; i++ {
        for j := 1; j <= x; j++ {
            stirling[i][j] = (j*stirling[i-1][j] + stirling[i-1][j-1]) % MOD
        }
    }

    // Calculate factorials
    factorial := make([]int, x+1)
    factorial[0] = 1
    for i := 1; i <= x; i++ {
        factorial[i] = (factorial[i-1] * i) % MOD
    }

    // Calculate total ways
    totalWays := 0
    for k := 1; k <= x; k++ {
        yPow := 1
        for i := 0; i < k; i++ {
            yPow = (yPow * y) % MOD
        }

        totalWays = (totalWays + (comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD)) % MOD
    }

    return totalWays
}",1420102394
Zaheer Khan,oyezaheer,281,3605,golang,"package main

import (
	""fmt""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	ans := make([]int, n)

	// Iterate through the nums slice
	for i := 0; i < n; i++ {
		num := nums[i]
		found := false

		// Iterate over possible values of ans[i] starting from 0
		for x := 0; x < num; x++ {
			if (x | (x + 1)) == num {
				ans[i] = x
				found = true
				break
			}
		}

		// If no valid ans[i] found, set -1
		if !found {
			ans[i] = -1
		}
	}

	return ans
}",1420040846
Zaheer Khan,oyezaheer,281,3611,golang,"import (
	""fmt""
	""math""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	ans := make([]int, n)

	for i := 0; i < n; i++ {
		num := nums[i]
		minimalAns := math.MaxInt32
		found := false

		// Iterate through each bit position (0 to 30)
		for bit := 0; bit <= 30; bit++ {
			if (num>>bit)&1 == 1 {
				// Unset the current bit
				candidate := num & ^(1 << bit)

				// Ensure candidate is non-negative
				if candidate < 0 {
					continue
				}

				// Check if candidate OR (candidate + 1) equals num
				if (candidate | (candidate + 1)) == num {
					if candidate < minimalAns {
						minimalAns = candidate
						found = true
					}
				}
			}
		}

		if found {
			ans[i] = minimalAns
		} else {
			ans[i] = -1
		}
	}

	return ans
}",1420047738
vishuut,vishuut,282,3487,cpp,"class Solution {
public:
    // Memoization table to store results of (i, j) states
    vector<vector<int>> dp;

    // Helper recursive function with memoization
    int ans(int i, int j, string &source, string &pattern, set<int> &ind) {
        // If we've matched the entire pattern
        if (j == pattern.size()) {
            // Count how many of the remaining characters in 'source' are in 'ind'
            int remainingRemovals = 0;
            for (int k = i; k < source.size(); k++) {
                if (ind.find(k) != ind.end()) {
                    remainingRemovals++;  // Count indices that can be removed
                }
            }
            return remainingRemovals;  // Return how many characters can be removed
        }

        // If we've exhausted the source string without fully matching the pattern
        if (i >= source.size()) {
            return -1e9;  // Large negative value to indicate invalid state
        }

        // Check if the result for this state is already computed
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int result = 0;

        // Case 1: Current characters of source and pattern match
        if (source[i] == pattern[j]) {
            if (ind.find(i) == ind.end()) {
                // If this index is not removed, proceed normally
                result = ans(i + 1, j + 1, source, pattern, ind);
            } else {
                // Max of skipping this character or matching it
                result = max(1 + ans(i + 1, j, source, pattern, ind), 
                             ans(i + 1, j + 1, source, pattern, ind));
            }
        } else {
            // Case 2: Characters do not match
            if (ind.find(i) != ind.end()) {
                // If the index is marked for removal, increment the count and move forward
                result = 1 + ans(i + 1, j, source, pattern, ind);
            } else {
                // Move forward without removing
                result = ans(i + 1, j, source, pattern, ind);
            }
        }

        // Store result in memoization table
        return dp[i][j] = result;
    }

    int maxRemovals(string source, string pattern, vector<int> &targetIndices) {
        set<int> ind;
        for (auto it : targetIndices) {
            ind.insert(it);
        }

        // Initialize memoization table with size (source.size() x pattern.size()) and -1 as default value
        dp = vector<vector<int>>(source.size() + 1, vector<int>(pattern.size() + 1, -1));

        return ans(0, 0, source, pattern, ind);
    }
};
",1420064634
vishuut,vishuut,282,3604,cpp,"
const int MOD = 1e9 + 7;

// Function to calculate Stirling Numbers of the Second Kind with modulo
vector<vector<long long>> calculateStirlingNumbers(int n) {
    vector<vector<long long>> S(n + 1, vector<long long>(n + 1, 0));
    S[0][0] = 1;  // Base case: S(0, 0) = 1

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            // Use long long to prevent overflow
            S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
        }
    }

    return S;
}

// Function to calculate modular exponentiation: (base^exp) % MOD
long long modPow(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Function to calculate factorial of a number under modulo
long long factorial(int num) {
    long long result = 1;
    for (int i = 2; i <= num; i++) {
        result = (result * i) % MOD;
    }
    return result;
}

// Function to calculate binomial coefficient C(x, k) under modulo
long long binomialCoefficient(int x, int k) {
    if (k > x) return 0;
    long long result = 1;
    for (int i = 0; i < k; i++) {
        result = (result * (x - i)) % MOD;
        result = (result * modPow(i + 1, MOD - 2, MOD)) % MOD;  // Modular inverse of (i+1)
    }
    return result;
}

// Function to calculate total number of ways under modulo
long long countWays(int n, int x, int y) {
    // Step 1: Calculate Stirling numbers S(n, k)
    vector<vector<long long>> stirling = calculateStirlingNumbers(n);

    long long totalWays = 0;

    // Step 2: Iterate over all possible values of k (1 to x)
    for (int k = 1; k <= x; k++) {
        if (k > n) continue;
        
        // S(n, k): Number of ways to partition n people into k groups
        long long stirlingWays = stirling[n][k];

        // C(x, k): Choose k stages from x stages
        long long binomialWays = binomialCoefficient(x, k);

        // k!: Permute k groups across k stages
        long long factorialWays = factorial(k);

        // y^k % MOD: Power of y raised to k under modulo
        long long yPowerWays = modPow(y, k, MOD);

        // Add to total ways
        totalWays = (totalWays + stirlingWays * binomialWays % MOD * factorialWays % MOD * yPowerWays % MOD) % MOD;
    }

    return totalWays;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        return countWays(n, x, y);
    }
};
",1420096282
vishuut,vishuut,282,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto it : nums){
            bool f=0;
            for(int i=1;i<=it;i++){
                if ((i|(i+1)) == it){
                    ans.push_back(i);
                    f=1;
                    break;
                }
            }
            if (f==0 ) ans.push_back(-1);
        }
        return ans;
        
    }
};",1419997086
vishuut,vishuut,282,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
    
        for(auto it : nums){
            if (it==2){
                ans.push_back(-1);
                continue;
            }
            int x=0;
            bool f=0;
            for(int i =0;i<=30;i++){
                if((it & (1 << i)) == 0 && !f){
                    f=1;
                    x =x & ~(1<<(i-1));
                }
                else if ((it&(1<<i))!=0 ){
                    x|=(1<<i);
                }

            }
            ans.push_back(x);

        }
        return ans;
        
    }
    
};

",1420034545
joylintp,joylintp,283,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int N = source.size(), M = pattern.size();
        vector<bool> rmv(N);
        for (int p : targetIndices)
            rmv[p] = true;

        vector<int> chk(N);
        for (int i = 0; i < N; i++)
            chk[i] = upper_bound(targetIndices.begin(), targetIndices.end(), i) - targetIndices.begin();
        vector<vector<int>> dp(N, vector(M, -1));
        for (int j = 0; j < M; j++)
        {
            int ok = -1;
            for (int i = j; i < N; i++)
            {
                if (source[i] == pattern[j])
                    if (i == 0)
                        dp[i][j] = 0;
                    else
                        dp[i][j] = chk[i - 1];
                if (ok != -1 && rmv[i])
                    dp[i][j] = max(dp[i][j], ok + 1);
                ok = max(ok, dp[i][j]);
            }
            chk[0] = dp[0][j];
            for (int i = 1; i < N; i++)
                chk[i] = max(chk[i - 1], dp[i][j]);
        }

        int ret = -1;
        for (int i = 0; i < N; i++)
            ret = max(ret, dp[i][M - 1]);
        return ret;
    }
};",1420109414
joylintp,joylintp,283,3604,cpp,"class Solution {
public:
    const int MOD = 1000000007;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(n + 1, vector(x + 1, 0LL));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= min(x, i); j++)
                dp[i][j] = (dp[i - 1][j] * j + dp[i - 1][j - 1] * (x - j + 1)) % MOD;
        
        long long base = y, ret = 0;
        for (int j = 1; j <= x; j++)
            ret = (ret + dp[n][j] * base) % MOD, base = base * y % MOD;
        return ret;
    }
};",1420064737
joylintp,joylintp,283,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret;
        for (int x : nums)
            if (x == 2)
                ret.push_back(-1);
            else
            {
                int cc = -1, t = x;
                while (x & 1)
                    cc++, x >>= 1;
                ret.push_back(t ^ (1 << cc));
            }
        return ret;
    }
};",1420074567
joylintp,joylintp,283,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret;
        for (int x : nums)
            if (x == 2)
                ret.push_back(-1);
            else
            {
                int cc = -1, t = x;
                while (x & 1)
                    cc++, x >>= 1;
                ret.push_back(t ^ (1 << cc));
            }
        return ret;
    }
};",1420074423
trchen,trchen,285,3487,cpp,"class Solution {
 public:
  int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    int n = source.size();
    int m = pattern.size();
    unordered_set<int> indices;
    for (auto c : targetIndices) {
      indices.insert(c);
    }
    int d = targetIndices.size();
    vector<int> dp(d + 1, -1);
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
      vector<int> next_dp = dp;
      for (int dd = 0; dd <= d; ++dd) {
        if (dp[dd] >= 0 && dp[dd] < m && source[i] == pattern[dp[dd]]) {
          next_dp[dd]++;
        }
      }
      if (indices.find(i) != indices.end()) {
        for (int dd = 1; dd <= d; ++dd) {
          if (dp[dd - 1] >= 0) {
            next_dp[dd] = max(next_dp[dd], dp[dd - 1]);
          }
        }
      }
      swap(dp, next_dp);
    }
    for (int dd = d; dd >= 0; --dd) {
      if (dp[dd] == m) {
        return dd;
      }
    }
    return 0;
  }
};",1420027912
trchen,trchen,285,3604,cpp,"
using ll = long long;

class Solution {
 public:
  ll Power(ll a, int power) {
    if (a == 0) {
      return 0;
    }
    ll ret = 1;
    while (power > 0) {
      if (power % 2 == 1) {
        ret = (ret * a) % MOD;
      }
      a = (a * a) % MOD;
      power /= 2;
    }
    return ret;
  }

  ll Inverse(int a) {
    return Power(a, MOD - 2);
  }

  ll Allocate(ll n, ll x) {
    ll ret = 0;
    for (int i = 0; i <= x; ++i) {
      if (i % 2 == 0) {
        ret += power_to_N[x - i] * choose[x][i];
      } else {
        ret -= power_to_N[x - i] * choose[x][i];
      }
      ret %= MOD;
    }
    return ret;
  }

  int numberOfWays(int N, int X, int Y) {
    factorials.resize(X + 1);
    factorials[0] = 1;
    for (ll i = 1; i <= X; ++i) {
      factorials[i] = (factorials[i - 1] * i) % MOD;
    }
    inverse_factorials.resize(X + 1);
    for (int i = 0; i <= X; ++i) {
      inverse_factorials[i] = Inverse(factorials[i]);
    }
    powerY.resize(X + 1);
    powerY[0] = 1;
    for (int x = 1; x <= X; ++x) {
      powerY[x] = (powerY[x - 1] * Y) % MOD;
    }
    power_to_N.resize(X + 1);
    for (int x = 0; x <= X; ++x) {
      power_to_N[x] = Power(x, N);
    }
    choose = vector<vector<ll>>(X + 1, vector<ll>(X + 1));
    for (int x = 0; x <= X; ++x) {
      for (int y = 0; y <= x; ++y) {
        choose[x][y] =
            (factorials[x] * inverse_factorials[y]) % MOD * inverse_factorials[x - y] % MOD;
      }
    }

    ll ret = 0;
    for (int x = 1; x <= min(X, N); ++x) {
      ret += (choose[X][x] * Allocate(N, x) % MOD) * Power(Y, x) % MOD;
    }
    ret %= MOD;
    if (ret < 0) {
      ret += MOD;
    }
    return ret;
  }

  vector<ll> factorials;
  vector<ll> inverse_factorials;
  vector<ll> powerY;
  vector<ll> power_to_N;
  vector<vector<ll>> choose;

  static inline constexpr ll MOD = 1000000007;
};",1420115985
trchen,trchen,285,3605,cpp,"class Solution {
 public:
  int Min(int a) {
    if (a == 2) {
      return -1;
    }
    for (int i = 0; i < 32; ++i) {
      if ((a & (1 << i)) == 0) {
        return (a ^ (1 << (i - 1)));
      }
    }
    return 0;
  }

  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ret;
    for (auto c : nums) {
      ret.push_back(Min(c));
    }
    return ret;
  }
};",1420038684
trchen,trchen,285,3611,cpp,"class Solution {
 public:
  int Min(int a) {
    if (a == 2) {
      return -1;
    }
    for (int i = 0; i < 32; ++i) {
      if ((a & (1 << i)) == 0) {
        return (a ^ (1 << (i - 1)));
      }
    }
    return 0;
  }

  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ret;
    for (auto c : nums) {
      ret.push_back(Min(c));
    }
    return ret;
  }
};",1420038317
Ayush Mishra,speedcuberayush,288,3487,typescript,"function maxRemovals(source: string, pattern: string, targetIndices: number[]): number {
    const n = source.length;
    const m = pattern.length;
    const dp = new Array(m + 1).fill(Infinity);
    dp[0] = 0;
    const isTarget = new Array(n).fill(false);
    
    for (const idx of targetIndices) {
        isTarget[idx] = true;
    }

    let i = 0;
    while (i < n) {
        let j = m;
        while (j > 0) {
            if (source[i] === pattern[j - 1] && dp[j - 1] !== Infinity) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
            j--;
        }
        i++;
    }

    return targetIndices.length - (dp[m] === Infinity ? 0 : dp[m]);
}
",1420069600
Ayush Mishra,speedcuberayush,288,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, num: int, maxX: int, baseY: int) -> int:
        params = [num, maxX, baseY]
        binomials = [[0] * (maxX + 1) for _ in range(maxX + 1)]
        
        for i in range(maxX + 1):
            binomials[i][0] = 1
            for j in range(1, i + 1):
                binomials[i][j] = (binomials[i - 1][j - 1] + binomials[i - 1][j]) % MOD
        
        stirling = [[0] * (maxX + 1) for _ in range(num + 1)]
        stirling[0][0] = 1
        
        for i in range(1, num + 1):
            for j in range(1, maxX + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        factorials = [1] * (maxX + 1)
        for i in range(1, maxX + 1):
            factorials[i] = factorials[i - 1] * i % MOD
        
        totalWays = 0
        for k in range(1, maxX + 1):
            power = pow(baseY, k, MOD)
            
            binomialCoeff = binomials[maxX][k]
            stirlingCoeff = stirling[num][k]
            factorialCoeff = factorials[k]
            
            currentTerm = (binomialCoeff * stirlingCoeff) % MOD
            currentTerm = (currentTerm * factorialCoeff) % MOD
            currentTerm = (currentTerm * power) % MOD
            
            totalWays = (totalWays + currentTerm) % MOD
        
        return totalWays
",1420116417
Ayush Mishra,speedcuberayush,288,3605,python3,"class Solution:
    def minBitwiseArray(self, nums):
        ans = [-1] * len(nums)

        for i, x in enumerate(nums):
            for a in range(x):
                if (a | (a + 1)) == x:
                    ans[i] = a
                    break

        return ans
",1419997164
Ayush Mishra,speedcuberayush,288,3611,python3,"class Solution:
    def minBitwiseArray(self, nums):
        n = len(nums)
        ans = [-1] * n

        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False

            for bit in range(31):
                if (num >> bit) & 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0: continue

                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            if found: 
                ans[i] = minimalAns
        return ans
",1420047906
Dhruv Pasricha,pasricha_dhruv,289,3487,cpp,"string s, t;
int canRemove[4000];
int dp[3002][3002];

class Solution {

    int f(int id1, int id2)
    {
        if(id1 == s.size())
        {
            return id2 == t.size() ? 0 : -5000;
        }

        if(dp[id1][id2] != -1) return dp[id1][id2];

        int ans1 = f(id1 + 1, id2 + (id2 < t.size() and s[id1] == t[id2]));
        int ans2 = canRemove[id1] ? 1 + f(id1 + 1, id2) : ans1;

        return dp[id1][id2] = max(ans1, ans2);
    }

public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        for(int i = 0; i < n; ++i) canRemove[i] = 0;
        for(auto it : targetIndices) canRemove[it] = 1;
        s = source;
        t = pattern;
        int m = pattern.size();
        for(int i = 0; i <= n; ++i) {
            for(int j = 0; j <= m; ++j) {
                dp[i][j] = -1;
            }
        }
        return f(0, 0);      
    }
};",1420025062
Dhruv Pasricha,pasricha_dhruv,289,3604,cpp,"#define int long long

int dp[1010][1010];
const int mod = 1e9 + 7;
bool done = 0;

int power(int x, int n)
{
    if(n == 0) return 1;
    if(n % 2 == 1) return (power(x, n - 1) * x) % mod;
    int ans = power(x, n / 2);
    return (ans * ans) % mod;
}
 
#define ll long long
const int N = 1e3 + 10;
using namespace std;
 
// array to store inverse of 1 to N
ll factorialNumInverse[N + 1];
 
// array to precompute inverse of 1! to N!
ll naturalNumInverse[N + 1];
 
// array to store factorial of first N numbers
ll fact[N + 1];
 
// Function to precompute inverse of numbers
void InverseofNumber(ll p)
{
    naturalNumInverse[0] = naturalNumInverse[1] = 1;
    for (int i = 2; i <= N; i++)
        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
}
// Function to precompute inverse of factorials
void InverseofFactorial(ll p)
{
    factorialNumInverse[0] = factorialNumInverse[1] = 1;
 
    // precompute inverse of natural numbers
    for (int i = 2; i <= N; i++)
        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
}
 
// Function to calculate factorial of 1 to N
void factorial(ll p)
{
    fact[0] = 1;
 
    // precompute factorials
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % p;
    }
}
 
// Function to return nCr % p in O(1) time
ll Binomial(ll N, ll R, ll p)
{
    // n C r = n!*inverse(r!)*inverse((n-r)!)
    ll ans = ((fact[N] * factorialNumInverse[R])
              % p * factorialNumInverse[N - R])
             % p;
    return ans;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {

        if(!done)
        {
            InverseofNumber(mod);
            InverseofFactorial(mod);
            factorial(mod);
            done = 1;
        }

        dp[0][0] = 1;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= x; ++j)
            {
                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]) % mod;
            }
        }

        int ans = 0;
        for(int i = 1; i <= x; ++i)
        {
            ans += ((((dp[n][i] * power(y, i)) % mod) * ((Binomial(x, i, mod) * fact[i]) % mod)) % mod);
            ans %= mod;
        }

        return ans;
    }
};

#undef int",1420110107
Dhruv Pasricha,pasricha_dhruv,289,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; ++i)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                int b = 0;
                while((1 << b) & nums[i])
                {
                    ++b;
                }
                --b;
                ans[i] = nums[i] - (1 << b);
            }
        }   
        return ans;
    }
};",1420011199
Dhruv Pasricha,pasricha_dhruv,289,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; ++i)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                int b = 0;
                while((1 << b) & nums[i])
                {
                    ++b;
                }
                --b;
                ans[i] = nums[i] - (1 << b);
            }
        }   
        return ans;    
    }
};",1420012378
Bhupesh,bhupi28,290,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        Set<Integer> set = new HashSet<>();
        for(int i : targetIndices) set.add(i);
        int[][] dp = new int[pattern.length()+2][source.length() + 2];
        for(int[] a : dp) Arrays.fill(a , -1);
        int ans = fun(0 , 0 , source , pattern , set , dp);
        return ans;
    }
    
    int fun(int i , int j , String source , String pattern , Set<Integer> set , int[][] dp){
        if(i >= source.length()){
            if(j >= pattern.length()){
                return 0;
            }
            return -1_000_000;
        }
        else if(dp[j][i] != -1){
            return dp[j][i];
        }
        int ans = -1_000_000_0;
        if(j >= pattern.length()){
            if(set.contains(i)){
                ans = Math.max(ans , 1 + fun(i+1 , j , source , pattern , set , dp));
            }
            else{
                ans = Math.max(ans , fun(i+1 , j , source , pattern , set, dp));
            }
        }
        else{
            if(source.charAt(i) == pattern.charAt(j)){
                if(set.contains(i)){
                    ans = Math.max(ans , fun(i+1 , j+1 , source , pattern , set, dp));
                    ans = Math.max(ans , 1 + fun(i+1 , j , source , pattern , set, dp));
                }
                else{
                    ans = Math.max(ans , fun(i+1 , j+1 , source , pattern , set, dp));
                    ans = Math.max(ans , fun(i+1 , j , source , pattern , set, dp));
                }
            }
            else{
                if(set.contains(i)){
                    ans = Math.max(ans , 1 + fun(i + 1 , j , source , pattern , set, dp));
                }
                else{
                    ans = Math.max(ans , fun(i+1 , j , source , pattern , set, dp));
                }
            }
        }
        
        
        return dp[j][i] = ans;
    }
}",1420110164
Bhupesh,bhupi28,290,3604,java,"import java.math.BigInteger;

class Solution {
    public int numberOfWays(int a, int b, int c) {
        final int d = 1_000_000_007;
        
        int e = Math.max(a, b);
        long[] f = new long[e + 1];
        long[] g = new long[e + 1];
        f[0] = 1;
        for(int h = 1; h <= e; h++) {
            f[h] = (f[h-1] * h) % d;
        }
        g[e] = modInverse(f[e], d);
        for(int h = e - 1; h >= 0; h--) {
            g[h] = (g[h+1] * (h+1)) % d;
        }
        
        long[][] i = new long[a + 1][b + 1];
        i[0][0] = 1;
        for(int j = 1; j <= a; j++) {
            for(int k = 1; k <= b; k++) {
                i[j][k] = (i[j-1][k-1] + (k * i[j-1][k]) % d) % d;
            }
        }
        
        long l = 0;
        for(int m = 1; m <= Math.min(a, b); m++) {
            if(b < m) continue;
            long n = (f[b] * modInverse(f[b - m], d)) % d;
            
            long o = (n * i[a][m]) % d;
            
            o = (o * power(c, m, d)) % d;
            
            l = (l + o) % d;
        }
        
        long p = l;
        
        return (int) p;
    }
    
    private long power(long q, long r, int s) {
        long t = 1;
        q = q % s;
        while(r > 0){
            if((r & 1) == 1){
                t = (t * q) % s;
            }
            q = (q * q) % s;
            r >>= 1;
        }
        return t;
    }
    
    private long modInverse(long u, int v) {
        return power(u, v - 2, v);
    }
}",1420050069
Bhupesh,bhupi28,290,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans = new int[nums.size()];
        
ol:     for(int i = 0 ; i < nums.size() ; i++){
            int x = nums.get(i);
            
            int len = Integer.toBinaryString(x).length();
            
            for(int j = len ; j >= 0 ; j--){
                long z = pow(2 , j);
                
                if(x - z > 0){
                    long vval = x - z;
                    if(((vval) | (vval + 1)) == x){
                        ans[i] = (int)vval;
                        continue ol;
                    }
                }
            }
    
            ans[i] = -1;
        }
        
        return ans;
    }
    
    long pow(long a, long b ) {
	    long res = 1;
	    while (b > 0) {
	        if ((b & 1) == 0) {
	            a  = (a*a) ;
	            b = b >> 1;
	        } else {
	            res = (res*a) ;
	            b--;
	        }
	    }
	    return res;
}

}",1420029538
Bhupesh,bhupi28,290,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans = new int[nums.size()];
        
ol:     for(int i = 0 ; i < nums.size() ; i++){
            int x = nums.get(i);
            
            int len = Integer.toBinaryString(x).length();
            
            for(int j = len ; j >= 0 ; j--){
                long z = pow(2 , j);
                
                if(x - z > 0){
                    long vval = x - z;
                    if(((vval) | (vval + 1)) == x){
                        ans[i] = (int)vval;
                        continue ol;
                    }
                }
            }
    
            ans[i] = -1;
        }
        
        return ans;
    }
    
    long pow(long a, long b ) {
	    long res = 1;
	    while (b > 0) {
	        if ((b & 1) == 0) {
	            a  = (a*a) ;
	            b = b >> 1;
	        } else {
	            res = (res*a) ;
	            b--;
	        }
	    }
	    return res;
}

}",1420029199
Ahobilesha,aho343,291,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        ans=[False]*len(source)
        for ind in targetIndices:
            ans[ind]=True
        dp=[float('inf')]*(len(pattern)+1)
        dp[0]=0
        for i in range(len(source)):
            for j in range(len(pattern),0,-1):
                if source[i]==pattern[j-1] and dp[j-1]!=float('inf'):
                    dp[j]=min(dp[j], dp[j-1] + (1 if ans[i] else 0))
        result=len(targetIndices)-max(dp[len(pattern)],0)
        return result",1420073120
Ahobilesha,aho343,291,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD=10**9+7
        ans=0
        C=[[0]*(x+1) for z in range(x+1)]
        i=0
        while i<=x:
            C[i][0]=1
            j=1
            while j<=i:
                C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD
                j+=1
            i+=1
        tab=[[0]*(x+1) for z in range(n+1)]
        tab[0][0]=1
        i=1
        while i<=n:
            j=1
            while j<=x:
                tab[i][j]=(j*tab[i-1][j]+tab[i-1][j-1])%MOD
                j+=1
            i+=1
        fact=[1]*(x+1)
        i=1
        while i<=x:
            fact[i]=fact[i-1]*i%MOD
            i+=1
        k=1
        while k<=x:
            pow_y=1
            p=0
            while p<k:
                pow_y=(pow_y*y)%MOD
                p+=1
            ans=(ans+C[x][k]*tab[n][k]%MOD*fact[k]%MOD*pow_y%MOD)%MOD
            k+=1
        return ans
",1420110337
Ahobilesha,aho343,291,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[-1]*len(nums) 
        for i in range(len(nums)):
            for j in range(nums[i]+1):
                if (j|(j+1))==nums[i]:
                    ans[i]=j
                    break 
        return ans",1420007172
Ahobilesha,aho343,291,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[-1]*len(nums)
        for i in range(len(nums)):
            num=nums[i]
            mi=float('inf')
            f=False
            for b in range(31):
                if (num>>b)&1==1:
                    c=num & ~(1<<b)
                    if c<0:
                        continue
                    if (c|(c+1))==num:
                        if c<mi:
                            mi=c
                            f=True
            ans[i]= mi if mi!=float('inf') else -1
        return ans",1420053027
Pranshu Jain,pranshujain0111,292,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

/* clang-format off */

/* TYPES  */
#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vll vector<long long>
#define mii map<int, int>
#define si set<int>
#define sc set<char>

/* FUNCTIONS */
#define f(i,s,e) for(long long int i=s;i<e;i++)
#define cf(i,s,e) for(long long int i=s;i<=e;i++)
#define rf(i,e,s) for(long long int i=e-1;i>=s;i--)
#define pb push_back
#define eb emplace_back

/* PRINTS */
template <class T>
void print_v(vector<T> &v) { cout << ""{""; for (auto x : v) cout << x << "",""; cout << ""\b}""; }

/* UTILS */
#define MOD 1000000007
#define PI 3.1415926535897932384626433832795
#define read(type) readInt<type>()
ll min(ll a,int b) { if (a<b) return a; return b; }
ll min(int a,ll b) { if (a<b) return a; return b; }
ll max(ll a,int b) { if (a>b) return a; return b; }
ll max(int a,ll b) { if (a>b) return a; return b; }
ll gcd(ll a,ll b) { if (b==0) return a; return gcd(b, a%b); }
ll lcm(ll a,ll b) { return a/gcd(a,b)*b; }
string to_upper(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A'; return a; }
string to_lower(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A'; return a; }
bool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }
void yes() { cout<<""YES\n""; }
void no() { cout<<""NO\n""; }

/*  All Required define Pre-Processors and typedef Constants */
typedef long int int32;
typedef unsigned long int uint32;
typedef long long int int64;
typedef unsigned long long int  uint64;

class Solution {
public:
    int maxRemovals(string original, string subsequence,
                    vector<int>& indicesToRemove) {
        int originalLength = original.length();
        int subsequenceLength = subsequence.length();
        vector<int> removalCount(subsequenceLength + 1,
                                 numeric_limits<int>::max());
        removalCount[0] = 0;
        vector<bool> targets(originalLength, false);

        markTargetIndices(indicesToRemove, targets);

        for (int i = 0; i < originalLength; ++i) {
            updateRemovalCounts(original[i], subsequence, removalCount, targets,
                                i, subsequenceLength);
        }

        return indicesToRemove.size() -
               (removalCount[subsequenceLength] == numeric_limits<int>::max()
                    ? 0
                    : removalCount[subsequenceLength]);
    }

private:
    void markTargetIndices(const vector<int>& indices, vector<bool>& targets) {
        for (int index : indices) {
            targets[index] = true;
        }
    }

    void updateRemovalCounts(char currentChar, const string& subsequence,
                             vector<int>& removalCount,
                             const vector<bool>& targets, int currentIndex,
                             int subsequenceLength) {
        for (int j = subsequenceLength; j > 0; --j) {
            if (currentChar == subsequence[j - 1] &&
                removalCount[j - 1] != numeric_limits<int>::max()) {
                removalCount[j] =
                    min(removalCount[j],
                        removalCount[j - 1] + (targets[currentIndex] ? 1 : 0));
            }
        }
    }
};
",1420058964
Pranshu Jain,pranshujain0111,292,3604,cpp,"#include <bits/stdc++.h>
using namespace std;

/* clang-format off */

/* TYPES  */
#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vll vector<long long>
#define mii map<int, int>
#define si set<int>
#define sc set<char>

/* FUNCTIONS */
#define f(i,s,e) for(long long int i=s;i<e;i++)
#define cf(i,s,e) for(long long int i=s;i<=e;i++)
#define rf(i,e,s) for(long long int i=e-1;i>=s;i--)
#define pb push_back
#define eb emplace_back

/* PRINTS */
template <class T>
void print_v(vector<T> &v) { cout << ""{""; for (auto x : v) cout << x << "",""; cout << ""\b}""; }

/* UTILS */

const int MODULO = 1e9 + 7;
#define PI 3.1415926535897932384626433832795
#define read(type) readInt<type>()
ll min(ll a,int b) { if (a<b) return a; return b; }
ll min(int a,ll b) { if (a<b) return a; return b; }
ll max(ll a,int b) { if (a>b) return a; return b; }
ll max(int a,ll b) { if (a>b) return a; return b; }
ll gcd(ll a,ll b) { if (b==0) return a; return gcd(b, a%b); }
ll lcm(ll a,ll b) { return a/gcd(a,b)*b; }
string to_upper(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A'; return a; }
string to_lower(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A'; return a; }
bool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }
void yes() { cout<<""YES\n""; }
void no() { cout<<""NO\n""; }

/*  All Required define Pre-Processors and typedef Constants */
typedef long int int32;
typedef unsigned long int uint32;
typedef long long int int64;
typedef unsigned long long int  uint64;


class Solution {
public:
    int numberOfWays(int totalItems, int maxGroups, int multiplier) {
        vector<vector<int>> binomialCoefficients = computeBinomialCoefficients(maxGroups);
        vector<vector<int>> stirlingNumbers = computeStirlingNumbers(totalItems, maxGroups);
        vector<int> factorials = computeFactorials(maxGroups);

        long long result = 0;
        for (int groups = 1; groups <= maxGroups; ++groups) {
            long long multiplierPower = computePower(multiplier, groups, MODULO);
            result = (result + 1LL * binomialCoefficients[maxGroups][groups] * stirlingNumbers[totalItems][groups] % MODULO * factorials[groups] % MODULO * multiplierPower % MODULO) % MODULO;
        }

        return result;
    }

private:
    vector<vector<int>> computeBinomialCoefficients(int limit) {
        vector<vector<int>> binomial(limit + 1, vector<int>(limit + 1, 0));
        for (int i = 0; i <= limit; ++i) {
            binomial[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % MODULO;
            }
        }
        return binomial;
    }

    vector<vector<int>> computeStirlingNumbers(int totalItems, int maxGroups) {
        vector<vector<int>> stirling(totalItems + 1, vector<int>(maxGroups + 1, 0));
        stirling[0][0] = 1;
        for (int items = 1; items <= totalItems; ++items) {
            for (int groups = 1; groups <= maxGroups; ++groups) {
                // Use long long to avoid overflow in multiplication
                stirling[items][groups] = (1LL * groups * stirling[items - 1][groups] + stirling[items - 1][groups - 1]) % MODULO;
            }
        }
        return stirling;
    }

    vector<int> computeFactorials(int limit) {
        vector<int> factorial(limit + 1, 1);
        for (int i = 1; i <= limit; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MODULO;
        }
        return factorial;
    }

    long long computePower(long long base, long long exponent, long long modulo) {
        long long result = 1;
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % modulo;
            }
            base = (base * base) % modulo;
            exponent /= 2;
        }
        return result;
    }
};",1420104053
Pranshu Jain,pranshujain0111,292,3605,cpp,"class Solution {
public:

    int findMinValue(int target) {
        for (int candidate = 0; candidate <= target; candidate++) {
            if ((candidate | (candidate + 1)) == target) {
                return candidate;
            }
        }
        return -1;  
    }

    vector<int> minBitwiseArray(const vector<int>& inputArray) {
        int size = inputArray.size();
        vector<int> result(size, -1); 

        for (int index = 0; index < size; index++) {
            result[index] = findMinValue(inputArray[index]);
        }

        return result;
    }
};
",1420009462
Pranshu Jain,pranshujain0111,292,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputNumbers) {
        int size = inputNumbers.size();
        vector<int> result(size);
        
        for (int index = 0; index < size; index++) {
            int currentNumber = inputNumbers[index];
            result[index] = calculateMinimalValue(currentNumber);
        }
        
        return result;
    }

private:
    int calculateMinimalValue(int number) {
        int minimumValue = INT_MAX;
        bool isFound = false;

        for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
            if (isBitSet(number, bitPosition)) {
                int potentialValue = unsetBit(number, bitPosition);

                if (potentialValue >= 0) {
                    if (isValidCandidate(potentialValue, number)) {
                        if (potentialValue < minimumValue) {
                            minimumValue = potentialValue;
                            isFound = true;
                        }
                    }
                }
            }
        }

        return isFound ? minimumValue : -1;
    }

    bool isBitSet(int number, int position) {
        return (number >> position) & 1;
    }

    int unsetBit(int number, int position) {
        return number & ~(1 << position);
    }

    bool isValidCandidate(int candidate, int original) {
        return (candidate | (candidate + 1)) == original;
    }
};
",1420045220
Sasura123,Sasura123,293,3487,cpp,"class Solution {
public:
    set<int> st;
    int dp[3001][3001];

    int func(int ind1,int ind2,string &pat,string &src){
        if(ind1==pat.size()) return 0;
        if(ind2==src.size()) return 1e9;

        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];

        int choose=1e9,notChoose=1e9;

        if(src[ind2]==pat[ind1]){
            if(st.find(ind2)!=st.end()) choose=1+func(ind1+1,ind2+1,pat,src);
            else choose=func(ind1+1,ind2+1,pat,src);
        }

        notChoose=func(ind1,ind2+1,pat,src);

        return dp[ind1][ind2]=min(choose,notChoose);
    }

    int maxRemovals(string source, string pattern, vector<int>& ti) {
        for(int i=0;i<ti.size();i++) st.insert(ti[i]);
        memset(dp,-1,sizeof(dp));

        return ti.size()-func(0,0,pattern,source);
    }
};",1420068516
Sasura123,Sasura123,293,3604,cpp,"#define ll long long
const ll M=1e9+7;

class Solution {
public:
    ll ypow[1002];
    ll dp[1001][1001];

    ll func(ll ind,ll cnt,int &n,int &x,int &y){
        if(ind==n) return ypow[cnt];

        if(dp[ind][cnt]!=-1) return dp[ind][cnt];

        ll same=(cnt*func(ind+1,cnt,n,x,y)%M)%M;
        ll diff=((x-cnt)*func(ind+1,cnt+1,n,x,y)%M)%M;

        return dp[ind][cnt]=same+diff;
    }

    int numberOfWays(int n, int x, int y) {
        ypow[1]=y;
        memset(dp,-1,sizeof(dp));

        for(ll i=2;i<=x;i++){
            ypow[i]=(ypow[i-1]%M*y)%M;
        }

        return (int)func(0,0,n,x,y)%M;
    }
};",1420110800
Sasura123,Sasura123,293,3605,cpp,"class Solution {
public:
    int findBit(int x){
        int cnt=-1;

        for(int i=0;i<32;i++){
            if((1<<i)&x) cnt++;
            else break;
        }

        return cnt;
    }

    int findRes(int x,int bit){
        int res=0;

        for(int i=0;i<32;i++){
            if(((1<<i)&x)&&i!=bit) res+=(1<<i);
        }

        return res;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;

        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int bit=findBit(nums[i]);

                int res=findRes(nums[i],bit);
                ans.push_back(res);
            }
        }

        return ans;
    }
};",1420035339
Sasura123,Sasura123,293,3611,cpp,"class Solution {
public:
    int findBit(int x){
        int cnt=-1;

        for(int i=0;i<32;i++){
            if((1<<i)&x) cnt++;
            else break;
        }

        return cnt;
    }

    int findRes(int x,int bit){
        int res=0;

        for(int i=0;i<32;i++){
            if(((1<<i)&x)&&i!=bit) res+=(1<<i);
        }

        return res;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;

        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int bit=findBit(nums[i]);

                int res=findRes(nums[i],bit);
                ans.push_back(res);
            }
        }

        return ans;
    }
};",1420034620
Raghavendra Gavuji,crimsonalpha19118,294,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0  
        target_set = set(targetIndices)
        for i in range(n):
            for j in range(min(m, i + 1), 0, -1):
                if source[i] == pattern[j - 1]:
                    if dp[j - 1] != float('inf'):
                        cost = dp[j - 1] + (1 if i in target_set else 0)
                        dp[j] = min(dp[j], cost)
        
        if dp[m] == float('inf'):
            return 0
        else:
            return len(targetIndices) - int(dp[m])",1420100471
Raghavendra Gavuji,crimsonalpha19118,294,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        MAX = 2005  
        factorial = [1] * MAX
        inv_factorial = [1] * MAX

        for i in range(1, MAX):
            factorial[i] = factorial[i - 1] * i % MOD
        inv_factorial[MAX - 1] = pow(factorial[MAX - 1], MOD - 2, MOD)
        for i in range(MAX - 2, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD
        N = n + 1  
        S = [[0] * (N) for _ in range(N)]
        S[0][0] = 1  # Base case

        for i in range(1, N):
            for k in range(1, i + 1):
                S[i][k] = (k * S[i - 1][k] + S[i - 1][k - 1]) % MOD

        def permutations(a, b):
            """"""Compute a Permutation b: P(a, b) = a! / (a - b)!""""""
            if a < b:
                return 0
            return factorial[a] * inv_factorial[a - b] % MOD

        total = 0
        min_k = min(n, x)  

        for k in range(1, min_k + 1):
            s = S[n][k]
            x_p_k = permutations(x, k)
            y_pow_k = pow(y, k, MOD)
            term = s * x_p_k % MOD * y_pow_k % MOD
            total = (total + term) % MOD

        return total",1420110863
Raghavendra Gavuji,crimsonalpha19118,294,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  

        for i in range(n):
            for x in range(nums[i] + 1):
                if (x | (x + 1)) == nums[i]:
                    ans[i] = x
                    break  

        return ans",1420009967
Raghavendra Gavuji,crimsonalpha19118,294,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            min_x = None
            for k in range(31):  # Since N can be up to 2^31 - 1
                x = N - (1 << k)
                if x >= 0 and (x | (x + 1)) == N:
                    if min_x is None or x < min_x:
                        min_x = x
            ans.append(min_x if min_x is not None else -1)
        return ans",1420036771
Chinedu,profchi,295,3487,java,"class Solution {
    int min = -1_000_000;
    
    Integer [][] memo;
    
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        Arrays.sort(targetIndices);
        
        memo = new Integer [source.length()][pattern.length()];
        return solve(source, pattern, targetIndices, 0, 0, 0);
    }
    
    private int solve(String source, String pattern, int [] target, int sIdx, int pIdx, int tIdx) {
        
        if (pIdx == pattern.length())
            return target.length - tIdx;
        else if (sIdx == source.length())
            return min;
        else if (memo[sIdx][pIdx] != null)
            return memo[sIdx][pIdx];
        
        boolean canSkip = tIdx < target.length && target[tIdx] == sIdx;
        int ntIdx = canSkip ? tIdx + 1 : tIdx;
        
        // leave
        int nsIdx = sIdx + 1;
        int npIdx = source.charAt(sIdx) == pattern.charAt(pIdx) ? pIdx + 1 : pIdx;
        
        int result = solve(source, pattern, target, nsIdx, npIdx, ntIdx);
            
        // skip
        if (canSkip) {
            int result2 = 1 + solve(source, pattern, target, nsIdx, pIdx, ntIdx);
            result = Math.max(result, result2);
        }
        
        memo[sIdx][pIdx] = result;
        return result;
    }
}",1420035931
Chinedu,profchi,295,3604,java,"class Solution {
    
    static int mod = 1_000_000_007;
    
    static Combinatorics comb = new Combinatorics(mod, 10_000);
    
    Integer [] memo;
    
    public int numberOfWays(int n, int x, int y) {
        
        // return solve(rem, n, y);
        
        int max = Math.min(x, n);
        
        long result = 0;
        long ways, v, yWays, val;
        
        memo = new Integer [max + 1];
        
        for (int i = 1; i <= max; ++i) {
            ways = comb.choose(x, i);
            v = countWays(n, i);
            
            yWays = powerSum(y, i, mod);
            
            val = ways * v;
            val %= mod;
            
            val *= yWays;
            val %= mod;
            
            result += val;
            result %= mod;
        }
        
        return (int) result;
    }
    
    private long countWays(int n, int x) {
        
        if (memo[x] != null)
            return memo[x];
        
        long total = powerSum(x, n , mod);
        
        long sub;
        
        for (int i = x - 1; i > 0; --i) {
            sub = countWays(n, i);
            sub *= comb.choose(x, i);
            
            sub %= mod;
            
            total += mod - sub;
            total %= mod;
        }
        
        memo[x] = (int)total;
        return total;
    }
    
    
    private static long powerSum(long a, long b, int mod) {
		Map<Long, Long> map = new HashMap<>();
		
		long current = 1;
		long val = a;
		long result = 1;
		
		while (current <= b) {
			map.put(current, val);
			
			val = val * val;
			val %= mod;
			
			current *= 2;
		}
		
		while (current > 1) {
			current /= 2;
			
			if (b >= current) {
				b -= current;
				result *= map.get(current);
				result %= mod;
			}
		}
		
		return result;
	}
    
}

class Combinatorics {

	private long [] factorial;
	private int max;
	private int mod;
	
	
	Combinatorics(int mod, int max) {
		this.max = max;
		this.mod = mod;
		
		factorial = new long [max + 2];
		factorial[0] = 1;
		
		for (int i = 1; i < factorial.length; ++i) {
			factorial[i] = factorial[i - 1] * i;
			factorial[i] %= mod;
		}
	}
	
	// n similar items among r people
	public long distribute(int n, int r) {
		
		return choose(n + r - 1, r - 1);
	}
	
	// number of ways to choose b people from n
	public long choose(int n, int b) {
		if (n < 0 || b < 0) return 1;
		
		long num = factorial[n];
		
		long den = factorial[n - b];
		den *= factorial[b];
		den %= mod;
		
		num *= multiplicativeInverse((int)den, mod);
		num %= mod;
		
		return num;
	}
	
	
	
	
	private int gcd(int a, int b) {
		if (a % b == 0)
			return b;
		
		return gcd(b , a % b);
	}
	
	private int[] egcd(int a, int b) {
        if (b == 0)
            return new int[] { a, 1, 0 };
        else {
            int[] arr = egcd(b, a % b);
 
            int gcd = arr[0];
            int X = arr[2];
            int Y = arr[1] - (a / b) * arr[2];
 
            return new int[] { gcd, X, Y };
        }
    }
 
    private int multiplicativeInverse(int a, int modulo) {
 
        int[] egcdValues = egcd(a, modulo);
 
        if (egcdValues[0] != 1)
            return 0;
        if (egcdValues[1] > 0)
            return egcdValues[1];
        else
            return egcdValues[1] + modulo;
    }
    
    
    // So if changes are conditionsly added from 0 mod mod
 	// How many steps would it take to get to diff
 	private long getMinSteps(int diff, int changes, int mod) {
 		if (diff == 0)
 			return 0;
 		else if (changes == 0)
 			return -1;
 		
 		//System.out.println(changes + "" "" + diff);
 		int h = mod;
 		int rep = gcd(h, changes);
 		
 		
 		
 		if (diff % rep != 0)
 			return -1;
 		
 		int rc = changes / rep;
 		int hc = h / rep;
 		int dc = diff / rep;
 		
 		long inv = multiplicativeInverse(rc, hc);
 		
 		inv *= dc;
 		inv %= hc;
 		
 		return inv;
 	}
 	
 	// a is a sequence incremented with start a increment by aR
 	// b is a sequence with start b incremted by bR
 	// returns the first number common to both sequence
 	// returns -1 if there's no common number
 	private long getMin(int a, int aR, int b, int bR) {
 		if (a == b)
 			return a;
 		
 		int target = a;
 		
 		
 		int needed = b % aR;
 		needed = a + aR - needed;
 		needed %= aR;
 		
 		
 		long times = getMinSteps(bR % aR, needed, aR);
 		if (times < 0) 
 			return -1;
 		
 		times *= bR;
 		times += b;
 		
 		return times;
 	}
 	
 	// a is a sequence incremented with start a increment by aR
 	// b is a sequence with start b incremted by bR
 	// returns time at which they both me, at t = 0 , first = a, second = b;
 	// at Result a + t*aR = b + t * bR;
 	// returns -1 if there are no common terms
 	private long getTime(int a, int aR, int b, int bR) {
 		if (a == b)
 			return 0;
 		
 		
 		int needed = b % aR;
 		needed = a + aR - needed;
 		needed %= aR;
 		
 		
 		return getMinSteps(bR % aR, needed, aR);
 	}

}
",1420111087
Chinedu,profchi,295,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        
        int [] result = new int [nums.size()];
        int idx = 0;
        
        Map<Integer, Integer> map = new HashMap<>();
        
        int val;
        
        for (int i = 0; i <= 1000; ++i) {
            val = i | (i + 1);
            
            if (!map.containsKey(val)) {
                map.put(val, i);
            }
        }
        
        
        for (int i = 0; i < result.length; ++i) {
            val = nums.get(i);
            result[i] = map.getOrDefault(val, -1);
        }
        
        
        
        return result;
    }
}",1419998714
Chinedu,profchi,295,3611,java,"class Solution {
   public int[] minBitwiseArray(List<Integer> nums) {
        
        int [] result = new int [nums.size()];
        int idx = 0;
        
        Map<Integer, Integer> map = new HashMap<>();
        
        int val;
        
        for (int i = 0; i < result.length; ++i) {
            val = nums.get(i);
            result[i] = getVal(val);
        }
        
        return result;
    }
    
    private int getVal(int target) {
        
        if (target == 2)
            return -1;
        
        int bit1, bit2;
        
        for (int i = 0; i <= 29; ++i) {
            bit1 = ((1 << i) & target) == 0 ? 0 : 1;
            bit2 = ((1 << (i + 1)) & target) == 0 ? 0 : 1;
            
            if (bit1 == 1 && bit2 == 0) {
                int res = target ^ (1 << i);
                return res;
            }
        }
        
        return target;
    }
}",1420011702
chota_don,karanjohn890,296,3487,cpp,"class Solution {
public:
    int solve(string &s,string &p,int i,int j,vector<int> &hash,vector<vector<int>> &dp){
        if(i>=s.length() && j>=p.length())return 0;
        if(i>=s.length())return 1000000;
        if(j>=p.length())return 0;
        if(dp[i][j]!=INT_MAX)return dp[i][j];
        int sol= solve(s,p,i+1,j,hash,dp);
        if(s[i]==p[j]){
            if(hash[i]==1)
                sol=min(sol,solve(s,p,i+1,j+1,hash,dp)+1);
            else
                 sol=min(sol,solve(s,p,i+1,j+1,hash,dp));  
        }
    return dp[i][j]=sol;
        
    }
    int maxRemovals(string s, string p, vector<int>& t) {
    vector<int> hashmap(s.length(),0);
        int n=s.length();
        for(int i=0;i<t.size();i++)hashmap[t[i]]++;
        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));
        return max(0,(int)t.size() - solve(s,p,0,0,hashmap,dp));
    }
};",1420025533
chota_don,karanjohn890,296,3604,cpp,"class Solution {
public:
    long long mod=1e9+7;
long long mmi(long long A, long long M) {
    long long m0 = M;
    long long y = 0, x = 1;

    if (M == 1)
        return 0;

    while (A > 1) {
        // q is quotient
        long long q = A / M;
        long long t = M;

        // m is remainder now, process same as
        // Euclid's algo
        M = A % M, A = t;
        t = y;

        // Update y and x
        y = x - q * y;
        x = t;
    }

    // Make x positive
    if (x < 0)
        x += m0;

    return x;
}

// Function for extended Euclidean Algorithm

    long long ncr(long long n,long long r,long long mod,vector<long long> &fact){
        if(n==r)return 1;
        long long ans = fact[n]*mmi(fact[n-r],mod);
        ans%=mod;
        ans*=mmi(fact[r],mod);
     
        ans%=mod;
        return ans;
    }
    
    long long solve(long long n,long long st,vector<long long> &dp,vector<long long> &fact){
        
        if(dp[st]!=-1)return dp[st];
        long long ans = power(st,n,mod);
        for(int i=st-1;i>=1;i--){
            long long curr = ncr(st,i,mod,fact);
            curr*=solve(n,i,dp,fact);
            ans-=curr;
            ans+=mod;
            ans%=mod;
        }
        return dp[st]=ans;
        
    }
    long long power(long long a,long long b,long long mod){
        if(b==0)return 1;
        if(b==1)return a;
        long long res = power(a,b/2,mod);
        res= (res*res)%mod;
        if(b%2==1)res = (res*a)%mod;
        return res;
    }
    
    int numberOfWays(int n, int x, int y) {
       vector<long long> fact(1002);
        fact[0]=1;
        for(long long i=1;i<1002;i++)fact[i]=(fact[i-1]*i)%mod;
        
       
        
        long long ans=0;
        vector<long long> dp(max({n,x,y})+20,-1);
        vector<vector<long long>> ncrdp(n,vector<long long>(n,-1));
        for(int i=1;i<=x;i++){
        
            if(n<i)continue;
            long long stages = ncr(x,i,mod,fact);
           
          
            long long curr = solve(n,i,dp,fact);
            curr=(curr*stages)%mod;
         
             long long marks = power((long long)y,(long long)i,mod);
            
            curr=(curr*marks)%mod;
            
            ans = (ans+curr)%mod;
        }
        return ans;
    }
};",1420111195
chota_don,karanjohn890,296,3605,cpp,"class Solution {
public:
    int solve(int a){
        int ans=1;
        int x=a;
        a/=2;
        while(a!=0){
            if(a%2==1)ans*=2;
            else break;
            a/=2;
        }
        return x-ans;
    }
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for(int i=0;i<a.size();i++){
            if(a[i]==2)ans.push_back(-1);
            else ans.push_back(solve(a[i]));
        }
        return ans;
    }
};",1420009569
chota_don,karanjohn890,296,3611,cpp,"class Solution {
public:
    int solve(int a){
        int ans=1;
        int x=a;
        a/=2;
        while(a!=0){
            if(a%2==1)ans*=2;
            else break;
            a/=2;
        }
        return x-ans;
    }
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for(int i=0;i<a.size();i++){
            if(a[i]==2)ans.push_back(-1);
            else ans.push_back(solve(a[i]));
        }
        return ans;
    }
};",1420008975
jkmp,jkmp,297,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        
        vector<int> idx(n);
        for (int x : targetIndices) {
            idx[x] = 1;
        }
        
        vector<int> dp(m + 1, 1E9);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = m - 1; j >= 0; j--) {
                if (source[i] == pattern[j]) {
                    dp[j + 1] = min(dp[j + 1], dp[j] + idx[i]);
                }
            }
        }
        
        for (int i = 0; i <= m; i++) {
            cout << dp[i] << "" \n""[i == m];
        }
        
        return targetIndices.size() - dp[m];
    }
};",1420051058
jkmp,jkmp,297,3604,cpp,"using i64 = long long;

const int M = 1E9 + 7;

template<typename T>
T power(T x, i64 y) {
    T res = 1;
    while (y) {
        if (y % 2 == 1) {
            res *= x;
        }
        x *= x;
        y /= 2;
    }
    return res;
}

struct Mint {
    int val;
    Mint() : val(0) {};
    Mint(i64 x) {
        val = x % M;
        if (val < 0) {
            val += M;
        }
    }
    Mint inv() const {
        return power(*this, M - 2);
    }
    Mint& operator += (const Mint& x) {
        val += x.val;
        if (val >= M) {
            val -= M;
        }
        return *this;
    }
    Mint& operator -= (const Mint& x) {
        val -= x.val;
        if (val < 0) {
            val += M;
        }
        return *this;
    }
    Mint& operator *= (const Mint& x) {
        val = 1LL * val * x.val % M;
        return *this;
    }
    Mint& operator /= (const Mint& x) {
        return *this *= x.inv();
    }
    friend Mint operator + (const Mint& x, const Mint& y) {
        Mint z = x;
        z += y;
        return z;
    }
    friend Mint operator - (const Mint& x, const Mint& y) {
        Mint z = x;
        z -= y;
        return z;
    }
    friend Mint operator * (const Mint& x, const Mint& y) {
        Mint z = x;
        z *= y;
        return z;
    }
    friend Mint operator / (const Mint& x, const Mint& y) {
        Mint z = x;
        z /= y;
        return z;
    }
    friend istream& operator >> (istream& is, Mint& x) {
        long long y;
        is >> y;
        x = Mint(y);
        return is;
    }
    friend ostream& operator << (ostream& os, const Mint& x) {
        return os << x.val;
    }
};

int m = 0;
vector<Mint> _fact(1, 1);
vector<Mint> _invFact(1, 1);

void init(int n) {
    if (n > m) {
        _fact.resize(n + 1);
        _invFact.resize(n + 1);
        for (int i = m + 1; i <= n; i++) {
            _fact[i] = _fact[i - 1] * i;
        }
        _invFact[n] = _fact[n].inv();
        for (int i = n - 1; i > m; i--) {
            _invFact[i] = _invFact[i + 1] * (i + 1);
        }
        m = n;
    }
}

Mint fact(int n) {
    if (n > m) {
        init(n);
    }
    return _fact[n];
}

Mint invFact(int n) {
    if (n > m) {
        init(n);
    }
    return _invFact[n];
}

Mint choose(int n, int m) {
    if (n < m || m < 0) {
        return 0;
    }
    return fact(n) * invFact(m) * invFact(n - m);
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        Mint ans = 0;
        for (int i = 1; i <= min(n, x); i++) {
            Mint cur = 0;
            for (int j = 0; j <= i; j++) {
                cur += (j % 2 == 0 ? 1 : -1) * choose(x, i) * choose(i, j) * power(Mint(i - j), n);
            }
            ans += cur * power(Mint(y), i);
        }
        return ans.val;
    }
};",1420111294
jkmp,jkmp,297,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int j = 0;
            while (nums[i] >> j & 1) {
                j++;
            }
            if (j == 0) {
                ans[i] = -1;
                continue;
            }
            ans[i] = nums[i] ^ (1 << (j - 1));
        }
        return ans;
    }
};",1419999879
jkmp,jkmp,297,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int j = 0;
            while (nums[i] >> j & 1) {
                j++;
            }
            if (j == 0) {
                ans[i] = -1;
                continue;
            }
            ans[i] = nums[i] ^ (1 << (j - 1));
        }
        return ans;
    }
};",1419999596
Wen-Chieh Tung,WJTung,298,3487,cpp,"class Solution {
 public:
  int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    unordered_set<int> T(targetIndices.begin(), targetIndices.end());
    vector<int> max_match = {0}; // max_match[i] = max match length when i operations are done
    for (int i = 0; i < source.length(); ++i) {
      vector<int> next(max_match.size());
      // don't remove current
      for (int j = 0; j < max_match.size(); ++j) {
        if (max_match[j] < pattern.length() && source[i] == pattern[max_match[j]]) {
          next[j] = max_match[j] + 1;
        } else {
          next[j] = max_match[j];
        }
      }
      if (T.contains(i)) {
        // remove current
        next.push_back(-1);
        for (int j = 0; j < max_match.size(); ++j) {
          next[j + 1] = max(max_match[j], next[j + 1]);
        }
      }
      max_match = move(next);
    }
    for (int i = max_match.size() - 1; i >= 0; --i) {
      if (max_match[i] == pattern.length()) {
        return i;
      }
    }
    return -1;
  }
};",1420053472
Wen-Chieh Tung,WJTung,298,3604,cpp,"class Solution {
 public:
  const long long MAX_N = 1000;
  const long long MOD = 1E9 + 7;

  vector<long long> factorial;
  vector<long long> inverse_factorial;

  // find the modular inverse using extended Euclidean algorithm
  long long modinv(long long a) {
    long long b = MOD, u = 1, v = 0;
    while (b) {
      long long q = a / b;
      a -= q * b;
      swap(a, b);
      u -= q * v;
      swap(u, v);
    }
    u %= MOD;
    if (u < 0) {
      u += MOD;
    }
    return u;
  }

  void build() {
    factorial.resize(MAX_N + 1);
    inverse_factorial.resize(MAX_N + 1);

    factorial[0] = 1;
    for (int i = 1; i <= MAX_N; i++) {
      factorial[i] = (factorial[i - 1] * i) % MOD;
    }

    inverse_factorial[0] = 1;
    for (int i = 1; i <= MAX_N; i++) {
      inverse_factorial[i] = (inverse_factorial[i - 1] * modinv(i)) % MOD;
    }
  }

  long long binomial_coefficient(int n, int k) {
    if (n < k) {
      return 0;
    }
    return (factorial[n] * ((inverse_factorial[k] * inverse_factorial[n - k]) % MOD)) % MOD;
  }

  int numberOfWays(int n, int x, int y) {
    build();

    vector<long long> count(x + 1); // count[i]: number of ways to assign performers to i stages without any stages being empty
    count[1] = 1;
    for (int s = 2; s <= x; ++s) {
      // power = s ^ n
      long long power = 1;
      for (int p = 1; p <= n; ++p) {
        power = power * s % MOD;
      }
      count[s] = power;
      for (int j = 1; j < s; ++j) {
        count[s] = (count[s] - (count[j] * binomial_coefficient(s, j) % MOD) + MOD) % MOD;
      }
    }
    long long ans = 0;
    long long power = y;
    for (int s = 1; s <= x; ++s) {
      ans = (ans + (count[s] * binomial_coefficient(x, s) % MOD) * power) % MOD;
      power = power * y % MOD;
    }
    return ans;
  }
};",1420117743
Wen-Chieh Tung,WJTung,298,3605,cpp,"class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans;
    for (int num : nums) {
      bool found = false;
      for (int i = 0; i < num; ++i) {
        if ((i | (i + 1)) == num) {
          ans.push_back(i);
          found = true;
          break;
        }
      }
      if (!found) {
        ans.push_back(-1);
      }
    }
    return ans;
  }
};",1419995654
Wen-Chieh Tung,WJTung,298,3611,cpp,"class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans;
    for (int num : nums) {
      if (num % 2 == 0) {
        ans.push_back(-1);
        continue;
      }
      // consecutive 1 in suffix
      int sum = 0;
      int cur = num;
      while (cur % 2 == 1) {
        sum *= 2;
        sum += 1;
        cur /= 2;
      }
      ans.push_back(num - sum + (sum / 2));
    }
    return ans;
  }
};",1420009533
tomarin,tomarint,299,3487,rust,"impl Solution {
    pub fn max_removals(source: String, pattern: String, target_indices: Vec<i32>) -> i32 {
        let source = source.as_bytes();
        let pattern = pattern.as_bytes();
        let slen = source.len();
        let plen = pattern.len();
        let mut dp = vec![vec![-1; plen + 1]; slen + 1];
        let mut available = vec![false; source.len()];
        for i in target_indices {
            available[i as usize] = true;
        }
        for i in 0..=slen {
            for j in 0..=plen {
                if i == 0 && j == 0 {
                    dp[i][j] = 0;
                    continue;
                }
                if i > 0 {
                    if dp[i - 1][j] != -1 {
                        dp[i][j] = dp[i][j].max(dp[i - 1][j]);
                    }
                }
                if i > 0 && available[i - 1] {
                    if dp[i - 1][j] != -1 {
                        dp[i][j] = dp[i][j].max(dp[i - 1][j] + 1);
                    }
                }
                if i > 0 && j > 0 && source[i - 1] == pattern[j - 1] {
                    if dp[i - 1][j - 1] != -1 {
                        dp[i][j] = dp[i][j].max(dp[i - 1][j - 1]);
                    }
                }
            }
            // println!(""i={}: {:?}"", i, dp[i]);
        }
        dp[slen][plen]
    }
}",1420082145
tomarin,tomarint,299,3604,rust,"const MOD: i64 = 1_000_000_007; // 10**9 + 7

#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Mint {
    val: i64,
}

impl Mint {
    pub fn new(n: i64) -> Self {
        let mut new_val = n % MOD + MOD;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }

    pub fn pow(&self, n: i64) -> Self {
        if n == 0 {
            Self { val: 1 }
        } else {
            let mut ret = self.pow(n >> 1);
            ret *= ret;
            if (n & 1) != 0 {
                ret *= *self;
            }
            ret
        }
    }

    pub fn inv(&self) -> Self {
        self.pow(MOD - 2)
    }
}

impl std::fmt::Display for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::fmt::Debug for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::ops::Add for Mint {
    type Output = Self;
    fn add(self, other: Self) -> Self::Output {
        let mut new_val = self.val + other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Sub for Mint {
    type Output = Self;
    fn sub(self, other: Self) -> Self::Output {
        let mut new_val = self.val + MOD - other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Mul for Mint {
    type Output = Self;
    fn mul(self, other: Self) -> Self::Output {
        Self {
            val: (self.val * other.val) % MOD,
        }
    }
}

impl std::ops::Div for Mint {
    type Output = Self;
    fn div(self, other: Self) -> Self::Output {
        if other.val == 0 {
            panic!(""0 division occured."");
        }
        self * other.inv()
    }
}

impl std::ops::AddAssign for Mint {
    fn add_assign(&mut self, other: Self) {
        *self = *self + other;
    }
}

impl std::ops::SubAssign for Mint {
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}

impl std::ops::MulAssign for Mint {
    fn mul_assign(&mut self, other: Self) {
        *self = *self * other;
    }
}

impl std::ops::DivAssign for Mint {
    fn div_assign(&mut self, other: Self) {
        *self = *self / other;
    }
}

impl Solution {
    pub fn number_of_ways(n: i32, x: i32, y: i32) -> i32 {
        let n = n as usize;
        let x = x as usize;
        let y = y as i64;
        let mut dp = vec![vec![Mint::new(0); x + 1]; n + 1];
        dp[0][0] = Mint::new(1);
        for i in 1..=n {
            for stage in 1..=x {
                // 新しいステージを割り当てる
                dp[i][stage] = dp[i][stage] + dp[i - 1][stage - 1] * Mint::new(y) * Mint::new(x as i64 - stage as i64 + 1);
                // 既存のステージに割り当てる
                dp[i][stage] = dp[i][stage] + dp[i - 1][stage] * Mint::new(stage as i64);
            }
        }
        let mut ans = Mint::new(0);
        for i in 0..=x {
            ans += dp[n][i];
        }
        ans.val as i32
    }
}",1420117837
tomarin,tomarint,299,3605,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![-1; n];
        for i in 0..n {
            if nums[i] & 1 == 1 {
                // 一番右側の連続する1の一番左側
                let mut b = 1;
                while nums[i] & (b<<1) != 0 {
                    b <<= 1;
                }
                ans[i] = (nums[i] & (!b));
            }
        }
        ans
    }
}",1420012489
tomarin,tomarint,299,3611,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<i64>>();
        let mut ans = vec![-1; n];
        for i in 0..n {
            if nums[i] & 1 == 1 {
                // 一番右側の連続する1の一番左側
                let mut b = 1;
                while nums[i] & (b<<1) != 0 {
                    b <<= 1;
                }
                ans[i] = (nums[i] & (!b)) as i32;
            }
        }
        ans
    }
}",1420015925
Ritikesh,ritikesh1999,300,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& ind) {
        int n = s.size();
        int m = t.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, 1e9));
        vector<int> vis(n, 0);
        
        for (auto &z : ind) {
            vis[z] = 1;
        }
        
        for (int i = 0 ; i <= n ; i++) {
            dp[i][0] = 0;
        }
        
        // dp[i][j] = min possible addition of char at position i (if they are present in ind arr) 
        // such that t is subsequence of s
        
        for (int i = 1 ; i <= n ; i++) {
            for (int j = 1 ; j <= m ; j++) {
                // don't use the ith char
                dp[i][j] = dp[i-1][j];
                
                if (s[i-1] == t[j-1]) {
                    // use the ith char
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + vis[i-1]);
                }
            }
        }
        
        return ind.size() - dp[n][m];
        
    }
};",1420078279
Ritikesh,ritikesh1999,300,3604,cpp,"class Solution {
    const int MOD = 1e9 + 7;


    long long modPow(long long base, long long exp, int mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
    
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));
    
        dp[0][0] = 1;

        for (int i = 1; i <= n; ++i) {      
            for (int k = 1; k <= x; ++k) {   
                dp[i][k] = (dp[i - 1][k] * k + dp[i - 1][k - 1] * (x - k + 1)) % MOD;
            }
        }

        long long totalWays = 0;


        for (int k = 1; k <= x; ++k) {

            long long scoreWays = modPow(y, k, MOD);

            totalWays = (totalWays + dp[n][k] * scoreWays) % MOD;
        }

        return totalWays;
    }
};",1420118069
Ritikesh,ritikesh1999,300,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0 ; i < n ; i++) {
            for (int k = 0 ; k <= 2000 ; k++) {
                if ((k | (k + 1)) == nums[i]) {
                    ans[i] = k;
                    break;
                }
            }
        }
        return ans;
    }
};",1419996179
Ritikesh,ritikesh1999,300,3611,cpp,"class Solution {
    vector<int> getBin(int num) {
        vector<int> bin(32, 0);
        
        for (int i = 0 ; i < 32 ; i++) {
            if (num & (1 << i)) {
                bin[i] = 1;
            }
        }
        
        return bin;
    }
    
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0 ; i < n ; i++) {
            if (nums[i] == 2) continue;
            
            vector<int> bin = getBin(nums[i]);
            
            int ind;
            for (ind = 0 ; ind < 32 ; ind++) {
                if (bin[ind] == 0) {
                    break;
                }
            }
            
            if (ind == 0) {
                ans[i] = nums[i] - 1;
            }
            else {
                int num = 0;
                for (int i = ind ; i < 32 ; i++) {
                    if (bin[i]) {
                        num += (1 << i);
                    }
                }
                
                for (int i = 0 ; i < ind-1; i++) {
                    num += (1 << i);
                }
                ans[i] = num;
            }
        }
        return ans;
    }
};",1420021145
Shicheng Chen,c337134154,301,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
     int n = source.length();
    int m = pattern.length();


    vector<bool> is_target(n, false);
    for (const int &idx : targetIndices) {
        if (idx >= 0 && idx < n) { 
            is_target[idx] = true;
        }
    }


    vector<int> prev(n + 1, INT32_MAX);
    vector<int> curr(n + 1, INT32_MAX);

    for (int j = 0; j <= n; ++j) {
        prev[j] = 0;
    }

    for (int i = 1; i <= m; ++i) {
        curr[0] = INT32_MAX;
        for (int j = 1; j <= n; ++j) {
            if (pattern[i - 1] == source[j - 1]) {
                int remove_cost = is_target[j - 1] ? 1 : 0;
                if (prev[j - 1] != INT32_MAX) {
                    curr[j] = min(curr[j - 1], prev[j - 1] + remove_cost);
                } else {
                    curr[j] = curr[j - 1];
                }
            } else {
                curr[j] = curr[j - 1];
            }
        }
        prev.swap(curr);
    }

    int min_used = prev[n];
    if (min_used == INT32_MAX) {
        return 0;
    }
    return targetIndices.size() - min_used;
}
};",1420081814
Shicheng Chen,c337134154,301,3604,cpp,"using namespace std;

typedef long long ll;
const int MOD = 1000000007;
class Solution {
public:
ll power_mod(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while(b > 0){
        if(b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

vector<vector<ll>> get_S(int n, int k){
    vector<vector<ll>> S(n+1, vector<ll>(k+1, 0));
    S[0][0] = 1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=min(i, k);j++){
            S[i][j] = (S[i-1][j-1] + j * S[i-1][j]) % MOD;
        }
    }
    return S;
}

vector<vector<ll>> get_C(int max_n){
    vector<vector<ll>> C(max_n+1, vector<ll>(max_n+1, 0));
    C[0][0] = 1;
    for(int n=1;n<=max_n;n++){
        C[n][0] = 1;
        C[n][n] = 1;
        for(int k=1;k<n;k++){
            C[n][k] = (C[n-1][k-1] + C[n-1][k]) % MOD;
        }
    }
    return C;
}

vector<ll> get_F(int max_n){
    vector<ll> fact(max_n+1, 1);
    for(int i=1;i<=max_n;i++) fact[i] = fact[i-1] * i % MOD;
    return fact;
}

    int numberOfWays(int n, int x, int y) {
            int max_nx = max(n, x);
    vector<vector<ll>> S = get_S(n, min(n, x));
    vector<vector<ll>> C = get_C(max_nx);
    vector<ll> fact = get_F(max_nx);
    ll result = 0;
    for(int k=1; k<=min(n, x); k++){
        ll c = C[x][k];
        ll k_fact = fact[k];
        ll S_nk = S[n][k];
        ll y_pow_k = power_mod(y, k);
        ll term = c * k_fact % MOD;
        term = term * S_nk % MOD;
        term = term * y_pow_k % MOD;
        result = (result + term) % MOD;
    }
    return result;
    }
};",1420105235
Shicheng Chen,c337134154,301,3605,python3,"class Solution:
    def minBitwiseArray(self, arr: List[int]) -> List[int]:
            ans = []
            for target in arr:
                succ = False
                for src in range(target):
                    if (src | (src + 1)) == target:
                        ans.append(src)
                        succ = True
                        break 
                if not succ:
                    ans.append(-1)
            return ans",1420003088
Shicheng Chen,c337134154,301,3611,python3,"class Solution:
    def minBitwiseArray(self, arr: List[int]) -> List[int]:
        ans = []
        for target in arr:
            succ = False
            for src in range(max(0,target//2-10000),
                            min(target//2+10000,target)):
                if (src | (src + 1)) == target:
                    ans.append(src)
                    succ = True
                    break
            if succ:continue
            for src in range(max(0,target-10000),target):
                if (src | (src + 1)) == target:
                    ans.append(src)
                    succ = True
                    break

            if not succ:
                ans.append(-1)
        return ans",1420035924
siuu_7,siuu_7,302,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& idx) {
        int n = s.size(), m = t.size(), k = idx.size();
        vector <int> dp(m+1, 1e9); dp[0] = 0;
        vector <bool> vis(n, 0);
        for(auto i : idx) vis[i] = 1;
        for(int i = 0; i<n; i++){
            for(int j = m; j>0; j--){
                if(s[i] == t[j-1]){
                    dp[j] = min(dp[j], dp[j-1] + vis[i]);
                }
            }
        }
        if(dp[m] < 1e9) return k - dp[m];
        else return k;
    }
};",1420054980
siuu_7,siuu_7,302,3604,cpp,"#define ll long long
class Solution {
public:
    int numberOfWays(int nn, int xx, int yy) {
        ll n = 1ll * nn, x = 1ll * xx, y = 1ll * yy;
        const ll mod = 1e9 + 7;
        vector <vector<ll>> dp(x+1, vector<ll>(x+1, 0)), dp2(n+1, vector<ll>(x+1, 0)); dp[0][0] = 1; dp2[0][0] = 1;
        vector <ll> fact(x+1), cnt(x+1); fact[0] = 1; cnt[0] = 1;
        for(ll i = 1; i<=x; i++){
            dp[i][0] = 1; cnt[i] = (cnt[i-1] * y) % mod; fact[i] = (i * fact[i-1]) % mod;
            for(ll j = 1; j<=i; j++) dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % mod;
        }
        for(ll i = 1; i<=n; i++){
            for(ll j = 1; j<=x; j++) dp2[i][j] = (dp2[i-1][j-1] + (j * dp2[i-1][j]) % mod) % mod;
        }
        ll ans = 0;
        for(ll i = 1; i<=x; i++){
            int temp = (dp[x][i] * dp2[n][i]) % mod;
            temp = (temp * fact[i]) % mod;
            temp = (temp * cnt[i]) % mod;
            ans = (ans + temp) % mod;
        }
        return ans%mod;
    }
};",1420105256
siuu_7,siuu_7,302,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = v.size(); vector <int> ans(n, INT_MAX);
        for(int i = 0; i<n; i++){
            for(int j = 0; j < 30; j++){
                int x = v[i] - (int)pow(2, j);
                if((x | (x + 1)) == v[i]){
                    ans[i] = min(ans[i], v[i] - (int)pow(2, j));
                }
            }
        }
        for(auto &i : ans) if(i == INT_MAX) i = -1;
        return ans;
    }
};",1420030514
siuu_7,siuu_7,302,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = v.size(); vector <int> ans(n, INT_MAX);
        for(int i = 0; i<n; i++){
            for(int j = 0; j < 30; j++){
                int x = v[i] - (int)pow(2, j);
                if((x | (x + 1)) == v[i]){
                    ans[i] = min(ans[i], v[i] - (int)pow(2, j));
                }
            }
        }
        for(auto &i : ans) if(i == INT_MAX) i = -1;
        return ans;
    }
};",1420030010
venkat_pasapuleti,venkat_pasapuleti,303,3487,cpp,"#include <vector>
#include <string>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        int dum=0;
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
            dum++;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        for(int k=0;k<50;k++)
        {
            k++;
        }
        dum+=10;
        cout << dum << "" "" << endl;
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420071870
venkat_pasapuleti,venkat_pasapuleti,303,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        int temp1=0,temp2=0,temp3=0;
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                temp1++;
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
            cout << temp1 << "" "";
        }
        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            temp2++;
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        cout << temp2 << endl;
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            temp3++;
            cout << temp3 << "" "";
            for(int dum=0;dum<50;dum++)
            {
                dum+=2;
                cout << dum << endl;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105593
venkat_pasapuleti,venkat_pasapuleti,303,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        vector<int> res(nums.size(), -1);
        for(int i=0;i<nums.size();i++)
        {
            for(int x=0;x<=nums[i];x++)
            {
                if((x|(x+1))==nums[i]){
                    res[i]=x;
                    break;
                }
            }
        }
        return res;
    }
};",1420009788
venkat_pasapuleti,venkat_pasapuleti,303,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            for(int dum=0;dum<20;dum++)
            {
                dum++;
            }
            
            ans[i]=found?minimalAns:-1;
        }
        for(int i=0;i<50;i++){
            i++;
        }
        return ans;
    }
};
",1420047293
viking72,viking72,304,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int num = source.size();
        int mum = pattern.size();
        
        vector<int> dynamic(mum + 1, std::numeric_limits<int>::max());
        dynamic[0] = 0;
        

        vector<bool> isTarget(num, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        for(int i=0;i<num;i++){
            i++;
        }

        for (int i = 0; i < num; ++i) {
            for (int j = mum; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dynamic[j - 1] != std::numeric_limits<int>::max()) {
                    dynamic[j] = std::min(dynamic[j], dynamic[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dynamic[mum] == std::numeric_limits<int>::max() ? 0 : dynamic[mum]);
    
    }
};",1420105121
viking72,viking72,304,3604,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int check=x;
        std::vector<std::vector<int>> Cot(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= check; i++) {
            Cot[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                Cot[i][j] = (Cot[i - 1][j - 1] + Cot[i - 1][j]) % MOD;
            }
        }
        int start=0;
        for(int i=0;i<100;i++ ){
            if(i==2)i+=100;break;
        }

        // Initialize the Stirling numbers of the second kind (S) array
        std::vector<std::vector<int>> S(n + 1, std::vector<int>(check + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= check; ++j) {
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        for(int i=100;i>=0;i--){
            if(i==100)break;
        }

        // Factorial array
        std::vector<int> fact(check + 1, 1);
        for (int i = 1; i <= check; ++i) {
            fact[i] = 1LL * fact[i - 1] * i % MOD;
        }

        int result = 0;
        // Main computation loop
        for (int k = 1; k <= check; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            result = (result + 1LL * Cot[check][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};",1420112175
viking72,viking72,304,3605,cpp,"class Solution {
public:
    int func(int num){
        for(int i=0;i<1000;i++){
            if((i | (i+1))==num){
                return i;
            }
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>answer;
        int number=nums.size();
        for(int i=0;i<number;i++){
            int numb=nums[i];
            
            answer.push_back(func(numb+1-1));
        }
        for(int i=0;i<number;i++){
            i++;
        }
        return answer;
    }
};",1420017193
viking72,viking72,304,3611,cpp,"class Solution {
public:

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                ans.push_back(-1);
            }
            else{
                string s="""";
                int a= nums[i];
                while(a>0){
                    s+=(a%2+'0');a/=2;
                }
                reverse(s.begin(),s.end());
                int chk=0;
                for(int i=s.length()-1;i>=0;i--){
                    if(s[i]=='0'){
                        chk++;
                        s[i+1]='0';break;
                    }
                }
                
                if(chk==0){
                    s[0]='0';
                }
                
                int res=stoi(s,nullptr,2);
                ans.push_back(res);
                // cout<<s<<endl;  
            }
        }
        
        return ans;
    }
};",1420035706
Gavnish kumar,gavnish_kumar,305,3487,cpp,"class Solution {
public:
int solveTabulation(string ss,string pp,unordered_map<int,bool>&mp){
    int n = ss.size();
        int m = pp.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 1e7));
        
    
        for (int i = 0; i <= n; i++) {
            dp[i][m] = 0;
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (ss[i] == pp[j] && mp[i]) {
                   
                    int a = dp[i + 1][j];   
                    int b = 1 + dp[i + 1][j + 1]; 
                    dp[i][j] = min(a, b);
                } else if (ss[i] != pp[j]) {
                    dp[i][j] = dp[i + 1][j];
                } else {
                    dp[i][j] = dp[i + 1][j + 1];
                }
            }
        }
        return dp[0][0];

}
    int maxRemovals(string s, string p, vector<int>& t) {
        unordered_map<int, bool> mp;
        for (auto it : t) {
            mp[it] = true;
        }
        
        
        int minval = solveTabulation(s,p,mp);
        return t.size() - minval;
    }
};
",1420066543
Gavnish kumar,gavnish_kumar,305,3604,cpp,"const int MOD = 1e9 + 7;
#define ll long long int
class Solution {
public:
    // Function to compute power with modulo
    ll powFunc(ll k, ll a) {
        ll p = 1;
        for (ll i = 0; i < k; i++) {
            p = (p * a) % MOD;
        }
        return p;
    }

    // Function to compute factorial modulo
    ll factorial(ll n) {
        ll fact = 1;
        for (ll i = 1; i <= n; i++) {
            fact = (fact * i) % MOD;
        }
        return fact;
    }

    int numberOfWays(int n, int x, int y) {
        vector<ll> prevComb(x + 1, 0), currComb(x + 1, 0);
        prevComb[0] = 1;
        for (ll i = 1; i <= x; i++) {
            currComb[0] = 1;
            for (ll j = 1; j <= i; j++) {
                currComb[j] = (prevComb[j - 1] + prevComb[j]) % MOD;
            }
            prevComb = currComb;
        }

        vector<ll> prevStirling(x + 1, 0), currStirling(x + 1, 0);
        prevStirling[0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; j++) {
                currStirling[j] = (j * prevStirling[j] + prevStirling[j - 1]) % MOD;
            }
            prevStirling = currStirling;
        }

        ll ans = 0;
        for (ll k = 1; k <= x; k++) {
            ll power = powFunc(k, y);
            ll comb = prevComb[k];
            ll s = currStirling[k];
            ll fact = factorial(k);
            ll term = (comb * s % MOD * fact % MOD * power % MOD) % MOD;
            ans = (ans + term) % MOD;
        }

        return ans;
    }
};",1420112402
Gavnish kumar,gavnish_kumar,305,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        vector<int> ans;
        for(auto &it: arr){
            if(it== 2){
                ans.push_back(-1);
                
            }
            else{
                 int j = 0;
                for(j; j<32; j++){
                    int x= 1<<j;
                    if(it & x) continue;
                    else break;
            }
            int a=~(1 << (j - 1));
            ans.push_back(it & a);
            }
           
        }
        return ans;
    }
};",1420070486
Gavnish kumar,gavnish_kumar,305,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        vector<int> ans;
        for(auto &it: arr){
            if(it== 2){
                ans.push_back(-1);
                
            }
            else{
                 int j = 0;
                for(j; j<32; j++){
                    int x= 1<<j;
                    if(it & x) continue;
                    else break;
            }
            int a=~(1 << (j - 1));
            ans.push_back(it & a);
            }
           
        }
        return ans;
    }
};",1420070147
Kinon,Kinon,306,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) { 
        int dp[3030][3030];
        bool target[3030];
        for(int i=0; i<=source.length(); i++){
            for(int j=0; j<=targetIndices.size(); j++){
                dp[i][j] = -1;
            }
        }
        dp[0][0] = 0;
        for(int i=0; i<source.length(); i++){
            target[i] = false;
        }
        for(int j=0; j<targetIndices.size(); j++){
            target[targetIndices[j]] = true;
        }
        /*for(int j=0; j<=targetIndices.size(); j++){
            cout << dp[0][j] << "" "";
        } cout << endl;*/
        for(int i=0; i<source.length(); i++){
            for(int j=0; j<=targetIndices.size(); j++){
                if(dp[i][j] >= 0){
                    dp[i+1][j] = dp[i][j] + (source[i] == pattern[dp[i][j]]);
                }
                if(target[i] && j>0){
                    dp[i+1][j] = max(dp[i+1][j], dp[i][j-1]);
                }
                //cout << dp[i+1][j] << "" "";
            } //cout << endl;
        }
        int ans = 0;
        for(int i=1; i<=targetIndices.size(); i++){
            if(dp[source.length()][i] == pattern.length()){
                ans = i;
            }
        }
        return ans;
    }
};",1420112579
Kinon,Kinon,306,3604,cpp,"class Solution {
public:
    const long long mod = 1e9+7;
    long long pangkat(long long a, long long b){
        a %= mod; b %= mod-1;
        long long ret = 1;
        while(b){
            if(b%2) ret = ret * a % mod;
            a = a*a%mod;
            b /= 2;
        }
        return ret;
    }
    long long inv(long long a){
        return pangkat(a, mod-2);
    }
    
    int numberOfWays(int n, int x, int y) {
        long long choose[1024][1024], ster[1024][1024]; // dari i obj warnain beda j warna
        for(int i=0; i<1024; i++){
            for(int j=0; j<1024; j++){
                ster[i][j] = 0;
            }
        }
        ster[0][0] = 1;
        choose[0][0] = 1;
        for(int i=1; i<1024; i++){
            for(int j=1; j<=i; j++){
                ster[i][j] = (ster[i-1][j] * j + ster[i-1][j-1]) % mod;
            }
            choose[i][0] = 1;
            for(int j=1; j<i; j++){
                choose[i][j] = (choose[i-1][j-1] + choose[i-1][j]) % mod;
            }
            choose[i][i] = 1;
        }
        //cout << ster[3][2] << endl;
        long long fac[1024];
        fac[0] = 1;
        for(int i=1; i<1024; i++){
            fac[i] = fac[i-1] * i % mod;
        }
        long long ans = 0;
        for(int i=1; i<=n; i++){
            ans += choose[x][i] * fac[i] % mod * ster[n][i] % mod * pangkat(y, i);
            ans %= mod;
        }
        return ans;
    }
};",1420100397
Kinon,Kinon,306,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0; i<nums.size(); i++){
            ans.push_back(-1);
            for(int j=1; j<=nums[i]; j*=2){
                if(((nums[i]-j) | (nums[i]-j+1)) == nums[i]){
                    ans[i] = nums[i]-j;
                }
            }
        }
        return ans;
    }
};",1420000448
Kinon,Kinon,306,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0; i<nums.size(); i++){
            ans.push_back(-1);
            for(int j=1; j<=nums[i]; j*=2){
                if(((nums[i]-j) | (nums[i]-j+1)) == nums[i]){
                    ans[i] = nums[i]-j;
                }
            }
        }
        return ans;
    }
};",1419999124
darishkhan,darishkhan,307,3487,cpp,"class Solution {
public:
    int func(string &s, string &t, int i, int j, unordered_map<int, int>&mp, vector<vector<int>> &dp)
    {
        if(i==s.size())
        {
            if(j==t.size()) return 0;
            else return -1e9;
        }
        if(dp[i][j]!=-1) return dp[i][j];
        int ans = -1e9;
        if(mp[i])
        {
            ans = max(ans, func(s, t, i+1, j, mp, dp)+1);
            if(j<t.size() and s[i]==t[j]) ans = max(ans, func(s, t, i+1, j+1, mp, dp));
        }
        else
        {
            if(j<t.size() and s[i]==t[j]) ans = max(ans, func(s, t, i+1, j+1, mp, dp));
            else ans = max(ans, func(s, t, i+1, j, mp, dp));
        }
        return dp[i][j] = ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        unordered_map<int, int> mp;
        for(int i:targetIndices) mp[i]=1;
        int n = source.size(), m = pattern.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));
        int ans = func(source, pattern, 0, 0, mp, dp);
        return ans;
    }
};",1420046196
darishkhan,darishkhan,307,3604,cpp,"#define intt int64_t
class Solution {
public:
    const intt mod = 1000000007;
    intt fac[1001];
    intt stir[1001][1001];

    intt binpow(intt a, intt b, intt m) {
        a %= m;
        intt res = 1;
        while (b > 0) {
            if (b & 1)
                res = res * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return res;
    }

    void doSomething()
    {
        fac[0]=1;
        for(int i=1;i<1001;i++) fac[i]=(i*fac[i-1])%mod;
        stir[0][0]=1;
        for(int i=1;i<=1000;i++) stir[i][1]=1;

        for(int i=1;i<1001;i++)
        {
            for(int j=1;j<=i;j++)
            {
                stir[i][j] = (((j*stir[i-1][j])%mod) + stir[i-1][j-1])%mod;
            }
        }
    }

    intt choose(intt n, intt x)
    {
        intt ans  = fac[n];
        ans *= binpow(fac[x], mod-2, mod);
        ans%=mod;
        ans *= binpow(fac[n-x], mod-2, mod);
        ans%=mod;
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        doSomething();
        intt ans  = 0;
        for(int i=1;i<=x;i++)
        {
            intt curr = ((choose(x, i)%mod) * ((((fac[i]*stir[n][i])%mod) * binpow(y, i, mod))%mod))%mod;
            ans += curr;
            ans%=mod;
        }
        return ans%mod;
    }
};",1420112626
darishkhan,darishkhan,307,3605,cpp,"#define intt int64_t
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> nums2 = nums;
        intt n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++)
        {
            if(nums2[i]==2)
            {
                ans.push_back((int)-1);
                continue;
            }
            intt number = nums2[i];
            for(int j=0;j<32;j++)
            {
                if((number&(1<<j))==0)
                {
                    break;
                }
                else
                {
                    if(j>0)number^=(1<<(j-1));
                    number^=(1<<j);
                }
            }
            ans.push_back((int)number);
        }

        return ans;
    }
};",1420012694
darishkhan,darishkhan,307,3611,cpp,"#define intt int64_t

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> nums2 = nums;
        intt n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++)
        {
            if(nums2[i]==2)
            {
                ans.push_back((int)-1);
                continue;
            }
            intt number = nums2[i];
            for(int j=0;j<32;j++)
            {
                if((number&(1<<j))==0)
                {
                    break;
                }
                else
                {
                    if(j>0)number^=(1<<(j-1));
                    number^=(1<<j);
                }
            }
            ans.push_back((int)number);
        }

        return ans;
    }
};",1420011471
Rohith Ganesh,2100031760_kluniversity,308,3487,java,"class Solution {
    public int maxRemovals(String one, String two, int[] thr) {
        return calcAns(one, two, thr);
    }

    private int calcAns(String one, String two, int[] thr) {
        int ek, dho;
         ek = one.length();
         dho = two.length();
        int[] mainArray = new int[dho + 1];

        for (int i = 0; i <= dho; i++)     mainArray[i] = Integer.MAX_VALUE;
        
        mainArray[0] = 0;

        boolean[] isUseful = new boolean[ek];
        for (int curPosition : thr) {
            isUseful[curPosition] = true;
        }

        for (int i = 0; i < ek; i++) {
            for (int j = dho; j > 0; j--) {
                if (one.charAt(i) == two.charAt(j - 1) && mainArray[j - 1] != Integer.MAX_VALUE) {
                    mainArray[j] = Math.min(mainArray[j], mainArray[j - 1] + (isUseful[i] ? 1 : 0));
                }
            }
        }

        return thr.length - (mainArray[dho] == Integer.MAX_VALUE ? 0 : mainArray[dho]);
    }
}
",1420070102
Rohith Ganesh,2100031760_kluniversity,308,3604,cpp,"#include <vector>

class Solution {
public:
    static const int NARUTO_MOD = 1e9 + 7;

    int numberOfWays(int shonen, int akatsuki, int sage) {
        return calcAnimeWays(shonen, akatsuki, sage);
    }

private:
    int calcAnimeWays(int shonen, int akatsuki, int sage) {
        std::vector<std::vector<int>> narutoComb(akatsuki + 1, std::vector<int>(akatsuki + 1, 0));
        for (int itachi = 0; itachi <= akatsuki; ++itachi) {
            narutoComb[itachi][0] = 1;
            for (int sasuke = 1; sasuke <= itachi; ++sasuke) {
                narutoComb[itachi][sasuke] = (narutoComb[itachi - 1][sasuke - 1] + narutoComb[itachi - 1][sasuke]) % NARUTO_MOD;
            }
        }

        std::vector<std::vector<int>> sakuraStirling(shonen + 1, std::vector<int>(akatsuki + 1, 0));
        sakuraStirling[0][0] = 1;
        for (int luffy = 1; luffy <= shonen; ++luffy) {
            for (int naruto = 1; naruto <= akatsuki; ++naruto) {
                sakuraStirling[luffy][naruto] = (1LL * naruto * sakuraStirling[luffy - 1][naruto] + sakuraStirling[luffy - 1][naruto - 1]) % NARUTO_MOD;
            }
        }

        std::vector<int> gokuFactorial(akatsuki + 1, 1);
        for (int zoro = 1; zoro <= akatsuki; ++zoro) {
            gokuFactorial[zoro] = (1LL * gokuFactorial[zoro - 1] * zoro) % NARUTO_MOD;
        }

        long long totalAnimeWays = 0;
        for (int shikamaru = 1; shikamaru <= akatsuki; ++shikamaru) {
            long long sagePow = 1;
            for (int itachi = 0; itachi < shikamaru; ++itachi) {
                sagePow = (sagePow * sage) % NARUTO_MOD;
            }
            totalAnimeWays = (totalAnimeWays + (1LL * narutoComb[akatsuki][shikamaru] * sakuraStirling[shonen][shikamaru] % NARUTO_MOD * gokuFactorial[shikamaru] % NARUTO_MOD * sagePow % NARUTO_MOD)) % NARUTO_MOD;
        }
        
        return totalAnimeWays;
    }
};
",1420106356
Rohith Ganesh,2100031760_kluniversity,308,3605,java,"import java.util.List;

class Solution {

    static int[] minBitwiseArray(List<Integer> nums)
    {
        int result [] = new int[nums.size()];
        result = calcAns(nums);
        return result;
    }
    public static int[] calcAns(List<Integer> nums) 
    {    
        int n = nums.size(); 
        int[] ans = new int[n]; 

        for (int i = 0; i < n; i++) 
        {
            int num = nums.get(i); 
            boolean check = false;

            for (int j = 0; j < num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j; 
                    check = true;
                    break;
                }
            }
            if (!check)     ans[i] = -1;
        }

        return ans; 
    }
}",1420016449
Rohith Ganesh,2100031760_kluniversity,308,3611,java,"import java.util.List;

class Solution {

    static int[] calcAns(List<Integer> inputList) {
        int n = inputList.size();
        int[] result = new int[n];

        for (int i = 0; i < n; i++) {
            int val = inputList.get(i);
            int mini = Integer.MAX_VALUE;
            boolean check = false;

            for (int ite = 0; ite <= 30; ite++) {
                if (((val >> ite) & 1) == 1) {
                    int curvalue = val & ~(1 << ite);

                    if (curvalue < 0) continue;

                    if ((curvalue | (curvalue + 1)) == val) {
                        if (curvalue < mini) {
                            mini = curvalue;
                            check = true;
                        }
                    }
                }
            }

            result[i] = check ? mini : -1;
        }

        return result; 
    }

    public static int[] minBitwiseArray(List<Integer> nums) {
        return calcAns(nums);
    }
}
",1420059390
Anubhav Gupta,anubhav0910,309,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size(), len = targetIndices.size();
        vector<int> isTarget(n, 0);
        for (int i : targetIndices) isTarget[i] = 1;
        vector<int> prev(m + 1, 1e9), curr(m + 1, 1e9);
        prev[0] = 0; 

        for(int i = 0; i < n; ++i){
            curr[0] = 0; 
            for(int j = 1; j <= m; ++j){
                int not_take = prev[j]; 
                int take = 1e9;
                if(source[i] == pattern[j - 1] && prev[j - 1] != 1e9){
                    take = prev[j - 1] + (isTarget[i] ? 1 : 0);
                }
                curr[j] = min(not_take, take);
            }
            prev = curr; 
        }
        if (prev[m] == 1e9) prev[m] = 0;
        return len - prev[m];
    }
};
",1420076333
Anubhav Gupta,anubhav0910,309,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    
    long long modExponent(long long base, long long exponent, long long mod) {
        long long result = 1;
        while (exponent) {
            if (exponent % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exponent /= 2;
        }
        return result;
    }
    
    int numberOfWays(int n, int x, int y) {
        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = (1LL * factorial[i - 1] * i) % mod;
        }
        
        vector<int> binomialCoeff(x + 1, 0);
        binomialCoeff[0] = 1;
        for (int i = 1; i <= x; i++) {
            for (int j = i; j > 0; --j) {
                binomialCoeff[j] = (binomialCoeff[j - 1] + binomialCoeff[j]) % mod;
            }
        }
        
        vector<int> powerSums(x + 1, 0);
        powerSums[0] = 1;
        for (int i = 1; i <= n; i++) {
            vector<int> newPowerSums(x + 1, 0);
            for (int j = 1; j <= x; j++) {
                newPowerSums[j] = (1LL * j * powerSums[j] + powerSums[j - 1]) % mod;
            }
            powerSums = newPowerSums;
        }
        
        int result = 0;
        for (int k = 1; k <= x; k++) {
            long long currentPower = modExponent(y, k, mod);
            result = (result + 1LL * binomialCoeff[k] * powerSums[k] % mod * factorial[k] % mod * currentPower % mod) % mod;
        }
        
        return result;
    }
};
",1420106426
Anubhav Gupta,anubhav0910,309,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        for(int i = 0; i < n; i++) {
            for (int val = 0; val <= nums[i]; val++) {
                if ((val | (val + 1)) == nums[i]) {
                    ans[i] = val;  
                    break; 
                }
            }
        }
        return ans;
    }
};
",1419995768
Anubhav Gupta,anubhav0910,309,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            int mn = 1e9;
            bool flag = false;
            for (int j = 0; j < 31; j++){
                if (((nums[i] >> j) & 1) == 1){
                    int mask = ~(1 << j);
                    int val = nums[i] & mask;
                    if(val >= 0 && (val | (val + 1)) == nums[i]) {
                        if(val < mn) {
                            flag = true;
                            mn = val;
                        }
                    }
                }
            }
            if(!flag) ans[i] = -1;
            else ans[i] = mn;
        }
        return ans;
    }
};
",1420060913
ham786,ham786,310,3487,cpp,"class Solution {
public:
    void LCS(string &source, string &pattern, vector<int>&dp, vector<bool>&isTarget, int n, int m) {
        for(int i=0;i<n;i++) {
            for (int j=m; j>0; j--) {
                if (source[i]==pattern[j-1] && dp[j-1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j-1] + (isTarget[i]?1:0));
                }
            }
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<int>dp(m+1,INT_MAX);
        dp[0]=0;
        vector<bool>isTarget(n, false);
        
        for(int &i:targetIndices) {
            isTarget[i]=true;
        }
        LCS(source, pattern, dp, isTarget, n, m);
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }

    
};",1420081469
ham786,ham786,310,3604,cpp,"class Solution{
public:
    const int MOD =1e9 + 7;
    int numberOfWays(int n, int x, int y){
        vector<vector<int>> combination(x+1, vector<int>(x+1, 0));
        for (int i=0; i <= x; i++) {
            combination[i][0]=1; 
            for (int j=1; j <= i; j++) {
                combination[i][j]=(combination[i-1][j-1] + combination[i-1][j])%MOD;
            }
        }
        vector<vector<long long>> samSpace(n+1, vector<long long>(x+1, 0));
        samSpace[0][0]=1;
        for (int i=1; i<=n; i++){
            for (int j =1; j <=x; j++){
                samSpace[i][j] =(j * samSpace[i-1][j] + samSpace[i-1][j-1])%MOD;
            }
        }

        vector<long long> fact(x+1, 1);
        for (int i=1; i<=x; i++){
            fact[i]=fact[i-1] * i% MOD;
        }

        long long result=0;
        for (int k=1; k<=x; k++){
            long long power=1;
            for (int p=0; p<k; p++){
                power=(power*y)%MOD;
            }
            long long term1=(combination[x][k]*samSpace[n][k])%MOD;
            long long term2=(term1*fact[k])%MOD;
            long long term3=(term2*power)%MOD;

            result=(result+term3)%MOD;
        }

        return result;
    }
};
",1420106589
ham786,ham786,310,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int num:nums){
            bool check = false;
            for(int x=0; x<=num;x++){
                if((x|(x+1))==num){
                    ans.push_back(x);
                    check=true;
                    break;
                }
            }
            if(!check){
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1419996493
ham786,ham786,310,3611,cpp,"class Solution{
public:
    vector<int> minBitwiseArray(vector<int>& nums){
        vector<int> ans(nums.size());
        for(int i=0;i<nums.size();i++) {
            int num=nums[i];
            int minimalAns=INT_MAX;
            bool found=false;
            
            for(int bit=0;bit<=30;bit++) {
                if(((num>>bit)&1)==1) {
                    int x=num&~(1<<bit);
                    if(x<0) continue;
                    if((x|(x+1))==num) {
                        if(x<minimalAns) {
                            minimalAns=x;
                            found=true;
                        }
                    }
                }
            }
            
            if(found) {
                ans[i]=minimalAns;
            } else {
                ans[i]=-1;
            }
        }
        return ans;
    }
};
",1420041404
l1cache__,l1cache__,311,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
		unordered_set<int> bad(targetIndices.begin(), targetIndices.end());
        vector<int> seq;
		int n = source.size(), m = pattern.size();
		vector<vector<int>> dp(n + 1, vector<int>(m + 1, 1e9));
		// dp[i][j] = min bad indices to make source[0..i] have pattern[0..j]
		for (int i = 0; i <= n; i++) dp[i][0] = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (source[i-1] == pattern[j-1]) {
					if (bad.count(i-1)) dp[i][j] = min(dp[i][j], dp[i-1][j-1]+1);
					else dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
				}
				dp[i][j] = min(dp[i][j], dp[i-1][j]);
			}
		}
		return bad.size()-dp[n][m];
    }
};",1420113475
l1cache__,l1cache__,311,3604,cpp,"#define ll long long

#define MOD 1000000007

ll modpow(ll a, ll b) {
	ll res = 1;
	while (b > 0) {
		if (b % 2 == 1) {
			res = (res * a) % MOD;
		}
		a = (a * a) % MOD;
		b /= 2;
	}
	return res;
}

ll C(ll n, ll k) {
	ll res = 1;
	for (ll i = 0; i < k; i++) {
		res = (res * (n - i)) % MOD;
		res = (res * modpow(i + 1, MOD - 2)) % MOD;
	}
	return res;
}

ll fact(ll n) {
	ll res = 1;
	for (ll i = 2; i <= n; i++) {
		res = (res * i) % MOD;
	}
	return res;
}

ll stirling[1001][1001];

auto build = []() {
	stirling[0][0] = 1;
	for (int i = 1; i <= 1000; i++) {
		for (int j = 1; j <= i; j++) {
			stirling[i][j] = (stirling[i-1][j-1] + (j * stirling[i-1][j]) % MOD) % MOD;
		}
	}
	return 0;
}();

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        ll assign = modpow(x, n);
		ll ans = 0;
		for (int i = x; i >= 1; i--) {
			if (n < i) continue;
			// i tables, assign at least 1 person to each table such that all tables are non-empty
			// ll ways = C(x, i) * modpow(i, n-i) % MOD; // assign 1 person to each table first
			// // need to account for ways to assign 1 person per table, which is tables!
			// ways = (ways * fact(i)) % MOD;
			ll ways = C(x, i) * stirling[n][i] % MOD;
			ways = (ways * fact(i)) % MOD;
			ways = (ways * modpow(y, i)) % MOD; // score
			// cout << i << ' ' << ways << endl;
			ans = (ans + ways) % MOD;
		}
		return ans;
    }
};",1420082967
l1cache__,l1cache__,311,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int dp[1001] = {};
        fill(dp, dp+1001, 1e9);
        for (int i = 0; i <= 1000; i++) {
            int x = i|(i+1);
            if (x < 1001) dp[x] = min(dp[x], i);
            if (dp[i] == 1e9) dp[i] = -1;
        }
        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); i++) ans[i] = dp[nums[i]];
        return ans;
    }
};",1420027994
l1cache__,l1cache__,311,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            if (__builtin_popcount(nums[i]+1) == 1) {
                ans[i] = nums[i]/2;
            } else {
				if (nums[i] == 2) {
					ans[i] = -1;
					continue;
				}
				string bin = bitset<32>(nums[i]).to_string();
				int j = bin.size()-1;
				while (j >= 0 && bin[j] == '1') {
					j--;
				}
				bin[j+1] = '0';
				ans[i] = stoi(bin, 0, 2);
            }
        }
        return ans;
    }
};",1420035386
Hsin-Jui Chen,joshuachen0213,312,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        vector<int> isTarget(n, 0);
        for (auto x : targetIndices) {
            isTarget[x] = 1;
        }
        for (int j = 1; j <= m; j++) {
            dp[0][j] = -1;
        }
        for (int i = 1; i <= n; i++) {
            dp[i][0] = dp[i - 1][0] + isTarget[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (dp[i - 1][j] != -1) {
                    dp[i][j] = dp[i - 1][j] + isTarget[i - 1];
                } else {
                    dp[i][j] = -1;
                }
                if (source[i - 1] == pattern[j - 1]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
};",1420031485
Hsin-Jui Chen,joshuachen0213,312,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const long long int mod = 1000000007;
        vector<long long int> dp(x, 0);
        vector<long long int> powers(x, 0), combs(min(x, n), 0);
        dp[0] = 1;
        long long int comb, cur, pow;
        for (int i = 1; i < min(x, n); i++) {
            comb = (i + 1);
            cur = 0;
            for (int j = 1; j <= i; j++) {
                cur += comb * dp[j - 1];
                cur %= mod;
                comb *= (i + 1 - j);
                comb %= mod;
                comb *= this->inverse(j + 1);
                comb %= mod;
            }
            pow = 1;
            for (int j = 0; j < n; j++) {
                pow *= (i + 1);
                pow %= mod;
            }
            pow -= cur;
            pow %= mod;
            if (pow < 0) {
                pow += mod;
            }
            dp[i] = pow;
            cout << dp[i] << endl;
        }
        pow = 1;
        cout << ""powers"" << endl;
        for (int i = 0; i < min(x, n); i++) {
            pow *= y;
            pow %= mod;
            powers[i] = pow;
            cout << powers[i] << endl;
        }
        cout << ""comb"" << endl;
        cur = 1;
        for (int i = 0; i < min(x, n); i++) {
            cur *= (x - i);
            cur %= mod;
            cur *= this->inverse(i + 1);
            cur %= mod;
            combs[i] = cur;
            cout << combs[i] << endl;
        }
        long long int ans = 0;
        for (int i = 0; i < min(x, n); i++) {
            cur = (combs[i] * dp[i]) % mod;
            ans += cur * powers[i];
            ans %= mod;
        }
        return (int)ans;
    }
    int inverse(int n) {
        const long long int p = 1000000007;
        long long int u = (long long)n, v = p;
        long long int x1 = 1, x2 = 0;
        long long int q, r, x;
        while (u != 1) {
            q = v / u;
            r = v - q * u;
            x = x2 - q * x1;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
        }
        while (x1 < 0)
            x1 += p;
        return (int)(x1 % p);
    }
};",1420107269
Hsin-Jui Chen,joshuachen0213,312,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x : nums) {
            ans.push_back(this->getAns(x));
        }
        return ans;
    }
    int getAns(int num) {
        if (num % 2 == 0) {
            return -1;
        }
        int ans = 0, n = num;
        while(num > 0) {
            if (num % 2 == 1) {
                ans <<= 1;
                ans += 1;
                num >>= 1;
            } else {
                break;
            }
        }
        return (n - ans) + (ans >> 1);
    }
};",1420002560
Hsin-Jui Chen,joshuachen0213,312,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x : nums) {
            ans.push_back(this->getAns(x));
        }
        return ans;
    }
    int getAns(int num) {
        if (num % 2 == 0) {
            return -1;
        }
        int ans = 0, n = num;
        while(num > 0) {
            if (num % 2 == 1) {
                ans <<= 1;
                ans += 1;
                num >>= 1;
            } else {
                break;
            }
        }
        return (n - ans) + (ans >> 1);
    }
};",1420006944
Bhavesh Sharma,Binary_Sirius,314,3487,cpp,"class Solution {
public:
    int f(int i, int j, string &s, string &p, set<int>&st,vector<vector<int>>&dp){
        if(i==s.size() || j==p.size()){
            if(i==s.size() && j==p.size())return 0;
            if(j==p.size()){
                int c=0;
                for(int k=i;k<s.size();k++){
                    if(st.find(k)!=st.end())c++;
                }
                return c;
            }
            if(i==s.size())return -1e6;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        int pi=-1e6,np=-1e6;
        np= max(np,f(i+1,j,s,p,st,dp));
        if(st.find(i)!=st.end()){
            np= max(np,f(i+1,j,s,p,st,dp)+1);
        }
        if(s[i]==p[j])pi=max(pi,f(i+1,j+1,s,p,st,dp));
        return dp[i][j]=max(pi,np);
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        set<int> st;
        for(auto i:targetIndices)st.insert(i);
        int n=source.size(),m=pattern.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        int ans= f(0,0,source,pattern,st,dp);
        return ans;
    }
};",1420030173
Bhavesh Sharma,Binary_Sirius,314,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll N=1e9+7,M=2005;
    ll powe(ll a, ll n) {

        ll r = 1;
        while (n) {
            if (n % 2) {
                r = ((r % N) * (a % N)) % N;
                n--;
            }
            else {
                a = ((a % N) * (a % N)) % N;
                n = n / 2;
            }
        }
        return r;
    }
    // C++ program to answer queries
    // of nCr in O(1) time.

    // array to store inverse of 1 to N
    ll factorialNumInverse[2005];

    // array to precompute inverse of 1! to N!
    ll naturalNumInverse[2005];

    // array to store factorial of first N numbers
    ll fact[2005];

    // Function to precompute inverse of numbers
    void InverseofNumber(ll N)
    {
        naturalNumInverse[0] = naturalNumInverse[1] = 1;
        for (int i = 2; i < M; i++)
            naturalNumInverse[i] = naturalNumInverse[N % i] * (N - N / i) % N;
    }
    // Function to precompute inverse of factorials
    void InverseofFactorial(ll N)
    {
        factorialNumInverse[0] = factorialNumInverse[1] = 1;

        // precompute inverse of natural numbers
        for (int i = 2; i < M; i++)
            factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % N;
    }
    // Function to calculate factorial of 1 to N
    void factorial(ll N)
    {
        fact[0] = 1;

        // precompute factorials
        for (int i = 1; i < M; i++) {
            fact[i] = (fact[i - 1] * i) % N;
        }
    }

    // Function to return nCr % N in O(1) time
    ll Binomial(ll n, ll r, ll N)
    {
        if (n < r)return 0;
        // n C r = n!*inverse(r!)*inverse((n-r)!)
        ll ans = ((fact[n] * factorialNumInverse[r])
                % N * factorialNumInverse[n - r])
                % N;
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        InverseofNumber(N);
        InverseofFactorial(N);
        factorial(N);
        long long ans=0;
        for(int i=1;i<=min(n,x);i++){
            long long xx= (powe(y,i)*Binomial(x,i,N))%N;
            long y= powe(i,n);
            for(int j=1;j<i;j++){
                long xxx= (Binomial(i,j,N)*powe(i-j,n))%N;
                if(j%2==1)xxx*=-1ll;
                xxx+=N; xxx%=N;
                y+=xxx; y%=N;
            }
            ans= ans +(xx*y)%N; ans%=N;
        }
        return ans;
    }
};",1420120135
Bhavesh Sharma,Binary_Sirius,314,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;i++){
            if(nums[i]==2)ans.push_back(-1);
            else{
                int x=0;
                for(int j=0;j<=30;j++){
                    if((nums[i]&(1<<j))==0)break;
                    else{
                        x=j;
                    }
                }
                int y= nums[i]^(1<<x);
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420008455
Bhavesh Sharma,Binary_Sirius,314,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;i++){
            if(nums[i]==2)ans.push_back(-1);
            else{
                int x=0;
                for(int j=0;j<=30;j++){
                    if((nums[i]&(1<<j))==0)break;
                    else{
                        x=j;
                    }
                }
                int y= nums[i]^(1<<x);
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420006752
Shubham Kumar,Shubham_Kumar_LeetCode,315,3487,cpp,"


class Solution {
    int solve(int i,int j,string &s, string& p, vector<bool> &pres,vector<vector<int>>& dp){
        int n=s.size();
        if(i==n){
            if(j!=p.size())return INT_MIN/10;
            return 0;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        if(pres[i]){
            int hata,matHata;
            hata=1+solve(i+1,j,s,p,pres,dp);
            if(j<p.size() && s[i]==p[j]){
                matHata=solve(i+1,j+1,s,p,pres,dp);
            }
            else matHata=solve(i+1,j,s,p,pres,dp);
            return dp[i][j]=max(hata,matHata);
        }
        else{
            if(j<p.size() && s[i]==p[j])return dp[i][j]= solve(i+1,j+1,s,p,pres,dp);
            else return dp[i][j]= solve(i+1,j,s,p,pres,dp);
        }
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size();
        vector<bool> pres(n);
        for(auto i:targetIndices)pres[i]=true;
        vector<vector<int>> dp(n,vector<int> (n,-1));
        return solve(0,0,source,pattern,pres,dp);
    }
};",1420039063
Shubham Kumar,Shubham_Kumar_LeetCode,315,3604,cpp,"class Solution
{
    int fact[1001];

    long long nCk(int n, int k)
    {
        if (k > n)
            return 0;
        return (fact[n] * 1ll * expTab((fact[n - k] * 1ll * fact[k]) % M, M - 2, M)) % M;
    }

    long long expTab(long long a, long long b, long long m)
    {
        long long ans = 1;
        while (b)
        {
            if (b & 1)
                ans = (1ll * ans * a) % m;
            a = (a * 1ll * a) % m;
            b >>= 1;
        }
        return ans;
    }

    long long S(int n, int k, vector<vector<long long>> &memo)
    {
        if (k == 0 && n == 0)
            return 1;
        if (k > n || k <= 0)
            return 0;
        if (k == n)
            return 1;
        if (k == 1)
            return 1;

        if (memo[n][k] != -1)
            return memo[n][k];

        memo[n][k] = ((k * 1ll * S(n - 1, k, memo)) % M + S(n - 1, k - 1, memo) % M) % M;
        return memo[n][k];
    }
    const int M = 1e9+7;

public:
    int numberOfWays(int n, int x, int y)
    {
        int ans = 0;
        // vector<int> fact((int)1e3 + 1, 1);
        fact[0] = 1;

        for (int i = 1; i <= 1000; i++){
            fact[i] = (fact[i - 1] * 1ll * i) % M;
            // if(i<10)cout<<fact[i]<<"" "";
        }
        // cout<<endl;
            

        vector<vector<long long>> memo(n + 1, vector<long long>(x + 1, -1));
        for (int i = 1; i <= x; i++)
        {
            // cout<<nCk(x,i)<<endl;
            // cout<<S(n,i,memo)<<endl;
            // cout<<fact[i]<<endl;
            // cout<<expTab(y,i,M)<<endl;
            int curr = (((((nCk(x, i) * 1ll * S(n, i, memo)) % M) * 1ll * fact[i]) % M) * 1ll * (expTab(y, i, M))) % M;
            ans = (ans + curr) % M;
        }
        return ans;
    }
};",1420120149
Shubham Kumar,Shubham_Kumar_LeetCode,315,3605,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num:nums){
            int i;
            for(i=0;i<31;i++)if((num&(1<<i))==0)break;
            if(i==0)ans.push_back(-1);
            else{
                i--;
                num=num&(~(1<<i));
                ans.push_back(num);
            }
        }   
        return ans;
    }
};",1420004637
Shubham Kumar,Shubham_Kumar_LeetCode,315,3611,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num:nums){
            int i;
            for(i=0;i<31;i++)if((num&(1<<i))==0)break;
            if(i==0)ans.push_back(-1);
            else{
                i--;
                num=num&(~(1<<i));
                ans.push_back(num);
            }
        }   
        return ans;
    }
};",1420006337
iron_spider,iron_spider,317,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        
        vector<int> removalCount = initializeDP(patternLength);
        vector<bool> targetFlags = markTargets(sourceLength, targetIndices);
        
        computeDP(source, pattern, sourceLength, patternLength, removalCount, targetFlags);
        
        return calculateMaxRemovals(removalCount, targetIndices.size());
    }
    
private:
    vector<int> initializeDP(int patternLength) {
        vector<int> dp(patternLength + 1, numeric_limits<int>::max());
        dp[0] = 0;
        return dp;
    }

    vector<bool> markTargets(int sourceLength, const vector<int>& targetIndices) {
        vector<bool> isTarget(sourceLength, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    void computeDP(const string& source, const string& pattern, int sourceLength, int patternLength, vector<int>& dp, const vector<bool>& isTarget) {
        for (int i = 0; i < sourceLength; i++) {
            for (int j = patternLength; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
    }

    int calculateMaxRemovals(const vector<int>& dp, int totalTargets) {
        return totalTargets - (dp[dp.size() - 1] == numeric_limits<int>::max() ? 0 : dp[dp.size() - 1]);
    }
};
",1420073540
iron_spider,iron_spider,317,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, totalItems: int, maxGroups: int, groupSize: int) -> int:
        combination = self.computeCombinations(maxGroups)
        stirling = self.computeStirlingNumbers(totalItems, maxGroups)
        factorial = self.computeFactorials(maxGroups)
        
        totalWays = 0
        for groups in range(1, maxGroups + 1):
            yPower = self.computePower(groupSize, groups)
            totalWays = (totalWays + combination[maxGroups][groups] * stirling[totalItems][groups] % MOD * factorial[groups] % MOD * yPower % MOD) % MOD
        
        return totalWays

    def computeCombinations(self, maxGroups: int) -> List[List[int]]:
        C = [[0] * (maxGroups + 1) for _ in range(maxGroups + 1)]
        for i in range(maxGroups + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
        return C

    def computeStirlingNumbers(self, totalItems: int, maxGroups: int) -> List[List[int]]:
        S = [[0] * (maxGroups + 1) for _ in range(totalItems + 1)]
        S[0][0] = 1
        for i in range(1, totalItems + 1):
            for j in range(1, maxGroups + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
        return S

    def computeFactorials(self, maxGroups: int) -> List[int]:
        fact = [1] * (maxGroups + 1)
        for i in range(1, maxGroups + 1):
            fact[i] = fact[i - 1] * i % MOD
        return fact

    def computePower(self, base: int, exponent: int) -> int:
        result = 1
        for _ in range(exponent):
            result = (result * base) % MOD
        return result
",1420107474
iron_spider,iron_spider,317,3605,cpp,"
class Solution {
public:
    int findMinimumValue(int prime) {
        for (int candidate = 1; candidate <= prime; ++candidate) {
            if ((candidate | (candidate + 1)) == prime) {
                return candidate;
            }
        }
        return -1;
    }

    vector<int> generateAnswerArray(const vector<int>& primes) {
        int size = primes.size();
        vector<int> answerArray(size, -1);

        for (int i = 0; i < size; ++i) {
            answerArray[i] = findMinimumValue(primes[i]);
        }

        return answerArray;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        return generateAnswerArray(nums);
    }
};
",1420005540
iron_spider,iron_spider,317,3611,cpp,"class Solution {
public:
    int convertBinaryStringToInt(const std::string& binaryStr) {
        int result = 0;
        long long powerOfTwo = 1;
        
        for (int i = binaryStr.length() - 1; i >= 0; i--) {
            result += (binaryStr[i] == '1') ? powerOfTwo : 0;
            powerOfTwo *= 2;
        }
        
        return result;
    }
    
    std::string getModifiedBinaryString(int number) {
        std::string binaryStr = std::bitset<33>(number).to_string();
        int index = binaryStr.length() - 1;

        // Change the rightmost '0' to '1'
        while (index >= 0 && binaryStr[index] != '1') {
            binaryStr[index] = '1';
            index--;
        }

        // Change the rightmost '1' to '0'
        while (index >= 0 && binaryStr[index] == '1') {
            index--;
        }
        index++;
        if (index < binaryStr.length()) {
            binaryStr[index] = '0';
        }

        return binaryStr;
    }

    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> result(nums.size(), -1);
        
        for (size_t i = 0; i < nums.size(); i++) {
            if (nums[i] % 2 != 0) {
                std::string modifiedBinaryStr = getModifiedBinaryString(nums[i]);
                int modifiedNumber = convertBinaryStringToInt(modifiedBinaryStr);
                result[i] = std::min(modifiedNumber, nums[i] - 1);
            }
        }
        
        return result;
    }
};
",1420034613
Роман Садовников,TheFuturoma,318,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        s = set()
        tr = set()
        for el in pattern:
            s.add(el)
        for el in targetIndices:
            tr.add(el)
        res = 0
        for i, el in enumerate(source):
            if el not in s and i in tr:
                res += 1
        dp = [-1] * (len(pattern) + 1)
        
        dp[0] = 0
        for i, el in enumerate(source):
            if el not in s:
                continue
            ndp = [-1] * (len(pattern) + 1)
            for j in range(len(dp)):
                ndp[j] = dp[j]
            if i in tr:
                for j in range(len(dp)):
                    if ndp[j] < 0:
                        continue
                    ndp[j] += 1
            for j in range(len(pattern) - 1, -1, -1):
                c = pattern[j]
                if c != el or dp[j] < 0:
                    continue
                ndp[j + 1] = max(ndp[j + 1], dp[j])
            plus = False
            if i in tr:
                plus = True
                # for j in range(0, len(pattern)):
                #     if pattern[j] == el and dp[j] >= 0:
                #         ndp[j] += 1
            for j in range(len(dp)):
                dp[j] = ndp[j]
        return res + dp[len(pattern)]",1420063581
Роман Садовников,TheFuturoma,318,3604,cpp,"#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

ll pow_mod(ll a, ll b, ll mod) {
    ll res = 1;
    ll curr_r = a;
    while (b) {
        if (b & 1) {
            res *= curr_r;
            res %= mod;
        }
        curr_r *= curr_r;
        curr_r %= mod;
        b >>= 1;
    }
    return res;
}
int COMB_N = 2 * 1e5 + 1;
vector<ll> fact(COMB_N);
vector<ll> fact_rev(COMB_N);
// ll mod = 998244353;
ll mod = 1e9 + 7;
map<pair<ll, ll>, ll> mem;

ll choose(ll k, ll n) {
    if (k > n) return 0;
    return ((fact[n] * fact_rev[k]) % mod * fact_rev[n - k]) %  mod;
}

class Solution {
public:
    

    // ll linear_choose(ll k, ll n) {
    //     if (k > n) return 0;
    //     ll res = 1;
    //     for (int i = n; i > n - k; i--) res = res * i % mod;
    //     return res * fact_rev[k] % mod;
    // }

    // int CURRENT_TEST = 0;

    // void pa() {
    //     cout << ""Case #"" << CURRENT_TEST << "": "" << endl;
    //     return;
    // }

    ll comb(ll box, ll ball) {
        if (mem.find({box, ball}) != mem.end()) {
            return mem[{box, ball}];
        }
        if (box == 1) {
            return 1;
        }
        ll res = pow_mod(box, ball, mod);
        for (ll new_box = 1; new_box < box; new_box++) {
            ll minus = comb(new_box, ball) * choose(box - new_box, box) % mod;
            res = (res - minus + mod) % mod;
        }
        mem[{box, ball}] = res;
        return res;
    }

    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        fact_rev[0] = 1;
        for (ll i = 1; i < COMB_N; i++) fact[i] = (fact[i - 1] * i) % mod;
        fact_rev[COMB_N - 1] = pow_mod(fact[COMB_N - 1], mod - 2, mod);
        for (ll i = COMB_N - 2; i > 0; i--) fact_rev[i] = (fact_rev[i + 1] * (i + 1)) % mod;

        ll res = 0;
        for (int i = 1; i <= min(n, x); i++) {
            ll box = choose(i, x);
            ll balls = comb(i, n);
            ll curr_sum = box * balls % mod * pow_mod(y, i, mod) % mod;
            res += curr_sum;
            res %= mod;
        }
        return res;
    }
};",1420107872
Роман Садовников,TheFuturoma,318,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for el in nums:
            res = -1
            for c in range(0, el):
                if (c | (c + 1)) == el:
                    res = c
                    break
            ans.append(res)
        return ans",1419995288
Роман Садовников,TheFuturoma,318,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for el in nums:
            if el == 2:
                res.append(-1)
                continue
            if ((el + 1) & (el)) == 0:
                res.append(el // 2)
                continue
            pos = -1
            it = 1
            while it < el:
                if el & it:
                    pos = it
                else:
                    if pos >= 0:
                        el -= pos
                        break
                it *= 2
            res.append(el)
        return res
",1420008718
Ying Liu,pein531,319,3487,cpp,"class Solution {
public:
    int maxRemovals(string a, string b, vector<int>& ts) {
        int n=a.length();
        int m=b.length();
        a="" ""+a+""-"";
        b="" ""+b+""+"";
        bool vis[n+2];
        int dp[n+2][m+2];
        memset(vis,0,sizeof(vis));
        memset(dp,-127/2,sizeof(dp));
        for(auto v:ts)  vis[v+1]=true;
        dp[0][0]=0;
        for(int i=0;i<=n;++i)
            for(int j=0;j<=m;++j){
                if(a[i+1]==b[j+1])  dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);
                else    dp[i+1][j]=max(dp[i+1][j],dp[i][j]);
                if(vis[i+1])    dp[i+1][j]=max(dp[i+1][j],dp[i][j]+1);
            }
        return dp[n][m];
    }
};",1420102110
Ying Liu,pein531,319,3604,cpp,"class Solution {
public:
    #define ll long long
    const int P=1e9+7;
    const int N=1005;
    int fac[1005],inv[1005];
    int ksm(int u,int v){
        int res=1;
        while(v){
            if(v&1)	res=(ll)res*u%P;
            v>>=1;	u=(ll)u*u%P;
        }
        return res;
    }
    int C(int n,int m){
        if(n<m||m<0)	return 0;
        return (ll)fac[n]*inv[m]%P*inv[n-m]%P;
    }
    void C_init(int n){
        fac[0]=1;
        for(int i=1;i<=n;++i)	fac[i]=(ll)fac[i-1]*i%P;
        inv[n]=ksm(fac[n],P-2);
        for(int i=n;i>=1;--i)	inv[i-1]=(ll)inv[i]*i%P;
    }
    int numberOfWays(int n, int x, int y) {
        C_init(1000);
        int S[1005][1005];
        memset(S,0,sizeof(S));
        S[0][0]=1;
        for(int i=1;i<=1000;++i)
            for(int j=1;j<=i;++j){
                S[i][j]=(S[i-1][j-1]+(ll)j*S[i-1][j]%P)%P;
            }
        int ans=0;
        for(int i=1;i<=x;++i){
            int res=(ll)S[n][i]*C(x,i)%P*fac[i]%P*ksm(y,i)%P;
            ans=(ans+res)%P;
        }
        return ans;
    }
};",1420087293
Ying Liu,pein531,319,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++) {
            for(int num = 1; num <= 2000; num++) {
                if((num | (num + 1)) == nums[i]) {
                    ans[i] = num;
                    break;
                }
            }
        }
        return ans;
    }
};",1420012141
Ying Liu,pein531,319,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int >ans;    ans.clear();
        
        for(auto v:nums){
            if(v==2){
                ans.push_back(-1);
                continue;
            }
            int p=0;
            while(v>>p&1)   p++;
            if((v>>p)%2)    ans.push_back(-1);
            else{
                int x=v>>(p+1)<<(p+1);
                int y=0;
                if(p>=1)    y=((1<<(p-1))-1);
                ans.push_back(x+y);
            }
        }
        return ans;
    }
};",1420080072
BZH110,BZH110,320,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        unordered_set<int> s(targetIndices.begin(), targetIndices.end());
        int n = source.size(), m = pattern.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        dp[0][0] = 0;
        for(int i=1;i<=n;i++){
            dp[i][0] = dp[i-1][0];
            if(s.count(i - 1))
                dp[i][0]++;
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(source[i] == pattern[j] && dp[i][j] >= 0){
                    dp[i + 1][j + 1] = dp[i][j];
                }
                if(source[i] == pattern[j] && dp[i][j] >= 0){
                    dp[i + 1][j + 1] = dp[i][j];
                }
                if(dp[i][j + 1] >= 0)
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j + 1] + (int)s.count(i));
                // cout << i << "" "" << j << "" "" << dp[i + 1][j + 1] << endl;
            }
        }
        return dp[n][m];
    }
};",1420079196
BZH110,BZH110,320,3604,cpp,"class Solution {
public:
    using ll = long long;
    ll C(int n, int m, int mod = INT_MAX) { // choose m from n
        if(n < m)
            return 0;
        if(2 * m > n)
            return C(n, n-m, mod);
        ll ans = 1, ans2 = 1;
        for(int i=n;i>n-m;i--)
            ans = (ans * (i % mod)) % mod;
        for(int i=1;i<=m;i++)
            ans2 = (ans2 * (i % mod)) % mod;
        return (ans * mypow(ans2, mod-2, mod)) % mod;
    }
    long long mypow(long long a, long long b, long long mod = LLONG_MAX) {
        a %= mod;
        if (b == 0)
            return 1;
        if (b == 1)
            return a;
        if (b % 2 == 0)
            return mypow((a * a) % mod, b / 2, mod);
        return (a * mypow((a * a) % mod, b / 2, mod)) % mod;
    }
    ll A(int n, int m, int mod = INT_MAX) {
        ll ans = 1;
        for(int i=n;i>n-m;i--)
            ans = (ans * (i % mod)) % mod;
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        ll mod = 1e9 + 7, ans = 0, pre = 0;
        vector<vector<ll>> dp(n + 1, vector<ll>(x + 1, 0));
        dp[0][0] = 1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=min(i, x);j++){
                dp[i][j] = ((dp[i-1][j] * j) % mod + dp[i-1][j-1]) % mod;
                // cout << i << "" "" << j << "" "" << dp[i][j] << endl;
            }
        }
        if(x >= n)
            dp[n][n] = 1;
        for(int i=1;i<=min(n, x);i++){
            ans += (C(x, i, mod) * dp[n][i]) % mod * A(i, i, mod) % mod * mypow(y, i, mod) % mod;
            ans %= mod;
        }
        return ans;
    }
};",1420056211
BZH110,BZH110,320,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0;i<n;i++){
            if(nums[i] == 2){
                continue;
            }
            int t = 0;
            while(nums[i] & (1 << t))
                t++;
            t--;
            ans[i] = nums[i] - (1 << t);
        }
        return ans;
    }
};",1420088671
BZH110,BZH110,320,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0;i<n;i++){
            if(nums[i] == 2){
                continue;
            }
            int t = 0;
            while(nums[i] & (1 << t))
                t++;
            t--;
            ans[i] = nums[i] - (1 << t);
        }
        return ans;
    }
};",1420088058
SRJM8941,SRJM8941,321,3487,cpp,"class Solution {
public:
    void name(string name,int n){
        if(name==""rahul""){
            n=n/2;
        }
    }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        std::vector<int> dp(m + 1, std::numeric_limits<int>::max()); 
        dp[0] = 0; 
        
        vector<bool> isAns(n, false); 
        for (int idx : targetIndices) {
            isAns[idx] = true;
        }
        
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != std::numeric_limits<int>::max()) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isAns[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == std::numeric_limits<int>::max() ? 0 : dp[m]);
        
    }
};",1420085436
SRJM8941,SRJM8941,321,3604,cpp,"class Solution {
public:
    void name( string ans, int n){
        ans=ans+"" "";
        n=n/2;
    }
    
     static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        
       vector<vector<int>> binomialCoeff(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            binomialCoeff[i][0] = 1;  
            for (int j = 1; j <= i; ++j) {
                binomialCoeff[i][j] = (binomialCoeff[i - 1][j - 1] + binomialCoeff[i - 1][j]) % MOD;
            }
        } 
        
        
        std::vector<std::vector<int>> stirlingNumbers(n + 1, std::vector<int>(x + 1, 0));
        stirlingNumbers[0][0] = 1;  
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

       
        std::vector<int> factorialValues(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorialValues[i] = (1LL * factorialValues[i - 1] * i) % MOD;
        }

        
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long powerOfY = 1;
            for (int i = 0; i < k; ++i) {
                powerOfY = (powerOfY * y) % MOD;
            }
            totalWays = (totalWays + (1LL * binomialCoeff[x][k] * stirlingNumbers[n][k] % MOD * factorialValues[k] % MOD * powerOfY % MOD)) % MOD;
        }
        return totalWays;

    }
};",1420108822
SRJM8941,SRJM8941,321,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0; i<n; i++){
            int num=nums[i];
            for(int k=0; k<num; k++){
                if((k | (k+1))==num){
                    ans[i]=k;
                    break;
                }
            }
        }
        return ans;
    }
};",1420006858
SRJM8941,SRJM8941,321,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int num=nums[i];
            int miniAns = INT_MAX;
            bool found=false;
            for(int bit=0; bit<=30; bit++){
                if(((num>>bit) & 1)==1){
                    int candi = num & ~(1<<bit);
                    if(candi < 0) continue;
                    if((candi | (candi+1))==num){
                        if(candi<miniAns){
                            miniAns=candi;
                            found=true;
                        }
                    }
                }
            }
            if(found){
                ans[i]=miniAns;
            }else{
                ans[i]=-1;
            }
            
        }
        return ans;
    }
};",1420050601
himanshu dhingra,himanshudhingra,322,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    bool hash[3001];
    int helper (int level, int pattern_made, string & s, string & pattern) {
        if (pattern_made == (int)pattern.size()) {
            int ans = 0;
            for (int i = level; i< s.size();i++) {
                ans += hash[i];
            }
            return ans;
        }
        if (level == (int)s.size()) {
            return -1e4;
        }

        if (dp[level][pattern_made] != -1) return dp[level][pattern_made];

        if (hash[level] == 0) {
            return dp[level][pattern_made] = helper(level + 1, pattern_made + (s[level] == pattern[pattern_made]), s, pattern);
        }
        if ((s[level] != pattern[pattern_made])) {
            return dp[level][pattern_made] = 1 + helper(level + 1, pattern_made, s, pattern);
        }
        return dp[level][pattern_made] = max (1 + helper(level + 1, pattern_made, s, pattern), helper(level + 1, pattern_made + 1, s, pattern));

    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset (dp, -1 , sizeof dp);
        memset(hash, 0,sizeof hash); 
        for (auto &it : targetIndices) {
            hash[it] = 1;
        }
        return helper(0,0,source,pattern);
    }
};",1420056966
himanshu dhingra,himanshudhingra,322,3604,cpp,"typedef long long ll;
class Solution {
public:

    ll dp[1001][1001];
    vector<long long> factorial;
    const int MOD = 1e9 + 7;

    vector<long long> computeFactorials() {
    int n = 1000;
    factorial[0] = 1;
    for (int i = 1; i <= n; ++i) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    return factorial;
}

// Function to compute modular inverse of x % mod
long long modInverse(long long x) {
    long long result = 1, power = MOD - 2; // Fermat's Little Theorem
    while (power) {
        if (power % 2) {
            result = (result * x) % MOD;
        }
        x = (x * x) % MOD;
        power /= 2;
    }
    return result;
}

// Function to compute nCr % mod
long long nCr(int n, int r, const vector<long long>& factorial) {
    if (r > n) return 0; // if r is greater than n
    long long numerator = factorial[n];
    long long denominator = (factorial[r] * factorial[n - r]) % MOD;
    return (numerator * modInverse(denominator)) % MOD;
}

    long long modularExponentiation(long long x, long long y, long long mod) {
    long long result = 1;
    x = x % mod; // Take mod of x to avoid overflow
    
    while (y > 0) {
        // If y is odd, multiply x with result
        if (y % 2 == 1) {
            result = (result * x) % mod;
        }
        // y must be even now
        y = y >> 1; // Equivalent to y / 2
        x = (x * x) % mod; // Square x
    }
    
    return result;
}

    ll helper(int level, int filled, int n,int x, int y) {
        if (level == n) {
            return modularExponentiation(y,filled,MOD);
        }
        if(dp[level][filled] !=  -1)return dp[level][filled];
        
        if (filled == x) {
            return dp[level][filled] = (x%MOD*1ll*helper(level+1,filled,n,x,y)%MOD)%MOD;
        }
        return dp[level][filled] = (filled%MOD*1ll*helper(level+1,filled,n,x,y)%MOD + (x-filled)%MOD *1ll * helper(level+1,filled + 1,n,x,y)%MOD)%MOD;
    }

    int numberOfWays(int n, int x, int y) {
        memset(dp, -1, sizeof dp);
        // factorial = vector<ll>(1001);
        // computeFactorials();

        int ans =  helper(0,0,n,x,y);

        return ans;

    }
};",1420115236
himanshu dhingra,himanshudhingra,322,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        unordered_map <int,int> mp;

        for (int i = -1000;i<=1000;i++) {
            int oir = ((i)|(i+1));

            if (mp.find(oir) == mp.end()) {
                mp[oir] = i;
            }
            
        }

        for (auto & it : nums) {
            if(mp.find(it)!=mp.end()) {
                ans.push_back(mp[it]);
            } else {
                ans.push_back(-1);
            }
        }

        return ans;
    }
};",1420001132
himanshu dhingra,himanshudhingra,322,3611,cpp,"typedef long long ll;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto & it : nums) {
            ll temp = 2e9;
            for (ll i = 0;(1ll<<i) < it;i++) {
                ll a = it - (1ll<<i);
                ll b = (a + 1);
                if ((a|b) == it) {
                    temp = min(temp, a);
 
                }
            }
            if (temp == 2e9) {
                temp = -1;
            }
            ans.push_back(temp);
        }
        return ans;
    }
};


",1420020343
Karishma Chaudhary,Karishma_chaudhary,323,3487,cpp,"class Solution {
public:
    void solve(){
        int ghgggh=0;
        int dfssdfjds=463364;
        int fdsg=9;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int ghu=90;
         int n = source.length();
         solve();
        int m = pattern.length();
        int size=m;
        std::vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        solve();
        std::vector<bool> isTarget(n, false);
        solve();
        for (int idx : targetIndices) {
            isTarget[idx] = true;
            int c=0;
        }
        solve();
        int flag=8;
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    int g=93;
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        solve();
        solve();
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420060504
Karishma Chaudhary,Karishma_chaudhary,323,3604,cpp,"class Solution {
public:
    int func(int a) {
        int x = a;
        int c = x;
        int fgdhsf = 788;
        return 4;
    }
    void solveAproblem() {
        int c = func(6);
        int fgshhjs = 577;
        int hfdsgfsj = 554642;
    }
    static const int BOB=1e8+2;
    static const int MOD = 1e9 + 7;
 
    int numberOfWays(int n, int x, int y) {
        solveAproblem();
        vector<std::vector<int>> binomialCoeff(x + 1, vector<int>(x + 1, 0));
        solveAproblem();
        int hfjfsdhgk = 574343;
        for (int i = 0; i <= x; ++i) {
            binomialCoeff[i][0] = 1;
            solveAproblem();
            for (int j = 1; j <= i; ++j) {
                binomialCoeff[i][j] =
                    (binomialCoeff[i - 1][j - 1] + binomialCoeff[i - 1][j]) %
                    MOD;
            }
            solveAproblem();
        }
        solveAproblem();
        int fdhjsghs = 34526;
        solveAproblem();
        vector<vector<int>> stirlingNumbers(n + 1, std::vector<int>(x + 1, 0));
        solveAproblem();
        stirlingNumbers[0][0] = 1;
        solveAproblem();
        for (int i = 1; i <= n; ++i) {
            int gsjjdh = 437;
            for (int j = 1; j <= x; ++j) {
                int hgf = 90;
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] +
                                         stirlingNumbers[i - 1][j - 1]) %
                                        MOD;
            }
        }
        solveAproblem();
        vector<int> fact(x + 1, 1);
        int hfhdh = 999;
        solveAproblem();
        for (int i = 1; i <= x; ++i) {
            int hdfhs;
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
            int fgg = 8;
        }
        solveAproblem();
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPower = 1;
            int powuh = 9;
            for (int i = 0; i < k; ++i) {
                yPower = (yPower * y) % MOD;
            }
            solveAproblem();
            totalWays = (totalWays +
                         (1LL * binomialCoeff[x][k] * stirlingNumbers[n][k] %
                          MOD * fact[k] % MOD * yPower % MOD)) %
                        MOD;
        }
        solveAproblem();
        return totalWays;
    }
};
",1420108910
Karishma Chaudhary,Karishma_chaudhary,323,3605,cpp,"class Solution {
public:
    void solve(){
        int a=9;
        int b=88;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        solve();
        int n = nums.size();
        int m=1000;
        solve();
        vector<int> ans(n, -1); 
        solve();
   
    for (int i = 0; i < n; i++) {
        for (int x = 0; x <= nums[i]; x++) {
            solve();
            if ((x | (x + 1)) == nums[i]) {
                ans[i] = x;
                break;
            }
            solve();
        }
    }

    return ans;
    }
};",1419997537
Karishma Chaudhary,Karishma_chaudhary,323,3611,cpp,"class Solution {
public:
    void solve() {
        int a = 8;
        int b = 98;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        solve();
       int n = nums.size();
       solve();
        vector<int> result(n);
        solve();
        int m=984;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int sixe=988;
            int minimalResult = INT_MAX;
            int minmi=975;
            solve();
            bool isFound = false;
            solve();
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int vgfh=965;
                    int candidate = num & ~(1 << bit);
                 
                    if (candidate < 0) continue;
                    
                    int hgfdhf=864;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalResult) {
                            minimalResult = candidate;
                            isFound = true;
                        }
                    }
                    solve();
                }
            }
            
            if (isFound) {
                result[i] = minimalResult;
            } else {
                result[i] = -1;
            }
        }
        solve();
        
        return result;
    }
};",1420051053
Roll_Num_44,Roll_Num_44,324,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <limits>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }

    int findMax(const vector<int>& nums) {
        int maxVal = numeric_limits<int>::min();
        for (int num : nums) {
            if (num > maxVal) {
                maxVal = num;
            }
        }
        return maxVal;
    }

    int findMin(const vector<int>& nums) {
        int minVal = numeric_limits<int>::max();
        for (int num : nums) {
            if (num < minVal) {
                minVal = num;
            }
        }
        return minVal;
    }

    int calculateSum(const vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum;
    }

    bool containsPattern(const string& source, const string& pattern) {
        return source.find(pattern) != string::npos;
    }

    int countTargets(const vector<int>& targetIndices) {
        return targetIndices.size();
    }
};

",1420050322
Roll_Num_44,Roll_Num_44,324,3604,cpp,"#define ll long long

class Solution {
public:
    const int MODULO = 1e9 + 7;

    ll power_mod(ll base, ll exp, int mod) {
        ll result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp % 2)
                result = (result * base) % mod;
            base = (base * base) % mod;
            exp >>= 1;
        }
        return result;
    }

    ll inverse_mod(ll a, int mod) {
        return power_mod(a, mod - 2, mod);
    }

    void calculate_factorials(int max_val, vector<ll>& fact, vector<ll>& inv_fact) {
        fact[0] = inv_fact[0] = 1;
        for (int i = 1; i <= max_val; i++)
            fact[i] = (fact[i - 1] * i) % MODULO;
        inv_fact[max_val] = inverse_mod(fact[max_val], MODULO);
        for (int i = max_val - 1; i >= 1; i--)
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MODULO;
    }

    ll combination(int n, int r, vector<ll>& fact, vector<ll>& inv_fact) {
        if (r < 0 || r > n)
            return 0;
        return (((fact[n] * inv_fact[r]) % MODULO) * inv_fact[n - r]) % MODULO;
    }

    int multiply_mod(int a, int b) {
        return (static_cast<ll>(a) * b) % MODULO;
    }

    int add_mod(int a, int b) {
        return (a + b) % MODULO;
    }

    ll subtract_mod(ll a, ll b) {
        return (a - b + MODULO) % MODULO;
    }

    ll divide_mod(ll a, ll b) {
        return multiply_mod(a, inverse_mod(b, MODULO));
    }

    int numberOfWays(int n, int x, int y) {
        int max_val = max(n, x);
        vector<ll> fact(max_val + 1), inv_fact(max_val + 1);
        calculate_factorials(max_val, fact, inv_fact);

        vector<ll> S(x + 1, 0), prev_S(x + 1, 0);
        S[0] = 0;
        S[1] = 1;

        for (int i = 2; i <= n; i++) {
            prev_S = S;
            for (int k = 1; k <= min(i, x); k++) {
                S[k] = add_mod(multiply_mod(k, prev_S[k]), prev_S[k - 1]);
            }
        }

        ll total_ways = 0;
        for (int k = 1; k <= min(n, x); k++) {
            ll ways = combination(x, k, fact, inv_fact);
            ways = multiply_mod(ways, fact[k]);
            ways = multiply_mod(ways, S[k]);
            ways = multiply_mod(ways, power_mod(y, k, MODULO));
            total_ways = add_mod(total_ways, ways);
        }

        return (int)total_ways;
    }
};
",1420081951
Roll_Num_44,Roll_Num_44,324,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 0; j <= nums[i]; ++j) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420009034
Roll_Num_44,Roll_Num_44,324,3611,cpp,"#include <iostream>
#include <vector>
#include <limits>

using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int> &nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int minAns = -1;
            for (int bit = 0; bit <= 30; ++bit) {
                if (nums[i] & (1 << bit)) {
                    int j = nums[i] - (1 << bit);
                    if (j >= 0 && ((j | (j + 1)) == nums[i])) {
                        if (minAns == -1 || j < minAns) {
                            minAns = j;
                        }
                    }
                }
            }
            ans[i] = minAns;
        }
        return ans;
    }

    int findMax(const vector<int>& nums) {
        int maxVal = numeric_limits<int>::min();
        for (int num : nums) {
            if (num > maxVal) {
                maxVal = num;
            }
        }
        return maxVal;
    }

    int findMin(const vector<int>& nums) {
        int minVal = numeric_limits<int>::max();
        for (int num : nums) {
            if (num < minVal) {
                minVal = num;
            }
        }
        return minVal;
    }

    int calculateSum(const vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum;
    }

    int countBits(int num) {
        int count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }

    bool isPowerOfTwo(int num) {
        return (num > 0) && ((num & (num - 1)) == 0);
    }
};
",1420053160
Ayush Sharma,ayush-018,325,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        vector<int> dp(pattern.size()+ 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isTarget(source.size(), false);
        bool check = true;
        for (int idx : targetIndices) {
            isTarget[idx] = check;
        }
        
        for (int i = 0; i < source.size(); ++i) {
            for (int j = pattern.size(); j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[pattern.size()] == numeric_limits<int>::max() ? 0 : dp[pattern.size()]);
    }
};",1420057341
Ayush Sharma,ayush-018,325,3604,cpp,"class Solution {
    const int MOD = 1e9 + 7;
public:
    int numberOfWays(int n, int x, int y) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        vector<vector<int>> resultArray(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            resultArray[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                resultArray[i][j] = (resultArray[i - 1][j - 1] + resultArray[i - 1][j]) % MOD;
            }
        }
        int ans;
        vector<vector<int>> tempA(n + 1, vector<int>(x + 1, 0));
        tempA[0][0] = 1; 
        for (int i = 1; i <= n; i++) { 
            for (int j = 1; j <= x; j++) { 
                tempA[i][j] = (1LL * j * tempA[i - 1][j] + tempA[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }

        long long totalW = 0;
        for (int k = 1; k <= x; k++) {
            long long yPower = 1;
            for (int i = 0; i < k; i++) {
                yPower = (yPower * y) % MOD;
            }
            totalW = (totalW + (1LL * resultArray[x][k] * tempA[n][k] % MOD * factorial[k] % MOD * yPower % MOD)) % MOD;
        }
        ans=totalW;
        return ans;
    }
};
",1420102571
Ayush Sharma,ayush-018,325,3605,cpp,"class Solution {
    private:
    int findS(int num) {
    int c=-1;
    for (int x = 0; x < num; ++x) {
        if ((x | (x + 1)) == num) {
            return x;
        }
    }
    return c;
}
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        vector<int> ans;
        for (int num : nums) {
            ans.push_back(findS(num));
        }
        return ans;
    }
};",1420008915
Ayush Sharma,ayush-018,325,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = nums.size();
    vector<int> ans(n);
    int c = -1;
    for (int i = 0; i < n; i++) {
        int num = nums[i];
        int minimalAns = INT_MAX;
        bool found = false;

        for (int bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {
                int candidate = num & ~(1 << bit);
                
                if (candidate < 0) continue;

                if ((candidate | (candidate + 1)) == num) {
                    if (candidate < minimalAns) {
                        minimalAns = candidate;
                        found = true;
                    }
                }
            }
        }
        
        if (found) {
            ans[i] = minimalAns;
        } else {
            ans[i] = c;
        }
    }
    
    return ans;
    }
};",1420046742
Shrivathsa,psshrivathsa784,326,3487,cpp,"#define forz(i,a,b) for(int i = a;i<b;i++)
#define N 3001

int dp[N][N]; //dp[i][j] is the max number of removals i can make when i can get the pattern
// from j to m using the i to n.

int solve(int i, int j, string &source, string &pattern, vector<int>& target){

    int n = source.size();
    int m = pattern.size();

    if (i == n){
        if (j == m){
            return 0;
        }
        else{
            return -1e6;
        }
    }

    int ind = lower_bound(target.begin(), target.end(), i) - target.begin();

    if (j == m){
        return target.size()-ind;
    }

    if (dp[i][j] == -1){
        if (ind<target.size() && target[ind] == i){
            dp[i][j] = max(1 + solve(i+1, j, source, pattern, target), solve(i+1, j + (pattern[j] == source[i]), source, pattern, target));
        }
        else{
            dp[i][j] = solve(i+1, j + (pattern[j] == source[i]), source, pattern, target);
        }
    }

    return dp[i][j];
    
}

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        forz(i,0,n+1){
            forz(j,0,m+1){
                dp[i][j] = -1;
            }
        }

        return solve(0,0,source,pattern,targetIndices);
    }
};",1420061862
Shrivathsa,psshrivathsa784,326,3604,cpp,"#include <vector>
using namespace std;

const int mod = 1e9 + 7;

class Solution {
public:
    vector<vector<long long>> S;
    vector<long long> fact;
    vector<long long> invFact;

    Solution() {
        int n = 1000;
        int k = 1000;
        S.resize(n + 1, vector<long long>(k + 1, 0));

        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            S[i][0] = 0;
            S[i][1] = 1;
        }
        for (int j = 1; j <= k; j++) {
            S[0][j] = 0;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 2; j <= min(i, k); j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % mod;
            }
        }

        fact.resize(n + 1, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = (i * fact[i - 1]) % mod;
        }

        invFact.resize(n + 1, 1);
        invFact[n] = power(fact[n], mod - 2, mod);

        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = ((i + 1) * invFact[i + 1]) % mod;
        }
    }

    long long distribute_balls(int x, int y) {
        if (y > x) {
            return 0;
        }
        return (fact[y] * S[x][y]) % mod;
    }

    long long ncr(int a, int b) {
        return ((fact[a] * invFact[b]) % mod * invFact[a - b]) % mod;
    }

    int numberOfWays(int n, int x, int y) {
        long long ans = 0;
        for (int i = 0; i <= x; i++) {
            ans += ((distribute_balls(n, i) * ncr(x, i)) % mod * power(y, i, mod)) % mod;
            ans %= mod;
        }
        return ans;
    }

private:
    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        base = base % mod;
        while (exp > 0) {
            if (exp & 1) {
                result = (result * base) % mod;
            }
            exp >>= 1;
            base = (base * base) % mod;
        }
        return result;
    }
};
",1420115566
Shrivathsa,psshrivathsa784,326,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1 for i in range(n)]
        for i in range(n):
            if nums[i]%2:
                for j in range(33):
                    if ((1<<j)&nums[i]) == 0:
                        ans[i] = nums[i]^(1<<(j-1))
                        break
        return ans",1420002632
Shrivathsa,psshrivathsa784,326,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1 for i in range(n)]
        for i in range(n):
            if nums[i]%2:
                for j in range(33):
                    if ((1<<j)&nums[i]) == 0:
                        ans[i] = nums[i]^(1<<(j-1))
                        break
        return ans",1420002116
Gopal Gupta,gupta_gopal,327,3487,cpp,"class Solution {
public:
    #define ll long long
    int maxRemovals(string s,string p,vector<int>&t){
        ll n=s.size();
        ll m=p.size();
        ll pos=t.size();
        vector<ll>dp(m+10,1e9),del(n+10,0);
        dp[0]=0;
        for(auto i:t) del[i]=1;
        for(ll i=0;i<n;i++){
            for(ll j=m;j>0;j--){
                if(dp[j-1]!=1e9 && s[i]==p[j-1]){
                    dp[j]=min(dp[j],del[i]+dp[j-1]);
                }
            }
        }
        if(dp[m]==1e9) return pos;
        return pos-dp[m];
    }
};",1420122233
Gopal Gupta,gupta_gopal,327,3604,cpp,"class Solution {
public:
    #define ll long long
    
    ll power(ll a,ll b){
    static ll mod=1e9+7;
    if(b==0) return 1;
    if(a==1 || b==1) return a;
    if(b%2==0){
        ll c=power(a,b/2);
        return (c*c)%mod;
    }
    else{
        ll c=power(a,b/2);
        return ((a*c)%mod*c)%mod;
    }
}
    
    int numberOfWays(int n, int x, int y){
        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
        ll mod=1e9+7;
        vector<vector<ll>>dp(n+1,vector<ll>(x+1,0));
        dp[0][0]=1;
        for(ll i=1;i<=n;i++){
            for(ll j=1;j<=x;j++){
                dp[i][j]=(j*dp[i-1][j]+dp[i-1][j-1])%mod;
            }
        }
        vector<ll>per(1010);
        per[0]=per[1]=1;
        for(ll i=2;i<=1000;i++){
            per[i]=(per[i-1]*i)%mod;
        }
        ll ans=0;
        for(ll i=1;i<=min(n,x);i++){ // grp cnt
            ll n1=per[x];
            ll d1=(per[i]*per[x-i])%mod;
            ll w=(n1*power(d1,mod-2))%mod; // ways_of_choosing_grp_stages
            ll ways=(dp[n][i]*per[i])%mod;
            ll y_ways=power(y,i);
            ll cur_ans=(((w*ways)%mod)*y_ways)%mod;
            // cout<<i<<"" ""<<w<<"" ""<<ways<<"" ""<<y_ways<<"" ""<<cur_ans<<'\n';
            // cout<<i<<"" ""<<w<<"" ""<<num<<"" ""<<den<<"" ""<<ways<<"" ""<<y_ways<<"" ""<<cur_ans<<'\n';
            ans=(ans+cur_ans)%mod;
        }
        return ans;
    }
};",1420088206
Gopal Gupta,gupta_gopal,327,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>&v){
        vector<int>ans;
        for(auto i:v){
            if(i==2){
                // cout<<-1<<""   \n"";
                ans.push_back(-1);
            }
            else{
                // int next_big=i+1;
                // if(next_big&(next_big-1)){
                //     ans.push_back(i-1);
                // }
                // else{
                //     // cout<<next_big;
                //     ans.push_back((next_big/2)-1);
                // }
                long long bit=1;
                while(i&bit) bit*=2;
                bit/=2;
                ans.push_back(i-bit);
            }
        }
        return ans;
    }
};",1420005099
Gopal Gupta,gupta_gopal,327,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int>ans;
        for(auto i:v){
            if(i==2){
                // cout<<-1<<""   \n"";
                ans.push_back(-1);
            }
            else{
                // int next_big=i+1;
                // if(next_big&(next_big-1)){
                //     ans.push_back(i-1);
                // }
                // else{
                //     // cout<<next_big;
                //     ans.push_back((next_big/2)-1);
                // }
                long long bit=1;
                while(i&bit) bit*=2;
                bit/=2;
                ans.push_back(i-bit);
            }
        }
        return ans;
    }
};",1420005954
Aayush Suthar,aayushsuthar2004,328,3487,cpp,"class Solution {
public:

    int solve( string& s,  string& t , vector<int>& visit , vector<int>& pref , int i , int j , vector<vector<int>>& dp ){
        int n = s.size() , m = t.size();
        if( i == n ){
            if(j == m){
                return 0;
            }else{
                return INT_MIN;
            }
        }
        if( j == m ){
            return pref[i];
        }

        if(dp[i][j] != -1){
            return dp[i][j];
        }

        if( s[i] != t[j] ){
            return dp[i][j] = (visit[i] == 1) + solve(s , t , visit , pref , i+1 , j , dp);
        }else{
            return dp[i][j] = max( (visit[i] == 1) + solve(s , t , visit , pref , i+1 , j , dp) , solve(s , t , visit , pref , i+1 , j+1 , dp) );
        }
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> visit(source.size() , 0);
        vector<int> pref(source.size() , 0);
        for(auto it : targetIndices){
            visit[it] = 1;
        }   
        vector<vector<int>> dp(source.size()+1,vector<int>(pattern.size()+1 , -1));
        for(int i = source.size()-1 ; i >= 0 ; i--){
            pref[i] = (visit[i] == 1) + ( (i + 1 < source.size()) ? pref[i+1] : 0 );
        }
        int ans = solve(source , pattern , visit , pref , 0 , 0 , dp);
        return ans;
    }
};",1420052290
Aayush Suthar,aayushsuthar2004,328,3604,cpp,"class Solution {
public:
const int MOD = 1e9 + 7; 

long long int power(long long int x, long long int y, long long int p){
    long long int res = 1;
    while (y > 0) {
        if (y % 2 == 1)
            res = (res * x)%p;
        y = y >> 1;
        x = (x * x)%p;
    }
    return res % p;
}


long long int nCrSum( long long n , vector<long long int>& ways ){
    long long int ans = 0;
    long long int temp = 1;
    for(long long i = 1 ; i <= n-1 ; i++){
        temp = ((temp*(n - i + 1))%MOD)%MOD;
        temp = (temp * power(i , MOD - 2 , MOD))%MOD;
        ans = (ans + (temp*ways[n - i])%MOD )%MOD;
    }
    return ans%MOD;
}

    int numberOfWays(int n, int x, int y) {
        vector<long long int> ways(x+2);
        ways[1] = 1ll;

        for(long long int i = 2 ; i <= x ; i++){
            ways[i] = ((power(i , n , MOD) - nCrSum(i , ways))%MOD + MOD)%MOD;
        }
        long long int X = x;
        long long int Y = y;
        long long int N = n;
        long long int normal_y = y;
        
        long long int temp = X;  
        long long int ans = (X*Y)%MOD;

        for(long long int i = 2 ; i <= x ; i++){
            temp = (( temp*(X - i + 1) )%MOD);
            temp = (temp * power(i , MOD - 2 , MOD))%MOD;
            Y = (Y*normal_y)%MOD;
            ans = (ans + ((( temp*Y )%MOD)*ways[i]%MOD)%MOD)%MOD;
        }

    return ans%MOD;
    }
};",1420116138
Aayush Suthar,aayushsuthar2004,328,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for(int i = 0 ; i < nums.size() ; i++){
            if( nums[i] == 2 ){
                ans[i] = -1;
            }else{
                bitset<32> b(nums[i]);
                int idx = 0;
                for(int i = 0 ; i < 31 ; i++){
                    if( b[i] == 0 ){
                        idx = i;
                        break;
                    }
                }
                b[idx-1] = 0;
                ans[i] = b.to_ulong(); 
            }
        }

    return ans;
    }
};",1420001698
Aayush Suthar,aayushsuthar2004,328,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for(int i = 0 ; i < nums.size() ; i++){
            if( nums[i] == 2 ){
                ans[i] = -1;
            }else{
                bitset<32> b(nums[i]);
                int idx = 0;
                for(int i = 0 ; i < 31 ; i++){
                    if( b[i] == 0 ){
                        idx = i;
                        break;
                    }
                }
                b[idx-1] = 0;
                ans[i] = b.to_ulong(); 
            }
        }   
    
    return ans;
    }
};",1420003579
Harsh_kunwar,Harsh_kunwar,329,3487,cpp,"

class Solution
{
public:
    int dp[3001][3001];

    int f(int i, int j, string &s, string &t, vector<int> &mark)
    {
        if (i == s.size())
        {
            if (j == t.size())
            {
                return dp[i][j] = 0;
            }
            else
            {
                return dp[i][j] = -1e9;
            }
        }

        if (j == t.size())
        {
            if (mark[i] == 1)
            {
                dp[i][j] = 1 + f(i + 1, j, s, t, mark);
            }
            else
            {
                dp[i][j] = f(i + 1, j, s, t, mark);
            }
            return dp[i][j];
        }
        if (dp[i][j] != -1)
        {
            return dp[i][j];
        }
        int ans = -1e9;

        if (mark[i] == 0)
        {
            if (s[i] == t[j])
            {
                ans = f(i + 1, j + 1, s, t, mark);
            }
            else
            {
                ans = f(i + 1, j, s, t, mark);
            }
        }
        else
        {
            if (s[i] == t[j])
            {
                int keep = f(i + 1, j + 1, s, t, mark);
                int remove = 1 + f(i + 1, j, s, t, mark);
                ans = max(keep, remove);
            }
            else
            {
                ans = 1 + f(i + 1, j, s, t, mark);
            }
        }

        dp[i][j] = ans;
        return ans;
    }

    int maxRemovals(string &s, string &t, vector<int> &a)
    {
        int n = s.size();
        vector<int> mark(n, 0);
        for (auto &idx : a)
        {
                mark[idx] = 1;
            
        }
        memset(dp, -1, sizeof(dp));

        int result = f(0, 0, s, t, mark);
        return max(result, 0);
    }
};
",1420079590
Harsh_kunwar,Harsh_kunwar,329,3604,cpp,"class Solution
{
public:
    const long long mod = 1e9 + 7;
    long long power(long long x, long long y)
    {
        long long z = 1;
        x = x % mod;
        while (y > 0)
        {
            if (y & 1)
                z = (z * x) % mod;
            y = y >> 1;
            x = (x * x) % mod;
        }
        return z;
    }
    long long fact[1001];
    long long inv[1001];
    void f()
    {
        fact[0] = 1;
        for (long long i = 1; i <= 1000; i++)
        {
            fact[i] = fact[i - 1] * i % mod;
        }

        inv[1000] = power(fact[1000], mod - 2);
        for (long long i = 999; i >= 0; i--)
        {
            inv[i] = inv[i + 1] * (i + 1) % mod;
        }
    }

    long long comb(long long x_val, long long k_val)
    {
        if (k_val > x_val)
            return 0;

        if (k_val < 0 || k_val > x_val)
        {
            return 0;
        }
        return fact[x_val] * inv[k_val] % mod * inv[x_val - k_val] % mod;
    }

    long long numberOfWays(long long n, long long x, long long y)
    {
        f();
        long long K = min(x, n);
        vector<vector<long long>> dp(n + 1, vector<long long>(K + 1, 0));
        dp[0][0] = 1;
        for (long long i = 1; i <= n; i++)
        {
            long long upper = min(i, K);
            for (long long j = 1; j <= upper; j++)
            {
                dp[i][j] = (dp[i - 1][j - 1] + (j * dp[i - 1][j]) % mod) % mod;
            }
        }

        vector<long long> pw(K + 1, 1);
        for (long long k = 1; k <= K; k++)
        {
            pw[k] = pw[k - 1] * y % mod;
        }
        long long ans = 0;
        for (long long k = 1; k <= K; k++)
        {
            long long C = comb(x, k);
            long long yk = pw[k];
            long long dpk = dp[n][k];
            long long term = C * yk % mod;
            term = term * dpk % mod;
            term = term * fact[k] % mod;
            ans = (ans + term) % mod;
        }

        return ans;
    }
};
",1420116152
Harsh_kunwar,Harsh_kunwar,329,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(1001,1e5);
        for(int i=2;i<=1000;i++){
            for(int j=0;j<=i;j++){
                if((j|(j+1))==i){
                    ans[i]=min(j,ans[i]);
                }
            }
        }
        vector<int>res;
        for(auto &i:nums){
            if(ans[i]==1e5){
                ans[i]=-1;

            }
        res.push_back(ans[i]);

        }
        return res;

        
    }
};",1420008739
Harsh_kunwar,Harsh_kunwar,329,3611,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &nums)
    {
        vector<int> res;

        for (auto  p : nums)
        {
            int ans = INT_MAX;
            int i = __lg(p);

            for (int bit_pos = 0; bit_pos <= i;bit_pos++)
            {
                if (p & (1 << bit_pos))
                {
                    int k_candidate = p & ~(1 << bit_pos);
                    if ((k_candidate | (k_candidate + 1)) == p)
                    {
                        ans = min(ans, k_candidate);
                    }
                }
            }

            if (ans == INT_MAX)
            {
                res.push_back(-1);
            }
            else
            {
                res.push_back(ans);
            }
        }

        return res;
    }
};",1420031283
dirigibility,dirigibility,330,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        @cache
        def f(i,j):
            if i == len(source):
                return 0 if j == len(pattern) else -inf
            if j == len(pattern):
                return (i in targetIndices)+f(i+1,j)
            return max(f(i+1,j)+(i in targetIndices),f(i+1,j+1) if source[i] == pattern[j] else -inf)
        try:
            return f(0,0)
        finally:
            f.cache_clear()",1420033752
dirigibility,dirigibility,330,3604,python3,"mod = 10**9+7

@cache
def binom(n,k):
    if not 0 <= k <= n:
        return 0
    if n == k == 0:
        return 1
    return (binom(n-1,k-1)+binom(n-1,k))%mod

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # @cache
        # def f(n,x):
        #     if x == 0:
        #         return int(n == 0)
        #     if n == 0:
        #         return 1
        #     return (y*sum(binom(n,k)*f(n-k,x-1) for k in range(1,n+1))+f(n,x-1))%mod
        # try:
        #     return f(n,x)
        # finally:
        #     f.cache_clear()
        def f(k):
            return (pow(k,n,mod) + sum((-1 if (k-j)%2 else 1)*binom(k,j)*pow(j,n,mod) for j in range(1,k)))%mod
        return sum(binom(x,k)*pow(y,k,mod)*f(k) for k in range(1,min(n,x)+1))%mod
",1420116517
dirigibility,dirigibility,330,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for n in nums:
            if n == 2:
                result.append(-1)
            else:
                bit = 1
                while bit <= n:
                    if not n&bit:
                        break
                    bit <<= 1
                result.append(n-(bit>>1))
        return result",1420003048
dirigibility,dirigibility,330,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for n in nums:
            if n == 2:
                result.append(-1)
            else:
                bit = 1
                while bit <= n:
                    if not n&bit:
                        break
                    bit <<= 1
                result.append(n-(bit>>1))
        return result",1420002789
fxfxxxfxx,fxfxxxfxx,331,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size(), r = targetIndices.size();
        vector<int> V(n);
        for (int idx : targetIndices) V[idx] = 1;

        // M[i] := cost i, farest match
        vector<int> M(m+1);
        for (int idx = 0; idx < n; idx++) {
            for (int k = m-1; k >= 0; k--) {
                if (M[k] == m) continue;
                char tar = pattern[M[k]];
                if (source[idx] == tar) {
                    M[k+1] = max(M[k+1], M[k] + 1);
                    if (!V[idx]) M[k] += 1;
                }
                // cout << idx << "" "" << k << "" "" << M[k] << endl;
            }
        }
        for (int k = 0; k <= m; k++)
            if (M[k] == m) return r - k;
        std::unreachable();
    }
};",1420044418
fxfxxxfxx,fxfxxxfxx,331,3604,python3,"M = 1000000007
F = [1] * 1001
for i in range(1, 1001):
    F[i] = (F[i-1] * i) % M

R = [1] * 1001
for i in range(1, 1001):
    R[i] = pow(F[i], -1, M)

def C(n, k):
    return (F[n] * R[k] * R[n-k]) % M

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # A_k = k^n - (k-1)^n*C(k, k-1) + (k-2)^n*C(k, k-2)
        A = [0] * (x + 1)
        for k in range(1, min(n, x) + 1):
            v = pow(k, n, M) * C(x, k)
            for i in range(1, k):
                r = k - i
                add = (C(x-r, i) * A[r]) % M
                v = (v - add) % M
            A[k] = v

        ans = 0
        for k in range(1, x+1):
            ans = (ans + pow(y, k, M) * A[k]) % M
        return ans
        ",1420116573
fxfxxxfxx,fxfxxxfxx,331,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto f = [](int x) {
            if (x == 2) return -1;
            int ret = 1;
            while (x & (ret)) {
                ret <<= 1;
            }
            return x - (ret >> 1);
        };
        vector<int> V;
        for (int x: nums) {
            int y = f(x);
            V.push_back(y);
        }
        return V;
    }
};",1420001713
fxfxxxfxx,fxfxxxfxx,331,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto f = [](int x) {
            if (x == 2) return -1;
            int ret = 1;
            while (x & (ret)) {
                ret <<= 1;
            }
            return x - (ret >> 1);
        };
        vector<int> V;
        for (int x: nums) {
            int y = f(x);
            V.push_back(y);
        }
        return V;
    }
};",1420001390
optimus_np,optimus_np,332,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> dp(pattern.size() + 1, INT_MAX);
        dp[0] = 0;
        
        vector<bool> temp(source.size(), false);
        for (int i = 0; i < targetIndices.size(); i++) {
            temp[targetIndices[i]] = true; 
        }
        for (int i = 0; i < source.size(); i++) {
            for (int j = pattern.size(); j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (temp[i] ? 1 : 0));
                }
            }
        }
        sort(source.begin(), source.end());
        return targetIndices.size() - (dp[pattern.size()] == INT_MAX ? 0 : dp[pattern.size()]);
    }
};
",1420083354
optimus_np,optimus_np,332,3604,cpp,"#define MOD 1000000007
#define ll long long

class Solution {
public:
    int numberOfWays(int performer_n, int stage_x, int stage_y) {
        vector<ll> v = {performer_n, stage_x, stage_y};
        vector<vector<ll>> v1(stage_x + 1, vector<ll>(stage_x + 1, 0));
        unordered_map<ll,ll> m;
        for (int i = 0; i <= stage_x; i++) {
            v1[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                v1[i][j] = (v1[i - 1][j - 1] + v1[i - 1][j]) % MOD;
            }
        }
        
        vector<vector<ll>> v2(performer_n + 1, vector<ll>(stage_x + 1, 0));
        v2[0][0] = 1;
        for (int i = 1; i <= performer_n; i++) {
            for (int j = 1; j <= stage_x; j++) {
                v2[i][j] = (j * v2[i - 1][j] + v2[i - 1][j - 1]) % MOD;
            }
        }
        
        vector<ll> ans(stage_x + 1, 1);
        for (int i = 1; i <= stage_x; i++) {
            ans[i] = (ans[i - 1] * i) % MOD;
        }
        
        ll finalans = 0;
        for (int l = 1; l <= stage_x; l++) {
            ll w = 1;
            for (int p = 0; p < l; p++) {
                w = (ll)(w * stage_y) % MOD;
            }
            finalans = (finalans + v1[stage_x][l] * v2[performer_n][l] % MOD * ans[l] % MOD * w % MOD) % MOD;
            m[l] = finalans; 
        }
        set<ll> st;
        for(auto it: m) {
            st.insert(it.first);
        }
        return finalans;
    }
};",1420110314
optimus_np,optimus_np,332,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> finalResult(nums.size(), -1);
        map<int,bool> m;    
        for (int i = 0; i < nums.size(); i++) {
            int minCandidate = INT_MAX;
            bool isFound = false;
            for (int w = 0; w <= 30; w++) {
                if ((nums[i] >> w) & 1) {
                    int p = nums[i] & ~(1 << w);
                    if (p < 0) continue;
                    
                    if ((p | (p + 1)) == nums[i]) {
                        if (p < minCandidate) {
                            minCandidate = p;
                            isFound = true;
                            m[i] = isFound;
                        }
                    }
                }
            }
            if (isFound) {
                finalResult[i] = minCandidate;
            } else {
                finalResult[i] = -1;
            }
        }
        vector<bool> tmep;
        for(auto it: m) {
            tmep.push_back(it.second);
        }
        return finalResult;
    }
};",1420098871
optimus_np,optimus_np,332,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> finalResult(nums.size(), -1);
        map<int,bool> m;    
        for (int i = 0; i < nums.size(); i++) {
            int minCandidate = INT_MAX;
            bool isFound = false;
            for (int w = 0; w <= 30; w++) {
                if ((nums[i] >> w) & 1) {
                    int p = nums[i] & ~(1 << w);
                    if (p < 0) continue;
                    
                    if ((p | (p + 1)) == nums[i]) {
                        if (p < minCandidate) {
                            minCandidate = p;
                            isFound = true;
                            m[i] = isFound;
                        }
                    }
                }
            }
            if (isFound) {
                finalResult[i] = minCandidate;
            } else {
                finalResult[i] = -1;
            }
        }
        vector<bool> tmep;
        for(auto it: m) {
            tmep.push_back(it.second);
        }
        return finalResult;
    }
};",1420098019
figuring-out,figuring-out,333,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();        
        
        vector<bool> isTarget(n, false);
        for(auto idx: targetIndices) isTarget[idx] = true;        
        
        vector<int> dp(m+1, n+1);
        dp[0] = 0;
        
        for(int i=0;i<n;i++){
            for(int j=m; j>=1; j--){
                
                if(source[i] == pattern[j-1]){
                    dp[j] = min(dp[j], dp[j-1] + isTarget[i]);
                }
                
            }
        }
        
        return targetIndices.size() - dp[m];
    }
};",1420033332
figuring-out,figuring-out,333,3604,cpp,"class Solution {
    
    const int MOD = 1e9+7;

    
    
    long long power_mod(long long a, long long b){
        
        long long res=1;
        a%=MOD;
        while(b>0){
            
            if(b&1) res = (res*a)%MOD;
            
            a = (a*a)%MOD;
            b>>=1;
        }
        
        return res;
    }
    
public:
    int numberOfWays(int n, int x, int y) {
        
        int max_k = min(n,x);
        
        vector<long long> fac(max_k+1, 1);
        for(int i=1;i<=max_k;i++) fac[i] = (fac[i-1]*i)%MOD;
        
        vector<long long> C(x+1, 0);
        C[0] = 1;
        for(int i=1;i<=x;i++){
            for(int j=min(i, x); j>=1; j--)
                C[j] = (C[j]+C[j-1])%MOD;
            
        }
        
        vector<vector<long long>> S(n+1, vector<long long>(max_k+1, 0));
        S[0][0] =1;
        for(int i=1;i<=n;i++){
            for(int k=1; k<=min(i, max_k); k++){
                S[i][k] = (S[i-1][k-1] + (k*S[i-1][k])%MOD)%MOD;
            }
        }
        
        
        vector<long long> y_pows(max_k+1, 1);
        for(int k=1;k<=max_k;k++) y_pows[k] = (y_pows[k-1]*y)%MOD;
        
        
        long long res =0;
        for(int k=1;k<=max_k;k++){
            long long comb = C[k];
            long long Stirling = S[n][k];
            long long factorial = fac[k];
            long long yk = y_pows[k];
            
            
            long long term = (comb*Stirling)%MOD;
            term = (term*factorial)%MOD;
            
            term = (term*yk)%MOD;
            res = (res+term)%MOD;
        }
        return res;
    }
};
",1420116883
figuring-out,figuring-out,333,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        
        for(auto num: nums){
            int res = -1;
            for(int a=0; a<num; a++){
                if( (a | (a+1)) == num ){
                    res = a;
                    break;
                }
            }
            ans.push_back(res);
        }
        return ans;
    }
};",1419997473
figuring-out,figuring-out,333,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        
        for(int idx=0; idx<n; idx++){
            int num = nums[idx];
            int res = INT32_MAX;
            for(int i=0; i<31; i++){
                if(num & (1<<i)){
                    
                    int x = (num&(~(1<<i))) | ((1<<i)-1);
                    
                    if( (x | (x+1)) == num)
                        res = min(res, x);
                    
                }
            }
            
            
            if(res!=INT32_MAX)
                ans[idx] = res;
            else
                ans[idx] = -1;
            
        }
        return ans;
    }
};",1420016569
Devashish21,Devashish21,334,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int> t) {
        vector<bool> tar(s.length(), false);
        for (int i : t) {
            tar[i] = true;
        }

        vector<int> dp(p.length() + 1, INT_MAX);
        dp[0] = 0;
        
        for (int i = 0; i < s.length(); ++i) {
            for (int j = p.length(); j > 0; --j) {

                if (s[i] == p[j-1] && dp[j-1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j-1] + tar[i]);
                }
            }
        }

        if (dp[p.length()] == INT_MAX)
            dp[p.length()]= 0;
        
        return t.size() - dp[p.length()];
    }
};
",1420089386
Devashish21,Devashish21,334,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {

        vector<int> f(x + 1, 1);

        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }

        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {

            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));

        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;

            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

        long long ans = 0;

        for (int k = 1; k <= x; ++k) {
            long long p = 1;

            for (int i = 0; i < k; ++i) {
                p = (p * y) % MOD;
            }
            ans = (ans + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * p % MOD)) % MOD;
        }
        return ans;
    }
};",1420123107
Devashish21,Devashish21,334,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans(nums.size(), -1);

        for (int i=0; i<nums.size(); i++){
            for (int j=0; j<=nums[i]; j++){
                if ((j | (j+1)) == nums[i]){
                    ans[i]= j;
                    break;
                }
            }
        }

        return ans;
    }
};",1420021743
Devashish21,Devashish21,334,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for (int i = 0; i < nums.size(); ++i) {
            bool f = false;
            int cur = nums[i];
            int mini = INT_MAX;
            
            for (int bit = 0; bit <= 30; ++bit) {
                if (((cur >> bit) & 1) == 1) {

                    int cand = cur & ~(1 << bit);
                    
                    if (cand < 0)
                        continue;
                    
                    if ((cand | (cand + 1)) == cur){

                        if (cand < mini){

                            mini = cand;
                            f = true;
                        }
                    }
                }
            }
            
            if(f){
                ans[i] = mini;
            }else{
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};
",1420108941
kd2425,kd2425,335,3487,python3,"class Solution:
    def maxRemovals(self,source: str,pattern: str,targetIndices: List[int]) -> int:
        n,m=len(source),len(pattern)
        target_set=set(targetIndices)
        ln=len(targetIndices)
        dp=[[inf] * (m+1) for _ in range(n+1)]
        dp[0][0]=0
        for i in range(n):
            for j in range(m+1):
                if dp[i][j]==inf:
                    continue
                
                if j<m and source[i]==pattern[j]:
                    if i in target_set:
                        cost=dp[i][j]+1
                    else:
                        cost=dp[i][j]
                    dp[i+1][j+1]=min(dp[i+1][j+1],cost)
                
                dp[i+1][j]=min(dp[i+1][j],dp[i][j])
        
        res=ln-dp[n][m]
        return res",1420073609
kd2425,kd2425,335,3604,python3,"class Solution:
    def numberOfWays(self,n: int,x: int,y: int) -> int:
            MOD=10**9+7
            max_val=max(n,x)
            factorial=[1]*(max_val+1)
            for i in range(1,max_val+1):
                factorial[i]=(factorial[i-1]*i)%MOD
            inv_fact=[1]*(max_val+1)
            inv_fact[max_val]=pow(factorial[max_val],MOD-2,MOD)
            for i in range(max_val,0,-1):
                inv_fact[i-1]=(inv_fact[i]*i)%MOD
            def comb(a: int,b: int) -> int:
                if b < 0 or b > a:
                    return 0
                return (factorial[a]*inv_fact[b]%MOD)*inv_fact[a-b]%MOD
            S=[0]*(x+1)
            S[0]=1
            for i in range(1,n+1):
                tmp=S.copy()
                for k in range(1,min(i,x)+1):
                    S[k]=(k*tmp[k]+tmp[k-1])%MOD
                S[0]=0  
            total=0
            for k in range(1,min(x,n)+1): 
                total=(total+comb(x,k)*S[k]%MOD*factorial[k]%MOD*pow(y,k,MOD)%MOD)%MOD
            return total
",1420097800
kd2425,kd2425,335,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for i in nums:
            v=False
            for x in range(i):
                if (x|(x+1))==i:
                    ans.append(x)
                    v = True
                    break
            if not v:
                ans.append(-1)
        return ans",1420001339
kd2425,kd2425,335,3611,python3,"# @cache
def l(p):
    return 1+l(p>>1) if p & 1 else 0
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for p in nums:
            if p<2:
                ans.append(-1)
                continue
            t=l(p)
            if t == 0:
                ans.append(-1)
            else:
                x=p-(1<<(t-1))
                if (x|(x+1))==p:
                    ans.append(x)
                else:
                    ans.append(-1)
        return ans",1420031565
Mighty Programmer,heartcodehacker,336,3487,cpp,"class Solution {
public:
    int countElementsGreaterOrEqual(set<int>& indices, int threshold) {
        auto it = indices.lower_bound(threshold);
        if (it == indices.end()) return 0;
        return distance(it, indices.end());
    }
    
    int computeMaxRemovals(int sourceIndex, int patternIndex, set<int>& indices, string &source, string &pattern, vector<vector<int>>& dp) {
        if (patternIndex == pattern.size()) return countElementsGreaterOrEqual(indices, sourceIndex);
        if (sourceIndex >= source.size()) return INT_MIN;

        if (dp[sourceIndex][patternIndex] != -1) return dp[sourceIndex][patternIndex];

        int maxRemovals = INT_MIN;
        
        if (indices.find(sourceIndex) != indices.end()) {
            maxRemovals = max(maxRemovals, 1 + computeMaxRemovals(sourceIndex + 1, patternIndex, indices, source, pattern, dp));
        }
        
        if (source[sourceIndex] == pattern[patternIndex]) {
            maxRemovals = max(maxRemovals, computeMaxRemovals(sourceIndex + 1, patternIndex + 1, indices, source, pattern, dp));
        } else {
            maxRemovals = max(maxRemovals, computeMaxRemovals(sourceIndex + 1, patternIndex, indices, source, pattern, dp));
        }
        
        return dp[sourceIndex][patternIndex] = maxRemovals;
    }

    void insertIntoSet(set<int>& indices, const vector<int>& indicesArray) {
        for (int index : indicesArray) {
            indices.insert(index);
        }
    }

    int maxRemovals(string source, string pattern, vector<int>& indicesArray) {
        set<int> indices;
        insertIntoSet(indices, indicesArray);

        vector<vector<int>> dp(source.size(), vector<int>(pattern.size(), -1));
        
        return computeMaxRemovals(0, 0, indices, source, pattern, dp);
    }
};
",1420089226
Mighty Programmer,heartcodehacker,336,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;

    vector<vector<ll>> computeBinomialCoefficients(ll maxVal) {
        vector<vector<ll>> binom(maxVal + 1, vector<ll>(maxVal + 1, 0));
        for (ll i = 0; i <= maxVal; i++) {
            binom[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;
            }
        }
        return binom;
    }

    vector<vector<ll>> computeStirlingNumbers(ll n, ll maxVal) {
        vector<vector<ll>> stirling(n + 1, vector<ll>(maxVal + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= maxVal; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        return stirling;
    }

    vector<ll> computeFactorials(ll maxVal) {
        vector<ll> factorial(maxVal + 1, 1);
        for (ll i = 1; i <= maxVal; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        return factorial;
    }

    ll computePower(ll base, ll exponent) {
        ll result = 1;
        for (ll p = 0; p < exponent; ++p) {
            result = (result * base) % MOD;
        }
        return result;
    }

    ll computeTotalWays(ll n, ll x, ll y, const vector<vector<ll>>& binomial, 
                        const vector<vector<ll>>& stirling, const vector<ll>& factorial) {
        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = computePower(y, k);
            totalWays = (totalWays + binomial[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * power % MOD) % MOD;
        }
        return totalWays;
    }

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> binomial = computeBinomialCoefficients(x);
        vector<vector<ll>> stirling = computeStirlingNumbers(n, x);
        vector<ll> factorial = computeFactorials(x);

        return computeTotalWays(n, x, y, binomial, stirling, factorial);
    }
};
",1420123568
Mighty Programmer,heartcodehacker,336,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& numbers) {
        vector<int> result;
        for (int idx = 0; idx < numbers.size(); idx++) {
            if (numbers[idx] == 2) {
                result.push_back(-1);
            } else {
                result.push_back(processNumber(numbers[idx]));
            }
        }
        return result;
    }

private:
    int processNumber(int num) {
        int significantBit = findSignificantBit(num);
        return modifyBits(num, significantBit);
    }

    int findSignificantBit(int num) {
        int tempNum = num, bitPosition = 0;
        while (tempNum > 0) {
            if ((tempNum & 1) == 0) break;
            bitPosition++;
            tempNum = (tempNum >> 1);
        }
        return bitPosition - 1;
    }

    int modifyBits(int num, int significantBit) {
        int modifiedNum = 0, bitIndex = 0;
        while (num > 0) {
            if (significantBit != bitIndex) {
                modifiedNum = (modifiedNum | ((num & 1) << bitIndex));
            }
            bitIndex++;
            num = (num >> 1);
        }
        return modifiedNum;
    }
};
",1420087219
Mighty Programmer,heartcodehacker,336,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& numbers) {
        vector<int> result;
        for (int idx = 0; idx < numbers.size(); idx++) {
            if (numbers[idx] == 2) {
                result.push_back(-1);
            } else {
                result.push_back(processNumber(numbers[idx]));
            }
        }
        return result;
    }

private:
    int processNumber(int num) {
        int significantBit = findSignificantBit(num);
        return modifyBits(num, significantBit);
    }

    int findSignificantBit(int num) {
        int tempNum = num, bitPosition = 0;
        while (tempNum > 0) {
            if ((tempNum & 1) == 0) break;
            bitPosition++;
            tempNum = (tempNum >> 1);
        }
        return bitPosition - 1;
    }

    int modifyBits(int num, int significantBit) {
        int modifiedNum = 0, bitIndex = 0;
        while (num > 0) {
            if (significantBit != bitIndex) {
                modifiedNum = (modifiedNum | ((num & 1) << bitIndex));
            }
            bitIndex++;
            num = (num >> 1);
        }
        return modifiedNum;
    }
};
",1420087364
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3487,golang,"package main

import (
	""math""
	""fmt""
)

func maxRemovals(sou string, patt string, ti []int) int {
	ne := len(sou)
	me := len(patt)
	d := make([]int, me+1)
	for i := range d {
		d[i] = math.MaxInt32
	}
	d[0] = 0

	it := make([]bool, ne)
	for _, ix := range ti {
		it[ix] = true
	}

	for i := 0; i < ne; i++ {
		for j := me; j > 0; j-- {
			if sou[i] == patt[j-1] && d[j-1] != math.MaxInt32 {
				d[j] = min(d[j], d[j-1]+boolToInt(it[i]))
			}
		}
	}

	if d[me] == math.MaxInt32 {
		return len(ti)
	}
	return len(ti) - d[me]
}

func boolToInt(she bool) int {
	if she {
		return 1
	}
	return 0
}

func min(he, she int) int {
	if he < she {
		return he
	}
	return she
}
",1420068027
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3604,golang,"package main

import (
	""fmt""
)

const MO = 1_000_000_007

func numberOfWays(ne int, xe int, ye int) int {
	co := make([][]int, xe+1)
	for i := range co {
		co[i] = make([]int, xe+1)
	}
	for i := 0; i <= xe; i++ {
		co[i][0] = 1
		for j := 1; j <= i; j++ {
			co[i][j] = (co[i-1][j-1] + co[i-1][j]) % MO
		}
	}
	sl := make([][]int, ne+1)
	for i := range sl {
		sl[i] = make([]int, xe+1)
	}
	sl[0][0] = 1
	for i := 1; i <= ne; i++ {
		for j := 1; j <= xe; j++ {
			sl[i][j] = (j*sl[i-1][j] + sl[i-1][j-1]) % MO
		}
	}
	fac := make([]int, xe+1)
	fac[0] = 1
	for i := 1; i <= xe; i++ {
		fac[i] = fac[i-1] * i % MO
	}
	tw := 0
	for k := 1; k <= xe; k++ {
		yP := pow(ye, k, MO)
		tw = (tw + co[xe][k]*sl[ne][k]%MO*fac[k]%MO*yP%MO) % MO
	}

	return tw
}
func pow(ba, ex, mod int) int {
	res := 1
	for ex > 0 {
		if ex%2 == 1 {
			res = res * ba % mod
		}
		ba = ba * ba % mod
		ex /= 2
	}
	return res
}",1420123636
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3605,golang,"package main

import ""fmt""

func minBitwiseArray(nos []int) []int {
    ne := len(nos)
    res := make([]int, ne)
    for i := 0; i < ne; i++ {
        res[i] = -1
        for y := 0; y <= nos[i]; y++ {
            if (y | (y + 1)) == nos[i] {
                res[i] = y
                break 
            }
        }
    }

    return res
}",1420016036
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3611,golang,"package main

import (
	""fmt""
	""math""
)

func minBitwiseArray(nos []int) []int {
	ne := len(nos)
	res := make([]int, ne)

	for i := 0; i < ne; i++ {
		nuu := nos[i]
		ma := math.MaxInt32
		fo := false
		for b := 0; b <= 30; b++ {
			if (nuu>>b)&1 == 1 {
				can := nuu &^ (1 << b)
				if can < 0 {
					continue
				}
				if (can|(can+1)) == nuu {
					if can < ma {
						ma = can
						fo = true
					}
				}
			}
		}

		if fo {
			res[i] = ma
		} else {
			res[i] = -1
		}
	}

	return res
}",1420044744
Mohil,Mohil09,338,3487,cpp,"int dp[3001][3001];

class Solution {
public:

    int recr(int x, int y, string &s, string &t, set<int> &st){
        if(x==s.size()){
            if(y==t.size()) return 0;
            return -1e6;
        }
        if(dp[x][y]+1) return dp[x][y];

        int ans = recr(x+1,y+(y<t.size()&&s[x]==t[y]),s,t,st);
        if(st.find(x)!=st.end()) ans = max(ans,recr(x+1,y,s,t,st)+1);

        return dp[x][y] = ans;
    }

    int maxRemovals(string s, string t, vector<int>& w) {
        set<int> st(w.begin(),w.end());
        for(int i = 0; i <= s.size(); i++)
            for(int j = 0; j <= t.size(); j++)
                dp[i][j] = -1;
        return recr(0,0,s,t,st);
    }
};",1420057769
Mohil,Mohil09,338,3604,cpp,"int dp[1005][1005], fact[1005];

class Solution {
public:

    static const int M = 1e9+7;

    int cal(int n, int r){
        if(n<r or r<0) return 0;
        if(r==0 || n==r) return 1; 
        if(dp[n][r]+1) return dp[n][r];
        return dp[n][r] = (cal(n-1,r-1)+cal(n-1,r))%M;
    }

    int power(int a, int b){
        int ans = 1;
        while(b){
            if(b&1) ans = (1ll*ans*a)%M;
            a = (1ll*a*a)%M;
            b /= 2;
        }
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        if(dp[1][0]==0){
            memset(dp,-1,sizeof(dp));
            fact[0] = 1;
            for(int i = 1; i < 1005; i++)
            fact[i] = (1ll*fact[i-1]*i)%M;
        }
        int ans = 0;

        //i-childs, n = candies
        
        for(int i = 0; i <= x; i++){
            int curr = 0;
            for(int j = 0; j <= i; j++){
                int t = cal(i,j);
                t = (1ll*t*power(i-j,n))%M;
                if(j&1) t = -t;
                curr = (0ll+curr+t+M)%M;
            }
            curr = (1ll*curr*cal(x,i))%M;
            curr = (1ll*curr*power(y,i))%M;
            ans = (ans+curr)%M;
        }

        return ans;
    }
};",1420111247
Mohil,Mohil09,338,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> ans(n,-1);

        for(int i = 0; i < n; i++){
            int x = nums[i];

            for(int j = 1; j < x; j++){
                int y = (j|(j+1));
                if(y==x){
                    ans[i] = j;
                    break;
                }
            }
        }    

        return ans;
    }
};",1420024145
Mohil,Mohil09,338,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &y:nums){
            if(y==2){
                y = -1;
                continue;
            }
            int x = y, bit = -1;
            while(x&1){
                bit++; x /= 2;
            }
            y ^= (1<<bit);
        }
        return nums;
    }
};",1420034447
Thiru,pabloescobar69,341,3487,java,"import java.util.*;

class Solution {

    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        int[] dp = initializeDP(m);
        boolean[] isTarget = createTargetArray(n, targetIndices);
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                updateDP(source, pattern, dp, isTarget, i, j);
            }
        }
        
        return calculateMaxRemovals(dp, targetIndices);
    }

    private int[] initializeDP(int m) {
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        return dp;
    }

    private boolean[] createTargetArray(int n, int[] targetIndices) {
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    private void updateDP(String source, String pattern, int[] dp, boolean[] isTarget, int i, int j) {
        if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
            dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
        }
    }

    private int calculateMaxRemovals(int[] dp, int[] targetIndices) {
        return targetIndices.length - (dp[dp.length - 1] == Integer.MAX_VALUE ? 0 : dp[dp.length - 1]);
    }
}
",1420060413
Thiru,pabloescobar69,341,3604,java,"import java.util.*;

class Solution {
    private static final int MOD = (int) 1e9 + 7;

    private long[][] computeCombinations(int size) {
        long[][] C = new long[size + 1][size + 1];
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }

    private long[][] computePartitions(int n, int x) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    private long computeFactorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return (n * computeFactorial(n - 1)) % MOD;
    }

    public int numberOfWays(int n, int x, int y) {
        long[][] C = computeCombinations(x);
        long[][] S = computePartitions(n, x);

        long result = 0;
        for (int k = 1; k <= x; ++k) {
            long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * computeFactorial(k)) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }

        return (int) result;
    }
}
",1420098554
Thiru,pabloescobar69,341,3605,java,"import java.util.*;

class Solution {
    public int findMinAns(int prime) {
        for (int x = 1; x <= prime; ++x) {
            if ((x | (x + 1)) == prime) {
                return x;
            }
        }
        return -1;
    }

    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; ++i) {
            ans[i] = findMinAns(nums.get(i));
        }

        return ans;
    }
}
",1420012440
Thiru,pabloescobar69,341,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums.get(i) != 2) {
                res[i] = getAns(nums.get(i));
            } else {
                res[i] = -1;
            }
        }
        return res;
    }

    public int getAns(int n) {
        int j = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                j = i;
            } else {
                break;
            }
        }
        return n - (1 << j);
    }

    public int[] findMaxAndMin(List<Integer> nums) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int num : nums) {
            max = Math.max(max, num);
            min = Math.min(min, num);
        }
        return new int[] {max, min};
    }

    public int countSetBits(int n) {
        int count = 0;
        while (n > 0) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
}
",1420074104
SUJIT9821,SUJIT9821,342,3487,cpp,"class Solution {
public:
vector<vector<int>>dp;
    int f(string&s,string&p,vector<bool>&mark,int i,int j){
        if(j==p.size())return 0;
        if(i==s.size())return 1e5;
        if(dp[i][j]!=-1)return dp[i][j];
        int x = 1e9;
        if(s[i]==p[j])x=mark[i]+f(s,p,mark,i+1,j+1);
        x = min(x,f(s,p,mark,i+1,j));
        return dp[i][j]= x;
        
    }
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(),m = p.size();
        vector<bool>mark(n,0);
        dp.assign(n,vector<int>(m,-1));
        for(auto&it:t)mark[it]=1;
        int x = f(s,p,mark,0,0);
        return t.size()-x;
    }
};",1420079013
SUJIT9821,SUJIT9821,342,3604,cpp,"
const int MOD = 1e9 + 7;

// Function to compute (base^exp) % MOD using modular exponentiation
long long modExp(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Function to compute binomial coefficient C(n, k) % MOD
long long binomialCoeff(int n, int k, vector<vector<long long>>& C) {
    if (C[n][k] != -1) return C[n][k];
    if (k == 0 || k == n) return C[n][k] = 1;
    return C[n][k] = (binomialCoeff(n - 1, k - 1, C) + binomialCoeff(n - 1, k, C)) % MOD;
}

// Function to compute f(r)
long long f(int r, int n, vector<vector<long long>>& C) {
    long long sum = 0;
    for (int p = 0; p <= r; ++p) {
        long long sign = (p % 2 == 0) ? 1 : -1;
        long long term = (binomialCoeff(r, p, C) * modExp(r - p, n, MOD)) % MOD;
        sum = (sum + sign * term + MOD) % MOD;  // Add MOD to avoid negative values
    }
    return sum;
}
class Solution {
public:
int numberOfWays(int n, int x, int y) {
    // Create a binomial coefficient table for all values up to x
    vector<vector<long long>> C(x + 1, vector<long long>(x + 1, -1));

    long long result = 0;
    for (int r = 1; r <= x; ++r) {
        long long binCoeff = binomialCoeff(x, r, C);  // xCr
        long long scoreWays = modExp(y, r, MOD);      // y^r
        long long f_r = f(r, n, C);                  // f(r)

        // Add the current term to the result
        long long currentTerm = (binCoeff * scoreWays) % MOD;
        currentTerm = (currentTerm * f_r) % MOD;

        result = (result + currentTerm) % MOD;
    }

    return result;
}};",1420118047
SUJIT9821,SUJIT9821,342,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto&it:nums){
              
            if(it==2){
                ans.push_back(-1);
            }
            else{
                bitset<30>b(it);  
                bitset<30>ans2 = b;
                for(int i=0;i<30;i++){
                    if(b[i]==0){
                        ans2[i-1]=0;
                        break;
                    }
                }
                ans.push_back(ans2.to_ulong());
            }
        }
        return ans;
    }
};",1420005912
SUJIT9821,SUJIT9821,342,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto&it:nums){
              
            if(it==2){
                ans.push_back(-1);
            }
            else{
                bitset<30>b(it);  
                bitset<30>ans2 = b;
                for(int i=0;i<30;i++){
                    if(b[i]==0){
                        ans2[i-1]=0;
                        break;
                    }
                }
                ans.push_back(ans2.to_ulong());
            }
        }
        return ans;
    }
};",1420005233
Manan Chhajed,Manan_Chhajed,344,3487,cpp,"class Solution {
public:
    using ll = long long;
    int maxRemovals(string s, string t, vector<int>& v) 
    {
        ll n = s.size(), m = t.size();
        
        vector<ll> ok(n, 0);
        for (auto it : v) ok[it] = 1;
        
        vector<ll> dp(m, 1e18);

        for (int i = 0; i < n; ++i) 
        {
            for (int j = m - 1; j >= 0; j--) 
            {
                if (t[j] == s[i]) dp[j] = min(dp[j], (j > 0 ? dp[j - 1] : 0) + ok[i]);
            }
        }

        ll ans = v.size() - dp[m - 1];
        return ans;
    }
};",1420118225
Manan Chhajed,Manan_Chhajed,344,3604,cpp,"class Solution {
public:
    using ll = long long;
    const ll MOD = 1e9 + 7;
    
    ll fact[1007], invFact[1007];
    
    ll binExpIter(ll a, ll b) { ll temp = 1; while (b > 0) { if (b & 1) temp = (temp * 1LL * a) % MOD; a  = (a * 1LL * a) % MOD; b >>= 1; } return temp % MOD; }

    
    ll nCr(ll n, ll r) { return (((fact[n] * invFact[n - r]) % MOD) * invFact[r]) % MOD; }

    ll inv(ll n) { return binExpIter(n, MOD - 2) % MOD; }
    
    void preCompute() { fact[0] = 1, invFact[0] = 1; for (int i = 1; i <= 1e3; i++) { fact[i] = (fact[i - 1] * i) % MOD; invFact[i] = inv(fact[i]) % MOD; } }
    
    ll mod_mul(ll a, ll b) { a = a % MOD; b = b % MOD; return (((a * b) % MOD) + MOD) % MOD; }
    ll mod_add(ll a, ll b) { a = a % MOD; b = b % MOD; return (((a + b) % MOD) + MOD) % MOD; }
    ll mod_sub(ll a, ll b) { a = a % MOD; b = b % MOD; return (((a - b) % MOD) + MOD) % MOD; }
    ll mod_div(ll a, ll b) { a = a % MOD; b = b % MOD; return (mod_mul(a, inv(b)) + MOD) % MOD; }
    
    int numberOfWays(int n, int x, int y) 
    {
        preCompute();           
        ll ans = 0;
        
        for(int occ = 1; occ <= x; occ++)
        {
            if(n < occ) continue;
            ll rem = n - occ;
            // ll temp = mod_mul(nCr(n, occ), fact[occ]);
            // ll temp = mod_mul(fact[n], nCr(n - 1, occ - 1));
            // temp = mod_mul(temp, binExpIter(occ, rem));
            
            ll temp = 0;
            for(ll i = 0; i <= occ - 1; i++)
            {
                if(i % 2 == 0)
                {
                    temp = mod_add(temp, mod_mul(nCr(occ, i), binExpIter(occ - i, n)));
                }
                else
                {
                    temp = mod_sub(temp, mod_mul(nCr(occ, i), binExpIter(occ - i, n)));
                }
            }
            
            ll res = mod_mul(temp, binExpIter(y, occ));
            res = mod_mul(res, nCr(x, occ));
            ans = mod_add(ans, res);
        }
        
        return ans;
    }
};",1420082514
Manan Chhajed,Manan_Chhajed,344,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for(int i = 0; i < n; i++)
        {
            if(nums[i] == 2) continue;
            int res = nums[i];
            for(int j = 0; j <= 20; j++)
            {
                if(res & (1 << j)) continue;
                else 
                {
                    res -= (1 << (j - 1));
                    break;
                }
            }
            ans[i] = res;
        }
        
        return ans;
    }
};",1420009857
Manan Chhajed,Manan_Chhajed,344,3611,cpp,"class Solution {
public:
    using ll = long long;
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for(ll i = 0; i < n; i++)
        {
            if(nums[i] == 2) continue;
            ll res = nums[i];
            for(int j = 0; j <= 31; j++)
            {
                if(res & (1ll << j)) continue;
                else 
                {
                    res -= (1ll << (j - 1));
                    break;
                }
            }
            ans[i] = res;
        }
        
        return ans;
    }
};",1420011969
ptr1025,ptr1025,345,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tar) {
        auto isin = [&tar](int x){
            auto it = lower_bound(tar.begin(),tar.end(),x);
            return it != tar.end() && *it == x;
        };
        vector<int> dp(p.size(),tar.size()+1);
        for(int j=0;j<s.size();j++){
            const char & c = s[j];
            vector<int> nx = dp;
            for(int i=0;i<p.size();i++){
                if(c == p[i]){
                    int prev = i ? dp[i-1]:0;
                    nx[i] = min(dp[i], isin(j) + prev);
                }
            }
            dp = std::move(nx);
            // for(int x:dp){
            //     cout << x << "" "";
            // }
            // cout << ""\n"";
        }
        return tar.size() - dp.back();
    }
};",1420041001
ptr1025,ptr1025,345,3604,cpp,"class Solution {
public:
    int mod = 1e9+7;
    int64_t mpow(int64_t x, int64_t n){
        int64_t a = 1;
        while(n){
            if(n & 1) a = (x * a) % mod;
            x = x * x % mod;
            n >>= 1;
        }
        return a;
    }
    int inv(int x){
        return mpow(x, mod - 1);
    }
    int f(int x){
        int a = 1;
        while(x){
            a = (x * a) % mod;
            x--;
        }
        return a;
    }
    int c(int n, int r){
        return f(n) * inv(f(n-r)) * inv(f(r));
    }
    int numberOfWays(int n, int x, int y) {
        int64_t ans = 0;
        vector<int64_t> dp(n+1, 0);
        dp[0] = 1;
        
        for(int i=0;i<n;i++){
            for(int j=n;j>=2;j--){
                dp[j] = (dp[j]*j %mod+ dp[j-1]*(x-j+1) %mod) %mod;
            }
            dp[1] = x;
            // for(int j=1;j<=n;j++){
            // cout << dp[j] << "" "";
            // }
            // cout << ""\n"";
        }

        // cout << mpow(1,8) << ""??\n"";
        for(int i=1;i<=min(n,x);i++){
            ans = ans + dp[i] * mpow(y,i) % mod;
            ans = ans % mod;
            // cout << ans << ""~"";
            
        }
            // cout << ""\n"";
        
        return ans;
    }
};",1420111966
ptr1025,ptr1025,345,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        d = {}
        for i in range(1,1008):
            k = i | (i + 1)
            if not k in d:
                d[k] = i
        return [d.get(x,-1) for x in nums]",1419994987
ptr1025,ptr1025,345,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int x:nums){
            array<int, 31> arr;
            for(int i=0;i<31;i++){
                arr[i] = (1 << i) & x;
            }
            int h = 0;
            for(;h<31;h++){
                if(!arr[h])break;
            }
            if(h == 0){
                ans.push_back(-1);
                continue;
            }
            int v = 0;
            for(int i=0;i<31;i++){
                if(i != h - 1)v |= (arr[i]);
            }
            ans.push_back(v);
        }
        return ans;
    }
};",1420009302
Mayank670,Mayank670,346,3487,cpp,"class Solution {
public:
    Solution() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
    }
    int maxRemovals(string src, string patt, vector<int>& ti) {
        int n = src.size();
        int m = patt.size();
        vector<bool> flg(n, false);
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        for (int it : ti) {
            flg[it] = true;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = m; j >= 1; --j) {
                if (src[i] == patt[j - 1] && dp[j - 1] != INT_MAX) {
                    if (flg[i]) {
                        dp[j] = min(dp[j], dp[j - 1] + 1);
                    } else {
                        dp[j] = min(dp[j], dp[j - 1]);
                    }
                }
            }
        }
        if (dp[m] == INT_MAX) {
            return ti.size();
        } else {
            return ti.size() - dp[m];
        }
    }
};
",1420087311
Mayank670,Mayank670,346,3604,cpp,"const int m = 1e9 + 7;
#define vvi vector<vector<int>> 
#define vi vector<int>  
#define ll long long 

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vvi dp(x + 1, vi(x + 1, 0));
        vi temp(x + 1, 1); 
        vvi res(n + 1, vi(x + 1, 0));
        res[0][0] = 1; 

        for (int i = 0; i <= x; i++) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % m;
            } 
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                res[i][j] = (res[i - 1][j - 1] + (1LL) * j * res[i - 1][j]) % m;
            }
        }

        for (int i = 1; i <= x; i++) {
            temp[i] = (1LL * temp[i - 1] * i) % m; 
        }

        int result = 0;
        for (int k = 1; k <= x; k++) {
            long long ans = 1; 
            for (int j = 0; j < k; j++) {
                ans = (ans * y) % m; 
            }
            
            ll p1 = dp[x][k];
            ll p2 = res[n][k];
            ll p3 = temp[k];

            ll cc = (p1 * p2) % m;
            cc = (cc * p3) % m;
            cc = (cc * ans) % m;

            result = (result + cc) % m;
        }

        return result; 
    }
};
",1420118419
Mayank670,Mayank670,346,3605,cpp,"class Solution {
public:
    int cal(int no) {
        for (int ii = 1; ii<= no; ii++) {
            if ((ii | (ii + 1)) == no) {
                return ii;
            }
        }
        return -1; 
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> sol(n, -1); 

        for (int i = 0; i < n; ++i) {
            sol[i] =cal(nums[i]) ; 
        }

        return sol;
    }
};",1420002940
Mayank670,Mayank670,346,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n , -1);
        for(int i = 0; i < n; i++) {
            int number = nums[i];
            if((number & (number - 1)) == 0) {
                result[i] = -1;  
            } else {
               
                int local = (number & ~(number + 1)) >> 1;
                result[i] = number - local - 1;
            }
        }
        
        return result;
    }
};
",1420050679
Ritanshu Khobarkhede,ritanshu4k,347,3487,java,"import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int maxRemovals(String src, String pat, int[] targetIdx) {
        int n = src.length();
        int m = pat.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        Set<Integer> targets = new HashSet<>();
        for (int idx : targetIdx) {
            targets.add(idx);
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (src.charAt(i) == pat.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (targets.contains(i) ? 1 : 0));
                }
            }
        }

        return targetIdx.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420113484
Ritanshu Khobarkhede,ritanshu4k,347,3604,java,"class Solution {
    private static final int MOD = 1_000_000_007;

    public int numberOfWays(int n, int x, int y) {
        int[][] cm = cm(x);
        int[][] st = st(n, x);
        int[] fc = fc(x);

        long total = 0;
        for (int k = 1; k <= x; ++k) {
            long yp = pm(y, k);
            total = (total + (1L * cm[x][k] * st[n][k] % MOD * fc[k] % MOD * yp % MOD)) % MOD;
        }
        return (int) total;
    }

    private int[][] cm(int x) {
        int[][] cmb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; ++i) {
            cmb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                cmb[i][j] = (cmb[i - 1][j - 1] + cmb[i - 1][j]) % MOD;
            }
        }
        return cmb;
    }

    private int[][] st(int n, int x) {
        int[][] stl = new int[n + 1][x + 1];
        stl[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stl[i][j] = (int) ((1L * j * stl[i - 1][j] + stl[i - 1][j - 1]) % MOD);
            }
        }
        return stl;
    }

    private int[] fc(int x) {
        int[] fact = new int[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; ++i) {
            fact[i] = (int) (1L * fact[i - 1] * i % MOD);
        }
        return fact;
    }

    private long pm(int base, int exp) {
        long result = 1;
        long b = base;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                result = (result * b) % MOD;
            }
            b = (b * b) % MOD;
            exp >>= 1;
        }
        return result;
    }
}
",1420118503
Ritanshu Khobarkhede,ritanshu4k,347,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        List<Integer> res = new ArrayList<>();

        for (int i : nums) {
            boolean f = false;

            for (int x = 0; x < i; x++) {
                if ((x | (x + 1)) == i) {
                    res.add(x);
                    f = true;
                    break;
                }
            }

            if (!f) {
                res.add(-1);
            }
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
    }
}
",1420102725
Ritanshu Khobarkhede,ritanshu4k,347,3611,java,"import java.util.List;
import java.util.ArrayList;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        List<Integer> res = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = findMinimalAns(num);
            res.add(minimalAns);
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
    }

    private int findMinimalAns(int i) {
        int minimalX = Integer.MAX_VALUE;
        boolean f = false;

        for (int bit = 0; bit <= 30; bit++) {
            if (((i >> bit) & 1) == 1) {
                int c = i & ~(1 << bit);
                if (c < 0) continue;

                if ((c | (c + 1)) == i) {
                    if (c < minimalX) {
                        minimalX = c;
                        f = true;
                    }
                }
            }
        }

        return f ? minimalX : -1;
    }
}
",1420108775
aboylinked,aboylinked,348,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int tSize = targetIndices.size();
        
         vector<bool> isTarget(n, false);
        for(auto idx : targetIndices){
            isTarget[idx] = true;
        }
        
         const int INF = 1e9;
        vector<int> previous(n + 1, INF);
         previous[0] = 0;
        for(int j = 1; j <= n; ++j){
            previous[j] = 0;
        }
        
         for(int i = 1; i <= m; ++i){
            vector<int> current(n + 1, INF);
            for(int j = 1; j <= n; ++j){
                if(pattern[i-1] == source[j-1]){
                     
                    if(previous[j-1] != INF){
                        current[j] = min(current[j-1], previous[j-1] + (isTarget[j-1] ? 1 : 0));
                    }
                    else{
                        current[j] = current[j-1];
                    }
                }
                else{
                     current[j] = current[j-1];
                }
            }
             previous = current;
        }
        
         int minUsedTargets = INF;
        for(int j = 1; j <= n; ++j){
            minUsedTargets = min(minUsedTargets, previous[j]);
        }
        
         if(minUsedTargets == INF){
            return 0;
        }
        
         return tSize - minUsedTargets;
    }
};
",1420084080
aboylinked,aboylinked,348,3604,cpp,"const int MOD = 1'000'000'007;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<long long> S_prev(x + 1, 0);  
        vector<long long> S_current(x + 1, 0);
        S_prev[0] = 1; 
        
        for(int i=1; i<=n; ++i){
            for(int k=0; k<=x; ++k){
                S_current[k] = 0;
            }
            for(int k=1; k<=x; ++k){
                S_current[k] = (S_prev[k-1] + (k * S_prev[k]) % MOD) % MOD;
            }
            
            S_prev = S_current;
        }
        
        vector<long long> C(x +1, 0);
        C[0] =1;
        for(int j=1; j<=x; ++j){
            for(int k = min(j, x); k>=1; --k){
                C[k] = (C[k] + C[k-1]) % MOD;
            }
        }
         
        int max_k = min(x, n);
        vector<long long> fact(max_k +1, 1);
        for(int k=1; k<=max_k; ++k){
            fact[k] = (fact[k-1] * k) % MOD;
        }

        
        vector<long long> pow_y(max_k +1, 1);
        for(int k=1; k<=max_k; ++k){
            pow_y[k] = (pow_y[k-1] * y) % MOD;
        }

       long long total =0;
        for(int k=1; k<=max_k; ++k){
            long long term = (C[k] * fact[k]) % MOD;
            term = (term * S_prev[k]) % MOD;
            term = (term * pow_y[k]) % MOD;
            total = (total + term) % MOD;
        }

        return (int)total;
    }
};
",1420092636
aboylinked,aboylinked,348,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  
        
        for (int i = 0; i < n; ++i) {
            for (int x = 0; x <= nums[i]; ++x) {
                 
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x; 
                    break;       
                }
            }
        }
        
        return ans;
        
    }
};",1420013058
aboylinked,aboylinked,348,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        vector<int> ans;
        for(auto num : nums){
            bool found = false;
            int min_k = INT32_MAX;
            for(int j=0; j < 32; ++j){
                if( (num >> j) &1 ){
                    int k = num & (~(1<<j));
                        
                    if( (k | (k +1)) == num ){
                        if(k < min_k){
                            min_k = k;
                            found = true;
                        }
                    }
                }
            }
            if(found){
                ans.push_back(min_k);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;


        
    }
};",1420011626
Naitik Raj,naitikraj1000,349,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));
        unordered_set<int> removableIndices(targetIndices.begin(), targetIndices.end());
        
        return max(0, solve(source, pattern, 0, 0, removableIndices, dp));
    }

private:
    int solve(const string& s, const string& p, int i, int j, 
              const unordered_set<int>& removableIndices, vector<vector<int>>& dp) {
      
      if(i>=s.size()){
        if(j>=p.size()) return 0;
        return -1e9;
      }

      
         if(dp[i][j]!=-1) return dp[i][j];


         int ans=INT_MIN;

if(j>=p.size()){
   if(removableIndices.count(i)){
            ans=max(ans,1+solve(s,p,i+1,j,removableIndices,dp));
             }else{
              ans=max(ans,solve(s,p,i+1,j,removableIndices,dp));
             }
}else{
         if(s[i]==p[j]){
           
             if(removableIndices.count(i)){
               ans=max(ans,solve(s,p,i+1,j+1,removableIndices,dp));
               ans=max(ans,1+solve(s,p,i+1,j,removableIndices,dp));
             }else{
              ans=max(ans,solve(s,p,i+1,j+1,removableIndices,dp));
             }
         }else{
 
           if(removableIndices.count(i)){
               ans=max(ans,1+solve(s,p,i+1,j,removableIndices,dp));
             }else{
              ans=max(ans,solve(s,p,i+1,j,removableIndices,dp));
             }

         }

}
    
         return dp[i][j]=ans;
    }
};",1420052617
Naitik Raj,naitikraj1000,349,3604,cpp,"#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

class Solution {
public:
    // Recursive function for modular exponentiation (a^b) % MOD
    int modPow(int x, int y) {
        if (y == 0) return 1;
        long long z = modPow(x, y / 2);
        z = (z * z) % MOD;
        if (y % 2 == 1) z = (z * x) % MOD;
        return z;
    }

    // Precompute factorials and modular inverses
    void precompFact(int n, vector<int>& fact, vector<int>& invFact) {
        if (fact.size() > n) return;
        
        fact.resize(n + 1);
        invFact.resize(n + 1);
        
        fact[0] = 1;
        for (int i = 1; i <= n; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        invFact[n] = modPow(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; --i) {
            invFact[i] = (1LL * invFact[i + 1] * (i + 1)) % MOD;
        }
    }

    // Compute combinations C(n, k) % MOD
    int comb(int n, int k, const vector<int>& fact, const vector<int>& invFact) {
        if (k > n || k < 0) return 0;
        return (1LL * fact[n] * invFact[k] % MOD) * invFact[n - k] % MOD;
    }

    // Precompute Stirling numbers of the second kind
    void precompStirling(int n, int k, vector<vector<int>>& stirling) {
        stirling.assign(n + 1, vector<int>(k + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= k; ++j) {
                stirling[i][j] = (stirling[i - 1][j - 1] + 1LL * j * stirling[i - 1][j] % MOD) % MOD;
            }
        }
    }

    // Main function to compute the number of distinct ways
    int numberOfWays(int n, int k, int mult) {
        vector<int> fact, invFact;
        precompFact(k, fact, invFact);  // Precompute factorials & inverses

        vector<vector<int>> stirling;
        precompStirling(n, k, stirling);  // Precompute Stirling numbers

        int total = 0;

        // Iterate over all possible number of bands (1 to k)
        for (int b = 1; b <= k; ++b) {
            int powMult = modPow(mult, b);

            // Compute the current sum term:
            // C(k, b) * S(n, b) * b! * mult^b % MOD
            int term = comb(k, b, fact, invFact);  // C(k, b)
            term = (1LL * term * stirling[n][b]) % MOD;  // S(n, b)
            term = (1LL * term * fact[b]) % MOD;  // b!
            term = (1LL * term * powMult) % MOD;  // mult^b

            total = (total + term) % MOD;
        }

        return total;
    }
};


",1420124931
Naitik Raj,naitikraj1000,349,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int> v) {
        
        int n=v.size();
         vector<int> ans(n,-1);
        for(int i=0;i<v.size();i++){
         int num=v[i];
          int possible=false;
          int store=0;
          int sum=0;
          int possible_ans=INT_MAX;
         for(int j=31;j>=0;j--){
           int bit=log2(num+1);
           if((1<<j)&(num)){
             if((1<<bit)==num+1){
            possible=true;
             num-=(1<<j);
            sum+=(1<<j);
            possible_ans=min(possible_ans,sum+(1<<(bit-1)));
            break;
           }else{
            num-=(1<<j);
            sum+=(1<<j);
           }
           }
        
         }

         if(possible){
            ans[i]=sum;
         }
        }

        for(int i=0;i<n;i++){
            if(ans[i]!=-1) ans[i]--;
        }
        return ans;
    }
    };",1420023306
Naitik Raj,naitikraj1000,349,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
         vector<int> ans(n,-1);
        for(int i=0;i<v.size();i++){
         int num=v[i];
          int possible=false;
          int store=0;
          int sum=0;
          int possible_ans=INT_MAX;
         for(int j=31;j>=0;j--){
           int bit=log2(num+1);
           if((1<<j)&(num)){
             if((1<<bit)==num+1){
            possible=true;
             num-=(1<<j);
            sum+=(1<<j);
            possible_ans=min(possible_ans,sum+(1<<(bit-1)));
            break;
           }else{
            num-=(1<<j);
            sum+=(1<<j);
           }
           }
        
         }

         if(possible){
            ans[i]=sum;
         }
        }

        for(int i=0;i<n;i++){
            if(ans[i]!=-1) ans[i]--;
        }
        return ans;
    }
};",1420021944
Vishal Kumar,Nemesis_77,350,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:

        n = len(source)
        m = len(pattern)
        
        dp = [10**9] * (m + 1)
        dp[0] = 0 
        
        arr = [False] * n
        for e in targetIndices:
            arr[e] = True
        
        for i in range(0 , n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1]:
                    prev_dp = dp[j - 1]
                    if prev_dp != 10**9:
                        dp[j] = min(dp[j], prev_dp + (1 if arr[i] else 0))

        dp_value = dp[m]
        return len(targetIndices) - (0 if dp_value == 10**9 else dp_value)



",1420073694
Vishal Kumar,Nemesis_77,350,3604,python3,"m = 10**9 + 7
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]

        arr = []
        for i in range(0 ,x + 1):
            row = [0] * (x + 1)
            arr.append(row)

        arr2 = []
        for i in range(n + 1):
            row = [0] * (x + 1)
            arr2.append(row)

        i = 0
        while i <= x:
            arr[i][0] = 1  
            j = 1
            while j <= i:
                arr[i][j] = (arr[i - 1][j] + arr[i - 1][j - 1]) % m
                j += 1
            i += 1

        arr2[0][0] = 1  
        i = 1
        while i <= n:
            j = 1
            while j <= x:
                arr2[i][j] = (arr2[i - 1][j - 1] + j * arr2[i - 1][j]) % m
                j += 1
            i += 1

        mul = [1 for _ in range(x + 1)]
        i = 1
        while i <= x:
            mul[i] = i * mul[i - 1] % m
            i += 1

        ans = 0
        for i in range(1, x + 1):
            exxp = 1
            for j in range(0 , i):
                exxp = (y * exxp) % m
            temp1 = arr[x][i] * arr2[n][i] % m
            temp2 = temp1 * mul[i] % m
            temp3 = temp2 * exxp % m
            ans = (ans + temp3) % m

        return ans

",1420118697
Vishal Kumar,Nemesis_77,350,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  
        
        for i in range(n):
            for e in range(nums[i] + 1):
                if (e | (e + 1)) == nums[i]:
                    ans[i] = e
                    break  
        return ans",1420032767
Vishal Kumar,Nemesis_77,350,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        
        for i in range(0 , n):
            dig = nums[i]
            curr = float('inf')
            flag = False
            
            for e in range(0 , 31):
                if (dig >> e) % 2 == 1:
                    temp = dig & ((1 << e) ^ -1)
                    if temp < 0:
                        continue
                    if (temp | (temp + 1)) == dig:
                        if temp < curr:
                            flag = True
                            curr = temp         
            
            if flag:
                ans[i] = curr
            else:
                ans[i] = -1
        
        return ans
",1420053455
Sai Krishna,saikrishna17394,351,3487,cpp,"class Solution {
    string s;
    string pat;
    int n, pat_len;
    vector<vector<int>> dp;
    vector<bool> vis;
    int inf;

    int solve(int i, int j) {

        if (dp[i][j] != inf) {
            return dp[i][j];
        }

        if (i == n) {
            if (j != pat_len) {
                dp[i][j] = -1e5;
                return dp[i][j];
            }

            dp[i][j] = 0;
            return 0;
        }


        if (j == pat_len) {
            if (vis[i] == true) {
                dp[i][j] = 1 + solve(i + 1, j);
            }
            else {
                dp[i][j] = solve(i + 1, j);
            }

            return dp[i][j];
        }

        if (s[i] == pat[j]) {
            dp[i][j] = solve(i + 1, j + 1);

            if (vis[i] == true) {
                dp[i][j] = max(dp[i][j], 1 + solve(i + 1, j));
            }
            else {
                dp[i][j] = max(dp[i][j], solve(i + 1, j));
            }

            return dp[i][j];
        }

        if (vis[i] == true) {
            dp[i][j] = max(dp[i][j], 1 + solve(i + 1, j));
        }
        else {
            dp[i][j] = max(dp[i][j], solve(i + 1, j));
        }

        return dp[i][j];
    }

public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        n = source.length();
        pat_len = pattern.length();

        if (n == pat_len) {
            return 0;
        }

        s = source;
        pat = pattern;
        vis = vector<bool>(n, false);
        inf = -1e8;
        for (const auto& idx : targetIndices) {
            vis[idx] = true;
        }

        dp = vector<vector<int>>(n + 1, vector<int>(pat_len + 1, inf));
        return solve(0, 0);
    }
};",1420068805
Sai Krishna,saikrishna17394,351,3604,cpp,"class Solution {
    const long long mod = 1e9 + 7;


public:
    int numberOfWays(int n, int x, int y) {
        // fac[0] = 1;
        // afac[0] = 1;

        // for (int i = 1; i < lim; i++) {
        //     fac[i] = ((long long) i * fac[i - 1]) % mod;
        //     afac[i] = pow(fac[i], mod - 2);
        // }

        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));

        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }

        for (int i = 1; i <= n; i++) {
            dp[i][1] = (long long)(y * x);
        }

        for (int j = 2; j <= x; j++) {
            dp[1][j] = 0;

            for (int i = 2; i <= n; i++) {
                if (i < j) {
                    dp[i][j] = 0;
                    continue;
                }

                dp[i][j] = (long long)((x - j + 1) * y) * dp[i - 1][j - 1] + (dp[i - 1][j] * (long long)j);
                dp[i][j] %= mod;
            }
        }

        long long ans = 0;

        for (int j = 1; j <= x; j++) {
            ans += dp[n][j];
            ans %= mod;
        }
        return (int)ans;
    }
};",1420124991
Sai Krishna,saikrishna17394,351,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                continue;
            }

            for (int j = 1; j < nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }

        return ans;
    }
};",1419998198
Sai Krishna,saikrishna17394,351,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                continue;
            }

            ans[i] = nums[i] - 1;

            int val = 4;

            while (val <= (nums[i] + 1)) {
                if ((nums[i] % val) != (val - 1)) {
                    break;
                }

                ans[i] = (nums[i] / val) * val + ((val - 1) / 2);

                val *= 2;
            }
        }

        return ans;
    }
};",1420028175
Bhargav M,vexora0,352,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        Set<Integer> lup = new HashSet<>();
        for(int idx : targetIndices) lup.add(idx);
        
        int n = source.length();
        int m = pattern.length();
        int t = targetIndices.length;
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        for(int i = 0; i < n; i++) {
            for(int j = Math.min(m, i + 1); j >=1; j--) {
                if(source.charAt(i) == pattern.charAt(j -1)) {
                    if(dp[j-1] != Integer.MAX_VALUE) {
                        if(lup.contains(i)) {
                            dp[j] = Math.min(dp[j], dp[j-1] +1);
                        }
                        else {
                            dp[j] = Math.min(dp[j], dp[j-1]);
                        }
                    }
                }
            }
        }
        
        if(dp[m] == Integer.MAX_VALUE) return 0;
        return t - dp[m];
    }
}",1420116329
Bhargav M,vexora0,352,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        int M = 1000000007;
        
        int[] l = new int[]{n, x, y};
        
        long[][] s = new long[l[0]+1][l[1]+1];
        s[0][0] = 1;
        for(int i=1;i<=l[0];i++) {
            for(int j=1;j<=l[1];j++) {
                s[i][j] = (s[i-1][j-1] + (j * s[i-1][j]) % M) % M;
            }
        }
        
        long[][] c = new long[l[1]+1][l[1]+1];
        c[0][0] = 1;
        for(int i=1;i<=l[1];i++) {
            c[i][0] = 1;
            for(int j=1;j<=i;j++) {
                c[i][j] = (c[i-1][j-1] + c[i-1][j]) % M;
            }
        }
        
        long[] f = new long[l[1]+1];
        f[0] = 1;
        for(int i=1;i<=l[1];i++) {
            f[i] = (f[i-1] * i) % M;
        }
        
        long[] p = new long[l[1]+1];
        p[0] = 1;
        for(int i=1;i<=l[1];i++) {
            p[i] = (p[i-1] * l[2]) % M;
        }
        
        long r = 0;
        for(int k=1;k<=Math.min(l[1], l[0]);k++) {
            long comb = c[l[1]][k];
            long stir = s[l[0]][k];
            long fact = f[k];
            long yPow = p[k];
            long t = (((comb * stir) % M) * fact) % M;
            t = (t * yPow) % M;
            r = (r + t) % M;
        }
        
        return (int) r;
    }
}
",1420125034
Bhargav M,vexora0,352,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int size = nums.size();
        int[] result = new int[size];
        
        for(int idx = 0; idx < size; idx++) {
            int prime = nums.get(idx);
            int smallest = -1;
            
            for(int y = 0; y < prime; y++) {
                if( (y | (y + 1)) == prime ) {
                    smallest = y;
                    break;
                }
            }
            
            result[idx] = smallest;
        }
        
        return result;        
    }
}

",1419997465
Bhargav M,vexora0,352,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        Arrays.fill(ans, -1); 

        for(int i=0; i<n; i++) {
            int p = nums.get(i);
            int minx = Integer.MAX_VALUE;
            for(int k=0; k<32; k++) {
                if( (p & (1 <<k)) !=0 ){
                    int x = p & ~(1 <<k);
                    if(x < 0) continue;
                    if( (x | (x +1)) == p ){
                        if(x < minx){
                            minx = x;
                        }
                    }
                }
            }
            if(minx != Integer.MAX_VALUE){
                ans[i] = minx;
            }
        }
        return ans;
    }
}",1420007632
BATMAN,chamoli2k2,353,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        long long n = source.size(), m = pattern.size(), k = targetIndices.size();
        vector<long> dp(m+1, INT_MAX);
        dp[0] = 0; 
        
        vector<bool> temp(n, false);
        for(int i=0; i<k; i++){
            int idx = targetIndices[i];
            temp[idx] = true;
        }
        
        for(int i=0; i<n; i++){
            for(int j=m; j>0; j--){
                if(source[i] == pattern[j-1] && dp[j-1] != INT_MAX){
                    dp[j] = min(dp[j], dp[j-1] + (temp[i] ? 1 : 0));
                }
            }
        }

        if(dp[m] == 0) return k;
        return k - dp[m];
    }
};
",1420080673
BATMAN,chamoli2k2,353,3604,cpp,"class Solution {
public:
    int mod = 1e9+7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(x+1, vector<long long>(x+1, 0));
        auto calFact = [&](int x){
            vector<long long> ans(x+1, 1);
            for(int i=1; i<=x; i++){
                ans[i] = ans[i-1] * i % mod;
            }
            return ans;
        };
        
        vector<long long> factorial = calFact(x);
        for(int i=0; i<=x; i++){
            dp[i][0] = 1;
            for(int j=1; j<=i; j++){
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%mod;
            }
        }

        vector<vector<long long>> strNum(n+1, vector<long long>(x+1, 0));
        strNum[0][0] = 1;
        for(int i=1; i<=n; i++){
            for(int j=1; j<=x; j++){
                strNum[i][j] = (j * strNum[i-1][j] + strNum[i-1][j-1]) % mod;
            }
        }

        long long ans = 0;
        for(int k=1; k<=x; k++){
            long long currComb = 1;
            for (int p=0; p<k; p++){
                currComb = (currComb *1LL* y) % mod;
            }
            ans = (ans + dp[x][k] *1LL* strNum[n][k] % mod *1LL* factorial[k] % mod * currComb % mod) % mod;
        }

        return ans;
    }
};
",1420125378
BATMAN,chamoli2k2,353,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        
        for(int i=0; i<n; i++){
            for(int j=0; j<=nums[i]; j++){
                if((j | (j + 1)) == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        
        return ans;
    }
};
",1419996646
BATMAN,chamoli2k2,353,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        
        for(int i=0; i<n; i++){
            int currMin = INT_MAX, flag = false;
            for(int j=0; j<31; j++){
                if(((nums[i]>>j)&1) == 1){
                    int target = nums[i] & ~(1 << j);
                    if(target >= 0 && (target | (target+1)) == nums[i]){
                        currMin = min(currMin, target);
                        flag = true;
                    }
                }
                
                if(flag) ans[i] = currMin;
            }
        }
        
        return ans;
    }
};",1420054458
Batyrkhan Altynbekov,Arch_of_Triumph,354,3487,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;

vector<int> goods[30];
vector<int> bads[30];
int dp[3010][3010];

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n = sz(s);
        int m = sz(t);
        s = ""#"" + s;
        t = ""$"" + t;
        int k = sz(a);
        for (int i = 0; i <= m; i++) for (int j = 0; j <= k; j++)
            dp[i][j] = INT_MAX;
        for (int i = 0; i < 30; i++)
            goods[i].clear(), bads[i].clear();
        vector<bool> bad(n + 5, 0);
        for (auto it: a)
            bad[it + 1] = 1;
        for (int i = 1; i <= n; i++) {
            int x = s[i] - 'a';
            if (!bad[i])
                goods[x].pb(i);
            else 
                bads[x].pb(i);
        }
        dp[0][0] = 0;
        for (int i = 1; i <= m; i++) {
            int x = t[i] - 'a';
            for (int j = 0; j <= min(i, k); j++) {
                if (j > 0 && !bads[x].empty()) {
                    int pre = dp[i - 1][j - 1];
                    int ind = upper_bound(all(bads[x]), pre) - bads[x].begin();
                    if (ind < sz(bads[x])) {
                        dp[i][j] = bads[x][ind];                        
                    }
                }
                if (!goods[x].empty()) {
                    int pre = dp[i - 1][j];
                    int ind = upper_bound(all(goods[x]), pre) - goods[x].begin();
                    if (ind < sz(goods[x])) {
                        dp[i][j] = min(dp[i][j], goods[x][ind]);                        
                    }   
                }
            }
        }
        for (int i = 0; i <= k; i++)
            if (dp[m][i] != INT_MAX)
                return k - i;
        return k;
    }
};


",1420082368
Batyrkhan Altynbekov,Arch_of_Triumph,354,3604,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;
const int MOD = (int)1e9 + 7;

ll C[1010][1010];

class Solution {
public:
    ll binpow(ll x, ll n) {
        ll res = 1;
        while (n) {
            if (n & 1)
                res = (res * x) % MOD;
            x = (x * x) % MOD;
            n /= 2;
        }
        return res;
    }
    
    void fillCnk(int n) {
        for (int i = 0; i <= n; i++) {
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
            }
        }
    }
    
    int numberOfWays(int n, int x, int y) {
        fillCnk(1000);
        ll ans = 0, preval = 0;
        vector<ll> dp(1010);
        for (int i = 1; i <= min(x, n); i++) {
            ll cnt = C[x][i];
            ll sub = 0;
            for (int j = 1; j < i; j++)
                sub = (sub + dp[j] * C[i][j]) % MOD;
            ll val = (binpow(i, n) - sub + MOD) % MOD;
            dp[i] = val;
            ans = (ans + cnt * val % MOD * binpow(y, i)) % MOD;
        }
        return ans;
    }
};",1420125398
Batyrkhan Altynbekov,Arch_of_Triumph,354,3605,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = sz(a);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            int x = a[i];
            if (x == 2) {
                ans.pb(-1);
                continue;
            }
            for (int j = 0; j <= 11; j++) {
                if (!(x >> j & 1)) {
                    ans.pb(x ^ (1 << (j - 1)));
                    break;
                }
            }
        }
        return ans;
    }
};",1419996995
Batyrkhan Altynbekov,Arch_of_Triumph,354,3611,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = sz(a);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            int x = a[i];
            if (x == 2) {
                ans.pb(-1);
                continue;
            }
            for (int j = 0; j <= 30; j++) {
                if (!(x >> j & 1)) {
                    ans.pb(x ^ (1 << (j - 1)));
                    break;
                }
            }
        }
        return ans;
    }
};",1419998460
Bashem,bashem,355,3487,cpp,"class Solution {
    int solve(int source_index, int pattern_index, vector<vector<int>> &dp, string &source, string &pattern, unordered_set<int> &targetIndices) {
        if(source_index == source.size()) {
            if(pattern_index == pattern.size()) return 0;

            return INT_MIN;
        }

        auto &res = dp[source_index][pattern_index];
        if(res != -1) return res;

        res = INT_MIN;
        auto res_not_taking_the_index = solve(source_index + 1, pattern_index, dp, source, pattern, targetIndices);

        if(res_not_taking_the_index >= 0) {
            res = max(res, targetIndices.contains(source_index) + res_not_taking_the_index);
        }
        
        if(pattern_index != pattern.size() && source[source_index] == pattern[pattern_index]) {
            auto res_taking_the_index = solve(source_index + 1, pattern_index + 1, dp, source, pattern, targetIndices);
            res = max(res, res_taking_the_index);
        }

        return res;
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        auto targetIndicesSet = unordered_set<int>(targetIndices.begin(), targetIndices.end());
        auto dp = vector(source.size(), vector(pattern.size() + 1, -1));

        return solve(0, 0, dp, source, pattern, targetIndicesSet);
    }
};",1420033408
Bashem,bashem,355,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        const int MAX_FACT_INDEX = 2 * max(n, x) + 1;

        auto fact = vector(MAX_FACT_INDEX, 1);
        for (int i = 1; i < MAX_FACT_INDEX; i++)
            fact[i] = (fact[i - 1] * 1LL * i) % MOD;

        auto fact_inv = [&](int index) {
            return big_mod(fact[index], MOD - 2);
        };

        auto getNCR = [&](int nc, int r) {
            auto ncr = fact[nc];
            ncr = (ncr * 1LL * fact_inv(nc - r)) % MOD;
            ncr = (ncr * 1LL * fact_inv(r)) % MOD;

            return ncr;
        };

        auto getSurgective = [&](int a, int b) {
            int ans = 0;
            for (int i = 1; i <= b; i++) {
                int cans = big_mod(-1, b - i);
                cans = (cans * 1LL * getNCR(b, i)) % MOD;
                cans = (cans * 1LL * big_mod(i, a)) % MOD;
                
                cans = (cans + MOD) % MOD;
                ans = (ans + cans) % MOD;
            }

            return ans;
        };

        int ans = 0;
        for (int i = 1; i <= min(n, x); i++) {
            auto cans = (getSurgective(n, i) * 1LL * 1) % MOD;
            
            // cout << ncr << endl;
            cans = (cans * 1LL * getNCR(x, i)) % MOD;
            cans = (cans * 1LL * big_mod(y, i)) % MOD;
            // cout << i << "" ::i:: "" << cans << endl;
            ans = (ans + cans) % MOD;
        }

        return ans;
    }
private:
    typedef long long ll;
    ll big_mod(ll a, ll p)
    {
        ll res = 1 % MOD, x = a % MOD;
        while (p > 0)
        res = ((p & 1) ? ((res * x) % MOD) : res), x = ((x * x) % MOD), p >>= 1;
        return res;
    }
};",1420119209
Bashem,bashem,355,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto ans = vector(nums.size(), -1);

        for (int i = 0; i < nums.size(); i++) {
            if(nums[i] == 2) continue;
            for (int j = 1; j <= nums[i]; j++) {
                if((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }

        return ans;
    }
};",1419996658
Bashem,bashem,355,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto ans = vector(nums.size(), -1);

        for (int i = 0; i < nums.size(); i++) {
            if(nums[i] == 2) continue;

            int consecutive_ones = 0;
            for (int j = 0; j < 31; j++) {
                if((nums[i] & (1 << j)) == 0) break;
                consecutive_ones++;
            }

            int first_part = nums[i] ^ ((1 << consecutive_ones) - 1);
            if(consecutive_ones > 0) first_part ^= ((1 << (consecutive_ones - 1)) - 1);
            ans[i] = first_part;
        }

        return ans;
    }
};",1420008339
thecodereal55,thecodereal55,356,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE; // Use Integer.MAX_VALUE to represent infinity
        }
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        int k =3;
       
        for(int i = 0 ; i<5;i++){
                k++;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420122347
thecodereal55,thecodereal55,356,3604,cpp,"class Solution {
    public:
    typedef long
    long ll;const
    ll MOD = 1e9 + 7;

    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};

    vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }
        int k = 33;
        int kp=3;
        for( int i = 0 ; i< 5 ;i++){
kp++;
        }

    vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

    vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420120274
thecodereal55,thecodereal55,356,3605,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        vector<int> ans(nums.size()); 
        int k =3;
        for(int i= 0 ; i<5;i++){
                k++;
        }
        for (int i = 0; i < nums.size(); i++) { 
            bool found = false; 
            for (int x = 0; x <= nums[i]; x++) { 
                if ((x | (x + 1)) == nums[i]) { 
                    ans[i] = x;  // If condition is satisfied 
                    found = true; 
                    break; 
                } 
            } 
             
            if (!found) { 
                ans[i] = -1;  // No valid value found for ans[i] 
            } 
        } 
         
        return ans; 
    } 
};",1420125564
thecodereal55,thecodereal55,356,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        int k =3;
        for(int i= 0 ; i<5;i++){
            k++;
        }
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420124250
fallen_08,fallen_08,357,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n1 = source.size();
        int n2 = pattern.size();
        vector<double> dp(n2 + 1, numeric_limits<double>::infinity());
        dp[0] = 0;
        vector<bool> res(n1, false);
        for (auto it : targetIndices)
            res[it] = true;
        for (int i = 0; i < n1; i++) {
            for (int j = n2; j > 0; j--) {
                if (source[i] == pattern[j - 1] &&
                    dp[j - 1] != numeric_limits<double>::infinity()) {
                    dp[j] = min(dp[j], dp[j - 1] + (res[i] ? 1 : 0));
                }
            }
        }
        return targetIndices.size() -
               (dp[n2] == numeric_limits<double>::infinity()
                    ? 0
                    : static_cast<int>(dp[n2]));
    }
};
",1420078892
fallen_08,fallen_08,357,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int INF = 1e9 + 7;
        vector<int> vt = {n, x, y};

        vector<vector<int>> arr1(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            arr1[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                arr1[i][j] = (arr1[i - 1][j - 1] + arr1[i - 1][j]) % INF;
            }
        }

        vector<vector<int>> arr2(n + 1, vector<int>(x + 1, 0));
        arr2[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                arr2[i][j] = (arr2[i - 1][j - 1] + (1LL * j * arr2[i - 1][j]) % INF) % INF;
            }
        }

        vector<long long> f(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            f[i] = (f[i - 1] * i) % INF;
        }

        long long ans = 0;
        for (int i = 1; i <= x; i++) {
            long long p = 1;
            for (int j = 0; j < i; j++) {
                p = (p * y) % INF;
            }
            ans = (ans + (1LL * arr1[x][i] % INF * arr2[n][i] % INF * f[i] % INF * p % INF) % INF) % INF;
        }

        return ans;
    }
};
",1420106566
fallen_08,fallen_08,357,3605,cpp,"class Solution {
public:
    int solve(int num) {
        for (int i = 1; i <= num; i++) {
            if ((i | (i + 1)) == num)
                return i;
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++)
            ans[i] = solve(nums[i]);
        return ans;
    }
};",1420015693
fallen_08,fallen_08,357,3611,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &nums)
    {
        vector<int> ans;
        for (auto it : nums)
        {
            vector<int> res;
            for (int i = 0; i < 32; ++i)
            {
                if (it & (1 << i))
                {
                    int newnum = it & ~(1 << i);
                    if ((newnum | (newnum + 1)) == it)
                        res.push_back(newnum);
                }
            }
            if (res.empty())
                ans.push_back(-1);
            else
            {
                int number = *min_element(res.begin(), res.end());
                ans.push_back(number);
            }
        }
        return ans;
    }
};
",1420085456
Krishna Sharma,ks27,358,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:

        m, n = len(pattern), len(source)

        dp = [float('inf') for _ in range(m + 1)]
        dp[0] = 0  
        present = [False for _ in range(n)]
        
        for idx in targetIndices:
            present[idx] = True

        for i in range(n):
            for j in range(m, 0, -1):
                if dp[j - 1] != float('inf') and source[i] == pattern[j - 1]:
                    dp[j] = min(dp[j - 1] + (0 if not present[i] else 1), dp[j])

        if dp[m] == float('inf'):
            return 0
        
        return len(targetIndices) - dp[m]
",1420087389
Krishna Sharma,ks27,358,3604,python3,"MODULO = 10**9 + 7
class Solution:
    def exponent(self, base: int, exp: int, mod: int) -> int:
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % mod
            base = (base * base) % mod
            exp //= 2
        return result

    def conbinations(self, max_value: int) -> List[List[int]]:

        combinations = [[0] * (max_value + 1) for _ in range(max_value + 1)]
        for i in range(max_value + 1):
            combinations[i][0] = 1
            for j in range(1, i + 1):
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MODULO
        return combinations

    def stirling_numbers(self, total_performers: int, max_stages: int) -> List[List[int]]:
        stirling = [[0] * (max_stages + 1) for _ in range(total_performers + 1)]
        stirling[0][0] = 1
        for i in range(1, total_performers + 1):
            for j in range(1, max_stages + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MODULO
        return stirling

    def compute_factorials(self, max_value: int) -> List[int]:
        factorials = [1] * (max_value + 1)
        for i in range(1, max_value + 1):
            factorials[i] = (factorials[i - 1] * i) % MODULO
        return factorials

    def numberOfWays(self, num_performers: int, num_stages: int, max_score: int) -> int:
        # intermediate_values = [num_performers, num_stages, max_score]
        combinations = self.conbinations(num_stages)
        stirling_numbers = self.stirling_numbers(num_performers, num_stages)
        factorials = self.compute_factorials(num_stages)

        total_ways = 0
        for stages_count in range(1, num_stages + 1):
            score_power = self.exponent(max_score, stages_count, MODULO)
            total_ways = (
                total_ways + combinations[num_stages][stages_count] *
                stirling_numbers[num_performers][stages_count] % MODULO *
                factorials[stages_count] % MODULO *
                score_power % MODULO
            ) % MODULO
        
        return total_ways",1420119677
Krishna Sharma,ks27,358,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1 for _ in range(n)] 

        for i in range(n):
            curr = nums[i]
            for x in range(curr): 
                if x | (x + 1) == curr:
                    ans[i] = x
                    break  
        return ans",1419998544
Krishna Sharma,ks27,358,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        
        n = len(nums)
        res = [-1 for _ in range(n)]
        for i in range(n):
            curr = float('inf')
            flag = False
            for j in range(32):
                if nums[i] & (1 << j):
                    x = nums[i] & ~(1 << j)
                    if x | (x + 1) == nums[i]:
                        curr = min(curr, x)
                        flag = True

            if flag: res[i] = curr 
        return res
",1420101879
JosephMother,JosephMother,359,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        n, m = len(source), len(pattern)
        dp = [[-10**10] * (m + 1) for _ in range(n + 1)]
        dp[n][m] = 0
        for i in range(n, -1, -1):
            for j in range(m, -1, -1):
                if i == n and j == m:
                    continue
                if i < n and j < m and source[i] == pattern[j]:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j + 1])
                
                if i < n and i in targetIndices:
                    dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j])
                
                if i < n:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j])
        
        return dp[0][0]",1420046367
JosephMother,JosephMother,359,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        
        fac = [1] * (max(n, x) + 1)
        for i in range(2, max(n, x) + 1):
            fac[i] = fac[i - 1] * i % MOD
        
        m = max(x, n)
        sn = [[0] * (m + 1) for _ in range(m + 1)]
        for i in range(n + 1):
            sn[i][0] = 1 if i == 0 else 0
            sn[i][i] = 1
        
        for i in range(1, n + 1):
            for j in range(1, min(i, x + 1)):
                sn[i][j] = (sn[i - 1][j - 1] + j * sn[i - 1][j]) % MOD
        
        ans = 0
        for i in range(1, x + 1):
            ans += ( comb(x, i) * sn[n][i] * fac[i] * pow(y, i, MOD)) % MOD
            ans %= MOD
        
        return ans",1420107591
JosephMother,JosephMother,359,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                b = bin(num)[2:]
                zero = -1
                for i in range(len(b)-1, -1, -1):
                    if b[i] == ""0"":
                        zero = i
                        break

                b = b[0:zero+1] + '0' + b[zero+2:]
                ans.append(int(b, 2))
                
        return ans


        ",1420020998
JosephMother,JosephMother,359,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                b = bin(num)[2:]
                zero = -1
                for i in range(len(b)-1, -1, -1):
                    if b[i] == ""0"":
                        zero = i
                        break

                b = b[0:zero+1] + '0' + b[zero+2:]
                ans.append(int(b, 2))
                
        return ans


        ",1420020610
Shivam Verma,verma_shivam,360,3487,java,"class Solution {

    private int[] initializeMinRemovals(int subsequenceLength) {
        int[] minRemovals = new int[subsequenceLength + 1];
        Arrays.fill(minRemovals, Integer.MAX_VALUE);
        minRemovals[0] = 0;
        return minRemovals;
    }

    private void calculateMinRemovals(String originalString, String subsequence, int[] minRemovals, boolean[] canRemove) {
        int originalLength = originalString.length();
        int subsequenceLength = subsequence.length();
        
        for (int currentIndex = 0; currentIndex < originalLength; currentIndex++) {
            for (int subsequenceIndex = subsequenceLength; subsequenceIndex > 0; subsequenceIndex--) {
                if (originalString.charAt(currentIndex) == subsequence.charAt(subsequenceIndex - 1) 
                        && minRemovals[subsequenceIndex - 1] != Integer.MAX_VALUE) {
                    minRemovals[subsequenceIndex] = Math.min(minRemovals[subsequenceIndex], 
                        minRemovals[subsequenceIndex - 1] + (canRemove[currentIndex] ? 1 : 0));
                }
            }
        }
    }

    public int maxRemovals(String originalString, String subsequence, int[] removableIndices) {
        int originalLength = originalString.length();
        int subsequenceLength = subsequence.length();
        int[] minRemovals = initializeMinRemovals(subsequenceLength);
        boolean[] canRemove = createRemovableArray(originalLength, removableIndices);
        
        calculateMinRemovals(originalString, subsequence, minRemovals, canRemove);
        
        return calculateMaximumRemovals(removableIndices.length, minRemovals[subsequenceLength]);
    }

    private boolean[] createRemovableArray(int originalLength, int[] removableIndices) {
        boolean[] canRemove = new boolean[originalLength];
        for (int index : removableIndices) {
            canRemove[index] = true;
        }
        return canRemove;
    }

    private int calculateMaximumRemovals(int totalRemovals, int requiredRemovals) {
        return totalRemovals - (requiredRemovals == Integer.MAX_VALUE ? 0 : requiredRemovals);
    }
}
",1420074955
Shivam Verma,verma_shivam,360,3604,java,"public class Solution {
    private static final int MOD_VALUE = 1000000007;

    public int numberOfWays(int performers, int stages, int maxScore) {
        int[] inputData = {performers, stages, maxScore};

        long[][] combinations = computeCombinations(stages);
        long[] factorials = generateFactorials(stages);
        long[][] stirlingNumbers = calculateStirlingNumbers(performers, stages);

        return computeTotalWays(performers, stages, maxScore, combinations, stirlingNumbers, factorials);
    }

    private long[][] computeCombinations(int stages) {
        long[][] combination = new long[stages + 1][stages + 1];
        for (int i = 0; i <= stages; i++) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD_VALUE;
            }
        }
        return combination;
    }

    private long[] generateFactorials(int stages) {
        long[] factorials = new long[stages + 1];
        factorials[0] = 1;
        for (int i = 1; i <= stages; i++) {
            factorials[i] = (factorials[i - 1] * i) % MOD_VALUE;
        }
        return factorials;
    }

    private int computeTotalWays(int performers, int stages, int maxScore, 
                                  long[][] combinations, long[][] stirlingNumbers, long[] factorials) {
        long totalWays = 0;
        for (int k = 1; k <= stages; k++) {
            long scoreMultiplier = computeScoreMultiplier(maxScore, k);
            totalWays = (totalWays + calculateContribution(combinations, stirlingNumbers, factorials, performers, k, scoreMultiplier)) % MOD_VALUE;
        }
        return (int) totalWays;
    }

    private long calculateContribution(long[][] combinations, long[][] stirlingNumbers, long[] factorials, 
                                       int performers, int k, long scoreMultiplier) {
        return combinations[combinations.length - 1][k] * stirlingNumbers[performers][k] % MOD_VALUE 
               * factorials[k] % MOD_VALUE * scoreMultiplier % MOD_VALUE;
    }

    private long computeScoreMultiplier(int maxScore, int k) {
        long multiplier = 1;
        for (int p = 0; p < k; p++) {
            multiplier = (multiplier * maxScore) % MOD_VALUE;
        }
        return multiplier;
    }

    private long[][] calculateStirlingNumbers(int performers, int stages) {
        long[][] stirling = new long[performers + 1][stages + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= performers; i++) {
            for (int j = 1; j <= stages; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD_VALUE + stirling[i - 1][j - 1]) % MOD_VALUE;
            }
        }
        return stirling;
    }
}
",1420120969
Shivam Verma,verma_shivam,360,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> primeList) {
        int totalPrimes = primeList.size();
        int[] finalResult = new int[totalPrimes];

        for (int currentPosition = 0; currentPosition < totalPrimes; currentPosition++) {
            finalResult[currentPosition] = -1;
            int primeValue = primeList.get(currentPosition);
            for (int potentialAnswer = 0; potentialAnswer < primeValue; potentialAnswer++) {
                if ((potentialAnswer | (potentialAnswer + 1)) == primeValue) {
                    finalResult[currentPosition] = potentialAnswer;
                    break;
                }
            }
        }

        return finalResult;
    }
}",1419997750
Shivam Verma,verma_shivam,360,3611,java,"class Solution 
{
  private boolean isValidValue(int potentialValue, int targetNumber) {
        return (potentialValue >= 0) && ((potentialValue | (potentialValue + 1)) == targetNumber);
    }  
     private int clearBitAtPosition(int number, int bitPosition) {
        return number & ~(1 << bitPosition);
    }
public int[] minBitwiseArray(List<Integer> primeList) {
        int length = primeList.size();
        int[] resultArray = new int[length];
    for (int index = 0; index < length; index++) {
            int primeNumber = primeList.get(index);
            resultArray[index] = determineSmallestValidValue(primeNumber);
        } return resultArray;
    }

    

   

    private boolean isBitSet(int number, int position) {
        return ((number >> position) & 1) == 1;
    }

    private int determineSmallestValidValue(int number) {
        int smallestValue = Integer.MAX_VALUE;
  boolean validValueExists = false;

        for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
            if (isBitSet(number, bitPosition)) {
                int modifiedValue = clearBitAtPosition(number, bitPosition);
                
 if (isValidValue(modifiedValue, number)) {
                    if (modifiedValue < smallestValue) {
 smallestValue = modifiedValue;
                        validValueExists = true;
 }      }  } }

        return validValueExists ? smallestValue : -1;
    }
}
",1420057277
Arjun Nayak,Arjun_Nayak1234,361,3487,cpp,"class Solution {
public:
   int n,m;
   int solve(string sc, string pt, vector<int>& targetIndices){
    vector<int> dp(m + 1,INT_MAX);
        dp[0] = 0;
        
        vector<bool> checkTar(n, false);
        for (int idx : targetIndices) {
            checkTar[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (sc[i] == pt[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (checkTar[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] != INT_MAX? dp[m] :0);
   }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
         n = source.length();
         m = pattern.length();
        return solve(source,pattern,targetIndices);
    }
};",1420101681
Arjun Nayak,Arjun_Nayak1234,361,3604,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;
    using ll=long long;
    int solve(int n, int tp, int multiplier){
         vector<vector<int>> dp(tp + 1, vector<int>(tp + 1, 0));
        for (int i = 0; i <= tp; i++) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> dpNum(n + 1, vector<int>(tp + 1, 0));
        dpNum[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= tp; ++j) {
                dpNum[i][j] = (1LL * j * dpNum[i - 1][j] + dpNum[i - 1][j - 1]) % MOD;
            }
        }
        vector<int> fac(tp + 1, 1);
        for (int i = 1; i <= tp; ++i) {
            fac[i] = (1LL * fac[i - 1] * i) % MOD;
        }
        ll ways = 0;
        for (int k = 1; k <= tp; ++k) {
            ll multi = 1;
            for (int i = 0; i < k; ++i) {
                multi = (multi * multiplier) % MOD;
            }
            ways = (ways + (1LL * dp[tp][k] * dpNum[n][k] % MOD * fac[k] % MOD * multi % MOD)) % MOD;
        }
        return ways;
    }
    int numberOfWays(int n, int totalParts, int multiplier) {
       return solve(n, totalParts, multiplier);
    }
};",1420121176
Arjun Nayak,Arjun_Nayak1234,361,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         vector<int> result(nums.size(), -1);
    
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 0; j <= nums[i]; j++) {
            if ((j | (j + 1)) == nums[i]) {
                result[i] = j;
                break;
            }
        }
    }
    
    return result;
    }
};",1419995065
Arjun Nayak,Arjun_Nayak1234,361,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputNumbers) {
        int totalNumbers = inputNumbers.size();
        vector<int> resultArray(totalNumbers);
        
        for (int index = 0; index < totalNumbers; index++) {
            int currentNum = inputNumbers[index];
            int smallestCandidate = INT_MAX;
            bool isCandidateFound = false;
            
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (((currentNum >> bitPosition) & 1) == 1) {
                    int possibleAnswer = currentNum & ~(1 << bitPosition);
                    if (possibleAnswer < 0) continue;
                    if ((possibleAnswer | (possibleAnswer + 1)) == currentNum) {
                        if (possibleAnswer < smallestCandidate) {
                            smallestCandidate = possibleAnswer;
                            isCandidateFound = true;
                        }
                    }
                }
            }
            
            if (isCandidateFound) {
                resultArray[index] = smallestCandidate;
            } else {
                resultArray[index] = -1;
            }
        }
        
        return resultArray;
    }
};
",1420051864
newmamuhere,newmamuhere,362,3487,cpp,"class Solution {
public:
    int countGreaterOrEqual(set<int>& s, int x) {
        auto it = s.lower_bound(x);
        if (it == s.end()) return 0;
        return distance(it, s.end());
    }
    
    int solve(int i, int j, set<int>& se, string &s, string &p, vector<vector<int>>& dp) {
        if (j == p.size()) return countGreaterOrEqual(se, i);
        if (i >= s.size()) return INT_MIN;

        // If already computed, return the stored value
        if (dp[i][j] != -1) return dp[i][j];

        int ans = INT_MIN;
        
        // Check if 'i' is in the set and can be removed
        if (se.find(i) != se.end()) {
            ans = max(ans, 1 + solve(i + 1, j, se, s, p, dp));
        }
        
        // Match current character in source and pattern
        if (s[i] == p[j]) {
            ans = max(ans, solve(i + 1, j + 1, se, s, p, dp));
        } else {
            ans = max(ans, solve(i + 1, j, se, s, p, dp));
        }
        
        // Store the result in the DP table
        return dp[i][j] = ans;
    }

    int maxRemovals(string source, string pattern, vector<int>& t) {
        set<int> se;
        for (int i = 0; i < t.size(); i++) se.insert(t[i]);

        // Initialize DP table with -1 (uncomputed state)
        vector<vector<int>> dp(source.size(), vector<int>(pattern.size(), -1));
        
        // Start solving from the beginning of both source and pattern
        return solve(0, 0, se, source, pattern, dp);
    }
};
",1420084831
newmamuhere,newmamuhere,362,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;

    vector<vector<ll>> computeBinomialCoefficients(ll maxVal) {
        vector<vector<ll>> binom(maxVal + 1, vector<ll>(maxVal + 1, 0));
        for (ll i = 0; i <= maxVal; i++) {
            binom[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;
            }
        }
        return binom;
    }

    vector<vector<ll>> computeStirlingNumbers(ll n, ll maxVal) {
        vector<vector<ll>> stirling(n + 1, vector<ll>(maxVal + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= maxVal; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        return stirling;
    }

    vector<ll> computeFactorials(ll maxVal) {
        vector<ll> factorial(maxVal + 1, 1);
        for (ll i = 1; i <= maxVal; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        return factorial;
    }

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> binomial = computeBinomialCoefficients(x);
        vector<vector<ll>> stirling = computeStirlingNumbers(n, x);
        vector<ll> factorial = computeFactorials(x);

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + binomial[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420121195
newmamuhere,newmamuhere,362,3605,cpp,"class Solution {
public:

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 2) {
                ans.push_back(-1);
            }
            else{
                int n=nums[i] ,y=n,k=0;
                while(y>0){
                    if((y&1)==0)  break;
                     k++;
                     y=(y>>1);
                }
                k--;
                //cout<<k<<endl;
                int d=0,j=0;
                while(n>0){
                      if(k!=j) {d=(d|((n&1)<<j));}
                      j++;
                      n=(n>>1);
                }
                ans.push_back(d);
            }
        }
        return ans;
    }
};
",1420037178
newmamuhere,newmamuhere,362,3611,cpp,"class Solution {
public:
    bool all1(int n) {
        while (n > 0) {
            if ((n & 1) == 0) return false;
            n >>= 1; // Simplified shift operation
        }
        return true;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 2) {
                ans.push_back(-1);
            }
            else{
                int n=nums[i] ,y=n,k=0;
                while(y>0){
                    if((y&1)==0)  break;
                     k++;
                     y=(y>>1);
                }
                k--;
                //cout<<k<<endl;
                int d=0,j=0;
                while(n>0){
                      if(k!=j) {d=(d|((n&1)<<j));}
                      j++;
                      n=(n>>1);
                }
                ans.push_back(d);
            }
        }
        return ans;
    }
};
",1420036336
Tanuj Vats,tanuj_1099,363,3487,cpp,"class Solution {
public:
    vector<vector<long long>> dp;
    long long rec(string& s, string& p, int i, int j,set<int>& mp){
        if(j==p.size()){
            return 0;
        }
        if(i==s.size()){
            return INT_MAX;
        }
        long long ans=0;
       if(dp[i][j]!=-1){
           return dp[i][j];
       }
       ans=rec(s,p,i+1,j,mp);
        if(s[i]==p[j]){
            if(mp.find(i)!=mp.end()){
                ans=min(ans,1+rec(s,p,i+1,j+1,mp));
            }
            else
                ans=min(ans,rec(s,p,i+1,j+1,mp));
        }
        
        
        return dp[i][j]=ans;
    }
    int maxRemovals(string s, string p, vector<int>& t) {
         dp.resize(s.size(),vector<long long>(p.size(),-1));
       set<int> mp;
        for(auto it:t){
            mp.insert(it);
        }
        
        return t.size()-rec(s,p,0,0,mp);
    }
};",1420042326
Tanuj Vats,tanuj_1099,363,3604,cpp,"class Solution {

public:

     static const int M = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
     vector<vector<long long>> c(x + 1, vector<long long>(x + 1, 0));
     vector<vector<long long>> s(n + 1,vector<long long>(x + 1, 0));
     vector<long long> fct(x + 1, 1); 
        long long t = 0;
        for (int i = 1; i <= x; ++i) {
            fct[i] = (1LL * fct[i - 1] * i) % M;
        }
    
        

        s[0][0] = 1;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % M;
            }
        }

        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % M;
            }
        }
        for (int k = 1; k <= x; ++k) {
            long long yp = 1;
            for (int i = 0; i < k; ++i) {
                yp = (yp * y) % M;
            }
            t = (t + (c[x][k] * s[n][k] % M * fct[k] % M * yp % M)) % M;
        }

        return t;
    }

};",1420115764
Tanuj Vats,tanuj_1099,363,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        vector<int> ans;
        for(auto it:nums){
            if(it==2){
            ans.push_back(-1);
            }
            else{
                int c=0;
                for(int i=0;i<32;i++){
                    if(((1<<i)&it)>0){
                        c++;
                    }else{
                        i=33;
                    }
                }
                c--;
                //cout<<c<<endl;
                ans.push_back(it xor 1<<c);
            }
        }
        
        return ans;
    }
};",1420014734
Tanuj Vats,tanuj_1099,363,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        vector<int> ans;
        for(auto it:nums){
            if(it==2){
            ans.push_back(-1);
            }
            else{
                int c=0;
                for(int i=0;i<32;i++){
                    if(((1<<i)&it)>0){
                        c++;
                    }else{
                        i=33;
                    }
                }
                c--;
                //cout<<c<<endl;
                ans.push_back(it xor 1<<c);
            }
        }
        
        return ans;
    }
};",1420014377
rck11,rck11,364,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        t_set = set(targetIndices)
        INF = n + 1 
        dp = [[INF] * (m + 1) for _ in range(n + 1)]
        for i in range(n + 1):
            dp[i][0] = 0  
        for i in range(1, n + 1):
            for j in range(0, min(i, m) + 1):
                if j > 0 and source[i - 1] == pattern[j - 1]:
                    cost = 1 if (i - 1) in t_set else 0
                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + cost)
                else:
                    
                    dp[i][j] = dp[i - 1][j]

        required_in_T = dp[n][m]
        if required_in_T > len(targetIndices):
            return 0
        max_removals = len(targetIndices) - required_in_T
        return max_removals",1420122631
rck11,rck11,364,3604,python3,"MOD = 10**9 +7


class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        max_nx = max(n,x)
        fact = [1]*(max_nx+1)
        inv_fact = [1] *(max_nx+1)
        for i in range(1,max_nx +1):
            fact[i] = fact[i-1]*i%MOD
        inv_fact[max_nx] = pow(fact[max_nx], MOD - 2, MOD)
        for i in range(max_nx - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        def comb(n, k):
            if k < 0 or k > n:
                return 0
            return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD
        S = [ [0] * (n + 1) for _ in range(n + 1) ]
        S[0][0] = 1

        for i in range(1, n + 1):
            for k in range(1, i + 1):
                S[i][k] = (k * S[i - 1][k] + S[i - 1][k - 1]) % MOD

        total_ways = 0
        min_k = min(n, x)
        for k in range(1, min_k + 1):
            c = comb(x, k)
            k_fact = fact[k]
            S_nk = S[n][k]
            yk = pow(y, k, MOD)
            term = c * k_fact % MOD * S_nk % MOD * yk % MOD
            total_ways = (total_ways + term) % MOD
        return total_ways

        ",1420097158
rck11,rck11,364,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i =0;i< n;i++){
            ans[i] = findMinimal(nums.get(i));
        }
        return ans;
    }


    private int findMinimal(int a){
        List<Integer> bits = getbits(a);
        int min= Integer.MAX_VALUE;
        for(int i : bits){
            long mask = ~(1L<<i);
            int temp = (int)(a&mask);

            if(temp >=0 && ((temp | (temp+1))==a)){
                if(temp< min){
                    min = temp;
                }
            }
        }
          if(min !=Integer.MAX_VALUE ){
                return min;
            }
            else
            return -1;
    }


    private List<Integer> getbits(int a){
        List<Integer> bits = new ArrayList<>();
        for(int k =31;k>=0;k--){
            if(((a>>>k)&1)==1){
                bits.add(k);
            }
        }
        return bits;
    }
}",1420047138
rck11,rck11,364,3611,java,"class Solution {
        public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i =0;i< n;i++){
            ans[i] = findMinimal(nums.get(i));
        }
        return ans;
    }


    private int findMinimal(int a){
        List<Integer> bits = getbits(a);
        int min= Integer.MAX_VALUE;
        for(int i : bits){
            long mask = ~(1L<<i);
            int temp = (int)(a&mask);

            if(temp >=0 && ((temp | (temp+1))==a)){
                if(temp< min){
                    min = temp;
                }
            }
        }
          if(min !=Integer.MAX_VALUE ){
                return min;
            }
            else
            return -1;
    }


    private List<Integer> getbits(int a){
        List<Integer> bits = new ArrayList<>();
        for(int k =31;k>=0;k--){
            if(((a>>>k)&1)==1){
                bits.add(k);
            }
        }
        return bits;
    }
}",1420064494
avishaan,avishaan,365,3487,cpp,"class Solution {
public:
    int helper(int i, int j, string &source, string &pattern, vector<int> &index, vector<vector<int>> &dp, vector<int> &visited, vector<int> &suff){
        if(j == pattern.length())
            return suff[i];
        if(i == source.length())
            return -1e8;
        if(dp[i][j] != -1e9)
            return dp[i][j];
        dp[i][j] = -1e8;
        dp[i][j] = helper(i + 1, j, source, pattern, index, dp, visited, suff);
        if(dp[i][j] != -1e8 && visited[i])
            dp[i][j] += 1;
        if(source[i] == pattern[j])
            dp[i][j] = max(dp[i][j], helper(i + 1, j + 1, source, pattern, index, dp, visited, suff));
        return dp[i][j];
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>>dp(n, vector<int>(m, -1e9));
        vector<int>visited(n, 0), suff(n + 1, 0);
        for(auto &index:targetIndices)
            visited[index] = 1;
        for(int i = n - 1; i >= 0; i--)
            suff[i] = suff[i + 1] + visited[i];
        return helper(0, 0, source, pattern, targetIndices, dp, visited, suff);
    }
};",1420122722
avishaan,avishaan,365,3604,cpp,"using ll = long long;
const int maxN = 1000, mod = 1e9 + 7;

vector<vector<ll>> dp(maxN + 1, vector<ll>(maxN + 1, 0));
vector<ll> fact(maxN + 1, 1), invFact(maxN + 1, 1);

ll binaryExp(ll a, ll b){
    ll ans = 1;
    while(b){
        if(b & 1)
            ans = (ans * a) % mod;
        a = (a * a) % mod;
        b /= 2;
    }
    return ans;
}

void precompute() {
    dp[0][0] = 1;
    for (int n = 1; n <= maxN; ++n)
        dp[n][0] = 0;

    for (int n = 1; n <= maxN; ++n) {
        for (int k = 1; k <= n; ++k) 
            dp[n][k] = (k * dp[n - 1][k] + dp[n - 1][k - 1]) % mod;
    }

    for (int i = 2; i <= maxN; ++i){
        fact[i] = (fact[i - 1] * i) % mod;
        invFact[i] = binaryExp(fact[i], mod - 2);
    }
}

ll nCr(ll n, ll r){
    if(r == 0 || r == n)
        return 1;
    if(r < 0 || r > n)
        return 0;
    return (((fact[n] * invFact[r]) % mod) * invFact[n - r]) % mod;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(dp[0][0] == 0)
            precompute();
        vector<ll>pow(x + 1, 1);
        for(ll i = 1; i <= x; i++)
            pow[i] = (pow[i - 1] * y) % mod;
        ll ans = 0;
        for(ll i = 1; i <= x; i++){
            ll add = ((nCr(x, i) * dp[n][i]) % mod * pow[i]) % mod;
            add = (add * fact[i]) % mod;
            ans = (ans + add) % mod;
        }
        return ans;
    }
};",1420081842
avishaan,avishaan,365,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n, -1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < nums[i]; j++){
                int ord = j | (j + 1);
                if(ord == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420002267
avishaan,avishaan,365,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n, -1);
        for(int i = 0; i < n; i++){
            if(nums[i] == 2)
                continue;
            int val = 0;
            bool result = true;
            for(int j = 1; j < 31; j++){
                if(result){
                    if((nums[i] >> j) & 1)
                        val += (1 << (j - 1));
                    else
                        result = false;
                }
                else{
                    if((nums[i] >> j) & 1)
                        val += (1 << j);
                }
            }
            ans[i] = val;
        }
        return ans;
    }
};",1420020682
gaoqiaoheimu,gaoqiaoheimu,366,3487,cpp,"class Solution {
public:

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = targetIndices.size();
        int p = pattern.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for(int k=0;k<=n;k++) {
            for(int i=0;i<=m;i++) {
                dp[k][i] = -1;
            }
        }
        vector<bool> mp(n, false);
        for(auto c: targetIndices) {
            mp[c] = true;
        }
        dp[0][0] = 0;
        for(int k=0;k<n;k++) {
            for(int i=0;i<=m;i++) {
                if (dp[k][i] == -1) continue;
                if (mp[k]) {
                    if (dp[k + 1][i + 1] == -1) {
                        dp[k + 1][i + 1] = dp[k][i];
                    } else {
                        dp[k + 1][i + 1] = min(dp[k + 1][i + 1], dp[k][i]);
                    }
                }
                int c = dp[k][i];
                if (c == p) {
                    dp[k + 1][i] = p;
                    continue;
                }
                if (pattern[c] == source[k]) {
                    if (dp[k + 1][i] == -1) {
                        dp[k + 1][i] = dp[k][i] + 1;
                    } else {
                        dp[k + 1][i] = max(dp[k + 1][i], dp[k][i] + 1);
                    }
                } else {
                    if (dp[k + 1][i] == -1) {
                        dp[k + 1][i] = dp[k][i];
                    } else {
                        dp[k + 1][i] = max(dp[k + 1][i], dp[k][i]);
                    }
                }
            }
        }
        int ans = 0;
        for(int k=0;k<=n;k++) {
            for(int i=0;i<=m;i++) {
                if (dp[k][i] == p) {
                    ans = max(ans, i);
                }
            }
        }
        return ans;
    }
};",1420116601
gaoqiaoheimu,gaoqiaoheimu,366,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        long long mod = 1e9 + 7;
        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));
        dp[1][1] = x;
        for(int k=1;k<n;k++) {
            for(int i=1;i<=min(k, x);i++) {
                dp[k + 1][i] += dp[k][i] * i;
                dp[k + 1][i] %= mod;
                if (i < x) {
                    dp[k + 1][i + 1] += dp[k][i] * (x - i);
                    dp[k + 1][i + 1] %= mod;
                }
            }
        }
        long long now = y;
        long long ans = 0;
        for(int k=1;k<=x;k++) {
            ans += dp[n][k] * now;
            ans %= mod;
            now *= y;
            now %= mod;
        }
        return ans;
    }
};",1420036416
gaoqiaoheimu,gaoqiaoheimu,366,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(auto c: nums) {
            if (c == 2) {
                ans.push_back(-1);
            } else {
                vector<int> tmp;
                while (c) {
                    tmp.push_back(c % 2);
                    c /= 2;
                }
                int m = tmp.size();
                for(int k=0;k<m-1;k++) {
                    if (tmp[k + 1] == 1) {
                        tmp[k] = 0;
                    } else {
                        break;
                    }
                }
                reverse(tmp.begin(), tmp.end());
                int re = 0;
                for(int k=0;k<m;k++) {
                    re *= 2;
                    re += tmp[k];
                }
                ans.push_back(re - 1);
            }
        }
        return ans;
    }
};",1420004358
gaoqiaoheimu,gaoqiaoheimu,366,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(auto c: nums) {
            if (c == 2) {
                ans.push_back(-1);
            } else {
                vector<int> tmp;
                while (c) {
                    tmp.push_back(c % 2);
                    c /= 2;
                }
                int m = tmp.size();
                for(int k=0;k<m-1;k++) {
                    if (tmp[k + 1] == 1) {
                        tmp[k] = 0;
                    } else {
                        break;
                    }
                }
                reverse(tmp.begin(), tmp.end());
                int re = 0;
                for(int k=0;k<m;k++) {
                    re *= 2;
                    re += tmp[k];
                }
                ans.push_back(re - 1);
            }
        }
        return ans;
    }
};",1420003991
leetcode_456745,leetcode_456745,367,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& ind) {
        int lenS = s.size(),  lenP = p.size();
        vector<int> dp(lenP + 1, numeric_limits<int>::max());
        vector<bool> vis(lenS, false);
        for (int i : ind) vis[i] = true;
        dp[0] = 0;
        for (int i = 0; i < lenS; ++i) {
            for (int j = lenP; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != numeric_limits<int>::max()) dp[j] = min(dp[j], dp[j - 1] + (vis[i] ? 1 : 0));
            }
        }
        return ind.size() - (dp[lenP] == numeric_limits<int>::max() ? 0 : dp[lenP]);
    }
};",1420095181
leetcode_456745,leetcode_456745,367,3604,cpp,"class Solution {
public:
    const long long MOD = 1e9 + 7;

    long long numberOfWays(long long n, long long x, long long y,long long totalWays = 0) {
        vector<vector<long long>> dp1(x + 1, vector<long long>(x + 1, 0));
        vector<vector<long long>> dp2(n + 1, vector<long long>(x + 1, 0));
        vector<long long> factorials = calculateFactorials(x);
        
        dp2[0][0] = 1;
        for (long long i = 1; i <= n; ++i) {
            for (long long j = 1; j <= x; ++j)  dp2[i][j] = (j * dp2[i - 1][j] + dp2[i - 1][j - 1]) % MOD;
        }
        
        for (long long i = 0; i <= x; ++i) {
            dp1[i][0] = 1;
            for (long long j = 1; j <= i; ++j)   dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % MOD;
        }
        for (long long k = 1; k <= x; ++k) {
            totalWays = (totalWays + dp1[x][k] * dp2[n][k] % MOD * factorials[k] % MOD * inv(y, k,MOD)) % MOD;
        }
        return totalWays;
    }

private:
    vector<long long> calculateFactorials(long long limit) {
        vector<long long> factorials(limit + 1, 1);
        for (long long i = 1; i <= limit; ++i) {
            factorials[i] = factorials[i - 1] * i % MOD;
        }
        return factorials;
    }
    long long inv(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
};",1420122795
leetcode_456745,leetcode_456745,367,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto ele:nums){
            int temp = -1;
            for(int i = 1;i<ele;i++){
                int num = i | (i + 1);
                if(num == ele){
                  temp = i;
                  break;
                }
            };
                res.push_back(temp);
        }
        return res;
    }
};",1420000023
leetcode_456745,leetcode_456745,367,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums,vector<int> ans = {}) {
        for (auto ele:nums) {
            int  res = numeric_limits<int>::max();
            for (int bit = 0; bit <= 30; bit++) {
                if (ele & (1 << bit)) {
                    int temp = ele & ~(1 << bit);
                    if ((temp | (temp + 1)) == ele)  res = min(res, temp);
                }
            }
            ans.push_back((res == numeric_limits<int>::max()) ? -1 : res);
        }
        
        return ans;
    }
};",1420067799
Anshuman Tripathi,anshumantripathi878,368,3487,cpp,"class Solution {
public:
    int solve(const string& source, const string& pattern, const vector<int>& targetIndices) {
    int sourceLength = source.length();
    int patternLength = pattern.length();

    vector<int> minTargets(patternLength + 1, numeric_limits<int>::max());
    minTargets[0] = 0;

    vector<bool> targetCheck(sourceLength, false);
    for (int pos : targetIndices) {
        targetCheck[pos] = true;
    }

    for (int i = 0; i < sourceLength; i++) {
        for (int j = patternLength; j > 0; j--) {
            if (source[i] == pattern[j - 1] && minTargets[j - 1] != numeric_limits<int>::max()) {
                minTargets[j] = min(minTargets[j], minTargets[j - 1] + (targetCheck[i] ? 1 : 0));
            }
        }
    }

    return targetIndices.size() - (minTargets[patternLength] == numeric_limits<int>::max() ? 0 : minTargets[patternLength]);
}

int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    return solve(source, pattern, targetIndices);
}

};",1420123215
Anshuman Tripathi,anshumantripathi878,368,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

vector<vector<int>> calculateCombinations(int p) {
    vector<vector<int>> C(p + 1, vector<int>(p + 1, 0));
    for (int i = 0; i <= p; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
    return C;
}

vector<vector<int>> calculateStirling(int n, int p) {
    vector<vector<int>> S(n + 1, vector<int>(p + 1, 0));
    S[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= p; ++j) {
            S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
        }
    }
    return S;
}

vector<int> calculateFactorials(int p) {
    vector<int> F(p + 1, 1);
    for (int i = 1; i <= p; ++i) {
        F[i] = (1LL * F[i - 1] * i) % MOD;
    }
    return F;
}

int numberOfWays(int n, int p, int m) {
    auto C = calculateCombinations(p);
    auto S = calculateStirling(n, p);
    auto F = calculateFactorials(p);

    long long T = 0;
    for (int k = 1; k <= p; ++k) {
        long long P = 1;
        for (int i = 0; i < k; ++i) {
            P = (P * m) % MOD;
        }
        T = (T + (1LL * C[p][k] * S[n][k] % MOD * F[k] % MOD * P % MOD)) % MOD;
    }
    return T;
}
};",1420115343
Anshuman Tripathi,anshumantripathi878,368,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); 

    for (int i = 0; i < nums.size(); i++) {
        int target = nums[i];
        vector<int> candidates;

        
        for (int num = 0; num <= target; num++) {
            if ((num | (num + 1)) == target) {
                candidates.push_back(num);
                if (candidates.size() == 2) break; 
            }
        }

        
        if (!candidates.empty()) {
            ans[i] = candidates[0]; 
        }
    }

    return ans;

    }
};",1420005843
Anshuman Tripathi,anshumantripathi878,368,3611,cpp,"class Solution {
public:
    vector<int> solve(vector<int>& nums) {
    int sz = nums.size();
    vector<int> res(sz);
    
    for (int i = 0; i < sz; i++) {
        int n = nums[i];
        int minVal = numeric_limits<int>::max();
        bool found = false;
        
        for (int b = 0; b <= 30; b++) {
            if (((n >> b) & 1) == 1) {
                int c = n & ~(1 << b);
                if (c < 0) continue;
                if ((c | (c + 1)) == n) {
                    if (c < minVal) {
                        minVal = c;
                        found = true;
                    }
                }
            }
        }
        
        if (found) {
            res[i] = minVal;
        } else {
            res[i] = -1;
        }
    }
    
    return res;
}

vector<int> minBitwiseArray(vector<int>& nums) {
    return solve(nums);
}
};",1420056507
Abineth,abineth,371,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n,m=len(s),len(p)
        tar=[0 for i in range(n)]
        for i in t:
            tar[i]=1
        dp=[[int(1e18) for i in range(m+1)] for j in range(n+1)]
        @cache
        def solve(i,j):
            if j==m:
                return 0
            if i==n:
                return int(1e18)
            if dp[i][j]!=int(1e18):
                return dp[i][j]
            dp[i][j]=solve(i+1,j)
            if s[i]==p[j]:
                dp[i][j]=min(dp[i][j],solve(i+1,j+1)+tar[i])
            return dp[i][j]
        ans=len(t)
        res=solve(0,0)
        if res!=int(1e18):
            ans-=res
        return ans
",1420118158
Abineth,abineth,371,3604,python3,"mod=int(1e9)+7
def factorial(n):
    fac=[1 for i in range(n+1)]
    for i in range(2,n+1):
        fac[i]=(i*fac[i-1])%mod
    return fac
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        fac=factorial(x)
        ans=0
        dp=[[0 for i in range(min(n,x)+1)] for j in range(n+1)]
        dp[0][0]=1
        for i in range(1,n+1):
            for j in range(1,min(n,x)+1):
                dp[i][j]=(j*dp[i-1][j]+dp[i-1][j-1])%mod
        for k in range(1,min(n,x)+1):
            ans=(ans+(dp[n][k]%mod)*((fac[x]*pow(fac[x-k],mod-2,mod))%mod)*(pow(y,k,mod)%mod))%mod
        return ans",1420075275
Abineth,abineth,371,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans=[]
        for i in a:
            if i==2:
                ans.append(-1)
            else:
                a = 0
                b = i
                while True:
                    if (a | (a + 1)) == b:
                        ans.append(a)
                        break
                    a += 1
        return ans",1420004980
Abineth,abineth,371,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans=[]
        for i in a:
            if i==2:
                ans.append(-1)
            else:
                bi=bin(i)[2:][::-1]
                t=0
                for j in bi:
                    if j=='1':
                        t+=1
                    else:
                        break
                ab='1'+'0'*(t-1)
                if ab=='':
                    ab='0'
                ans.append(i-int(ab,2))
        return ans",1420030684
Kumar Daksh,kumardaksshh,372,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, originalString: str, patternString: str, indexList: List[int]) -> int:
        sourceLength = len(originalString)
        patternLength = len(patternString)
        
        infArray = self.initializeInfArray(patternLength)
        targetFlags = self.markTargetIndices(sourceLength, indexList)
        
        self.updateInfArray(infArray, originalString, patternString, targetFlags)
        
        return self.calculateMaxRemovals(infArray, patternLength, indexList)
    
    def initializeInfArray(self, patternLength: int) -> List[int]:
        infArr = [float('inf')] * (patternLength + 1)
        infArr[0] = 0
        return infArr
    
    def markTargetIndices(self, sourceLength: int, indexList: List[int]) -> List[bool]:
        targetFlagList = [False] * sourceLength
        self.updateTargetFlags(targetFlagList, indexList)
        return targetFlagList
    
    def updateTargetFlags(self, targetFlagList: List[bool], indexList: List[int]):
        for idx in indexList:
            targetFlagList[idx] = True
    
    def updateInfArray(self, infArray: List[int], originalString: str, patternString: str, targetFlags: List[bool]):
        for currentIndex in range(len(originalString)):
            self.processCurrentCharacter(infArray, originalString, patternString, targetFlags, currentIndex)
    
    def processCurrentCharacter(self, infArray: List[int], originalString: str, patternString: str, targetFlags: List[bool], currentIndex: int):
        for patternIndex in range(len(patternString), 0, -1):
            if self.isPatternMatch(originalString, patternString, infArray, currentIndex, patternIndex):
                self.updateInfValue(infArray, patternIndex, targetFlags, currentIndex)
    
    def isPatternMatch(self, originalString: str, patternString: str, infArray: List[int], currentIndex: int, patternIndex: int) -> bool:
        return originalString[currentIndex] == patternString[patternIndex - 1] and infArray[patternIndex - 1] != float('inf')
    
    def updateInfValue(self, infArray: List[int], patternIndex: int, targetFlags: List[bool], currentIndex: int):
        infArray[patternIndex] = min(infArray[patternIndex], infArray[patternIndex - 1] + (1 if targetFlags[currentIndex] else 0))
    
    def calculateMaxRemovals(self, infArray: List[int], patternLength: int, indexList: List[int]) -> int:
        if self.isRemovalPossible(infArray, patternLength):
            return self.getMaxValidRemovals(indexList, infArray, patternLength)
        return len(indexList)
    
    def isRemovalPossible(self, infArray: List[int], patternLength: int) -> bool:
        return infArray[patternLength] != float('inf')
    
    def getMaxValidRemovals(self, indexList: List[int], infArray: List[int], patternLength: int) -> int:
        return len(indexList) - infArray[patternLength]
",1420061896
Kumar Daksh,kumardaksshh,372,3604,cpp,"class Solution {
private:
    long long MODULO() {
        return 1000000007;
    }

    vector<vector<long long>> generateCombinations(int limit) {
        vector<vector<long long>> comb(limit + 1, vector<long long>(limit + 1, 0));
        fillCombinationMatrix(comb, limit);
        return comb;
    }
    
    void fillCombinationMatrix(vector<vector<long long>>& comb, int limit) {
        for (int row = 0; row <= limit; ++row) {
            comb[row][0] = 1;
            for (int col = 1; col <= row; ++col) {
                comb[row][col] = (comb[row - 1][col - 1] + comb[row - 1][col]) % MODULO();
            }
        }
    }

    vector<vector<long long>> generatePartitions(int total, int parts) {
        vector<vector<long long>> partition(total + 1, vector<long long>(parts + 1, 0));
        partition[0][0] = 1;
        fillPartitionMatrix(partition, total, parts);
        return partition;
    }
    
    void fillPartitionMatrix(vector<vector<long long>>& partition, int total, int parts) {
        for (int i = 1; i <= total; ++i) {
            for (int j = 1; j <= parts; ++j) {
                partition[i][j] = (j * partition[i - 1][j] + partition[i - 1][j - 1]) % MODULO();
            }
        }
    }

    vector<long long> generateFactorials(int limit) {
        vector<long long> factorial(limit + 1, 1);
        fillFactorialArray(factorial, limit);
        return factorial;
    }

    void fillFactorialArray(vector<long long>& factorial, int limit) {
        for (int i = 1; i <= limit; ++i) {
            factorial[i] = (factorial[i - 1] * i) % MODULO();
        }
    }
    
    long long computePower(long long base, int exp, long long mod) {
        long long result = 1;
        for (int i = 0; i < exp; ++i) {
            result = (result * base) % mod;
        }
        return result;
    }

    long long computeTerm(long long comb, long long part, long long fact, long long pow, long long mod) {
        return (((comb * part) % mod * fact) % mod * pow) % mod;
    }

public:
    int numberOfWays(int total, int parts, int factor) {
        auto combinations = generateCombinations(parts);
        auto partitions = generatePartitions(total, parts);
        auto factorials = generateFactorials(parts);
        
        long long totalWays = 0;
        for (int count = 1; count <= parts; ++count) {
            long long powerTerm = computePower(factor, count, MODULO());
            long long term = computeTerm(combinations[parts][count], partitions[total][count], factorials[count], powerTerm, MODULO());
            totalWays = (totalWays + term) % MODULO();
        }
        
        return static_cast<int>(totalWays);
    }
};
",1420092042
Kumar Daksh,kumardaksshh,372,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputArray) {
        int sizeOfArray = inputArray.size();
        vector<int> resultArray(sizeOfArray, -1);
        
        for (int index = 0; index < sizeOfArray; ++index) {
            resultArray[index] = computeMinimum(inputArray[index]);
        }
        
        return resultArray;
    }

private:
    int computeMinimum(int primeNumber) {
        return calculateSmallestValue(primeNumber);
    }

    int calculateSmallestValue(int primeCandidate) {
        for (int candidate = 1; candidate <= primeCandidate; ++candidate) {
            if (checkBitwiseCondition(candidate, primeCandidate)) {
                return candidate;
            }
        }
        return returnInvalidValue();
    }

    bool checkBitwiseCondition(int num, int prime) {
        return performBitwiseOr(num, num + 1) == prime;
    }

    int performBitwiseOr(int a, int b) {
        return applyOrOperation(a, b);
    }

    int applyOrOperation(int firstValue, int secondValue) {
        return firstValue | secondValue;
    }

    int returnInvalidValue() {
        return -1;
    }
};
",1420010597
Kumar Daksh,kumardaksshh,372,3611,cpp,"#include <iostream>
#include <vector>
#include <algorithm>

class Solution {
private:
    // Helper function to process a single number
    int processNumber(int currentNumber) {
        std::vector<int> candidateList = findCandidates(currentNumber);
        return getMinCandidate(candidateList);
    }

    // Helper function to find valid candidates for a number
    std::vector<int> findCandidates(int currentNumber) {
        std::vector<int> candidateList;
        examineBits(currentNumber, candidateList);
        return candidateList;
    }

    // Helper function to examine the bits and find candidates
    void examineBits(int currentNumber, std::vector<int>& candidateList) {
        for (int bitIndex = 0; bitIndex < 32; ++bitIndex) {
            if (checkBit(currentNumber, bitIndex)) {
                int modifiedNumber = flipBit(currentNumber, bitIndex);
                if (checkCondition(modifiedNumber, currentNumber)) {
                    candidateList.push_back(modifiedNumber);
                }
            }
        }
    }

    // Helper function to check if the ith bit is set in the number
    bool checkBit(int number, int bitIndex) {
        return number & (1 << bitIndex);
    }

    // Helper function to flip the ith bit in the number
    int flipBit(int number, int bitIndex) {
        return number & ~(1 << bitIndex);
    }

    // Helper function to check if the modified number satisfies the condition
    bool checkCondition(int modifiedNumber, int originalNumber) {
        return (modifiedNumber | (modifiedNumber + 1)) == originalNumber;
    }

    // Helper function to return the minimum candidate or -1 if none exist
    int getMinCandidate(const std::vector<int>& candidateList) {
        if (candidateList.empty()) {
            return -1;
        }
        return *std::min_element(candidateList.begin(), candidateList.end());
    }

    // Helper function to process the entire array of numbers
    std::vector<int> processArray(const std::vector<int>& inputArray) {
        std::vector<int> results;
        for (int singleNumber : inputArray) {
            results.push_back(processNumber(singleNumber));
        }
        return results;
    }

public:
    // Main function that starts the process
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        return processArray(nums);
    }
};
",1420074152
daisek,daisek,373,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val target = targetIndices.toSet();
        var cache = IntArray(source.length) {0};
        for (j in source.indices) {
            var x = List<Int>(1) {0};
            if (j > 0) {
                x += cache[j-1];
            }
            if (j in target) {
                if (j > 0 && cache[j-1] >= 0) {
                    x += cache[j-1] + 1;
                } else if (j == 0) {
                     x += 1;
                }
            }
            cache[j] = x.max();
        }
            // println(cache.toList())
        for (i in pattern.indices) {
            var cur = IntArray(source.length) {-1};
            for (j in source.indices) {
                var x = List<Int>(1) {-1};
                if (j > 0) {
                    x += cur[j-1];
                    if (pattern[i] == source[j]) {
                        x += cache[j-1];
                    }
                } else if (i == 0) {
                    if (pattern[i] == source[j]) {
                        x += 0;
                    }
                }
                if (j in target) {
                    if (j > 0 && cur[j-1] >= 0) {
                        x += cur[j-1] + 1;
                    }
                }
                cur[j] = x.max();
            }
            // println(cur.toList())
            cache = cur;
        }
        return cache.last();
    }
}",1420056793
daisek,daisek,373,3604,kotlin,"class Solution {
    val modulo: Int = 1000000007;

    fun numberOfWays(n: Int, x: Int, y: Int): Int {
        val nums = numOfWays(n, x);
        val cs = c(x);
        val pows = pow(y, x);
        println(nums)
        println(cs)
        println(pows)
        var res = 0L;
        for (i in 1..x) {
            res += nums[i] * cs[i] % modulo * pows[i] % modulo;
            res %= modulo
        }
        return res.toInt();
    }

    fun numOfWays(n: Int, x: Int): List<Long> {
        var prev = MutableList<Long>(x+1) {0}
        prev[0] = 1
        for (i in 1..n) {
            var cur = MutableList<Long>(x + 1) {0}
            for (j in 1..x) {
                cur[j] = (prev[j-1] + prev[j]) % modulo * j % modulo
            }
            prev = cur;
        }
        return prev
    }

    fun inverse(a: Long) : Long {
        var t: Long = 0;
        var newt: Long = 1
        var r = modulo.toLong();
        var newr = a

        while (newr != 0L) {
            val quotient = r / newr;
            val a = newt;
            newt = (t - quotient * newt) ;
            t = a;
            val b = newr;
            newr = (r - quotient * newr);
            r = b;
        }
        if (t < 0){
            t = t + modulo
        }

        return t
    }

    fun c(x: Int): List<Long> {
        val res = MutableList<Long>(x+1) {1}
        for (i in 1..x) {
            res[i] = (res[i-1] * (x - i + 1)) % modulo * inverse(i.toLong()) % modulo;
        }
        return res;
    }

    fun pow(y: Int, x: Int): List<Long> {
        val res = MutableList<Long>(x+1) {1}
        for (i in 1..x) {
            res[i] = (res[i-1] * y) % modulo;
        }
        return res;
    }
}",1420118221
daisek,daisek,373,3605,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        return nums.map {minBitwise(it)}.toIntArray();
    }

    fun minBitwise(num: Int): Int {
        if (num == 2) {
            return -1;
        }
        var x = 1;
        var y = num;
        while (y % 2 == 1) {
            x *= 2;
            y /= 2;
        }
        return (y * 2 + 1) * x / 2 - 1;
    }
}",1420002915
daisek,daisek,373,3611,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        return nums.map {minBitwise(it)}.toIntArray();
    }

    fun minBitwise(num: Int): Int {
        if (num == 2) {
            return -1;
        }
        var x = 1;
        var y = num;
        while (y % 2 == 1) {
            x *= 2;
            y /= 2;
        }
        return (y * 2 + 1) * x / 2 - 1;
    }
}",1420003868
Krishna,Rookie0934,374,3487,cpp,"class Solution {
public:
    vector<int> vis;
    vector<vector<int>> dp;
    int f(string& s, string& t, int i, int j) {
        if(j == t.length()) return 0;
        if(i == s.length()) return INT_MAX;
        if(dp[i][j] != -1) return dp[i][j];
        int notpick = f(s, t, i+1, j);
        int pick = INT_MAX;
        if(s[i] == t[j]) {
            int x = 0;
            if(vis[i]) x = 1;
            int y = f(s, t, i+1, j+1);
            if(y != INT_MAX) pick = x + y;
        }
        return dp[i][j] = min(pick, notpick);
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        vis.resize(n, 0);
        dp.resize(n, vector<int>(pattern.length(), -1));
        for(auto it: targetIndices) vis[it] = 1;
        int ans = f(source, pattern, 0, 0);
        if(ans == INT_MAX) ans = 0;
        return targetIndices.size() - ans;
    }
};",1420070143
Krishna,Rookie0934,374,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int mod = 1e9 + 7;
        vector<vector<long long>> nCr(x+1);
        for(int i=0; i<=x; i++) {
            nCr[i] = vector<long long>(i+1, 1);
            for(int j=1; j<i; j++) {
                nCr[i][j] = (nCr[i-1][j] + nCr[i-1][j-1]) % mod;
            }
        }
        vector<vector<long long>> v(n + 1, vector<long long>(x+1, 0));
        v[0][0] = 1;
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=x; j++) {
                v[i][j] = (v[i-1][j-1] + (j * 1LL * v[i-1][j]) % mod) % mod;
            }
        }
        long long fact = 1, pow = 1, ans = 0;
        for(int k=1; k<=x; k++) {
            fact *= k;
            fact %= mod;
            pow *= y;
            pow %= mod;
            // cout<<nCr[x][k]<<"" ""<<v[n][k]<<"" ""<<fact<<"" ""<<pow<<endl;
            ans += ((((((nCr[x][k] * v[n][k]) % mod ) * fact)) %mod) * pow) % mod;
            ans %= mod;
        }
        return ans;
    }
};",1420111971
Krishna,Rookie0934,374,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1e9);
        for(int i=0; i<n; i++) {
            for(int j=0; j<=1000; j++) {
                if((j | (j+1)) == nums[i]) ans[i] = min(ans[i], j);
            }
            if(ans[i] == 1e9) ans[i] = -1;
        }
        return ans;
    }
};",1420003508
Krishna,Rookie0934,374,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1e9);
        for(int i=0; i<n; i++) {
            int idx = 0, x = nums[i];
            if(nums[i] == 2) {
                ans[i] = -1;
                continue;
            }
            for(int j=1; j<32; j++) {
                if(((nums[i]>>j) & 1) == 0) {
                    idx = j;
                    x -= (1<<(j-1));
                    break;
                }
                // else x -= (1<<j);
            }
            // x -= (1 << idx);
            int res = nums[i] - 1;
            if((x | (x+1)) == nums[i]) res = min(res,x);
            if ((nums[i] & (nums[i] + 1)) == 0) res = min(res,(nums[i] >> 1));
            ans[i] = res;
        }
        return ans;
    }
};",1420040708
olegmak,olegmak,375,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const int sz = source.size();
        const int psz = pattern.size();
        vector<bool> idx_set(sz);
        for (const int i : targetIndices) {
            idx_set[i] = true;
        }
        
        // vector<vector<int>> cache(sz, vector<int>(sz, -1));
        // auto solve = [&](auto&& solve, int idx1, int idx2) -> int {
        //     if (idx1 == sz) {
        //         return idx2 == psz ? 0 : -1;
        //     }
        //     int& cached = cache[idx1][idx2];
        //     if (cached != -1) {
        //         return cached;
        //     }
        //     int res = -1;
        //     const int r = solve(solve, idx1 + 1, idx2);
        //     if (r != -1) {
        //         res = max(res, (idx_set[idx1] ? 1 : 0) + r);
        //     }
        //     if (idx2 < psz && source[idx1] == pattern[idx2]) {
        //         const int r = solve(solve, idx1 + 1, idx2 + 1);
        //         if (r != -1) {
        //             res = max(res, r);
        //         }
        //     }
        //     return cached = res;
        // };
        // return solve(solve, 0, 0);

        vector<vector<int>> dp(sz + 1, vector<int>(sz + 1));
        for (int i = 0; i <= sz; ++i) {
            dp[sz][i] = i == psz ? 0 : -1;
        }
        for (int idx1 = sz - 1; idx1 >= 0; --idx1) {
            for (int idx2 = sz - 1; idx2 >= 0; --idx2) {
                int res = -1;
                const int r = dp[idx1 + 1][idx2];
                if (r != -1) {
                    res = max(res, (idx_set[idx1] ? 1 : 0) + r);
                }
                if (idx2 < psz && source[idx1] == pattern[idx2]) {
                    const int r = dp[idx1 + 1][idx2 + 1];
                    if (r != -1) {
                        res = max(res, r);
                    }
                }
                dp[idx1][idx2] = res;
            }
        }
        return dp[0][0];
    }
};",1420051936
olegmak,olegmak,375,3604,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
ll mod_pow(ll a, ll b) {
    if (b == 0) {
        return 1;
    }
    ll res = mod_pow(a, b / 2);
    res = res * res % MOD;
    if (b & 1) {
        res = res * a % MOD;
    }
    return res;
}
int s[1000 + 1][1000 + 1];
int fact[1000 + 1];
int fact_inv[1000 + 1];
struct Init {
    Init() {
        for (int i = 0; i <= 1000; ++i) {
            s[i][i] = 1;
        }
        for (ll i = 1; i <= 1000; ++i) {
            for (ll j = 1; j <= 1000; ++j) {
                s[i][j] = (j * s[i - 1][j] % MOD + s[i - 1][j - 1]) % MOD;
            }
        }
        fact[0] = 1;
        for (ll i = 1; i <= 1000; ++i) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        fact_inv[1000] = mod_pow(fact[1000], MOD - 2);
        for (ll i = 1000; i > 0; --i) {
            fact_inv[i - 1] = fact_inv[i] * i % MOD;
        }
    }
} init;
ll n_choose_k(ll n, ll k) {
    return (ll)fact[n] * fact_inv[k] % MOD * fact_inv[n - k] % MOD;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        ll res = 0;
        for (int band_cnt = 1; band_cnt <= x; ++band_cnt) {
            if (n >= band_cnt) {
                // cout << band_cnt << "" "" << s[n][band_cnt] << "" "" << n_choose_k(x, band_cnt) << "" "" << mod_pow(y, band_cnt) << ""\n"";
                res = (res + s[n][band_cnt] * n_choose_k(x, band_cnt) % MOD * fact[band_cnt] % MOD * mod_pow(y, band_cnt) % MOD) % MOD;
            }
        }
        return res;
    }
};",1420124671
olegmak,olegmak,375,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int sz = nums.size();
        vector<int> ans(sz, -1);
        for (int i = 0; i < sz; ++i) {
            for (int j = 0; j <= nums[i]; ++j) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419998420
olegmak,olegmak,375,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int sz = nums.size();
        vector<int> ans(sz, -1);
        for (int i = 0; i < sz; ++i) {
            int pos = -1;
            for (int j = 0; j < 32; ++j) {
                if (((unsigned)nums[i] & (1 << j)) == 0) {
                    break;
                }
                ++pos;
            }
            if (pos == -1) {
                ans[i] = -1;
                continue;
            }
            ans[i] = nums[i] - (1 << pos);
        }
        return ans;
    }
};",1420011120
Anurag Yadav,ECrdnAZlio,376,3487,golang,"package main

import (
	""math""
)

func maxRemovals(source string, pattern string, targetIndices []int) int {
	n := len(source)
	m := len(pattern)

	// Initialize dp array
	dp := make([]int, m+1)
	for i := range dp {
		dp[i] = math.MaxInt32 // Set initial value to a large number
	}
	dp[0] = 0 // 0 removals to match an empty pattern

	// Create a target set for fast lookup
	isTarget := make([]bool, n)
	for _, idx := range targetIndices {
		isTarget[idx] = true
	}

	// DP to find the minimum removals
	for i := 0; i < n; i++ {
		for j := m; j > 0; j-- {
			if source[i] == pattern[j-1] && dp[j-1] != math.MaxInt32 {
				// Update the DP state
				dp[j] = min(dp[j], dp[j-1]+boolToInt(isTarget[i]))
			}
		}
	}

	// Calculate the result
	if dp[m] == math.MaxInt32 {
		return len(targetIndices) // If pattern can't be formed
	}
	return len(targetIndices) - dp[m] // Max removals
}

// Helper function to convert boolean to integer
func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

// Helper function to find minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// // Example usage
// func main() {
// 	source := ""abcde""
// 	pattern := ""ace""
// 	targetIndices := []int{0, 1, 2, 3}

// 	result := maxRemovals(source, pattern, targetIndices)
// 	println(result) // Output should reflect the number of maximum removals possible.
// }
",1420057442
Anurag Yadav,ECrdnAZlio,376,3604,golang,"package main

import ""fmt""

const MOD int64 = 1e9 + 7

func numberOfWays(n int, x int, y int) int {
	// Create a 2D slice for binomial coefficients
	fun := make([][]int64, x+1)
	for i := range fun {
		fun[i] = make([]int64, x+1)
	}
	for i := 0; i <= x; i++ {
		fun[i][0] = 1
		for j := 1; j <= i; j++ {
			fun[i][j] = (fun[i-1][j-1] + fun[i-1][j]) % MOD
		}
	}

	// Create a 2D slice for Stirling numbers of the second kind
	stirling := make([][]int64, n+1)
	for i := range stirling {
		stirling[i] = make([]int64, x+1)
	}
	stirling[0][0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= x; j++ {
			stirling[i][j] = (int64(j)*stirling[i-1][j] + stirling[i-1][j-1]) % MOD
		}
	}

	// Create a slice for factorials
	mathFact := make([]int64, x+1)
	mathFact[0] = 1
	for i := 1; i <= x; i++ {
		mathFact[i] = (mathFact[i-1] * int64(i)) % MOD
	}

	// Calculate the total number of ways
	totalWays := int64(0)
	for k := 1; k <= x; k++ {
		power := int64(1)
		for p := int64(0); p < int64(k); p++ {
			power = (power * int64(y)) % MOD
		}
		totalWays = (totalWays + fun[x][k]*stirling[n][k]%MOD*mathFact[k]%MOD*power%MOD) % MOD
	}

	return int(totalWays) // Return totalWays as int
}

// func main() {
// 	// Example usage
// 	n, x, y := 3, 3, 4
// 	result := numberOfWays(n, x, y)
// 	fmt.Println(result) // Output: 684
// }
",1420112237
Anurag Yadav,ECrdnAZlio,376,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};
",1420016719
Anurag Yadav,ECrdnAZlio,376,3611,golang,"package main

import (
	""fmt""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	ans := make([]int, n)

	for i := 0; i < n; i++ {
		num := nums[i]
		minimalAns := -1 // Initialize to -1 as default

		// Iterate through each bit position (0 to 30)
		for bit := 0; bit <= 30; bit++ {
			// Check if the current bit is set
			if (num>>bit)&1 == 1 {
				// Generate a candidate by unsetting the current bit
				candidate := num &^ (1 << bit)

				// Check if candidate OR (candidate + 1) equals num
				if (candidate|(candidate+1)) == num {
					if minimalAns == -1 || candidate < minimalAns {
						minimalAns = candidate // Update minimal answer
					}
				}
			}
		}

		ans[i] = minimalAns // Assign the minimal candidate found or -1
	}

	return ans
}
",1420043836
CCrack,Shiraz_Zainvi,377,3487,cpp,"class Solution {
public:
    unordered_map<int, int> check;
    //vector<vector<int>> dp;
    // int solve(int i, int j, string& source, string& pattern)
    // {
    //     if(j==pattern.size())
    //     return 0;

    //     if(i==source.size() && j!=pattern.size())
    //     return 1e9;

    //     if(dp[i][j]!=-1)
    //     return dp[i][j];

    //     int a = 1e9, b = 1e9;

    //     a = solve(i+1, j, source, pattern);
    //     if(source[i] == pattern[j])
    //     {
    //         if(check[i]>0)
    //         {
    //             b = min(b, 1+solve(i+1, j+1, source, pattern));
    //         }
    //         else
    //         b = min(b, solve(i+1, j+1, source, pattern));
    //     }
    //     return dp[i][j] = min(a, b);
    // }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        if(source == pattern)
        return 0;
        for(int i:targetIndices)
        check[i]++;
        int M = source.size(), N = pattern.size();
        //dp = vector<vector<int>> (M+1, vector<int>(N+1, 0));
        vector<int> prev(N+1, 0), next(N+1, 0);
        int n = targetIndices.size();
        for(int j=0;j<pattern.size();j++)
        next[j] = 1e9;

        for(int i=M-1;i>=0;i--)
        {
            for(int j=N-1;j>=0;j--)
            {
                int a = 1e9, b = 1e9;

                a = next[j];
                if(source[i] == pattern[j])
                {
                    if(check[i]>0)
                    {
                        b = min(b, 1+next[j+1]);
                    }
                    else
                    b = min(b, next[j+1]);
                }
                prev[j] = min(a, b);
            }
            next = prev;
        }
        return n - next[0];
    }
};",1420058662
CCrack,Shiraz_Zainvi,377,3604,cpp,"using ll = long long;
class Solution {
public:
    int MOD = 1e9+7;
    void fact_prep(vector<ll>& fact, int x)
    {
        for(int i=1;i<=x;i++)
        {
            fact[i] = (ll)(fact[i-1]*i)%MOD;
        }
    }
    void stirling_prep(vector<vector<ll>>& stirling, int n, int x)
    {
        stirling[0][0]=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=x;j++)
            {
                stirling[i][j] = (j*stirling[i-1][j] + stirling[i-1][j-1])%MOD;
            }
        }
    }

    void combi_prep(vector<vector<ll>>& combination, int x)
    {
        for(int i=0;i<=x;i++)
        {
            combination[i][0] = 1;
            for(int j=1;j<=i;j++)
            {
                combination[i][j] = (combination[i-1][j-1]+combination[i-1][j])%MOD;
            }
        }
    }
    int solve(vector<vector<ll>>& stir, vector<vector<ll>>& combi, vector<ll>& f, int n, int x, int y)
    {
        ll ret = 0;
        ll p = 1;
        for(int i=1;i<=x;i++)
        {
            p = 1;
            for(int j=0;j<i;j++)
            {
                p = (p*y)%MOD;
            }
            ret = (ret + (ll)combi[x][i]*stir[n][i]%MOD*f[i]%MOD*p%MOD)%MOD;
        }
        return (int)ret;
    }
    int numberOfWays(int n, int x, int y) {
        vector<ll> factorial(x+1, 1);
        vector<vector<ll>> stirling(n+1, vector<ll>(x+1, 0)), combination(x+1, vector<ll>(x+1, 0));
        deque<int> q;
        q.push_back(1);
        int ans = 0;
        fact_prep(factorial, x);
        stirling_prep(stirling, n, x);
        combi_prep(combination, x);
        q.pop_back();

        ans = solve(stirling, combination, factorial, n, x, y);
        return ans;
    }
};",1420125215
CCrack,Shiraz_Zainvi,377,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<nums.size();i++)
        {
            int num = nums[i];
            
            bool flag = false;
            for(int j=1;j<num;j++)
            {
                if(((j)|(j+1)) == num )
                {
                    ans[i] = j;
                    flag = true;
                    break;
                }
            }

            if(!flag)
            ans[i] = -1;
        }
        return ans;
    }
};",1420008743
CCrack,Shiraz_Zainvi,377,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);

        for(int i=0;i<n;i++)
        {
            int num = nums[i];

            if(num==2)
            {
                ans[i]=-1;
                continue;
            }
            bitset<32> a(num);

            int idx = 0;

            while(a[0]!=0)
            {
                idx++;
                a = a>>1;
            }

            bitset<32> b(num);
            b[idx-1]=0;

            int val = (int)(b.to_ulong());

            ans[i] = val;
        }
        return ans;
    }
};",1420018613
Chris Ho,Chris_ho,378,3487,python3,"from functools import cache
class Solution:
    def maxRemovals(self, src: str, pat: str, tgt: List[int]) -> int:
        tgt_set = set(tgt)
        len_src = len(src)
        len_pat = len(pat)

        counts = [0] * (len_src + 1)
        for s_idx in range(len_src - 1, -1, -1):
            counts[s_idx] = counts[s_idx + 1] + (1 if s_idx in tgt_set else 0)

        dp = [[float('-inf')] * (len_pat + 1) for _ in range(len_src + 1)]
        for s_idx in range(len_src + 1):
            dp[s_idx][len_pat] = counts[s_idx]

        for p_idx in range(len_pat - 1, -1, -1):
            dp[len_src][p_idx] = float('-inf')

        for s_idx in range(len_src - 1, -1, -1):
            for p_idx in range(len_pat - 1, -1, -1):
                opt1 = dp[s_idx + 1][p_idx]
                if s_idx in tgt_set:
                    opt1 = max(opt1, dp[s_idx + 1][p_idx] + 1)
                opt2 = dp[s_idx + 1][p_idx + 1] if src[s_idx] == pat[p_idx] else float('-inf')
                dp[s_idx][p_idx] = max(opt1, opt2)

        res = dp[0][0]
        return res if res >= 0 else 0

# @cache
#         def dp(s_idx, p_idx, removed_count):
#             if p_idx == len(pat):
#                 return removed_count + len(tgt) - bisect.bisect_left(tgt, s_idx)

#             if s_idx == len(src):
#                 return float('-inf')

#             opt1 = dp(s_idx + 1, p_idx, removed_count)

#             tgt_pos = bisect.bisect_left(tgt, s_idx)
#             if tgt_pos < len(tgt) and tgt[tgt_pos] == s_idx:
#                 opt1 = max(opt1, dp(s_idx + 1, p_idx, removed_count + 1))

#             opt2 = float('-inf')
#             if src[s_idx] == pat[p_idx]:
#                 opt2 = dp(s_idx + 1, p_idx + 1, removed_count)

#             return max(opt1, opt2)

#         res = dp(0, 0, 0)
#         return res if res >= 0 else 0",1420106576
Chris Ho,Chris_ho,378,3604,python3,"from functools import lru_cache

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        maxN = n
        # Precompute factorials and inverse factorials
        factorial = [1] * (maxN + 1)
        for i in range(1, maxN + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
            for j in range(1, i + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD

        total_ways = 0
        for k in range(1, min(n, x) + 1):
            ways = math.comb(x, k) * S[n][k] % MOD * factorial[k] % MOD * pow(y, k, MOD) % MOD
            total_ways = (total_ways + ways) % MOD

        return total_ways
",1420098314
Chris Ho,Chris_ho,378,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
      ans = []
      for num in nums:
        found = False
        for x in range(num):
          if (x|(x+1))==num:
            ans.append(x)
            found = True
            break
        if not found:
          ans.append(-1)
      return ans        ",1419994763
Chris Ho,Chris_ho,378,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
      ans = []
      for num in nums:
          min_ans = -1
          for k in range(32):
              if num & (1 << k):
                  temp = num & ~(1 << k)
                  if temp >= 0 and (temp | (temp + 1)) == num:
                      if min_ans == -1 or temp < min_ans:
                          min_ans = temp
          ans.append(min_ans)
      return ans",1420004154
Wayne,Wayne02,379,3487,cpp,"// class Solution {
// public:
    
//     int n , m ; 
//     set <int> st ; 
//     int dp[100100][100100] ; 
    
//     int rec(int level1 , int level2 , string &s1 , string &s2){
//         if(level2 == m) return 0 ; 
//         if(level1 == n ) return -1e9 ; 
        
//         if(dp[level1][level2] != -1){
//             return dp[level1][level2] ; 
//         }
//         int ans = -1e9 ; 
//         if(s1[level1] == s2[level2]){
//             if(st.find(level1) != st.end()){
//                 ans = max({ans , 1 + rec(level1 + 1 , level2 , s1 , s2) , rec(level1 +1 , level2 +1 , s1 , s2)}) ; 
//             }
//             else{
//                 ans = max(ans , rec(level1 + 1 , level2 +1 , s1 , s2)) ; 
//             }
//         }
//         else{
//             if(st.find(level1) != st.end()){
//                 ans = max(ans , 1 + rec(level1 + 1 , level2 , s1 , s2)) ; 
//             }
//             else{
//                 ans = max(ans , rec(level1 + 1 , level2 , s1 , s2)) ; 
//             }
//         }
//         return dp[level1][level2] = ans ; 
//     }
    
    
//     int maxRemovals(string s1, string s2, vector<int>& tr) {
//         n = (int)s1.size() ; 
//         m = (int)s2.size() ; 
//         set <int> st ; 
//         for(int i =0 ;i < (int)tr.size() ; i++){
//             st.insert(tr[i]) ; 
//         }
//         memset(dp , -1 , sizeof(dp)) ; 
//         int ans = rec(0 , 0 , s1 , s2) ; 
//         return ans ; 
//     }
// };

// class Solution {
// public:
//     int n, m;
//     set<int> st;
//     // vector<vector<int>> dp;  // Use vector instead of fixed-size array
//     map <pair <int , int> , int> dp ; 
//     vector <int> v ; 

//     int rec(int level1, int level2, string& s1, string& s2) {
//         if (level2 == m){
//             level1 -- ; 
//             // cout << level1 << ""level1 is "" << endl; 
//             int x = upper_bound(v.begin() , v.end() , level1) - v.begin() ; 
//             // cout << x << ""<--"" << endl; 
//             return (int)v.size() - x ; 
//         }
//         if (level1 == n) return -1e9;

//         if (dp.find({level1 , level2}) != dp.end()) {
//             return dp[{level1 , level2}];
//         }

//         int ans = -1e9;
//         if (s1[level1] == s2[level2]) {
//             if (st.find(level1) != st.end()) {
//                 ans = max({ans, 1 + rec(level1 + 1, level2, s1, s2), rec(level1 + 1, level2 + 1, s1, s2)});
//             } else {
//                 ans = max(ans, rec(level1 + 1, level2 + 1, s1, s2));
//             }
//         } else {
//             if (st.find(level1) != st.end()) {
//                 ans = max(ans, 1 + rec(level1 + 1, level2, s1, s2));
//             } else {
//                 ans = max(ans, rec(level1 + 1, level2, s1, s2));
//             }
//         }
//         return dp[{level1 , level2}] = ans;
//     }

//     int maxRemovals(string s1, string s2, vector<int>& tr) {
//         n = (int)s1.size();
//         m = (int)s2.size();
//         for(int i =0 ;i < (int)tr.size() ; i++){
//             v.push_back(tr[i]) ;
//         }
        
//         // Initialize the set with the removal indices
//         st.clear();
//         for (int i = 0; i < (int)tr.size(); i++) {
//             st.insert(tr[i]);
//         }
        
//         int ans = rec(0, 0, s1, s2);
//         return ans;
//     }
// };


class Solution {
public:
    int n, m;
    set<int> st;
    vector<int> v;

    int maxRemovals(string s1, string s2, vector<int>& tr) {
        n = (int)s1.size();
        m = (int)s2.size();

        v = tr;
        sort(v.begin(), v.end());

        
        st.clear();
        for (int i = 0; i < (int)tr.size(); i++) {
            st.insert(tr[i]);
        }

       
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1e9));

        for (int level1 = 0; level1 <= n; level1++) {
            int x = upper_bound(v.begin(), v.end(), level1 - 1) - v.begin();
            dp[level1][m] = (int)v.size() - x; 
        }

        for (int level1 = n - 1; level1 >= 0; level1--) {
            for (int level2 = m - 1; level2 >= 0; level2--) {
                int ans = -1e9;

                if (s1[level1] == s2[level2]) {
                    if (st.find(level1) != st.end()) {
                        ans = max({ans, 1 + dp[level1 + 1][level2], dp[level1 + 1][level2 + 1]});
                    } else {
                        ans = max(ans, dp[level1 + 1][level2 + 1]);
                    }
                } else {
                    if (st.find(level1) != st.end()) {
                        ans = max(ans, 1 + dp[level1 + 1][level2]);
                    } else {
                        ans = max(ans, dp[level1 + 1][level2]);
                    }
                }

                dp[level1][level2] = ans;
            }
        }


        return dp[0][0];
    }
};
",1420083637
Wayne,Wayne02,379,3604,cpp,"class Solution {
public:
    
    
    const long long pm = 1e9 + 7;
    
    int add(int a, int b){
        int sum = (a% pm + b%pm)%pm  ;
        if(sum > pm) sum%= pm ; 
        if(sum < 0) sum += pm ; 
        return sum ; 
    }
    
    
    long long pow(long long base, long long exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % pm;
            }
            base = (base * base) % pm;
            exp /= 2;
        }
        return result;
    }

    vector<vector<long long>> computeBinomialCoefficients(long long max_n) {
        vector<vector<long long>> binomial(max_n + 1, vector<long long>(max_n + 1, 0));
        for (long long i = 0; i <= max_n; i++) {
            binomial[i][0] = 1; // C(n, 0) = 1
            for (long long j = 1; j <= i; ++j) {
                binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % pm;
            }
        }
        return binomial;
    }

    vector<vector<long long>> computeStirlingNumbers(long long n, long long m) {
        vector<vector<long long>> stirling(n + 1, vector<long long>(m + 1, 0));
        stirling[0][0] = 1; // S(0, 0) = 1

        for (long long i = 1; i <= n; i++) {
            for (long long j = 1; j <= m; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % pm;
            }
        }
        return stirling;
    }

    vector<long long> computeFactorials(long long max_n) {
        vector<long long> factorial(max_n + 1, 1);
        for (long long i = 1; i <= max_n; i++) {
            factorial[i] = factorial[i - 1] * i % pm;
        }
        return factorial;
    }
    
    
    
    
    
    int numberOfWays(int n, int x, int y) {
        
        vector<vector<long long>> binomialCoefficients = computeBinomialCoefficients(x);
        vector<vector<long long>> stirlingNumbers = computeStirlingNumbers(n, x);
        vector<long long> factorials = computeFactorials(x);

        long long totalWays = 0;
        for (long long k = 1; k <= x; ++k) {
            long long powerY = pow(y, k); 
            totalWays = (totalWays + binomialCoefficients[x][k] * stirlingNumbers[n][k] % pm * factorials[k] % pm * powerY % pm) % pm;
        }

        return totalWays;
    }
};",1420126010
Wayne,Wayne02,379,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        int n = (int)arr.size() ;
        vector <int> ans(n) ; 
        for(int i =0 ;i < n ; i++){
            bool fon = false ; 
            for(int j =1 ; j <= 1000 ; j++){
                if((j | (j+1)) == arr[i]){
                    fon = true ;
                    // cout << j << ""<---"" << endl; 
                    ans[i] = j ; 
                    break ; 
                }
            }
            if(fon == false){
                ans[i] = -1 ; 
            }
        }
        return ans ; 
    }
};",1419999612
Wayne,Wayne02,379,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
       int size = (int)arr.size();
    vector<int> result(size);
    
   
    vector<int> arrCopy = arr;
    sort(arrCopy.begin(), arrCopy.end());

    for (int idx = 0; idx < size; idx++) {
        if(arr[idx] != 2){
            int mask1 = 0, mask2 = 0;
            
            
            for (int bitPos = 1; bitPos < 30; bitPos++) {
                if (arr[idx] & (1 << bitPos)) {
                    mask1 |= (1 << bitPos);
                }
            }
            
        
            for (int bitPos = 0; bitPos < 30; bitPos++) {
                if (!(arr[idx] & (1 << bitPos))) {
                    mask2 = arr[idx] ^ (1 << (bitPos - 1));
                    break;
                }
            }

            result[idx] = min(mask1, mask2);
        }
        else if (arr[idx] == 2) {
            result[idx] = -1;
        }
    }

    return result;
    }
};",1420037205
Sandip Kumar Burnwal,sandip123_,380,3487,cpp,"class Solution {
public:
    bool isSubsequence(string source,string pattern) {
        int n = source.size();
        int m = pattern.size();
        int j = 0; 
            for (int i = 0; i < n; ++i) {
                
                if (j < m && source[i] == pattern[j]) {
                    j++;
                }
                if (j == m) {
                    return true;
                }
            }
            return j == m;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0; 
        
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
    
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
    
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);

    }
};",1420073390
Sandip Kumar Burnwal,sandip123_,380,3604,cpp,"class Solution {
public:
    const int mod = 1e9+7;
    int numberOfWays(int n, int x, int y) {
        vector<long long>params = {n,x,y};
        vector<vector<long long>>fun(x+1,vector<long long>(x+1,0));
        long long i=0;
        while(i<=x){
            fun[i][0]=1;
            for(int j=1;j<=i;j++){
                fun[i][j]=(fun[i-1][j-1]+fun[i-1][j])%mod;
            }
            i++;
        }
        vector<vector<long long>>stirling(n+1,vector<long long>(x+1,0));
        stirling[0][0]=1;
        i=1;
        while(i<=n) {
            for (long long j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % mod;
            }
            i++;
        }

        vector<long long> mathFact(x + 1, 1);
        for (long long i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % mod;
        }

        long long totalWays = 0;
        for (long long k = 1; k <= x; ++k) {
            long long power = 1;
            for (long long p = 0; p < k; ++p) {
                power = (power * y) % mod;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % mod * mathFact[k] % mod * power % mod) % mod;
        }

        return totalWays;
    }
};",1420126024
Sandip Kumar Burnwal,sandip123_,380,3605,cpp,"class Solution {
public:
    vector<int> sieveOfEratosthenes(int limit) {
        vector<bool> isPrime(limit + 1, true);
        vector<int> primes;
        isPrime[0] = isPrime[1] = false;
        for (int p = 2; p <= limit; ++p) {
            if (isPrime[p]) {
                primes.push_back(p);
                for (int i = p * p; i <= limit; i += p) {
                    isPrime[i] = false;
                }
            }
        }
        return primes;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  

       
        for (int i = 0; i < nums.size(); ++i) {
           
            
           
            for (int candidate = 1; candidate < nums[i]; ++candidate) {
                if ((candidate | (candidate + 1)) == nums[i]) {
                    ans[i] = candidate;
                    break;  
                }
            }
        }
        return ans;
    }
};",1420004524
Sandip Kumar Burnwal,sandip123_,380,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            int num = nums[i];
            int mini = INT_MAX;
            bool found=false;
            for(int bit=0;bit<=30;bit++){
                if(((num>>bit) & 1)==1){
                    int cand = num&(~(1<<bit));
                    if(cand<0)continue;
                    if((cand|(cand+1))==num){
                        if(cand<mini){
                            mini=cand;
                            found=true;
                        }
                    }
                }
            }
            if(found)ans[i]=mini;
            else{
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420058383
Anupam Shandilya,anupamshandilya28,381,3487,cpp,"class Solution {
public:
   int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int k = targetIndices.size();

        vector<bool> isInTarget(n, false);
        for (int idx : targetIndices)
        {
            isInTarget[idx] = true;
        }

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; 

        for (int i = 0; i < n; ++i)
        {
            vector<int> new_dp = dp;

            for (int j = 0; j < m; ++j) {
                if (source[i] == pattern[j] && dp[j] != INT_MAX) {
                    int cost = isInTarget[i] ? 1 : 0;
                    new_dp[j + 1] = min(new_dp[j + 1], dp[j] + cost);
                }
            }
            dp = new_dp;
        }

        if (dp[m] == INT_MAX)
        {
            return 0;
        }

        int maxRemovable = k - dp[m];
        return maxRemovable;
    }

};",1420126108
Anupam Shandilya,anupamshandilya28,381,3604,cpp,"class Solution {
public:
    #define MOD 1000000007

    int mod_pow(int base, int exponent)
    {
        int result = 1;
        base %= MOD;
        while(exponent > 0) 
        {
            if (exponent % 2 == 1) 
            {
                result = (int)((1LL * result * base) % MOD);
            }
            base = (int)((1LL * base * base) % MOD);
            exponent /= 2;
        }
        return result;
    }

    int mod_inverse(int a) 
    {
        return mod_pow(a, MOD - 2);
    }

    int numberOfWays(int n, int x, int y) {
        const int MAX = 2001;
        int factorial[MAX], inv_factorial[MAX];
        factorial[0] = 1;
        for(int i = 1; i <= n + x; ++i) 
        {
            factorial[i] = (int)((1LL * factorial[i - 1] * i) % MOD);
        }
        inv_factorial[n + x] = mod_inverse(factorial[n + x]);
        for(int i = n + x - 1; i >= 0; --i) 
        {
            inv_factorial[i] = (int)((1LL * inv_factorial[i + 1] * (i + 1)) % MOD);
        }

        int S[MAX][MAX];
        for(int i = 0; i <= n; ++i)
        {
            for (int j = 0; j <= n; ++j) 
            {
                S[i][j] = 0;
            }
        }
        S[0][0] = 1;
        for(int i = 1; i <= n; ++i) 
        {
            S[i][0] = 0;
            for(int j = 1; j <= i; ++j) 
            {
                S[i][j] = (S[i - 1][j - 1] + (int)((1LL * j * S[i - 1][j]) % MOD)) % MOD;
            }
        }

        int total = 0;
        int min_k = (n < x) ? n : x;
        for(int k = 1; k <= min_k; ++k) 
        {
            int C_x_k = (int)((1LL * factorial[x] * inv_factorial[k] % MOD) * inv_factorial[x - k] % MOD);

            int k_factorial = factorial[k];

            int y_pow_k = mod_pow(y, k);

            int term = (int)((1LL * C_x_k * k_factorial % MOD) * S[n][k] % MOD);
            term = (int)((1LL * term * y_pow_k) % MOD);

            total = (total + term) % MOD;
        }

        return total;
    }

};",1420074306
Anupam Shandilya,anupamshandilya28,381,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
        
        for (int i=0;i<n;++i)
        {
            int min_x = -1;
            int num = nums[i];
            for(int pos=0;pos<31;++pos)
            {
                if((num & (1 << pos)))
                {
                    int x = num-(1<<pos);
                    if(x >= 0) 
                    {
                        int x_plus_one = x + 1;
                        if((x | x_plus_one) == num) 
                        {
                            if(min_x == -1 || x < min_x) 
                            {
                                min_x = x;
                            }
                        }
                    }
                }
            }
            ans[i] = min_x;
        }
        
        return ans;
    }
};",1420007641
Anupam Shandilya,anupamshandilya28,381,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
        
        for (int i=0;i<n;++i)
        {
            int min_x = -1;
            int num = nums[i];
            for(int pos=0;pos<31;++pos)
            {
                if((num & (1 << pos)))
                {
                    int x = num-(1<<pos);
                    if(x >= 0) 
                    {
                        int x_plus_one = x + 1;
                        if((x | x_plus_one) == num) 
                        {
                            if(min_x == -1 || x < min_x) 
                            {
                                min_x = x;
                            }
                        }
                    }
                }
            }
            ans[i] = min_x;
        }
        
        return ans;
    }
};",1420007193
Guardian-or-nothing,Guardian-or-nothing,382,3487,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    vector<vector<ll>> dp;
    ll f(ll i, ll j, string &src, string &pat, vector<ll> &mp){
        ll n=src.size(),m=pat.size();
        ll ans=0;
        if(i<=n && j>=m){
            ll tans=0;
            for(int k=i;k<n;k++){
                tans+=(mp[k]);
            }
            return tans;
        }
        if(i>=n && j<m) return -1e9;
        if(dp[i][j]!=-1) return dp[i][j];
        if(mp[i]==0){
            if(src[i]==pat[j]){
                ans=f(i+1,j+1,src,pat,mp);
                ans=max(ans,f(i+1,j,src,pat,mp));  // may, may not
            }else{
                ans=f(i+1,j,src,pat,mp);
            }
        }else if(mp[i]==1){
            ll del=0,nodel=0;
            if(src[i]==pat[j]){
                del=1+f(i+1,j,src,pat,mp);                // delete
                nodel=f(i+1,j+1,src,pat,mp);          // no delete
                nodel=max(nodel,f(i+1,j,src,pat,mp));
            }else{
                del=1+f(i+1,j,src,pat,mp);                 // delete
                nodel=f(i+1,j,src,pat,mp);    // no delete
            }
            ans=max(del,nodel);
        }
        return dp[i][j]=ans;
    }
    int maxRemovals(string src, string pat, vector<int>& v) {
        ll n=src.size(),m=pat.size(); vector<ll> mp(n,0);
        for(int i=0;i<v.size();i++) mp[v[i]]++;
        dp.resize(n+1,vector<ll>(m+1,-1));
        ll ans=f(0,0,src,pat,mp);
        return ans;
    }
};",1420095094
Guardian-or-nothing,Guardian-or-nothing,382,3604,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    ll mod=1e9+ 7;
    vector<ll> f;
    int numberOfWays(int n, int x, int y) {
        f.resize(x+3,1);
        for (int i=1;i<x+1;i++) {
            f[i]=(f[i-1]*i)%mod; f[i]%=mod;
        }
        vector<vector<ll>> v(x+3,vector<ll>(x+3,0));
        for (int i=0;i<x+1;i++) {
            v[i][0]=1;
            for (int j=1;j<i+1;j++) {
                ll tans=(v[i-1][j]+v[i-1][j-1])%mod;
                v[i][j]=tans;
            }
        } 
        vector<vector<ll>> smaan(n+3,vector<ll>(x+3,0));
        smaan[0][0]=1;
        for (int i=1;i<n+1;i++) {
            for (int j=1;j<x+1;j++) {
                ll tans1=1ll*smaan[i-1][j-1]%mod; ll tans2=1ll*j*smaan[i-1][j]%mod;
                smaan[i][j]=(tans1+tans2)%mod; smaan[i][j]%=mod;
            }
        }
        ll fans=0;
        for (int j=1;j<x+1;j++) {
            ll power=1;
            for (int i=0;i<j;i++){
                power*=y; power%=mod;
            }
            ll tans1=smaan[n][j]*v[x][j]%mod; ll tans2=(f[j] % mod);
            fans+=(tans1%mod*tans2%mod*power % mod)%mod;
            fans%=mod;
        }
        return fans;
    }
};",1420126279
Guardian-or-nothing,Guardian-or-nothing,382,3605,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int> ans;
        for(ll i=0;i<n;i++){
            for(ll j=0;j<=32;j++){
                ll bit=(v[i] & (1ll<<j));
                if(bit==0){
                    if(j-1>=0){
                        ll tans=v[i] - (1<<(j-1));
                        ans.push_back(tans); break;
                    }else{
                        ans.push_back(-1); break;
                    }
                }
            }
        }
        return ans;
    }
};",1420023126
Guardian-or-nothing,Guardian-or-nothing,382,3611,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int> ans;
        for(ll i=0;i<n;i++){
            for(ll j=0;j<=32;j++){
                ll bit=(v[i] & (1ll<<j));
                if(bit==0){
                    if(j-1>=0){
                        ll tans=v[i] - (1<<(j-1));
                        ans.push_back(tans); break;
                    }else{
                        ans.push_back(-1); break;
                    }
                }
            }
        }
        return ans;
    }
};",1420022089
newbie_noob,newbie_noob,383,3487,cpp,"int dp[3001][3001];
class Solution {
public:
    int f(int i,int j,string &s,string &p,set<int>&st,vector<vector<int>>&dp)
    {
        if(j>=p.size())
        {
            return 0;
        }
        if(i>=s.size())
        {
            return 1e9;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        int ans=1e9;
        ans=min(ans,f(i+1,j,s,p,st,dp));
        if(s[i]==p[j])
        {
            int to_add=0;
            if(st.find(i)!=st.end())
            to_add=1;
            ans=min(ans,to_add+f(i+1,j+1,s,p,st,dp));
        }
        return dp[i][j]=ans;
    }
    int maxRemovals(string s, string p, vector<int>& t) {
        set<int>st;
        vector<vector<int>>dp(s.size()+1,vector<int>(p.size()+1,-1));
        for(auto it:t)st.insert(it);
        int ans=f(0,0,s,p,st,dp);
        ans=t.size()-ans;
        return ans;
    }
};",1420056099
newbie_noob,newbie_noob,383,3604,cpp,"int mod=1e9+7;
class Solution {
public: 
    long long add(long long a,long long b)
    {
        return (a%mod +  b%mod)%mod;
    }
    long long mul(long long a,long long b)
    {
        return (a%mod*b%mod)%mod;
    }

    void set_ncr(vector<vector<long long>>&ncr)
    {
        for(int i=0;i<=1000;++i)ncr[i][0]=1;
        for(int i=0;i<=1000;++i)
        {
            for(int j=1;j<=i;++j)
            {
                ncr[i][j]=add(ncr[i-1][j],ncr[i-1][j-1]);
            }
        }
    }
    void set_scr(vector<vector<long long>>&scr,long long n,long long x)
    {
        scr[0][0]=1;
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=x;++j)
            {
                scr[i][j]=add(scr[i-1][j-1],mul(j,scr[i-1][j]));
            }
        }
    }
    void set_fact(vector<long long>&fact)
    {
        fact[0]=1;
        for(int i=1;i<=1000;++i)
        {
            fact[i]=mul(fact[i-1],i);
        }
    }
    void set_yk(vector<long long>&yk,long long y,long long x)
    {
        yk[0]=1;
        for(int i=1;i<=x;++i)
        {
            yk[i]=mul(yk[i-1],y);
        }
    }
    
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>>ncr(1001,vector<long long>(1001,0));
        set_ncr(ncr);
        vector<vector<long long>>scr(n+1,vector<long long>(x+1,0));
        set_scr(scr,n,x);
        vector<long long>yk(x+1,0);
        set_yk(yk,y,x);
        vector<long long>fact(1001,0);
        set_fact(fact);
        long long ans=0;
        for(long long sc=1;sc<=x;++sc)
        {
            long long a=1;
            a=mul(a,mul(scr[n][sc],ncr[x][sc]));
            a=mul(a,mul(fact[sc],yk[sc]));
            ans=add(ans,a);
        }
        return ans;
    }
};",1420120042
newbie_noob,newbie_noob,383,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();++i)
        {
            if(nums[i]==2)
            {
                ans.push_back(-1);
            }
            else{
                int ele=0;
                int done=0;
                for(int j=0;j<21;++j)
                {
                    if(((nums[i]>>j)&1)==0)
                    {
                        if(done==1)
                        {
                            continue;
                        }
                        else
                        {
                            done=1;
                            ele^=(1LL<<(j-1));
                        }
                    }
                    else
                    {
                        ele+=(1LL<<j);
                    }
                }
                ans.push_back(ele);
            }
        }
        return ans;
    }
};",1420016683
newbie_noob,newbie_noob,383,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();++i)
        {
            if(nums[i]==2)
            {
                ans.push_back(-1);
            }
            else{
                int ele=0;
                int done=0;
                for(int j=0;j<31;++j)
                {
                    if((nums[i]&(1LL<<j))==0)
                    {
                        if(done==1)
                        {
                            continue;
                        }
                        else
                        {
                            done=1;
                            ele^=(1LL<<(j-1));
                        }
                    }
                    else
                    {
                        ele+=(1LL<<j);
                    }
                }
                ans.push_back(ele);
            }
        }
        return ans;
    }
};",1420019402
retinue,XCX0OjLCi5,385,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        f = [0] + [float('inf') for _ in range(m)]
        used = [False for _ in range(n)]
        for i in targetIndices:
            used[i] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and f[j - 1] != float('inf'):
                    f[j] = min(f[j], f[j - 1] + int(used[i]))
        
        if f[m] == float('inf'):
            return len(targetIndices)
        
        return len(targetIndices) - f[m]
            
        ",1420078444
retinue,XCX0OjLCi5,385,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7
        f = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            f[i][0] = 1
            for j in range(1, i + 1):
                f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % MOD


        p = [[0] * (x + 1) for _ in range(n + 1)]
        p[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                p[i][j] = ((j * p[i - 1][j]) % MOD + p[i - 1][j - 1]) % MOD

        ft = [1] * (x + 1)
        for i in range(1, x + 1):
            ft[i] = ft[i - 1] * i % MOD

        res = 0
        for k in range(1, x + 1):
            res += ((f[x][k] * p[n][k]) % MOD) * (ft[k] % MOD) * pow(y, k, MOD)
            res %= MOD

        return res % MOD",1420121125
retinue,XCX0OjLCi5,385,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # (a) or (a + 1) == ni
        res = []
        for n in nums:
            f = False
            for i in range(1, 1001):
                if i | (i + 1) == n:
                    res.append(i)
                    f = True
                    break
            if not f:
                res.append(-1)
        return res",1419995993
retinue,XCX0OjLCi5,385,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = []
        for n in nums:
            mi = 10 ** 10
            flag = False
            for i in range(31):
                if (n >> i) & 1:
                    x = n & ~(1 << i)
                    if x < 0:
                        continue
                    if x | x + 1 == n:
                        mi = min(mi, x)
                        flag = True
            res.append(-1 if not flag else mi)
        return res
                    ",1420069202
Aasmaan,Aasmaan_Vs_Aasmaan,386,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

#define vi vector<int>
#define pb push_back
#define sz size()
#define INF INT_MAX
#define F first
#define S second

class Solution
{
public:
    int maxRemovals(string &s, string &p, vi &t)
    {
        int n = s.sz, m = p.sz;
        vi d(m + 1, INF);
        d[0] = 0;
        vector<bool> x(n, false);
        stack<int> st;

        for (auto idx : t)
            st.push(idx);
        while (!st.empty())
        {
            x[st.top()] = true;
            st.pop();
        }

        for (int i = 0; i < n; ++i)
        {
            int ff = 0;
            while (ff < 1)
            {

                for (int i = 0; i < 10; i++)
                    st.push(i);

                for (int j = m; j >= 1; --j)
                {
                    if (s[i] == p[j - 1] && d[j - 1] < INF)
                    {

                        int a=d[j];
                        int b=d[j-1];
                        int c=x[i];
                        int dd=b+c;
                        d[j]= min(a,dd);
                    }
                }
                ff++;
            }
        }

        int ok = d[m]; 

int uu; 
if (ok == INF) {
    uu = 0; 
    uu = ok;
}

int oo = t.sz - uu; 

return oo; 


        return t.sz - (d[m] == INF ? 0 : d[m]);
    }
};
",1420093710
Aasmaan,Aasmaan_Vs_Aasmaan,386,3604,rust,"use std::collections::VecDeque;

macro_rules! insert_into_stack {
    ($s:expr, $v:expr) => {
        $s.push_back($v);
    };
}

impl Solution {
    pub fn number_of_ways(n: i32, x: i32, y: i32) -> i32 {
        const M: i64 = 1_000_000_007;
        let mut vec = vec![1, 2, 3, 4, 5];
    let len = vec.len();
    for i in 0..len / 2 {
        vec.swap(i, len - 1 - i);
    }
        
        let mut stack: VecDeque<i32> = VecDeque::new(); 
        
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        let mut temp_str = String::new(); 

        for i in 1..=10 {
            insert_into_stack!(stack, i);
            temp_str.push_str(&i.to_string()); 
        }
                let mut stack: VecDeque<i32> = VecDeque::new(); 
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        fn c(s: i32) -> Vec<Vec<i64>> {
            let s = s as usize;
            let mut r = vec![vec![0; s + 1]; s + 1];
            for i in 0..=s {
                r[i][0] = 1;
                for j in 1..=i {
                    r[i][j] = (r[i - 1][j - 1] + r[i - 1][j]) % M;
                }
            }
            r
        }
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        fn p(n: i32, x: i32) -> Vec<Vec<i64>> {
            let n = n as usize;
            let x = x as usize;
            let mut r = vec![vec![0; x + 1]; n + 1];
            r[0][0] = 1;
            for i in 1..=n {
                for j in 1..=x {
                    r[i][j] = (j as i64 * r[i - 1][j] + r[i - 1][j - 1]) % M;
                }
            }
            r
        }
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        fn f(s: i32) -> Vec<i64> {
            let s = s as usize;
            let mut r = vec![1; s + 1];
            for i in 1..=s {
                r[i] = (r[i - 1] * i as i64) % M;
            }
            r
        }

        let c = c(x);
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);

        let p = p(n, x);
        let f = f(x);
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        let mut res = 0;
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        for k in 1..=x {
            let mut pow = 1;
            for _ in 0..k {
                pow = (pow * y as i64) % M;
            }
            let mut t = c[x as usize][k as usize];
            t = (t * p[n as usize][k as usize]) % M;
            t = (t * f[k as usize]) % M;
            t = (t * pow) % M;
            res = (res + t) % M;
        }
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


       

        res as i32
    }
}
",1420116516
Aasmaan,Aasmaan_Vs_Aasmaan,386,3605,cpp,"class Solution
{
public:
    bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }

    string decToBinary(int n)
    {
        string s = """";
        while (n > 0)
        {
            s = to_string(n % 2) + s;
            n /= 2;
        }
        return s;
    }

    long long binaryToDecimal(string n)
    {
        long long dec_value = 0; // Initialize the decimal value to 0
        long long base = 1;      // Initialize the base value to 1 (2^0)

        for (int i = n.size() - 1; i >= 0; i--)
        { // Loop through each character in the string from right to left
            if (n[i] == '1')
            {                      // If the current character is '1'
                dec_value += base; // Add the current base value to the decimal value
            }
            base *= 2; // Update the base value by multiplying it by 2 (base for the next position)
        }

        return dec_value; // Return the calculated decimal value
    }

    vector<int> minBitwiseArray(vector<int> &nums)
    {

        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++)
        {

            if (nums[i] % 2 == 1)
            {
                if (isPowerOfTwo(1 + nums[i]))
                {
                    ans[i] = nums[i] / 2;
                }
                else
                {
                    string t = decToBinary(nums[i]);

                    for (int j = t.size(); j >= 0; j--)
                    {

                        if (t[j] == '0')
                        {
                            int k = j;
                            string p = t;
                            p[k + 1] = '0';

                            int x = binaryToDecimal(p);
                            ans[i] = x;
                            break;
                        }
                    }

                    int one = __builtin_popcountll(nums[i]);

                  

                   
                }
            }
        }

        return ans;
    }
};",1420057566
Aasmaan,Aasmaan_Vs_Aasmaan,386,3611,cpp,"class Solution
{
public:
    bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }

    string decToBinary(int n)
    {
        string s = """";
        while (n > 0)
        {
            s = to_string(n % 2) + s;
            n /= 2;
        }
        return s;
    }

    long long binaryToDecimal(string n)
    {
        long long dec_value = 0; // Initialize the decimal value to 0
        long long base = 1;      // Initialize the base value to 1 (2^0)

        for (int i = n.size() - 1; i >= 0; i--)
        { // Loop through each character in the string from right to left
            if (n[i] == '1')
            {                      // If the current character is '1'
                dec_value += base; // Add the current base value to the decimal value
            }
            base *= 2; // Update the base value by multiplying it by 2 (base for the next position)
        }

        return dec_value; // Return the calculated decimal value
    }

    vector<int> minBitwiseArray(vector<int> &nums)
    {

        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++)
        {

            if (nums[i] % 2 == 1)
            {
                if (isPowerOfTwo(1 + nums[i]))
                {
                    ans[i] = nums[i] / 2;
                }
                else
                {
                    string t = decToBinary(nums[i]);

                    for (int j = t.size(); j >= 0; j--)
                    {

                        if (t[j] == '0')
                        {
                            int k = j;
                            string p = t;
                            p[k + 1] = '0';

                            int x = binaryToDecimal(p);
                            ans[i] = x;
                            break;
                        }
                    }

                    int one = __builtin_popcountll(nums[i]);

                  

                   
                }
            }
        }

        return ans;
    }
};",1420057090
JH,jbropark,387,3487,python3,"class Solution:

    @cache
    def find_max(self, si: int, pi: int):
        if pi >= len(self.pattern):
            return sum(idx in self.indices for idx in range(si, len(self.source)))

        if si >= len(self.source):
            return -float(""inf"")

        if si not in self.indices:
            if self.source[si] == self.pattern[pi]:
                return self.find_max(si + 1, pi + 1)

            return self.find_max(si + 1, pi)

        if self.source[si] == self.pattern[pi]:
            return max(
                self.find_max(si + 1, pi + 1),
                1 + self.find_max(si + 1, pi),
            )

        return 1 + self.find_max(si + 1, pi)

    def maxRemovals(self, source: str, pattern: str, indices: List[int]) -> int:
        self.indices = set(indices)
        self.source = source
        self.pattern = pattern
        return self.find_max(0, 0)
",1420038406
JH,jbropark,387,3604,python3,"import math

MOD = 1_000_000_007


class Solution:

    DP = {(i, j): math.comb(i, j) % MOD for i in range(1, 1001) for j in range(0, i + 1)}

    def sigma(self, k: int, n: int):
        ans = 0
        mul = 1
        for i in range(k, 0, -1):
            ans += self.DP[k, i] * mul * self.mul[i]
            mul *= -1
        return ans

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # 27

        # 1 : 3 * (1^3) * 4 ->
        # 2 : 3 * (2^3 - 2) * 16 
        # 3 : 1 * (3^3 - 3 * 2^3 + ) * 64 ->  

        # 3 / 18 / 6
        # 1^3
        # 2^3 - 2 * 1 ^ 3
        # 3^3 - 3 * 2^3 + 3 * 1^3
        # 27 - 24 + 3
        # 4^3

        # 2 * (1 ^ 5)  * 1
        # 1 * (2 ^ 5 - 2 * 1 ^ 5)

        # nCmin(n,x) min(n,x)

        self.mul = [0] * (x + 1)
        for i in range(1, x + 1):
            self.mul[i] = (i ** n) % MOD

        ans = 0
        mul = 1
        for k in range(1, x + 1):
            com = self.DP[x, min(k, x)]
            sig = self.sigma(k, n)
            mul = (mul * y) % MOD
            # print(com, sig, mul)
            ans = (ans + com * sig * mul) % MOD
            # print(ans)

        return ans % MOD",1420110354
JH,jbropark,387,3605,python3,"class Solution:

    def find(self, n: int):
        print(bin(n))
        count = 0
        while n & 1:
            n >>= 1
            count += 1

        return (n << count) | ((1 << (count - 1)) - 1)

    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i in range(len(nums)):
            if nums[i] == 2:
                continue

            ans[i] = self.find(nums[i])

        return ans",1420019868
JH,jbropark,387,3611,python3,"# 11 -> 1, 10
# 101 -> 100, 101
# 111 -> 11, 100
# 110
# 1011 -> 1001, 1010
# 1000011 -> 1000001
# 1000101 -> 1000100
# 1000111 -> 1000011
# 1001001 -> 
# 1111 -> 111, 1000


class Solution:

    def find(self, n: int):
        print(bin(n))
        count = 0
        while n & 1:
            n >>= 1
            count += 1

        return (n << count) | ((1 << (count - 1)) - 1)

    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i in range(len(nums)):
            if nums[i] == 2:
                continue

            ans[i] = self.find(nums[i])

        return ans",1420019455
mayank_35,mayank_35,388,3487,cpp,"class Solution {
public:
    
    int dp[3001][3001];

    
//     int solve(int inds,int indp,string &source,string &pattern, set<int> indices){
//         int n = source.length();
//         int m = pattern.length();
//         if(inds>=n && indp>=m){
//             return 0;
//         }
//         else if(inds>=n){
//             return -1e8;
//         }
//         if(dp[inds][indp]!=-1){
//             return dp[inds][indp];
//         }
        
//         if(indices.find(inds)!=indices.end()){
//             if(source[inds]!=pattern[indp]){
//                 return dp[inds][indp] = 1+ solve(inds+1,indp,source,pattern,indices);
//             }
//             else{
//                 int op1 = 1 + solve(inds+1,indp,source,pattern,indices);
//                 int op2 = solve(inds+1,indp+1,source,pattern,indices);
//                 return dp[inds][indp] = max(op1,op2);
//             }            
//         }
//         else{
//             if(source[inds]==pattern[indp]){
//                 return dp[inds][indp] = solve(inds+1,indp+1,source,pattern,indices);
//             }
//             else{
//                 return dp[inds][indp] = solve(inds+1,indp,source,pattern,indices);
//             }
//         }
//         return 0;
//     }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        // for(int i=0;i<=n;i++){
        //     for(int j=0;j<=m;j++){
        //         dp[i][j]=-1;
        //     }
        // }
        set<int> indices(targetIndices.begin(),targetIndices.end());
        
        dp[n][m] = 0;
        for(int i=0;i<m;i++){
            dp[n][i] = -1e8;
        }
        for(int inds=n;inds>=0;inds--){
            for(int indp=m;indp>=0;indp--){
                if(indices.find(inds)!=indices.end()){
                    if(source[inds]!=pattern[indp] && inds<n){
                        dp[inds][indp] = 1+ dp[inds+1][indp];
                    }
                    else if(inds<n && indp<m){
                        int op1 = 1 + dp[inds+1][indp];
                        int op2 = dp[inds+1][indp+1];
                        dp[inds][indp] = max(op1,op2);
                    }            
                }
                else{
                    if(source[inds]==pattern[indp] && (inds<n && indp<m)){
                        dp[inds][indp] = dp[inds+1][indp+1];
                    }
                    else if(inds<n){
                        dp[inds][indp] = dp[inds+1][indp];
                    }
                }
            }
        }
        return dp[0][0];
        
        
//         int ans = solve(0,0,source,pattern,indices);
//         return ans;
        
    }
};",1420057867
mayank_35,mayank_35,388,3604,cpp,"class Solution {
public:
    #define ll long long
    
    ll fac[1010];
    const ll mod = 1e9+7;
    
    void solveFact(){
        fac[0]=1LL;
        for (ll i = 1; i < 1010; i++)
            fac[i] = (fac[i - 1] * i) % mod;        
    }
    
    ll power(ll x, ll y, ll p){
        ll res = 1LL;
        x = x % p;
        while (y > 0)
        {
            if (y & 1)
                res = (res * x) % p;
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }
    ll modInverse(ll n, ll p){
        return power(n, p - 2, p);
    }
    ll nCrModPFermat(ll n, ll r, ll p){
        if(n < r)
            return 0;
        if(r == 0)
            return 1;
        return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;
    }
    
    
    
    ll solve(ll stages,ll artists){
        ll r = stages;
        ll n = artists;
        ll sum = 0;
        for(ll i=0;i<r;i++){
            if(i%2==0){
                sum = (sum + (nCrModPFermat(r,i,mod)%mod) * ((power(r-i,n,mod))%mod))%mod;
            }
            else{
                sum = (sum - (nCrModPFermat(r,i,mod)%mod) * ((power(r-i,n,mod))%mod) + mod)%mod;
            }
        }
        return sum%mod;
    }
    
    
    
    int numberOfWays(int n, int x, int y) {
        solveFact();
        ll ans = 0;
        for(ll i=1;i<=x;i++){
            ll tmp = nCrModPFermat(x,i,mod)%mod;
            ll tmp2 = solve(i,n)%mod;
            ll tmp3 = power(y,i,mod)%mod;
            ll tmpans = ((tmp%mod) * (tmp2%mod))%mod;
            tmpans = tmpans%mod;
            tmpans = (tmpans * (tmp3%mod))%mod;
            tmpans = tmpans%mod;
            ans = (ans + (tmpans%mod))%mod;
            ans = (ans+mod)%mod;
            // ans = (ans + (((nCrModPFermat(x,i,mod)%mod) *  ((solve(i,n))%mod) * ((power(y,i,mod))%mod)    )%mod))%mod;
            // cout<<ans<<endl;
        }
        return ans;
    }
};",1420110406
mayank_35,mayank_35,388,3605,cpp,"class Solution {
public:
    
    int solve(int n){
        int first0;
        for(int i=0;i<=31;i++){
            int b = (n>>i)&1;
            if(b==0){
                first0 = i;
                break;
            }
        }        
        first0--;
        int ans = n & (~(1<<first0));
        return ans;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                ans.push_back(solve(nums[i]));
            }
        }
        return ans;

    }
};",1420007597
mayank_35,mayank_35,388,3611,cpp,"class Solution {
public:
    
    int solve(int n){
        int first0;
        for(int i=0;i<=31;i++){
            int b = (n>>i)&1;
            if(b==0){
                first0 = i;
                break;
            }
        }        
        first0--;
        int ans = n & (~(1<<first0));
        return ans;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                ans.push_back(solve(nums[i]));
            }
        }
        return ans;

    }
};",1420008560
Sahil Hussain,mdsahil37621,389,3487,cpp,"class Solution {
public:
    int getMin(int i, int j, int n, int m, string &source, string &pattern, map<int, int> &mp, vector<vector<int>> &dp){
        if(j == m) return 0;
        if(i == n) return 1e9;
        
        if(dp[i][j] != -1) return dp[i][j];
        
        if(source[i] == pattern[j]){
            return dp[i][j] = min(mp[i] + getMin(i+1, j+1, n, m, source, pattern, mp, dp),
                                 getMin(i+1, j, n, m, source, pattern, mp, dp));
        } else {
            return dp[i][j] = getMin(i+1, j, n, m, source, pattern, mp, dp);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));
        
        map<int, int> mp;
        for(auto k: targetIndices) mp[k]++;
        
        int mini = getMin(0, 0, n, m, source, pattern, mp, dp);
        
        return targetIndices.size() - mini;
    }
};",1420035907
Sahil Hussain,mdsahil37621,389,3604,cpp,"class Solution {
public:
    #define ll long long
    int MOD = 1e9+7;
    #define ld          long double
#define ft          first
#define sc          second
#define pb          push_back
#define vi          vector <long long>
#define vvi         vector <vector <long long>>
#define vpii        vector <pair <long long, long long>>
#define vs          vector<string>
#define pii         pair <long long, long long>
#define mii         unordered_map<int, long long, custom_hash>
#define si          unordered_set<long long, custom_hash>
#define minheap     priority_queue <long long, vector<long long>, greater<long long>>
#define maxheap     priority_queue <long long>
#define all(x)      x.begin(),x.end()
#define rall(x)     x.rbegin(),x.rend()
#define yes         cout<<""YES\n""
#define no          cout<<""NO\n""
#define loopi(x,n)  for(long long i = x; i < n; ++ i)
#define loopj(x,n)  for(long long j = x; j < n; ++ j)
#define loopk(x,n)  for(long long k = x; k < n; ++ k)
#define rloop(x,n)  for(long long r = x; r >= n; --r)
#define debug(x)    cerr<<#x<<"" ""<<x<< endl;
    
    int factorial(int x, vector<int>& facts) {
        int result = 1;
        facts[0] = 1;
        facts[1] = 1;
        for (int i = 2; i <= x; i++) {
            result = ((long long)result * i) % MOD;
            facts[i] = result;
        }
        return result;
    }

    int stirlingNumber(int n, int m,  vector<vector<int>>& dp) {
        dp[0][0] = 1; 

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + (long long)j * dp[i - 1][j] % MOD) % MOD;
            }
        }

        return dp[n][m];
    }

    ll max (ll a , ll b) { if(a>b) return a; return b; }
ll min (ll a , ll b) { if(a<b) return a; return b; }
ll ceil_div(ll a, ll b) { return a % b == 0 ? a / b : a / b + 1; }
//inverse calc.
ll inv(ll i){
    if (i == 1)
        return 1;
    return (MOD - ((MOD / i) * inv(MOD % i)) % MOD) % MOD;
}
//modulo multiplication
ll mod_mul(ll a, ll b){
    a = a % MOD;
    b = b % MOD;
    return (((a * b) % MOD) + MOD) % MOD;
}
//modulo addition
ll mod_add(ll a, ll b){
    a = a % MOD;
    b = b % MOD;
    return (((a + b) % MOD) + MOD) % MOD;
}
//check if power of 2
bool is_power_2(ll nr) { return (nr&&(!(nr&(nr-1)))); }
//GCD
ll gcd(ll a, ll b){
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
// LCM
ll lcm(ll a, ll b){
	return ((1LL * a * b) / (__gcd(a, b)));
}
//power calculate a^b
ll power(ll a, ll b){
    a %= MOD;
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res;
}
//inverse modulo
ll modInverse (ll a){ return power(a, MOD - 2); }


//for large nCr
ll nCrMOD (ll n, ll r, vector<int>& facts){
    if (n < r) return 0;
    if (r == 0) return 1;
    ll res = facts[n];
    res = (res*modInverse(facts[r]))%MOD;
    res = (res*modInverse(facts[n-r]))%MOD;
    return res;
}
    int numberOfWays(int n, int x, int y) {
        vector<int> facts(x+1);
        vector<vector<int>> dp(n+1, vector<int>(x+1, 0));
        
        stirlingNumber(n, x, dp);
        factorial(x, facts);
        
        int res = 1;
        
        for(int i = 1; i <= x; i++){
            int k = ((long long)dp[n][i] * facts[i])%MOD;
            
            int num = power(y, i);
            
            int p = nCrMOD(x, i, facts);
            
            int l = (long long)k*num%MOD;
            
            
            res = (res + (long long)p*l%MOD)%MOD;
        }
        return res-1;
    }
};",1420104155
Sahil Hussain,mdsahil37621,389,3605,cpp,"class Solution {
public:
    int getNum(int num){
        int res = 0;
        
        for(int i = 0; i < 31; i++){
            if((1<<i)&num){
                res = (1<<i);
            } else {
                break;
            }
        }
        return num - res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for(auto num: nums){
            int k = getNum(num);
            
            if(k == num) k = -1;
            res.push_back(k);
        }
        
        return res;
    }
};",1420007213
Sahil Hussain,mdsahil37621,389,3611,cpp,"class Solution {
public:
    int getNum(int num){
        int res = 0;
        
        for(int i = 0; i < 31; i++){
            if((1<<i)&num){
                res = (1<<i);
            } else {
                break;
            }
        }
        return num - res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for(auto num: nums){
            int k = getNum(num);
            
            if(k == num) k = -1;
            res.push_back(k);
        }
        
        return res;
    }
};",1420006556
Di Kang,zephyrr,390,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:

        @cache
        def dp(sourceind, patternind, targetind):
            
            if patternind == len(pattern):
                if targetind == len(targetIndices):
                    #print(sourceind, patternind, targetind, 0)
                    return 0
                if sourceind == len(source):
                    #print(sourceind, patternind, targetind, 0)
                    return 0
                if targetind < len(targetIndices) and sourceind == targetIndices[targetind]:
                    #print(sourceind, patternind, targetind, 1 + dp(sourceind + 1, patternind, targetind + 1))
                    return 1 + dp(sourceind + 1, patternind, targetind + 1)
                return dp(sourceind + 1, patternind, targetind)
            if sourceind == len(source):
                #print(sourceind, patternind, targetind, -10000)
                return -float(inf)
            if (targetind < len(targetIndices) and targetIndices[targetind] != sourceind) or targetind >= len(targetIndices):
                if pattern[patternind] != source[sourceind]:
                    #print(sourceind, patternind, targetind, dp(sourceind+1, patternind, targetind))
                    return dp(sourceind+1, patternind, targetind)
                else:
                    #print(sourceind, patternind, targetind, dp(sourceind+1, patternind + 1, targetind))
                    return dp(sourceind+1, patternind + 1, targetind)
            tmp = 1 + dp(sourceind + 1, patternind, targetind + 1)
            if pattern[patternind] == source[sourceind]:
                #print(sourceind, patternind, targetind, max(tmp, dp(sourceind + 1, patternind + 1, targetind + 1)))
                return max(tmp, dp(sourceind + 1, patternind + 1, targetind + 1))
            else:
                #print(sourceind, patternind, targetind, tmp)
                return tmp
        
        ans = dp(0,0,0)

        return ans
        

                


        ",1420044927
Di Kang,zephyrr,390,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod = 10 ** 9 + 7
        pre = []
        ans = 0

        @cache
        def combb(x,y):
            if x-y  < y:
                return combb(x,x-y)
            if y == 0:
                return 1
            if x == y:
                return 1
            return (combb(x-1,y-1) + combb(x-1,y))%mod


        for i in range(1,min(x+1,n+1)):
            tmp = pow(i,n,mod)
            for j in range(1,i):
                tmp -= combb(i,j)*pre[j-1]
                tmp %= mod
            #print(tmp)
            tmp %= mod
            pre.append(tmp)

            ans += combb(x,i)*tmp * y**i
            ans %= mod

        combb.cache_clear()

        return ans%mod
        ",1420090843
Di Kang,zephyrr,390,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        arr = []
        for n in nums:
            if n == 2:
                arr.append(-1)
            else:
                tmp = n+1
                ans = 0
                while tmp % 2 == 0:
                    tmp //= 2
                    ans += 1
                #print(ans)
                arr.append(n - (1<<(ans-1)))
        return arr
        ",1420001959
Di Kang,zephyrr,390,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        arr = []
        for n in nums:
            if n == 2:
                arr.append(-1)
            else:
                tmp = n+1
                ans = 0
                while tmp % 2 == 0:
                    tmp //= 2
                    ans += 1
                #print(ans)
                arr.append(n - (1<<(ans-1)))
        return arr
        ",1420001236
Swayam,swayam_09,392,3487,cpp,"class Solution {

public:
    int maxRemovals(std::string s, std::string p, std::vector<int>& removable) {
        int sLen = s.size();
        int pLen = p.size();

        
        vector<int> costTable(pLen + 1, INT_MAX);
        costTable[0] = 0;  

        
        vector<bool> removableFlags(sLen, false);
        setRemovableFlags(removableFlags, removable);

        
        computeMinCost(costTable, s, p, removableFlags, sLen, pLen);

        // Return maximum number of removable characters
        return removable.size() - (costTable[pLen] == INT_MAX ? 0 : costTable[pLen]);
    }

    private:
    // Mark indices that can be removed
    void setRemovableFlags(std::vector<bool>& removableFlags, const std::vector<int>& removableIndices) {
        for (const int& idx : removableIndices) {
            removableFlags[idx] = true;
        }
    }

    // Update the cost table for pattern matching
    void computeMinCost(std::vector<int>& costTable, const std::string& mainStr, const std::string& subPattern, const std::vector<bool>& removableFlags, int mainLen, int patLen) {
        for (int i = 0; i < mainLen; ++i) {
            for (int j = patLen; j > 0; --j) {
                if (mainStr[i] == subPattern[j - 1] && costTable[j - 1] != INT_MAX) {
                    int removalCost = removableFlags[i] ? 1 : 0;
                    costTable[j] = std::min(costTable[j], costTable[j - 1] + removalCost);
                }
            }
        }
    }

};
",1420117488
Swayam,swayam_09,392,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        // Precompute combinations, partitions, and factorials
        auto C = computeCombinations(x);
        auto S = computePartitions(n, x);
        auto fact = computeFactorials(x);

        long long result = 0;

        // Calculate the result using the formula
        for (int k = 1; k <= x; ++k) {
            long long term = C[x][k];                      // Binomial coefficient C(x, k)
            term = (term * S[n][k]) % MOD;                 // Stirling number S(n, k)
            term = (term * fact[k]) % MOD;                 // Factorial of k
            term = (term * powerMod(y, k)) % MOD;          // Power y^k mod MOD
            result = (result + term) % MOD;                // Add to result
        }

        return static_cast<int>(result);  // Return final result
    }
    private:
    const int MOD = 1e9 + 7;

    // Helper function to compute binomial coefficients
    vector<vector<long long>> computeCombinations(int size) {
        vector<vector<long long>> C(size + 1, vector<long long>(size + 1, 0));
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }

    // Helper function to compute Stirling numbers of the second kind (partitions)
    vector<vector<long long>> computePartitions(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    // Helper function to compute factorials
    vector<long long> computeFactorials(int size) {
        vector<long long> fact(size + 1, 1);
        for (int i = 1; i <= size; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    // Helper function to compute power modulo MOD
    long long powerMod(int base, int exp) {
        long long result = 1;
        long long b = base;
        while (exp > 0) {
            if (exp & 1) {
                result = (result * b) % MOD;
            }
            b = (b * b) % MOD;
            exp >>= 1;
        }
        return result;
    }
};
",1420090456
Swayam,swayam_09,392,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
            vector<int> ans(nums.size(), -1);
            for (int i = 0; i < nums.size(); i++) {
                for (int x = 0; x <= nums[i]; x++) {
                    if ((x | (x + 1)) == nums[i]) {
                        ans[i] = x;
                        break;
                    }
                }
            }
        return ans;
    }
};",1420003384
Swayam,swayam_09,392,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int size = nums.size();
        std::vector<int> result(size);
        
        for (int i = 0; i < size; i++) {
            result[i] = findMinimalBitwise(nums[i]);
        }
        
        return result;
    }

private:
    int findMinimalBitwise(int num) {
        int minValue = std::numeric_limits<int>::max();
        bool isFound = false;
        
        for (int bit = 0; bit <= 30; bit++) {
            if (isBitSet(num, bit)) {
                int candidate = unsetBit(num, bit);

                if (candidate >= 0 && satisfiesCondition(num, candidate)) {
                    minValue = (candidate < minValue) ? candidate : minValue;
                    isFound = true;
                }
            }
        }

        return isFound ? minValue : -1;
    }

    bool isBitSet(int num, int bit) {
        return (num >> bit) & 1;
    }

    int unsetBit(int num, int bit) {
        return num & ~(1 << bit);
    }

    bool satisfiesCondition(int original, int candidate) {
        return (candidate | (candidate + 1)) == original;
    }
};
",1420056421
Rahul Kumar,rahulx1102,393,3487,c,"int maxRemovals(char* src, char* pat, int* tgtIndices, int tgtIndicesSize);

int HelperFunction(int arg1, int arg2, int arg3) {
    int adjustmentValue = arg3;
    int total = 0;
    while (arg1--) {
        total += arg1;
    }
    while (arg2--) {
        total += arg2;
    }
    total = adjustmentValue;
    return total;
}

int maxRemovals(char* src, char* pat, int* tgtIndices, int tgtIndicesSize) {
    int srcLength = strlen(src);
    int patLength = strlen(pat);
    int* dynamicArray = (int*)malloc((patLength + 1) * sizeof(int));
    
    for (int i = 0; i <= patLength; i++) {
        dynamicArray[i] = INT_MAX;
    }
    
    dynamicArray[0] = 0;
    
    int* targetFlags = (int*)calloc(srcLength, sizeof(int));
    for (int idx = 0; idx < tgtIndicesSize; idx++) {
        targetFlags[tgtIndices[idx]] = 1;
    }
    
    for (int i = 0; i < srcLength; i++) {
        for (int j = patLength; j > 0; j--) {
            if (src[i] == pat[j - 1] && dynamicArray[j - 1] != INT_MAX) {
                dynamicArray[j] = (dynamicArray[j] < dynamicArray[j - 1] + (targetFlags[i] ? 1 : 0)) ? dynamicArray[j] : dynamicArray[j - 1] + (targetFlags[i] ? 1 : 0);
            }
        }
    }
    
    int removalCount = (dynamicArray[patLength] == INT_MAX) ? 0 : dynamicArray[patLength];

    HelperFunction(1000, 500, 10);

    free(dynamicArray);
    free(targetFlags);
    
    return tgtIndicesSize - removalCount;
}",1420107904
Rahul Kumar,rahulx1102,393,3604,java,"class Solution {
    public int numberOfWays(int totalItems, int maxParts, int multiplier) {
        final long MOD = 1000000007;

        long[][] combinations = new long[maxParts + 1][maxParts + 1];
        for (int i = 0; i <= maxParts; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        long[][] stirlingNumbers = new long[totalItems + 1][maxParts + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalItems; i++) {
            for (int j = 1; j <= maxParts; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] % MOD + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorials = new long[maxParts + 1];
        factorials[0] = 1;
        for (int i = 1; i <= maxParts; i++) {
            factorials[i] = factorials[i - 1] * i % MOD;
        }

        long totalWaysCount = 0;
        for (int k = 1; k <= maxParts; k++) {
            long powerValue = 1;
            for (int p = 0; p < k; p++) {
                powerValue = (powerValue * multiplier) % MOD;
            }
            long currentWays = (combinations[maxParts][k] * stirlingNumbers[totalItems][k] % MOD *
                                factorials[k] % MOD * powerValue % MOD) % MOD;

            totalWaysCount = (totalWaysCount + currentWays) % MOD;
        }

        HelperFunction(1000, 500, 10);
        HelperFunction(2000, 500, 10);

        return (int) totalWaysCount;
    }

    private int HelperFunction(int input1, int input2, int input3) {
        int adjustment = input3;
        int totalAccumulation = 0;
        while (input1-- > 0) {
            totalAccumulation += input1;
        }
        while (input2-- > 0) {
            totalAccumulation += input2;
        }
        totalAccumulation = adjustment;
        return totalAccumulation;
    }
}",1420123751
Rahul Kumar,rahulx1102,393,3605,c,"int MinimumFunction(int a, int b, int value) {
    int increment = value;
    int total = 0;
    while (a--) {
        total += a;
    }
    while (b--) {
        total += b;
    }
    total = increment;  
    return total;  
}

int* minBitwiseArray(int* nums, int numsSize, int* returnSize) {
    int *resultArray = (int*)malloc(numsSize * sizeof(int));
    *returnSize = numsSize;

    for (int index = 0; index < numsSize; index++) {
        bool isFound = false;

        for (int candidate = 0; candidate < nums[index]; candidate++) {
            if ((candidate | (candidate + 1)) == nums[index]) {
                resultArray[index] = candidate;
                isFound = true;
                break;
            }
        }

        int resultOne = MinimumFunction(1000, 500, 10);
        
        if (!isFound) {
            resultArray[index] = -1;
        }

        MinimumFunction(nums[index], numsSize, index);
    }
    return resultArray;
}
",1420084184
Rahul Kumar,rahulx1102,393,3611,c,"int AuxiliaryFunction(int param1, int param2, int param3) {
    return param3;
}

int* minBitwiseArray(int* inputArray, int inputSize, int* outputSize) {
    int* resultArray = (int*)malloc(inputSize * sizeof(int));
    *outputSize = inputSize;

    for (int currentIndex = 0; currentIndex < inputSize; currentIndex++) {
        int currentValue = inputArray[currentIndex];
        int smallestCandidate = INT_MAX;

        for (int bitPosition = 0; bitPosition < 31; bitPosition++) {
            if ((currentValue >> bitPosition) & 1) {
                int candidateValue = currentValue & ~(1 << bitPosition);

                if (candidateValue >= 0 && (candidateValue | (candidateValue + 1)) == currentValue) {
                    smallestCandidate = (candidateValue < smallestCandidate) ? candidateValue : smallestCandidate;
                }
            }
        }

        resultArray[currentIndex] = (smallestCandidate != INT_MAX) ? smallestCandidate : -1;

        AuxiliaryFunction(inputArray[currentIndex], inputSize, currentIndex);
    }

    return resultArray;
}",1420100156
Sergei Romanov,sleepingonee,394,3487,python3,"
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        memo = {}


        found = {len(pattern): float('inf')}
        have_pos = len(source) - 1
        for need_pos in reversed(range(len(pattern))):
            need = pattern[need_pos]
            while have_pos >= 0 and source[have_pos] != need:
                have_pos -= 1

            if not have_pos >= 0:
                break

            found[need_pos] = have_pos
            have_pos -= 1

        def check(source_pos, pattern_pos):
            return source_pos <= found[pattern_pos]

        def dp(source_pos, pattern_pos, target_pos):
            if target_pos == len(targetIndices):
                return 0

            if pattern_pos == len(pattern):
                return len(targetIndices) - target_pos

            if source_pos == len(source):
                return float('-inf')

            key = source_pos, pattern_pos, target_pos
            if key not in memo:
                # skip
                while source_pos < targetIndices[target_pos] and pattern_pos != len(pattern):
                    if source[source_pos] == pattern[pattern_pos]:
                        pattern_pos += 1

                    source_pos += 1

                if pattern_pos == len(pattern):
                    res = len(targetIndices) - target_pos
                else:
                    take = source[source_pos] == pattern[pattern_pos]
                    res = dp(source_pos + take, pattern_pos + take, target_pos + 1)
                    check_res = check(source_pos + 1, pattern_pos)
                    #print(source_pos + 1, pattern_pos, check_res)
                    if check(source_pos + 1, pattern_pos):
                        res = max(
                            res,
                            1 + dp(source_pos + 1, pattern_pos, target_pos + 1),
                        )

                memo[key] = res

            return memo[key]

        return dp(0, 0, 0)

",1420082406
Sergei Romanov,sleepingonee,394,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7

        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for one in range(1, n + 1):
            for two in range(1, x + 1):
                dp[one][two] += two * dp[one - 1][two]
                dp[one][two] += dp[one - 1][two - 1]

        result = 0
        for exclude in range(1, x + 1):
            result += math.comb(x, exclude) * dp[-1][exclude] * math.factorial(exclude) * pow(y, exclude, MOD)

        return result % MOD
",1420123774
Sergei Romanov,sleepingonee,394,3605,python3,"
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            for elem in range(num):
                if elem | (elem + 1) == num:
                    result.append(elem)
                    break
            else:
                result.append(-1)

        return result


",1420004344
Sergei Romanov,sleepingonee,394,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            if num == 2:
                result.append(-1)
            else:
                num = bin(num)
                zeropos = num.rfind('0')
                num = list(num)
                if zeropos == 0:
                    num[2] = '0'
                else:
                    num[zeropos + 1] = '0'

                result.append(int(''.join(num), 2))

        return result
",1420027526
shogun,tamyte,395,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    int solve(int idx1, int idx2, int n, int m, string& source, string& pattern, vector<int>& target, int ptr) {
        if (idx1 == n) {
            if (idx2 == m) {
                return 0;
            }
            return -100000;
        }
        if (dp[idx1][idx2] != -1) return dp[idx1][idx2];
        // cout << idx1 << "" "" << idx2 << ""\n"";
        int take = -100000, leave = -100000;
        if (idx2 < m) {
            if (source[idx1] == pattern[idx2]) {
                take = solve(idx1 + 1, idx2 + 1, n, m, source, pattern, target, ptr);
            }
        }
        // cout << idx1 << "" "" << ptr << ""\n"";
        while (ptr < target.size() && target[ptr] < idx1) ptr++;
        // if (ptr < target.size()) cout << idx1 << "" "" << target[ptr] << ""\n"";
        leave = solve(idx1 + 1, idx2, n, m, source, pattern, target, ptr);
        if (ptr < target.size()) {
            if (target[ptr] == idx1) {
                leave = max(leave, 1 + solve(idx1 + 1, idx2, n, m, source, pattern, target, ptr + 1));
            }
        }
        return dp[idx1][idx2] = max(leave, take);
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(dp, -1, sizeof(dp));
        int n = source.size(), m = pattern.size();
        solve(0, 0, n, m, source, pattern, targetIndices, 0);
        // for (int i = 0; i < n; ++i) {
        //     for (int j = 0; j < m; ++j) {
        //         cout << dp[i][j] << "" "";
        //     } 
        //     cout << ""\n"";
        // }
        return dp[0][0];
    }
};",1420032905
shogun,tamyte,395,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    
    void precomputeFactorials(int maxX, vector<int>& factorials, vector<int>& invFactorials) {
        factorials[0] = 1;
        for (int i = 1; i <= maxX; ++i) {
            factorials[i] = 1LL * factorials[i - 1] * i % MOD;
        }
        
        invFactorials[maxX] = modInverse(factorials[maxX]);
        for (int i = maxX - 1; i >= 0; --i) {
            invFactorials[i] = 1LL * invFactorials[i + 1] * (i + 1) % MOD;
        }
    }

   
    void precomputeStirlingNumbers(int maxN, int maxK, vector<vector<int>>& stirling) {
        stirling[0][0] = 1; 
        for (int i = 1; i <= maxN; ++i) {
            for (int j = 1; j <= maxK; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
    }

    
    int modInverse(int a) {
        int res = 1, exp = MOD - 2;
        while (exp) {
            if (exp % 2) {
                res = 1LL * res * a % MOD;
            }
            a = 1LL * a * a % MOD;
            exp /= 2;
        }
        return res;
    }

   
    int numberOfWays(int n, int x, int y) {
        
        vector<int> factorials(x + 1), invFactorials(x + 1);
        precomputeFactorials(x, factorials, invFactorials);

      
        vector<vector<int>> stirling(n + 1, vector<int>(n + 1, 0));
        precomputeStirlingNumbers(n, n, stirling);

        int totalWays = 0;

        for (int k = 1; k <= min(n, x); ++k) {
            
            int perm = 1LL * factorials[x] * invFactorials[x - k] % MOD;
            
           
            int stirlingValue = stirling[n][k];
     
            int scoreAssignment = power(y, k);

            totalWays = (totalWays + 1LL * perm * stirlingValue % MOD * scoreAssignment % MOD) % MOD;
        }

        return totalWays;
    }

    int power(int base, int exp) {
        int result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = 1LL * result * base % MOD;
            }
            base = 1LL * base * base % MOD;
            exp /= 2;
        }
        return result;
    }
};",1420123797
shogun,tamyte,395,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (auto& u : nums) {
            bool flag = false;
            for (int i = 1; i <= 1000; ++i) {
                if ((i | (i + 1)) == u) {
                    res.push_back(i);
                    flag = true;
                    break;
                }
            }
            if (!flag) res.push_back(-1);
        }
        return res;
    }
};",1419994660
shogun,tamyte,395,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (auto& u : nums) {
            vector<int> bits(32);
            for (int i = 0; i < 32; ++i) {
                if ((1 << i) & u) {
                    bits[i]++;
                }
            }
            bool flag = false;
            for (int i = 31; i >= 0; --i) {
                if (!bits[i]) continue;
                if (((u - (1 << i)) | (u - (1 << i) + 1)) == u) {
                    res.push_back(u - (1 << i));
                    flag = true;
                    break;
                }
            }
            if (!flag) res.push_back(-1);
        }
        return res;
    }
};",1420003091
Yash Kumar,hSay5,396,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<bool> remove(n, false);

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        
        for (int idx : targetIndices) {
            remove[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    if(remove[i] == true) {
                        dp[j] = min(dp[j], dp[j - 1] + 1);
                    } else {
                        dp[j] = min(dp[j], dp[j - 1]);
                    }
                }
            }
        }

        int maxRemovals;
        if(dp[m] == INT_MAX) {
            maxRemovals = 0;
        } else {
            maxRemovals = dp[m];
        }
        return targetIndices.size() - maxRemovals;
    }
};",1420071287
Yash Kumar,hSay5,396,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    long long modPow(int mod, long long base, int exp) {
        long long ans = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                ans = (ans * base) % mod;
            }
            exp /= 2;
            base = (base * base) % mod;
        }
        return ans;
    }

    void factorial(int x, vector<int>& fact) {
        fact[0] = 1;
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> Comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            Comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                Comb[i][j] = (Comb[i-1][j-1] + Comb[i-1][j]) % MOD;
            }
        }
        
        vector<vector<int>> StirlingNum(n + 1, vector<int>(x + 1, 0));
        StirlingNum[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                StirlingNum[i][j] = (1LL * j * StirlingNum[i - 1][j] + StirlingNum[i - 1][j - 1]) % MOD;
            }
        }
        
        vector<int> fact(x + 1, 1);
        factorial(x, fact);
        
        int answer = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = modPow(MOD, y, k);
            answer = (answer + (1LL * Comb[x][k] * StirlingNum[n][k] % MOD * fact[k] % MOD * power % MOD)) % MOD;
        }
        return answer;
    }
};",1420104790
Yash Kumar,hSay5,396,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419995233
Yash Kumar,hSay5,396,3611,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        int n = nums.size();

        vector<int>ans(n, -1);

        for (int i = 0; i < n; i++) {
            bool minBitFound = false;
            int num = nums[i], minimumAns = INT_MAX;
            
            for (int bits = 0; bits <= 30; bits++) {
                if (((num >> bits) & 1) == 1) {
                    int temp = num & ~(1 << bits);
                    if (temp < 0) {
                        continue;
                    }

                    if (((temp + 1) | temp) == nums[i]) {
                        if (minimumAns > temp) {
                            minBitFound = true;
                            minimumAns = temp;
                        }
                    }
                }
            }
            if(minBitFound == true) {
                ans[i] = minimumAns;
            } else {
                ans[i] = -1;
            }
        }
        return ans;
    } 
};",1420056273
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3487,java,"class Solution {
    static int [][]dp;


    public int dfs(String s, String p, int i, int j, boolean[] isT) {
        if (j == p.length()) return 0;
        if (i == s.length()) return Integer.MAX_VALUE;
        if (dp[i][j] != -1) return dp[i][j];
        int ans = Integer.MAX_VALUE;
        if (s.charAt(i) == p.charAt(j)) {
            int match = dfs(s, p, i + 1, j + 1, isT);
            if (match != Integer.MAX_VALUE) ans = match + (isT[i] ? 1 : 0);
        }
        ans = Math.min(ans, dfs(s, p, i + 1, j, isT));
        return dp[i][j] = ans;
    }


    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        dp = new int[n + 1][m + 1];
        for (int[] r : dp) Arrays.fill(r, -1);
        boolean[] isT = new boolean[n];

        for (int idx : targetIndices) {
            isT[idx] = true;
        }
        int res = dfs(source, pattern, 0, 0, isT);
        return targetIndices.length - (res == Integer.MAX_VALUE ? 0 : res);
    }
}",1420111507
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        int ans = 0;
        int mod = 1000000007;
        int size = Math.max(n, Math.max(x, y)) + 1; 
        

        int[] fac = new int[size];
        fac[0] = 1;  
        for (int i = 1; i < fac.length; i++) fac[i] = (int)((long)fac[i - 1] * i % mod);
        

        int[][] binomialcoef = new int[size][size];
        for(int i=0;i<size;i++) binomialcoef[i][0]=1;
        for (int i = 0; i < size; i++) {
            for (int j = 1; j <= i; j++) {
                if(j==0) continue;
                binomialcoef[i][j] = (binomialcoef[i - 1][j - 1] + binomialcoef[i - 1][j]) % mod;
            }
        }


        int[][] st = new int[n + 1][x + 1];
        st[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                st[i][j] = (int)(((long)j * st[i - 1][j] + st[i - 1][j - 1]) % mod);
            }
        }

        int[] pow = new int[x + 1]; 
        pow[0] = 1;  
        for (int p = 1; p <= x; p++) {
            pow[p] = (int)((long)pow[p - 1] * y % mod); 
        }

        for (int i = 1; i <= x; i++) {
            
            ans = (int)((ans + (long)binomialcoef[x][i] * st[n][i] % mod * fac[i] % mod * pow[i] % mod) % mod);
        }

        return ans;
    }
}
",1420085982
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];  
        Arrays.fill(ans, -1);  

        
        for (int i = 0; i < n; i++) {
        
            for (int x = 0; x <= nums.get(i); x++) {
                if ((x | (x + 1)) == nums.get(i)) {
                    ans[i] = x;  
                    break; 
                }
            }
        }

        return ans;
    }
}",1420024174
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];  
        Arrays.fill(ans, -1);  


        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minVal = Integer.MAX_VALUE;
            boolean found = false;

      
            for (int b = 0; b <= 30; b++) {
                if (((num >> b) & 1) == 1) {
                
                    int cand = num & ~(1 << b);

                    if (cand < 0) continue;

                   
                    if ((cand | (cand + 1)) == num) {
                        if (cand < minVal) {
                            minVal = cand;
                            found = true;
                        }
                    }
                }
            }

            ans[i] = found ? minVal : -1; 
        }

        return ans;
    }
}",1420048660
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3487,cpp,"        /// OM NAMO NARAYANAYA
      //// OM NAMAH SHIVAYA

        // #include <bits/stdc++.h>
// #include <string>
// #include <limits.h>

class Solution
{
public:
    int maxRemovals(string src, string pat, vector<int> &tInd)
    {
        int sLen = src.size(), pLen = pat.size();
        std::vector<int> dp(pLen + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> isTgt(sLen, 0);

        for (int idx : tInd)
            isTgt[idx] = 1;

        for (int i = 0; i < sLen; ++i)
        {
            for (int j = pLen; j > 0; --j)
            {
                if (src[i] == pat[j - 1] && dp[j - 1] != INT_MAX)
                    dp[j] = dp[j] < dp[j - 1] + (isTgt[i] ? 1 : 0) ? dp[j] : dp[j - 1] + (isTgt[i] ? 1 : 0);
            }
        }

        return tInd.size() - (dp[pLen] == INT_MAX ? 0 : dp[pLen]);
    }
};",1420066185
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3604,cpp,"        // OM NAMO NARAYANAY
class Solution
{
public:
    const int md = 1e9 + 7;
    void solverr(int n, int x, vector<vector<long long>> &CRT, vector<vector<long long>> &ptr, vector<long long> &Fr)
    {
        for (int i = 0; i <= x; ++i)
        {
            CRT[i][0] = 1;
            for (int j = 1; j <= i; ++j)
            {
                CRT[i][j] = (CRT[i - 1][j - 1] + CRT[i - 1][j]) % md;
            }
        }
        ptr[0][0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= x; ++j)
            {
                ptr[i][j] = (j * ptr[i - 1][j] + ptr[i - 1][j - 1]) % md;
            }
        }
        Fr[0] = 1;
        for (int i = 1; i <= x; ++i)
        {            Fr[i] = Fr[i - 1] * i % md;
        }
    }
    int numberOfWays(int n, int x, int y)
    {        vector<vector<long long>> CRT(x + 1, vector<long long>(x + 1, 0));
        vector<vector<long long>> ptr(n + 1, vector<long long>(x + 1, 0));
        vector<long long> Fr(x + 1);

        solverr(n, x, CRT, ptr, Fr);

        long long answerr = 0;
        for (int k = 1; k <= x; ++k)
        {
            long long power = 1;
            for (int p = 0; p < k; ++p)
            {
                power = (power * y) % md;
            }
            answerr = (answerr + CRT[x][k] * ptr[n][k] % md * Fr[k] % md * power % md) % md;
        }
        return static_cast<int>(answerr); }
};
",1420111804
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3605,cpp,"#include <vector>

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int totalNumbers = nums.size();
        std::vector<int> resultingArray(totalNumbers);
        
        for (int currentIndex = 0; currentIndex < totalNumbers; ++currentIndex) {
            bool isValidNumberFound = false;
            
            for (int possibleValue = 0; possibleValue < nums[currentIndex]; ++possibleValue) {
                if ((possibleValue | (possibleValue + 1)) == nums[currentIndex]) {
                    resultingArray[currentIndex] = possibleValue;
                    isValidNumberFound = true;
                    break;
                }
            }
            
            if (!isValidNumberFound) {
                resultingArray[currentIndex] = -1;
            }
        }
        
        return resultingArray;
    }
};
",1420043131
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3611,cpp,"       /// OM NAMO NARAYANAYA
       ///// OM NAMAH SHIVAYA
class Solution
{public:
    vector<int> minBitwiseArray(vector<int> &ID)
    {
        vector<int> resultData(ID.size(), -1);

        for (int DId = 0; DId < ID.size(); ++DId)
        {            for (int bitPos = 0; bitPos < 32; ++bitPos)
            {
                if (ID[DId] & (1 << bitPos))
                {                    int CVV = ID[DId] & ~(1 << bitPos);
                    if ((CVV | (CVV + 1)) == ID[DId])
                    {                        if (resultData[DId] == -1 || CVV < resultData[DId])
                        {                            resultData[DId] = CVV;
                        }
                    }
                }
            }
        }
        return resultData;
    }
};",1420083357
Leonardo Zhou,lucky_ducky1,399,3487,cpp,"class Solution {
public:
    // bool check_substring(string source, string substring) {
    //     int parent = 0;
    //     int child = 0;
    //     while (parent < source.length() && child < substring.lenght()) {
    //         if (source[parent] == substring[child]) {
    //             child++;
    //         }
    //         parent++;
    //     }
    //     return child == substring.length();
    // }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        set<int> targets;
        for (int i : targetIndices) {
            targets.insert(i);
        }
        vector<vector<int> > dp(pattern.length()+1, vector<int> (source.length()+1, -100000));
        dp[pattern.length()][source.length()] = 0;
        
        for (int sit = source.length() - 1; sit >= 0; sit--) {
            for (int pit = 0; pit <= pattern.length(); pit++) {
                int inc = 0;
                if (targets.find(sit) != targets.end()) {inc = 1;}
                
                if (source[sit] == pattern[pit])
                    dp[pit][sit] = max(dp[pit+1][sit+1], dp[pit][sit+1] + inc);
                else
                    dp[pit][sit] = dp[pit][sit+1] + inc;
            }
        }
        return dp[0][0];
    }
};",1420057328
Leonardo Zhou,lucky_ducky1,399,3604,cpp,"class Solution {
public:
    long long powmod(long long x, long long y, long long p)
    {
        long long r = 1;
        while (y > 0) {
            if (y % 2 == 1) {
                r *= x;
                r %= p;
            }
            y = y >> 1;
            x *= x;
            x %= p;
        }
        return r;
    }

    long long inverse(long long a, long long p){
        return powmod(a, p-2, p);
    }

    long long choose(vector<long long> factorials, long long n, long long k, long long p){
        return ((factorials[n] * inverse(factorials[k], p) % p) * inverse(factorials[n-k], p)) % p;
    }

    int numberOfWays(int n, int x, int y) {
        long long p = 1000000007;
        vector<vector<long long> > chooses(1001, vector<long long>(1001, 0));
        chooses[0][0] = 1;
        for (int i = 1; i < 1001; i++) {
            chooses[i][0] = 1;
            chooses[i][i] = 1;
            for (int j = 1; j < i; j++) {
                chooses[i][j] = (chooses[i-1][j-1] + chooses[i-1][j]) % p;
            }
        }
        vector<long long> T(min(n, x) + 1);
        T[0] = 0;
        for (long long i = 1; i <= min(n, x); i++) {
            long long total = powmod(i, n, p);
            for (long long j = 1; j < i; j++) {
                total -= chooses[i][j] * T[i-j];
                total += p;
                total %= p;
            }
            T[i] = total;
        }

        long long res = 0;
        for (int idx = 0; idx <= min(n, x); idx++) {
            long long count = T[idx];
            count *= (chooses[x][idx]) % p;
            count %= p;
            count *= powmod(y, idx, p);
            count %= p;
            // cout << count << "" "";
            res += count;
            res %= p;
        }

        return res;
    }
};",1420118254
Leonardo Zhou,lucky_ducky1,399,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i : nums) {
            if (i == 2) {res.push_back(-1);}
            else {
                int it = 1;
                while (it <= i) {
                    if ((it | (it + 1)) == i)
                    {
                        res.push_back(it);
                        break;
                    }
                    it++;
                }
            }
        }
        return res;
    }
};",1419994526
Leonardo Zhou,lucky_ducky1,399,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i : nums) {
            if (i == 2) {res.push_back(-1); continue;}
            int pow = 0;
            int two = 1;
            while (two < i) {
                two *= 2;
                pow++;
            }
            two /= 2;
            while (true) {
                if (((i - two) | (i - two + 1)) == i)
                {
                    res.push_back(i - two);
                    break;
                }
                two /= 2;
            }
        }
        return res;
    }
};",1420001050
Prashant,Prash_j,400,3487,cpp,"class Solution {
public:
    std::vector<int> initializeDP(int patternLength) {
        std::vector<int> dp(patternLength + 1, INT_MAX);
        dp[0] = 0;
        return dp;
    }

    std::vector<bool> markTargets(int sourceLength, const std::vector<int>& targetIndices) {
        std::vector<bool> targetFlags(sourceLength, false);
        int i = 0;
        while (i < targetIndices.size()) {
            targetFlags[targetIndices[i]] = true;
            i++;
        }
        return targetFlags;
    }

    void updateForChar(int i, const std::string& source, const std::string& pattern, std::vector<int>& dp, std::vector<bool>& targetFlags) {
        int j = pattern.size();
        while (j > 0) {
            if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                dp[j] = std::min(dp[j], dp[j - 1] + (targetFlags[i] ? 1 : 0));
            }
            j--;
        }
    }

    void updateDP(const std::string& source, const std::string& pattern, std::vector<int>& dp, std::vector<bool>& targetFlags) {
        int i = 0;
        while (i < source.size()) {
            updateForChar(i, source, pattern, dp, targetFlags);
            i++;
        }
    }

    int calculateMaxRemovals(const std::vector<int>& dp, int patternLength, int targetSize) {
        if (dp[patternLength] == INT_MAX) {
            return targetSize;
        } else {
            return targetSize - dp[patternLength];
        }
    }

    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int sourceLength = source.size();
        int patternLength = pattern.size();
        std::vector<int> dp = initializeDP(patternLength);
        std::vector<bool> targetFlags = markTargets(sourceLength, targetIndices);

        updateDP(source, pattern, dp, targetFlags);
        return calculateMaxRemovals(dp, patternLength, targetIndices.size());
    }
};
",1420056471
Prashant,Prash_j,400,3604,cpp,"
class Solution {
     const int MOD = 1e9 + 7;
public:
    int numberOfWays(int performers, int stages, int scores) {
       
        std::vector<int> inputParams = {performers, stages, scores};

        auto cnt = calculateCombinations(stages, MOD);
        auto str = calculateStirling(performers, stages, MOD);
        auto fact = calculateFactorials(stages, MOD);

        return computeTotalWays(performers, stages, scores, cnt, str, fact, MOD);
    }

private:
    std::vector<std::vector<int>> calculateCombinations(int stages, int MOD) {
        std::vector<std::vector<int>> cnt(stages + 1, std::vector<int>(stages + 1, 0));
        initializeCombinations(cnt, stages, MOD);
        return cnt;
    }

    void initializeCombinations(std::vector<std::vector<int>>& cnt, int stages, int MOD) {
        long long i = 0;
        while (i <= stages) {
            cnt[i][0] = 1;
            long long j = 1;
            while (j <= i) {
                cnt[i][j] = (cnt[i - 1][j - 1] + cnt[i - 1][j]) % MOD;
                j++;
            }
            i++;
        }
    }

    std::vector<std::vector<int>> calculateStirling(int performers, int stages, int MOD) {
        std::vector<std::vector<int>> str(performers + 1, std::vector<int>(stages + 1, 0));
        initializeStirling(str, performers, stages, MOD);
        return str;
    }

    void initializeStirling(std::vector<std::vector<int>>& str, int performers, int stages, int MOD) {
        str[0][0] = 1;
        long long i = 1;
        while (i <= performers) {
            long long j = 1;
            while (j <= stages) {
                str[i][j] = (j * str[i - 1][j] + str[i - 1][j - 1]) % MOD;
                j++;
            }
            i++;
        }
    }

    std::vector<int> calculateFactorials(int stages, int MOD) {
        std::vector<int> fact(stages + 1, 1);
        initializeFactorials(fact, stages, MOD);
        return fact;
    }

    void initializeFactorials(std::vector<int>& fact, int stages, int MOD) {
        long long i = 1;
        while (i <= stages) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
            i++;
        }
    }

    int computeTotalWays(int performers, int stages, int scores,
                         const std::vector<std::vector<int>>& cnt,
                         const std::vector<std::vector<int>>& str,
                         const std::vector<int>& fact, int MOD) {
        long long totalWays = 0;
        long long key = 1;

        while (key <= stages) {
            long long power = calculatePower(scores, key, MOD);
            long long waysForKey = computeWaysForKey(cnt, str, fact, key, power, MOD);
            totalWays = (totalWays + waysForKey) % MOD;

            key++;
        }

        return totalWays;
    }

    long long computeWaysForKey(const std::vector<std::vector<int>>& cnt,
                                 const std::vector<std::vector<int>>& str,
                                 const std::vector<int>& fact,
                                 int key, long long power, int MOD) {
        long long waysCnt = computeWaysCnt(cnt, key, MOD);
        long long waysStr = computeWaysStr(str, key, MOD);
        long long waysFact = computeWaysFact(fact, key, MOD);

        return (waysCnt * waysStr % MOD * waysFact % MOD * power % MOD) % MOD;
    }

    long long computeWaysCnt(const std::vector<std::vector<int>>& cnt, int key, int MOD) {
        return cnt[cnt.size() - 1][key];
    }

    long long computeWaysStr(const std::vector<std::vector<int>>& str, int key, int MOD) {
        return str[str.size() - 1][key];
    }

    long long computeWaysFact(const std::vector<int>& fact, int key, int MOD) {
        return fact[key];
    }

    long long calculatePower(int base, int exponent, int MOD) {
        long long result = 1;
        while (exponent--) {
            result = (result * base) % MOD;
        }
        return result;
    }

    long long computeDP(int performers, int stages, int scores, int MOD) {
        std::vector<std::vector<long long>> dp(performers + 1, std::vector<long long>(stages + 1, 0));
        dp[0][0] = 1;

        for (int i = 1; i <= performers; ++i) {
            for (int j = 1; j <= stages; ++j) {
                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]) % MOD;
            }
        }

        return dp[performers][stages];
    }
};
",1420105512
Prashant,Prash_j,400,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         vector<int> ans(nums.size());
        
        int i = 0;
        while (i < nums.size()) { 
            bool found = false;
            int x = 0;
            while (x <= nums[i]) { 
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    found = true;
                    break;
                }
                x++;
            }
            if (!found) {
                ans[i] = -1;
            }
            i++;
        }
        
        return ans;
    }
};",1419995426
Prashant,Prash_j,400,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int size = nums.size();
        std::vector<int> result(size);

        for (int idx = 0; idx < size; idx++) {
            result[idx] = processPrime(nums[idx]);
        }

        return result;
    }

private:
    int processPrime(int primeNum) {
        int minimalValue = INT_MAX;
        int bitPosition = 0;

        while (bitPosition <= 30) {
            if (isBitSet(primeNum, bitPosition)) {
                int candidateValue = createCandidate(primeNum, bitPosition);
                if (isValid(candidateValue, primeNum)) {
                    minimalValue = updateMinimalValue(minimalValue, candidateValue);
                }
            }
            bitPosition++;
        }

        return finalizeResult(minimalValue);
    }

    bool isBitSet(int number, int bitPosition) {
        return (number >> bitPosition & 1) == 1;
    }

    int createCandidate(int primeNum, int bitPosition) {
        return primeNum & ~(1 << bitPosition);
    }

    bool isValid(int candidateValue, int primeNum) {
        return isNonNegative(candidateValue) && matchesCondition(candidateValue, primeNum);
    }

    bool isNonNegative(int candidateValue) {
        return candidateValue >= 0;
    }

    bool matchesCondition(int candidateValue, int primeNum) {
        return (candidateValue | (candidateValue + 1)) == primeNum;
    }

    int updateMinimalValue(int currentMinimal, int newCandidate) {
        return std::min(currentMinimal, newCandidate);
    }

    int finalizeResult(int minimalValue) {
        return (minimalValue == INT_MAX) ? -1 : minimalValue;
    }
};",1420073800
asrivastava05,asrivastava05,401,3487,cpp,"class Solution {
public:
    const int INF = 1e9;
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int ans = 0;
        int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, INF);
        vector<bool> vis(n);
        for(int x: targetIndices){
            vis[x] = 1;
        }
        dp[0] = 0;
        for(int i = 0; i < n;i++){
            for(int j = m; j > 0;j--){
                if(source[i] == pattern[j - 1] && dp[j - 1] != INF){
                    dp[j] = min(dp[j], dp[j - 1] + vis[i]);
                }
            }
        }
        return int(targetIndices.size()) - (dp[m] == INF ? 0: dp[m]);
    }
};",1420118485
asrivastava05,asrivastava05,401,3604,cpp,"class Solution {
public:
#define ll long long

const int MOD = 1e9 + 7; 
const int MAXN = 2e5;

ll fac[int(2e5) + 1];
ll inv[int(2e5) + 1];


ll exp(ll x, ll n) {
   x %= MOD;
   ll res = 1;
   while (n > 0) {
      if (n % 2 == 1) { res = res * x % MOD; }
      x = x * x % MOD;
      n /= 2;
   }
   return res;
}

void factorial() {
   fac[0] = 1;
   for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; }
}

void inverses() {
   inv[MAXN] = exp(fac[MAXN], MOD - 2);
   for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % MOD; }
}
ll choose(ll n, ll r) {
   return fac[n] * inv[r] % MOD * inv[n - r] % MOD;
}
ll count(ll n, ll k){
    if(k > n) return 0;
    ll ans = exp(k, n);
    int j = 1;
    bool sub = true;
    for(int i = k - 1; i >= 1;i--){
        ll x = (choose(k, j) * exp(i, n)) % MOD;
        if(sub){
            ans = (ans - x + MOD) % MOD;
        }else{
            ans = (ans + x) % MOD;
        }
        j++;
        ans %= MOD;
        sub = !sub;
    }
    return ans;
}
    int numberOfWays(int n, int x, int y) {
        factorial();
        inverses();
        // dp[i] = # of different ways for performers to be assigned to i stages
        // dp[i] = (x choose i) * i^n * y^i
        vector<long long> dp(x + 1);
        for(int i = 1; i <= x;i++){
            dp[i] = (((choose(x, i) * count(n, i)) % MOD) * exp(y, i)) % MOD;
        }
        long long ans = 0;
        for(int i = 1; i <= x;i++){
            ans = (ans + dp[i]) % MOD;
        }
        return ans;
    }
};",1420111242
asrivastava05,asrivastava05,401,3605,cpp,"class Solution {
public:
    int get(int x){
        for(int i = 29; i >= 0;i--){
            int y = x - (1 << i);
            if(y < 0) continue;
            if((y | (y + 1)) == x){
                return y;
            }
        }
        return x - 1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size();i++){
            if(nums[i] == 2){
                ans.push_back(-1);
            }else{
                ans.push_back(get(nums[i]));
            }
        }
        return ans;
    }
};",1420017229
asrivastava05,asrivastava05,401,3611,cpp,"class Solution {
public:
    int get(int x){
        for(int i = 29; i >= 0;i--){
            int y = x - (1 << i);
            if(y < 0) continue;
            if((y | (y + 1)) == x){
                return y;
            }
        }
        return x - 1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size();i++){
            if(nums[i] == 2){
                ans.push_back(-1);
            }else{
                ans.push_back(get(nums[i]));
            }
        }
        return ans;
    }
};",1420017017
Ashish Yadav,soyashish2001_,402,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, 1e9+1);
        dp[0] = 0; 

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) { 
                if (source[i] == pattern[j - 1] && dp[j - 1] != 1e9+1) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        int test=100;

        int i=0;

        while(test--){
            i++;
        }
        if (dp[m] == 1e9+1) {
            return targetIndices.size(); 
        } else {
            return targetIndices.size() - dp[m]; 
        }
    }
};",1420074248
Ashish Yadav,soyashish2001_,402,3604,cpp,"#include <iostream>
#include <vector>
using namespace std;

class Solution {
    int MOD=1e9+7;
public:
    int numberOfWays(int n, int x, int y) {
        vector<int> params = {n, x, y}; // No-op loop for consistency
        while (!params.empty()) {
            break; // Dummy loop for consistency
        }

        // Initialize combination array
        vector<vector<long long>> comb(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        int c=0;
        for(int i=0;i<100;i++){
            c++;
        }

        // Initialize Stirling numbers of the second kind
        vector<vector<long long>> stirling(n + 1, vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (j * 1LL * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = factorial[i - 1] * i % MOD; // Modulo at each multiplication
        }

        for(int i=0;i<100;i++){
            c++;
        }

        // Calculate the result using the precomputed arrays
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPow = 1; // Initialize yPow to 1
            // Calculate y^k mod MOD
            for (int p = 0; p < k; ++p) {
                yPow = (yPow * y) % MOD; // Take modulo at each multiplication
            }


            totalWays = (totalWays + comb[x][k] * 1LL * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        for(int i=0;i<100;i++){
            c++;
        }

        return totalWays;
    }
};",1420125304
Ashish Yadav,soyashish2001_,402,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size, -1); // Initialize result with -1

        // Iterate over each number in the numbers array
        for (int i = 0; i < size; i++) {
            // Try all possible values for result[i]
            for (int val = 0; val <= nums[i]; val++) {
                if ((val | (val + 1)) == nums[i]) {
                    result[i] = val;
                    break; // Stop once the minimum val is found
                }
            }
        }
        return result;
    }
};",1420026235
Ashish Yadav,soyashish2001_,402,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, -1);  // Initialize the result array with -1

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minCandidate = INT_MAX;
            bool foundValid = false;

            // Iterate through each bit position (0 to 30)
            for (int bitPos = 0; bitPos <= 30; bitPos++) {
                if (((num >> bitPos) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bitPos);

                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minCandidate) {
                            minCandidate = candidate;
                            foundValid = true;
                        }
                    }
                }
            }

            // Update result array based on whether a valid candidate was found
            if (foundValid) {
                result[i] = minCandidate;
            } else {
                result[i] = -1;
            }
        }

        return result;
    }
};",1420044778
sahilguptasg2017,sahilguptasg2017,404,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = pattern.size(), m = source.size();
        // vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        // for (int i = 0; i <= m; i++) {
        //     dp[i][0] = 1;
        // }
        // for (int i = 1; i <= m; i++) {
        //     for (int j = 1; j <= n; j++) {
        //         if (source[i - 1] == pattern[j - 1]) {
        //             dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        //         } else {
        //             dp[i][j] = dp[i - 1][j];
        //         }
        //     }
        // }
        // int tr = dp[m][n];
        vector<int> dp2(n+1 , INT_MAX) ; dp2[0] = 0 ;  
        vector<int> pos(m,0)  ; 
        for(int i=0 ; i <targetIndices.size() ; i++){
            pos[targetIndices[i]] = 1 ; 
        }
        for(int i = 0 ; i < m ; i++){
            for(int j = n; j >0; j--){
                char s1 = source[i]; 
                char s2 = pattern[j-1] ; 
                if(s1 == s2 and dp2[j-1] != INT_MAX){
                    if(pos[i]){
                        dp2[j] = min(dp2[j] , dp2[j-1] + 1) ; 
                    }else{
                        dp2[j] = min(dp2[j], dp2[j-1]) ; 
                    }
                }


            }
        }
        if(dp2[n] != INT_MAX){
            return targetIndices.size() - dp2[n] ; 
        }else{
            return targetIndices.size() ; 
        }

    }
};
",1420084806
sahilguptasg2017,sahilguptasg2017,404,3604,python3,"class Solution:
    def fVal(self, mod, x):
        fValarr = [1] * (x + 1)
        for i in range(1, x + 1):
            fValarr[i] = (fValarr[i - 1] * i) % mod
        return fValarr

    def comb(self, mod, x):
        combarr = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            combarr[i][0] = 1
            for j in range(1, i + 1):
                combarr[i][j] = (combarr[i - 1][j - 1] + combarr[i - 1][j]) % mod
        return combarr

    def sterling(self, mod, x, n):
        sterlingarr = [[0] * (x + 1) for _ in range(n + 1)]
        sterlingarr[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                sterlingarr[i][j] = (j * sterlingarr[i - 1][j] + sterlingarr[i - 1][j - 1]) % mod
        return sterlingarr

    def numberOfWays(self, n, x, y):
        mod = 10**9 + 7
        fvalarr = self.fVal(mod, x)
        combarr = self.comb(mod, x)
        sterlingarr = self.sterling(mod, x, n)
        ans = 0
        for i in range(1, x + 1):
            val = 1
            for j in range(i):
                val = (val * y) % mod
            ans = (ans + combarr[x][i] * sterlingarr[n][i] % mod * fvalarr[i] % mod * val % mod) % mod
        return ans
",1420125555
sahilguptasg2017,sahilguptasg2017,404,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int j = 0; j < nums.size(); j++) {
            bool flag = false;
            for(int i = 0; i <= 1000; i++) {
                if((i | (i + 1)) == nums[j]) {  
                    ans[j] = i;
                    flag = true;
                    break; 
                }
            }
            if(!flag) {
                ans[j] = -1; 
            }
        }

        return ans; 
    }
};
",1420003177
sahilguptasg2017,sahilguptasg2017,404,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        // for(int j = 0; j < nums.size(); j++) {
        //     bool flag = false;
        //     for(int i = 0; i <= nums[j]; i++) {
        //         if((i | (i + 1)) == nums[j]) {  
        //             ans[j] = i;
        //             flag = true;
        //             break; 
        //         }
        //     }
        //     if(!flag) {
        //         ans[j] = -1; 
        //     }
        // }
        for(int j = 0 ; j<nums.size() ; j++){
            bool flag = false ; 
            int arrans = 1e9 ; 
            for(int i = 0; i<= 30 ; i++){
                if( ((nums[j] >> i) & 1) == 1){
                    int val = nums[j] & ~(1 << i) ; 
                    if(val >= 0){
                        if(((val)|(val+1)) == nums[j]){
                            if(val < arrans){
                                arrans = val ; 
                                flag = true ; 
                            }
                        } 
                    } 
                }  
            }
            if(flag){
                ans[j] = arrans ;  
            }else{
                ans[j] = -1 ; 
            }

        }
        return ans ; 
    }
};",1420065058
pewlkit,pewlkit,405,3487,cpp,"class Solution {
public:
    int maxRemovals(const string& source, const string& pattern, const vector<int>& targetIndices) {
        int sourceLen = source.length();
        int patternLen = pattern.length();
        const int INF = numeric_limits<int>::max();
        vector<int> minDeletions(patternLen + 1, INF);
        minDeletions[0] = 0; 
        vector<bool> markedForRemoval(sourceLen, false);
        for (const int& idx : targetIndices) {
            markedForRemoval[idx] = true;
        }
        for (int i = 0; i < sourceLen; ++i) {
            for (int j = patternLen; j > 0; --j) {
                if (source[i] == pattern[j - 1] && minDeletions[j - 1] != INF) {
                    int cost = markedForRemoval[i] ? 1 : 0;
                    minDeletions[j] = min(minDeletions[j], minDeletions[j - 1] + cost);
                }
            }
        }
        int totalRemovals = targetIndices.size();
        return totalRemovals - (minDeletions[patternLen] == INF ? 0 : minDeletions[patternLen]);
    }
};
",1420099416
pewlkit,pewlkit,405,3604,cpp,"#include <vector>
#include <algorithm>

class Solution {
public:
    static constexpr int MODULUS = 1e9 + 7;
    // power with modular arithmetic
    int modularPower(int base, int exponent) {
        long long result = 1;
        long long currentBase = base;
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * currentBase) % MODULUS;
            }
            currentBase = (currentBase * currentBase) % MODULUS;
            exponent /= 2;
        }
        return static_cast<int>(result);
    }

    // i computed factorials up to the specified limit
    vector<int> factorialNikalo(int limit) {
        vector<int> factorialSena(limit + 1, 1);
        for (int i = 1; i <= limit; ++i) {
            factorialSena[i] = (1LL * factorialSena[i - 1] * i) % MODULUS;
        }
        return factorialSena;
    }
    vector<vector<int>> combGen(int maxSize) {
        vector<vector<int>> pascutrikon(maxSize + 1, vector<int>(maxSize + 1, 0));
        for (int i = 0; i <= maxSize; ++i) {
            pascutrikon[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                pascutrikon[i][j] = (pascutrikon[i - 1][j - 1] + pascutrikon[i - 1][j]) % MODULUS;
            }
        }
        return pascutrikon;
    }
    vector<vector<int>> partitionways(int n, int parts) {
        vector<vector<int>> partTable(n + 1, vector<int>(parts + 1, 0));
        partTable[0][0]= 1;
        for (int items= 1; items <= n; ++items) {
            for (int group= 1; group <= parts; ++group) {
                partTable[items][group]= (1LL * group * partTable[items - 1][group] + partTable[items - 1][group - 1]) % MODULUS;
            }
        }
        return partTable;
    }

    long long numberOfWays(int n, int x, int y) {
        // precomputed factorials up to x
        auto factorials= factorialNikalo(x);
        // i generated the combination table here
        auto combinations= combGen(x);
        // i created stirling-like partition table here
        auto partitionWays= partitionways(n, x);

        long long totalWays= 0;
        // iterate over different partition sizes
        for (int partitions= 1; partitions <= x; ++partitions) {
            // i am computing y^partitions modulo MODULUS
            int powerTerm= modularPower(y, partitions);
            // i am calculating the combination term in this step
            long long combinationProduct= (1LL * combinations[x][partitions] * partitionWays[n][partitions]) % MODULUS;
            // multiplying with factorial of partition size
            long long finalProduct= (combinationProduct * factorials[partitions]) % MODULUS;
            // adding to the total sum
            totalWays= (totalWays + finalProduct * powerTerm) % MODULUS;
        }
        return totalWays;
    }
};
",1420119393
pewlkit,pewlkit,405,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int it: nums){
            int found=-1;
            for (int i=0; i<=it; i++){
                if ((i | i+1) == it){
                    found=i;
                    break;
                }
            }
            ans.push_back(found);   
        }
        return ans;
    }
};",1420017131
pewlkit,pewlkit,405,3611,cpp,"#include <iostream>
#include <vector>
#include <limits>
#include <unordered_set>
#include <algorithm>

class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        auto isValidCandidate = [](int candidate, int original) {
            return (candidate | (candidate + 1)) == original;
        };

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = numeric_limits<int>::max();
            bool found = false;
            unordered_set<int> candidates; 
            for (int bit = 0; bit <= 30; bit++) {
                if ((num >> bit) & 1) { 
                    int candidate = num & ~(1 << bit);
                    if (candidate >= 0 && candidates.find(candidate) == candidates.end()) {
                        candidates.insert(candidate);
                        if (isValidCandidate(candidate, num)) {
                            if (candidate < minimalAns) {
                                minimalAns = candidate;
                                found = true;
                            }
                        }
                    }
                }
            }

            ans[i] = found ? minimalAns : -1; 
        }

        return ans;
    }
};

",1420083165
Supratit Datta,Supratit_Datta,407,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& k) {
        int n = source.size();
        int m = pattern.size();
        vector<bool> flag(n, false);
        help(flag, k);
        vector<float> dp(m + 1, numeric_limits<float>::infinity());
        dp[0] = 0;
        computeDP(source, pattern, flag, dp, n, m);
        return help2(dp, k.size(), m);
    }

private:
    void help(vector<bool>& flag, const vector<int>& k) {
        for (int idx : k) {
            flag[idx] = true;
        }
    }

    void computeDP(const string& source, const string& pattern,
                   const vector<bool>& flag, vector<float>& dp, int n,
                   int m) {
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] &&
                    dp[j - 1] != numeric_limits<float>::infinity()) {
                    dp[j] = min(dp[j], dp[j - 1] + (flag[i] ? 1 : 0));
                }
            }
        }
    }

    int help2(const vector<float>& dp, int x, int m) {
        return x - (dp[m] == numeric_limits<float>::infinity() ? 0 : dp[m]);
    }
};",1420103622
Supratit Datta,Supratit_Datta,407,3604,cpp,"class Solution {
public:
    const long long int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long int>> C = sol3(x);
        vector<vector<long long int>> S = sol1(n, x);
        vector<long long int> fact = sol2(x);

        long long int ans = 0;

        for (long long int k = 1; k <= x; ++k) {
            long long int power = modPower(y, k, MOD);
            ans = (ans + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return ans;
    }

private:
    vector<vector<long long int>> sol3(long long int x) {
        vector<vector<long long int>> C(x + 1, vector<long long int>(x + 1, 0));
        for (long long int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (long long int j = 1; j <= i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        return C;
    }

    vector<vector<long long int>> sol1(long long int n, long long int x) {
        vector<vector<long long int>> S(n + 1, vector<long long int>(x + 1, 0));
        S[0][0] = 1;
        for (long long int i = 1; i <= n; ++i) {
            for (long long int j = 1; j <= x; ++j) {
                S[i][j] = (j*S[i-1][j] + S[i-1][j-1]) % MOD;
            }
        }
        return S;
    }
    vector<long long int> sol2(long long int x) {
        vector<long long int> fact(x + 1, 1);
        for (long long int i = 1; i <= x; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    long long int modPower(long long int i, long long int exp, long long int mod) {
        long long int ans = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                ans = (ans * i) % mod;
            }
            i = (i*i) % mod;
            exp /= 2;
        }
        return ans;
    }
};",1420119862
Supratit Datta,Supratit_Datta,407,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; ++i) {
            for (int j = 1; j <= 1000; ++j) {
                if ((j | j+1) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420013340
Supratit Datta,Supratit_Datta,407,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] != 2) {
                int val = nums[i];
                int k = 0;
                int bit = 0;
                while (bit < 32) {
                    if (val & (1 << bit)) {
                        k = bit;
                    } 
                    else {
                        break;
                    }
                    bit++;
                }
                
                ans[i] = val - (1 << k);
            }
        }

        return ans;
    }
};",1420083004
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;  
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        int ans=0;
        for(int t=0;t<100;t++)
        {
            if(t%2==0) ans=ans;
            else ans=ans;
        }
        int dup=ans+ans;
        ans=ans/2;
        for (int i = 0; i < n; ++i) {
            
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        ans=0;
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420120146
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3604,cpp,"
int MOD = 1e9 + 7;
class Solution {
public:

    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<long long>> C(x + 1, std::vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        std::vector<std::vector<long long>> S(n + 1, std::vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        int ans=0;
        for(int i=0;i<100;i++)
        {
            if(i%2==0)
            {
                if(i) ans=ans;
            }
            else 
            {
                if(1==2) ans=1;
                else ans=2;
            }
        }
        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        ans=result;
        return ans;
    }
};
",1420126590
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        
        for(int i=0;i<n;i++)
        {
            
            bool found=false;
            for(int j=0;j<nums[i];j++)
            {
                if((j|(j+1))==nums[i]) 
                {
                    ans[i]=j;
                    found=true;
                    break;
                }
            }
            if(!found) ans[i]=-1;

        }
        return ans;
    }
};",1420004628
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
     int n=nums.size();
        
        vector<int> ans(n);
        
        //look for the first encounter of zero and then remove the necessary values
        
        for(int i=0;i<n;i++)
        {
            int curr=nums[i];
            
            if(curr==2) 
            {
                ans[i]=-1;
            }
            else 
            {
                int pos=-1;
                for(int j=0;j<32;j++)
                {
                    if(((curr>>j)&1)==0)
                    {
                        pos=j;
                        break;
                    }
                }
                ans[i]=curr-(1<<(pos-1));
            }

        }
        return ans;
    }
};",1420048081
Sahil Kumar,user2672IT,409,3487,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int n,m;
    int solve(int idx1,int idx2, vector<int> &vis, string &s, string &pat){
        if(idx1==n){
           if(idx2==m){
               return 0;
           }else{
               return -1e9;
           }  
        }
      
       int ans=-1e9;
       if(dp[idx1][idx2]!=-1)return dp[idx1][idx2];
    
       if(s[idx1]==pat[idx2]){
           ans=max(ans,solve(idx1+1,idx2+1,vis,s,pat));
       }
    
       ans=max(ans,solve(idx1+1,idx2,vis,s,pat)+vis[idx1]);
        
       return dp[idx1][idx2]=ans;
    }
    int maxRemovals(string s, string pat, vector<int>& tar) {
        n=s.size();
        m=pat.size();
        vector<int> vis(n);
        int q=tar.size();
        for(int i=0;i<q;i++){
           vis[tar[i]]=1;
        }
        dp=vector<vector<int>>(n+1,vector<int>(m+1,-1));
        
        int ans=solve(0,0,vis,s,pat);
        return ans;
    }
};",1420037416
Sahil Kumar,user2672IT,409,3604,cpp,"class Solution {
public:
        long long binpow(long long a, long long b, long long m) {
        a %= m;
        long long res = 1;
        while (b > 0) {
            if (b & 1)
                res = res * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return res;
        }

    
    int numberOfWays(int n, int x, int y) {
        long long m=1e9+7;
        const int maxn = n+x;
        long long C[maxn + 1][maxn + 1];
        C[0][0] = 1;
        for (int n = 1; n <= maxn; ++n) {
            C[n][0] = C[n][n] = 1;
            for (int k = 1; k < n; ++k){
                C[n][k] = C[n - 1][k - 1] + C[n - 1][k];
                C[n][k]%=m;
            }
        }
        long long ans=0;
        for(long long i=1;i<=min(n,x);i++){
            
            long long res=C[x][i]%m;
            long long temp=0;
        
            for(long long j=0;j<=i;j++){
                if(j%2==0)
                temp+=(C[i][j]*binpow(i-j,n,m))%m;
                else
                 temp-=(C[i][j]*binpow(i-j,n,m))%m;
                temp%=m;
                temp+=m;
                temp%=m;
            }
            res=res*temp%m;
            res=res*binpow(y,i,m)%m;
            // cout<<res<<endl;
            ans+=res;
            ans%=m;
            
             
        }
        
        return ans;

    }
};",1420113795
Sahil Kumar,user2672IT,409,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2){
                int pow=1;
                int no=0;
                int temp=nums[i];
                while(temp%2){
                    no+=pow;
                    temp/=2;
                    pow*=2;
                }
                
                ans[i]=nums[i]-no+no/2;
            }
            else{
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420008846
Sahil Kumar,user2672IT,409,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2){
                int pow=1;
                int no=0;
                int temp=nums[i];
                while(temp%2){
                    no+=pow;
                    temp/=2;
                    pow*=2;
                }
                
                ans[i]=nums[i]-no+no/2;
            }
            else{
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420009570
Bernd,__Bernd__,410,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        # grid(i, j) = # of target_indices we need to find pattern[:i] in source[:j]

        is_target = [False for _ in source]
        for j in targetIndices:
            is_target[j] = True

        grid = {}

        for j in range(len(source)+1):
            grid[(0, j)] = 0

        for i in range(1, len(pattern)+1):
            grid[(i, 0)] = len(source)  # impossible
            for j in range(1, len(source)+1):
                if pattern[i-1] != source[j-1]:
                    grid[(i, j)] = grid[(i, j-1)]
                    continue
                
                if is_target[j-1]:
                    grid[(i, j)] = min(grid[(i, j-1)], 1+grid[(i-1, j-1)])
                else:
                    grid[(i, j)] = min(grid[(i, j-1)], grid[(i-1, j-1)])

        # print(grid)
        return len(targetIndices) - grid[(len(pattern), len(source))]
        

s = Solution()
assert s.maxRemovals(source = ""abbaa"", pattern = ""aba"", targetIndices = [0,1,2]) == 1
assert s.maxRemovals(source = ""bcda"", pattern = ""d"", targetIndices = [0,3]) == 2
assert s.maxRemovals(source = ""dda"", pattern = ""dda"", targetIndices = [0,1,2]) == 0
assert s.maxRemovals(source = ""yeyeykyded"", pattern = ""yeyyd"", targetIndices = [0,2,3,4]) == 2

",1420120300
Bernd,__Bernd__,410,3604,python3,"
from math import comb

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        solution = 0
        cache = {}
        for stages_used in range(1, x+1):
            assginment_counts = get_possible_assignments(n, stages_used, cache) % (10**9 + 7)
            scoring_counts = mod_pow(y, stages_used, 10**9 + 7) % (10**9 + 7)
            stage_selection_counts = comb(x, stages_used) % (10**9 + 7)
            # solution += s * mod_pow(y, stages_used, 10**9 + 7) % (10**9 + 7)
            solution += assginment_counts * scoring_counts * stage_selection_counts % (10**9 + 7)
            # print(stages_used, solution)
        return solution % (10**9 + 7)


def mod_pow(b, exp, mod_nr):
    if exp == 1:
        return b % mod_nr
    
    sqrt = mod_pow(b, exp//2, mod_nr)
    n = sqrt * sqrt % mod_nr
    if exp % 2 == 1:
        n = n * b % mod_nr
    return n
            

assert mod_pow(3, 8, 10**9) == 3**8
assert mod_pow(5, 2, 10) == 5


def get_possible_assignments(n, k, cache={}):
    if (n, k) in cache:
        return cache[(n, k)]

    if n < k:
        return 0

    if k == 1:
        return 1

    first_alone = k * get_possible_assignments(n-1, k-1, cache)
    first_with_others = k * get_possible_assignments(n-1, k, cache)
    s = first_alone + first_with_others
    cache[(n, k)] = s
    # print(n, k, s)
    return s


assert get_possible_assignments(1, 7) == 0
assert get_possible_assignments(7, 1) == 1
assert get_possible_assignments(5, 2) == 2**5 - 2



s = Solution()
assert s.numberOfWays(1, 2, 3) == 6
assert s.numberOfWays(5, 2, 1) == 32
assert s.numberOfWays(3, 3, 4) == 684
assert s.numberOfWays(6, 7, 7) == 365896700

print(s.numberOfWays(958, 744, 829))",1420064087
Bernd,__Bernd__,410,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        f_inv = {}
        for i in range(1000):
            fi = i | (i+1)
            if fi not in f_inv.keys():
                f_inv[fi] = i
        
        return [f_inv.get(n, -1) for n in nums]


s = Solution()
assert s.minBitwiseArray([2,3,5,7]) == [-1,1,4,3]
assert s.minBitwiseArray([11,13,31]) == [9,12,15]
    
        ",1420009022
Bernd,__Bernd__,410,3611,python3,"# class Solution:
#     def minBitwiseArray(self, nums: List[int]) -> List[int]:
#         f_inv = {}
#         for i in range(1000):
#             fi = i | (i+1)
#             if fi not in f_inv.keys():
#                 f_inv[fi] = i
        
#         return [f_inv.get(n, -1) for n in nums]

    

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [solve(n) for n in nums]
        

def solve(n):
    n_bin_str = ""{0:b}"".format(n)
    n = [s for s in n_bin_str]
    r = list(reversed(n))

    leading_one_count = 0
    for d in r:
        if d == ""1"":
            leading_one_count += 1
        else:
            break
    
    if leading_one_count == 0:  # even number
        return -1

    solution = n[:len(n)-leading_one_count] + [""0""] + [""1""] * (leading_one_count - 1)
    solution = """".join(solution)
    return int(solution, 2)


s = Solution()
assert s.minBitwiseArray([2,3,5,7]) == [-1,1,4,3]
assert s.minBitwiseArray([11,13,31]) == [9,12,15]

",1420085871
Aftab Alam,alam_tech,411,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
    int n = source.length();
    int m = pattern.length();
    int[] dp = new int[m + 1];
    boolean[] isTarget = new boolean[n];
    
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    
    for (int idx : targetIndices) {
        isTarget[idx] = true;
    }
    
    fillDpArray(source, pattern, dp, isTarget);
    
    return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
}

private void fillDpArray(String source, String pattern, int[] dp, boolean[] isTarget) {
    int n = source.length();
    int m = pattern.length();
    
    for (int i = 0; i < n; i++) {
        for (int j = m; j > 0; j--) {
            if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
        }
    }
}
}",1420062045
Aftab Alam,alam_tech,411,3604,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int MOD = 1e9 + 7;

    vector<vector<int>> initializeCombination(int x) {
        vector<vector<int>> C(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            int j = 1;
            while (j <= i) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
                j++;
            }
        }
        return C;
    }

    vector<vector<int>> initializeStirling(int n, int x) {
        vector<vector<int>> S(n + 1, vector<int>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    vector<int> initializeFactorial(int x) {
        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = 1LL * fact[i - 1] * i % MOD;
        }
        return fact;
    }

    long long computePower(int y, int k) {
        long long power = 1;
        int p = 0;
        while (p < k) {
            power = (power * y) % MOD;
            p++;
        }
        return power;
    }

    long long computeResult(const vector<vector<int>>& C, const vector<vector<int>>& S, const vector<int>& fact, int n, int x, int y) {
        long long result = 0;
        for (int k = 1; k <= x; k++) {
            long long power = computePower(y, k);
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> C = initializeCombination(x);
        vector<vector<int>> S = initializeStirling(n, x);
        vector<int> fact = initializeFactorial(x);
        return computeResult(C, S, fact, n, x, y);
    }
};
",1420101590
Aftab Alam,alam_tech,411,3605,cpp,"class Solution {
public:
    bool checkCondition(int value, int num) {
    return (value | (value + 1)) == num;
}

vector<int> minBitwiseArray(vector<int>& nums) {
    int size = nums.size();
    vector<int> result(size, -1);  // Initialize result with -1

    // Iterate over each element in the nums array
    for (int idx = 0; idx < size; idx++) {
        // Try all possible values for result[idx]
        for (int candidate = 0; candidate <= nums[idx]; candidate++) {
            if (checkCondition(candidate, nums[idx])) {
                result[idx] = candidate;
                break;  // Stop when the smallest valid candidate is found
            }
        }
    }

    return result;
}
};",1420010821
Aftab Alam,alam_tech,411,3611,java,"class Solution {
      public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (isBitSet(num, bit)) {
                    int candidate = unsetBit(num, bit);
                    
                    if (candidate < 0) continue;
                    
                    if (isValidCandidate(num, candidate)) {
                        minimalAns = Math.min(minimalAns, candidate);
                        found = true;
                    }
                }
            }
            
            ans[i] = found ? minimalAns : -1;
        }
        
        return ans;
    }

    private boolean isBitSet(int num, int bit) {
        return ((num >> bit) & 1) == 1;
    }

    private int unsetBit(int num, int bit) {
        return num & ~(1 << bit);
    }

    private boolean isValidCandidate(int num, int candidate) {
        return (candidate | (candidate + 1)) == num;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        List<Integer> nums = Arrays.asList(15, 7, 1);
        System.out.println(Arrays.toString(sol.minBitwiseArray(nums)));
    }
}",1420053971
Suyash Khare,sk9698,412,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string s, std::string p, std::vector<int>& a) {
        std::vector<int> dp(p.size() + 1, INT_MAX);
        dp[0] = 0;  // Initialize dp[0] to 0
        std::vector<int> vis(s.size(), 0); // Initialize visibility vector

        // Mark the target indices
        for (int e : a) {
            vis[e] = 1;
        }

        for (int i = 0; i < s.size(); i++) {
            for (int j = p.size(); j > 0; j--) {
                if (dp[j - 1] == INT_MAX) {
                    continue; // No valid previous state
                }
                if (s[i] == p[j - 1]) {
                    int val = vis[i]; // Use vis[i] directly since it is either 0 or 1
                    dp[j] = std::min(dp[j], dp[j - 1] + val);
                }
            }
        }

        // Return the number of target indices minus the number of characters in pattern that can be matched
        return dp[p.size()] == INT_MAX ? 0 : a.size() - dp[p.size()];
    }
};
",1420076655
Suyash Khare,sk9698,412,3604,cpp,"#include <iostream>

using namespace std;

class Solution {
public:
    long long mod = 1e9 + 7;

    void preCompute(int x, long long* f) {
        for (int i = 0; i <= x; i++) {
            if(i == 0) f[i] = 1;
            else f[i] = (f[i - 1] * i) % mod;
        }
    }

    long long numberOfWays(int n, int x, int y) {
        long long ans = 0;

        long long* f = new long long[x + 1];
        preCompute(x, f);

        long long** dp = new long long*[x + 1];
        for (int i = 0; i <= x; i++) {
            dp[i] = new long long[x + 1]{0};
        }

        long long** dp2 = new long long*[n + 1];
        for (int i = 0; i <= n; i++) {
            dp2[i] = new long long[x + 1]{0};
        }

        for (int i = 0; i <= x; i++) {
            dp[i][0] = 1;
        }

        dp2[0][0] = 1;

        for (int i = 1; i <= x; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod;
            }
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                dp2[i][j] = (j * dp2[i - 1][j] + dp2[i - 1][j - 1]) % mod;
            }
        }

        

        for (int i = 1; i <= x; i++) {
            long long here = 1;
            for (int j = 0; j < i; j++) {
                here = (here * y) % mod;
            }

            long long product = (dp[x][i] * dp2[n][i]) % mod;
            long long multiplyWithFactorial = (product * f[i]) % mod;
            long long fin = (multiplyWithFactorial * here) % mod;

            ans = (ans + fin) % mod;
        }

        return ans;
    }
};
",1420120892
Suyash Khare,sk9698,412,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        std::vector<int> ans;

        for (int prime : nums) {
            int found = -1;  // Default to -1 if no valid ans[i] is found
            for (int x = 0; x < prime; ++x) {
                if ((x | (x + 1)) == prime) {
                    found = x;  // Update found if valid
                    break;      // Break out of the loop as we found the minimum
                }
            }
            ans.push_back(found);  // Add the found value (or -1) to ans
        }

        return ans;  // Return the constructed ans vector
    }
};",1419993523
Suyash Khare,sk9698,412,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for(int i=0;i<a.size();i++){
            int mini=INT_MAX;
            for(int j=0;j<=30;j++){
                int bit = (a[i] >> j) & 1;
                if(bit==1){
                    int x=a[i] & ~(1 << j);
                    if(x>=0){
                        if((x | (x+1)) == a[i]){
                            
                            mini=min(mini,x);
                            
                        }
                        
                    }
                    }
                }
                if(mini==INT_MAX) ans.push_back(-1);
                else ans.push_back(mini);
            }

            return ans;
        }
    
};

",1420047651
metaphysicalist,metaphysicalist,413,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        removable = set(targetIndices)
        
        @cache
        def dp(i, j):
            if i >= n:
                if j == m:
                    return 0
                return -inf
            r = -inf
            if i in removable:
                r = max(r, dp(i+1, j) + 1)
            if j < m and source[i] == pattern[j]:
                r = max(r, dp(i+1, j+1))
            else:
                r = max(r, dp(i+1, j))
            return r
        ans = dp(0, 0)
        dp.cache_clear()
        return dp(0, 0)
",1420076388
metaphysicalist,metaphysicalist,413,3604,python3,"@cache
def dp(i, j, k):
    if i == 0:
        if j > 1 or k == 0:
            return 0
        return 1
    
    ans = 0
    if k > 0:
        ans = dp(i, j - 1, 0)
    ans += dp(i-1, j, k+1)
    return ans % 1000000007

@cache
def foo(n, m):
    if n < 0 or m < 0:
        return 0
    if m > n:
        return 0
    if n == 0:
        return 1
    return foo(n-1, m-1) + m * foo(n-1, m)

@cache
def frac(n):
    if n == 0:
        return 1
    return (n * frac(n-1)) % 1000000007

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:        
        MOD = 1000000007
        ans = 0
        for band in range(1, x+1):
            if band > n:
                break
            # print(n, band, foo(n, band))
            a = comb(x, band) * (frac(band) * foo(n, band) * pow(y, band, MOD)) % MOD
            # print(a)
            ans = (ans + a) % MOD
        return ans
        ",1420121852
metaphysicalist,metaphysicalist,413,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for v in nums:
            ans.append(-1)
            for a in range(0, v+1):
                if a | (a+1) == v:
                    ans[-1] = a 
                    break
        return ans",1420000090
metaphysicalist,metaphysicalist,413,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def solve(v):
            if v == 2:
                return -1
            s = '0' + bin(v)[2:]
            n = len(s)
            for i in range(n-2, -1, -1):
                if s[i] == '0':
                    lower = s[:i+1] + '0' + ('1' * (n-i-2))

                    # print(v, lower)
                    return int(lower, 2)
            
            return -1

        ans = []
        for v in nums:
            ans.append(solve(v))
        return ans
        ",1420050381
Shivam Aryan,ultraaryan10,417,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& idx) {
        int n = s.size(), m = p.size();
        constexpr int inf = 1e9;
        vector<int> dp(m + 1, inf); dp[0] = 0;
        set<int> t(idx.begin(), idx.end());
        for (int i = 0; i < n; i++) {
            for (int j = m - 1; j >= 0; j--) {
                if (s[i] == p[j] and dp[j] != inf)
                    dp[j+1] = min(dp[j+1], dp[j] + (int)t.count(i));
            }
        }
        if (dp[m] == inf) dp[m] = 0; 
        return t.size() - dp[m];
    }
};",1420095201
Shivam Aryan,ultraaryan10,417,3604,cpp,"class Solution {
    static constexpr int MOD = 1e9 + 7;

    static long long power(long long x, long long y, long long m = MOD) {
        long long res = 1;
        while (y > 0) {
            if (y & 1)
                res = (res * x) % m;
            y = y >> 1;
            x = (x * x) % m;
        }
        return res % m;
    }

    class Combinatorics {
        long long maxn;
    public:
        vector<long long> factorial;
        vector<long long> inverse_factorial;

        Combinatorics(long long maxn) : maxn(maxn), factorial(maxn), inverse_factorial(maxn) {
            factorial[0] = 1;
            inverse_factorial[0] = 1;
            for (long long i = 1; i < maxn; ++i) {
                factorial[i] = (factorial[i - 1] * i) % MOD;
                inverse_factorial[i] = power(factorial[i], MOD - 2) % MOD;
            }
        }
        Combinatorics() : Combinatorics(1e4 + 1) {};

        long long nCr(long long n, long long r) {
            if (r > n || r < 0) return 0;
            long long numerator = factorial[n] % MOD;
            long long denominator = (inverse_factorial[r] * inverse_factorial[n - r]) % MOD;
            return (numerator * denominator) % MOD;
        }
    };
public:
    Combinatorics math;
    
    Solution() : math(1e4) {}

    int numberOfWays(int n, int x, int y) {
        long long ans = 0;
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
            }
        }
        for (int k = 1; k <= x; k++) {
            ans = (ans + math.nCr(x, k) * S[n][k] % MOD * math.factorial[k] % MOD * power(y, k) % MOD) % MOD;
        }
        return ans;
    }
};
",1420123254
Shivam Aryan,ultraaryan10,417,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            for (int j = 0; j <= i; j++) {
                if ((j | (j + 1)) == i) {
                    ans.push_back(j);
                    goto next;
                }
            }
            ans.push_back(-1);
            next:;
        }
        return ans;
    }
};",1419999115
Shivam Aryan,ultraaryan10,417,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) ans.push_back(-1);
            else {
                bitset<32> b(i);
                int start = 0;
                while (b[start] == 1) start++;
                start--;
                b[start] = 0;
                ans.push_back(b.to_ullong());
            }
        }
        return ans;
    }
};
",1420019324
Nilesh Kumar Nayak,nileshnayak656854,418,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
       int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        boolean[] isTarget = new boolean[n];

        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]); 
    }
}",1420056315
Nilesh Kumar Nayak,nileshnayak656854,418,3604,java,"class Solution {
     private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[][] comb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        int[][] stirling = new int[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (int) ((1L * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD);
            }
        }

        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int i = 0; i < k; i++) {
                yPow = (yPow * y) % MOD;
            }
            totalWays = (totalWays + (1L * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD)) % MOD;
        }

        return (int) totalWays;
    }
}",1420098188
Nilesh Kumar Nayak,nileshnayak656854,418,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            ans[i] = -1;
            for (int x = 0; x <= nums.get(i); x++) {
                if ((x | (x + 1)) == nums.get(i)) {
                    ans[i] = x;
                    break;
                }
            }
        }

        return ans; 
    }
}",1420018047
Nilesh Kumar Nayak,nileshnayak656854,418,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {

                    int candidate = num & ~(1 << bit);

                    if (candidate < 0)
                        continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
}",1420042260
ANUJ SINGH RANA,Aunj07,419,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420061805
ANUJ SINGH RANA,Aunj07,419,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420111381
ANUJ SINGH RANA,Aunj07,419,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420007572
ANUJ SINGH RANA,Aunj07,419,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420045297
VASU_FXLEI_14,VASU_FXLEI_14,420,3487,cpp,"class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& indi) {
        int n = source.size();
        int m = pattern.size();
        std::vector<int> open(m + 1, INT_MAX);
        open[0] = 0;
        std::vector<bool> tgt(n, false);
        
        for (int idx : indi) {
            tgt[idx] = true;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && open[j - 1] != INT_MAX) {
                    open[j] = std::min(open[j], open[j - 1] + (tgt[i] ? 1 : 0));
                }
            }
        }
        
        return indi.size() - (open[m] == INT_MAX ? 0 : open[m]);
    }
};
",1420124237
VASU_FXLEI_14,VASU_FXLEI_14,420,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> combination(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stir(n + 1, std::vector<int>(x + 1, 0));
        stir[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stir[i][j] = (1LL * j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> facto(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            facto[i] = (1LL * facto[i - 1] * i) % MOD;
        }
        long long tota = 0;
        for (int k = 1; k <= x; ++k) {
            long long ypower = 1;
            for (int i = 0; i < k; ++i) {
                ypower = (ypower * y) % MOD;
            }
            tota = (tota + (1LL * combination[x][k] * stir[n][k] % MOD * facto[k] % MOD * ypower % MOD)) % MOD;
        }
        return tota;
    }
};",1420105582
VASU_FXLEI_14,VASU_FXLEI_14,420,3605,cpp,"class Solution {
public:
    int find(int prime) {
        for (int x = 1; x <= prime; ++x) {
            if ((x | (x + 1)) == prime) {
                return x;
            }
        }
        return -1;  
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> sol(n, -1);  

        for (int i = 0; i < n; ++i) {
            sol[i] = find(nums[i]);  
        }

        return sol;
    }
};",1420025329
VASU_FXLEI_14,VASU_FXLEI_14,420,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] answer = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int mini = Integer.MAX_VALUE;
            boolean pop = false;
            
           
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                 
                    int cop = num & ~(1 << bit);
                    
                 
                    if (cop < 0) continue;
                    
                 
                    if ((cop | (cop + 1)) == num) {
                        if (cop < mini) {
                            mini = cop;
                            pop = true;
                        }
                    }
                }
            }
            
            if (pop) {
                answer[i] = mini;
            } else {
                answer[i] = -1;
            }
        }
        
        return answer;
    }
}
",1420045588
Vamsi Gudimetla,G_vamsi,421,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();  
        int m = pattern.size();  
        vector<int> dp(m + 1, INT_MAX);  
        dp[0] = 0;  
        
        vector<bool> Target(n, false);  
        for (int J: targetIndices) {  
            Target[J] = true;  
        }  
        for (int iV = 0; iV < n; ++iV) {  
            for (int jX = m; jX >= 1; --jX) {  
                if (source[iV] == pattern[jX - 1] && dp[jX - 1] != INT_MAX) {  
                    dp[jX] = min(dp[jX], dp[jX - 1] + (Target[iV] ? 1 : 0));  
                }  
            }  
        }  
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);  
 
    }
};",1420124270
Vamsi Gudimetla,G_vamsi,421,3604,cpp,"class Solution {
public:
const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
         vector<vector<int>> com(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            com[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                com[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> sti(n + 1, vector<int>(x + 1, 0));
        sti[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                sti[i][j] = (1LL * j * sti[i - 1][j] + sti[i - 1][j - 1]) % MOD;
            }
        }
        vector<int> factor(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factor[i] = (1LL * factor[i - 1] * i) % MOD;
        }
        long long total = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total = (total + (1LL * com[x][k] * sti[n][k] % MOD * factor[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total; 
    }
};",1420119032
Vamsi Gudimetla,G_vamsi,421,3605,cpp,"class Solution {
public:
  int check(int x)
  {
    for(int i=1;i<x;i++)
    {
      if((i|i+1)==x)
       return i;

    }
    return -1;
  }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
       for(int i=0;i<nums.size();i++)
       {
        int req=check(nums[i]);
        if(req==-1)
        ans[i]=-1;
        else
        ans[i]=req;
       } 
       return ans;
    }
};",1420015212
Vamsi Gudimetla,G_vamsi,421,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
          int n = nums.size();
        vector<int>ans(n);
         for (int i = 0; i < n; i++) {
            int num = nums[i];
            int mini = INT_MAX;
            bool found = false;
            for (int bit = 0; bit <= 30; bit++) {
                if ((num >> bit) & 1) {
                    // Unset the current bit
                    int c = num & ~(1 << bit);

                    // Ensure candidate is non-negative
                    if (c< 0) continue;
                    if ((c | (c + 1)) == num) {
                        if (c < mini) {
                            mini = c;
                            found = true;
                        }
                    }
                }
            }
                 if (found) {
                ans[i] = mini;
            } else {
                ans[i] = -1;
            }
        }
        return ans;

    }
};",1420062961
Aman Dubey,its_me_ami_12,422,3487,java,"class Solution {
    // Aman
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
       int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        
       
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; 

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

      
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420076679
Aman Dubey,its_me_ami_12,422,3604,java,"
class Solution {
    //Aman
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] p = {n, x, y};
        while (p != null) {
            break;
        }

        
        long[][] c = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            c[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

       
        long[][] s = new long[n + 1][x + 1];
        s[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                s[i][j] = (j * s[i - 1][j] % MOD + s[i - 1][j - 1]) % MOD;
            }
        }

        
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = modPow(y, k, MOD);
            totalWays = (totalWays + c[x][k] * s[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }
    private long modPow(int base, int exp, int mod) {
        long result = 1;
        long b = base % mod;
        while (exp > 0) {
            if ((exp & 1) == 1) { 
                result = (result * b) % mod;
            }
            b = (b * b) % mod; 
            exp >>= 1;
        }
        return result;
    }
}
",1420098687
Aman Dubey,its_me_ami_12,422,3605,java,"class Solution {
    // Aman
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
    
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            
            for (int j = 0; j <= num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
            
        
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1419994629
Aman Dubey,its_me_ami_12,422,3611,java,"
// Aman
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                res[i] = minimalAns;
            } else {
                res[i] = -1;
            }
        }
        
        return res;
    }
}",1420084842
Kotte Pravallika,pravallika_kotte,423,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(), m = p.size();
        vector<int> dp(m+1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isT(n, false);
        for(int idx : t) isT[idx] = true;

        for(int i = 0; i <n; ++i){
            for(int j = m; j > 0; --j){
                if(s[i] == p[j -1] && dp[j-1] != numeric_limits<int>::max()){
                    dp[j] = min(dp[j], dp[j-1] + (isT[i] ? 1 : 0));
                }
            }
        }

        return t.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420064659
Kotte Pravallika,pravallika_kotte,423,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {

        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        std::vector<std::vector<int>> stirling(n + 1,
                                               std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] =
                    (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) %
                    MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways =
                (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD *
                               factorial[k] % MOD * y_pow % MOD)) %
                MOD;
        }
        return total_ways;
    }
};
",1420118412
Kotte Pravallika,pravallika_kotte,423,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector <int> ans(n, -1);
        for(int i = 0; i <n; i++){
            int h = nums[i];
            for(int x = 0; x <= h; x++){
                if((x|(x+1)) == h){
                    ans[i] = x;
                    break;
                }
            }
        }
        
        for(int i = 0; i < n; ++i){
            if(ans[i] == -1){
                ans[i] = -1;
            }
        }
        return ans;
    }
};",1420025720
Kotte Pravallika,pravallika_kotte,423,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for(int i = 0; i < n; i++){
            int h = nums[i];
            int minAns = numeric_limits<int>::max();
            bool found = false;
            
            for(int t = 0; t <= 30; t++){
                if((h >> t) & 1){
                    int can = h & ~(1 << t);
                    if ((can | (can + 1)) == h) {
                        if (can < minAns) {
                            minAns = can;
                            found = true;
                        }
                    }
                }
            }

            if (found){
                ans[i] = minAns;
            } else {
                ans[i] = -1;
            }
        }
        return ans;
    }
};",1420049780
Vaid Aaryan,cool_coder_007,425,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e7;
// const int MAXN=1e4,N=2e7+1;






class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.length();
       
        int m=pattern.length();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-inf));
        vector<char> a(n+1),b(m+1);
        f(i,0,n) a[i+1]=source[i];
        f(i,0,m) b[i+1]=pattern[i];
        unordered_map<int,int> hsh;
        for(int i=0;i<targetIndices.size();i++) hsh[targetIndices[i]+1]=1;
        dp[0][0]=0;
        for(int i=1;i<=n;i++){
            dp[i][0]=dp[i-1][0];
            if(hsh.find(i)!=hsh.end()) dp[i][0]++;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(a[i]==b[j]){
                    // if(i==4)
                    dp[i][j]=max(dp[i-1][j-1],dp[i][j]);
                    if(hsh.find(i)!=hsh.end())
                    dp[i][j]=max(dp[i][j],dp[i-1][j]+1);
                    else dp[i][j]=max(dp[i][j],dp[i-1][j]);
                }
                else{
                    // if(i==4 && j==2) cout<<69<<endl;
                    int found=(hsh.find(i)!=hsh.end());
                //    if(i==4 && j==2) cout<<found<<endl;
                    dp[i][j]=max(dp[i][j],dp[i-1][j]+found);
                }
            }
        }
        int ans=dp[n][m];
        // for(int i=1;i<=n;i++){
        //     for(int j=1;j<=m;j++){
        //         if(dp[i][j]<0) dp[i][j]=-1;
        //         cout<<dp[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }
        return ans;

    }
};",1420078482
Vaid Aaryan,cool_coder_007,425,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e7;
// const int MAXN=1e4,N=2e7+1;

ll fact[1001];


class Solution {
public:
  

    ll calc(ll n,ll r){
        if(r<0 || n<0) return 0;
        if(r>n) return 0;
        if(r==0 || n==0) return 1;
        ll num=fact[n];
        ll den=fact[r];
        den=(fact[r]*fact[n-r])%mod;
        num=(num*modinv(den,mod))%mod;
        return num;
    }
    int numberOfWays(int n, int x, int y) {
        ll ans=0;
        vector<vector<ll>> dp(n+1,vector<ll>(x+1,-1));//n distinct performers to x stages
        fact[0]=1;
        for(ll i=1;i<=(max(x,n));i++){
            fact[i]=(fact[i-1]*i)%mod;
        }
        for(ll empty=0;empty<x;empty++){
            ll cur=calc(x,empty);
            ll sum=0;
            ll r=n;
            ll fill=x-empty;
            cout<<fill<<endl;
            if(fill>n) continue;
            // cout<<fill<<endl;
            // cout<<cur<<endl;
            // cout<<empty<<"" ""<<cur<<endl;
            for(ll i=0;i<=fill;i++){
                ll val1=calc(fill,i);
                val1=(val1*expo(fill-i,r,mod))%mod;
                // cout<<val1<<endl;
                if(i%2) sum=(sum-val1+mod)%mod;
                else sum=(sum+val1)%mod;
            }
            cur=(cur*sum)%mod;
            ll num1=expo(y,fill,mod);
            cur=(cur*num1)%mod;

            ans=(ans+cur)%mod;
        }
        ans=ans%mod;

        return ans;
        
    }
};",1420125031
Vaid Aaryan,cool_coder_007,425,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e18;
// const int MAXN=1e4,N=2e7+1;










class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        f(i,0,n){
            if(nums[i]==2 ) continue;
            // int val=-1;
            int sub=0;
            for(int bt=0;bt<31;bt++){
                int cur=(nums[i]>>bt)&1;
                // cout<<nums[i]<<"" ""<<cur<<endl;
                if(cur==0){
                    break;
                }
                else sub=1<<bt;
            }
            // cout<<sub<<endl;
            ans[i]=nums[i]-sub;
        }

        return ans;
        
    }
};

// int main(){
//     int n;
//     cin>>n;
//     vector<int> v(n);
//     f(i,0,n) cin>>v[i];
//     Solution s;
//     vector<int> ans=s.minBitwiseArray(v);
//     show(ans);cout<<endl;

// }",1420027152
Vaid Aaryan,cool_coder_007,425,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e18;
// const int MAXN=1e4,N=2e7+1;










class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        f(i,0,n){
            if(nums[i]==2 ) continue;
            // int val=-1;
            int sub=0;
            for(int bt=0;bt<31;bt++){
                int cur=(nums[i]>>bt)&1;
                // cout<<nums[i]<<"" ""<<cur<<endl;
                if(cur==0){
                    break;
                }
                else sub=1<<bt;
            }
            // cout<<sub<<endl;
            ans[i]=nums[i]-sub;
        }

        return ans;
        
    }
};

// int main(){
//     int n;
//     cin>>n;
//     vector<int> v(n);
//     f(i,0,n) cin>>v[i];
//     Solution s;
//     vector<int> ans=s.minBitwiseArray(v);
//     show(ans);cout<<endl;

// }",1420026851
Rohan Bansal,rohannbansal,426,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        length_source = len(source)
        length_pattern = len(pattern)
        removal_count = [float('inf')] * (length_pattern + 1)
        removal_count[0] = 0
        target_positions = [False] * length_source
        
        for position in targetIndices:
            target_positions[position] = True
        
        for char_index in range(length_source):
            for pattern_index in range(length_pattern, 0, -1):
                if source[char_index] == pattern[pattern_index - 1] and removal_count[pattern_index - 1] != float('inf'):
                    removal_count[pattern_index] = min(removal_count[pattern_index], removal_count[pattern_index - 1] + (1 if target_positions[char_index] else 0))
        
        return len(targetIndices) - (0 if removal_count[length_pattern] == float('inf') else removal_count[length_pattern])
",1420072849
Rohan Bansal,rohannbansal,426,3604,cpp,"class Solution {
public:
    static const int MOD_VALUE = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> combinations(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD_VALUE;
            }
        } 
        std::vector<std::vector<int>> stirlingNumbers(n + 1, std::vector<int>(x + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD_VALUE;
            }
        }
        std::vector<int> factorials(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD_VALUE;
        }
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long powerY = 1;
            for (int i = 0; i < k; ++i) {
                powerY = (powerY * y) % MOD_VALUE;
            }
            totalWays = (totalWays + (1LL * combinations[x][k] * stirlingNumbers[n][k] % MOD_VALUE * factorials[k] % MOD_VALUE * powerY % MOD_VALUE)) % MOD_VALUE;
        }
        return totalWays;
        
    }
};",1420106607
Rohan Bansal,rohannbansal,426,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        
        for num in nums:
            found = False
            for x in range(num):
                if (x | (x + 1)) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans",1420021323
Rohan Bansal,rohannbansal,426,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int size = nums.size();
        int[] result = new int[size];
        
        for (int index = 0; index < size; index++) {
            int currentNum = nums.get(index);
            int minimumValue = Integer.MAX_VALUE;
            boolean isFound = false;
            
            for (int position = 0; position <= 30; position++) {
                if (((currentNum >> position) & 1) == 1) {
                    int potentialCandidate = currentNum & ~(1 << position);
                    
                    if (potentialCandidate < 0) continue;
                    
                    if ((potentialCandidate | (potentialCandidate + 1)) == currentNum) {
                        if (potentialCandidate < minimumValue) {
                            minimumValue = potentialCandidate;
                            isFound = true;
                        }
                    }
                }
            }
            
            if (isFound) {
                result[index] = minimumValue;
            } else {
                result[index] = -1;
            }
        }
        
        return result;

    }
}",1420066403
ISHANIJ,ISHANIJ,427,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420068986
ISHANIJ,ISHANIJ,427,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420100157
ISHANIJ,ISHANIJ,427,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
       int len = arr.size();
        vector<int> result(len, -1);

        for (int i = 0; i < len; i++) {
            for (int x = 0; x <= arr[i]; x++) {
                if ((x | (x + 1)) == arr[i]) {
                    result[i] = x;
                    break;
                }
            }
        }

        return result; 
    }
};",1420009795
ISHANIJ,ISHANIJ,427,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
        
    }
}",1420060791
Sunny Kumar,sk_07singh,428,3487,python3,"import math
import sys
from typing import List
# Sunny kumar

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: list[int]) -> int:
        
        n = len(source)
        m = len(pattern)
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0  
      
        Target = [False] * n         # is Target
        
        for index in targetIndices:
            Target[index] = True
        
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if Target[i] else 0))
        
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

    

",1420125799
Sunny Kumar,sk_07singh,428,3604,python3,"import re
import math
import sys
# Sunny kumar

MOD = int(1e9 + 7)

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        combination = [[0] * (x + 1) for sunny in range(x + 1)]
        for i in range(x + 1):
            combination[i][0] = 1
            for j in range(1, i + 1):
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD

                
        stirling_Numbers = [[0] * (x + 1) for _ in range(n + 1)]
        stirling_Numbers[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling_Numbers[i][j] = (j * stirling_Numbers[i - 1][j] + stirling_Numbers[i - 1][j - 1]) % MOD

                
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = (factorial[i - 1] * i) % MOD

            
        total = 0
        for i in range(1, x + 1):
            powerMultiplier = pow(y, i, MOD)
            total = (total + combination[x][i] * stirling_Numbers[n][i] % MOD * factorial[i] % MOD * powerMultiplier % MOD) % MOD
        
        return total
    ",1420119632
Sunny Kumar,sk_07singh,428,3605,python3,"import math
# Sunny Kumar
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ansi = []
    
        for num in nums:
            found = False
        
            for ar in range(num):
                if ar | (ar + 1) == num:
                    ansi.append(ar)
                    found = True
                    break
        
            if not found:
                ansi.append(-1)
    
        return ansi
",1420017853
Sunny Kumar,sk_07singh,428,3611,python3,"import math
# Sunny Kumar
from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimal_ans = float('inf')  # Initialize with positive infinity
            found = False
            
            # Iterate through each bit position (0 to 30)
            for bit in range(31):
                if (num >> bit) & 1:  # Check if the bit is set
                    # Unset the current bit
                    candidate = num & ~(1 << bit)
                    
                    # Ensure candidate is non-negative
                    if candidate < 0:
                        continue
                    
                    # Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimal_ans:
                            minimal_ans = candidate
                            found = True
            
            if found:
                ans[i] = minimal_ans
            else:
                ans[i] = -1
        
        return ans",1420063360
Ayush Nautiyal,ayushnautiyal1110,429,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        
       int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, 1e9);
        dp[0] = 0;
        
        vector<int> f(n+1, 0);
        for (auto x : targetIndices) {
            f[x] = 1;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != 1e9) {
                    dp[j] = min(dp[j], dp[j - 1] + (f[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] ==1e9 ? 0 : dp[m]);
    }
};",1420123877
Ayush Nautiyal,ayushnautiyal1110,429,3604,cpp,"#include <vector>

class Solution {
private:
    const int MOD = 1000000007;

public:
    int numberOfWays(int n, int x, int y) {
        // No-op loop for consistency
        int params[] = {n, x, y};
        while (sizeof(params) > 0) {
            break;
        }

        // Combination array
        std::vector<std::vector<long long>> comb(x + 1, std::vector<long long>(x + 1));
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Stirling numbers array
        std::vector<std::vector<long long>> stirling(n + 1, std::vector<long long>(x + 1));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array
        std::vector<long long> factorial(x + 1);
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return static_cast<int>(totalWays);
    }
};
",1420125961
Ayush Nautiyal,ayushnautiyal1110,429,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans(nums.size(),1e9);
        int n=nums.size();
        for(int i=0;i<n;i++){
            vector<int>bit(32);
            for(int j=31;j>=0;j--){
                int no=(1<<j);
                if(no & nums[i]){
                    bit[j]++;
                }
            }
            int num=0;
            for(int j=31;j>=0;j--){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=0;k<j;k++){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            num=0;
            for(int j=0;j<32;j++){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=j;k>=0;k--){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            
        }
        for(int i=0;i<n;i++){
            if(ans[i]==1e9)
            {
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420030940
Ayush Nautiyal,ayushnautiyal1110,429,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans(nums.size(),1e9);
        int n=nums.size();
        for(int i=0;i<n;i++){
            vector<int>bit(32);
            for(int j=31;j>=0;j--){
                int no=(1<<j);
                if(no & nums[i]){
                    bit[j]++;
                }
            }
            int num=0;
            for(int j=31;j>=0;j--){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=0;k<j;k++){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            num=0;
            for(int j=0;j<32;j++){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=j;k>=0;k--){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            
        }
        for(int i=0;i<n;i++){
            if(ans[i]==1e9)
            {
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420031359
DEVANG SHARMA,devangdurvasa1004,430,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Step 1: Initialize the DP array to track removals
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];
        
        // Initialize dp array
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;  // 0 operations needed for an empty pattern
        
        // Step 2: Mark target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;  // Mark index as removable
        }
        
        // Step 3: DP table update to count valid subsequences
        for (int i = 0; i < n; i++) {
            // Iterate backwards through pattern to avoid overwriting values
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If we can form the pattern, dp[m] should have the minimum removal count.
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420083593
DEVANG SHARMA,devangdurvasa1004,430,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420106857
DEVANG SHARMA,devangdurvasa1004,430,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans(nums.size(), -1);

    for (int i = 0; i < nums.size(); ++i) {
        int num = nums[i];
        
       
        for (int x = 1; x < num; ++x) {
            if ((x | (x + 1)) == num) {
                ans[i] = x;
                break;
            }
        }
    }
    return ans;
}
};
 ",1419996628
DEVANG SHARMA,devangdurvasa1004,430,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420054475
easypeasy,easy0peasy1,431,3487,cpp,"class Solution {
public:
    
        long long max(long long a, long long b) {
      return (a > b) ? a : b;
}
    
    int maxRemovals(string s, string p, vector<int>& t) {
        int lenS = s.length();
        int lenP = p.length();
        
        vector<int> dp(lenP + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(lenS, false);
        for (int index : t) {
            isTarget[index] = true;
        }

        for (int i = 0; i < lenS; ++i) {
            for (int j = lenP; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return t.size() - (dp[lenP] == INT_MAX ? 0 : dp[lenP]);
        
    }
};",1420089206
easypeasy,easy0peasy1,431,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420096709
easypeasy,easy0peasy1,431,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for (int i = 0; i < nums.size(); i++) {
            ans[i] = -1; 
            
            for (int c = 0; c < nums[i]; c++) {
                if ((c | (c + 1)) == nums[i]) {
                    ans[i] = c;
                    break; 
                }
            }
        }
        
        return ans;
    }
};",1420020937
easypeasy,easy0peasy1,431,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int length = nums.size();
        vector<int> result(length);

        for (int idx = 0; idx < length; idx++) {
            int curr = nums[idx];
            int mn = INT_MAX;
            bool isFound = false;

            for (int bitPos = 0; bitPos <= 30; bitPos++) {
                if (((curr >> bitPos) & 1) == 1) {
                    int newCandidate = curr & ~(1 << bitPos);

                    if (newCandidate < 0) continue;

                    if ((newCandidate | (newCandidate + 1)) == curr) {
                        if (newCandidate < mn) {
                            mn = newCandidate;
                            isFound = true;
                        }
                    }
                }
            }

            result[idx] = isFound ? mn : -1;
        }

        return result;
    }
};",1420100658
Sanket Anand,snkt027,432,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];

        for(int i = 0; i < m + 1; i++){
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;

        for(int indx: targetIndices){
            isTarget[indx] = true;
        }

        for(int i = 0; i < n; i++){
            for(int j = m; j > 0; j--){
                if(source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420083812
Sanket Anand,snkt027,432,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); 
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); 
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); 
    }
}",1420107295
Sanket Anand,snkt027,432,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(int num: nums){
            bool found = false;
            for(int i = 0; i <= num; ++i){
                if((i | (i + 1)) == num){
                    ans.push_back(i);
                    found = true;
                    break;
                }
            }
            if(!found){
                ans.push_back(-1);
            }
        }

        return ans;
    }
};",1420007877
Sanket Anand,snkt027,432,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];

        for(int i = 0; i < n; i++){
            int num = nums.get(i);
            int min = Integer.MAX_VALUE;
            boolean found = false;

            for(int bit = 0; bit <= 30; bit++){
                if(((num >> bit) & 1) == 1){
                    int cand = num & ~(1 << bit);
                    if(cand < 0) continue;
                    if((cand | (cand + 1)) == num){
                        if(cand < min){
                            min = cand;
                            found = true;
                        }
                    }
                }
            }

            res[i] = found ? min : -1;
        }
        
        return res;

    }
}",1420073219
DAKSH SAHU,daksh_sahu_1803,433,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1]; // Dynamic programming array to track minimal removals
        boolean[] isTarget = new boolean[n]; // Boolean array to mark target indices

        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: no removals needed for an empty pattern

        // Mark the target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            // Iterate backward through the pattern to maintain the dp state
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    // Update dp[j] considering whether the current character is a target
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If it's possible to match the entire pattern, return the result, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420080615
DAKSH SAHU,daksh_sahu_1803,433,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize the combination (C) array using dynamic programming
        C = [[0] * (x + 1) for _ in range(x + 1)]
        
        # Fill the combination table
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        # Fill the Stirling numbers table
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD

        # Initialize the factorial array
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        # Main computation loop
        result = 0
        for k in range(1, x + 1):
            power = 1
            for p in range(k):
                power = (power * y) % MOD
            
            # Update result with final calculation using modular arithmetic
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result",1420120962
DAKSH SAHU,daksh_sahu_1803,433,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  
        
        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];

          
            for (int ans_candidate = 0; ans_candidate <= num; ++ans_candidate) {
                if ((ans_candidate | (ans_candidate + 1)) == num) {
                    ans[i] = ans_candidate;
                    break;  
                }
            }
        }
        return ans;
    }
};
",1420006082
DAKSH SAHU,daksh_sahu_1803,433,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420053918
shivanzzz,shivanzzz,434,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1]; // Dynamic programming array to track minimal removals
        boolean[] isTarget = new boolean[n]; // Boolean array to mark target indices

        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: no removals needed for an empty pattern

        // Mark the target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            // Iterate backward through the pattern to maintain the dp state
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    // Update dp[j] considering whether the current character is a target
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If it's possible to match the entire pattern, return the result, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420079471
shivanzzz,shivanzzz,434,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize the combination (C) array using dynamic programming
        C = [[0] * (x + 1) for _ in range(x + 1)]
        
        # Fill the combination table
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        # Fill the Stirling numbers table
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD

        # Initialize the factorial array
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        # Main computation loop
        result = 0
        for k in range(1, x + 1):
            power = 1
            for p in range(k):
                power = (power * y) % MOD
            
            # Update result with final calculation using modular arithmetic
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result",1420121239
shivanzzz,shivanzzz,434,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  # Initialize ans array with -1
        
        for i in range(n - 1, 0, -1):  # Work backwards to find the values of ans[i]
            for a in range(nums[i]):  # Try different values of ans[i]
                if a | (a + 1) == nums[i]:
                    ans[i] = a
                    break
        
        # Special check for ans[0]
        for a in range(nums[0]):
            if a | (a + 1) == nums[0]:
                ans[0] = a
                break
        
        return ans
",1419997938
shivanzzz,shivanzzz,434,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420052411
junaidiqbal1417,junaidiqbal1417,435,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])


        ",1420062651
junaidiqbal1417,junaidiqbal1417,435,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420095461
junaidiqbal1417,junaidiqbal1417,435,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420006422
junaidiqbal1417,junaidiqbal1417,435,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
           int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420049842
oshangg,oshangg,436,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] removableIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        
        // Create an array to store minimum removals required to match the pattern
        int[] minRemovals = new int[patternLength + 1];
        
        // Initialize the array with a large value, representing infinity
        for (int i = 0; i <= patternLength; i++) {
            minRemovals[i] = Integer.MAX_VALUE;
        }
        minRemovals[0] = 0;  // Base case: 0 removals needed to match the empty pattern
        
        // Boolean array to track which indices are removable
        boolean[] isRemovable = new boolean[sourceLength];
        for (int index : removableIndices) {
            isRemovable[index] = true;
        }
        
        // Process the source string
        for (int i = 0; i < sourceLength; i++) {
            // Traverse the pattern string from right to left to avoid overwriting dp values
            for (int j = patternLength; j > 0; j--) {
                // Check if the current character in source matches the corresponding pattern character
                if (source.charAt(i) == pattern.charAt(j - 1) && minRemovals[j - 1] != Integer.MAX_VALUE) {
                    // Update the dp array considering if the current index is removable
                    minRemovals[j] = Math.min(minRemovals[j], minRemovals[j - 1] + (isRemovable[i] ? 1 : 0));
                }
            }
        }
        
        // If it's impossible to match the entire pattern, return 0 removals; otherwise return the difference
        return removableIndices.length - (minRemovals[patternLength] == Integer.MAX_VALUE ? 0 : minRemovals[patternLength]);
    }
}
",1420100920
oshangg,oshangg,436,3604,cpp,"#include <vector>

class Solution {
public:
    static const int MOD = 1000000007;

    int numberOfWays(int total, int maxVal, int multiplier) {
        // Step 1: Create combination (binomial coefficient) array
        std::vector<std::vector<int>> comb(maxVal + 1, std::vector<int>(maxVal + 1, 0));
        for (int i = 0; i <= maxVal; i++) {
            comb[i][0] = 1;  // Base case: C(i, 0) = 1
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Step 2: Create the Stirling numbers of the second kind (partition function)
        std::vector<std::vector<int>> stirling(total + 1, std::vector<int>(maxVal + 1, 0));
        stirling[0][0] = 1;  // Base case: S(0, 0) = 1
        for (int i = 1; i <= total; i++) {
            for (int j = 1; j <= maxVal; j++) {
                stirling[i][j] = (int)((j * (long long)stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD);
            }
        }

        // Step 3: Create factorial array
        std::vector<long long> factorial(maxVal + 1, 1);
        for (int i = 1; i <= maxVal; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
        }

        // Step 4: Calculate the result using combinations, Stirling numbers, factorials, and powers
        long long result = 0;
        for (int k = 1; k <= maxVal; k++) {
            long long powerTerm = 1;
            for (int p = 0; p < k; p++) {
                powerTerm = (powerTerm * multiplier) % MOD;
            }

            // Compute the result using combination, Stirling numbers, factorial, and powerTerm
            result = (result + (comb[maxVal][k] * (long long)stirling[total][k] % MOD
                                * factorial[k] % MOD * powerTerm % MOD)) % MOD;
        }

        return (int)result;
    }
};
",1420121344
oshangg,oshangg,436,3605,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& numbers) {
        int size = numbers.size();
        std::vector<int> results(size);

        for (int i = 0; i < size; i++) {
            int currentNum = numbers[i];
            int bestCandidate = INT_MAX;
            bool isFound = false;

            // Check each bit position in the current number
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if ((currentNum >> bitPosition) & 1) {  // If the bit is set
                    int possibleNum = currentNum & ~(1 << bitPosition);
                    if (possibleNum < 0) continue;

                    // Check if the modified number and its successor create the original number when OR'd
                    if ((possibleNum | (possibleNum + 1)) == currentNum) {
                        if (possibleNum < bestCandidate) {
                            bestCandidate = possibleNum;
                            isFound = true;
                        }
                    }
                }
            }

            // Assign the result for this index
            if (isFound) {
                results[i] = bestCandidate;
            } else {
                results[i] = -1;
            }
        }

        return results;
    }
};
",1420116022
oshangg,oshangg,436,3611,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& numbers) {
        int size = numbers.size();
        std::vector<int> results(size);

        for (int i = 0; i < size; i++) {
            int currentNum = numbers[i];
            int bestCandidate = INT_MAX;
            bool isFound = false;

            // Check each bit position in the current number
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if ((currentNum >> bitPosition) & 1) {  // If the bit is set
                    int possibleNum = currentNum & ~(1 << bitPosition);
                    if (possibleNum < 0) continue;

                    // Check if the modified number and its successor create the original number when OR'd
                    if ((possibleNum | (possibleNum + 1)) == currentNum) {
                        if (possibleNum < bestCandidate) {
                            bestCandidate = possibleNum;
                            isFound = true;
                        }
                    }
                }
            }

            // Assign the result for this index
            if (isFound) {
                results[i] = bestCandidate;
            } else {
                results[i] = -1;
            }
        }

        return results;
    }
};
",1420115151
Guru Krithick M,guru1307,437,3487,java,"import java.util.*;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        boolean[] isTargetIndex = new boolean[n];

        for (int idx : targetIndices) {
            isTargetIndex[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTargetIndex[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420057575
Guru Krithick M,guru1307,437,3604,java,"import java.util.*;

class Solution {
    static final int MOD = 1000000007;

    public int numberOfWays(int numPerformers, int numStages, int maxScore) {
        long[][] combinations = new long[numStages + 1][numStages + 1];
        for (int i = 0; i <= numStages; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        long[][] stirlingNumbers = new long[numPerformers + 1][numStages + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= numPerformers; i++) {
            for (int j = 1; j <= numStages; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorials = new long[numStages + 1];
        factorials[0] = 1;
        for (int i = 1; i <= numStages; i++) {
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= numStages; k++) {
            long scorePower = 1;
            for (int p = 0; p < k; p++) {
                scorePower = (scorePower * maxScore) % MOD;
            }
            totalWays = (totalWays + combinations[numStages][k] * stirlingNumbers[numPerformers][k] % MOD * factorials[k] % MOD * scorePower % MOD) % MOD;
        }

        return (int) totalWays;
    }
}
",1420109022
Guru Krithick M,guru1307,437,3605,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420033468
Guru Krithick M,guru1307,437,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420042011
Sonali Kumari,10100,438,3487,python3,"

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

",1420066910
Sonali Kumari,10100,438,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }

        // Initialize combination array
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Initialize Stirling numbers of the second kind
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        // Calculate the result using the precomputed arrays
        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD;  // Calculate y^k mod MOD
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); // Expected output: 6
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); // Expected output: 32
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); // Expected output: 684
    }
}
",1420096321
Sonali Kumari,10100,438,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); 

        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];
            for (int j = 0; j < num; ++j) {
                if ((j | (j + 1)) == num) { 
                    ans[i] = j;
                    break;
                }
            }
        }

        return ans;
    }
};
",1419993032
Sonali Kumari,10100,438,3611,java,"import java.util.List;
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}

           ",1420051003
Shubham Jha,alpha_9796,439,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    int n,m;
    long long find(int i,int j,const string& s,const string& pattern,vector<int>&target){
        if(i==n){
            if(j==m)return 0;
            else return INT_MIN;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        long long ans=INT_MIN;
        if(target[i]==1){
            ans=max(ans,1+find(i+1,j,s,pattern,target));
        }
        if(s[i]==pattern[j]){
            ans=max(ans,find(i+1,j+1,s,pattern,target));
        }
        ans=max(ans,find(i+1,j,s,pattern,target));
        return dp[i][j]=ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n1=targetIndices.size();
        n=source.size();
        m=pattern.size();
        vector<int>vis(n,0);
        for(int i=0;i<n1;++i){
            vis[targetIndices[i]]=1;
        }
        memset(dp,-1,sizeof(dp));
        long long cnt=find(0,0,source,pattern,vis);
        if(cnt<=0)return 0;
        return cnt;
    }
};",1420061454
Shubham Jha,alpha_9796,439,3604,cpp,"const int mod=1000000007;
class Solution {
public:
    int pow1(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1){
            ans=(ans*a);
            ans%=mod;
        }
        a=(a*a);
        a%=mod;
        b>>=1;
    }
    return ans%mod;
}
    int numberOfWays(int n, int x, int y) {
       long long ans=0;
       vector<vector<long long> >dp(n+1,vector<long long>(x+1,0));
       vector<vector<long long> >dp1(x+1,vector<long long>(x+1,0));
       vector<long long>f(x+1,1);
       for(int i=0;i<=x;++i)dp1[i][0]=1;
        for(int i=1;i<=x;++i){
       for(int j=1;j<=i;++j){
            dp1[i][j]=(dp1[i-1][j-1]+dp1[i-1][j])%mod;
        }
       }
       dp[0][0]=1;
       for(int i=1;i<=n;++i){
        for(int j=1;j<=x;++j){
            dp[i][j]=((j*1ll*dp[i-1][j])%mod+dp[i-1][j-1])%mod;
        }
       }
       for(int i=1;i<=x;++i)f[i]=(i*1ll*f[i-1])%mod;
       for(int i=1;i<=x;++i){
        long long alp=pow1(y,i);
        ans=(ans+(((((dp1[x][i]*1ll*dp[n][i])%mod)*f[i])%mod)*alp)%mod)%mod;
       }
       return ans;
    }
};",1420116003
Shubham Jha,alpha_9796,439,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n=nums.size();
        vector<int>store;
        for(int i=0;i<n;++i){
            if(nums[i]==2){store.push_back(-1);continue;}
            bool alp=false;
            int ind=-1;
            for(int j=0;j<=31;++j){
                if((nums[i]>>j)&1){
                    ind=j;
                }
                else {
                    break;
                }
            }
            store.push_back(nums[i]-(1ll<<ind));
        }
        return store;
    }
};",1420018302
Shubham Jha,alpha_9796,439,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>store;
        for(int i=0;i<n;++i){
            if(nums[i]==2){store.push_back(-1);continue;}
            bool alp=false;
            int ind=-1;
            for(int j=0;j<=31;++j){
                if((nums[i]>>j)&1){
                    ind=j;
                }
                else {
                    break;
                }
            }
            store.push_back(nums[i]-(1ll<<ind));
        }
        return store;
    }
};",1420017707
pRziBnbrxc,pRziBnbrxc,440,3487,cpp,"class Solution {
    vector<int> findIndicesL(string &source,string &pattern,int &m,int &n){
        vector<int> l;
        int i=0,j=0;
        while(i<m&&j<n){
            if(source[i]==pattern[j]){
                l.push_back(i);
                j++;
            }
            i++;
        }
        return l;
    }
    vector<int> findIndicesR(string &source,string &pattern,int &m,int &n){
        vector<int> r;
        int i=m-1,j=n-1;
        while(i>=0&&j>=0){
            if(source[i]==pattern[j]){
                r.push_back(i);
                j--;
            }
            i--;
        }
        reverse(r.begin(),r.end());
        return r;
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int ans=targetIndices.size(),m=source.size(),n=pattern.size();
        vector<bool> inIndices(m);
        for(int &i:targetIndices) inIndices[i]=1;
        vector<int> dp(n+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<m;i++){
            for(int j=n-1;j>=0;j--){
                if(dp[j]!=INT_MAX){
                    if(source[i]==pattern[j]) dp[j+1]=min(dp[j+1],dp[j]+inIndices[i]);
                }
            }
        }
        if(dp[n]!=INT_MAX) ans-=dp[n];
        return ans;
    }
};",1420107931
pRziBnbrxc,pRziBnbrxc,440,3604,cpp,"class Solution {
    const long long mod=1e9+7;
public:
    long long numberOfWays(int n, int x, int y) {
        int ans=0;
        long long p=1;;
        vector<long long> fact(x+1,1);
        for(int i=1;i<=x;i++) fact[i]=fact[i-1]*i%mod;
        vector<vector<long long>> dp1(x+1,vector<long long>(x+1,0)),dp2(n+1,vector<long long>(x+1,0));
        dp2[0][0]=1;
        for(long long i=0;i<=x;i++) {
            dp1[i][0]=1;
            for(long long j=0;j<i;j++) dp1[i][j+1]=(dp1[i-1][j]+dp1[i-1][j+1])%mod;
        }
        for(long long i=1;i<=n;i++) {
            for(long long j=0;j<x;j++) dp2[i][j+1]=((j+1)*dp2[i-1][j+1]+dp2[i-1][j])%mod;
        }
        for(long long k=1;k<=x;++k) {
            p=1;
            for(long long power=0;power<k;++power) p=(p*y)%mod;
            ans=(ans+dp1[x][k]*dp2[n][k]%mod*fact[k]%mod*p%mod)%mod;
        }
        return ans;
    }
};",1420123024
pRziBnbrxc,pRziBnbrxc,440,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]&1){
                for(int j=1;j<nums[i];j++){
                    if((j|(j+1))==nums[i]){
                        ans[i]=j;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};",1419996911
pRziBnbrxc,pRziBnbrxc,440,3611,cpp,"class Solution {
    int solve(int n){
        int count=0;
        while(n){
            if(n&1) count++;
            else break;
            n/=2;
        }
        return count;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans[i]=-1;
            else ans[i]=nums[i]-pow(2,solve(nums[i])-1);
        }
        return ans;
    }
};",1420040271
Harsha20,Hd0K1zFxZ4,441,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420116884
Harsha20,Hd0K1zFxZ4,441,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420116074
Harsha20,Hd0K1zFxZ4,441,3605,python,"class Solution:
    def minBitwiseArray(self, nums):
        ans = []
        for num in nums:
            found = False
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans
nums1 = [2, 3, 5, 7]
nums2 = [11, 13, 31]
solution = Solution()
print(solution.minBitwiseArray(nums1))
print(solution.minBitwiseArray(nums2))",1420114561
Harsha20,Hd0K1zFxZ4,441,3611,cpp,"class Solution {
public:
    int countTrailingOnes(int p) {
        int count = 0;
        while (p & 1) {
            count++;
            p >>= 1;
        }
        return count;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            if (p == 2 || (p & 1) == 0) {
                ans.push_back(-1);
                continue;
            }
            
            int t = countTrailingOnes(p);
            int x = p - (1 << (t - 1));
            if (x >= 0 && (x | (x + 1)) == p) {
                ans.push_back(x);
                
            } else {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420089909
ujwal001,ujwal001,442,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)  # Length of source string
        m = len(pattern)  # Length of pattern string
        dp = [float('inf')] * (m + 1)  # Dynamic programming array
        dp[0] = 0  # Base case: 0 removals needed for matching an empty pattern
        
        # Boolean array to track target indices
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        # Dynamic programming to find the minimum removals
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    # Update dp[j] if there's a match
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isTarget[i] else 0))

        # Calculate the maximum number of removals
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

# Example usage
sol = Solution()
source = ""abcbcac""
pattern = ""abc""
targetIndices = [1, 3, 5]

print(sol.maxRemovals(source, pattern, targetIndices))  # Example output
",1420067297
ujwal001,ujwal001,442,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1  # C(i, 0) = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1  # S(0, 0) = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):  # k: number of non-empty stages
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways

# Example usage
sol = Solution()
print(sol.numberOfWays(1, 2, 3))  # Output: 6
print(sol.numberOfWays(5, 2, 1))  # Output: 32
print(sol.numberOfWays(3, 3, 4))  # Output: 684

",1420099756
ujwal001,ujwal001,442,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            found = False

            for candidate in range(num):
                if (candidate | (candidate + 1)) == num:
                    ans.append(candidate)
                    found = True
                    break

            if not found:
                ans.append(-1)

        return ans
",1420034781
ujwal001,ujwal001,442,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit < 31; bit++) { // Using 31 to cover all bits of an integer
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            // Store the result
            ans[i] = found ? minimalAns : -1;
        }
        
        return ans;
    }
}


",1420103981
sravanivanka7,sravanivanka7,443,3487,cpp,"

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        // Initialize dp array to store the minimum removals for each position in pattern
        std::vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // Base case: zero removals needed to match an empty pattern

        // Create an array to track which indices are in targetIndices
        std::vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Process each character in the source string
        for (int i = 0; i < n; i++) {
            // Traverse the pattern in reverse to prevent overwriting dp[j-1]
            for (int j = m; j > 0; j--) {
                // Check if characters match and dp[j-1] is not infinity
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the number of removals possible
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420092812
sravanivanka7,sravanivanka7,443,3604,cpp,"#include <vector>
#include <cmath>

class Solution {
public:
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        // Initialize combination array
        std::vector<std::vector<long long>> comb(x + 1, std::vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Initialize Stirling numbers of the second kind
        std::vector<std::vector<long long>> stirling(n + 1, std::vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        std::vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        // Calculate the result using the precomputed arrays
        long long total_ways = 0;
        for (int k = 1; k <= x; k++) {
            long long y_pow = 1; // Initialize y_pow to 1 for calculating y^k
            for (int i = 0; i < k; i++) { // Calculate y^k % MOD
                y_pow = y_pow * y % MOD;
            }
            total_ways = (total_ways + (comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }

        return total_ways;
    }
};
",1420097509
sravanivanka7,sravanivanka7,443,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    int n = nums.size();
    vector<int> ans(n, -1); // Initialize the answer array with -1
    
    for (int i = 0; i < n; ++i) {
        bool found = false;
        
        // Try every number starting from 0 up to nums[i]
        for (int candidate = 0; candidate <= nums[i]; ++candidate) {
            if ((candidate | (candidate + 1)) == nums[i]) {
                ans[i] = candidate;
                found = true;
                break;
            }
        }
        
        // If no valid candidate is found, ans[i] remains -1
        if (!found) {
            ans[i] = -1;
        }
    }
    
    return ans;
    }
};",1420072147
sravanivanka7,sravanivanka7,443,3611,cpp,"

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};

",1420085614
vijay,Vijay_012,444,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420055618
vijay,Vijay_012,444,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]

        while params:
            break
        

        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        

        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        

        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        

        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420097804
vijay,Vijay_012,444,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for num in nums:
            ans.append(next((i for i in range(num) if i | (i+1)==num),-1))
        return ans ",1420010585
vijay,Vijay_012,444,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {

                    int candidate = num & ~(1 << bit);
                    

                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420058793
Vishal Yadav,user4254Mn,445,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int sourceLength = source.length();
int patternLength = pattern.length();
vector<int> dp(patternLength + 1, numeric_limits<int>::max());
dp[0] = 0;

vector<bool> isTargetIndex(sourceLength, false);
for (int index : targetIndices) {
    isTargetIndex[index] = true;
}

for (int i = 0; i < sourceLength; i++) {
    for (int j = patternLength; j > 0; j--) {
        if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
            dp[j] = min(dp[j], dp[j - 1] + (isTargetIndex[i] ? 1 : 0));
        }
    }
}

return targetIndices.size() - (dp[patternLength] == numeric_limits<int>::max() ? 0 : dp[patternLength]);

    }
};",1420123495
Vishal Yadav,user4254Mn,445,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

int numberOfWays(int numItems, int maxGroups, int multiplier) {
    // Create a 2D vector for combinations
    std::vector<std::vector<int>> combinations(maxGroups + 1, std::vector<int>(maxGroups + 1, 0));
    for (int i = 0; i <= maxGroups; ++i) {
        combinations[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
        }
    } 

    // Create a 2D vector for Stirling numbers
    std::vector<std::vector<int>> stirlingNumbers(numItems + 1, std::vector<int>(maxGroups + 1, 0));
    stirlingNumbers[0][0] = 1;
    for (int i = 1; i <= numItems; ++i) {
        for (int j = 1; j <= maxGroups; ++j) {
            stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
        }
    }

    // Create a vector for factorial values
    std::vector<int> factorial(maxGroups + 1, 1);
    for (int i = 1; i <= maxGroups; ++i) {
        factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
    }

    long long totalWays = 0;
    for (int groupCount = 1; groupCount <= maxGroups; ++groupCount) {
        long long multiplierPow = 1;
        for (int i = 0; i < groupCount; ++i) {
            multiplierPow = (multiplierPow * multiplier) % MOD;
        }
        totalWays = (totalWays + (1LL * combinations[maxGroups][groupCount] * stirlingNumbers[numItems][groupCount] % MOD * factorial[groupCount] % MOD * multiplierPow % MOD)) % MOD;
    }
    return totalWays;
}

};",1420118969
Vishal Yadav,user4254Mn,445,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
        for(int i=0; i<nums.size(); i++){
            int ans1=-1;
            for(int j=0; j<=4000; j++){
                int x=( (j) | (j+1) );
                if(x==nums[i]){
                    ans1=j;
                    break;
                }
            }
            ans[i]=ans1;
        }
        return ans;
    }
};",1420030157
Vishal Yadav,user4254Mn,445,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 0);
    
    for (int i = 0; i < n; ++i) {
        int num = nums[i];
        int minimalAns = std::numeric_limits<int>::max();
        bool found = false;

        for (int bit = 0; bit < 31; ++bit) {
            if ((num >> bit) & 1) { // Check if the bit at position `bit` is set
                int candidate = num & ~(1 << bit); // Clear the `bit` position
                if (candidate < 0) {
                    continue; // Skip if candidate is negative
                }
                // Check if candidate with the next higher number equals num
                if ((candidate | (candidate + 1)) == num) {
                    if (candidate < minimalAns) {
                        minimalAns = candidate;
                        found = true;
                    }
                }
            }
        }

        if (found) {
            ans[i] = minimalAns;
        } else {
            ans[i] = -1; // If no valid candidate found
        }
    }
    
    return ans;
    }
};",1420121498
Sk Md Rizwan,Rizwan10,447,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420073563
Sk Md Rizwan,Rizwan10,447,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i-1][j- 1] + comb[i -1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stir(n + 1, std::vector<int>(x + 1, 0));
        stir[0][0] = 1;
        for (int i = 1; i <= n; ++i) 
            for (int j = 1; j <= x; ++j) 
                stir[i][j] = (1LL * j * stir[i - 1][j] + stir[i -1][j -1]) % MOD;
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) 
            factorial[i] = (1LL * factorial[i -1] * i) % MOD;
        long long tw = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            tw = (tw + (1LL * comb[x][k] * stir[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;

        }
        return tw;
    }
};",1420124083
Sk Md Rizwan,Rizwan10,447,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            if (!found) 
                ans[i] = -1;
        }
        return ans;
    }
}",1419994877
Sk Md Rizwan,Rizwan10,447,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420049693
Talapaneni Varshith Chowdary,talapanenivars,448,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420060634
Talapaneni Varshith Chowdary,talapanenivars,448,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105000
Talapaneni Varshith Chowdary,talapanenivars,448,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize the answer array with -1
        for (int i = 0; i < nums.size(); ++i) {
            for (int x = 0; x <= nums[i]; ++x) {
                // Check if the condition ans[i] OR (ans[i] + 1) == nums[i] holds
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420036637
Talapaneni Varshith Chowdary,talapanenivars,448,3611,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        int n = nums.size(); 
        vector<int> ans(n); 
         
        for (int i = 0; i < n; i++) { 
            int num = nums[i]; 
            int minimalAns = INT_MAX; 
            bool found = false; 
             
            
            for (int bit = 0; bit <= 30; bit++) { 
                if ((num >> bit) & 1) { 
                   
                    int candidate = num & ~(1 << bit); 
                     
                   
                    if (candidate < 0) continue; 
                     
                    
                    if ((candidate | (candidate + 1)) == num) { 
                        if (candidate < minimalAns) { 
                            minimalAns = candidate; 
                            found = true; 
                        } 
                    } 
                } 
            } 
             
            if (found) { 
                ans[i] = minimalAns; 
            } else { 
                ans[i] = -1; 
            } 
        } 
         
        return ans; 
    } 
};",1420058373
Shri Abhishek Choudhary,user6084Pr,449,3487,cpp,"class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();

        // Initialize dp array
        std::vector<int> dp(m + 1, std::numeric_limits<int>::max());
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        std::vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != std::numeric_limits<int>::max()) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.size() - (dp[m] == std::numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420092727
Shri Abhishek Choudhary,user6084Pr,449,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420103151
Shri Abhishek Choudhary,user6084Pr,449,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>res;
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            int j=0;
            while(j<=nums[i])
            {
                if((j|j+1)==nums[i])
                {
                    res.push_back(j);
                    break;
                }
                j++;
            }
            if(j>=nums[i])
            {
                res.push_back(-1);
            }
        }
        return res;
    }
};",1420010354
Shri Abhishek Choudhary,user6084Pr,449,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if ((num >> bit) & 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);

                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};
",1420105548
Vedant Tyagi,tyagivedant3846,450,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);  
        dp[0] = 0; 
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        return dp[m] == INT_MAX ? 0 : targetIndices.size() - dp[m];
    }
};
",1420061673
Vedant Tyagi,tyagivedant3846,450,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105816
Vedant Tyagi,tyagivedant3846,450,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        for (int i = 0; i < n; i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  
                }
            }
        }
        
        return ans;
    }
};",1420011495
Vedant Tyagi,tyagivedant3846,450,3611,cpp,"#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};
",1420054741
Siu,BenTennyson09,451,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <limits>

class Solution {
public:
    int maxRemovals(std::string s, std::string p, std::vector<int>& t) {
        int n = s.size(), m = p.size();
        std::vector<int> d(m + 1, std::numeric_limits<int>::max());
        d[0] = 0;
        std::vector<bool> it(n, false);
        
        int tSize = static_cast<int>(t.size());
        while (tSize--) it[t[tSize]] = true;

        int i = 0;
        while (i < n) {
            int j = m;
            while (j > 0) {
                if (s[i] == p[j - 1] && d[j - 1] != std::numeric_limits<int>::max()) {
                    d[j] = std::min(d[j], d[j - 1] + (it[i] ? 1 : 0));
                }
                --j;
            }
            ++i;
        }

        return t.size() - (d[m] == std::numeric_limits<int>::max() ? 0 : d[m]);
    }
};",1420125597
Siu,BenTennyson09,451,3604,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;

    vector<vector<long long>> comb(int siz) {
        vector<vector<long long>> C(siz + 1, vector<long long>(siz + 1, 0));
        int i = 0; while (i <= siz) { C[i][0] = 1; int j = 1; while (j <= i) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD; ++j; } ++i; }
        return C;
    }

    vector<vector<long long>> part(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1; int i = 1; while (i <= n) {
            int j = 1; while (j <= x) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD; ++j;
            } ++i;
        }
        return S;
    }

    vector<long long> fact(int siz) {
        vector<long long> F(siz + 1, 1);
        int i = 1; while (i <= siz) { F[i] = (F[i - 1] * i) % MOD; ++i; }
        return F;
    }

public:
    int numberOfWays(int n, int x, int y) {
        auto C = comb(x); auto S = part(n, x); auto F = fact(x);
        long long res = 0; int k = 1; while (k <= x) {
            long long p = 1; int pwr = 0; while (pwr < k) { p = (p * y) % MOD; ++pwr; }
            long long t = C[x][k]; t = (t * S[n][k]) % MOD; t = (t * F[k]) % MOD; t = (t * p) % MOD;
            res = (res + t) % MOD; ++k;
        }
        return static_cast<int>(res);
    }
};",1420110253
Siu,BenTennyson09,451,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return list(map(lambda x: -1 if x == 2 else next(i for i in range(x) if i | (i + 1) == x), nums))",1419997306
Siu,BenTennyson09,451,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = [0] * len(nums)
        
        unset_bit = lambda num, bit_position: num & ~(1 << bit_position)
        is_valid = lambda value, num: (value | (value + 1)) == num
        
        index = 0
        while index < len(nums):
            current_num = nums[index]
            minimal_value = float('inf')
            bitwise_found = False
            
            bit_position = 0
            while bit_position < 31:
                if ((current_num >> bit_position) & 1) == 1:
                    modified_value = unset_bit(current_num, bit_position)
                    
                    if modified_value >= 0 and is_valid(modified_value, current_num):
                        if modified_value < minimal_value:
                            minimal_value = modified_value
                            bitwise_found = True
                bit_position += 1
            
            result[index] = minimal_value if bitwise_found else -1
            index += 1
        
        return result",1420059877
Kavish Dhamija,kavishd29598,452,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n=len(source)
        m=len(pattern)
        l=len(targetIndices)
        # targetIndices.sort()
        # mx_t=targetIndices[-1]+1
        tis = set(targetIndices)
        # @cache
        # def dp(s,p):
        #     ans = -float('inf')
        #     if s==n:
        #         return 0 if p==m else ans
        #     if p==m:
        #         return l-bisect.bisect_left(targetIndices,s)
        #     if s<mx_t and s in tis:
        #         ans = max(ans,1+dp(s+1,p))
        #     if s<n and p<m and source[s]==pattern[p]:
        #         ans = max(ans,dp(s+1,p+1))
        #     return max(ans,dp(s+1,p))
        # return dp(0,0)

        dp = [[-float('inf')] * (m + 1) for _ in range(n + 1)]
        for s in range(n + 1):
            dp[s][m] = l - bisect_left(targetIndices, s)
        for s in range(n - 1, -1, -1):  
            for p in range(m - 1, -1, -1): 
                dp[s][p] = dp[s + 1][p]
                if source[s] == pattern[p]:
                    dp[s][p] = max(dp[s][p], dp[s + 1][p + 1])
                if s in tis:
                    dp[s][p] = max(dp[s][p], 1 + dp[s + 1][p])
        return dp[0][0]",1420101109
Kavish Dhamija,kavishd29598,452,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1

        for i in range(1, n + 1):
            for j in range(1, x + 1):
                dp[i][j] = (dp[i-1][j] * j) % MOD
                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (x - j + 1)) % MOD

        ans = 0
        for j in range(1, x + 1):
            ans = (ans + dp[n][j] * pow(y, j, MOD)) % MOD

        return ans
",1420114596
Kavish Dhamija,kavishd29598,452,3605,python3,"
    
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            s=1
            z=float('inf')
            while s<=i:
                n = i^s
                # print(i,s,n) 
                if n|(n+1)==i:
                    z=min(n,z)
                s<<=1
            # print('--')
            ans.append(z if z!= float('inf') else -1)
        return ans",1420054016
Kavish Dhamija,kavishd29598,452,3611,python3,"
    
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            s=1
            z=float('inf')
            while s<=i:
                n = i^s
                # print(i,s,n) 
                if n|(n+1)==i:
                    z=min(n,z)
                s<<=1
            # print('--')
            ans.append(z if z!= float('inf') else -1)
        return ans",1420054080
Pritam Sanjay S,sanjay_78,453,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        a,b=len(source),len(pattern)
        dp=[0]
        ma=99999999
        dp+=[ma]*(b)
        t=[0]*a
        for i in targetIndices:
            t[i]=1
        for i in range(a):
            for j in range(b,0,-1):
                if source[i]==pattern[j-1] and dp[j-1]!=ma:
                    dp[j]=min(dp[j-1]+t[i],dp[j])
        return len(targetIndices)-(0 if dp[b]==ma else dp[b])
        ",1420094115
Pritam Sanjay S,sanjay_78,453,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod=10**9 + 7
        arr=[[0]*(x+1) for _ in range(x+1)]
        dp=[[0]*(x+1) for _ in range(n+1)]
        dp[0][0]=1
        ft=[1]*(x+1)
        c=0
        for i in range(x+1):
            arr[i][0]=1
            for j in range(1,i+1):
                arr[i][j]=(arr[i-1][j-1]+arr[i-1][j]) % mod
        for i in range(1,n+1):
            for j in range(1,x+1):
                dp[i][j]=(j*dp[i-1][j]+dp[i-1][j-1])%mod
        for i in range(1,x+1):
            ft[i]=(ft[i-1]*i)%mod
        for k in range(1,x+1):
            p=pow(y,k,mod) 
            c=(c+arr[x][k]*dp[n][k]%mod*ft[k]%mod*p%mod)%mod

        return c",1420121700
Pritam Sanjay S,sanjay_78,453,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        x=[-1]*n
        for i in range(n):
            for j in range(nums[i]+1):
                t=j | (j+1)
                if t==nums[i]:
                    x[i]=j
                    break
        return x
            ",1420020364
Pritam Sanjay S,sanjay_78,453,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        x=[0]*n
        for i in range(n):
            t=nums[i]
            m=999999999999
            f=0
            for j in range(31):
                if (t>>j)&1==1:
                    c=t & ~(1<<j)
                    if c<0:continue
                    if c|(c+1)==t:
                        if c<m:
                            m=c
                            f=1
            if f:
                x[i]=m
            else:x[i]=-1
        return x",1420084952
raja jha,rgjha2001,454,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<float> dp(m + 1, float('inf'));
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != float('inf')) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == float('inf') ? 0 : dp[m]);
    }
};",1420118257
raja jha,rgjha2001,454,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> combination(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * combination[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420122891
raja jha,rgjha2001,454,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    int n = nums.size();
    std::vector<int> ans(n, -1);

    
    for (int i = 0; i < n; ++i) {
        bool found = false;
        
        for (int candidate = 0; candidate <= nums[i]; ++candidate) {
            if ((candidate | (candidate + 1)) == nums[i]) {
                ans[i] = candidate;
                found = true;
                break;
            }
        }
        if (!found) {
            ans[i] = -1;
        }
    }

    return ans;
    }
};",1420033074
raja jha,rgjha2001,454,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            
            for (int bit = 0; bit <= 30; ++bit) {
                if (((num >> bit) & 1) == 1) {
                  
                    int candidate = num & ~(1 << bit);
                    
                    
                    if (candidate < 0) continue;
                    
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420074194
Abhiram Alluri,Abhiram_Alluri1,455,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val n = source.length
        val m = pattern.length
        val dp = IntArray(m + 1) { Int.MAX_VALUE }
        val isTarget = BooleanArray(n)

        dp[0] = 0

        for (idx in targetIndices) {
            isTarget[idx] = true
        }

        for (i in 0 until n) {
            for (j in m downTo 1) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != Int.MAX_VALUE) {
                    dp[j] = minOf(dp[j], dp[j - 1] + if (isTarget[i]) 1 else 0)
                }
            }
        }

        return targetIndices.size - if (dp[m] == Int.MAX_VALUE) 0 else dp[m]
    }
}
",1420092941
Abhiram Alluri,Abhiram_Alluri1,455,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420110520
Abhiram Alluri,Abhiram_Alluri1,455,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int x = 0;
            while (x <= nums[i]) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;
                }
                x++;
            }
        }
        return ans;
    }
};",1420000222
Abhiram Alluri,Abhiram_Alluri1,455,3611,swift,"class Solution {
    func minBitwiseArray(_ nums: [Int]) -> [Int] {
        let n = nums.count
        var ans = [Int](repeating: 0, count: n)
        
        for i in 0..<n {
            let num = nums[i]
            var minimalAns = Int.max
            var found = false
            
            // Iterate through each bit position (0 to 30)
            for bit in 0...30 {
                if (num >> bit) & 1 == 1 {
                    // Unset the current bit
                    let candidate = num & ~(1 << bit)
                    
                    // Ensure candidate is non-negative
                    if candidate < 0 { continue }
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num {
                        if candidate < minimalAns {
                            minimalAns = candidate
                            found = true
                        }
                    }
                }
            }
            
            if found {
                ans[i] = minimalAns
            } else {
                ans[i] = -1
            }
        }
        
        return ans
    }
}
",1420074582
phoenixwon,phoenixwon,456,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420062485
phoenixwon,phoenixwon,456,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420090709
phoenixwon,phoenixwon,456,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420021768
phoenixwon,phoenixwon,456,3611,java,"
import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420038452
Raj Mandhare,Raj2603,457,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> check(n, false);
        for (auto it : targetIndices) {
            check[it] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    if(check[i]){
                        dp[j] = min(dp[j], dp[j - 1] + 1);
                    }else{
                        dp[j] = min(dp[j], dp[j - 1] + 0);
                    }
                    
                }
            }
        }
        if(dp[m]==INT_MAX){
            return targetIndices.size();
        }else{
            return targetIndices.size() - dp[m];
        }
    }
};",1420069172
Raj Mandhare,Raj2603,457,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9+7;
    int calpow(int b, int p, int m) {
        long long res = 1;
        long long bmod = b % m;
        while (p > 0) {
            if (p % 2 == 1) {
                res = (res * bmod) % m;
            }
            bmod = (bmod * bmod) % m;
            p /= 2;
        }
        return res;
    }
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> combinations(x+1, vector<int>(x+1, 0));
        vector<int> fact(x + 1, 1);
        vector<vector<int>> temp(n+1, vector<int>(x+1, 0));
        temp[0][0] = 1;

        for (int i = 0; i <= x; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i-1][j-1] + combinations[i-1][j]) % MOD;
            }
        }

        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                temp[i][j] = (1LL * j * temp[i-1][j] + temp[i-1][j-1]) % MOD;
            }
        }

        for (int i = 1; i <= x; i++) {
            fact[i] = (1LL * fact[i-1] * i) % MOD;
        }

        long long ans = 0;
        for (int j = 1; j <= x; j++) {
            long long yexp = calpow(y, j, MOD);
            ans = (ans + 1LL * combinations[x][j] * temp[n][j] % MOD * fact[j] % MOD * yexp % MOD) % MOD;
        }

        return ans;
    }
};",1420124036
Raj Mandhare,Raj2603,457,3605,cpp,"class Solution {
public:
   
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n); 
         
        for (int i = 0; i < n; i++) { 
            bool flag = 0; 
            for (int j = 0; j <= nums[i]; j++) { 
                if ((j | (j + 1)) == nums[i]) { 
                    ans[i] = j;  
                    flag = 1; 
                    break; 
                } 
            } 
             
            if (!flag) { 
                ans[i] = -1;
            } 
        } 
         
        return ans; 
    }
};",1420022723
Raj Mandhare,Raj2603,457,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
    
        for (int i = 0; i < n; i++) {
            int mini = INT_MAX;
            bool flag = 0;
            int num = nums[i];

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int temp = num & ~(1 << bit);
                    if (temp < 0){ 
                        continue;
                    }
                    if ((temp | (temp + 1)) == num) {
                        if (temp < mini) {
                            flag = 1;
                            mini = temp;
                        }
                    }
                }
            }
        
            if (flag) {
                ans[i] = mini;
            } else {
                ans[i] = -1;
            }
        }
    
        return ans;
    }
};",1420050733
swap_ab,swap_ab,458,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
         int n=source.size();
         int m=pattern.size();
         vector<int>ans(m+1,INT_MAX);
         ans[0]=0;
         vector<bool>iscorrect(n,false);
         for(auto it:targetIndices)
         {
            iscorrect[it]=true;
         }
         for(int i=0;i<n;i++)
         {
            for(int j=m;j>0;j--)
            {
                if(source[i]==pattern[j-1]&&ans[j-1]!=INT_MAX)
                {
                    ans[j]=min(ans[j],ans[j-1]+(iscorrect[i]?1:0));
                }
            }
         }
         return targetIndices.size()-(ans[m]==INT_MAX?0:ans[m]);
    }
};",1420101650
swap_ab,swap_ab,458,3604,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    
    vector<vector<long long>> computeCombinations(int size) {
        vector<vector<long long>> C(size + 1, vector<long long>(size + 1, 0));
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }
    
    vector<vector<long long>> computePartitions(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }
    
    vector<long long> computeFactorials(int size) {
        vector<long long> fact(size + 1, 1);
        for (int i = 1; i <= size; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

public:
    int numberOfWays(int n, int x, int y) {
        auto C = computeCombinations(x);
        auto S = computePartitions(n, x);
        auto fact = computeFactorials(x);
        
        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            long long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * fact[k]) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }
        
        return static_cast<int>(result);
    }
};",1420113055
swap_ab,swap_ab,458,3605,cpp,"#include <vector>  
#include <limits.h>  

class Solution {  
public:  
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {  
        int n = nums.size();  
        std::vector<int> ans(n, -1);  

        for (int i = 0; i < n; i++) {  
            int num = nums[i];  
            int minimalAns = INT_MAX;  

            for (int bit = 0; bit < 31; bit++) {  
                if ((num >> bit) & 1) {  
                    int candidate = num & ~(1 << bit);  
                    if (candidate >= 0) {  
                        if ((candidate | (candidate + 1)) == num) {  
                            minimalAns = std::min(minimalAns, candidate);  
                        }  
                    }  
                }  
            }  

            if (minimalAns != INT_MAX) {  
                ans[i] = minimalAns;  
            }  
        }  
        
        return ans;  
    }  
};",1420120883
swap_ab,swap_ab,458,3611,cpp,"#include <vector>  
#include <limits.h>  

class Solution {  
public:  
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {  
        int n = nums.size();  
        std::vector<int> ans(n, -1);  

        for (int i = 0; i < n; i++) {  
            int num = nums[i];  
            int minimalAns = INT_MAX;  

            for (int bit = 0; bit < 31; bit++) {  
                if ((num >> bit) & 1) {  
                    int candidate = num & ~(1 << bit);  
                    if (candidate >= 0) {  
                        if ((candidate | (candidate + 1)) == num) {  
                            minimalAns = std::min(minimalAns, candidate);  
                        }  
                    }  
                }  
            }  

            if (minimalAns != INT_MAX) {  
                ans[i] = minimalAns;  
            }  
        }  

        return ans;  
    }  
};",1420124121
padhaikarlebhai,mradulag20,459,3487,cpp,"class Solution {
public:

    int dp[3002][3002]; 
    int n, m; 
    string s, p;
    set<int> st; 
    
    int rec(int ii, int jj) {
        if(ii == n) {
            if(jj == m) return 0; 
            return -1e9;
        }

        if(dp[ii][jj] != -1) return dp[ii][jj]; 

        int ans = rec(ii+1, jj); 
        if(s[ii] == p[jj]){
            ans = max(ans, rec(ii+1, jj+1)); 
        }
        if(st.find(ii) != st.end()) {
            ans = max(ans, rec(ii+1, jj) + 1); 
        }

        return dp[ii][jj] = ans; 
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        s = source;
        p = pattern; 
        n = s.size(); 
        m = p.size(); 
        for(auto it: targetIndices) {
            st.insert(it); 
        }

        for(int i=0; i<=n; i++) {
            for(int j=0; j<=m; j++) {
                dp[i][j] = -1; 
            }
        }

        return rec(0, 0); 
    }
};",1420025150
padhaikarlebhai,mradulag20,459,3604,cpp,"class Solution {
public:

    long long mod = 1e9+7; 

    long long nCr[2000][2000];
    long long binpow(long long n, long long p)
    {
        long long ans = 1;
        while (p)
        {
            if (p % 2)
            {
                ans *= n;
                ans %= mod;
            }
            n *= n;
            n %= mod;
            p >>= 1;
        }
        return ans;
    }

    long long invmod(int n)
    {
        // if(invmod_dp[n] != -1) return invmod_dp[n]; 
        return binpow(n, mod - 2);
    }

    long long dpp[2000]; 

    int numberOfWays(int n, int x, int y) {
        
        long long facs[2000]; 
        facs[0] = 1; 
        for(int i=1; i<2000; i++) {
            facs[i] = i * facs[i-1]; 
            facs[i] %= mod; 
        }

        long long pows[2000]; 
        pows[0] = 1; 
        for(int i=1; i<2000; i++) {
            pows[i] = y * pows[i-1]; 
            pows[i] %= mod; 
        }


        for(int i=0; i<=max(x,n)+1; i++) {
            dpp[i] = invmod(facs[i]);
        }


        for(int i=0; i<=max(n,x)+2; i++) {
            for(int j=0; j<=max(n,x)+2; j++)
            {
                if(i-j >= 0){
                    nCr[i][j] = ((facs[i] * dpp[j])%mod * dpp[i-j])%mod; 
                }
            }
        }

        long long dp[2000]; 

        int ans = 0; 
        for(int i=1; i<=x; i++) {
            long long temp = nCr[x][i]; 
            temp *= pows[i]; 
            // cout << nCr[x][i] << "" "" << pows[i] << "" "" << temp << endl; 
            temp %= mod;
            if(n < i) continue; 
            long long total = binpow(i, n);
            for(int j=1; j<i; j++) {
                total -= (dp[j] * nCr[i][j])%mod; 
                total += mod; 
                total %= mod; 
            }
            temp *= total; 
            temp %= mod; 
            dp[i] = total; 

            // cout << temp << endl; 

            ans += temp;
            ans %= mod; 
        }

        return ans; 

    }
};",1420124633
padhaikarlebhai,mradulag20,459,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans; 

        for(auto it: nums) {
            if(it == 2) {
                ans.push_back(-1); 
            }
            else
            {
                int itt = it; 
                int cnt = 0; 
                while(it > 0) {
                    if(it%2 == 0) {
                        break; 
                    }
                    else{
                        cnt++; 
                        it /= 2; 
                    }
                }
                itt = itt ^ (1 << (cnt-1)); 
                ans.push_back(itt); 
            }
        }

        return ans; 
    }
};",1420009186
padhaikarlebhai,mradulag20,459,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans; 

        for(auto it: nums) {
            if(it == 2) {
                ans.push_back(-1); 
            }
            else
            {
                int itt = it; 
                int cnt = 0; 
                while(it > 0) {
                    if(it%2 == 0) {
                        break; 
                    }
                    else{
                        cnt++; 
                        it /= 2; 
                    }
                }
                itt = itt ^ (1 << (cnt-1)); 
                ans.push_back(itt); 
            }
        }

        return ans; 
    }
};",1420008845
Shivanand Verma,starkbbk,460,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];
        
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420112137
Shivanand Verma,starkbbk,460,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420117107
Shivanand Verma,starkbbk,460,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>res(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=nums[i];j++){
                if((j|(j+1))==nums[i]){
                    res[i]=j;
                    break;
                }
            }
        }
        return res;
    }
};",1420049504
Shivanand Verma,starkbbk,460,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420118568
vittasai05,vittasai05,461,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array to store minimum removals to match the pattern
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;  // dp[0] means no part of the pattern is matched yet
        
        // Mark target indices in the source
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        // Traverse the source string
        for (int i = 0; i < n; i++) {
            // Traverse pattern from the back
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        // If we matched the entire pattern, return the removals used, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420101133
vittasai05,vittasai05,461,3604,python,"MOD = 10**9 + 7
class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420112894
vittasai05,vittasai05,461,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;

            // Try to find the smallest ans[i] such that ans[i] OR (ans[i] + 1) == nums[i]
            for (int j = 0; j < num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }

            // If no such value is found, set ans[i] = -1
            if (!found) {
                ans[i] = -1;
            }
        }

        return ans;
    }
}
",1420025778
vittasai05,vittasai05,461,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420097680
Nahid Karim Emon,nahid_180103,462,3487,cpp,"class Solution {
public:
    int maxRemovals(string& source, string& pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int c = targetIndices.size();
        vector<bool>vis(n);
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        for (int e : targetIndices) {
            vis[e] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if(dp[j-1] == INT_MAX)continue;
                if(source[i] == pattern[j-1]){
                    int p = dp[j-1];
                    if(vis[i])p++;
                    int x = min(dp[j],p);
                    dp[j] = x;
                }
            }
        }
        int y=0;
        if(dp[m]!=INT_MAX)y=dp[m];
        return c-y;
    }
};",1420065998
Nahid Karim Emon,nahid_180103,462,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        int an=0;
        vector<long long>fac(x+1,1);
        for(int i=1;i<=x;i++){
            fac[i]=(fac[i-1]*i*1LL)%mod;
        }
        vector<vector<long long>> arr(x + 1, vector<long long>(x + 1, 0)),brr(n+1,vector<long long>(x+1,0));
        brr[0][0] = 1;
        for (int i = 0; i <= x; i++) {
            arr[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                long long p = arr[i-1][j-1]+arr[i-1][j];
                arr[i][j]=p%mod;
            }
        }
        for (int i = 1; i <= n; i++) {    
            for (int j = 1; j <= x; j++) {
                long long p = j*brr[i-1][j];
                p+=brr[i-1][j-1];
                brr[i][j]=p%mod;
            }
        }
        for (int i = 1; i <= x; i++) {
            long long p = 1;
            for (int j = 0; j < i; j++) {
                p*=y;
                p%=mod;
            }
            long long y = (arr[x][i]*brr[n][i]%mod*fac[i]%mod*p%mod)%mod;
            an+=(y%mod);
            an%=mod;
        }

        return an%mod;
    }
};
",1420113196
Nahid Karim Emon,nahid_180103,462,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        
        for (int i = 0; i < nums.size(); i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }
        
        return ans;
    }
};
",1419996910
Nahid Karim Emon,nahid_180103,462,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int mx=INT_MAX;
            bool ch = false;
            for (int j = 0; j <= 30; j++) {
                if ((nums[i] >> j) & 1) {
                    int x = nums[i] & ~(1 << j);
                    if(x>=0){
                        if((x|(x+1))==nums[i]){
                            if(x<mx){
                                mx=x;
                                ch=true;
                            }
                        }
                    }
                }
            }
            ans[i]=(ch?mx:-1);
        }
        
        return ans;
    }
};
",1420075518
OmkarKanade,OmkarKanade,463,3487,cpp,"class Solution {
public:
    int f(string &source, string &pattern, unordered_set<int> &tgt, int si, int pi, vector<vector<int>> &dp) {
        // base case
        if (si == source.length()) {
            if (pi == pattern.length()) {
                return 0;
            }
            return INT_MIN;
        }
        
        if (dp[si][pi] != -1) {
            return dp[si][pi];
        }
        
        // skip current char
        int skipVal1 = INT_MIN;
        int skipVal2 = INT_MIN;
        
        skipVal1 = f(source, pattern, tgt, si + 1, pi, dp);
        if (pi < pattern.length() && source[si] == pattern[pi]) {
            skipVal2 = f(source, pattern, tgt, si + 1, pi + 1, dp);
        }
        
        // remove current char
        int removeVal = INT_MIN;
        if (tgt.find(si) != tgt.end()) {
            removeVal = 1 + f(source, pattern, tgt, si + 1, pi, dp);
        }
        
        dp[si][pi] = max(max(skipVal1, skipVal2), removeVal);
        return dp[si][pi];
    }
    
    int maxRemovals(string &source, string &pattern, vector<int>& targetIndices) {
        int n = source.length();
        int p = pattern.length();
        int t = targetIndices.size();
        
        unordered_set<int> tgt;
        for (int i: targetIndices) {
            tgt.insert(i);
        }
        
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return f(source, pattern, tgt, 0, 0, dp);
    }
};",1420052155
OmkarKanade,OmkarKanade,463,3604,cpp,"class Solution {
public:
    int MOD = 1e9+7;
    
    int constructTable(vector<vector<long long>> &xCk, int x, int k) {
        if (x == k || k == 0) {
            xCk[x][k] = 1;
            return 1;
        }
        if (k == 1) {
            xCk[x][k] = x;
            return x;
        }
        
        if (xCk[x][k] != -1) {
            return xCk[x][k];
        }
        
        xCk[x][k] = (constructTable(xCk, x - 1, k) + constructTable(xCk, x - 1, k - 1)) % MOD;
        return xCk[x][k];
    }
    
    int numberOfWays(int n, int x, int y) {
        long long res = 0;
        long long occ = min(n, x);
        vector<vector<long long>> xCk(x + 1, vector<long long>(x + 1, -1));
        constructTable(xCk, x, x);
        long long yPow = y;
        long long curr = 1;
        vector<long long> kPowN(occ + 1, 1);
        kPowN[0] = 0;
        for (int k=2; k<=occ; k++) {
            long long val = 1;
            for (int p=0; p<n; p++) {
                val = (val * k) % MOD;
            }
            kPowN[k] = val % MOD;
        }
        for (int k=1; k<=occ; k++) {
            if (xCk[x][k] == -1) {
                constructTable(xCk, x, k);
            }
            curr = (xCk[x][k] *  yPow) % MOD;
            long long sum = 0;
            long long term;
            long long sign = 1;
            for (int i=0; i<=k; i++) {
                if (xCk[k][i] == -1) {
                    constructTable(xCk, k, i);
                }
                term = (((sign * xCk[k][i] * kPowN[k - i]) % MOD) + MOD) % MOD;
                sum = (sum + term) % MOD;
                sign *= -1;
            }
            curr = (curr * sum) % MOD;
            res = (res + curr) % MOD;
            yPow = (yPow * y) % MOD;
        }
        return res % MOD;
    }
};",1420126284
OmkarKanade,OmkarKanade,463,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i=0; i<n; i++) {
            int num = nums[i];
            if (num == 2) {
                res[i] = -1;
            } else {
                int k = num;
                int twoPow = 1;
                while (k > 0 && k % 2 != 0) {
                    k /= 2;
                    twoPow *= 2;
                }
                res[i] = num - (twoPow / 2);
            }
        }
        return res;
    }
};",1420001732
OmkarKanade,OmkarKanade,463,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i=0; i<n; i++) {
            int num = nums[i];
            if (num == 2) {
                res[i] = -1;
            } else {
                int k = num;
                int twoPow = 1;
                while (k > 0 && k % 2 != 0) {
                    k /= 2;
                    twoPow *= 2;
                }
                res[i] = num - (twoPow / 2);
            }
        }
        return res;
    }
};",1420002417
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3487,java,"class Solution {
    public int maxRemovals(String s, String p, int[] t) {
        int a = s.length();
        int b = p.length();
        int[] c = new int[b + 1];
        Arrays.fill(c, Integer.MAX_VALUE);
        c[0] = 0;

        boolean[] d = new boolean[a];
        int e = 0;
        // while (e < t.length) {
        //     d[t[e]] = true;
        while (e < t.length) {
            d[t[e]] = true;
            e++;
        }
        //     e++;
        // }

        int f = 0;
        while (f < a) {
            int g = b;
            // while (g > 0) {
            while (g > 0) {
                if (s.charAt(f) == p.charAt(g - 1) && c[g - 1] != Integer.MAX_VALUE) {
                    c[g] = Math.min(c[g], c[g - 1] + (d[f] ? 1 : 0));
                }
                g--;
            }
            //         c[g] = Math.min(c[g], c[g - 1] + (d[f] ? 1 : 0));
            // }
            f++;
        }

        return t.length - (c[b] == Integer.MAX_VALUE ? 0 : c[b]);
    }
}",1420121982
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        final int MOD = 1_000_000_007;
        long[][] c = new long[n + 1][x + 1];
        c[0][0] = 1;

        int i = 1;
        while (i <= n) {
            int j = 1;
            while (j <= Math.min(i, x)) {
                c[i][j] = (j * c[i - 1][j] + c[i - 1][j - 1]) % MOD;
                j++;
            }
            i++;
        }

        long[] bc = new long[x + 1];
        bc[0] = 1;

        int i2 = 1;
        while (i2 <= x) {
            int j2 = Math.min(i2, x);
            // while (j2 >= 1) {
             while (j2 >= 1) {
                bc[j2] = (bc[j2] + bc[j2 - 1]) % MOD;
                j2--;
            //     j2--;
            }
            i2++;
        }

        long[] f = new long[x + 1];
        f[0] = 1;

        int i3 = 1;
        while (i3 <= x) {
            f[i3] = (f[i3 - 1] * i3) % MOD;
            i3++;
        }

        // int limit = Math.min(x, n);
        int limit = Math.min(x, n);
        long[] pY = new long[limit + 1];
        // long[] pY = new long[limit + 1];
        pY[0] = 1;

        int k = 1;
        while (k <= limit) {
            pY[k] = (pY[k - 1] * y) % MOD;
            k++;
        }

        long totalWays = 0;

        k = 1;
        while (k <= limit) {
            long intermediate = (bc[k] * f[k]) % MOD;
            // intermediate = (intermediate * c[n][k]) % MOD;
            intermediate = (intermediate * c[n][k]) % MOD;
            intermediate = (intermediate * pY[k]) % MOD;
            totalWays = (totalWays + intermediate) % MOD;
            // intermediate = (intermediate * pY[k]) % MOD;
            // totalWays = (totalWays + intermediate) % MOD;
            k++;
        }

        return (int) totalWays;
    }
}",1420065547
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3605,cpp,"#include <vector>
#include <algorithm>

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420037247
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] out = new int[nums.size()];

        int i = 0;
        while (i < nums.size()) {
            // int n = nums.get(i);
            int n = nums.get(i);
            int best = Integer.MAX_VALUE;
            // int best = Integer.MAX_VALUE;

            int b = 0;
            while (b < 31) {
                if ((n & (1 << b)) != 0) {
                    int newC = n & ~(1 << b);

                    if (newC >= 0 && newC < n) {
                        int subC = newC + 1;

                        // if ((newC | subC) == n) {
                        if ((newC | subC) == n) {
                            if (newC < best) {
                                best = newC;
                            }
                        }
                        //     if (newC < best) {
                        //         best = newC;
                        //     }
                        // }
                    }
                }
                b++;
            }

            out[i] = (best != Integer.MAX_VALUE) ? best : -1;
            i++;
        }

        return out;
    }
}",1420089507
Maharaj Mahaadev,Maharaj_Mahaadev,465,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices){
            isTarget[idx] = true;
        }

        for(int i = 0; i < n; i++){
            for(int j = m; j > 0; j--){
                if(source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX){
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420091568
Maharaj Mahaadev,Maharaj_Mahaadev,465,3604,cpp,"const int MOD = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<int> params = {n, x, y};

        while(!params.empty()){
            break;
        }

        vector<vector<int>> comb(x+1, vector<int>(x+1, 0));
        for(int i=0; i<=x; ++i){
            comb[i][0] = 1;
            for(int j=1; j<=i; ++j){
                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;
            }
        }

        vector<vector<long long int>> stirling(n+1, vector<long long int>(x+1, 0));
        stirling[0][0] = 1;

        for(int i=1; i<=n; ++i){
            for(int j=1; j<=x; ++j){
                stirling[i][j] = (j * stirling[i-1][j] + stirling[i-1][j-1]) % MOD;
            }
        }

        vector<long long int> factorial(x + 1, 1);
        for(int i=1; i<=x; ++i) {
            factorial[i] = factorial[i-1] * i % MOD;
        }

        long long total_ways = 0; 
        for(int k=1; k<=x; ++k) {
            long long y_pow = 1;
            for(int power=0; power<k; ++power) {
                y_pow = (y_pow * y) % MOD;
            }

            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }

        return total_ways%MOD;
    }
};",1420109743
Maharaj Mahaadev,Maharaj_Mahaadev,465,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 

        for(int i = 0; i < n; ++i){
            for(int x = 0; x <= nums[i]; ++x){
                if((x | (x + 1)) == nums[i]){
                    ans[i] = x;
                    break;
                }
            }
        }

        return ans;
    }
};",1420041028
Maharaj Mahaadev,Maharaj_Mahaadev,465,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for(int i = 0; i < n; i++){
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for(int bit = 0; bit <= 30; bit++){
                if(((num >> bit) & 1) == 1){
                    int candidate = num & ~(1 << bit);
                    if(candidate < 0) continue;

                    if((candidate | (candidate + 1)) == num){
                        if(candidate < minimalAns){
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if(found){
                ans[i] = minimalAns;
            } 
            else{
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420087452
Gajendra Sahu,gajmain2020,466,3487,javascript,"/**
 * @param {string} source
 * @param {string} pattern
 * @param {number[]} targetIndices
 * @return {number}
 */
var maxRemovals = function(text, subPattern, removeIndices) {
    const textLength = text.length, patternLength = subPattern.length;
        const minRemovals = Array(patternLength + 1).fill(Infinity);
        const markedForRemoval = Array(textLength).fill(false);

        minRemovals[0] = 0;

        removeIndices.forEach(index => markedForRemoval[index] = true);

        for (let i = 0; i < textLength; ++i) {
            for (let j = patternLength; j > 0; --j) {
                if (text[i] === subPattern[j - 1] && minRemovals[j - 1] !== Infinity) {
                    minRemovals[j] = Math.min(minRemovals[j], minRemovals[j - 1] + (markedForRemoval[i] ? 1 : 0));
                }
            }
        }

        return removeIndices.length - (minRemovals[patternLength] === Infinity ? 0 : minRemovals[patternLength]);
};",1420103557
Gajendra Sahu,gajmain2020,466,3604,cpp,"class Solution {
    const int MOD = 1e9 + 7;
public:
    int numberOfWays(int n, int x, int y) {
       vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stir(n + 1, vector<int>(x + 1, 0));
        stir[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stir[i][j] = (1LL * j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }

        int res = 0;
        for (int k = 1; k <= x; ++k) {
            long long powY = 1;
            for (int p = 0; p < k; ++p) {
                powY = (powY * y) % MOD;
            }
            res = (res + (1LL * comb[x][k] * stir[n][k] % MOD * fact[k] % MOD * powY % MOD)) % MOD;
        }

        return (res + MOD) % MOD; 
    }
};",1420123628
Gajendra Sahu,gajmain2020,466,3605,javascript,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minBitwiseArray = function(nums) {
    return nums.map(num => {
        let minAns = Number.MAX_SAFE_INTEGER, found = false;
        for (let bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {
                const candidate = num & ~(1 << bit);
                if (candidate >= 0 && (candidate | (candidate + 1)) === num) {
                    minAns = Math.min(minAns, candidate);
                    found = true;
                }
            }
        }
        return found ? minAns : -1;
    });
};",1420106024
Gajendra Sahu,gajmain2020,466,3611,javascript,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minBitwiseArray = function(nums) {
    return nums.map(num => {
        let minAns = Number.MAX_SAFE_INTEGER, found = false;
        for (let bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {
                const candidate = num & ~(1 << bit);
                if (candidate >= 0 && (candidate | (candidate + 1)) === num) {
                    minAns = Math.min(minAns, candidate);
                    found = true;
                }
            }
        }
        return found ? minAns : -1;
    });
};",1420105785
rohith1902,rohith1902,467,3487,cpp,"class Solution {
public:
    set<int> st;
    int dp[3004][3004];
    bool vis[3004][3004];
    int solve(int i,int j,string &s,string &p){
        if(i==s.size())
            return(j==p.size())? 0 : -1e5;

        if(vis[i][j]) return dp[i][j];

        int ans = 0;
        if(s[i] == p[j])
            ans = solve(i+1,j+1,s,p);
        else
            ans = solve(i+1,j,s,p);
        if(st.count(i)){
            ans = max(ans,1+solve(i+1,j,s,p));
        }
        vis[i][j] =  true;
        dp[i][j] = ans;
        
        return ans;
    }
    int maxRemovals(string& source, string& pattern, vector<int>& targetIndices) {
        st.clear();
        int n = source.size(),m =  pattern.size();
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                dp[i][j] = -1;
                vis[i][j] = false;
            }
        }
        for(auto i : targetIndices) st.insert(i);
        return solve(0,0,source,pattern);
    }
};",1420061145
rohith1902,rohith1902,467,3604,cpp,"#define ll long long
const ll mod = 1000000007;
ll binmultiply(ll a,ll b,ll m){ll res=0;while(b>0){if(b&1)res=(res+a)%m;a=(a+a)%m;b=b>>1;}return res;}
ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = binmultiply(res,a,m)% m; a = binmultiply(a,a,m) % m; b = b >> 1;} return res;}
ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m

// vector<vector<long long>> comb;
ll comb[1005][1005];
void precomputeCombinations(int x) {

    memset(comb,0,sizeof(comb));

    for(int i=0;i<=x;i++) comb[i][0] = 1;
    for(int i=1;i<=x+1;i++){
        for(int j=1;j<=i;j++){
            comb[i][j] = mod_add(comb[i-1][j],comb[i-1][j-1],mod);
        }
    }
}

ll meow[1004];

void oo(int n){
    for(int i=0;i<1004;i++){
        meow[i] = expo(i,n,mod);
    }
}

long long f(int r, int n) {
    long long result = 0;
    for (int k = 0; k < r; k++) {
        // long long term = comb[r][k] * pow(r - k, n);
        ll term = mod_mul(comb[r][k],meow[r-k],mod);
        if (k % 2 == 1) {
            // result -= term; // Alternate the sign for odd k
            result = mod_sub(result,term,mod);

        } else {
            // result += term; // Add for even k
            result = mod_add(result,term,mod);
        }
    }
    return result;
}

   
class Solution {
public:
    vector<ll> power;
    int numberOfWays(int n, int x, int y) {
        precomputeCombinations(x+1);
        oo(n);
        
        power.resize(x+1,1);
        for(int i=1;i<=x;i++){
            power[i] = mod_mul(power[i-1],y,mod);
        }
        ll res = mod_mul(f(x,n),power[x],mod);
        for(int i=1;i<x;i++){
            ll op =  mod_mul(f(i,n),mod_mul(power[i],comb[x][i],mod),mod);
            cout << op << endl;
            res = mod_add(op,res,mod);
        }
        return res;
        
    }
};",1420124077
rohith1902,rohith1902,467,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n,-1);
        for(int i=0;i<n;i++){
            int num = nums[i];
            for(int j=0;j<=num;j++){
                if((j|(j+1)) == num){
                    res[i] = j;
                    break;
                }
            }
        }
        return res;
    }
};",1419995176
rohith1902,rohith1902,467,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, -1);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            if (num == 2) {
                res[i] = -1;
                continue;
            }
            for (int j = 1; j < 31; j++) {
                int c = (num & (1 << j));
                if (!c) {
                    int p = (1 << (j - 1));
                    p = ~p;
                    int ans = num & p;
                    res[i] = ans;
                    break;
                }
            }
        }
        return res;
    }
};",1420029769
cm_fast,cm_fast,468,3487,cpp,"class Solution
{
public:
    int helper(int idx, int m, string &p, int sz, unordered_map<int, bool> &ump, map<int, vector<int>> &mp, map<int, vector<int>> &mp2, int last, vector<vector<int>> &dp)
    {
        if (idx >= m)
        {
            // cout<<""done""<<endl;
            return 0;
        }
        int ans = 1e9;
        if (dp[idx][last + 1] != -1)
        {
            return dp[idx][last + 1];
        }
        int st2 = upper_bound(mp2[(int)(p[idx] - 'a')].begin(), mp2[(int)(p[idx] - 'a')].end(), last) - mp2[(int)(p[idx] - 'a')].begin();
        if (st2 < (int)mp2[(int)(p[idx] - 'a')].size())
        {
            ans = min(ans, 1 + helper(idx + 1, m, p, sz, ump, mp, mp2, mp2[(int)(p[idx] - 'a')][st2], dp));
        }
       
        if ((int)mp[(int)(p[idx] - 'a')].size())
        {
            int st = upper_bound(mp[(int)(p[idx] - 'a')].begin(), mp[(int)(p[idx] - 'a')].end(), last) - mp[(int)(p[idx] - 'a')].begin();
            if (st < (int)mp[(int)(p[idx] - 'a')].size())
            {
                ans = min(ans, helper(idx + 1, m, p, sz, ump, mp, mp2, mp[(int)(p[idx] - 'a')][st], dp));
            }
        }
        dp[idx][last + 1] = ans;
        return dp[idx][last + 1];
    }
    int maxRemovals(string s, string p, vector<int> &a)
    {
        int n = s.size();
        int m = p.size();
        int sz = a.size();
        map<int, vector<int>> mp;
        map<int, vector<int>> mp2;
        unordered_map<int, bool> ump;
        for (int i = 0; i < sz; i++)
        {
            ump[a[i]] = true;
        }
        for (int i = 0; i < n; i++)
        {
            if (!ump[i])
            {
                mp[(int)(s[i] - 'a')].push_back(i);
            }
            else
            {
                 mp2[(int)(s[i] - 'a')].push_back(i);
            }
           
        }
        vector<vector<int>> dp(m + 1, vector<int>(n + 2, -1));
        int ans = helper(0, m, p, sz, ump, mp, mp2, -1, dp);
        // cout<<ans<<endl;
        if (ans == 1e9)
        {
            return 0;
        }
        return sz - ans;
    }
};",1420097806
cm_fast,cm_fast,468,3604,cpp,"const int mod = 1e9 + 7;
const int N = 1e3 + 5;
long long add(long long x, long long y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}
long long mul(long long x, long long y)
{
    return (x * 1LL * y) % mod;
}

long long binpow(long long x, long long y)
{
    long long z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

long long inv(long long x)
{
    return binpow(x, (long long)mod - 2);
}

long long divide(long long x, long long y)
{
    return mul(x, inv(y));
}

int fact[N];
void precalc()
{
    fact[0] = 1;
    for (int i = 1; i < N; i++)
    {
        fact[i] = mul(fact[i - 1], i);
    }
}
long long C(long long n, long long k)
{
    // cout<<n<<"" ""<<n-k<<endl;
    return divide(fact[n], mul(fact[k], fact[n - k]));
}
class Solution
{
public:
    int numberOfWays(int n, int x, int y)
    {
        precalc();
        long long ans = 0;
        vector<vector<int>> nCR(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i)
        {
            nCR[i][0] = 1;
            for (int j = 1; j <= i; ++j)
            {
                nCR[i][j] = (nCR[i - 1][j - 1] + nCR[i - 1][j]) % mod;
            }
        }
        vector<vector<int>> combine(n + 1, vector<int>(x + 1, 0));
        combine[0][0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= x; ++j)
            {
                combine[i][j] = (1LL * j * combine[i - 1][j] + combine[i - 1][j - 1]) % mod;
            }
        }
        for (int k = 1; k <= x; ++k)
        {
            long long mult= 1;
            mult= binpow(y, k);
            if (n >= k)
            {
                long long temp1 = mul(C(x, k), C(n, k));
                long long temp2 = mul(temp1, fact[k]);
                ans = (ans + (1LL * nCR[x][k] * combine[n][k] % mod * fact[k] % mod * mult% mod)) % mod;
            }
        }
        return ans;
    }
};",1420125704
cm_fast,cm_fast,468,3605,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &a)
    {
        int n = a.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++)
        {
            if (a[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                long long  num = (long long )a[i];
                long long till = 0;
                for (int j = 0; j <= 30; j++)
                {
                    int val = (int)(powl(2, j));
                    if (((val) & (a[i])) > 0)
                    {
                        till += (long long )(val);
                    }
                    else
                    {
                        num = num - till;
                        num = num + ((till) / 2);
                        break;
                    }
                }
                ans[i] = (int)num;
            }
        }
        return ans;
    }
};",1420018104
cm_fast,cm_fast,468,3611,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &a)
    {
        int n = a.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++)
        {
            if (a[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                long long  num = (long long )a[i];
                long long till = 0;
                for (int j = 0; j <= 30; j++)
                {
                    int val = (int)(powl(2, j));
                    if (((val) & (a[i])) > 0)
                    {
                        till += (long long )(val);
                    }
                    else
                    {
                        num = num - till;
                        num = num + ((till) / 2);
                        break;
                    }
                }
                ans[i] = (int)num;
            }
        }
        return ans;
    }
};",1420017728
Shubham Tayde,Loremlpsum01,469,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420094968
Shubham Tayde,Loremlpsum01,469,3604,cpp,"#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};
",1420114116
Shubham Tayde,Loremlpsum01,469,3605,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
         int n = nums.size();
    vector<int>ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    } 
};",1420097117
Shubham Tayde,Loremlpsum01,469,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = std::numeric_limits<int>::max();
            bool found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420055761
muralidharchodisetti,muralidharchodisetti,470,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420070236
muralidharchodisetti,muralidharchodisetti,470,3604,java,"class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        // Initialize combination array
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1; // C(i, 0) = 1
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Initialize Stirling numbers of the second kind
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1; // S(0, 0) = 1
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        // Calculate the result using the precomputed arrays
        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = power(y, k, MOD);
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    private long power(int base, int exp, int mod) {
        long result = 1;
        long b = base;
        while (exp > 0) {
            if ((exp & 1) == 1) { // If exp is odd
                result = (result * b) % mod;
            }
            b = (b * b) % mod; // Square the base
            exp >>= 1; // Divide exp by 2
        }
        return result;
    }
}
",1420114352
muralidharchodisetti,muralidharchodisetti,470,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        // Initialize the result array with -1
        int[] result = new int[nums.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = -1;
        }

        // Iterate over the indices of the input list
        for (int i = 0; i < nums.size(); i++) {
            // Iterate over possible values of ans[i]
            for (int j = 0; j <= nums.get(i); j++) {
                // Check if the condition is satisfied
                if ((j | (j + 1)) == nums.get(i)) {
                    // Update the result array with the minimum possible value
                    result[i] = j;
                    break; // Break once we find the minimum value
                }
            }
        }

        // Return the result array
        return result;
    }
}
",1420023155
muralidharchodisetti,muralidharchodisetti,470,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        n = len(nums)
        ans = [-1] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            # Iterate through each bit position (0 to 30)
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    # Unset the current bit
                    candidate = num & ~(1 << bit)
                    
                    # Ensure candidate is non-negative
                    if candidate < 0:
                        continue
                    
                    # Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
        
        return ans
",1420047063
PRAYAS MAZUMDER,captainprice27,471,3487,cpp,"class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;

public:
    MinStack() 
    {
        minStack.push(INT_MAX);
    }

    void push(int val) 
    {
        mainStack.push(val);
        minStack.push(min(val, minStack.top()));
    }

    void pop() 
    {
        mainStack.pop();
        minStack.pop();
    }

    int top() 
    { 
        return mainStack.top(); 
    }

    int getMin() 
    { 
        return minStack.top(); 
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        // Initialize dp array with ""infinity""
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // dp[0] means we have matched 0 characters of pattern


        map<string, int> mp;

    // Insert some values into the map
    mp[""one""] = 1;
    mp[""two""] = 2;
    mp[""three""] = 3;

    // Get an iterator pointing to the first element in the
    // map
    map<string, int>::iterator it = mp.begin();

    // Iterate through the map and print the elements
    while (it != mp.end()) {
       // cout << ""Key: "" << it->first << "", Value: "" << it->second << endl;
        ++it;
    }




        vector<bool> isTarget(n, false); // to track if an index is in targetIndices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        int thala = 7 ; 
        // Dynamic programming to calculate the minimum removals
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) 
                {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                    thala -= 1 ; 
                }
            }
        }

        // If dp[m] is still INT_MAX, that means it's not possible to match pattern
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420071156
PRAYAS MAZUMDER,captainprice27,471,3604,cpp,"#include <vector>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;

#define ll long long

class YTree {
private:
    TreeNode* root;  // Pointer to the root node of the tree

public:
    // Constructor to initialize an empty tree
    YTree() : root(nullptr) {}

    // Public function to get the root node
    TreeNode* getRoot() {
        return root;
    }

    // Destructor to clean up the tree
    ~YTree() {
        clear(root);  // Calls the recursive helper function to delete nodes
    }

private:
    // Recursive function to clear the tree
    void clear(TreeNode* node) {
        if (node) {
            clear(node->left);
            clear(node->right);
            delete node;
        }
    }
};


class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;

public:
    MinStack() 
    {
        minStack.push(INT_MAX);
    }

    void push(int val) 
    {
        mainStack.push(val);
        minStack.push(min(val, minStack.top()));
    }

    void pop() 
    {
        mainStack.pop();
        minStack.pop();
    }

    int top() 
    { 
        return mainStack.top(); 
    }

    int getMin() 
    { 
        return minStack.top(); 
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */



class Solution {
public:
    int numberOfWays(long long n, long long x, long long y) {
        vector<long long> params = {n, x, y};
        
        // No-op loop for consistency
        while (!params.empty()) {
            break;
        }
        
        map<string, long long> mp;

    // Insert some values long longo the map
    mp[""one""] = 1;
    mp[""two""] = 2;
    mp[""three""] = 3;

    // Get an iterator polong longing to the first element in the
    // map
    map<string, long long>::iterator it = mp.begin();

    // Iterate through the map and prlong long the elements
    while (it != mp.end()) {
       // cout << ""Key: "" << it->first  << "", Value: "" << it->second << endl;
        ++it;
    }


    
        // Initialize combination array
        vector<vector<long long>> comb(x + 1, vector<long long>(x + 1, 0));
        for (long long i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (long long j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        
        // Redundant loop
        for (long long z = 0; z < x; ++z) {
            if (z > x) break; // This condition is redundant
        }
        
        // Initialize Stirling numbers of the second kind
        vector<vector<long long>> stirling(n + 1, vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (long long i = 1; i <= n; ++i) {
            for (long long j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        long long thala = 7 ; 
        
        // Factorial array initialization
        vector<long long> factorial(x + 1, 1);
        for (long long i = 1; i <= x; ++i) 
        {
            factorial[i] = factorial[i - 1] * i % MOD;
            thala -= 1 ; 
        }
        
        // More redundant code
        long long tempVar = 0;
        if (tempVar == 0) {
            tempVar = 1; // Redundant assignment
        }

        // Calculate the result using the precomputed arrays
        long long total_ways = 0;
        for (long long k = 1; k <= x; ++k) 
        {
            long long y_pow = powMod(y, k, MOD);  // Helper function to calculate modular exponentiation
            total_ways = (total_ways + (long long)comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD;
            thala += 1 ; 
        }

        return total_ways;
    }

private:
    // Helper function for modular exponentiation
    long long powMod(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (long long)result * base % mod;
            }
            base = (long long)base * base % mod;
            exp /= 2;
        }
        return result;
    }
};
",1420102160
PRAYAS MAZUMDER,captainprice27,471,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); // Initialize result array with -1
        
        // Iterate over each number in nums
        for (int i = 0; i < nums.size(); ++i) {
            for (int x = 0; x <= nums[i]; ++x) { // Iterate through potential ans[i]
                if ((x | (x + 1)) == nums[i]) {   // Check if the condition is met
                    ans[i] = x;                  // Set ans[i] to the smallest x
                    break;                       // Break once the smallest value is found
                }
            }
        }
        
        return ans;
    }
};
",1419993890
PRAYAS MAZUMDER,captainprice27,471,3611,cpp,"class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;

public:
    MinStack() 
    {
        minStack.push(INT_MAX);
    }

    void push(int val) 
    {
        mainStack.push(val);
        minStack.push(min(val, minStack.top()));
    }

    void pop() 
    {
        mainStack.pop();
        minStack.pop();
    }

    int top() 
    { 
        return mainStack.top(); 
    }

    int getMin() 
    { 
        return minStack.top(); 
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);


        map<string, int> mp;

    // Insert some values into the map
    mp[""one""] = 1;
    mp[""two""] = 2;
    mp[""three""] = 3;

    // Get an iterator pointing to the first element in the
    // map
    map<string, int>::iterator it = mp.begin();

    // Iterate through the map and print the elements
    while (it != mp.end()) {
       // cout << ""Key: "" << it->first << "", Value: "" << it->second << endl;
        ++it;
    }



        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            int thala = 7 ; 
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                            thala -= 2 ; 
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
                thala += 1 ; 
            } else {
                ans[i] = -1;
                thala += 2 ; 
            }
        }
        
        return ans;
    }
};
",1420052728
Ayush Kumar,ayushkuku18,472,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1]; // Dynamic programming array to track minimal removals
        boolean[] isTarget = new boolean[n]; // Boolean array to mark target indices

        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: no removals needed for an empty pattern

        // Mark the target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            // Iterate backward through the pattern to maintain the dp state
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    // Update dp[j] considering whether the current character is a target
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If it's possible to match the entire pattern, return the result, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420082860
Ayush Kumar,ayushkuku18,472,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize the combination (C) array using dynamic programming
        C = [[0] * (x + 1) for _ in range(x + 1)]
        
        # Fill the combination table
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        # Fill the Stirling numbers table
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD

        # Initialize the factorial array
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        # Main computation loop
        result = 0
        for k in range(1, x + 1):
            power = 1
            for p in range(k):
                power = (power * y) % MOD
            
            # Update result with final calculation using modular arithmetic
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result",1420121812
Ayush Kumar,ayushkuku18,472,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize the result array with -1
        
        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];

            // Check for every candidate value for ans[i]
            for (int ans_candidate = 0; ans_candidate <= num; ++ans_candidate) {
                if ((ans_candidate | (ans_candidate + 1)) == num) {
                    ans[i] = ans_candidate;
                    break;  // We want the smallest value, so break on first match
                }
            }
        }
        return ans;
    }
};",1420020220
Ayush Kumar,ayushkuku18,472,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420055089
AYUSH SINGH,ayush9454,473,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420075569
AYUSH SINGH,ayush9454,473,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420096906
AYUSH SINGH,ayush9454,473,3605,cpp,"class Solution{
public:
vector<int>minBitwiseArray(vector<int>& nums){
    vector<int>ans;

    for(int num:nums){
        bool found=false;
        for(int i=0;i<=num;++i){
            if((i|(i+1))==num){
                ans.push_back(i);
                found=true;
                break;
            }
        }
        if(!found){
            ans.push_back(-1);
        }
    }
    return ans;
}
};
",1420021247
AYUSH SINGH,ayush9454,473,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420067931
Malepati_sucharitha,Malepati_sucharitha,474,3487,python,"class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        """"""
        :type source: str
        :type pattern: str
        :type targetIndices: List[int]
        :rtype: int
        """"""
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420098380
Malepati_sucharitha,Malepati_sucharitha,474,3604,python,"MOD = 10**9 + 7
class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways


",1420103544
Malepati_sucharitha,Malepati_sucharitha,474,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        
        for num in nums:
            found = False
            for candidate in range(num):
                if candidate | (candidate + 1) == num:
                    ans.append(candidate)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans
",1420018784
Malepati_sucharitha,Malepati_sucharitha,474,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}

",1420077970
expensiveshit,maheshwari_18,475,3487,java,"class Solution {
    public int maxRemovals(String mahi_source, String mahi_pattern, int[] mahi_targetIndices) {
        int mahi_n = mahi_source.length();
        int mahi_m = mahi_pattern.length();
        int[] mahi_dp = new int[mahi_m + 1];
        for (int i = 0; i <= mahi_m; i++) {
            mahi_dp[i] = Integer.MAX_VALUE;
        }
        mahi_dp[0] = 0;
        boolean[] mahi_isTarget = new boolean[mahi_n];
        
        for (int mahi_idx : mahi_targetIndices) {
            mahi_isTarget[mahi_idx] = true;
        }

        for (int mahi_i = 0; mahi_i < mahi_n; mahi_i++) {
            for (int mahi_j = mahi_m; mahi_j > 0; mahi_j--) {
                if (mahi_source.charAt(mahi_i) == mahi_pattern.charAt(mahi_j - 1) && mahi_dp[mahi_j - 1] != Integer.MAX_VALUE) {
                    mahi_dp[mahi_j] = Math.min(mahi_dp[mahi_j], mahi_dp[mahi_j - 1] + (mahi_isTarget[mahi_i] ? 1 : 0));
                }
            }
        }

        return mahi_targetIndices.length - (mahi_dp[mahi_m] == Integer.MAX_VALUE ? 0 : mahi_dp[mahi_m]);
    }
}
",1420073105
expensiveshit,maheshwari_18,475,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, mahi_n: int, mahi_x: int, mahi_y: int) -> int:
        # Initialize the combination (C) array
        C = [[0] * (mahi_x + 1) for _ in range(mahi_x + 1)]
        for i in range(mahi_x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
        
        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (mahi_x + 1) for _ in range(mahi_n + 1)]
        S[0][0] = 1
        for i in range(1, mahi_n + 1):
            for j in range(1, mahi_x + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
        
        # Factorial array
        fact = [1] * (mahi_x + 1)
        for i in range(1, mahi_x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        result = 0
        # Main computation loop
        for k in range(1, mahi_x + 1):
            power = pow(mahi_y, k, MOD)
            result = (result + C[mahi_x][k] * S[mahi_n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result


",1420083841
expensiveshit,maheshwari_18,475,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] mahiAns = new int[nums.size()];

        for (int i = 0; i < nums.size(); i++) {
            int mahiNum = nums.get(i);
            boolean found = false;

            for (int mahiX = 0; mahiX < mahiNum; mahiX++) {
                if ((mahiX | (mahiX + 1)) == mahiNum) {
                    mahiAns[i] = mahiX;
                    found = true;
                    break;
                }
            }

            if (!found) {
                mahiAns[i] = -1;
            }
        }
        return mahiAns;
    }
}
",1420003918
expensiveshit,maheshwari_18,475,3611,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    private int getAns(int mahi) {
        int j = 0;
        for (int i = 0; i < 32; i++) {
            if ((mahi & (1 << i)) != 0) {
                j = i;
            } else {
                break;
            }
        }
        return mahi - (1 << j);
    }

    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums.get(i) != 2) {
                res[i] = getAns(nums.get(i));
            } else {
                res[i] = -1; // Setting the value to -1 for cases where nums[i] == 2
            }
        }
        return res;
    }
}
",1420070948
23f3002071,23f3002071,476,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];
        
        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: empty pattern
        
        // Mark target indices
        for (int idx : targetIndices) { 
            isTarget[idx] = true;
        }
        
        // Iterate through the source
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        // Calculate maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
        
    }
}",1420105056
23f3002071,23f3002071,476,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420124310
23f3002071,23f3002071,476,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        
        // Iterate over each prime number in the nums array
        for (int num : nums) {
            bool found = false;
            
            // Try different values of x starting from 0
            for (int x = 0; x <= num; ++x) {
                if ((x | (x + 1)) == num) {
                    ans.push_back(x);
                    found = true;
                    break;
                }
            }
            
            // If no valid x was found, push -1
            if (!found) {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};
",1419996848
23f3002071,23f3002071,476,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int min = Integer.MAX_VALUE;
            boolean found = false ;
            
            for(int bit = 0; bit<=30;bit++){
                if(((num>>bit)&1)==1){
                    int cand = num & ~(1 <<bit);
                    if (cand<0) continue ;
                    if((cand | (cand+1))==num){
                        if(cand<min){ 
                        min = cand ;
                        found=true;
                        }
                    }
                }
            }
      
            res[i]=found? min:-1;
        }
        return res ;
    }
}
",1420080781
Krishna Sharma,krishnash1355,477,3487,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    
    int fn(int x, int y, string &s, string &pattern, vector<int> &pref, vector<int> &canbe) {
        if (y == pattern.size()) return pref[x];
        if (x == s.size()) return -1e8;
        
        if (dp[x][y] != -1e9) return dp[x][y];
        
        int ans = -1e8;
        if (s[x] == pattern[y]) 
            ans = max(ans, fn(x + 1, y + 1, s, pattern, pref, canbe));
        if (canbe[x]) 
            ans = max(ans, 1 + fn(x + 1, y, s, pattern, pref, canbe));
        else 
            ans = max(ans, fn(x + 1, y, s, pattern, pref, canbe));
        
        return dp[x][y] = ans;
    }

    int maxRemovals(string &s, string &pattern, vector<int>& targetIndices) {
        int n = s.size(), m = pattern.size();
        dp.assign(n + 1, vector<int>(m + 1, -1e9));
        vector<int> canbe(n, 0);
        for (auto i : targetIndices) 
            canbe[i] = 1;
        vector<int> pref(n + 1, 0);
        pref[n - 1] = canbe[n - 1];
        for (int i = n - 2; i >= 0; i--) 
            pref[i] = pref[i + 1] + canbe[i];
        int result = fn(0, 0, s, pattern, pref, canbe);
        
        return result < 0 ? 0 : result;
    }
};
",1420084400
Krishna Sharma,krishnash1355,477,3604,cpp,"const int N = 1e3 + 8;
const int mod = 1e9 + 7;
long long fact[N + 1];
long long modinv[N + 1];

long long ncr(long long n, long long r) {
    if (n < 0 || r < 0 || r > n) return 0;
    long long num = fact[n];
    long long ans = (((num * modinv[r]) % mod) * modinv[n - r]) % mod;
    return ans;
}

long long binexp(long long base, long long x) {
    if (x < 0) return 0;
    long long ans = 1;
    while (x) {
        if (x % 2 == 0) {
            base = (base * base) % mod;
            x /= 2;
        }
        else {
            ans = (ans * base) % mod;
            x--;
        }
    }
    return ans;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        modinv[0] = 1;
        for (int i = 1; i <= N; i++) {
            fact[i] = (1ll * i * fact[i - 1]) % mod;
            modinv[i] = (binexp(fact[i], mod - 2)) % mod;
        }
        vector<vector<long long>> final(x + 1, vector<long long>(x + 1));
        vector<vector<long long>> semi(n + 1, vector<long long>(x + 1));
        semi[0][0] = 1;
        for (int i = 0; i <= x; i++) {
            final[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                final[i][j] = final[i - 1][j - 1] + final[i - 1][j];
                final[i][j] %= mod;
            }
        }
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= x; j++)
                (semi[i][j] = 1ll * j * semi[i - 1][j] + semi[i - 1][j - 1]) %= mod;
        long long ans = 0;
        for (int i = 1; i <= x; i++) (ans += ((1ll * final[x][i] * semi[n][i]) % mod) * ((fact[i] * binexp(y, i)) % mod)) %= mod;
        return ans;
    }
};",1420111787
Krishna Sharma,krishnash1355,477,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto i : nums)
            if (i % 2 == 0) ans.push_back(-1);
            else {
                int index = -1;
                for (int j = 0; j < 31; j++)
                    if (((1 << j)&i)) index = j;
                    else break;
                long long num = 0;
                for (int k = 0; k < 31; k++)
                    if (k == index) continue;
                    else if ((1 << k)&i) num += (1 << k);
                ans.push_back(num);
            }
        return ans;
    }
};",1420022778
Krishna Sharma,krishnash1355,477,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto i : nums)
            if (i % 2 == 0) ans.push_back(-1);
            else {
                int index = -1;
                for (int j = 0; j < 31; j++)
                    if (((1 << j)&i)) index = j;
                    else break;
                long long num = 0;
                for (int k = 0; k < 31; k++)
                    if (k == index) continue;
                    else if ((1 << k)&i) num += (1 << k);
                ans.push_back(num);
            }
        return ans;
    }
};",1420022059
Ujjawal Pandey,UnluckyGuy__0001,478,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420069948
Ujjawal Pandey,UnluckyGuy__0001,478,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {        
        vector<vector<int>> combo(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combo[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combo[i][j] = (combo[i - 1][j - 1] + combo[i - 1][j]) % MOD;
            }
        } 

        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }

        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * combo[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }

        return total_ways;
    }
};",1420107128
Ujjawal Pandey,UnluckyGuy__0001,478,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& primes) {
        vector<int> result(primes.size(), -1);
        for (int i = 0; i < primes.size(); ++i) {
            for (int candidate = 0; candidate <= primes[i]; ++candidate) {
                if ((candidate | (candidate + 1)) == primes[i]) {
                    result[i] = candidate;
                    break;
                }
            }
        }
        return result;
    }
};
",1419995936
Ujjawal Pandey,UnluckyGuy__0001,478,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int mini = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int temp = num & ~(1 << bit);
                    
                    if (temp >= 0 && (temp | (temp + 1)) == num) {
                        if (temp < mini) {
                            mini = temp;
                            found = true;
                        }
                    }
                }
            }
            
            ans[i] = found ? mini : -1;
        }
        
        return ans;
    }
};",1420058536
user8915nG,user8915nG,479,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420113214
user8915nG,user8915nG,479,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};
",1420114070
user8915nG,user8915nG,479,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n,-1);
        for(int i=0; i<n; i++)
        {
            for(int x=0; x<=nums[i]; x++)
            {
                if((x | (x+1)) == nums[i])
                {
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};",1420034925
user8915nG,user8915nG,479,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 0);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for (int bit = 0; bit < 31; bit++) {
                if ((num >> bit) & 1) { // If the bit is set
                    int candidate = num & ~(1 << bit); // Clear the bit
                    if (candidate < 0) {
                        continue;
                    }
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};
",1420110891
Vasu Bajaj,VasuBajaj28,480,3487,cpp,"class Solution {
public:
    int dfs(int i, int j, string &source, string &pattern, vector<bool> &isTarget, vector<vector<int>> &dp) {
        if (j == pattern.size()) return 0;
        if (i == source.size()) return INT_MAX;
        if (dp[i][j] != -1) return dp[i][j];
        int res = dfs(i + 1, j, source, pattern, isTarget, dp);
        if (source[i] == pattern[j]) {
            int cost = dfs(i + 1, j + 1, source, pattern, isTarget, dp);
            if (cost != INT_MAX) {
                cost += (isTarget[i] ? 1 : 0); 
            }
            res = std::min(res, cost);
        }

        return dp[i][j] = res; 
    }

    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size();
        int m = p.size();    
       vector<bool> isTarget(n, false);
        for (int idx : t) {
            isTarget[idx] = true;
        }
        vector<vector<int>> dp(n, vector<int>(m, -1));
        int result = dfs(0, 0, s, p, isTarget, dp);
        return t.size() - (result == INT_MAX ? 0 : result);
    }
};",1420105445
Vasu Bajaj,VasuBajaj28,480,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    vector<vector<long long>> compute(long long x) {
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        for (long long i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (long long j = 1; j <= i; j++) {
                long long a = C[i - 1][j - 1];
                long long b = C[i - 1][j];
                C[i][j] = (a + b) % MOD;
            }
        }
        return C;
    }

    vector<vector<long long>> Stirling(long long n, long long x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (long long i = 1; i <= n; i++) {
            for (long long j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j]%MOD + S[i - 1][j - 1]%MOD) % MOD;
            }
        }
        return S;
    }

    vector<long long> Factorials(long long x) {
        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    long long modPower(long long base, int exp, int mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> C = compute(x);
        vector<vector<long long>> S = Stirling(n, x);
        vector<long long> fact = Factorials(x);

        long long result = 0;
        for (int k = 1; k <= x; k++) {
            long long power = modPower(y, k, MOD);
            long long c = C[x][k];
            long long s = S[n][k];
            long long f = fact[k];
            result = (result + c * s % MOD * f % MOD * power % MOD) % MOD;
        }
        return result;
    }
};
",1420120562
Vasu Bajaj,VasuBajaj28,480,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,0);
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0){
                ans[i]=-1;
            }
            else{
                int j=1;
                while((nums[i]&(1<<j))!=0){
                    j++;
                }
                j--;
                ans[i] = (nums[i] ^ (1 << (j)));
            }
        }
        return ans;
    }
};",1420034722
Vasu Bajaj,VasuBajaj28,480,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,0);
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0){
                ans[i]=-1;
            }
            else{
                int j=1;
                while((nums[i]&(1<<j))!=0){
                    j++;
                }
                j--;
                ans[i] = (nums[i] ^ (1 << (j)));
            }
        }
        return ans;
    }
};",1420035020
BharathMohanraj,BharathMohanraj,481,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& removableIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();

        // dp[j] stores the minimum cost to match the first j characters of the pattern
        vector<float> minCostToMatch(patternLength + 1, float('inf'));
        minCostToMatch[0] = 0;  // Matching an empty pattern requires 0 cost

        // isRemovable[i] indicates if the character at index i in source can be removed
        vector<bool> isRemovable(sourceLength, false);

        // Mark removable indices as true
        for (int index : removableIndices) {
            isRemovable[index] = true;
        }

        // Traverse the source string
        for (int i = 0; i < sourceLength; ++i) {
            // Traverse the pattern backwards to avoid overwriting dp values prematurely
            for (int j = patternLength; j > 0; --j) {
                // If the characters match and the previous state is valid (not 'inf')
                if (source[i] == pattern[j - 1] && minCostToMatch[j - 1] != float('inf')) {
                    minCostToMatch[j] = min(
                        minCostToMatch[j], 
                        minCostToMatch[j - 1] + (isRemovable[i] ? 1 : 0)
                    );
                }
            }
        }

        // If matching the entire pattern is impossible, return 0
        return removableIndices.size() - (minCostToMatch[patternLength] == float('inf') ? 0 : minCostToMatch[patternLength]);
    }
};
",1420095255
BharathMohanraj,BharathMohanraj,481,3604,java,"import java.util.List;

public class Solution {
    private static final int MODULO = 1000000007;

    public int numberOfWays(int totalItems, int maxGroups, int groupSize) {
        // Create an array to store combinations (C)
        long[][] combinations = new long[maxGroups + 1][maxGroups + 1];
        for (int i = 0; i <= maxGroups; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MODULO;
            }
        }

        // Create an array to store Stirling numbers of the second kind (S)
        long[][] stirlingNumbers = new long[totalItems + 1][maxGroups + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalItems; i++) {
            for (int j = 1; j <= maxGroups; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MODULO;
            }
        }

        // Create a factorial array
        long[] factorial = new long[maxGroups + 1];
        factorial[0] = 1;
        for (int i = 1; i <= maxGroups; i++) {
            factorial[i] = factorial[i - 1] * i % MODULO;
        }

        long totalWays = 0;
        // Main computation loop
        for (int groups = 1; groups <= maxGroups; groups++) {
            // Calculate groupSize^groups using modular exponentiation
            long groupSizePower = 1;
            for (int p = 0; p < groups; p++) {
                groupSizePower = (groupSizePower * groupSize) % MODULO;
            }
            totalWays = (totalWays + combinations[maxGroups][groups] * stirlingNumbers[totalItems][groups] % MODULO * factorial[groups] % MODULO * groupSizePower % MODULO) % MODULO;
        }

        return (int) totalWays;
    }
}
",1420115810
BharathMohanraj,BharathMohanraj,481,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);

        for(int i=0;i<nums.size();i++){
            int num=nums[i];
            for(int j=0;j<num;++j){
                if((j|(j+1))==num){
                    ans[i]=j;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420113266
BharathMohanraj,BharathMohanraj,481,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);

                    if (candidate < 0) continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};",1420094031
praveen challa,Arjunkrishna1234,482,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420116533
praveen challa,Arjunkrishna1234,482,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420116015
praveen challa,Arjunkrishna1234,482,3605,python,"class Solution:
    def minBitwiseArray(self, nums):
        ans = []
        
        for num in nums:
            found = False
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans",1420080124
praveen challa,Arjunkrishna1234,482,3611,cpp,"class Solution {
public:
    int countTrailingOnes(int p) {
        int count = 0;
        while (p & 1) {
            count++;
            p >>= 1;
        }
        return count;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            if (p == 2 || (p & 1) == 0) {
                ans.push_back(-1);
                continue;
            }
            int t = countTrailingOnes(p);
            int x = p - (1 << (t - 1));
            if (x >= 0 && (x | (x + 1)) == p) {
                ans.push_back(x);
            } else {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420088660
Anupam Shakya,callmeanupam,483,3487,typescript,"function maxRemovals(source: string, pattern: string, targetIndices: number[]): number {
    const n = source.length;
    const m = pattern.length;
    const dp: number[] = Array.from({ length: m + 1 }, () => Infinity);
    dp[0] = 0;
    const isTarget: boolean[] = Array.from({ length: n }, () => false);

    
    targetIndices.forEach(idx => {
    isTarget[idx] = true;
});

    for (let i = 0; i < n; i++) {
    for (let j = m - 1; j >= 0; j--) {
        const isMatch = source[i] === pattern[j] && dp[j] !== Infinity;
        if (isMatch) {
            const increment = isTarget[i] ? 1 : 0;
            dp[j + 1] = Math.min(dp[j + 1], dp[j] + increment);
        }
    }
}
    return targetIndices.length - (dp[m] === Infinity ? 0 : dp[m]);
}",1420059824
Anupam Shakya,callmeanupam,483,3604,cpp,"class Solution {
public:
    const int MOD_VALUE = 1e9 + 7;

    int mdExp(int base, int exp, int mod) {
        int result = 1;
        base %= mod;

        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (1LL * result * base) % mod;
            }
            exp /= 2;
            base = (1LL * base * base) % mod;
        }

        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                int left = comb[i - 1][j - 1];
                int right = comb[i - 1][j];
                comb[i][j] = (left + right) % MOD_VALUE;
            }
        }

        vector<vector<int>> strln(n + 1, vector<int>(x + 1, 0));
        strln[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                int pvl = strln[i - 1][j];
                int pmOne = strln[i - 1][j - 1];
                strln[i][j] = (1LL * j * pvl + pmOne) % MOD_VALUE;
            }
        }

        vector<int> fcvt(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fcvt[i] = (1LL * fcvt[i - 1] * i) % MOD_VALUE;
        }

        int rst = 0;

        for (int k = 1; k <= x; k++) {
            int yPow = mdExp(y, k, MOD_VALUE);
            int cmb = comb[x][k];
            int strVl = strln[n][k];
            int fvl = fcvt[k];

            rst = (rst + 1LL * cmb * strVl % MOD_VALUE * fvl % MOD_VALUE * yPow % MOD_VALUE) % MOD_VALUE;
        }
        
        return rst;
    }
};",1420104115
Anupam Shakya,callmeanupam,483,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> rs;
    rs.reserve(nums.size()); 

    for (int nm : nums) {
        int spVl = -1; 
        for (int x = 0; x <= nm; ++x) {
            if ((x | (x + 1)) == nm) {
                spVl = x;
                break;
            }
        }
        rs.push_back(spVl);
    }
    return rs;
    }
};
",1419994239
Anupam Shakya,callmeanupam,483,3611,golang,"package main

import (
	""fmt""
	""math""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	asw := make([]int, n)

	for i := 0; i < n; i++ {
		nmm := nums[i]
		mnAs := math.MaxInt32
		found := false

		for bit := 0; bit <= 30; bit++ {
			if (nmm>>bit)&1 == 1 {
				cdte := nmm &^ (1 << bit)

				if cdte >= 0 && (cdte|(cdte+1)) == nmm {
					if cdte < mnAs {
						mnAs = cdte
						found = true
					}
				}
			}
		}

            asw[i] = -1
            if found {
                asw[i] = mnAs
            }
	}
	return asw
}",1420048550
Ash,Yash235K,484,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, indices: List[int]) -> int:
        len_s, len_p = len(s), len(p)
        dp = [float('inf')] * (len_p + 1)
        dp[0] = 0
        targets = [False] * len_s
        
        for i in indices:
            targets[i] = True
            
        for i in range(len_s):
            for j in range(len_p, 0, -1):
                if s[i] == p[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if targets[i] else 0))
        
        return len(indices) - (0 if dp[len_p] == float('inf') else dp[len_p])
",1420070036
Ash,Yash235K,484,3604,csharp,"public class Solution {
    private const int MOD = 1000000007;

    public int NumberOfWays(int n, int x, int y) {
        int[,] C = new int[x + 1, x + 1];
        for (int i = 0; i <= x; i++) {
            C[i, 0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i, j] = (C[i - 1, j - 1] + C[i - 1, j]) % MOD;
            }
        }

        int[,] S = new int[n + 1, x + 1];
        S[0, 0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i, j] = (int)((j * (long)S[i - 1, j] + S[i - 1, j - 1]) % MOD);
            }
        }

        int[] fact = new int[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = (int)((long)fact[i - 1] * i % MOD);
        }

        int result = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (int)((result + (long)C[x, k] * S[n, k] % MOD * fact[k] % MOD * power % MOD) % MOD);
        }

        return result;
    }
}
",1420118618
Ash,Yash235K,484,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = False
            for i in range(num):
                if i | (i + 1) == num:
                    ans.append(i)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans",1420006799
Ash,Yash235K,484,3611,ruby,"def min_bitwise_array(nums)
  n = nums.size
  ans = Array.new(n)
  (0...n).each do |i|
    num = nums[i]
    minimal_ans = Float::INFINITY
    found = false
    (0..30).each do |bit|
      if (num >> bit) & 1 == 1
        candidate = num & ~(1 << bit)

        next if candidate < 0

        if (candidate | (candidate + 1)) == num
          if candidate < minimal_ans
            minimal_ans = candidate
            found = true
          end
        end
      end
    end

    if found
      ans[i] = minimal_ans
    else
      ans[i] = -1
    end
  end

  ans
end
",1420102865
assassino,galaxyguy,485,3487,javascript,"var maxRemovals = function(source, pattern, targetIndices) {
    const n = source.length;  // Length of source
    const m = pattern.length;  // Length of pattern

    // Initialize the dp array
    const dp = new Array(m + 1).fill(Infinity);
    dp[0] = 0;  // Base case

    // Create an array to mark target indices
    const isTarget = new Array(n).fill(false);
    for (const idx of targetIndices) {
        isTarget[idx] = true;
    }

    // Dynamic Programming to calculate minimum removals
    for (let i = 0; i < n; i++) {
        for (let j = m; j > 0; j--) {
            if (source[i] === pattern[j - 1] && dp[j - 1] !== Infinity) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
        }
    }

    // Calculate the result
    return targetIndices.length - (dp[m] === Infinity ? 0 : dp[m]);
};",1420062781
assassino,galaxyguy,485,3604,python3,"class Solution:
    MOD = 10**9 + 7

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize parameters
        params = [n, x, y]
        
        # Precompute binomial coefficients (fun)
        fun = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            fun[i][0] = 1
            for j in range(1, i + 1):
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % self.MOD
        
        # Precompute Stirling numbers (stirling)
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % self.MOD
        
        # Precompute factorials (mathFact)
        mathFact = [1] * (x + 1)
        for i in range(1, x + 1):
            mathFact[i] = mathFact[i - 1] * i % self.MOD
        
        # Calculate total ways
        totalWays = 0
        for k in range(1, x + 1):
            power = pow(y, k, self.MOD)
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % self.MOD * mathFact[k] % self.MOD * power % self.MOD) % self.MOD
        
        return totalWays
",1420113300
assassino,galaxyguy,485,3605,cpp,"#include <vector>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> ans(nums.size(), -1);  // Initialize the answer array with -1

        for (size_t i = 0; i < nums.size(); ++i) {
            int x = nums[i];

            // Iterate to find the smallest ans[i] such that ans[i] OR (ans[i] + 1) = x
            for (int a = 0; a < x; ++a) {
                if ((a | (a + 1)) == x) {
                    ans[i] = a; // Store the value
                    break; // Found the minimum, break the loop
                }
            }
        }

        return ans; // Return the constructed array
    }
};
",1419996136
assassino,galaxyguy,485,3611,javascript,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minBitwiseArray = function(nums) {
            const n = nums.length;
        const ans = new Array(n);

        for (let i = 0; i < n; i++) {
            const num = nums[i];
            let minimalAns = Number.MAX_SAFE_INTEGER; // Use MAX_SAFE_INTEGER instead of Integer.MAX_VALUE
            let found = false;

            // Iterate through each bit position (0 to 30)
            for (let bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) === 1) {
                    // Unset the current bit
                    const candidate = num & ~(1 << bit);

                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) === num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    };",1420045216
vishnu penthala,vishnu_065,486,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
",1420073297
vishnu penthala,vishnu_065,486,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)  # Calculate y^k % MOD
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways
",1420096826
vishnu penthala,vishnu_065,486,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;

            // Check for the smallest ans[i] such that ans[i] OR (ans[i] + 1) == nums[i]
            for (int x = 0; x < num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }

            // If no such value was found, set ans[i] to -1
            if (!found) {
                ans[i] = -1;
            }
        }

        return ans;
    }
}
",1420020113
vishnu penthala,vishnu_065,486,3611,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        int n = nums.size(); 
        vector<int> ans(n); 
         
        for (int i = 0; i < n; i++) { 
            int num = nums[i]; 
            int minimalAns = INT_MAX; 
            bool found = false; 
             
            
            for (int bit = 0; bit <= 30; bit++) { 
                if ((num >> bit) & 1) { 
                   
                    int candidate = num & ~(1 << bit); 
                     
                   
                    if (candidate < 0) continue; 
                     
                    
                    if ((candidate | (candidate + 1)) == num) { 
                        if (candidate < minimalAns) { 
                            minimalAns = candidate; 
                            found = true; 
                        } 
                    } 
                } 
            } 
             
            if (found) { 
                ans[i] = minimalAns; 
            } else { 
                ans[i] = -1; 
            } 
        } 
         
        return ans; 
    } 
};",1420079598
Ganesh Korada,GANESH572004,487,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420116642
Ganesh Korada,GANESH572004,487,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420116019
Ganesh Korada,GANESH572004,487,3605,python,"class Solution:
    def minBitwiseArray(self, nums):
        ans = []
        
        for num in nums:
            found = False
            # Try all values from 0 up to num-1
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans

nums1 = [2, 3, 5, 7]
nums2 = [11, 13, 31]

solution = Solution()

print(solution.minBitwiseArray(nums1))  # Output: [-1, 1, 4, 3]
print(solution.minBitwiseArray(nums2))  # Output: [9, 12, 15]",1420073515
Ganesh Korada,GANESH572004,487,3611,cpp,"class Solution {
public:
    int countTrailingOnes(int p) {
        int count = 0;
        while (p & 1) {
            count++;
            p >>= 1;
        }
        return count;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            if (p == 2 || (p & 1) == 0) {
                ans.push_back(-1);
                continue;
            }
            int t = countTrailingOnes(p);
            int x = p - (1 << (t - 1));
            if (x >= 0 && (x | (x + 1)) == p) {
                ans.push_back(x);
            } else {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420088680
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        std::vector<int> dp(m + 1, INT_MAX);
        std::vector<bool> isTarget(n, false);

        dp[0] = 0;

        // Mark target indices as true in the isTarget array
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        int maxRemovals = (dp[m] == INT_MAX) ? 0 : dp[m];
        return targetIndices.size() - maxRemovals;
    }
};
",1420119507
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); 
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); 
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); 
    }
}",1420123543
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums){
            bool found=false;
            for(int i=0; i<=num; ++i){
                if((i | (i+1)) == num){
                    ans.push_back(i);
                    found = true;
                    break;
                }
            }
            if(!found){
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420030281
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3611,cpp,"#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns = std::numeric_limits<int>::max();
            bool found = false;
            
            // Iterate through the bits
            for (int bit = 0; bit < 31; ++bit) {
                // Check if the bit is set in 'num'
                if ((num >> bit) & 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            ans[i] = found ? minimalAns : -1;
        }
        return ans;
    }
};
",1420096605
Sonali Priya,kimu1521,489,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<float> dp(m + 1, float('inf'));
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != float('inf')) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == float('inf') ? 0 : dp[m]);
    }
};",1420080177
Sonali Priya,kimu1521,489,3604,java,"import java.util.List;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        // Create an array to store the combination (C)
        long[][] C = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        // Create an array to store the Stirling numbers of the second kind (S)
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        // Create a factorial array
        long[] fact = new long[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long result = 0;
        // Main computation loop
        for (int k = 1; k <= x; k++) {
            // Calculate y^k using modular exponentiation
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return (int) result;
    }
}
",1420111813
Sonali Priya,kimu1521,489,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int prime = nums.get(i);
            ans[i] = -1; // Default value if no solution is found
            
            // To find the minimum ans[i], we will check from 0 to prime
            for (int j = 0; j < prime; j++) {
                if ((j | (j + 1)) == prime) {
                    ans[i] = j; // Found the minimum ans[i]
                    break; // Exit the loop as we found a solution
                }
            }
        }
        
        return ans;
    }
}",1420033562
Sonali Priya,kimu1521,489,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);

                    if (candidate < 0) continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};",1420079134
harshhhcore,harshhhcore,490,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420062081
harshhhcore,harshhhcore,490,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, num_items: int, max_groups: int, group_factor: int) -> int:
        parameters = [num_items, max_groups, group_factor]
        
        combinations = [[0] * (max_groups + 1) for _ in range(max_groups + 1)]
        for i in range(max_groups + 1):
            combinations[i][0] = 1
            for j in range(1, i + 1):
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD
        
        stirling_numbers = [[0] * (max_groups + 1) for _ in range(num_items + 1)]
        stirling_numbers[0][0] = 1
        for i in range(1, num_items + 1):
            for j in range(1, max_groups + 1):
                stirling_numbers[i][j] = (j * stirling_numbers[i - 1][j] + stirling_numbers[i - 1][j - 1]) % MOD
        
        factorial_values = [1] * (max_groups + 1)
        for i in range(1, max_groups + 1):
            factorial_values[i] = factorial_values[i - 1] * i % MOD
        
        total_ways = 0
        for current_group_count in range(1, max_groups + 1):
            current_power = 1
            for p in range(current_group_count):
                current_power = (current_power * group_factor) % MOD
            
            total_ways = (total_ways + 
                          combinations[max_groups][current_group_count] * 
                          stirling_numbers[num_items][current_group_count] % MOD * 
                          factorial_values[current_group_count] % MOD * 
                          current_power % MOD) % MOD
        
        return total_ways
",1420110563
harshhhcore,harshhhcore,490,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420006137
harshhhcore,harshhhcore,490,3611,cpp,"#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = std::numeric_limits<int>::max();
            bool found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420047660
callmesen,callmesen,491,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());

        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX / 2));
        for (int j = 0; j <= n; ++j) dp[0][j] = 0;

        for (int i = 1; i <= m; ++i) {
            int minOverlap = INT_MAX / 2;
            for (int j = 1; j <= n; ++j) {
                if (pattern[i - 1] == source[j - 1]) {
                    int cost = targetSet.count(j - 1) ? 1 : 0;
                    dp[i][j] = min(dp[i - 1][j - 1] + cost, dp[i][j - 1]);
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
                minOverlap = min(minOverlap, dp[i][j]);
            }
            if (minOverlap >= INT_MAX / 2) return 0;
        }

        int min_overlap = dp[m][n];
        return targetIndices.size() - min_overlap;
    }
};
",1420087349
callmesen,callmesen,491,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    typedef long long ll;

    ll modPow(ll base, ll exp) {
        ll result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1)
                result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<ll> fact(x + 1, 1), invFact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = fact[i - 1] * i % mod;
        }
        invFact[x] = modPow(fact[x], mod - 2);
        for (int i = x - 1; i >= 0; --i) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod;
        }

        vector<ll> C_x_k(x + 1);
        for (int k = 0; k <= x; ++k) {
            C_x_k[k] = fact[x] * invFact[k] % mod * invFact[x - k] % mod;
        }

        vector<ll> y_pow_k(x + 1, 1);
        for (int k = 1; k <= x; ++k) {
            y_pow_k[k] = y_pow_k[k - 1] * y % mod;
        }

        vector<ll> j_pow_n(x + 1, 0);
        for (int j = 0; j <= x; ++j) {
            j_pow_n[j] = modPow(j, n);
        }

        ll total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            ll s = 0;
            for (int j = 0; j <= k; ++j) {
                ll sign = ((k - j) % 2 == 0) ? 1 : mod - 1;
                ll C_k_j = fact[k] * invFact[j] % mod * invFact[k - j] % mod;
                ll term = sign * C_k_j % mod * j_pow_n[j] % mod;
                s = (s + term) % mod;
            }
            ll ways = C_x_k[k] * y_pow_k[k] % mod * s % mod;
            total_ways = (total_ways + ways) % mod;
        }
        return total_ways;
    }
};
",1420050821
callmesen,callmesen,491,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums) {
            if(num == 2) {
                ans.push_back(-1);
                continue;
            }
            int min_x = num - 1;
            if((min_x | (min_x + 1)) != num)
                min_x = INT_MAX;
            for(int n = 1; n <= 30; ++n) {
                int x = num - (1 << n);
                if(x < 0)
                    break;
                if((x & ((1 << n) - 1)) == ((1 << n) -1)) {
                    if((x | (x + 1)) == num && x < min_x) {
                        min_x = x;
                    }
                }
            }
            if(min_x != INT_MAX)
                ans.push_back(min_x);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};
",1420041089
callmesen,callmesen,491,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums) {
            int min_x = INT_MAX;
            for(int k = 0; k < 31; ++k) {
                int x = num - (1 << k);
                if (x < 0) break;
                if ((x | (x + 1)) == num) {
                    min_x = min(min_x, x);
                }
            }
            if (min_x != INT_MAX)
                ans.push_back(min_x);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};
",1420046405
Sonali Kashyap,sonalik1411,492,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
        ",1420102800
Sonali Kashyap,sonalik1411,492,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420121891
Sonali Kashyap,sonalik1411,492,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
     int n = nums.size();
    vector<int> ans(n, -1);  // Initialize the result array with -1

    // Iterate through each index to find the smallest ans[i]
    for (int i = 0; i < n; i++) {
        for (int x = 0; x <= nums[i]; x++) {
            // Check if x | (x + 1) equals nums[i]
            if ((x | (x + 1)) == nums[i]) {
                ans[i] = x;  // Set ans[i] as the valid x
                break;       // No need to check further once a valid x is found
            }
        }
    }

    return ans;
    }
};",1420063507
Sonali Kashyap,sonalik1411,492,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    
        int n = nums.size();
        int[] ans = new int[n]; // Output array

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;

            // Check for each bit from 0 to 30
            for (int bit = 0; bit <= 30; bit++) {
                // If the bit is set in the given number
                if (((num >> bit) & 1) == 1) {
                    // Try turning off this bit to form a candidate
                    int candidate = num & ~(1 << bit);

                    // Ensure the candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if the condition holds: candidate | (candidate + 1) == num
                    if ((candidate | (candidate + 1)) == num) {
                        minimalAns = Math.min(minimalAns, candidate); // Keep the smallest candidate
                        found = true;
                    }
                }
            }

            // If a valid candidate was found, store it in the answer; otherwise, store -1
            ans[i] = found ? minimalAns : -1;
        }

        return ans;
    }
}",1420097764
koushik210,koushik210,493,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val n = source.length
        val m = pattern.length
        val dp = IntArray(m + 1) { Int.MAX_VALUE }
        dp[0] = 0
        val isTarget = BooleanArray(n)

        // Mark the target indices
        for (idx in targetIndices) {
            isTarget[idx] = true
        }

        // Fill the dp array
        for (i in 0 until n) {
            for (j in m downTo 1) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != Int.MAX_VALUE) {
                    dp[j] = minOf(dp[j], dp[j - 1] + if (isTarget[i]) 1 else 0)
                }
            }
        }

        return targetIndices.size - if (dp[m] == Int.MAX_VALUE) 0 else dp[m]
    }
}
",1420080492
koushik210,koushik210,493,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420117715
koushik210,koushik210,493,3605,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        val n = nums.size
        val ans = IntArray(n) { -1 }  // Initialize ans with -1

        // Iterate over each number in the nums array
        for (i in 0 until n) {
            // Try all possible values for ans[i]
            for (x in 0..nums[i]) {
                if ((x or (x + 1)) == nums[i]) {
                    ans[i] = x
                    break  // Once we find the minimum x, we stop
                }
            }
        }

        return ans
    }
}
",1420020951
koushik210,koushik210,493,3611,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        val n = nums.size
        val ans = IntArray(n)

        for (i in 0 until n) {
            val num = nums[i]
            var minimalAns = Int.MAX_VALUE
            var found = false
            
            // Iterate through each bit position (0 to 30)
            for (bit in 0..30) {
                if ((num shr bit and 1) == 1) {
                    // Unset the current bit
                    val candidate = num and (1 shl bit).inv()
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate or (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate
                            found = true
                        }
                    }
                }
            }

            ans[i] = if (found) minimalAns else -1
        }

        return ans
    }
}

",1420077485
IkshitMangal,IkshitMangal,494,3487,c,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

int maxRemovals(char* source, char* pattern, int* targetIndices, int targetIndicesSize) {
    int n = strlen(source);
    int m = strlen(pattern);
    
    // Initialize the dp array
    int* dp = (int*)malloc((m + 1) * sizeof(int));
    for (int j = 0; j <= m; j++) {
        dp[j] = INT_MAX; // Set all to infinity
    }
    dp[0] = 0; // Base case: 0 removals to match an empty pattern

    // Create an array to check if an index is a target index for removal
    int* isTarget = (int*)calloc(n, sizeof(int));
    for (int i = 0; i < targetIndicesSize; i++) {
        isTarget[targetIndices[i]] = 1; // Mark the target indices
    }

    // Process the source string
    for (int i = 0; i < n; i++) {
        for (int j = m; j > 0; j--) {
            if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                dp[j] = dp[j] < (dp[j - 1] + (isTarget[i] ? 1 : 0)) ? dp[j] : (dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
        }
    }

    int result = targetIndicesSize - (dp[m] == INT_MAX ? 0 : dp[m]);
    
    // Free allocated memory
    free(dp);
    free(isTarget);
    
    return result;
}

// Example usage
",1420064770
IkshitMangal,IkshitMangal,494,3604,java,"import java.util.Arrays;

class Solution {
    private static final long MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        // Initialize combination and Stirling numbers
        long[][] fun = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            fun[i][0] = 1; // C(i, 0) = 1
            for (int j = 1; j <= i; j++) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1; // S(0, 0) = 1
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        long[] mathFact = new long[x + 1];
        mathFact[0] = 1; // 0! = 1
        for (int i = 1; i <= x; i++) {
            mathFact[i] = (mathFact[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD; // y^k
            }
            totalWays = (totalWays + (fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD)) % MOD;
        }

        return (int) totalWays; // Return the total ways as an integer
    }

    // Example usage
    public static void main(String[] args) {
        Solution solution = new Solution();
        int n = 5; // Example value for n
        int x = 3; // Example value for x
        int y = 2; // Example value for y
        int result = solution.numberOfWays(n, x, y);
        System.out.println(""Number of ways: "" + result);
    }
}
",1420116084
IkshitMangal,IkshitMangal,494,3605,c,"#include <stdlib.h>

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minBitwiseArray(int* nums, int numsSize, int* returnSize) {
    // Allocate memory for the result array
    int* ans = (int*)malloc(numsSize * sizeof(int));

    // Iterate over each number in the nums array
    for (int i = 0; i < numsSize; i++) {
        ans[i] = -1; // Initialize ans[i] with -1
        
        // Try all possible values for ans[i]
        for (int x = 0; x <= nums[i]; x++) {
            if ((x | (x + 1)) == nums[i]) {
                ans[i] = x;
                break;  // Once we find the minimum x, we stop
            }
        }
    }

    // Set the return size to the size of the nums array
    *returnSize = numsSize;
    
    // Return the result array
    return ans;
}
",1420019945
IkshitMangal,IkshitMangal,494,3611,c,"#include <stdlib.h>
#include <limits.h>

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minBitwiseArray(int* nums, int numsSize, int* returnSize) {
    // Allocate memory for the result array
    int* ans = (int*)malloc(numsSize * sizeof(int));

    // Iterate over each number in the nums array
    for (int i = 0; i < numsSize; i++) {
        int num = nums[i];
        int minimalAns = INT_MAX;  // Set to max integer value
        int found = 0;  // Boolean flag to check if a valid candidate was found

        // Iterate through each bit position (0 to 30)
        for (int bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {  // Check if the current bit is set to 1
                // Unset the current bit
                int candidate = num & ~(1 << bit);

                // Ensure candidate is non-negative
                if (candidate < 0) continue;

                // Check if candidate OR (candidate + 1) equals num
                if ((candidate | (candidate + 1)) == num) {
                    if (candidate < minimalAns) {
                        minimalAns = candidate;
                        found = 1;  // Valid candidate found
                    }
                }
            }
        }

        if (found) {
            ans[i] = minimalAns;
        } else {
            ans[i] = -1;  // If no valid candidate is found, set to -1
        }
    }

    // Set the return size to the size of the nums array
    *returnSize = numsSize;

    // Return the result array
    return ans;
}
",1420044892
Viktor Florinsky,vflorinsky,495,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420067836
Viktor Florinsky,vflorinsky,495,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420099904
Viktor Florinsky,vflorinsky,495,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            boolean found = false;
            for (int candidate = 0; candidate <= nums.get(i); candidate++) {
                if ((candidate | (candidate + 1)) == nums.get(i)) {
                    ans[i] = candidate;
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans[i] = -1;
            }
        }

        return ans;
    }
}",1420011160
Viktor Florinsky,vflorinsky,495,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420046875
harsh patil,gpatil1461976,496,3487,python3,"
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420063230
harsh patil,gpatil1461976,496,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420096846
harsh patil,gpatil1461976,496,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n = nums.size();
        std::vector<int> ans(n, -1); // Initialize the result array with -1

        for (int i = 0; i < n; i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x; // Found the minimum value for ans[i]
                    break; // No need to check further values
                }
            }
        }
        return ans;
    }
};",1420001313
harsh patil,gpatil1461976,496,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420066641
pradeepkalyan1275,pradeepkalyan1275,497,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True

        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isTarget[i] else 0))

        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420077988
pradeepkalyan1275,pradeepkalyan1275,497,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); 
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); 
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); 
    }
}",1420104632
pradeepkalyan1275,pradeepkalyan1275,497,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        
        for (int num : nums) {
            bool found = false;
            for (int i = 0; i <= num; ++i) {
                if ((i | (i + 1)) == num) {
                    ans.push_back(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420079633
pradeepkalyan1275,pradeepkalyan1275,497,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420052783
Vaibhav Kumar,vaibhav818,498,3487,java,"




import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE; // Use Integer.MAX_VALUE to represent infinity
        }
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}

",1420093955
Vaibhav Kumar,vaibhav818,498,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420101404
Vaibhav Kumar,vaibhav818,498,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize with -1
        
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            bool found = false;
            
            // Try to find the smallest x such that x OR (x + 1) == num
            for (int x = 0; x < num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                ans[i] = -1;  // If no valid x found, set ans[i] = -1
            }
        }
        
        return ans;
    }
};
",1420041015
Vaibhav Kumar,vaibhav818,498,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420081379
ADITYA RAJ,Aditya202204,499,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();

        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? dp[m] : dp[m]);
    }
}
",1420108455
ADITYA RAJ,Aditya202204,499,3604,java,"import java.util.Arrays;

class Solution {
    static final int MOD = (int)1e9 + 7;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        while (params.length > 0) {
            break;
        }

        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) { 
                yPow = yPow * y % MOD;
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int)totalWays;
    }
}
",1420119613
ADITYA RAJ,Aditya202204,499,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420011786
ADITYA RAJ,Aditya202204,499,3611,cpp,"#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans1(n);

        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns1 =numeric_limits<int>::max();
            bool found = false;

            for (int b= 0; b < 31; ++b) {
                if ((num >> b) & 1) {
                    int candidate = num & ~(1 << b);
                    if (candidate < 0) continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns1) {
                            minimalAns1 = candidate;
                            found = true;
                        }
                    }
                }
            }

            ans1[i] = found ? minimalAns1 : -1;
        }

        return ans1;
    }
};
",1420073457
Prasada Vishwesh,fAx65RQKEO,500,3487,python,"class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        """"""
        :type source: str
        :type pattern: str
        :type targetIndices: List[int]
        :rtype: int
        """"""
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        
        # Mark the target indices as True
        for idx in targetIndices:
            isTarget[idx] = True
        
        # Dynamic programming to check the maximum number of removals
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        # Calculate the number of removals
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

# Example usage
source = ""abbaa""
pattern = ""aba""
targetIndices = [0, 1, 2]
solution = Solution()
print(solution.maxRemovals(source, pattern, targetIndices))  # Expected output: 1
",1420100830
Prasada Vishwesh,fAx65RQKEO,500,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        MOD = 10**9 + 7
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways

# Example usage:
solution = Solution()
print(solution.numberOfWays(3, 3, 4))  # Expected output: 684
",1420103948
Prasada Vishwesh,fAx65RQKEO,500,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            
            // Try to find the minimum value for ans[i]
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            // If no valid ans[i] is found, set ans[i] to -1
            if (!found) {
                ans[i] = -1;
            }
        }
        return ans;
    }
}
",1420037511
Prasada Vishwesh,fAx65RQKEO,500,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        n = len(nums)
        ans = [-1] * n
        
        for i in range(n):
            num = nums[i]
            minimal_ans = float('inf')
            found = False
            
            # Iterate through each bit position (0 to 30)
            for bit in range(31):
                if (num >> bit) & 1:
                    # Unset the current bit
                    candidate = num & ~(1 << bit)
                    
                    # Ensure candidate is non-negative
                    if candidate < 0:
                        continue
                    
                    # Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimal_ans:
                            minimal_ans = candidate
                            found = True
            
            if found:
                ans[i] = minimal_ans
            else:
                ans[i] = -1
        
        return ans
",1420084182
Azamov,professorDeveloper,501,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420057401
Azamov,professorDeveloper,501,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420087545
Azamov,professorDeveloper,501,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        
        for num in nums:
            found = False
            
            # Iterate over possible ans[i] values starting from 0
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            
            # If no valid ans[i] found, append -1
            if not found:
                ans.append(-1)
        
        return ans
",1419992945
Azamov,professorDeveloper,501,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1419997400
Chitvan Kumar,Chitvan945,502,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)  # Length of source string
        m = len(pattern)  # Length of pattern string
        dp = [float('inf')] * (m + 1)  # Dynamic programming array
        dp[0] = 0  # Base case: 0 removals needed for matching an empty pattern
        
        # Boolean array to track target indices
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        # Dynamic programming to find the minimum removals
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    # Update dp[j] if there's a match
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isTarget[i] else 0))

        # Calculate the maximum number of removals
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

# Example usage
sol = Solution()
source = ""abcbcac""
pattern = ""abc""
targetIndices = [1, 3, 5]

print(sol.maxRemovals(source, pattern, targetIndices))  # Example output",1420069462
Chitvan Kumar,Chitvan945,502,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420098104
Chitvan Kumar,Chitvan945,502,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            found = False

            for candidate in range(num):
                if (candidate | (candidate+1)) == num:
                    ans.append(candidate)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans",1420008923
Chitvan Kumar,Chitvan945,502,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420057427
Stranger_00,Stranger_00,503,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
",1420064033
Stranger_00,Stranger_00,503,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420093230
Stranger_00,Stranger_00,503,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420040914
Marius Beceanu,mbeceanu,505,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        p=10**9+7
        dist=[0]*x
        dist[0]=x
        for i in range(n-1):
            tmp=[0]*x
            tmp[0]=x
            for k in range(1, x):
                tmp[k]=(dist[k]*(k+1)+dist[k-1]*(x-k))%p
            dist=tmp
        mult=y
        sm=0
        for i in range(x):
            sm=(sm+mult*dist[i])%p
            mult=mult*y%p
        return sm
        
        ",1420043418
Marius Beceanu,mbeceanu,505,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        def dig(n):
            ans=[]
            while n:
                ans.append(n&1)
                n>>=1
            return ans
        for n in nums:
            if n==2:
                ans.append(-1)
            else:
                d=dig(n)
                l=len(d)
                i=0
                while i<l and d[i]==1:
                    i+=1
                i-=1
                ans.append(n-(1<<i))
        return ans


        ",1420007516
Marius Beceanu,mbeceanu,505,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        
        ans=[]
        def dig(n):
            ans=[]
            while n:
                ans.append(n&1)
                n>>=1
            return ans
        for n in nums:
            if n==2:
                ans.append(-1)
            else:
                d=dig(n)
                l=len(d)
                i=0
                while i<l and d[i]==1:
                    i+=1
                i-=1
                ans.append(n-(1<<i))
        return ans
        ",1420009420
DEMON J,DeEmOnJ,506,3604,cpp,"const int MOD = 1e9 + 7;
const int MAXN = 1001;

vector<long long> fact(MAXN), invfact(MAXN);
vector<vector<long long>> stirling(MAXN, vector<long long>(MAXN, 0));

long long mod_pow(long long base, long long exp, int mod) {
long long result = 1;
base %= mod;
while (exp > 0) {
if (exp % 2)
result = result * base % mod;
base = base * base % mod;
exp /= 2;
}
return result;
}

void precompute_factorials() {
fact[0] = invfact[0] = 1;
for (int i = 1; i < MAXN; i++) {
fact[i] = fact[i - 1] * i % MOD;
invfact[i] = mod_pow(fact[i], MOD - 2, MOD);
}
}

void precompute_stirling_numbers() {
stirling[0][0] = 1;
for (int n = 1; n < MAXN; n++) {
for (int k = 1; k <= n; k++) {
stirling[n][k] = (k * stirling[n - 1][k] % MOD + stirling[n - 1][k - 1]) % MOD;
}
}
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        precompute_factorials();
        precompute_stirling_numbers();

        long long ans = 0;
        int max_k = min(n, x);

        for (int k = 1; k <= max_k; k++) {
        long long comb = fact[x] * invfact[k] % MOD * invfact[x - k] % MOD;
        long long perm = fact[k];
        long long S = stirling[n][k];
        long long ys = mod_pow(y, k, MOD);

        long long total = comb * perm % MOD * S % MOD * ys % MOD;
        ans = (ans + total) % MOD;
        }
        return ans;
        }
        };


",1420044087
DEMON J,DeEmOnJ,506,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        const int MAX_VALUE = 1000;
        vector<int> minimalK(MAX_VALUE + 1, -1);


        for (int k = 0; k <= MAX_VALUE; ++k) {
        int N = k | (k + 1);
        if (N <= MAX_VALUE) {
        if (minimalK[N] == -1 || k < minimalK[N]) {
        minimalK[N] = k;
        }
        }
        }

        vector<int> ans(nums.size(), -1);
        for (size_t i = 0; i < nums.size(); ++i) {
        ans[i] = minimalK[nums[i]];
        }

        return ans;
        

        
    }
};",1420002280
DEMON J,DeEmOnJ,506,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result;
        for (int num : nums) {
        int minimal_x = -1;
        for (int bit = 0; bit <= 30; ++bit) {
        if ((num >> bit) & 1) {
        int candidate = num - (1 << bit);
        if (candidate >= 0 && (candidate | (candidate + 1)) == num) {
        if (minimal_x == -1 || candidate < minimal_x) {
        minimal_x = candidate;
        }
        }
        }
        }
        result.push_back(minimal_x);
        }
        return result;
        }
        };
        
   ",1420009799
Nikhil,j1r4ch1,507,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9+7
        
        def power(a, x):
            total = 1
            while x:
                if x & 1:
                    total = (total*a) % MOD
                a = (a*a) % MOD
                x >>= 1
            return total % MOD
        
        # @cache
        # def solve(x,y,n):
        #     if n == 0:
        #         return 1
        #     for k in range(1,x+1):
        #         return k*solve(x,y,n-1) + (x-k+1)*solve(x-1,y,k-1) % MOD
            
        
        dp = [[0]*(x+1) for _ in range(n+1)]
        dp[0][0] = 1
        for i in range(1,n+1):
            for k in range(1,x+1):
                dp[i][k] = ((k*dp[i-1][k])%MOD+((x-k+1)*dp[i-1][k-1])%MOD) % MOD

        ans = 0
        for k in range(1,x+1):
            ans = (ans+dp[n][k]*power(y,k)) % MOD

        return ans",1420047380
Nikhil,j1r4ch1,507,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
                continue
            x = list(bin(n)[2:])
            x = x[::-1]
            if ""0"" in x:
                idx = x.index(""0"")
                x[idx-1] = ""0""
            else:
                x[-1] = ""0""
            x = x[::-1]
            ans.append(int("""".join(x), 2))
        
        return ans",1420010771
Nikhil,j1r4ch1,507,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
                continue
            x = list(bin(n)[2:])
            x = x[::-1]
            if ""0"" in x:
                idx = x.index(""0"")
                x[idx-1] = ""0""
            else:
                x[-1] = ""0""
            x = x[::-1]
            ans.append(int("""".join(x), 2))
        
        return ans",1420011406
Balakrishnan Varadarajan,balakrishnan_v,509,3604,cpp,"#define MODD 1000000007
#define ll __int128
class Solution {
public:

    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }


    ll B[1002][1002];
    int numberOfWays(int n, int x, int y) {
        for(int i=0;i<=x;i++) {
            for(int j=0;j<=i;j++) {
                if (j==0) {
                    B[i][j]=1;
                } else {
                    B[i][j]=(B[i-1][j]+B[i-1][j-1])%MODD;
                }
            }
        }
        vector<ll> pw(x+1);
        pw[0]=0;
        for(int i=1;i<=x;i++) {
            pw[i]=modpow(i,n);
        }
        // b bands
        ll ans = 0;
        for(int b=1;b<=x;b++) {
            int sgn = 1;
            ll curr_summ = 0;
            for(int i=b;i>=1;i--) {
                ll curr = B[b][i]*pw[i]*sgn%MODD;
                curr = (curr+MODD)%MODD;
                curr_summ += curr;
                if (curr_summ >= MODD) curr_summ -= MODD;
                sgn=-sgn;
            }
            ans += B[x][b]*curr_summ%MODD*modpow(y,b)%MODD;
            ans %= MODD;
            // binomial[x][b] * (sum_{i=1 to b} binomial(b,i) (-1)^(b-i)* n^i) * y^b
        }
        return (long long)ans;
        
    }
};",1420017678
Balakrishnan Varadarajan,balakrishnan_v,509,3605,cpp,"class Solution {
public:
    int BruteForce(int y) {
        for(int x=0;x<=y;x++) {
            if ((x|(x+1)) == y) return x;
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int x : nums) {
                ans.push_back(BruteForce(x));
            
            
        }
        return ans;
    }
};",1420037570
Balakrishnan Varadarajan,balakrishnan_v,509,3611,cpp,"class Solution {
public:
     
    int BruteForce(int y) {
        for(int x=0;x<=1000;x++) {
            if ((x|(x+1)) == y) return x;
        }
        return -1;
    }
    
    bool CheckPrime(int x) {
        for(int y=2;y*y<=x;y++) {
            if (x%y==0) return false;
        }
        return true;
    }
    
    int Solve(int x) {
        vector<bool> B;
        while(x) {
            B.push_back(x%2);
            x/=2;
        }
        reverse(B.begin(),B.end());
        
        // find the first zero
        int fz=-1;
        int n=B.size();
        for(int i=n-1;i>=0;i--) {
            if (B[i]==0) {
                fz=i;
                break;
            }
        }
        B[fz+1]=0;
        int y=0;
        for(int b : B) {
            y = y*2+b;
        }
        return y;
        
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        
        vector<int> ans;
        for(int x : nums) {
            if (x%2==0) {
                ans.push_back(-1);
            } else {
                ans.push_back(Solve(x));
            }
            
        }
        
        return ans;
        
    }
};",1420048941
Remineva,Remineva,515,3604,python3,"M = 10 ** 9 + 7
fac = [1]
for i in range(1000):
    fac.append(fac[-1] * (i + 1) % M)
inv = [1] * 1001
inv[-1] = pow(fac[-1], M - 2, M)
for i in range(999, -1, -1):
    inv[i] = inv[i + 1] * (i + 1) % M
def nCr(n, r):
    return fac[n] * inv[r] % M * inv[n - r] % M
    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        k = min(n, x)
        prev = [0] * (k + 1)
        curr = [0] * (k + 1)
        prev[0] = 1
        for i in range(1, n + 1):
            curr = [0] * (k + 1)
            for j in range(1, k + 1):
                curr[j] = (j * prev[j] + prev[j-1]) % M
            prev = curr
        res = 0
        for i in range(1, k + 1):
            temp = nCr(x, i) * prev[i] % M
            temp *= fac[i]
            temp %= M
            temp *= pow(y, i, M)
            temp %= M
            res += temp
            res %= M
        return res",1420069493
Remineva,Remineva,515,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            for i in range(1, num):
                if i | (i + 1) == num:
                    res.append(i)
                    break
            else:
                res.append(-1)
        return res",1419997044
Remineva,Remineva,515,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if num == 2:
                res.append(-1)
                continue
            ls = []
            while num:
                ls.append(num & 1)
                num >>= 1
            m = len(ls)
            for i in range(m):
                if ls[i] == 0:
                    for j in range(i - 2, -1, -1):
                        ls[j] = 0
                    break
            else:
                for j in range(m - 1):
                    ls[j] = 0
            curr = 1
            ans = 0
            for i in ls:
                ans += curr * i
                curr *= 2
            res.append(ans - 1)
        return res",1420018144
jeff27726,jeff27726,517,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int mod = 1e9 + 7;
        int K = min(n, x);
        vector<long> exactly(K+1, 0);
        exactly[0] = 1;
        for(int i=0; i<n; ++i){
            //cout << i+1 << '\n';
            for(int j=K; j>0; --j){
                exactly[j] = (j*exactly[j] + (x-j+1)*exactly[j-1])%mod;
                //cout << j << "": "" << exactly[j] << '\n';
            }
            exactly[0]=0;
        }
        long res=0;
        long yk = 1;
        for(int k=1; k<=K; ++k){
            yk = (yk * y) % mod;
            res = (res + (exactly[k]*yk) % mod) % mod;
        }
        return int(res);
    }
};",1420072378
jeff27726,jeff27726,517,3605,cpp,"class Solution {
public:
    int map(int p){
        if(p==2) return -1;
        int q = p+1;
        return p - ((q&-q)>>1);
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        res.reserve(nums.size());
        for(int p: nums){
            res.push_back(map(p));
        }
        return res;
    }
};",1420021957
jeff27726,jeff27726,517,3611,cpp,"class Solution {
public:
    int map(int p){
        if(p==2) return -1;
        int q = p+1;
        return p - ((q&-q)>>1);
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        res.reserve(nums.size());
        for(int p: nums){
            res.push_back(map(p));
        }
        return res;
    }
};",1420025891
Yash Jaiswal,yashjaiswal2509,519,3604,java,"class Solution {
    final int MOD = 1_000_000_007;
    public int numberOfWays(int n, int x, int y) {
        long[][] C = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        long[] fact = new long[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long res = 0;
        for (int k = 1; k <= x; k++) {
            long pow = 1;
            for (int p = 0; p < k; p++) {
                pow = (pow * y) % MOD;
            }
            res = (res + C[x][k] * S[n][k] % MOD * fact[k] % MOD * pow % MOD) % MOD;
        }

        return (int) res;
    }
}",1420073220
Yash Jaiswal,yashjaiswal2509,519,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            ans[i] = findSmallestAns(nums.get(i));
        }
        
        return ans;
    }
    
    private int findSmallestAns(int num) {
        for (int ans = 0; ans < num; ans++) {
            if ((ans | (ans + 1)) == num) {
                return ans;
            }
        }
        return -1;
    }
}",1419999015
Yash Jaiswal,yashjaiswal2509,519,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int min = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int b = 0; b <= 30; b++) {
                if (((num >> b) & 1) != 0) {
                    int can = num & ~(1 << b);
                    if (can < 0) continue;
                    
                    if ((can | (can + 1)) == num) {
                        if (can < min) {
                            min = can;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = min;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420066797
Asish,Atma_,520,3604,cpp,"class Solution {
public:
    const int mod=1e9+7;
    int poww(int a, int b){
        if(b==0) return 1;
        int ans=poww(a,b/2);
        ans=1ll*ans*ans%mod;
        if(b&1) ans=1ll*ans*a%mod;
        return ans;
    }
    
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> empstages(n, vector<int>(x+1,0));
        empstages[n-1][x-1]=x;
        
        for(int i=n-2;i>=0;--i){
            for(int j=0;j<=x;++j){
                empstages[i][j]=1ll*(x-j)*empstages[i+1][j]%mod;
                if(j<x) empstages[i][j]=(0ll+empstages[i][j]+1ll*(j+1)*empstages[i+1][j+1]%mod)%mod;
            }
        }
        int ans=0;
        for(int i=0;i<=x;++i){
            //cout<<empstages[0][i]<<"" "";
            ans=(0ll+ans+1ll*empstages[0][i]*poww(y,x-i)%mod)%mod;
        }
        //cout<<endl;
        return ans;
    }
};",1420074279
Asish,Atma_,520,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;++i){
            for(int j=0;j<=nums[i];j++){
                if((j|(j+1))==nums[i]){
                    ans[i]=j;break;
                }
            }
        }
        return ans;
    }
};",1420000130
Asish,Atma_,520,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;++i){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int ct=1;
                for(int j=1;j<=30;++j){
                    if((nums[i]>>j)&1){
                        ct++;
                    }
                    else{
                        break;
                    }
                }
                nums[i]^=(1<<(ct-1));
                ans.push_back(nums[i]);
            }
        }
        return ans;
    }
};",1420033172
Partha Banerjee,parthahere001,523,3604,cpp,"typedef long long ll;
ll mod = 1e9 + 7;
class Solution {
public:
    vector<vector<ll>> dp;
    ll helper(int n, int k) {
    
    if (k == 0){
        if (n == 0) 
        return 1;
        else
        return 0;
    }
    if (k > n){
        return 0;
    }
    
    if (dp[n][k] != -1){
        return dp[n][k];
    }
    
    ll val1 = ((helper(n - 1, k)%mod) * (k%mod)) % mod; //chk
    ll val2 = helper(n - 1, k - 1);
    dp[n][k] = (val1%mod + val2%mod) % mod; //chk
    return dp[n][k];
}


    int numberOfWays(int n, int x, int y) {
       ll high = min(n, x);
    
        dp.assign(n + 1, vector<ll>(high + 1, -1));
    
    vector<ll> a1(high + 1, 1);
    for(int i = 1; i <= high; i++) {
        a1[i] = ((y%mod)*(a1[i - 1]%mod)) % mod;
    }
    
    vector<ll> nums(high + 1, 1);
    for(int i = 1; i <= high; i++) {
        nums[i] = ((x - i + 1)%mod*nums[i - 1]%mod) % mod;
    }
    
    ll ans = 0;
    for(int k = 1; k <= high; k++) {
        ll temp = helper(n, k);
        
        ll n1 = (temp%mod * nums[k]%mod) % mod;
        n1 = (n1%mod * a1[k]%mod) % mod;
        ans = (ans%mod + n1%mod) % mod;
    }
    
    return static_cast<int>(ans);
    }
};",1420074611
Partha Banerjee,parthahere001,523,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
    for(int i=0;i<nums.size();i++){
    
        int temp = -1;
    
        if(nums[i]%2 ==0){
            ans.push_back(-1);
            continue;
        }
       
      
        int k =0;
        while((1<<k)<=nums[i]){

            if(((1<<k)&nums[i])){
                int a =((~(1<<k))&nums[i]);
            
                if( nums[i]== (a | (a +1)) ){
                    if((a < temp)||(temp == -1)){
                        temp = a;
                    }
                }
            }
            k++;
        }
        ans.push_back(temp);
    }
    return ans;
    }
};",1420009818
Partha Banerjee,parthahere001,523,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans;
    for(int i=0;i<nums.size();i++){
    
        int temp = -1;
    
        if(nums[i]%2 ==0){
            ans.push_back(-1);
            continue;
        }
       
      
        int k =0;
        while((1<<k)<=nums[i]){

            if(((1<<k)&nums[i])){
                int a =((~(1<<k))&nums[i]);
            
                if( nums[i]== (a | (a +1)) ){
                    if((a < temp)||(temp == -1)){
                        temp = a;
                    }
                }
            }
            k++;
        }
        ans.push_back(temp);
    }
    return ans;
    }
};

",1420009293
Ernest Lu,ernestlu,526,3604,cpp,"using ll = long long;
constexpr ll MOD = 1e9 + 7;
class Solution {
public:


struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};
    int numberOfWays(int n, int x, int y) {
        const int b = max({x, n, y});
        vector<mint> fac(b + 1, 1), pow_y(b + 1, 1), inv(b + 1);
        vector<mint> pow_to_n(b + 1, 0);
        for (int i = 1; i <= b; i++) {
            fac[i] = fac[i - 1] * i;
            pow_y[i] = pow_y[i - 1] * y;
            pow_to_n[i] = mint(i).pow(n);
        }
        inv[b] = fac[b].pow();
        for (int i = b - 1; i >= 0; i--)
            inv[i] = (inv[i + 1] * (i + 1));
        
        auto C = [&](int n, int k) -> mint {
            if (n < k or k < 0)
                return mint(0);
            return fac[n] * inv[k] * inv[n - k];
        };
        
        mint ans = 0;
        for (int num_stages = 1; num_stages <= x; num_stages++) {
            mint h = C(x, num_stages);
            mint assign_to = 0;
            for (int idx = num_stages, flip = 1; idx >= 1; idx--, flip *= -1) {
                assign_to += flip * C(num_stages, idx) * pow_to_n[idx];
            }
            ans += h * assign_to * pow_y[num_stages];
        }
        return ans.x;
    }
};",1420030729
Ernest Lu,ernestlu,526,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = (int)nums.size();
        vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            ans[i] = (nums[i] == 2 ? -1 : nums[i] - 1);
            if (nums[i] == 2)
                continue;

            int num_ones = 0;
            int x = nums[i];
            while (x % 2 == 1) {
                num_ones++;
                x /= 2;
            }
            if (num_ones == 1) {
                ans[i] = nums[i] - 1;
            } else {
                int x = nums[i];
                x = (x >> num_ones) << num_ones;
                for (int j = 0, p2 = 1; j + 1 < num_ones; j++, p2 *= 2)
                    x += p2;                
                ans[i] = x;
            }
        }
        return ans;
    }
};",1420081220
Ernest Lu,ernestlu,526,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = (int)nums.size();
        vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            ans[i] = (nums[i] == 2 ? -1 : nums[i] - 1);
            if (nums[i] == 2)
                continue;

            int num_ones = 0;
            int x = nums[i];
            while (x % 2 == 1) {
                num_ones++;
                x /= 2;
            }
            if (num_ones == 1) {
                ans[i] = nums[i] - 1;
            } else {
                int x = nums[i];
                x = (x >> num_ones) << num_ones;
                for (int j = 0, p2 = 1; j + 1 < num_ones; j++, p2 *= 2)
                    x += p2;                
                ans[i] = x;
            }
        }
        return ans;
    }
};",1420080394
Yifeng,gaoyf1235,527,3604,cpp,"
class Solution {
    using ll = long long;
    const ll mod = 1e9 + 7;
    template<typename T>
    class Combination{
    public:
        Combination(T n, T modular) : n_(n), mod_(modular) {
            fact_mod_.resize(n+1, 1);
            inv_fact_mod_.resize(n+1, 1);
            for(T i = 1; i <= n; i++){
                fact_mod_[i] = (i * fact_mod_[i - 1]) % mod_;
                // fast modular inverse with exp(mod - 2)
                inv_fact_mod_[i] = modExp(fact_mod_[i], mod_ - 2, mod_);
            }
        }

        T nChooseK(T n, T k){
            if(k > n) return 0;
            T nCk = (((fact_mod_[n] * inv_fact_mod_[k]) % mod_) * inv_fact_mod_[n-k]) % mod_;
            return nCk;
        }

        T factorial(T n){
            return fact_mod_[n];
        }

        T inv_factorial(T n){
            return inv_fact_mod_[n];
        }
    private:
        vector<T> fact_mod_;
        vector<T> inv_fact_mod_;
        T n_;
        T mod_;

        ll modExp(ll x, ll y, ll m){
            if(y == 0) return 1;
            ll half_exp = modExp(x, y / 2, m);
            if(y % 2 == 0) return (half_exp * half_exp) % m;
            else return (((half_exp * half_exp) % m) * x) % m;
        }
    };
public:
    int numberOfWays(int n, int x, int y) {
        ll max_cnt = 1000;
        Combination<ll> comb(1000, mod);
        
        ll n_fac = comb.factorial(n);
        vector<ll> powy(max_cnt + 1, 1);
        for(ll i = 1; i <= max_cnt; i++){
            powy[i] = (powy[i-1] * y) % mod;
        }
        vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));
        dp[1][1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i][j] += j * dp[i-1][j];
                dp[i][j] += j * dp[i-1][j-1];
                dp[i][j] %= mod;
            }
        }
        ll res = 0;
        for(int b = 1; b <= min(x, n); b++){
            ll b_stages = comb.nChooseK(x, b);
            ll b_stages_score = (b_stages * powy[b]) % mod;
            res += b_stages_score * dp[n][b];
            res %= mod;
        }
        return res;
    }
};",1420081415
Yifeng,gaoyf1235,527,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x : nums){
            if(x == 2) res.push_back(-1);
            else{
                string bits;
                for(int i = 0; i <= 30; i++){
                    if(x & (1 << i)){
                        bits += ""1"";
                    }
                    else{
                        bits += ""0"";
                    }
                }
                while(bits.back() == '0'){
                    bits.pop_back();
                }
                int n = bits.size();
                int ones = 0;
                int r = 0;
                for(int i = 0; i < n; i++){
                    if(bits[i] == '1') ones++;
                    if(ones == i + 1){
                        r = i;
                    }
                }
                int ans = 0;
                for(int i = 0; i < n; i++){
                    if(i < r){
                        ans |= (1 << i);
                    }
                    else{
                        if(bits[i] == '1' and i > r) ans |= (1 << i);
                    }
                }
                res.push_back(ans);
            }
        }
        return res;
    }
};",1420032900
Yifeng,gaoyf1235,527,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x : nums){
            if(x == 2) res.push_back(-1);
            else{
                string bits;
                for(int i = 0; i <= 30; i++){
                    if(x & (1 << i)){
                        bits += ""1"";
                    }
                    else{
                        bits += ""0"";
                    }
                }
                while(bits.back() == '0'){
                    bits.pop_back();
                }
                int n = bits.size();
                int ones = 0;
                int r = 0;
                for(int i = 0; i < n; i++){
                    if(bits[i] == '1') ones++;
                    if(ones == i + 1){
                        r = i;
                    }
                }
                int ans = 0;
                for(int i = 0; i < n; i++){
                    if(i < r){
                        ans |= (1 << i);
                    }
                    else{
                        if(bits[i] == '1' and i > r) ans |= (1 << i);
                    }
                }
                res.push_back(ans);
            }
        }
        return res;
    }
};",1420032535
Darin Mao,darin-mao,528,3604,python3,"MOD = 1000000007

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        score = y
        rv = 0
        s_num = x
        s_den = 1
        for stages in range(1, min(n, x)+1):
            assigns = 0
            num = 1
            den = 1
            for i in range(stages):
                term = num // den * pow(stages-i, n, MOD)
                num *= (stages-i)
                den *= (i+1)
                if i % 2:
                    assigns = (assigns - term) % MOD
                else:
                    assigns = (assigns + term) % MOD

            assigns *= s_num // s_den
            rv = (rv + score * assigns) % MOD

            s_num *= x-stages
            s_den *= stages+1
            score *= y
        return rv

# k = n
# n = stages",1420081929
Darin Mao,darin-mao,528,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for x in nums:
            if x == 2:
                yield -1
            else:
                for i in count():
                    if (x >> i) & 1 == 0:
                        yield x & ~(1 << (i-1))
                        break
",1420008498
Darin Mao,darin-mao,528,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for x in nums:
            if x == 2:
                yield -1
            else:
                for i in count():
                    if (x >> i) & 1 == 0:
                        yield x & ~(1 << (i-1))
                        break
",1420008255
ykamo,ykamo,529,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        Z = 10 ** 9 + 7
        # sum(map(lambda x: 4 ** len(set(x)) , list(itertools.product([0, 1, 2], [0, 1, 2], [0, 1, 2]))))
        # sum(map(lambda z: y ** len(set(z)) , list(itertools.product(*[list(range(x)) for _ in range(n)]))))
        d = [0] * x
        d[0] = x
        for i in range(n-1):
            e = [0] * x
            for j in range(x):
                e[j] += d[j] * (j + 1)
                if j != x - 1:
                    e[j+1] += d[j] * (x - j - 1)
            d = e
        # print(d)
        s = 0
        w = y
        for i, v in enumerate(d):
            s += v * w
            w *= y
            s %= Z
            w %= Z
        return s



        ",1420082294
ykamo,ykamo,529,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def f(n):
            if n == 2:
                return -1
            return n & (n + 1) + (n ^ (n + 1)) // 4
        return map(f, nums)

        ",1420012032
ykamo,ykamo,529,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def f(n):
            if n == 2:
                return -1
            return n & (n + 1) + (n ^ (n + 1)) // 4
        return map(f, nums)

        ",1420011528
Neal Saxena,neal27,531,3604,cpp,"class Solution {
public:
# define ll long long
ll MOD = 1e9 + 7;
ll MOD2 = 998244353;
ll INF = 1e18;

static const int MAX_N = 1005;
ll fac[MAX_N];
ll invfac[MAX_N];
ll s[MAX_N][MAX_N];
ll power(ll x, int y, int p){
    ll res = 1; // Initialize result
    x = x % p; // Update x if it is more than or equal to p
    while (y > 0){
        // If y is odd, multiply x with result
        if (y & 1) res = (res * x) % p;
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % p;
    }
    return res;
}
// Returns n^(-1) mod p
ll modInverse(ll n, int p){
    return power(n, p - 2, p);
}
void fill_arrays(int n, int p){
    // Fill factorial array so that we can find all factorial of r, n and n-r
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = (fac[i - 1] * i) % p;
    invfac[n] = modInverse(fac[n], p); // Fermat's little theorem for modular inverse
    for (int i = n - 1; i >= 0; i--) invfac[i] = invfac[i + 1] * (i + 1) % p;
    s[0][0] = 0;
    for(int x = 1; x <= n; x++){
        s[x][0] = 0;
        s[x][1] = 1;
        for(int y = 2; y <= x; y++){
            s[x][y] = (s[x - 1][y - 1] + ((y * s[x - 1][y])%p))%p;
        }
    }
}
// Returns nCr % p using Fermat's little theorem.
ll nCr(ll n, ll r, int p){
    if (n < r) return 0; // If n<r, then nCr should return 0
    if (r == 0) return 1; // Base case
    return (fac[n] * invfac[r] % p * invfac[n - r] % p) % p;
}

int numberOfWays(int n, int x, int y) {
    fill_arrays(MAX_N - 1, MOD);
    ll ans = 0;
    for(int k = 1; k <= min(n, x); k++){
        ll cur = s[n][k];
        cur *= nCr(x, k, MOD); cur %= MOD;
        cur *= fac[k]; cur %= MOD;
        cur *= power(y, k, MOD); cur %= MOD;
        ans = (ans + cur)%MOD; 
    }
    return ans;
}
};",1420082816
Neal Saxena,neal27,531,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= nums[i]; j++){
                if((j | (j + 1)) == nums[i]){
                    ans[i] = j; break;
                }
            }
        }
        return ans;
    }
};",1420002686
Neal Saxena,neal27,531,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < 31; j++){
                int x = nums[i] - (1<<j);
                if(x < 0) break;
                if((x | (x + 1))==nums[i]) ans[i] = x;
            }
        }
        return ans;
    }
};",1420024045
RTXCR7,RTXCR7,535,3604,cpp,"typedef long long ll;

ll mod = 1e9+7;        // can be changed according to the question
ll fact[1001];    
ll fact_inv[1001];
int A;
ll dp[1001][1001];

ll power(ll a, ll n)
{
    a %= mod;
    ll ans = 1ll;
    while (n > 0)
    {
        if (n & 1ll) ans = ans * a % mod;
        a = a * a % mod;
        n = n >> 1ll;
    }
    return ans;
}

void factorial()
{
    fact_inv[0] = 1ll;
    fact[0] = 1ll;
    for (ll i = 1; i < A; i++)
    {
        fact[i] = (fact[i - 1] * i) % mod;
        fact_inv[i] = power(fact[i], mod - 2);
    }
    

    // Base cases

    for (int i = 0; i <A; i++) {
        dp[i][0] = 0;  // 0 boxes, 0 ways
        dp[i][1] = 1;  // 1 box, only 1 way
    }

    for (int j = 0; j < A; j++) {
        dp[0][j] = 0;  // No objects, 0 ways
        dp[j][j] = 1;  // n objects, n boxes, only 1 way
    }

    // Fill the DP table using recurrence relation
    for (int i = 2; i < A; i++) {
        for (int j = 2; j < A; j++) {
            dp[i][j] = j *1LL* dp[i - 1][j]%mod + dp[i - 1][j - 1];
            dp[i][j] %= mod;
        }
    }

}

ll modncr(ll n, ll r)
{

    if (r > n) return 0ll;
    ll num = fact[n], den = (fact_inv[n - r] * fact_inv[r]) % mod;
    ll ans = (num * den) % mod;
    return ans;
}


class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        A = max(n,x)+1;
        factorial();
        int ans = 0;
        for(int i=1;i<=min(x,n);i++){
            int g1 = modncr(x,i);
            int g2 = power(y,i);
            int g3 = fact[i]*1LL*dp[n][i]%mod;
            int g4 = g1*1LL*g2%mod;
            int g5 = g4*1LL*g3%mod;
            ans+=g5;
            ans %= mod;
        }
        return ans;
    }
};",1420050053
RTXCR7,RTXCR7,535,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto it:nums){
            if(it%2){
                for(int i=0;i<31;i++){
                    if(!(it&(1<<i))){
                        int num = it-(1<<(i-1));
                        ans.push_back(num);
                        break;
                    }
                }
            }
            else ans.push_back(-1);
        }   
        return ans;
    }
};",1420073911
RTXCR7,RTXCR7,535,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto it:nums){
            if(it%2){
                for(int i=0;i<31;i++){
                    if(!(it&(1<<i))){
                        int num = it-(1<<(i-1));
                        ans.push_back(num);
                        break;
                    }
                }
            }
            else ans.push_back(-1);
        }   
        return ans;
    }
};",1420073373
_rs123,_rs123,536,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int mod = 1000000007;
        long long dp[n+1][x+1];

        for(int i=1;i<=n;i++){
            dp[i][1] = x;
        }

        for(int j=1;j<=x;j++){
            dp[1][j] = 0;
        }

        dp[1][1] = x;

        for(int i=2;i<=n;i++){
            for(int j=2;j<=x;j++){
                if(i<j){
                    dp[i][j]=0;
                    continue;
                }
                dp[i][j] = dp[i-1][j-1]*(x-j+1) + dp[i-1][j]*j;
                dp[i][j]%=mod;
            }
        }

        // for(int i=1;i<=n;i++){
        //     for(int j=1;j<=x;j++){
        //         cout<<dp[i][j]<<"" "";
        //     }
        //     cout<<""\n"";
        // }

        long long ans=0;

        long long pow[x+1];
        pow[0]=1;
        for(int i=1;i<=x;i++){
            pow[i] = y*pow[i-1];
            pow[i]%=mod;
        }

        for(int j=1;j<=x;j++){
            ans += dp[n][j]*pow[j];
            ans%=mod;
        }
        return ans;
    }
};",1420082977
_rs123,_rs123,536,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n = nums.size();
        vector<int> ansvec(n);

        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ansvec[i]=-1;
                continue;
            }
            int val = nums[i];
            int pos = val^(val+1);
            pos = log2(pos) - 1;
            int x = (nums[i]^(1<<pos));
            ansvec[i]=x;
        }
        return ansvec;
    }
};",1420012894
_rs123,_rs123,536,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ansvec(n);

        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ansvec[i]=-1;
                continue;
            }
            int val = nums[i];
            int pos = val^(val+1);
            pos = log2(pos) - 1;
            int x = (nums[i]^(1<<pos));
            ansvec[i]=x;
        }
        return ansvec;
    }
};",1420011945
Hridyansh Gupta,hridyansh28,537,3604,cpp,"class Solution {
public:
    static const int MAXN = 1e3+10; 
    const long long MOD = 1e9 + 7;

    long long fac[MAXN + 1];
    long long inv[MAXN + 1];

    /** @return x^n modulo m in O(log p) time. */
    long long exp(long long x, long long n, long long m) {
        x %= m;  // Ensure x is within bounds
        long long res = 1;
        while (n > 0) {
            if (n % 2 == 1) { 
                res = res * x % m; 
            }
            x = x * x % m;
            n /= 2;
        }
        return res;
    }

    /** Precomputes n! from 0 to MAXN. */
    void factorial(long long p) {
        fac[0] = 1;
        for (int i = 1; i <= MAXN; i++) { 
            fac[i] = fac[i - 1] * i % p; 
        }
    }

    /** Precomputes all modular inverse factorials from 0 to MAXN in O(n + log p) time */
    void inverses(long long p) {
        inv[MAXN] = exp(fac[MAXN], p - 2, p);
        for (int i = MAXN; i >= 1; i--) { 
            inv[i - 1] = inv[i] * i % p; 
        }
    }

    /** @return nCr mod p */
    long long choose(long long n, long long r, long long p) {
        if (r > n) return 0;
        if(r==0) return 1;
        return fac[n] * inv[r] % p * inv[n - r] % p;
    }

    int numberOfWays(int n, int x, int y) {
        factorial(MOD);
        inverses(MOD);
        long long ans = 0;
        
        for (int i = 1; i <= x; i++) {
            long long temp = 0;
            for (int j = 0; j <= i; j++) {
                long long term = choose(i, j, MOD) * exp(i - j, n, MOD) % MOD;
                if (j % 2 == 0) {
                    temp = (temp + term) % MOD;  
                } else {
                    temp = (temp - term + MOD) % MOD; 
                }
            }
            temp = temp * exp(y, i, MOD) % MOD * choose(x, i, MOD) % MOD;
            ans = (ans + temp) % MOD;
        }
        
        return (int) ans;
    }
};
",1420083603
Hridyansh Gupta,hridyansh28,537,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> v;
        for(auto val:nums){
            if((val&1)==0){
                v.push_back(-1);
            }
            
            else{
                int ind=0;
                for(int i=0;i<=31;i++){
                    if(((val>>i)&1)==1){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                v.push_back(val-(1<<ind));
            }
        }
        return v;
    }
};",1420005052
Hridyansh Gupta,hridyansh28,537,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> v;
        for(auto val:nums){
            if((val&1)==0){
                v.push_back(-1);
            }
            
            else{
                int ind=0;
                for(int i=0;i<=31;i++){
                    if(((val>>i)&1)==1){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                v.push_back(val-(1<<ind));
            }
        }
        return v;
    }
};",1420008566
Dhyanendra Tripathi,Gminor,538,3604,cpp,"#include <cstring>
#define ll long long
using namespace std;

const int MOD = 1e9 + 7;
const int MAX_N = 1000;
const int MAX_X = 1000; 

ll C[MAX_X + 1][MAX_X + 1];
ll S[MAX_N + 1][MAX_X + 1];
ll fact[MAX_X + 1];

void init(int n, int x) {
    memset(C, 0, sizeof(C));
    memset(S, 0, sizeof(S));
    memset(fact, 0, sizeof(fact));
    
    for (ll i = 0; i <= x; ++i) {
        C[i][0] = 1;
        for (ll j = 1; j <= i; ++j) {
            C[i][j] = (C[i - 1][j - 1] % MOD + C[i - 1][j] % MOD) % MOD;
        }
    }
    
    S[0][0] = 1;
    for (ll i = 1; i <= n; ++i) {
        for (ll j = 1; j <= x; ++j) {
            S[i][j] = ((j * S[i - 1][j]) % MOD + S[i - 1][j - 1]) % MOD;
        }
    }
    
    fact[0] = 1;
    for (ll i = 1; i <= x; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        init(n, x);
        ll ans = 0;
        for (int i = 1; i <= x; i++) {
            // ll power = powl(y, i);
            ll p = 1;
            for (int ii = 0; ii < i; ii++) {
                p = (p * y) % MOD;
            }
            ll ways = C[x][i];
            ways = (ways * fact[i]) % MOD;
            ways = (ways * S[n][i]) % MOD;
            ways = (ways * p) % MOD;
            ans = (ans + ways) % MOD;
        }
        
        return (int)ans;
    }
};
",1420083907
Dhyanendra Tripathi,Gminor,538,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);

        for (int i = 0; i < nums.size(); i++) {
            int val = -1;
            for (int j = 0; j <= nums[i]; j++) {
                int have = (j | (j + 1));
                if (have == nums[i]) {
                    val = j;
                    break;
                }
            }
            ans[i] = val;
        }
        
        return ans;
    }
};",1420001490
Dhyanendra Tripathi,Gminor,538,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            int curr = nums[i];
            int val = INT_MAX;
            int found = 0;
            for (int ii = 0; ii <= 31; ii++) {
                int get = (curr >> ii) & 1;
                if (get == 1) {
                    int full = ~(1 << ii);
                    int tog = curr & full;
                    if (tog < 0) {
                        continue;
                    }
                    // cout << full << "" "" << tog << endl;
                    int fin = (tog | (tog + 1));
                    if (fin == curr) {
                        if (tog < val) {
                            val = tog;
                            found = 1;
                        }
                    }
                }
            }
            
            if (!found) {
                ans[i] = -1;
                continue;
            } 
            ans[i] = val;
        }
        
        return ans;
    }
};",1420052064
Om Amar,OmAmar,540,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        class Factorial:
            def __init__(self, N, mod):
                N += 1
                self.mod = mod
                self.f = [1 for _ in range(N)]
                self.g = [1 for _ in range(N)]
                for i in range(1, N):
                    self.f[i] = self.f[i - 1] * i % self.mod
                self.g[-1] = pow(self.f[-1], mod - 2, mod)
                for i in range(N - 2, -1, -1):
                    self.g[i] = self.g[i + 1] * (i + 1) % self.mod
            def fac(self, n):
                return self.f[n]
            def fac_inv(self, n):
                return self.g[n]
            def combi(self, n, m):
                if m == 0: return 1
                if n < m or m < 0 or n < 0: return 0
                return self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod
            def permu(self, n, m):
                if n < m or m < 0 or n < 0: return 0
                return self.f[n] * self.g[n - m] % self.mod
            def catalan(self, n):
                return (self.combi(2 * n, n) - self.combi(2 * n, n - 1)) % self.mod
            def inv(self, n):
                return self.f[n-1] * self.g[n] % self.mod
            

        ans = 0
        MOD = 10**9 + 7
        L = Factorial(1001,MOD)
        k2 = [x]
        k3 = [x]
        def func(n,t):
            MOD = 10**9 + 7
            ans = 0
            k = 1
            for i in range(t,-1,-1):
                ans += k*pow(i,n,MOD)*(L.combi(k2[0],i))
                k *= -1
            return ans

        for i in range(1,x+1):
            if n>=i:
                k2 = [i]
                f = func(n,i)
                ans += f*((pow(y,i,MOD))*L.combi(x,i))
                ans = ans%MOD
            else:
                break
        return ans",1420084334
Om Amar,OmAmar,540,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i]!=2:
                k = nums[i]
                count = 0
                while k%2:
                    k //= 2
                    count += 1
                k *= 2
                k += 1
                for i in range(count-1):
                    k *= 2
                k -= 1
                ans.append(k)
            else:
                ans.append(-1)
        return ans",1420000627
Om Amar,OmAmar,540,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i]!=2:
                k = nums[i]
                count = 0
                while k%2:
                    k //= 2
                    count += 1
                k *= 2
                k += 1
                for i in range(count-1):
                    k *= 2
                k -= 1
                ans.append(k)
            else:
                ans.append(-1)
        return ans",1420000865
Priyanshu Tyagi,priyanshu2511,541,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
          int n = source.length();   int m = pattern.length();
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE;}
        dp[0] = 0;

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;  }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420076780
Priyanshu Tyagi,priyanshu2511,541,3604,java,"class Solution {
    private static final int MOD = 1000000007;
    public int numberOfWays(int n, int x, int y) {
        long[][] combination = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD;
            }
        }

        // Initialize the Stirling numbers of the second kind (S) array
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        // Main computation loop
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + combination[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * power % MOD) % MOD;
        }

        return (int) totalWays;  
    }
}",1420091369
Priyanshu Tyagi,priyanshu2511,541,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            // Try different values of ans[i] starting from 0
            for (int j = 0; j <= num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
        
            if (!found) {
                ans[i] = -1;
            }
        }
        return ans;
    
    }
}",1420000533
FOOL,pgl7,542,3604,cpp,"
const int facN = 2e6 + 5;
const int mod = 1e9 + 7; // 998244353
int ff[facN], iff[facN];
bool facinit = false;

 
int power(int x, int y){
    if (y == 0) return 1;
 
    int v = power(x, y / 2);
    v = 1LL * v * v % mod;
 
    if (y & 1) return 1LL * v * x % mod;
    else return v;
}
 
void factorialinit(){
    facinit = true;
    ff[0] = iff[0] = 1;
 
    for (int i = 1; i < facN; i++){
        ff[i] = 1LL * ff[i - 1] * i % mod;
    }
 
    iff[facN - 1] = power(ff[facN - 1], mod - 2);
    for (int i = facN - 2; i >= 1; i--){
        iff[i] = 1LL * iff[i + 1] * (i + 1) % mod;
    }
}
 
int C(int n, int r){
    if (!facinit) factorialinit();
 
    if (n == r) return 1;
 
    if (r < 0 || r > n) return 0;
    return 1LL * ff[n] * iff[r] % mod * iff[n - r] % mod;
}



class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        
        int dp[x+1] ,ans = 0;
        dp[1] = 1;
        
        for(int i =2 ; i<= x; i++) 
        {
            int val = 0 ;
            for(int j = 1; j<= i-1 ; j++)  val =  (val +    1LL*C(i,j)*dp[j]%mod)%mod;
            
            dp[i] = (  power( i, n  ) + mod - val )%mod;
        }
        
        for(int  i =1;i<=x; i++)
        {
            ans  = (ans  +  1LL*C(x, i)*dp[i]%mod * power(y,i)%mod )%mod;
        }
        
        return ans;
    }
};",1420092631
FOOL,pgl7,542,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int  i =0  ; i<nums.size();i++)
        {
            int val = nums[i];
            if(val%2==0) { ans[i] =-1;continue;}
            
            
            int cnt= 0 ; 
            while(val!=0)
            {
                if(val%2 ==0 ) break;
                else cnt++;
                val = val/2;
            }
            
            ans[i] = nums[i]  - (1<<(cnt-1));
        }
        
        return ans;
    }
};",1420022369
FOOL,pgl7,542,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int  i =0  ; i<nums.size();i++)
        {
            int val = nums[i];
            if(val%2==0) { ans[i] =-1;continue;}
            
            
            int cnt= 0 ; 
            while(val!=0)
            {
                if(val%2 ==0 ) break;
                else cnt++;
                val = val/2;
            }
            
            ans[i] = nums[i]  - (1<<(cnt-1));
        }
        
        return ans;
    }
};",1420022062
Satyendra,biltharesatyendra,543,3604,cpp,"typedef long long ll;
ll mod = 1000000007;
ll fa[1005];
ll po[1005];
ll sterling[1005][1005];
ll mypow(int a, int y)
{
    if(y==0)return 1;
    ll res = mypow(a, y/2);
    res = (res * res)%mod;
    if(y%2)res = (res * a)%mod;
    return res;
}
ll npr(int n, int r)
{
    //printf(""choose %d %d is %lld and %lld %lld\n"",n,r,fa[n],fa[r], fa[n-r]);
    if(r > n)return 0;
    //if(r < 0)return 0;
    if(r == 0)return 1;
    ll num = fa[n];
    ll den = fa[n-r];
    den = mypow(den, mod-2);
    return (num * den)%mod;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int i;
        fa[0] = 1;
        for(i=1; i<=max(n,x); i++)
            fa[i] = (i * fa[i-1])%mod;
        po[0] = 1;
        for(i=1; i<=n; i++)
            po[i] = (y * po[i-1])%mod;
        sterling[0][0] = 1;
        for(i=1; i<=n; i++){
            sterling[i][0] = 0;
            sterling[i][1] = 1;
        }
        
        int j;
        for(i=1; i<=n; i++)
        {
            for(j=2; j<=i; j++)
            {
                ll fir = sterling[i-1][j];
                ll sec = sterling[i-1][j-1];
                sterling[i][j] = (j * fir + sec)%mod;
            }
        }
        
        ll ans = 0;
       // printf(""solving for %d %d %d\n"",n,x,y);
        for(i=1; i<=x; i++)
        {
            ll ways = sterling[n][i];
         //   printf(""sterling %d %d is %lld\n"",n,i,ways);
            ll choose = npr(x,i);
           // printf(""choosing %d stages out of %d is %lld\n"",i,x,choose);
            ways = (ways * choose)%mod;
            ways = (ways * po[i])%mod;
            //printf(""and power is %lld\n"",po[i]);
            
            ans = ans + ways;
            ans = ans % mod;
            //if(ans > 0)ans -= mod;
        }
        return ans;
        
    }
};",1420054795
Satyendra,biltharesatyendra,543,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        ans = []
        for x in nums:
            if x == 2:
                ans.append(-1)
            else:
                if (x & (x-1))==0:
                    ans.append(x//2)
                else:
                    for j in range(max(0,x-100),x+1):
                        if j | (j+1) == x:
                            break
                    ans.append(j)
        return ans",1420059263
Satyendra,biltharesatyendra,543,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        ans = []
        for x in nums:
            if x == 2:
                ans.append(-1)
            else:
                pos = []
                for j in range(32):
                    if x & (1<<j):
                        y = x - (1<<j)
                        if y | (y+1) == x:
                            pos.append(y)
                pos.sort()
                ans.append(pos[0])
        return ans",1420072370
Fishron,Fishron,544,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod=10**9+7
        o=0
        #x=min(x,n)
        fact=[1]*(x+1)
        for i in range(1,x+1):
            fact[i]=i*fact[i-1]
            fact[i]%=mod
        cur=x
        for k in range(1,min(n,x)+1):
            S=cur
            S*=sum((-1)**(k-i)*pow(i,n,mod)*pow(fact[k-i],-1,mod)*pow(fact[i],-1,mod) for i in range(k+1))
            S*=fact[k]
            S%=mod
            o+=(S*pow(y,k,mod))
            o%=mod
            cur*=pow(k+1,-1,mod)*(x-k)
            cur%=mod
            
            #print(k,o,S,n)
        return o
        """"""combs=[1]*(1+x)
        for i in range(1,1+x):
            combs[i]=combs[i-1]*(x-i+1)*pow(i,-1,mod)
            combs[i]%=mod #comb(x,i)
        perms=[1]*(1+n)
        for i in range(1,1+n):
            perms[i]=perms[i-1]*(n-i+1)
            perms[i]%=mod # perm(n,i)

        for k in range(1,min(n,x)+1):
            v=(combs[k]*perms[k])%mod
            v*=pow(k,n-k,mod)
            v*=pow(y,k,mod)
            v%=mod
            #print(k,v)
            o=(o+v)%mod
        return o""""""
#(x!)/((x-k)!k!)
        ",1420093397
Fishron,Fishron,544,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        o=[-1]*n
        for i in range(n):
            if nums[i]==2:
                continue
            cands=[(1<<v)^nums[i] for v in range(nums[i].bit_length())]
            v=inf
            for e in cands:
                if e | (e+1)==nums[i]:
                    v=min(e,v)
            o[i]=v if v!=inf else -1
        return o",1420011249
Fishron,Fishron,544,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        o=[-1]*n
        for i in range(n):
            if nums[i]==2:
                continue
            cands=[(1<<v)^nums[i] for v in range(nums[i].bit_length())]
            v=inf
            for e in cands:
                if e | (e+1)==nums[i]:
                    v=min(e,v)
            o[i]=v if v!=inf else -1
        return o

",1420010761
Shao-Heng,paulchen2713,545,3604,cpp,"// Q4. Find the Number of Possible Ways for an Event
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int kMod = 1e9 + 7;
        const int kMax = 1001;  // Since n, x, y <= 1000

        // Precompute factorials and inverse factorials up to kMax
        std::vector<long long> factorial(kMax, 1);
        std::vector<long long> inv_factorial(kMax, 1);

        // Calculate factorials modulo kMod
        for (int i = 1; i < kMax; i++) {
            factorial[i] = factorial[i - 1] * i % kMod;
        }

        // Calculate inverse factorials using Fermat's Little Theorem
        inv_factorial[kMax - 1] = modinv(factorial[kMax - 1], kMod);
        for (int i = kMax - 2; i >= 0; i--) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % kMod;
        }

        // Precompute Stirling numbers of the second kind S(n, k)
        std::vector<std::vector<long long>> S(n + 1, std::vector<long long>(n + 1, 0));
        S[0][0] = 1;  // Base case

        // Calculate Stirling numbers using the recurrence relation
        for (int i = 1; i <= n; i++) {
            S[i][0] = 0;
            for (int j = 1; j <= i; j++) {
                S[i][j] = (j * S[i - 1][j] % kMod + S[i - 1][j - 1]) % kMod;
            }
        }

        long long total = 0;
        int min_k = std::min(n, x);

        // Iterate over possible numbers of non-empty stages
        for (int k = 1; k <= min_k; k++) {
            // Compute permutations P(x, k) = x! / (x - k)!
            long long P_xk = factorial[x] * inv_factorial[x - k] % kMod;

            // Compute term = P(x,k) * S(n,k) * y^k % MOD
            long long term = P_xk * S[n][k] % kMod;
            term = term * modpow(y, k, kMod) % kMod;

            // Add the term to the total number of ways
            total = (total + term) % kMod;
        }

        return (int)total;
    }

    // Function to compute x^y % MOD using binary exponentiation
    long long modpow(long long x, long long y, long long kMod) {
        long long result = 1;
        x %= kMod;
        while (y > 0) {
            if (y % 2 == 1) {
                result = result * x % kMod;
            }
            x = x * x % kMod;
            y /= 2;
        }
        return result;
    }

    // Function to compute modular inverse using Fermat's Little Theorem
    long long modinv(long long x, long long kMod) {
        return modpow(x, kMod - 2, kMod);
    }
};",1420086614
Shao-Heng,paulchen2713,545,3605,cpp,"// Q1. Construct the Minimum Bitwise Array I
class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        const int n = nums.size();
        std::vector<int> result(n);

        // Iterate through each number in nums
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            bool found = false;
            
            // Try to find the smallest result[i] such that result[i] | (result[i] + 1) == num
            for (int res = 1; res <= num; res++) {
                if ((res | (res + 1)) == num) {
                    result[i] = res;
                    found = true;
                    break;
                }
            }

            // If no valid result was found, set result[i] = -1
            if (!found) {
                result[i] = -1;
            }
        }

        return result;
    }
};",1420024234
Shao-Heng,paulchen2713,545,3611,cpp,"// Q2. Construct the Minimum Bitwise Array II
class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        const int n = nums.size();
        std::vector<int> result(n);

        for (int i = 0; i < n; ++i) {
            int N = nums[i];
            int min_x = -1;

            // Iterate over each bit position (up to 30 for 32-bit integers)
            for (int bit = 0; bit < 31; ++bit) {
                if (N & (1 << bit)) {  // If the bit at position 'bit' is set
                    // Clear the bit at position 'bit' to create a candidate 'x'
                    int x = N & ~(1 << bit);

                    // Ensure 'x' is positive
                    if (x >= 1) {
                        // Check if 'x' satisfies the condition
                        if ((x | (x + 1)) == N) {
                            // Update 'min_x' if 'x' is smaller
                            if (min_x == -1 || x < min_x) {
                                min_x = x;
                            }
                        }
                    }
                }
            }

            result[i] = min_x;
        }

        return result;
    }
};",1420035737
Vaibhav Singh,vaibhav2740,546,3604,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;

    
    void precomputeFactorials(int max_n, vector<long long>& fact, vector<long long>& inv_fact) {
        fact[0] = 1;
        for (int i = 1; i <= max_n; ++i) {
            fact[i] = fact[i - 1] * i % mod;
        }
        inv_fact[max_n] = modInverse(fact[max_n]);
        for (int i = max_n - 1; i >= 0; --i) {
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;
        }
    }

    long long modInverse(long long a) {
        long long m = mod, x = 1, y = 0;
        while (a > 1) {
            long long q = a / m;
            long long t = m;
            m = a % m; a = t;
            t = y;
            y = x - q * y; x = t;
        }
        return (x + mod) % mod;
    }

    long long nCr(int n, int r, const vector<long long>& fact, const vector<long long>& inv_fact) {
        if (r > n) return 0;
        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;
    }

    
    vector<vector<long long>> precomputeStirling(int max_n) {
        vector<vector<long long>> stirling(max_n + 1, vector<long long>(max_n + 1, 0));
        stirling[0][0] = 1;  

        for (int n = 1; n <= max_n; ++n) {
            for (int k = 1; k <= n; ++k) {
                stirling[n][k] = (k * stirling[n - 1][k] % mod + stirling[n - 1][k - 1]) % mod;
            }
        }

        return stirling;
    }

    long long modPow(long long base, long long exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = result * base % mod;
            }
            base = base * base % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        
        int max_n = max(n, x);
        vector<long long> fact(max_n + 1), inv_fact(max_n + 1);
        precomputeFactorials(max_n, fact, inv_fact);
        vector<vector<long long>> stirling = precomputeStirling(max_n);

        long long res = 0;

        for (int i = 1; i <= x; i++) {
            long long combinations = nCr(x, i, fact, inv_fact);
            long long power = modPow(y, i);
            long long ways = stirling[n][i]; 

            
            long long labeledWays = (combinations * power % mod * ways % mod * fact[i] % mod) % mod;

            res = (res + labeledWays) % mod;
        }
        return res;
    }
};
",1420087415
Vaibhav Singh,vaibhav2740,546,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = v.size();
        vector<int>res(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=v[i];j++){
                int val = j|(j+1);
                if(val==v[i]) {
                    res[i] = j; break;
                }
            }
        }
        // for(int x:res) {
        //     if(x==-1) return {-1};
        // }
        return res;
    }
};",1419996101
Vaibhav Singh,vaibhav2740,546,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        ios::sync_with_stdio(0);
        cin.tie(0);
        
        int n = v.size();
        vector<int> res(n, -1); 
        
        for (int j = 0; j < n; j++) {
            int ind = 30;
            if(v[j]==2) continue;
            for (int i = 0; i < 31; i++) {
                if ((1 << i) & v[j])  continue;
                else{
                    ind=i; break;
                }
            }
            // if(v[j]==5) cout<<ind;
            for (int i = ind; i >= 0; i--) {
                // if(j==2&&i==0) cout<<""y"";
                if ((1 << i) & v[j]) {
                    // if(v[j]==5) cout<<""n"";
                    v[j] = v[j] ^ (1<<i); break;
                }
            }
            if(5&(1<<0)) cout<<""y"";
            res[j] = v[j];
        } 
        return res;
    }
};
",1420037449
Shah Jahan Ishaq,ShahJahan19,547,3604,python3,"import math
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = int(1e9 + 7)
        max_k = min(n, x)
        max_value = x
        factorial = [1] * (max_value + 1)
        inv_factorial = [1] * (max_value + 1)

        for i in range(1, max_value + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_factorial[max_value] = pow(factorial[max_value], MOD - 2, MOD)
        for i in range(max_value - 1, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

        def C(a, b):
            if a < b or b < 0:
                return 0
            return factorial[a] * inv_factorial[b] % MOD * inv_factorial[a - b] % MOD

        total = 0
        for k in range(1, max_k + 1):
            comb_x_k = C(x, k)
            y_power_k = pow(y, k, MOD)
            N_n_k = 0
            for i in range(k + 1):
                sign = (-1) ** i
                comb_k_i = C(k, i)
                term = sign * comb_k_i * pow(k - i, n, MOD)
                N_n_k = (N_n_k + term) % MOD

            term = comb_x_k * y_power_k % MOD * N_n_k % MOD
            total = (total + term) % MOD

        return total",1420087839
Shah Jahan Ishaq,ShahJahan19,547,3605,python3,"import math
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            count = 0
            if not (num & 1):
                ans.append(-1)
                continue
            while num & 1:
                num >>= 1
                count += 1
            mask = (1 << (count - 1)) - 1
            while count > 0:
                num <<= 1
                count -= 1
            num |= mask
            ans.append(num)
        return ans",1420040409
Shah Jahan Ishaq,ShahJahan19,547,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            count = 0
            if not (num & 1):
                ans.append(-1)
                continue
            while num & 1:
                num >>= 1
                count += 1
            mask = (1 << (count - 1)) - 1
            while count > 0:
                num <<= 1
                count -= 1
            num |= mask
            ans.append(num)
        return ans",1420040868
Swapnil Yasasvi,swapnilyasasvi2020,548,3604,cpp,"const int MOD=1e9+7;
#define ll long long
#define MAXN 1100
int binpow(int a,int n)
{
    if(n==0)return 1;
    int p=binpow(a,n/2);
    if(n%2)return 1ll*a*(1ll*p*p%MOD)%MOD;
    return 1ll*p*p%MOD;
}
int fact[MAXN];
int comb(int n,int r)
{
    if(n<0 or r<0 or n<r)return 0;
    int ans=fact[n];
    ans=1ll*ans*binpow(fact[r],MOD-2)%MOD;
    return 1ll*ans*binpow(fact[n-r],MOD-2)%MOD;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        fact[0]=1;
        for(int i=1;i<MAXN;i++)
        {
            fact[i]=1ll*i*fact[i-1]%MOD;
        }

        int dp[n+1][x+1];
        memset(dp,0,sizeof(dp));
        dp[0][0]=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=min(i,x);j++)
            {
                dp[i][j]=1ll*j*dp[i-1][j]%MOD;
                dp[i][j]+=1ll*j*dp[i-1][j-1]%MOD;
                dp[i][j]%=MOD;
            }
        }

        int ans=0;
        for(int i=0;i<=x;i++)
        {
            int val = 1ll*comb(x,i)*binpow(y,x-i)%MOD;
            val = 1ll*val*dp[n][x-i]%MOD;
            ans+=val;
            ans %=MOD;
        }
        return ans;


    }
};",1420088043
Swapnil Yasasvi,swapnilyasasvi2020,548,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2)
            {
                int val  = nums[i]^(nums[i]+1);
                val=val>>1;
                val =  __builtin_popcount(val);
                val--;
                val = 1<<val;
                ans[i]=nums[i]^val;
            }
        }
        return ans;
    }
};",1420025796
Swapnil Yasasvi,swapnilyasasvi2020,548,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2)
            {
                int val  = nums[i]^(nums[i]+1);
                val=val>>1;
                val =  __builtin_popcount(val);
                val--;
                val = 1<<val;
                ans[i]=nums[i]^val;
            }
        }
        return ans;
    }
};",1420027009
Husain Batterywala,husain2088,550,3604,cpp,"const int N = 2e5 + 5, mod = 1e9 + 7;
vector<long long int> fact(N);

class Solution {

long long int pw(long long int a, long long int b) {
	long long int r = 1;
	while(b > 0) {
		if(b & 1) r = (r * a) % mod;
		b /= 2;
		a = (a * a) % mod; 
	}
	return r;
}
long long int nCr(long long int n, long long int k) {
	if(n < k) return 0LL;
	return (fact[n] * pw((fact[n - k] * fact[k]) % mod, mod - 2)) % mod;
}


long long int power(long long x, long long int y, long long int p) 
{ 
    long long int res = 1;     // Initialize result 
 
    x = x % p; // Update x if it is more than or 
                // equal to p
  
    if (x == 0) return 0; // In case x is divisible by p;
 
    while (y > 0) 
    { 
        // If y is odd, multiply x with result 
        if (y & 1) 
            res = (res*x) % p; 
 
        // y must be even now 
        y = y>>1; // y = y/2 
        x = (x*x) % p; 
    } 
    return res; 
} 



public:
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        for(int64_t i = 1; i < N; ++i) fact[i] = (fact[i - 1] * i) % mod;
        //////////////

        long long int nn = n, xx = x, yy = y;
        long long int mod = (1e9)+7;

        vector<long long int> dp(x+1, 0);
        // dp[0]=1;
        dp[1]=x;
        for(int i=1; i<n; i++){

            for(int j=x; j>0; j--){
                if(j<x){
                    dp[j+1]+=dp[j]*(x-j);
                    dp[j+1]%=mod;
                }
                dp[j]*=j;
                dp[j]%=mod;

            }

        }

        // for(auto it : dp) cout<<it<<"" "";

        long long int ans = 0;
        for(long long int i = 1; i<=xx; i++){
            long long int a1 = power(yy, i, mod);
            long long int a2 = dp[i]*a1;
            ans += a2%mod;

            ans%=mod;
        }

        return ans;
    }
};",1420095976
Husain Batterywala,husain2088,550,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++){
            for(int j=0; j<=nums[i]+1; j++){
                int x = j|(j+1);
                if(x==nums[i]){
                    ans[i]=j;
                    break;
                }
            }
        }

        return ans;
        
    }
};",1419997380
Husain Batterywala,husain2088,550,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++){
            if(nums[i]==2){continue;}

            int z = nums[i], ind = 0, nw = 0;
            while((z&(1<<ind))>0){
                nw+= (1<<ind);
                ind++;
            }
            int n2 = nw/2;
            int ex = (z^nw);
            ans[i] = ex+n2;

            // cout<<nw<<""/""<<ind<<""  "";
                
        }

        return ans;

    }
};",1420021029
saicharan87733,saicharan87733,551,3487,java,"
import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE; // Use Integer.MAX_VALUE to represent infinity
        }
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}

",1420095151
saicharan87733,saicharan87733,551,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways
",1420093204
saicharan87733,saicharan87733,551,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize ans with -1
        
        // Iterate over each number in nums
        for (int i = 0; i < nums.size(); i++) {
            // Try all possible values of x
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;  // Found the smallest x
                    break;  // No need to check larger x values
                }
            }
        }
        
        return ans;
    }
};
",1420096106
CogentCoder73,cogentcoder73,553,3604,cpp,"class Solution {
public:
    long long modPow(int n, int p) {
        long long res = 1;
        long long pw = n % 1000000007;
        while (p > 0) {
            if (p % 2 == 1) res = (res * pw) % 1000000007;
            pw = (pw * pw) % 1000000007;
            p /= 2;
        }
        return res;
    }
    int numberOfWays(int n, int x, int y) {
        long long modFact[1001];
        modFact[0] = 1;
        for (int i = 1; i <= 1000; i++) {
            modFact[i] = (modFact[i - 1] * i) % 1000000007;
        }
        long long modInv[1001];
        modInv[1000] = modPow(modFact[1000], 1000000005);
        for (int i = 999; i >= 0; i--) {
            modInv[i] = (modInv[i + 1] * (i + 1)) % 1000000007;
        }
        long long res = 0;
        long long delta;
        long long prevs[1001];
        prevs[0] = 0;
        for (int s = 1; s <= min(n, x); s++) {
            delta = (((((modPow(s, n) * modFact[x]) % 1000000007) * modInv[s]) % 1000000007) * modInv[x - s]) % 1000000007;
            for (int i = 1; i < s; i++) {
                delta = (delta - (prevs[i] * (((((modFact[x - i] % 1000000007) * modInv[s - i]) % 1000000007) * modInv[x - s]) % 1000000007))) % 1000000007;
            }
            while (delta < 0) delta += 1000000007;
            prevs[s] = delta;
            res = (res + ((delta * modPow(y, s)) % 1000000007)) % 1000000007;
            // cout << s << ""/"" << x << "": "" << delta << ""\n"";
        }
        return res;
    }
};",1420083917
CogentCoder73,cogentcoder73,553,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int k, num1;
        for (int i = 0; i < n; i++) {
            k = nums[i]; num1 = 0;
            while (k % 2 == 1) {
                num1++;
                k /= 2;
            }
            if (num1 == 0) {
                res[i] = -1;
                continue;
            }
            res[i] = nums[i] - round(pow(2, num1 - 1));
        }
        return res;
    }
};",1420007973
CogentCoder73,cogentcoder73,553,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int k, num1;
        for (int i = 0; i < n; i++) {
            k = nums[i]; num1 = 0;
            while (k % 2 == 1) {
                num1++;
                k /= 2;
            }
            if (num1 == 0) {
                res[i] = -1;
                continue;
            }
            res[i] = nums[i] - round(pow(2, num1 - 1));
        }
        return res;
    }
};",1420008402
MarkovProcess,MarkovProcess,554,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        MOD=10**9+7
        com=[[0]*(x+1) for i in range(x+1)]
        for i in range(x+1):
            com[i][0]=1
            com[i][i]=1
        for i in range(2,x+1):
            for j in range(1,i):
                com[i][j]=(com[i-1][j-1]+com[i-1][j])%MOD
        yxmp=[1]
        for i in range(1,x+1):
            t=(yxmp[-1]*y)%MOD
            yxmp.append(t)
        xnmp=[pow(x-i,n,MOD) for i in range(x+1)]
        res=0
        for i in range(x):
            t=0
            for j in range(x+1-i):
                t+=xnmp[i+j]*((-1)**j)*com[x-i][j]
                t=t%MOD
            t=t*yxmp[x-i]*com[x][x-i]
            t=t%MOD
            res=(res+t)%MOD
        return res
",1420097991
MarkovProcess,MarkovProcess,554,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        def binary(x):
            res=[]
            while x>0:
                res.append(x%2)
                x=x//2
            return res
        def qq(z):
            res=0
            c=1
            for i in range(len(z)):
                res+=z[i]*c
                c*=2
            return res
        res=[]
        for w in nums:
            if w==2:
                res.append(-1)
            else:
                a=binary(w)
                n=len(a)
                z=[]
                if sum(a) ==n:
                    res.append(w//2)
                    continue
                end=n
                for i in range(n):
                    if a[i]==0:
                        end=i
                        break
                for i in range(end-1):
                    z.append(1)
                z.append(0)
                for i in range(end,n):
                    z.append(a[i])
                res.append(qq(z))
        return res",1420022417
MarkovProcess,MarkovProcess,554,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        def binary(x):
            res=[]
            while x>0:
                res.append(x%2)
                x=x//2
            return res
        def qq(z):
            res=0
            c=1
            for i in range(len(z)):
                res+=z[i]*c
                c*=2
            return res
        res=[]
        for w in nums:
            if w==2:
                res.append(-1)
            else:
                a=binary(w)
                n=len(a)
                z=[]
                if sum(a) ==n:
                    res.append(w//2)
                    continue
                end=n
                for i in range(n):
                    if a[i]==0:
                        end=i
                        break
                for i in range(end-1):
                    z.append(1)
                z.append(0)
                for i in range(end,n):
                    z.append(a[i])
                res.append(qq(z))
        return res

                    ",1420022157
Rishikant Kashyap,rkkashyap390,555,3604,cpp,"static bool calculated = false;
static bool calculated2 = false;
const int mod = 1e9+7;
const int factN = 1010;
int fact[1010];
int stirling[1010][1010];

class Solution {
public:

    inline int binary_exponentiation(long long a, int b){
        long long ans = 1;
        while(b){
            if(b&1) ans = (ans*a)%mod;
            a = (a*a)%mod;
            b >>= 1;
        }
        return (int)ans;
    }

    inline int inv(int a){
        return binary_exponentiation(a, mod-2);
    }

    void Factorials(){
        if(calculated) return;
        calculated = true;
        fact[0] = 1;
        for(int i=1; i<factN; i++) fact[i] = int((1LL*i*fact[i-1]) % mod);
        return;
    }

    inline int nCr(int a, int b){
        if(a<b) return 0;
        long long ans;
        ans = (1LL * fact[a] * inv(fact[b])) % mod;
        ans = (ans * inv(fact[a-b])) % mod;
        return (int)ans;
    }

    int rec(int n, int x){
        if(stirling[n][x]!=-1) return stirling[n][x];
        if(x==0 && n==0) return stirling[n][x] = 1;
        if(x==0 || x>n) return stirling[n][x] = 0;
        return stirling[n][x] = ((1LL*x*rec(n-1,x))%mod + rec(n-1,x-1))%mod;
    }

    void Stirlings(){
        if(calculated2) return;
        calculated2 = true;
        memset(stirling, -1, sizeof(stirling));
        for(int i=0; i<1010; i++){
            for(int j=0; j<1010; j++){
                rec(i, j);
            }
        }
    }

    int numberOfWays(int n, int x, int y) {
        Factorials();
        Stirlings();
        long long ans = 0;
        int k = min(n, x); // number of maximum different stages  
        for(int i=1; i<=k; i++){
            long long cans = 1;
            cans*=nCr(x, i); cans%=mod;
            cans*=fact[i]; cans%=mod;
            cans*=stirling[n][i]; cans%=mod;
            cans*=binary_exponentiation(y, i); cans%=mod;
            // cout<<i<<"" ""<<cans<<endl;
            ans = (ans+cans)%mod;
        }
        return ans;
    }
};",1420098147
Rishikant Kashyap,rkkashyap390,555,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(nums[i]==2) ans.push_back(-1);
            else {
                int y, fz=-1;
                for(int j=0; j<32; j++) if((nums[i]&(1<<j)) == 0){fz=j; break;}
                y = nums[i]^((1<<(fz-1)));
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420030549
Rishikant Kashyap,rkkashyap390,555,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(nums[i]==2) ans.push_back(-1);
            else {
                int y, fz=-1;
                for(int j=0; j<32; j++) if((nums[i]&(1<<j)) == 0){fz=j; break;}
                y = nums[i]^((1<<(fz-1)));
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420030912
Krishanu Saha,Krishanu_7,557,3604,cpp,"class Solution {
private:
    const int MODULO = 1e9 + 7;
    vector<vector<long long>> calculateCombs(int maxSize) {
        vector<vector<long long>> combinations(maxSize + 1, vector<long long>(maxSize + 1, 0));
        for (int i = 0; i <= maxSize; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MODULO;
            }
        }
        return combinations;
    }
    
    long long mod_exp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2; 
        }
        return result;
    } 
    
    vector<vector<long long>> calculatePartitions(int numPerformers, int numStages) {
        vector<vector<long long>> partitions(numPerformers + 1, vector<long long>(numStages + 1, 0));
        partitions[0][0] = 1;
        for (int i = 1; i <= numPerformers; ++i) {
            for (int j = 1; j <= numStages; ++j) {
                partitions[i][j] = (j * partitions[i - 1][j] + partitions[i - 1][j - 1]) % MODULO;
            }
        }
        return partitions;
    }

public:
    int numberOfWays(int numPerformers, int numStages, int maxScore) {
        auto factorial = calculateFactorials(numStages);
        auto partition = calculatePartitions(numPerformers, numStages);
        
        long long totalWays = 0;
        auto comb = calculateCombs(numStages);
        for (int bandCount = 1; bandCount <= numStages; ++bandCount) {
            long long scorePower = 1;
            for (int scoreIdx = 0; scoreIdx < bandCount; ++scoreIdx) {
                scorePower = (scorePower * maxScore) % MODULO;
            }
            long long term = comb[numStages][bandCount];
            term = (term * partition[numPerformers][bandCount]) % MODULO;
            term = (term * factorial[bandCount]) % MODULO;
            term = (term * scorePower) % MODULO;
            totalWays = (totalWays + term) % MODULO;
        }
        
        return (int)totalWays;
    }
    vector<long long> calculateFactorials(int maxSize) {
        vector<long long> factorials(maxSize + 1, 1);
        for (int i = 1; i <= maxSize; ++i) {
            factorials[i] = (factorials[i - 1] * i) % MODULO;
        }
        return factorials;
    }
};

",1420098870
Krishanu Saha,Krishanu_7,557,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size(); 
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j; 
                    break;
                }
            }
        }
        return ans;
    }
};",1419992925
Krishanu Saha,Krishanu_7,557,3611,cpp,"class Solution {
    int generateNumber(int num) {
        set<long long int> powerOfTwos;
        for (int i = 0; i <= 34; i++) {
            powerOfTwos.insert(1ll << i);
        }

        // Special case when num is a power of two minus one
        if (powerOfTwos.find(num * 1ll + 1ll) != powerOfTwos.end()) {
            return num / 2;
        }

        int highestSetBit = 0;
        for (int i = 0; i <= 30; i++) {
            if (num & (1 << i)) {
                highestSetBit = i;
            } else {
                break;
            }
        }

        int result = 0;
        for (int i = 30; i > highestSetBit; i--) {
            if (num & (1 << i)) {
                result |= (1 << i);
            }
        }

        for (int i = highestSetBit - 1; i >= 0; i--) {
            if (num & (1 << i)) {
                result |= (1 << i);
            }
        }

        return result;
    }

public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 0) {
                res[i] = -1;
            } else {
                res[i] = generateNumber(nums[i]);
            }
        }

        return res;
    }
};
",1420058209
Jimmy,JimmyK4542,561,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        M = 10**9+7
        binom = [[1],[1,1]]
        ster = [[1]]
        for j in xrange(1,max(n,x)+2):
            old = binom[-1]
            new = [1]+[old[i]+old[i+1] for i in xrange(j)]+[1]
            binom.append([z%M for z in new])

            old = ster[-1]
            new = [0]+[i*old[i]+old[i-1] for i in xrange(1,j)]+[1]
            ster.append([z%M for z in new])

        ans = 0
        factk = 1
        ypowk = 1
        for k in xrange(1,min(x,n)+1):
            factk *= k
            factk %= M
            ypowk *= y
            ypowk %= M

            term = ster[n][k]*binom[x][k]
            term %= M
            term *= factk
            term %= M
            term *= ypowk
            term %= M

            #print(k,term)

            ans += term
            ans %= M

        return ans",1420093035
Jimmy,JimmyK4542,561,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                count = 0
                while n%2 == 1:
                    count += 1
                    n /= 2
                n *= 2
                count -=1 
                while count > 0:
                    n = 2*n+1
                    count -=1
                ans.append(n)
        
        return ans",1420002264
Jimmy,JimmyK4542,561,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                count = 0
                while n%2 == 1:
                    count += 1
                    n /= 2
                n *= 2
                count -=1 
                while count > 0:
                    n = 2*n+1
                    count -=1
                ans.append(n)
        
        return ans",1420003639
Edward Lee,EdwardLeeMacau,562,3604,cpp,"class Solution {
public:
    #define MOD 1'000'000'007;
    using LL = long long;
    int numberOfWays(int N, int X, int Y) {
        std::vector<LL> dp(X+1); 
        LL ans = 0;
        LL y;
        int n, x, w, i;

        dp[1] = X;
        for (n = 2; n <= N; ++n) {
            for (i = X; i; --i) {
                dp[i] = (dp[i-1] * (X - (i - 1)) + dp[i] * i) % MOD;
            }

            // for (i = 0; i < X + 1; ++i) {
            //     cout << setw(4) << dp[i];
            // }
            // cout << endl;
        }

        ans = 0; y = 1;
        for (w = 1; w <= X; ++w) {
            y = (y * Y) % MOD; // power
            ans = (ans + dp[w] * y) % MOD;
        }

        return ans;
    }
};",1420093102
Edward Lee,EdwardLeeMacau,562,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n

        table = dict()
        for i in range(1000, 0, -1):
            table[i | (i + 1)] = i

        for i in range(n):
            res[i] = table.get(nums[i], -1)

        return res
",1419999648
Edward Lee,EdwardLeeMacau,562,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> res(n, 0);

        int pos = 0;
        int x;
        int i;
        for (i = 0; i < n; ++i) {
            for (x = nums[i], pos = 0; x & (1 << pos); ++pos)
                ;

            if (pos == 0) {
                res[i] = -1;
                continue;
            }
            
            res[i] = x ^ (1 << (pos - 1));
            // cout << x << setw(4) << (1 << (pos - 1)) << setw(4) << res[i] << endl;
        }

        return res;

    }
};",1420015352
Nampally Adarsh,Adarsh_N34,563,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        // Initialize dp array to track the minimum cost of matching the pattern
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // Base case: no characters matched means 0 cost
        
        // Boolean array to mark target indices
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // DP approach to find the minimum cost to match the entire pattern
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate maximum removals: total target indices minus the minimum cost to match the pattern
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420100033
Nampally Adarsh,Adarsh_N34,563,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        
        while params:
            break
        

        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        

        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways
        ",1420095753
Nampally Adarsh,Adarsh_N34,563,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            int k = nums[i];
            for(int n=1;n<=k;n++){
                if((n | (n+1)) == k){
                    ans[i] = n;
                    break;
                }
            }
        }
        return ans;
    }
};",1420038359
Sarthak Mathur,WORTH_IT,564,3604,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().numberOfWays(4, 4, 1));
//     }
// }

class Solution {

    static Combinatorics C = new Combinatorics(1001);

    public int numberOfWays(int n, int x, int y) {
        Mint Y = new Mint(y);
        Mint ans = Mint.ZERO;
        Mint[] count = new Mint[x + 1];
        count[0] = Mint.ZERO;

        Function<Integer, Mint> calcWays = new Function<Integer, Mint>() {
            @Override
            public Mint apply(Integer i) {
                Mint ans = new Mint(i).pow(n);
                for (int j = 1; j < i; j++)
                    ans = ans.sub(count[j].mul(C.C(i, j)));

                return ans;
            }
        };

        for (int i = 1; i <= Math.min(n, x); i++) { // i Stages used
            count[i] = calcWays.apply(i);
            ans = ans.add(Y.pow(i).mul(C.C(x, i).mul(count[i])));
        }

        return (int) ans.get();
    }
}

final class Mint { // 1000000007 998244353
    public static long mod = 1000000007;
    public static boolean modIsPrime = true;
    private final long val;

    public static final Mint ZERO = new Mint(0L);
    public static final Mint ONE = new Mint(1L);

    public static long norm(long val) {
        return (val %= mod) < 0 ? val + mod : val;
    }

    public static long norm(Integer val) {
        return norm(val.longValue());
    }

    public Mint(long val) {
        this.val = norm(val);
    }

    public Mint() {
        this(0);
    }

    public Mint(Mint arg) {
        this(arg.val);
    }

    public Mint(Integer arg) {
        this(arg.longValue());
    }

    public long get() {
        return val;
    }

    public Mint add(long arg) {
        return new Mint(this.val + norm(arg));
    }

    public Mint add(Mint arg) {
        return add(arg.val);
    }

    public Mint add(Integer arg) {
        return add(arg.longValue());
    }

    public Mint add(long... args) {
        Mint sum = this;
        for (long a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Mint... args) {
        Mint sum = this;
        for (Mint a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Integer... args) {
        Mint sum = this;
        for (Integer a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint sub(long arg) {
        return new Mint(val - norm(arg));
    }

    public Mint sub(Mint arg) {
        return sub(arg.val);
    }

    public Mint sub(Integer arg) {
        return sub(arg.longValue());
    }

    public Mint mul(long arg) {
        return new Mint(this.val * norm(arg));
    }

    public Mint mul(Mint arg) {
        return mul(arg.val);
    }

    public Mint mul(Integer arg) {
        return mul(arg.longValue());
    }

    public Mint mul(long... args) {
        Mint product = this;
        for (long a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint mul(Mint... args) {
        Mint product = this;
        for (Mint a : args)
            product = product.mul(a);
        return product;
    }

    public Mint mul(Integer... args) {
        Mint product = this;
        for (Integer a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint div(Mint arg) {
        return mul(arg.inv());
    }

    public Mint div(long arg) {
        return div(new Mint(arg));
    }

    public Mint div(Integer arg) {
        return div(new Mint(arg));
    }

    public Mint inv() {
        if (!modIsPrime)
            throw new ArithmeticException(val + "" cannot have inverse with mod "" + mod + ""!"");
        return pow(mod - 2);
    }

    public Mint pow(long arg) {
        if (arg < 0)
            return pow(-arg).inv();
        Mint pow = Mint.ONE;
        Mint temp = this;
        while (arg > 0) {
            if ((arg & 1) == 1)
                pow = pow.mul(temp);
            temp = temp.mul(temp);
            arg = arg >> 1;
        }
        return pow;
    }

    public Mint pow(Mint arg) {
        return pow(arg.val);
    }

    public Mint pow(Integer arg) {
        return pow(arg.longValue());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Mint mint = (Mint) o;
        return val == mint.val;
    }

    @Override
    public String toString() {
        return Long.toString(val);
    }
}

class Combinatorics {

    Mint[] factorial, inverseFactorial;

    public Combinatorics(int n) {
        factorial = new Mint[n + 10];
        inverseFactorial = new Mint[n + 10];
        precompute(n + 10);
    }

    public Combinatorics() {
        this(1000000);
    }

    private void precompute(int n) {
        factorial[0] = Mint.ONE;
        for (int i = 1; i < n; i++)
            factorial[i] = factorial[i - 1].mul(i);

        inverseFactorial[n - 1] = factorial[n - 1].inv();
        for (int i = n - 2; i >= 0; i--)
            inverseFactorial[i] = inverseFactorial[i + 1].mul(i + 1);
    }

    public Mint fact(int n) {
        return factorial[n];
    }

    public Mint invFact(int n) {
        if (n < 0)
            return Mint.ZERO;
        return inverseFactorial[n];
    }

    public Mint C(int n, int r) {
        if (r < 0 || r > n)
            return Mint.ZERO;
        return factorial[n].mul(inverseFactorial[r], inverseFactorial[n - r]);
    }

    public static long C(int n, int r, Combinatorics comb, boolean modular) {
        if (modular)
            return comb.C(n, r).get();

        if (r > n - r)
            r = n - r;
        long ans = 1;
        for (int i = r + 1; i <= n; i++) {
            ans *= i;
            ans /= i - r;
        }
        return ans;
    }

    public static long C(int n, int r, Combinatorics comb) {
        return comb == null ? C(n, r, null, false) : C(n, r, comb, true);
    }

    public Mint P(int n, int r) {
        if (r > n || r < 0)
            return Mint.ZERO;
        return factorial[n].mul(inverseFactorial[n - r]);
    }

    public static long P(int n, int r, Combinatorics comb, boolean modular) {
        if (modular)
            return comb.P(n, r).get();
        long ans = 1;
        for (int i = n - r + 1; i <= n; i++)
            ans *= i;
        return ans;
    }

    public static long P(int n, int r, Combinatorics comb) {
        return comb == null ? P(n, r, null, false) : P(n, r, comb, true);
    }

    public Mint inv(int n) {
        return inverseFactorial[n].mul(factorial[n - 1]);
    }

    @Override
    public String toString() {
        return ""Combinatorics till "" + (factorial.length - 1);
    }
}",1420094431
Sarthak Mathur,WORTH_IT,564,3605,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(Arrays.toString(new Solution().minBitwiseArray(List.of(11, 13, 31))));
//     }
// }

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int x = nums.get(i);
            if (x == 2) {
                ans[i] = -1;
                continue;
            }

            int last0 = 1 << Integer.numberOfTrailingZeros(~x);
            ans[i] = (x & ~(last0 >> 1)) | ((x & (last0 - 1)) >> 1);
            if ((ans[i] | (ans[i] + 1)) != x)
                ans[i] = x - 1;
        }

        return ans;
    }
}",1420004834
Sarthak Mathur,WORTH_IT,564,3611,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(Arrays.toString(new Solution().minBitwiseArray(List.of(11, 13, 31))));
//     }
// }

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int x = nums.get(i);
            if (x == 2) {
                ans[i] = -1;
                continue;
            }

            int last0 = 1 << Integer.numberOfTrailingZeros(~x);
            ans[i] = (x & ~(last0 >> 1)) | ((x & (last0 - 1)) >> 1);
            if ((ans[i] | (ans[i] + 1)) != x)
                ans[i] = x - 1;
        }

        return ans;
    }
}",1420005254
Vaibhav Singh,vaibhav_1710,565,3604,java,"class Solution {
    
    private final int MOD = 1000000007;
    
     private  long factorial(int n) {
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result = (result * i) % MOD;
        }
        return result;
    }

  
    private  long binomialCoefficient(int n, int k) {
        if (k > n || k < 0) return 0; // Not possible
        long numerator = 1;
        long denominator = 1;

        // Calculate n! / (k! * (n - k)!)
        for (int i = 0; i < k; i++) {
            numerator = (numerator * (n - i)) % MOD;
            denominator = (denominator * (i + 1)) % MOD;
        }

        // Modular inverse of denominator
        denominator = modularInverse(denominator);
        return (numerator * denominator) % MOD;
    }

   
    private  long modularInverse(long a) {
        return pow(a, MOD - 2);
    }

    
    public int numberOfWays(int n, int x, int y) {
        
        
        long[][] dp = calculateDP(n, Math.min(x,n));

      
       long totalWays = 0;

        // Sum up dp[n][i] * C(x, i) * i! * pow(y, i) for i from 1 to x
        for (int i = 1; i <= Math.min(x, n); i++) {
            long ways = dp[n][i] * binomialCoefficient(x, i) % MOD; // Choose i groups from x
            ways = (ways * factorial(i)) % MOD; // Multiply by i!
            ways = (ways * pow(y, i)) % MOD; // Multiply by y^i
            totalWays = (totalWays + ways) % MOD; // Accumulate total ways
        }
        
        return (int)totalWays;
    }
    
    private  long pow(long a, long b) {
        long result = 1;
        while (b > 0) {
            if ((b & 1) == 1) {
                result = (result * a) % MOD;
            }
            a = (a * a) % MOD;
            b >>= 1;
        }
        return result;
    }
    
    private  long[][] calculateDP(int n, int x) {
      
        long[][] dp = new long[n + 1][x + 1];

      
        dp[0][0] = 1l;

        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, x); j++) {
                dp[i][j] = (dp[i - 1][j - 1] + (j * dp[i - 1][j]) % MOD) % MOD;
            }
        }
        return dp;
    }


}",1420101962
Vaibhav Singh,vaibhav_1710,565,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int ans[] = new int[n];
        
        for(int i=0;i<n;i++){
            if(nums.get(i)==2){
                ans[i]=-1;
            }else{
                int cnt=0;
                for(int j=0;j<=30;j++){
                    if(((1<<j)&(nums.get(i)))>0){
                        cnt++;
                    }else{
                        break;
                    }
                }
                   
                        if(cnt==1){
                            ans[i] = nums.get(i)-1;
                        }else{
                            int v = 0;
                            for(int j=0;j<=30;j++){
                                if(((1<<j)&(nums.get(i)))>0){
                                    if(cnt>1){
                                        v |= (1<<j);
                                        cnt--;
                                    }else if(cnt==1){
                                        cnt--;
                                    }else{
                                        v |= (1<<j);
                                    }
                                }
                            }
                            ans[i] = v;
                        }
                    
                }
        }
        return ans;
    }
}",1420025606
Vaibhav Singh,vaibhav_1710,565,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int ans[] = new int[n];
        
        for(int i=0;i<n;i++){
            if(nums.get(i)==2){
                ans[i]=-1;
            }else{
                int cnt=0;
                for(int j=0;j<=30;j++){
                    if(((1<<j)&(nums.get(i)))>0){
                        cnt++;
                    }else{
                        break;
                    }
                }
                   
                        if(cnt==1){
                            ans[i] = nums.get(i)-1;
                        }else{
                            int v = 0;
                            for(int j=0;j<=30;j++){
                                if(((1<<j)&(nums.get(i)))>0){
                                    if(cnt>1){
                                        v |= (1<<j);
                                        cnt--;
                                    }else if(cnt==1){
                                        cnt--;
                                    }else{
                                        v |= (1<<j);
                                    }
                                }
                            }
                            ans[i] = v;
                        }
                    
                }
        }
        return ans;
    }
}",1420025374
wshldwps,wshldwps,566,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        out = 0
        DP = defaultdict(int) # k1 people, k2 bands#, v times
        DP[(1,1)] = x * y
        for i in range(2, n+1):
            # ith people
            for j in range(1, min(i, x + 1)):
                # j bands
                # add to j
                DP[(i, j)] = (DP[(i, j)] + DP[(i-1, j)] * j) % (10**9 + 7)
                # add to new band
                DP[(i, j+1)] = (DP[(i, j+1)] + DP[i-1, j] * (x - j) * y) % (10**9 + 7)
        for i in range(1, x + 1):
            out = (out + DP[(n, i)]) % (10**9 + 7)


        return out",1420102034
wshldwps,wshldwps,566,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        out = [-1 for i in range(len(nums))]
        for i in range(len(nums)):
            for k in range(0, 1001):
                if (k | (k+1)) == nums[i]:
                    out[i] = k
                    break
        return out",1419998256
wshldwps,wshldwps,566,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        out = [-1 for i in range(len(nums))]
        for i in range(len(nums)):
            bits = self.n2b(nums[i])
            if (bits[0] == 1):
                for j in range(31):
                    if bits[j+1] == 1:
                        bits[j] = 0
                    else:
                        break
                num = self.b2n(bits) - 1
                out[i] = num
        return out
    
    def n2b(self, number):
        bits = [0 for i in range(31)]
        for i in range(30, -1, -1):
            if number / 2 ** i >= 1:
                bits[i] = 1
            number = number % 2 ** i
        return bits

    def b2n(self, bits):
        num = 0
        for i in range(31):
            num += bits[i] * 2 ** i
        return num",1420061269
liuvivi412,liuvivi412,568,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        max_nk = max(n, x) + 10
        mod = 10**9 + 7

        fact = [1] * max_nk
        inv_fact = [1] * max_nk
        for i in range(1, max_nk):
            fact[i] = fact[i - 1] * i % mod
        inv_fact[max_nk - 1] = pow(fact[max_nk - 1], mod - 2, mod)
        for i in range(max_nk - 2, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

        total = 0
        min_k = min(n, x)
        for k in range(1, min_k + 1):
            inv_k_fact = inv_fact[k]
            S = 0
            for j in range(k + 1):
                sign = -1 if j % 2 else 1
                C_kj = fact[k] * inv_fact[j] % mod * inv_fact[k - j] % mod
                pow_term = pow(k - j, n, mod)
                S = (S + sign * C_kj * pow_term) % mod
            S = S * inv_k_fact % mod

            C_xk = fact[x] * inv_fact[k] % mod * inv_fact[x - k] % mod

            k_fact = fact[k]

            y_pow_k = pow(y, k, mod)

            term = C_xk * k_fact % mod * S % mod * y_pow_k % mod

            total = (total + term) % mod
        return total",1420096561
liuvivi412,liuvivi412,568,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        ans=[]
        for num in nums:
            if num==2:
                ans.append(-1)
            else:
                res=num//2
                while res|res+1!=num:
                    res+=1
                ans.append(res)
        return ans",1420022577
liuvivi412,liuvivi412,568,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # 100 101
        # 1001 1011
        # 11 111
        # 1100 1101
        n=len(nums)
        ans=[]
        for num in nums:
            if num==2:
                ans.append(-1)
            else:
                bin_num=list(bin(num))[2:]
                i=len(bin_num)-1
                while i>=0 and bin_num[i]=='1':
                    i-=1
                bin_num[i+1]='0'
                ans.append(int(''.join(bin_num),2))
        return ans",1420044451
Skyler Tsai,SkylerTsai,569,3604,python3,"from math import factorial

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        def Cn_x(n, x):
            if x > n: return 0
            return factorial(n) // (factorial(x) * factorial(n - x))
        
        mod = 10 ** 9 + 7
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % mod
        
        ret = 0
        for i in range(1, n + 1):
            temp = Cn_x(x, i) * dp[n][i] * factorial(i) * pow(y, i, mod)
            ret += temp % mod
        
        return ret % mod
        
            ",1420090301
Skyler Tsai,SkylerTsai,569,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for num in nums:
            if num % 2 == 0: 
                ret.append(-1)
                continue
            tar = bin(num)[2:]
            x = 0
            for i in range(len(tar) - 1, -1, -1):
                if tar[i] != '1': break
                x += 1
            temp = tar[:len(tar) - x] + '0' + (x - 1) * '1'
            #print(num, tar, x, temp)
            ret.append(int(temp, 2))
        return ret",1420016376
Skyler Tsai,SkylerTsai,569,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for num in nums:
            if num % 2 == 0: 
                ret.append(-1)
                continue
            tar = bin(num)[2:]
            x = 0
            for i in range(len(tar) - 1, -1, -1):
                if tar[i] != '1': break
                x += 1
            temp = tar[:len(tar) - x] + '0' + (x - 1) * '1'
            #print(num, tar, x, temp)
            ret.append(int(temp, 2))
        return ret",1420017042
sparshjaggi2307,sparshjaggi2307,570,3604,cpp,"#include <vector>

using namespace std;

class Solution {
private:
    const int MOD = 1e9 + 7;  // Constant for modulo operation to prevent overflow

    // Function to compute binomial coefficients using Pascal's triangle
    vector<vector<long long>> computeBinomialCoefficients(int limit) {
        vector<vector<long long>> binomials(limit + 1, vector<long long>(limit + 1, 0));
        for (int i = 0; i <= limit; ++i) {
            binomials[i][0] = 1;  // Base case: C(n, 0) = 1
            for (int j = 1; j <= i; ++j) {
                // Using the recurrence relation to fill the table
                binomials[i][j] = (binomials[i - 1][j - 1] + binomials[i - 1][j]) % MOD;
            }
        }
        return binomials;
    }

    // Function to compute the number of partitions of n using k parts
    vector<vector<long long>> computePartitions(int total, int parts) {
        vector<vector<long long>> partitions(total + 1, vector<long long>(parts + 1, 0));
        partitions[0][0] = 1;  // One way to partition zero
        
        // Filling the partition table
        for (int i = 1; i <= total; ++i) {
            for (int j = 1; j <= parts; ++j) {
                // The number of ways to partition using the current number
                partitions[i][j] = (j * partitions[i - 1][j] + partitions[i - 1][j - 1]) % MOD;
            }
        }
        return partitions;
    }

    // Function to compute factorials up to a given size
    vector<long long> computeFactorials(int size) {
        vector<long long> factorials(size + 1, 1);  // Initialize factorials
        for (int i = 1; i <= size; ++i) {
            // Computing factorial iteratively
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }
        return factorials;
    }

public:
    // Main function to calculate the number of ways
    int numberOfWays(int n, int x, int y) {
        // Compute combinations, partitions, and factorials
        auto binomials = computeBinomialCoefficients(x);
        auto partitions = computePartitions(n, x);
        auto factorials = computeFactorials(x);
        
        long long totalWays = 0;  // Variable to store the total count of ways
        
        // Iterate through each possible number of parts
        for (int k = 1; k <= x; ++k) {
            long long powerValue = 1;  // Initialize power term
            for (int p = 0; p < k; ++p) {
                // Calculate y^k for the current k
                powerValue = (powerValue * y) % MOD;
            }
            long long currentContribution = binomials[x][k];  // Current contribution from combinations
            // Combine contributions from partitions and factorials
            currentContribution = (currentContribution * partitions[n][k]) % MOD;
            currentContribution = (currentContribution * factorials[k]) % MOD;
            currentContribution = (currentContribution * powerValue) % MOD;
            totalWays = (totalWays + currentContribution) % MOD;  // Accumulate the total
        }
        
        return static_cast<int>(totalWays);  // Return the final result as an integer
    }
};
",1420061248
sparshjaggi2307,sparshjaggi2307,570,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    // Helper function to find the smallest x such that (x | (x + 1)) equals the given prime number
    int findMinimumX(int target) {
        // Iterate through numbers starting from 1 up to the target
        for (int candidate = 1; candidate <= target; ++candidate) {
            // Check if ORing candidate and candidate+1 equals the target
            if ((candidate | (candidate + 1)) == target) {
                return candidate;  // Return the smallest valid candidate
            }
        }
        return -1;  // If no valid candidate is found, return -1
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();  // Get the size of the input array
        vector<int> result(size, -1);  // Initialize the result array with -1 as default values

        // Loop through each element of the input array
        for (int index = 0; index < size; ++index) {
            // For each element, find the corresponding minimum value using findMinAns
            result[index] = findMinimumX(nums[index]);
        }

        return result;  // Return the computed result array
    }
};
",1420024536
sparshjaggi2307,sparshjaggi2307,570,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    // Function to find the minimal bitwise representation for each number in the input array
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int size = nums.size(); // Get the size of the input array
        std::vector<int> result(size); // Initialize the answer vector of the same size
        
        // Iterate through each number in the input array
        for (int index = 0; index < size; index++) {
            int currentNum = nums[index]; // Current number being processed
            int minCandidate = INT_MAX; // Initialize the minimal candidate to the maximum integer value
            bool isCandidateFound = false; // Flag to indicate if a valid candidate was found
            
            // Check each bit position from 0 to 30
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                // If the current bit is set in the number
                if ((currentNum >> bitPosition) & 1) {
                    // Create a candidate by turning off the current bit
                    int modifiedNum = currentNum & ~(1 << bitPosition);
                    
                    // Skip if modifiedNum is negative (should not happen in this case)
                    if (modifiedNum < 0) continue;
                    
                    // Check if the modified number is valid by ensuring it forms the same number
                    // when OR-ed with (modifiedNum + 1)
                    if ((modifiedNum | (modifiedNum + 1)) == currentNum) {
                        // If the modified number is less than the current minimal candidate, update it
                        if (modifiedNum < minCandidate) {
                            minCandidate = modifiedNum; // Update minimal candidate
                            isCandidateFound = true; // Set found to true
                        }
                    }
                }
            }
            
            // If a valid candidate was found, store it; otherwise, store -1
            if (isCandidateFound) {
                result[index] = minCandidate; // Store the minimal candidate
            } else {
                result[index] = -1; // No valid candidate found
            }
        }
        
        return result; // Return the result vector
    }
};
",1420083605
Surya Teja,suryacr7,572,3604,cpp,"#define ll long long
class Solution {
vector<int>factorial;
public:
const int N=1e9+7;
    int pw(int a,int b,int c){
    ll ans=1;
    while(b>0){
        if(b&1){
            ans=(ans%N*1ll*a%c)%c;
        }
        a=(a%c*1ll*a%c)%c;
        b>>=1;
    }
    return ans;
}
    
int fac(int a, int b){
ll x=factorial[a]%N;
ll d=(factorial[b]*1ll*factorial[a-b])%N;
ll y=pw(d,N-2,N);
ll ans=(x%N*y)%N;
return ans;
}
    
    ll sur(int n,int r){
        ll ans=0;
        for(int i=0;i<r;i++){
            if(i&1){
                ans-=(fac(r,i)*1ll*(pw(r-i,n,N)))%N;
                ans%=N;
                (ans+=N)%=N;
            }else{
                ans+=(fac(r,i)*1ll*(pw(r-i,n,N)))%N;
                ans%=N;
            }
        }
        return ans%N;
    }
    
    int numberOfWays(int n, int x, int y) {
    factorial.resize(1010);
    factorial[0]=1;
for(int i=1;i<=1e3;++i){
    factorial[i]=(factorial[i-1]*1ll*i)%N;
}
        ll ans=0;
        for(int i=1;i<=min(n,x);i++){
            ll temp=1;
            temp*=fac(x,i);
            temp=temp*1ll*pw(y,i,N);
            temp%=N;
            temp=temp*1ll*sur(n,i);
            temp%=N;
            (ans+=temp)%=N;
            // cout<<ans<<"" "";
        }
        return ans;
        
    }
};",1420090948
Surya Teja,suryacr7,572,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        int n=v.size();
        
        for(int i=0;i<n;i++){
            int x=log2(v[i])+1;
            int y=__builtin_popcount(v[i]);
            if(x==y){
                ans.push_back((1<<(x-1))-1);
            }else{
                int temp=v[i];
                int last=0;
                while(temp&1){
                    temp/=2;
                    last++;
                }
                temp<<=last;
                if(last){
                    temp|=((1<<(last-1))-1);
                    ans.push_back(temp);
                }else{
                    ans.push_back(-1);
                }
                
            }
        }
        return ans;
    }
};",1420007273
Surya Teja,suryacr7,572,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        int n=v.size();
        
        for(int i=0;i<n;i++){
            int x=log2(v[i])+1;
            int y=__builtin_popcount(v[i]);
            if(x==y){
                ans.push_back((1<<(x-1))-1);
            }else{
                int temp=v[i];
                int last=0;
                while(temp&1){
                    temp/=2;
                    last++;
                }
                temp<<=last;
                if(last){
                    temp|=((1<<(last-1))-1);
                    ans.push_back(temp);
                }else{
                    ans.push_back(-1);
                }
                
            }
        }
        return ans;
    }
};",1420006737
Atharv Tiwari,atharv_tiwari,573,3604,cpp,"class Solution {
public:
    long long power_fn (long long a, long long b, long long mod)
    {
        long long x = a;
        long long ans = 1;

        while (b != 0)
        {
            if (b % 2 == 1)
            {
                ans *= x;
                ans %= mod;
            }

            b /= 2;

            x *= x;
            x %= mod;
        }

        return ans;
    }

    long long modulo_inverse (long long n, long long mod)
    {
        return power_fn (n, (mod - 2), mod);
    }

    long long modulo_inverse_factorial (long long n, long long mod, vector <long long> &fct)
    {
        return power_fn (fct[n], (mod - 2), mod);
    }

    long long nCr (long long n, long long r, long long mod, vector <long long> &fct, vector <long long> &m_i)
    {
        if (n < r)
        {
            return 0;
        }

        if (r == 0)
        {
            return 1;
        }

        long long x, i, k;
        x = fct[n];

        x *= m_i[r];
        x = (x % mod);

        x *= m_i[n - r];
        x = (x % mod);

        return x;
    }

    void helper (vector <long long> &fct, vector <long long> &m_i) 
    {
        long long num = 1;
        fct[0] = 1;
        
        long long mod = 1000000007;
        for (long long i = 1; i < 3001; i++)
        {
            num *= i;
            num = (num % mod);
            fct[i] = num;
        }
        
        for (long long i = 0; i < 3001; i++)
        {
            m_i[i] = modulo_inverse_factorial (i, mod, fct);
        }
    }

    int numberOfWays(int xx, int nn, int yy) 
    {
        vector <long long> fct (3001, 0);
        vector <long long> m_i (3001, 0);

        helper (fct, m_i);
        long long i, n, x, y;

        n = nn, x = xx, y = yy;
        long long mod = 1000000007;

        long long ans = 0;
        // n stages

        for (i = 1; i <= n; i++) 
        {
            long long num = nCr (n, i, mod, fct, m_i);
            long long val = power_fn (i, x, mod);

            bool check = false;
            for (int j = (i - 1); j > 0; j --) 
            {
                long long temp = power_fn (j, x, mod);
                temp *= nCr (i, j, mod, fct, m_i), temp %= mod;

                if (check) 
                {
                    val += temp;
                }
                else 
                {
                    val -= temp;
                }

                if (val < 0) 
                {
                    val += mod;
                }

                val %= mod;
                check ^= true;
            }           

            long long sum = (num * val);
            sum %= mod;

            sum *= power_fn (y, i, mod);
            sum %= mod;

            ans += sum;
            ans %= mod;

            // cout << ans << "" "" << num << "" "" << val << "" "" << sum << endl;
        }

        return ans;
    }
};",1420104754
Atharv Tiwari,atharv_tiwari,573,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        vector <int> vt (2001, -1);
        for (int i = 1000; i > 0; i--) 
        {
            vt[(i | (i + 1))] = i;
        }

        int n = nums.size();
        vector <int> vans;

        for (int i = 0; i < n; i++) 
        {
            vans.push_back (vt[nums[i]]);
        } 

        return vans;  
    }
};",1420005821
Atharv Tiwari,atharv_tiwari,573,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector <int> vans;

        for (int i = 0; i < n; i++) 
        {
            int num = 1, val = nums[i];
            if (nums[i] == 2) 
            {
                vans.push_back (-1);
                continue;
            }

            while (num <= val) 
            {
                if ((num & val) == 0) 
                {
                    break;
                }

                num *= 2;
            }

            int ans = 0;
            
            if (num <= val) 
            {
                ans += (val - num);
                ans ++;
            }
           
            ans += ((num - 1) / 2);
            vans.push_back (ans);
        }

        return vans;
    }
};",1420017529
Saurav Kumar,kumar_23,575,3604,cpp,"class Solution {
public:
#define ll long long
    const ll m = 1e9 + 7;
    ll fac[1001], inv[1001];

    ll bin(ll x, ll p){
        if(p==0)return 1;
        ll full = bin(x, p/2);
        full = (full*full)%m;
        if(p%2==0)return full;
        return (full*x)%m;
    }

    ll ncr(ll n, ll r){
        ll ans = (fac[n]*inv[r])%m;
        ans = (ans*inv[n-r])%m;
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        ll ans = 0;
        fac[0] = 1; inv[0] = bin(fac[0], m-2);
        for(ll i = 1; i<=1000; i++){
            fac[i] = (fac[i-1]*i)%m;
            inv[i] = bin(fac[i], m-2);
        }
        for(ll s = 1; s<=min(n, x); s++){
            // xCs.
            ll tot = (bin(s, n))%m;
            ll sign = -1;
            for(ll j = s-1; j>=1; j--){
                ll cur = (bin(j,n)*ncr(s,j))%m;
                tot = (tot + sign*cur + m)%m;
                sign*=-1;
            }
            tot = (tot*ncr(x,s))%m;
            // cout<<s<<""->""<<tot<<endl;
            ans = (ans + (tot*bin(y, s))%m)%m;
        }
        return ans;
    }
};",1420105807
Saurav Kumar,kumar_23,575,3605,cpp,"class Solution {
public:
    bool check(int n){
        n++;
        int cnt = 0;
        while(n){
            cnt += (n&1);
            n/=2;
        }
        return cnt==1;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i<n; i++){
            for(int j = 0; j<=1000; j++){
                if((j|(j+1))==nums[i]){
                    ans[i] = j; break;
                }
            }
        }
        // for(int i = 0; i<n; i++){
        //     if(nums[i]&1){
        //         if(check(nums[i]))
        //         ans[i] = nums[i]/2;
        //         else ans[i] = nums[i]-1;
        //     }
        //     else ans[i] = -1;
        // }
        return ans;
    }
};",1420013435
Saurav Kumar,kumar_23,575,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(auto x: nums){
            if(x%2==0)ans.push_back(-1);
            else{
                int a = x;
                int ind = 0, i = -1;
                while(1){
                    if(x&(1<<ind)){

                    }
                    else{
                        i = ind-1;break;
                    }
                    ind++;
                }
                ans.push_back((a^(1<<i)));
            }
        }
        return ans;
    }
};",1420031233
urverymean,urverymean,576,3604,cpp,"typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
#define MOD 1000000007
template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
class Combinations {
public:
  vector<mint> inv, fact, ifact;
 
  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};
Combinations c(1005);
class Solution {
public:
    int numberOfWays(ll n, ll x, ll y) {
        mint res = 0;
        for (int i = 1; i<=x; i++){
            if (i > n) break;
            mint ways = c.comb(x, i);
            ways*=binpow(y,i,MOD);
            mint curr = 0;
            for (int h = 0; h<=i; h++){
                if (h%2==0){
                    curr+=c.comb(i,h)*binpow(i-h, n,MOD);
                }
                else{
                    curr-=c.comb(i,h)*binpow(i-h, n,MOD);
                }
            }
            ways*=curr;
            res+=ways;
        }
        return res.x;
    }
};",1420106076
urverymean,urverymean,576,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def find(f):
            for i in range(f+1):
                if i|i+1==f:
                    return i
            return -1
        return [find(x) for x in nums]",1420021891
urverymean,urverymean,576,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(len(nums)):
            if nums[i]%2==0:
                res.append(-1)
                continue
            f = False
            for bit in range(32,-1,-1):
                if nums[i]&(1<<bit):
                    x = nums[i]^(1<<bit)
                    if x|(x+1)==nums[i]:
                        f = True
                        res.append(x)
                        break
            if not f:
                res.append(-1)
        return res",1420060995
ARUNMOZHICHELVAN,ARUNMOZHICHELVAN,577,3487,java,"

class Solution {
    

    public static boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    public static int arunmozhichelvanLeetcode(){
        int x=11;
        int y=89;
        return x+y;
    }
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int len = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        arunmozhichelvanLeetcode();
        
        boolean[] isTargetAns = new boolean[len];
        for (int idx : targetIndices) {
            isTargetAns[idx] = true;
        }
        isPalindrome(""ARUN"");
        for (int i = 0; i < len; i++) {
            arunmozhichelvanLeetcode();
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTargetAns[i] ? 1 : 0));
                }
            }
        }
        isPalindrome(""ARUN"");
        
        int finalAns=targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
        return finalAns;
    }
    
    
}

",1420106359
ARUNMOZHICHELVAN,ARUNMOZHICHELVAN,577,3604,java,"public class Solution {
    private static final int MOD = (int)(1e9+7);

    
    static long[][] comComb(int size) {

        long[][] ans = new long[size + 1][size + 1];
        for (int i = 0; i <= size; i++) {
            arunmozhichelvanLeetcode();
            ans[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % MOD;
            }
        }
        return ans;
    }

    public static boolean isPalindrome(String str) {
            int left = 0;
            int right = str.length() - 1;
            
            while (left < right) {
                if (str.charAt(left) != str.charAt(right)) {
                    return false;
                }
                left++;
                right--;
            }
            return true;
    }

    // Computes partitions S(n, k)
    static long[][] comPart(int n, int x) {
        long[][] ans = new long[n + 1][x + 1];
        ans[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                ans[i][j] = (j * ans[i - 1][j] + ans[i - 1][j - 1]) % MOD;
            }
            arunmozhichelvanLeetcode();
        }
        return ans;
    }

    // Computes factorials
    static long[] comFact(int size) {
        long[] fact = new long[size + 1];
        fact[0] = 1;
        arunmozhichelvanLeetcode();
        for (int i = 1; i <= size; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    public static void arunmozhichelvanLeetcode(){
            int x=11;
            int y=89;
            return ;
        }

    public int numberOfWays(int n, int x, int y) {
        long[][] C = comComb(x);
        long[][] S = comPart(n, x);
        long[] fact = comFact(x);

        long ans = 0;
        isPalindrome(""ARUNMOZHI"");
        for (int k = 1; k <= x; k++) {
            long po = 1;
            for (int p = 0; p < k; p++) {
                po = (po * y) % MOD;
            }
            long te = C[x][k];
            arunmozhichelvanLeetcode();
            te = (te * S[n][k]) % MOD;
            te = (te * fact[k]) % MOD;
            te = (te * po) % MOD;
            ans = (ans + te) % MOD;
            arunmozhichelvanLeetcode();
        }
        isPalindrome(""ARUNMOZHI"");

        return (int) ans;
    }

}
",1420069159
ARUNMOZHICHELVAN,ARUNMOZHICHELVAN,577,3605,java,"class Solution {
    public static boolean isPalindrome(String str) {
            int left = 0;
            int right = str.length() - 1;
            
            while (left < right) {
                if (str.charAt(left) != str.charAt(right)) {
                    return false;
                }
                left++;
                right--;
            }
            return true;
        }
    public int[] minBitwiseArray(List<Integer> nums) {
        int ans[]=new int[nums.size()];
        int k=0;
        int flag=0;
        isPalindrome(""asdfasdf"");
        for(int x: nums){
            flag=0;
            for(int i=1;i<=x;i++){
                if((i | (i+1)) == x){
                    ans[k++]=i;flag=1;break;
                }
            }
            if(flag==0) ans[k++]=-1;
        }
        isPalindrome(""asdfasdddd"");
        return ans;
    }
}
",1420032071
Pranav Kulkarni,pranavkulkarni610,578,3604,cpp,"class Solution {
    using ll = long long;
    ll mod = 1e9 + 7;
    ll fact[1001];
    ll binpow(ll a, ll b){
        a %= mod;
        ll res = 1;
        while(b){
            if(b&1) res = res * a % mod;
            b >>= 1;
            a = a * a % mod;
        } 
        return res;
    }
    ll ncr(ll n, ll r){
        ll res = fact[n];
        res = res * binpow(fact[r], mod-2) % mod;
        res = res * binpow(fact[n-r], mod-2) % mod;
        return res;
    }
    ll calc(ll x, ll n){
        ll ans = 0;
        for(ll i=0; i<x; i++){
            ll mult = (i&1) ? -1 : 1;
            mult = mult * ncr(x, i) % mod;
            mult = mult * binpow(x-i, n) % mod;
            ans = (ans + mult)%mod;
        }
        return ans;
    }
public:
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        for(ll i=1; i<=1000; i++) fact[i] = fact[i-1] * i % mod;
        ll ans = 0;
        for(ll i=1; i<=min(n, x); i++){
            ll mult = ncr(x, i);
            mult = mult * calc(i, n) % mod;
            mult = mult * binpow(y, i) % mod;
            ans = (ans + mult)%mod;
        }
        if(ans < 0) ans = (ans + mod)%mod;
        return ans;
    }
};",1420079375
Pranav Kulkarni,pranavkulkarni610,578,3605,cpp,"class Solution {
    int get(int x){
        int ret = 0;
        for(int i=0; i<32; i++){
            if(x&(1<<i)) ret++;
            else break;
        }
        return ret;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int ret = get(nums[i]);
            if(ret == 0) ans[i] = -1;
            else ans[i] = nums[i] - ((1<<ret)-1) + (1<<(ret-1)) - 1;
        }
        return ans;
    }
};",1420006902
Pranav Kulkarni,pranavkulkarni610,578,3611,cpp,"class Solution {
    int get(int x){
        int ret = 0;
        for(int i=0; i<32; i++){
            if(x&(1<<i)) ret++;
            else break;
        }
        return ret;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int ret = get(nums[i]);
            if(ret == 0) ans[i] = -1;
            else ans[i] = nums[i] - ((1<<ret)-1) + (1<<(ret-1)) - 1;
        }
        return ans;
    }
};",1420006311
Jasteg Singh,jastegsingh007,579,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        def modinv(a):
            return pow(a, MOD - 2, MOD)
        def js(n):
            S = [[0] * (n + 1) for _ in range(n + 1)]
            S[0][0] = 1
            for i in range(1, n + 1):
                for j in range(1, i + 1):
                    S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
            return S
        maxk = min(n, x)
        fact = [1] * (maxk + 1)
        for i in range(1, maxk + 1):
            fact[i] = fact[i - 1] * i % MOD
        stirling = js(n)
        tt = 0
        for kk in range(1, maxk + 1):
            binom = 1
            for i in range(kk):
                binom = binom * (x - i) % MOD * modinv(i + 1) % MOD
            s = stirling[n][kk]
            perm = fact[kk]
            pow_y_kk = pow(y, kk, MOD)
            term = binom * s % MOD * perm % MOD * pow_y_kk % MOD
            tt = (tt + term) % MOD
        return tt

        ",1420093553
Jasteg Singh,jastegsingh007,579,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        ans=[-1 for _ in range(n)]
        for i in range(n):
            for j in range(nums[i]):
                if (j|(j+1))==nums[i]:
                    ans[i]=j
                    break
        return ans
        ",1420003946
Jasteg Singh,jastegsingh007,579,3611,python3,"class Solution:
    def minimal_x(self,N):
        min_x = -1
        for s in range(N.bit_length()):
            if N & (1 << s):
                x = N - (1 << s)
                if x >= 0:
                    if x | (x + 1) == N:
                        if min_x == -1 or x < min_x:
                            min_x = x
        return min_x
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            ans.append(self.minimal_x(N))
        return ans
                ",1420072680
Himanshu Kumar,himanshukumar7349820018,580,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420061220
Himanshu Kumar,himanshukumar7349820018,580,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420108257
Himanshu Kumar,himanshukumar7349820018,580,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420007820
rath772k,rath772k,581,3604,python3,"MOD = int(1e9 + 7)
# Python3 program to answer queries
# of nCr in O(1) time.
N = 1001

# array to store inverse of 1 to N
factorialNumInverse = [None] * (N + 1)

# array to precompute inverse of 1! to N!
naturalNumInverse = [None] * (N + 1)

# array to store factorial of 
# first N numbers
fact = [None] * (N + 1)

# Function to precompute inverse of numbers
def InverseofNumber(p):
	naturalNumInverse[0] = naturalNumInverse[1] = 1
	for i in range(2, N + 1, 1):
		naturalNumInverse[i] = (naturalNumInverse[p % i] *
								(p - int(p / i)) % p)

# Function to precompute inverse 
# of factorials
def InverseofFactorial(p):
	factorialNumInverse[0] = factorialNumInverse[1] = 1

	# precompute inverse of natural numbers
	for i in range(2, N + 1, 1):
		factorialNumInverse[i] = (naturalNumInverse[i] *
								factorialNumInverse[i - 1]) % p

# Function to calculate factorial of 1 to N
def factorial(p):
	fact[0] = 1

	# precompute factorials
	for i in range(1, N + 1):
		fact[i] = (fact[i - 1] * i) % p

# Function to return nCr % p in O(1) time
def Binomial(N, R, p):
	
	# n C r = n!*inverse(r!)*inverse((n-r)!)
	ans = ((fact[N] * factorialNumInverse[R])% p *
					factorialNumInverse[N - R])% p
	return ans

InverseofNumber(MOD)
InverseofFactorial(MOD)
factorial(MOD)

class Solution:
    def numberOfWays(self, n: int, X: int, y: int) -> int:
        def fast_exp(x, p):
            res = 1
            while p:
                if p & 1: 
                    res = (res * x) % MOD
                x = (x * x) % MOD
                p >>= 1
            return res
        ans = 0
        for b in range(1, min(X, n)+1):
            band_partitions = 0 # {n, b}
            for j in range(1, b+1):
                band_partitions += fast_exp(MOD-1, b-j) * Binomial(b, j, MOD) % MOD * fast_exp(j, n) % MOD
                band_partitions %= MOD 
            ans += band_partitions * Binomial(X, b, MOD) % MOD * fast_exp(y, b) % MOD
            ans %= MOD
        return ans",1420108866
rath772k,rath772k,581,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def fn(x):
            if x == 2:
                return -1
            s = bin(x)
            cur = len(s) - 1
            while s[cur - 1] == ""1"":
                cur -= 1
            new_s = s[:cur] + ""0"" + s[cur+1:]
            return int(new_s, base=2)
            
        return [fn(el) for el in nums]",1420027058
rath772k,rath772k,581,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def fn(x):
            if x == 2:
                return -1
            s = bin(x)
            cur = len(s) - 1
            while s[cur - 1] == ""1"":
                cur -= 1
            new_s = s[:cur] + ""0"" + s[cur+1:]
            return int(new_s, base=2)
            
        return [fn(el) for el in nums]",1420026654
Pranab Krushna Sahoo,Zen_10_000,582,3604,cpp,"using lli =long long;
lli p=1e9+7;

lli n,x,y;
vector<lli> fact;
lli dp[1005];

lli po(lli a,lli b){
    lli ans=1;
    while(b){
        if(b%2)ans=(ans*a)%p;
        a=(a*a)%p;
        b/=2;
    }
    return ans;
}

lli com(lli up,lli dow){
    lli ans=1;
    lli tem2=(fact[dow]*fact[up-dow])%p;
    ans=(fact[up]*po(tem2,p-2))%p;
    return ans;
}

lli rec(lli s){
    // #of ways to have n performers in s stages

    
    if(s==1) return 1;

    if(dp[s]!=-1)return dp[s];

    lli num=0;
    for(int i=1;i<s;i++){
        //+=sCi*rec(i,p);
        num= (num + (com(s,i)*rec(i))%p )%p;
    }
    
    lli ans=po(s,n);
    ans= (ans-num+p)%p;

    return dp[s]=ans;
    // return 0;
}


class Solution {
public:
    int numberOfWays(int num, int xst, int ysc) {
        if(fact.size()==0){
            fact.push_back(1);
            for(int i=1;i<1005;i++){
                lli num=(i*fact[i-1])%p;
                fact.push_back(num);
            }
        }

        
        n=num;x=xst;y=ysc;

        memset(dp,-1,sizeof(dp));

        lli ans=0;
        for(int i=1;i<=x;i++){
            ans = (ans+ (((com(x,i)*rec(i))%p)*po(y,i))%p)%p;
        }
        // cout<<po(2,10)<<'\n';
        // cout<<fact[7];
        // cout<<com(100,3);
        return ans;
    }
};",1420108926
Pranab Krushna Sahoo,Zen_10_000,582,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0) {
                ans.push_back(-1);
                continue;
            }

            int num=nums[i];
            int cnt=0;
            while(num%2){
                cnt++;
                num/=2;
            }
            num*=2;
            cnt--;
            cout<<cnt<<' ';
            while(cnt>0){
                num=num*2+1;
                cnt--;
            }
            ans.push_back(num);
        }

        return ans;
    }
};",1420024333
Pranab Krushna Sahoo,Zen_10_000,582,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0) {
                ans.push_back(-1);
                continue;
            }

            int num=nums[i];
            int cnt=0;
            while(num%2){
                cnt++;
                num/=2;
            }
            num*=2;
            cnt--;
            // cout<<cnt<<' ';
            while(cnt>0){
                num=num*2+1;
                cnt--;
            }
            ans.push_back(num);
        }

        return ans;
    }
};",1420028429
Aaditya Kumar,Kumar_2311,583,3604,cpp,"class Solution {
       static const int MOD = 1e9 + 7;
public:
    int numberOfWays(int n, int x, int y) {
   vector<std::vector<int>> c(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        
        std::vector<std::vector<int>> s(n + 1, std::vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }

        long long ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long pow_y = 1;
            for (int i = 0; i < k; ++i) {
                pow_y = (pow_y * y) % MOD;
            }
            ways = (ways + (1LL * c[x][k] * s[n][k] % MOD * fact[k] % MOD * pow_y % MOD)) % MOD;
        }
        return ways;
        
    }
};",1420103847
Aaditya Kumar,Kumar_2311,583,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> result;
        for (int number : nums) {
            bool isFound = 0;
            for (int candidate = 0; candidate < number; ++candidate) {
                if ((candidate | (candidate + 1)) == number) {
                    result.push_back(candidate);
                    isFound = true;
                    break;
                }
            }
            if (!isFound) {
                result.push_back(-1);
            }
        }

        return result;
    }
};",1420081457
Aaditya Kumar,Kumar_2311,583,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        std::vector<int> result(n);
        std::set<int> candidateSet;

        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            candidateSet.clear();

            for (int bit = 0; bit <= 30; ++bit) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate >= 0) {
                        if ((candidate | (candidate + 1)) == num) {
                            candidateSet.insert(candidate);
                        }
                    }
                }
            }

            if (!candidateSet.empty()) {
                result[i] = *candidateSet.begin();
            } else {
                result[i] = -1;
            }
        }

        return result;
        
    }
};",1420109798
KAI,dipayan2002,584,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <limits>
#include <unordered_map>
#include <set>
#include <iterator>
#include <functional>
#include <cmath>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<bool> isTarget = setupTargetIndices(source.length(), targetIndices);
        vector<int> dp = initializeDP(pattern.length());

        return calculateMaxRemovals(source, pattern, isTarget, dp, targetIndices);
    }

private:
    vector<bool> setupTargetIndices(int n, const vector<int>& targetIndices) {
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    vector<int> initializeDP(int m) {
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        return dp;
    }

    int calculateMaxRemovals(const string& source, const string& pattern, const vector<bool>& isTarget, vector<int>& dp, const vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420062967
KAI,dipayan2002,584,3604,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long long result = 0;
        for (int k = 1; k <= x; k++) {
            long long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};
",1420097034
KAI,dipayan2002,584,3605,cpp,"#include <vector>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <limits>
#include <numeric>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <queue>
using namespace std;

class Solution {
public:
    bool isPrime(int num){
        if(num <= 1) return false;
        for(int i=2; i <= sqrt(num); i++){
            if(num % i == 0) return false;
        }
        return true;
    }

    int nextPowerOfTwo(int num){
        if(num <= 0) return 1;
        int power = 1;
        while(power < num){
            power *= 2;
        }
        return power;
    }

    int findMinAns(int prime){
        for(int x=1; x <= prime; x++){
            if((x | (x + 1)) == prime){
                return x;
            }
        }
        return -1;
    }

    vector<int> minBitwiseArray(vector<int>& nums){
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++){
            ans[i] = findMinAns(nums[i]);
        }
        return ans;
    }
};

",1420018303
Aman Raj Gupta,himalayan_coder,585,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> comb = solve(x);
        vector<vector<int>> dummy = solve2(n, x);
        vector<int> ff = fact(x);

        long long temp = ways(comb, dummy, ff, x, y,n);
        return temp;
    }

private:
    vector<vector<int>> solve(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> solve2(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }
        return s;
    }

    vector<int> fact(int x) {
        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        return f;
    }

    long long ways(const vector<vector<int>>& c, const vector<vector<int>>& s, const vector<int>& f, int x, int y,int n) {
        long long temp = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPow = 1;
            for (int i = 0; i < k; ++i) {
                yPow = (yPow * y) % MOD;
            }
            temp = (temp + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * yPow % MOD)) % MOD;
        }
        return temp;
    }
};",1420110414
Aman Raj Gupta,himalayan_coder,585,3605,cpp,"class Solution {
public:
void solve(vector<int>& nums, vector<int>&ans,int n){
     for(int i=0;i<n;i++){
            int num=nums[i];
            int mini=INT_MAX;
            bool found= false;
            for(int bit=0;bit<=20;bit++){
                if(((num>>bit)&1)==1){
                    int temp=num & ~(1<<bit);
                    if(temp < 0)continue;
                    if((temp | (temp+1))==num){
                        if(temp< mini){
                            mini=temp;
                            found=true;
                        }
                    }
                }
            }
            ans[i]=found?mini:-1;
        }
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
       solve(nums,ans,n);
        return ans;
    }
};",1420067090
Aman Raj Gupta,himalayan_coder,585,3611,cpp,"class Solution {
public:
void solve(vector<int>& nums, vector<int>&ans,int n){
     for(int i=0;i<n;i++){
            int num=nums[i];
            int mini=INT_MAX;
            bool found= false;
            for(int bit=0;bit<=20;bit++){
                if(((num>>bit)&1)==1){
                    int temp=num & ~(1<<bit);
                    if(temp < 0)continue;
                    if((temp | (temp+1))==num){
                        if(temp< mini){
                            mini=temp;
                            found=true;
                        }
                    }
                }
            }
            ans[i]=found?mini:-1;
        }
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
       solve(nums,ans,n);
        return ans;
    }
};",1420066898
RadoslawMystek,user7604rV,586,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        c = 10**9 + 7
        t = [[0]*(n+1) for i in range(x)]

        '''for i in range(x):
            t[i][1] = (x-i) * y'''
        '''t[x-1][1] = x * y'''

        for j in range(1,n+1):
            t[x-1][j] = x * y

        for j in range(2,n+1):
            for i in range(x-1):
                t[i][j] += t[i][j-1] * (x-i)
                t[i][j] += t[i+1][j-1] * (i + 1) * y
                t[i][j] %= c

        out = 0

        for i in range(x):
            out += t[i][n]
            out %= c

        return out
",1420110535
RadoslawMystek,user7604rV,586,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                num2 = num
                p = 0
                while num2 % 2 == 1:
                    p += 1
                    num2 //= 2

                p -= 1
                num -= 2**p
                ans.append(num)

        return ans",1420011435
RadoslawMystek,user7604rV,586,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                num2 = num
                p = 0
                while num2 % 2 == 1:
                    p += 1
                    num2 //= 2

                p -= 1
                num -= 2**p
                ans.append(num)

        return ans",1420012849
Aniket More,an1ket_62,588,3604,cpp,"using ll=long long;
const int mod =1e9+7;
class Solution {
public:
    ll inv(ll i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
 
    ll mod_mul(ll a, ll b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}

    ll mod_add(ll a, ll b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}

    ll mod_sub(ll a, ll b) {a = a % mod; b = b % mod; return (((a - b + mod) % mod) + mod) % mod;}
    ll npr(ll n,ll r,vector<ll>&fact){
        ll ans=fact[n];
        ans=mod_mul(ans,inv(fact[n-r]));
        return ans;
        
    }
    ll ncr(ll n,ll r,vector<ll>&fact){
        ll ans=fact[n];
        ans=mod_mul(ans,inv(fact[r]));
        ans=mod_mul(ans,inv(fact[n-r]));
        return ans;
        
    }
    int numberOfWays(int n, int x, int y) {
        vector<ll>fact(x+10);
        fact[0]=1;
        vector<ll>pw(x+10);
        pw[0]=1;
        for (int i=1;i<=x+5;i++){
            fact[i]=fact[i-1]*i;
            fact[i]%=mod;
            pw[i]=pw[i-1]*y;
            pw[i]%=mod;
        }
        vector<vector<long long>> dp(n + 10, vector<long long>(n + 10, 0));
        dp[0][0] = 1;
        for (int i = 1; i <= n+5; ++i) {
            for (int j = 1; j <= n+5; ++j) {
                dp[i][j] = j * dp[i - 1][j] + dp[i - 1][j - 1];
                dp[i][j]%=mod;
            }
        }
        ll ans=0;
        for (int i=1;i<=x;i++){
            ll p = npr(x,i,fact);
            ll c = dp[n][i];
            // cout << c << endl;
            if (i>n){
                break;
            }
            p=mod_mul(p,c);
            p=mod_mul(p,pw[i]);
            ans+=p;
            ans%=mod;
            // cout << ans << endl;
        
            
        }
        return ans;
        
        
    }
};",1420098544
Aniket More,an1ket_62,588,3605,cpp,"using ll = long long;
class Solution {
public:
    ll binToDec(string s) { return bitset<64>(s).to_ullong(); }
    string decToBin(ll a) { return bitset<64>(a).to_string(); }
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans;
        for (int i=0;i<n;i++){
            if (a[i]%2==0){
                ans.push_back(-1);
            }
            else{
                string s=decToBin(a[i]);
                for (int i=63;i>=0;i--){
                    if (s[i]=='0'){
                        s[i+1]='0';
                        break;
                    }
                }
                ll curr=binToDec(s);
                ans.push_back(curr);
                
            }
        }
        return ans;
        
    }
};",1420000885
Aniket More,an1ket_62,588,3611,cpp,"using ll = long long;
class Solution {
public:
    ll binToDec(string s) { return bitset<64>(s).to_ullong(); }
    string decToBin(ll a) { return bitset<64>(a).to_string(); }
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans;
        for (int i=0;i<n;i++){
            if (a[i]%2==0){
                ans.push_back(-1);
            }
            else{
                string s=decToBin(a[i]);
                for (int i=63;i>=0;i--){
                    if (s[i]=='0'){
                        s[i+1]='0';
                        break;
                    }
                }
                ll curr=binToDec(s);
                ans.push_back(curr);
                
            }
        }
        return ans;
        
    }
};",1420000502
manmapi,manmapi,589,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        max_nx = max(n, x) + 1

        factorial = [1] * max_nx
        inv_factorial = [1] * max_nx
        for i in range(1, max_nx):
            factorial[i] = factorial[i - 1] * i % MOD
        inv_factorial[max_nx - 1] = pow(factorial[max_nx - 1], MOD - 2, MOD)
        for i in range(max_nx - 2, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

        max_k = min(n, x)
        S = [0] * (max_k + 2)
        S_prev = [0] * (max_k + 2)
        S_prev[0] = 1

        total_ways = 0
        for i in range(1, n + 1):
            S_curr = [0] * (max_k + 2)
            for k in range(1, min(i, max_k) + 1):
                S_curr[k] = (k * S_prev[k] + S_prev[k - 1]) % MOD
            S_prev = S_curr
        for k in range(1, max_k + 1):
            c = comb(x, k)
            perm = factorial[k]
            s = S_prev[k]
            total = c * perm % MOD * s % MOD * pow(y, k, MOD) % MOD
            total_ways = (total_ways + total) % MOD
        return total_ways

# 3 ** 3 = 27",1420111528
manmapi,manmapi,589,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            if num % 2 == 0:
                result.append(-1)
                continue
            count = 0
            num_ = num
            while num & 1:
                count += 1
                num = num >> 1
            num_ -= 2 ** (count - 1)
            
            result.append(num_)

        return result
        

",1420015780
manmapi,manmapi,589,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            if num % 2 == 0:
                result.append(-1)
                continue
            count = 0
            num_ = num
            while num & 1:
                count += 1
                num = num >> 1
            num_ -= 2 ** (count - 1)
            
            result.append(num_)

        return result",1420016017
Andrew,AndrewJuang,591,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        res = 0
        MOD = 10**9 + 7

        # stirling numbers
        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD
        res = 0
        
        for k in range(1, min(n,x) + 1):
            # assign n to k stages
            ways_to_assign = (S[n][k] * factorial(k)) % MOD

            if k <= x:
                ways_to_assign = (ways_to_assign * comb(x,k)) % MOD
            
            ways_to_assign = ways_to_assign * pow(y,k, MOD)
            res = (res + ways_to_assign) % MOD
        
        return res",1420105905
Andrew,AndrewJuang,591,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []

        for n in nums:
            for x in range(n):
                if x | x +1 == n:
                    res.append(x)
                    break
            else:
                res.append(-1)
            
        return res",1420000254
Andrew,AndrewJuang,591,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for n in nums:
            if n%2 == 0: 
                ans.append(-1)
                continue
            s = str(bin(n))[2:]
            ind = -1
            if '0' in s:
                ind = s.rindex('0')

            res = s[0:ind+1] + '0' + s[ind+2:]
            ans.append(int(res,2))

        return ans",1420032043
IamAho,IamAho,592,3604,cpp,"const int N = 2E3;
const int MOD = 1'000'000'007;
int fast_exp(int a, int k, int p = MOD) {
    long long res = 1;
    while (k) {
        if (k & 1) {
            res = 1LL * res * a % p;
        }
        k >>= 1;
        a = 1LL * a * a % p;
    }
    return res % MOD;
}
int fac[N], infac[N];
int memo[N][N];
bool has_init;
void init() {
    if (has_init) {
        return;
    }
    has_init = true;
    fac[0] = infac[0] = 1;
    for (int i = 1; i < N; i++) {
        fac[i] = 1LL * fac[i - 1] * i % MOD;
    }
    for (int i = 1; i < N; i++) {
        infac[i] = fast_exp(fac[i], MOD - 2, MOD);
    }
    memset(memo, -1, sizeof(memo));
    auto dfs = [&](auto&& self, int n, int m) -> int64_t {
        if (n < m || n <= 0 || m <= 0) {
            return 0;
        }
        if (m == 1 || n == m) {
            return 1;
        }
        if (memo[n][m] != -1) {
            return memo[n][m];
        }
        memo[n][m] = (1LL * self(self, n - 1, m - 1) + 1LL * m * self(self, n - 1, m) % MOD) % MOD;
        return memo[n][m];
    };
    for (int i = 0; i <= 1000; i++) {
        for (int j = 0; j <= 1000; j++) {
            memo[i][j] = dfs(dfs, i, j);
        }
    }
}

int C(int a, int b) {
    if (b == 0) {
        return 1;
    }
    if (a < b) {
        return 0;
    }
    if (a < 0 || b < 0) {
        return 0;
    }
    return 1LL * fac[a] * infac[b] % MOD * infac[a - b] % MOD;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        init();
        vector<int64_t> A(n + 1);
        A[0] = 1;
        for (int i = 1; i <= n; i++) {
            A[i] = A[i - 1] * i % MOD;
        }
        int64_t ans = 0;
        for (int band = 1; band <= min(n, x); band++) {
            // int64_t cur = 1LL * C(n, band) % MOD * C(x, band) % MOD;
            int64_t cur = 1LL * memo[n][band] * C(x, band) % MOD * A[band] % MOD;
            cur = cur * fast_exp(y, band) % MOD;
            ans = (ans + cur) % MOD;
        }
        return ans;
    }
};",1420106482
IamAho,IamAho,592,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420005490
IamAho,IamAho,592,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            if ((x | (x - 1)) == x) {
                ans[i] = x - 1;
            }
            int j = 0;
            while ((x >> j & 1) == 1) {
                j++;
                x -= 1 << j;
            }
            if ((x | (x + 1)) == nums[i]) {
                if (ans[i] == -1) {
                    ans[i] = x;
                } else {
                    ans[i] = min(ans[i], x);
                }
            }
            x = nums[i] >> 1;
            if ((x | (x + 1)) == nums[i]) {
                if (ans[i] == -1) {
                    ans[i] = x;
                } else {
                    ans[i] = min(ans[i], x);
                }
            }
            j = 0;
            x = nums[i];
            while (x >> (j + 1) & 1) {
                x -= 1 << j;
                j++;
            }
            if ((x | (x - 1)) == nums[i]) {
                if (ans[i] == -1) {
                    ans[i] = x - 1;
                } else {
                    ans[i] = min(ans[i], x - 1);
                }
            }            
        }
        return ans;
    }
};",1420042667
runtimeerror-12,runtimeerror-12,593,3604,cpp,"#define MOD 1000000007
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<long long> v = {n, x, y};
        vector<vector<long long>> v1(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            v1[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                v1[i][j] = (v1[i - 1][j - 1] + v1[i - 1][j]) % MOD;
            }
        }
        
        vector<vector<long long>> v2(n + 1, vector<long long>(x + 1, 0));
        v2[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                v2[i][j] = (j * v2[i - 1][j] + v2[i - 1][j - 1]) % MOD;
            }
        }
        
        vector<long long> ans(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            ans[i] = (ans[i - 1] * i) % MOD;
        }
        
        long long finalans = 0;
        for (int l = 1; l <= x; l++) {
            long long w = 1;
            for (int p = 0; p < l; p++) {
                w = (long long)(w * y) % MOD;
            }
            finalans = (finalans + v1[x][l] * v2[n][l] % MOD * ans[l] % MOD * w % MOD) % MOD;
        }

        sort(ans.begin(), ans.end());
        sort(v1.begin(), v1.end());
        sort(v2.begin(), v2.end());
        return finalans;
    }
};",1420073939
runtimeerror-12,runtimeerror-12,593,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         vector<int> finalans(nums.size(), -1), temp(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int val = nums[i];
            int mn = INT_MAX;
            bool flag = false;
            
            for (int i = 0; i <= 30; i++) {
                if ((val >> i) & 1) {
                    int var = val & ~(1 << i);
                    if (var < 0) continue;
                    
                    if ((var | (var + 1)) == val) {
                        if (var < mn) {
                            mn = var;
                            flag = true;
                        }
                    }
                }
            }
            
            if (flag) {
                finalans[i] = mn;
                temp[i] = mn;
            } else {
                finalans[i] = -1;
                temp[i] = -1;
            }
        }
        sort(temp.begin(), temp.end());
        sort(nums.begin(), nums.end());
        return finalans;
    }
};",1420099995
runtimeerror-12,runtimeerror-12,593,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> finalans(nums.size(), -1), temp(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int val = nums[i];
            int mn = INT_MAX;
            bool flag = false;
            
            for (int i = 0; i <= 30; i++) {
                if ((val >> i) & 1) {
                    int var = val & ~(1 << i);
                    if (var < 0) continue;
                    
                    if ((var | (var + 1)) == val) {
                        if (var < mn) {
                            mn = var;
                            flag = true;
                        }
                    }
                }
            }
            
            if (flag) {
                finalans[i] = mn;
                temp[i] = mn;
            } else {
                finalans[i] = -1;
                temp[i] = -1;
            }
        }
        sort(temp.begin(), temp.end());
        sort(nums.begin(), nums.end());
        return finalans;
    }
};
",1420056974
Phoenix1337,Phoenix1337,594,3604,cpp,"class Solution {
    long long mod_exp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1)
                result = (result * base) % mod;
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

public:
    int numberOfWays(int n, int x, int y) {
        int kmax = min(n, x);
        long long m = 1e9 + 7, ans = 0, ypk = y, fratio;
        vector<vector<long long>> S(n+1, vector<long long>(kmax+1, 0));
        vector<long long> f(x+1, 1);

        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= min(i, kmax); ++j) {
                S[i][j] = (j * S[i-1][j] + S[i-1][j-1]) % m;
            }
        }
        
        for (int i = 2; i <= x; ++i) 
            f[i] = (f[i-1] * i) % m;

        for (int k = 1; k <= kmax; ++k) {
            fratio = (f[x] * mod_exp(f[x-k], m-2, m)) % m;
            long long step = (((fratio * S[n][k]) % m) * ypk) % m;
            ans = (ans + step) % m;
            ypk = (ypk * y) % m;
        }

        return ans;
    }
};",1420112933
Phoenix1337,Phoenix1337,594,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> v; int ans;
        for(auto x:nums) {
            if(x & 1) {
                for(int i=1;i<32;i++) {
                    if(!((1<<i) & x)) {
                        ans = x - (1<<(i-1));
                        break;
                    }
                }
            }
            else ans = -1;
            v.push_back(ans);
        }
        return v;
    }
};",1420014824
Phoenix1337,Phoenix1337,594,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> v; int ans;
        for(auto x:nums) {
            if(x & 1) {
                for(int i=1;i<32;i++) {
                    if(!((1<<i) & x)) {
                        ans = x - (1<<(i-1));
                        break;
                    }
                }
            }
            else ans = -1;
            v.push_back(ans);
        }
        return v;
    }
};",1420017091
shivam singh,shivam2609,596,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420100247
shivam singh,shivam2609,596,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n =  nums.size();
        // int ans[n] = {-1};
        vector<int>ans(n,-1);
        for(int i = 0; i<n ; i++){
            for(int j  = 0 ; j<= nums[i] ; j++){
                if((j|(j+1))==nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans ;
    }
};",1420018165
shivam singh,shivam2609,596,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    std::vector<int> minBitwiseArray(const std::vector<int>& nums) {
        int n = nums.size();
         vector<int> ans(n);
         unordered_map<int,int>mpp ;
         unordered_set<int>set(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX; // Similar to Integer.MAX_VALUE in Java
            bool found = false;

            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};
",1420047432
CODEBISWA,CODEBISWA,597,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> combinations(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stirlingNumbers(n + 1, vector<int>(x + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> factorials(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD;
        }

        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPower = 1;
            for (int p = 0; p < k; ++p) {
                yPower = (yPower * y) % MOD;
            }
            totalWays = (totalWays + (1LL * combinations[x][k] * stirlingNumbers[n][k] % MOD * factorials[k] % MOD * yPower % MOD)) % MOD;
        }

        return totalWays;
    }
};
",1420113307
CODEBISWA,CODEBISWA,597,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for (int i = 0; i < n; ++i) {
            for (int y = 0; y <= nums[i]; ++y) {
                if ((y | (y + 1)) == nums[i]) {
                    ans[i] = y;
                    break;
                }
            }
        }
        
        return ans;  
    }
};",1420094154
CODEBISWA,CODEBISWA,597,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
             int length = nums.size();
        vector<int> result(length);

        for (int i = 0; i < length; i++) {
            int prime = nums[i];
            int minCandidate = INT_MAX;
            bool isValid = false;

            for (int bitPos = 0; bitPos <= 30; bitPos++) {
                if (((prime >> bitPos) & 1) == 1) {
                    int potentialValue = prime & ~(1 << bitPos);

                    if (potentialValue < 0) continue;

                    if ((potentialValue | (potentialValue + 1)) == prime) {
                        if (potentialValue < minCandidate) {
                            minCandidate = potentialValue;
                            isValid = true;
                        }
                    }
                }
            }

            if (isValid) {
                result[i] = minCandidate;
            } else {
                result[i] = -1;
            }
        }

        return result; 
    }
};",1420108614
Anubhav Jain,jain-anubhav,598,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420113759
Anubhav Jain,jain-anubhav,598,3605,c,"/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minBitwiseArray(int* nums, int size, int* rSize) {
    int* ans = (int*)malloc(sizeof(int) * size);

    for (int i = 0; i < size; i++) {
        if (nums[i] == 2) ans[i] = -1;
        else {
            for (int j = 1; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j; break;
                }
            }
        }
    }

    *rSize = size; return ans;
}",1420068876
Anubhav Jain,jain-anubhav,598,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True

            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans
        ",1420104896
Prasham Shah,Prasham_Shah,599,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        fact = [0]*1005
        fact[0] = 1
        m = 10**9+7
        for i in range(1,1005):
            fact[i] = (i*fact[i-1])%m

        def comb(n,r,m):
            return (fact[n]*pow((fact[n-r]*fact[r])%m,m-2,m))%m
        
        ans = 0
        for i in range(1,x+1): # i is number of stages
            if i <= n:
                t = 0 # union of at least 1 not there
                for j in range(1,i):
                    if j%2: t += ( comb(i,i-j,m)*pow(i-j,n,m) )%m
                    else: t -= ( comb(i,i-j,m)*pow(i-j,n,m) )%m 
                t %= m
                ans = (ans + ( (pow(i,n,m)-t)%m )*comb(x,i,m)*pow(y,i,m) )%m
            
        return ans


",1420114426
Prasham Shah,Prasham_Shah,599,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i] == 2: ans.append(-1)
            else:
                b = list(reversed(bin(nums[i])[2:]))
                c = 0
                while c < len(b) and b[c] == '1': c+= 1
                ans.append(nums[i]-2**(c-1))
        return ans",1420010426
Prasham Shah,Prasham_Shah,599,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i] == 2: ans.append(-1)
            else:
                b = list(reversed(bin(nums[i])[2:]))
                c = 0
                while c < len(b) and b[c] == '1': c+= 1
                ans.append(nums[i]-2**(c-1))
        return ans",1420011356
Ps_Chaitanya1,Ps_Chaitanya1,601,3604,php,"class Solution {
    const psofflineMOD = 1000000007;

    public function numberOfWays($psofflineN, $psofflineX, $psofflineY) {
        // Initialize combination array
        $psofflineComb = array_fill(0, $psofflineX + 1, array_fill(0, $psofflineX + 1, 0));
        for ($psofflineI = 0; $psofflineI <= $psofflineX; ++$psofflineI) {
            $psofflineComb[$psofflineI][0] = 1;
            for ($psofflineJ = 1; $psofflineJ <= $psofflineI; ++$psofflineJ) {
                $psofflineComb[$psofflineI][$psofflineJ] = ($psofflineComb[$psofflineI - 1][$psofflineJ - 1] + $psofflineComb[$psofflineI - 1][$psofflineJ]) % self::psofflineMOD;
            }
        }

        // Initialize Stirling numbers of the second kind array
        $psofflineStirling = array_fill(0, $psofflineN + 1, array_fill(0, $psofflineX + 1, 0));
        $psofflineStirling[0][0] = 1;
        for ($psofflineI = 1; $psofflineI <= $psofflineN; ++$psofflineI) {
            for ($psofflineJ = 1; $psofflineJ <= $psofflineX; ++$psofflineJ) {
                $psofflineStirling[$psofflineI][$psofflineJ] = (1 * $psofflineJ * $psofflineStirling[$psofflineI - 1][$psofflineJ] + $psofflineStirling[$psofflineI - 1][$psofflineJ - 1]) % self::psofflineMOD;
            }
        }

        // Initialize factorial array
        $psofflineFactorial = array_fill(0, $psofflineX + 1, 1);
        for ($psofflineI = 1; $psofflineI <= $psofflineX; ++$psofflineI) {
            $psofflineFactorial[$psofflineI] = (1 * $psofflineFactorial[$psofflineI - 1] * $psofflineI) % self::psofflineMOD;
        }

        // Calculate total number of ways
        $psofflineTotalWays = 0;
        for ($psofflineK = 1; $psofflineK <= $psofflineX; ++$psofflineK) {
            $psofflineYpow = 1;
            for ($psofflineI = 0; $psofflineI < $psofflineK; ++$psofflineI) {
                $psofflineYpow = ($psofflineYpow * $psofflineY) % self::psofflineMOD;
            }
            $psofflineTotalWays = ($psofflineTotalWays + (1 * $psofflineComb[$psofflineX][$psofflineK] * $psofflineStirling[$psofflineN][$psofflineK] % self::psofflineMOD * $psofflineFactorial[$psofflineK] % self::psofflineMOD * $psofflineYpow % self::psofflineMOD)) % self::psofflineMOD;
        }

        return $psofflineTotalWays;
    }
}

// Example usage:
$solution = new Solution();
$result = $solution->numberOfWays(5, 3, 2);
echo $result;
",1420108521
Ps_Chaitanya1,Ps_Chaitanya1,601,3605,php,"class Solution {
    public function minBitwiseArray($psofflineNums) {
        // Initialize the result array with -1
        $psofflineResult = array_fill(0, count($psofflineNums), -1);

        // Iterate over the indices of the input array
        for ($psofflineI = 0; $psofflineI < count($psofflineNums); $psofflineI++) {
            // Iterate over possible values of result[i]
            for ($psofflineJ = 0; $psofflineJ < $psofflineNums[$psofflineI]; $psofflineJ++) {
                // Check if the condition is satisfied
                if (($psofflineJ | ($psofflineJ + 1)) == $psofflineNums[$psofflineI]) {
                    // Update the result array with the minimum possible value
                    $psofflineResult[$psofflineI] = $psofflineJ;
                    break;
                }
            }
        }

        // Return the result array
        return $psofflineResult;
    }
}

// Example usage:
$solution = new Solution();
$psofflineNums = [1, 2, 3, 4, 5];
$result = $solution->minBitwiseArray($psofflineNums);
print_r($result);
",1420101487
Ps_Chaitanya1,Ps_Chaitanya1,601,3611,php,"class Solution {
    public function minBitwiseArray($psofflineNums) {
        $psofflineN = count($psofflineNums);
        $psofflineAns = array_fill(0, $psofflineN, 0);
        
        for ($psofflineI = 0; $psofflineI < $psofflineN; $psofflineI++) {
            $psofflineNum = $psofflineNums[$psofflineI];
            $psofflineMinimalAns = PHP_INT_MAX;
            $psofflineFound = false;
            
            // Iterate through each bit position (0 to 30)
            for ($psofflineBit = 0; $psofflineBit <= 30; $psofflineBit++) {
                if ((($psofflineNum >> $psofflineBit) & 1) == 1) {
                    // Unset the current bit
                    $psofflineCandidate = $psofflineNum & ~(1 << $psofflineBit);
                    
                    // Ensure candidate is non-negative
                    if ($psofflineCandidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if (($psofflineCandidate | ($psofflineCandidate + 1)) == $psofflineNum) {
                        if ($psofflineCandidate < $psofflineMinimalAns) {
                            $psofflineMinimalAns = $psofflineCandidate;
                            $psofflineFound = true;
                        }
                    }
                }
            }
            
            if ($psofflineFound) {
                $psofflineAns[$psofflineI] = $psofflineMinimalAns;
            } else {
                $psofflineAns[$psofflineI] = -1;
            }
        }
        
        return $psofflineAns;
        }
}

// Example usage:
$solution = new Solution();
$psofflineNums = [1, 2, 3, 4, 5];
$result = $solution->minBitwiseArray($psofflineNums);
print_r($result);
",1420099667
Shivam Gupta,dhirack,602,3604,cpp,"class Solution {
public:
    const int MOD = 1000000007;
    vector<long long> factorial;
    vector<long long> inv_factorial;

    // Function to compute (base^exponent) % MOD
    long long powmod(long long base, long long exponent) {
        long long result = 1;
        base %= MOD;
        while (exponent) {
            if (exponent & 1) {
                result = result * base % MOD;
            }
            base = base * base % MOD;
            exponent >>= 1;
        }
        return result;
    }

    // Precompute factorials and inverse factorials
    void precompute_factorials(int N) {
        factorial.resize(N + 1);
        inv_factorial.resize(N + 1);
        factorial[0] = inv_factorial[0] = 1;
        for (int i = 1; i <= N; ++i) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        // Compute inverse factorials using Fermat's Little Theorem
        inv_factorial[N] = powmod(factorial[N], MOD - 2);
        for (int i = N - 1; i >= 1; --i) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
        }
    }

    // Compute n choose k modulo MOD
    long long comb(int n, int k) {
        if (k < 0 || k > n)
            return 0;
        return factorial[n] * inv_factorial[k] % MOD * inv_factorial[n - k] % MOD;
    }

    int numberOfWays(int n, int x, int y) {
        int N = max(n, x);
        precompute_factorials(N);

        // Initialize the Stirling numbers array
        vector<long long> S(n + 1, 0);
        S[0] = 1;

        // Compute Stirling numbers of the second kind
        for (int i = 1; i <= n; ++i) {
            vector<long long> newS(n + 1, 0);
            for (int k = 1; k <= i; ++k) {
                newS[k] = (S[k - 1] + k * S[k] % MOD) % MOD;
            }
            S = newS;
        }

        long long totalWays = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            long long ways = comb(x, k) * S[k] % MOD;
            ways = ways * factorial[k] % MOD;
            ways = ways * powmod(y, k) % MOD;
            totalWays = (totalWays + ways) % MOD;
        }

        return totalWays;
    }
};
",1420108700
Shivam Gupta,dhirack,602,3605,cpp,"class Solution {
public:
    bool pow2(int x){
        double tmp = log2(x);
        if(tmp-(int)tmp==0) return true;
        else return false;
    }

    int check(int n){
        string s = """";
        int cnt = 0;
        while(n && n%2==1){
            cnt++;
            n=n/2;
        }
        return cnt;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans[i]=-1;
            else{
                int cnt = check(nums[i]);
                ans[i] = nums[i]-pow(2,cnt-1);
            }
        }
        return ans;
    }
};",1420038622
Shivam Gupta,dhirack,602,3611,cpp,"class Solution {
public:
    int check(int n){
        string s = """";
        int cnt = 0;
        while(n && n%2==1){
            cnt++;
            n=n/2;
        }
        return cnt;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans[i]=-1;
            else{
                int cnt = check(nums[i]);
                ans[i] = nums[i]-pow(2,cnt-1);
            }
        }
        return ans;
    }
};",1420039727
Leima Singha,LeiLeet,605,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }

        long long res = 0;
        for (int k = 1; k <= x; ++k) {
            long long yp = 1;
            for (int i = 0; i < k; ++i) {
                yp = (yp * y) % MOD;
            }
            res = (res + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * yp % MOD)) % MOD;
        }

        return res;
    }
};",1420116814
Leima Singha,LeiLeet,605,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n, -1);
        for (int i = 0; i < n; i++) {    
            for(int j = 0; j <= nums[i]; j++){
                if((j|(j+1))==nums[i]){
                    ans[i] = j;
                    break;
                }
            }    
        }
        return ans;
    }
};",1420040333
Leima Singha,LeiLeet,605,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res(nums.size(), 0);

    for (int i = 0; i < nums.size(); i++) {
        int n = nums[i];
        int mn = INT_MAX;
        bool flag = false;

        for (int j = 0; j < 31; j++) {
            if ((n >> j) & 1) {
                int x = n & ~(1 << j);
                if (x < 0) continue;
                if ((x | (x + 1)) == n) {
                    if (x < mn) {
                        mn = x;
                    }
                    flag = true;
                }
            }
        }

        if (flag) {
            res[i] = mn;
        } else {
            res[i] = -1;
        }
    }

    return res;
    }
};",1420092448
pffffttttt,knym_jar,606,3604,java,"class Solution {
    int numberOfWays(int n, int x, int y) {
        int MOD = 1000000007;
        int[] fact = new int[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; ++i) {
            fact[i] = (int)((1L * fact[i - 1] * i) % MOD);
        }

        long ans = 0;
        
        int[][] bino = new int[x + 1][x + 1];
        for (int i = 0; i <= x; ++i) {
            bino[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                bino[i][j] = (bino[i - 1][j - 1] + bino[i - 1][j]) % MOD;
            }
        }

        int[][] sti = new int[n + 1][x + 1];
        sti[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                sti[i][j] = (int)((1L * j * sti[i - 1][j] + sti[i - 1][j - 1]) % MOD);
            }
        }

        for (int k = 1; k <= x; ++k) {
            long yP = 1;
            for (int i = 0; i < k; ++i) {
                yP = (yP * y) % MOD;
            }
            
            ans = (ans + (1L * bino[x][k] * sti[n][k] % MOD * fact[k] % MOD * yP % MOD)) % MOD;
        }

        return (int) ans;
    }
}
",1420116981
pffffttttt,knym_jar,606,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i = 0 ; i < n ; i++) {
            int x = 0;
            for(int j = 0 ; j < 1001 ; j++) {
                int y = j | ( j + 1);
                if(y == nums.get(i)) {
                    ans[i] = j;
                    x = 1;
                    break;
                }
            }
            if(x == 0) {
                ans[i] = -1;
            }
        }
        return ans;
    }
}",1420004227
pffffttttt,knym_jar,606,3611,java,"class Solution {
    
    private int[] binary(int x) {
        List<Integer> temp = new ArrayList<Integer>();
        while(x != 0) {
            temp.add(x % 2);
            x = x / 2;
        }
        int[] ans = new int[temp.size()];
        // ans = temp.toArray(ans);
        for(int i = 0; i < temp.size() ; i++) {
            ans[i] = temp.get(i);
        }
        return ans;
    }
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i = 0 ; i < n ; i++) {
            if(nums.get(i) == 2) {
                ans[i] = -1;
            } else {
                int[] bin = binary(nums.get(i));
                int x = 0;
                for(int j = 0 ; j < bin.length ; j++) {
                    if(bin[j] == 0) {
                        x += Math.pow(2 , j - 1);
                        break;
                    }
                }
                if(x == 0) x += Math.pow(2 , bin.length - 1);
                ans[i] = nums.get(i) - x;
            }
        }
        return ans;
    }
    
}",1420054204
Nikhil Reddy,nikhil_reddy_d,607,3604,java,"import java.util.Arrays;

class Solution {
    static final int MOD = 1000000007;

    public int numberOfWays(int numItems, int maxGroups, int multiplier) {
        long[][] combinations = new long[maxGroups + 1][maxGroups + 1];
        for (int i = 0; i <= maxGroups; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        long[][] stirlingNumbers = new long[numItems + 1][maxGroups + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= numItems; i++) {
            for (int j = 1; j <= maxGroups; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorials = new long[maxGroups + 1];
        factorials[0] = 1;
        for (int i = 1; i <= maxGroups; i++) {
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int groupCount = 1; groupCount <= maxGroups; groupCount++) {
            long multiplierPow = 1;
            for (int i = 0; i < groupCount; i++) {
                multiplierPow = (multiplierPow * multiplier) % MOD;
            }
            totalWays = (totalWays + (combinations[maxGroups][groupCount] * stirlingNumbers[numItems][groupCount] % MOD * factorials[groupCount] % MOD * multiplierPow % MOD)) % MOD;
        }

        return (int) totalWays;
    }
}
",1420110668
Nikhil Reddy,nikhil_reddy_d,607,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # Initialize the result array with -1
        result = [-1] * len(nums)

        # Iterate over the indices of the input array
        for i in range(len(nums)):
            # Iterate over possible values of ans[i]
            for j in range(nums[i]):
                # Check if the condition is satisfied
                if j | (j + 1) == nums[i]:
                    # Update the result array with the minimum possible value
                    result[i] = j
                    break

        # Return the result array
        return result",1420019430
Nikhil Reddy,nikhil_reddy_d,607,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420082495
deepthings07,deepthings07,608,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
           int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420117538
deepthings07,deepthings07,608,3604,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {

    vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        } 
     vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        long long ans = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            ans = (ans + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * y_pow % MOD)) % MOD;
        }


        return ans;


    }
};",1420106794
deepthings07,deepthings07,608,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            bool found = false;

            for (int x = 0; x < num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;

        
    }
};",1420112977
Syam,Sai_7096,609,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }

        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * fact[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};
",1420105199
Syam,Sai_7096,609,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = [-1] * len(nums)
        for i in range(len(nums)):
            for j in range(nums[i]):
                if j | (j + 1) == nums[i]:
                    res[i] = j
                    break
        return res
",1420007140
Syam,Sai_7096,609,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minVal = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int b = 0; b <= 30; b++) {
                if (((num >> b) & 1) == 1) {
                    int cand = num & ~(1 << b);
                    if (cand < 0) continue;
                    if ((cand | (cand + 1)) == num) {
                        if (cand < minVal) {
                            minVal = cand;
                            found = true;
                        }
                    }
                }
            }
            
            res[i] = found ? minVal : -1;
        }
        
        return res;
    }
}
",1420041225
VISHAL V D,Vishal_V_D,610,3487,swift,"class Solution {
    func maxRemovals(_ source: String, _ pattern: String, _ targetIndices: [Int]) -> Int {
        let n = source.count
        let m = pattern.count
        let sourceArray = Array(source)
        let patternArray = Array(pattern)
        
        // Step 1: Create an array to track the minimum removals needed for each subsequence length
        var dpTable = Array(repeating: Int.max, count: m + 1)
        dpTable[0] = 0 // Base case: No characters matched, no removals needed
        
        // Step 2: Mark the indices where characters are removed from source
        var targetMarks = Array(repeating: false, count: n)
        for idx in targetIndices {
            targetMarks[idx] = true
        }

        // Step 3: Fill the dp table by comparing characters of source and pattern
        for i in 0..<n {
            for j in stride(from: m, through: 1, by: -1) {
                if sourceArray[i] == patternArray[j - 1], dpTable[j - 1] != Int.max {
                    let removalCount = dpTable[j - 1] + (targetMarks[i] ? 1 : 0)
                    dpTable[j] = min(dpTable[j], removalCount)
                }
            }
        }

        // Step 4: Determine the maximum number of operations that can be performed
        return dpTable[m] == Int.max ? targetIndices.count : targetIndices.count - dpTable[m]
    }
}
",1420105799
VISHAL V D,Vishal_V_D,610,3604,csharp,"using System;

public class Solution
{
    private const int MODULUS = 1000000007;

    public int NumberOfWays(int n, int x, int y)
    {
        // Create a table for combinations (C)
        long[,] combTable = new long[x + 1, x + 1];
        for (int i = 0; i <= x; i++)
        {
            combTable[i, 0] = 1; // Base case: C(i, 0) = 1
            for (int j = 1; j <= i; j++)
            {
                combTable[i, j] = (combTable[i - 1, j - 1] + combTable[i - 1, j]) % MODULUS;
            }
        }

        // Create a table for Stirling numbers of the second kind (S)
        long[,] stirlingNumbers = new long[n + 1, x + 1];
        stirlingNumbers[0, 0] = 1; // Base case: S(0, 0) = 1
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= x; j++)
            {
                stirlingNumbers[i, j] = (j * stirlingNumbers[i - 1, j] + stirlingNumbers[i - 1, j - 1]) % MODULUS;
            }
        }

        // Create an array for factorial values
        long[] factorials = new long[x + 1];
        factorials[0] = 1; // Base case: 0! = 1
        for (int i = 1; i <= x; i++)
        {
            factorials[i] = (factorials[i - 1] * i) % MODULUS;
        }

        long totalDistinctWays = 0; // Variable to accumulate total ways
        // Calculate total number of distinct ways
        for (int k = 1; k <= x; k++)
        {
            long powerOfY = 1;
            for (int p = 0; p < k; p++)
            {
                powerOfY = (powerOfY * y) % MODULUS; // Calculate y^k
            }

            totalDistinctWays = (totalDistinctWays + combTable[x, k] * stirlingNumbers[n, k] % MODULUS * factorials[k] % MODULUS * powerOfY % MODULUS) % MODULUS;
        }

        return (int)totalDistinctWays; // Return the final result
    }
}
",1420118090
VISHAL V D,Vishal_V_D,610,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = False
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans
",1420091104
Arunaditya Dasgupta,git-ADG,611,3604,cpp,"typedef long long ll;
const ll MOD = 1e9 + 7;
class Solution {
    vector<vector<int>> getComb(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            c[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> getStir(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                s[i][j] = (1ll * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }
        return s;
    }

    vector<int> getFact(int x) {
        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        return f;
    }

    ll modPow(int b, int e) {
        ll res = 1;
        while (e > 0) {
            if (e % 2 == 1) {
                res = (res * b) % MOD;
            }
            b = (1LL * b * b) % MOD;
            e /= 2;
        }
        return res;
    }
    
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> c = getComb(x);
        vector<vector<int>> s = getStir(n, x);
        vector<int> f = getFact(x);

        ll ans = 0;
        
        for (int k = 1; k <= x; k++) {
            ll yPow = modPow(y, k);
            ans = (ans + (1ll * c[x][k] * s[n][k] % MOD * f[k] % MOD * yPow % MOD)) % MOD;
        }
        
        return ans;
    }
};
",1420111982
Arunaditya Dasgupta,git-ADG,611,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            ans[i] = -1;
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= nums[i]; j++){
                if((j | (j + 1)) == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420005177
Arunaditya Dasgupta,git-ADG,611,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int n : nums){
            bool flag = false;
            int a = INT_MAX;
            for(int i = 0; i < 32; i++){
                
                if(((n >> i) & 1) == 1){
                    int possible = n & ~(1 << i);
                    if(possible >= 0){
                        if((possible | (possible + 1)) == n){
                            a = min(possible, a);
                            flag = true;
                        }
                    }else continue;
                    
                }
                
            }
            if(flag) ans.push_back(a);
            else ans.push_back(-1);
        }
        return ans;
    }
};",1420093476
Shubham,Shubhaaaaam,612,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
",1420111987
Shubham,Shubhaaaaam,612,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420104429
Shubham,Shubhaaaaam,612,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        l=len(nums)
        ans=[]
        for i in range(0,l):
            ans.append(-1)
            for j in range(0,nums[i]):
                if (j|(j+1))==int(nums[i]):
                    ans[i]=j
                    break
                else:
                    j+1
        return ans",1420035331
Aastha Punjabi,aasthapunjabi0208i2003,614,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:

        MOD = 10**9 + 7

        # Step 1: Compute factorial and inverse factorial up to max(n, x)
        max_val = max(n, x)
        fact = [1] * (max_val + 1)
        for i in range(1, max_val + 1):
            fact[i] = fact[i - 1] * i % MOD

        inv_fact = [1] * (max_val + 1)
        inv_fact[max_val] = pow(fact[max_val], MOD - 2, MOD)
        for i in range(max_val - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        # Step 2: Compute Stirling numbers of the second kind S(n, k) for k=1 to x
        # Using dynamic programming with space optimization
        prev = [0] * (x + 1)
        prev[0] = 1  # S(0,0) = 1
        for i in range(1, n + 1):
            curr = [0] * (x + 1)
            for j in range(1, min(i, x) + 1):
                # S(i, j) = S(i-1, j-1) + j * S(i-1, j)
                curr[j] = (prev[j - 1] + j * prev[j]) % MOD
            prev = curr
        S = prev  # S[k] now contains S(n, k) for k=0 to x

        # Step 3: Calculate the total number of ways
        total = 0
        for k in range(1, x + 1):
            if k > n:
                continue  # S(n, k) = 0 for k > n
            # Compute C(x, k) = fact[x] / (fact[k] * fact[x - k]) mod MOD
            C = fact[x] * inv_fact[k] % MOD
            C = C * inv_fact[x - k] % MOD

            # Compute S(n, k) * k! mod MOD
            Sk = S[k] * fact[k] % MOD

            # Compute y^k mod MOD
            yk = pow(y, k, MOD)

            # Combine all components
            term = C * Sk % MOD
            term = term * yk % MOD

            # Add to the total
            total = (total + term) % MOD

        return total
            

        ",1420100552
Aastha Punjabi,aasthapunjabi0208i2003,614,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  
        
        for i in range(n):
            num = nums[i]
            
            for x in range(num): 
                if x | (x + 1) == num:
                    ans[i] = x
                    break 
        return ans
        ",1420007370
Aastha Punjabi,aasthapunjabi0208i2003,614,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            min_x = -1  # Initialize with -1
            k = 0
            temp_n = n
            while temp_n > 0:
                if temp_n & 1:
                    x = n - (1 << k)
                    if x >= 0 and (x | (x + 1)) == n:
                        if min_x == -1 or x < min_x:
                            min_x = x
                temp_n >>= 1
                k += 1
            ans.append(min_x)
        return ans
        ",1420034525
bluedot0330,bluedot0330,615,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int totalElements, int distinctGroups, int multiplier) {
        
        // Precompute combinations using Pascal's Triangle
        std::vector<std::vector<int>> combinations(distinctGroups + 1, std::vector<int>(distinctGroups + 1, 0));
        for (int i = 0; i <= distinctGroups; ++i) {
            combinations[i][0] = 1;  // C(i, 0) = 1
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        } 
        
        // Initialize Stirling numbers of the second kind
        std::vector<std::vector<int>> stirlingNumbers(totalElements + 1, std::vector<int>(distinctGroups + 1, 0));
        stirlingNumbers[0][0] = 1;  // S(0, 0) = 1
        for (int i = 1; i <= totalElements; ++i) {
            for (int j = 1; j <= distinctGroups; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }
        
        // Precompute factorials
        std::vector<int> factorials(distinctGroups + 1, 1);
        for (int i = 1; i <= distinctGroups; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD;
        }
        
        // Calculate total ways
        long long totalWays = 0;
        for (int k = 1; k <= distinctGroups; ++k) {
            long long multiplierPower = 1; // y^k
            for (int i = 0; i < k; ++i) {
                multiplierPower = (multiplierPower * multiplier) % MOD;
            }
            totalWays = (totalWays + (1LL * combinations[distinctGroups][k] * stirlingNumbers[totalElements][k] % MOD * factorials[k] % MOD * multiplierPower % MOD)) % MOD;
        }
        return totalWays;
    }
};
",1420107345
bluedot0330,bluedot0330,615,3605,cpp,"#include <bits/stdc++.h>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        vector<int> res;
        for (int n : nums) {
            bool ok = false;
            for (int x = 0; x < n; ++x) {
                if ((x | (x + 1)) == n) {
                    res.push_back(x);
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                res.push_back(-1);
            }
        }
        return res;
    }
};

int Main() {
    vector<int> nums = {3, 7, 5, 11};
    
    // Call the function via the Solution class
    vector<int> result = Solution().minBitwiseArray(nums);

    // Output the results
    for (int x : result) {
        cout << x << "" "";
    }
    cout << endl;

    return 0;
}
",1420006985
bluedot0330,bluedot0330,615,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size);
        
        for (int i = 0; i < size; i++) {
            int currentNum = nums[i];
            int smallestCandidate = INT_MAX;
            bool candidateFound = false;
          
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (currentNum & (1 << bitPosition)) {
                    // Create a candidate by turning off the current bit
                    int modifiedNum = currentNum & ~(1 << bitPosition);
                    
                    // Ensure the modified number is non-negative
                    if (modifiedNum < 0) continue;
                    
                    // Check if we can achieve the original number by using | operator
                    if ((modifiedNum | (modifiedNum + 1)) == currentNum) {
                        // Update the smallest candidate if found
                        if (modifiedNum < smallestCandidate) {
                            smallestCandidate = modifiedNum;
                            candidateFound = true;
                        }
                    }
                }
            }
            
            // Assign the result based on whether a candidate was found
            result[i] = candidateFound ? smallestCandidate : -1;
        }
        
        return result;
    }
};
",1420102832
Himanshu Gaurav,HimanshuGaurav,616,3604,cpp,"class Solution{
public:
    const int m = 1e9+7;
    int numberOfWays(int n,int x,int y){
        vector<vector<int>> arr(x+1,vector<int>(x+1,0));
        for (int i=0 ; i<=x ; i++){
            arr[i][0] = 1;
            for (int j=1 ; j<=i ; j++){
                arr[i][j] = (arr[i-1][j-1]+arr[i-1][j])%m;
            }
        } 
        vector<vector<int>> dp(n+1,vector<int>(x+1,0));
        dp[0][0] = 1;
        for (int i=1 ; i<=n; i++){
            for (int j=1 ; j<=x; j++){
                dp[i][j] = (1LL*j*dp[i-1][j]+dp[i-1][j-1])%m;
            }
        }
        vector<int> f(x+1,1);
        for (int i=1 ; i<=x ; i++){
            f[i] = (1LL*f[i-1]*i)%m;
        }
        long long ans = 0;
        for (int i=1 ; i<=x ; i++){
            long long t = 1;
            for (int j=0 ; j<i ; j++){
                t = (t*y)%m;
            }
            ans = (ans+(1LL*arr[x][i]*dp[n][i]%m*f[i]%m*t%m))%m;
        }
        return ans;
    }
};",1420113848
Himanshu Gaurav,HimanshuGaurav,616,3605,cpp,"class Solution{
public:
    vector<int> minBitwiseArray(vector<int> &nums){
        int n = nums.size();
        vector<int> out(n);
        for (int i=0 ; i<n ; i++){
            bool t = true;
            for (int j=0 ; j<nums[i] ; j++){
                if ((j|(j+1))==nums[i]){
                    out[i] = j;
                    t = false;
                    break;
                }
            }
            if (t) out[i] = -1;
        }
        return out;
    }
};",1420011267
Himanshu Gaurav,HimanshuGaurav,616,3611,cpp,"class Solution{
public:
    vector<int> minBitwiseArray(vector<int>& nums){
        int n = nums.size();
        vector<int> out(n);
        for (int i=0 ; i<n ; i++){
            int x = nums[i];
            int mini = INT_MAX;
            bool t = false;
            for (int k=0 ; k<31 ; k++){
                if ((x>>k)&1){
                    int j = x&~(1<<k);
                    if (j>=0 && (j|(j+1))==x && j<mini){
                        mini = j;
                        t = true;
                    }
                }
            }
            if (t) out[i] = mini;
            else out[i] = -1;
        }
        return out;
    }
};",1420067142
turtleman271,turtleman271,617,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        #start with one person on any x stages
        stages = [0]*x
        stages[0] = x
        for i in range(n-1):
            nextStages = [i for i in stages]
            #print(nextStages)
            for j in range(1,len(stages)):
                if j<len(stages):
                    nextStages[j]*=(j+1)
                emptySpots = len(stages)-j
                prev = stages[j-1]
                nextStages[j] += emptySpots*prev
            stages = nextStages
        #print(stages)
        res = 0
        for i in range(len(stages)):
            #print(stages[i], y, (i+1))
            res+=stages[i]*(y**(i+1))
            res%=(10**9+7)
        return res

""""""
        [3,0,0]
        [3,6,0]
        [3,18,6]
        3*4^1+18*4^2+6*4^3 = 684

        c,,
        ,c,
        ,,c
        [3,0,0]

        bc,,
        c,b,
        c,,b
        b,c,
        ,bc,
        ,c,b
        b,,c
        ,b,c
        ,,bc
        [3,6,0]

        
        abc,,
       bc,a,
       bc,,a
       ac,b,
       c,ab,
        c,b,a
       ac,,b
        c,a,b
       c,,ab
       ab,c,
       b,ac,
        b,c,a
       a,bc,
        ,abc,
       ,bc,a
        a,c,b
       ,ac,b
       ,c,ab
       ab,,c
        b,a,c
       b,,ac
        a,b,c
       ,ab,c
       ,b,ac
       a,,bc
       ,a,bc
        ,,abc
        [3,18,6]
        """"""",1420113900
turtleman271,turtleman271,617,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for i in range(len(nums)):
            cur = nums[i]
            result.append(-1)
            for j in range(1, cur):
                if j | j+1 == cur:
                    result[-1] = j
                    break
        return result",1420006054
turtleman271,turtleman271,617,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        pows = []
        a = 1
        while a <= 1000000000:
            pows.append(a)
            a*=2
        print(pows)

        for i in range(len(nums)):
            cur = nums[i]
            result.append(-1)
            for j in pows:
                other = cur - j
                if other | other+1 == cur:
                    result[-1] = other
                
        return result",1420025397
Procodgok,Procodgok,618,3604,cpp,"#define ll long long int
#define mod 1000000007
#define modsum(a,b)  ((a%mod)+(b%mod))%mod
#define modpro(a,b)  ((a%mod)*(b%mod))%mod
#define moddif(a,b)  ((a%mod)-(b%mod)+mod)%mod
#define modsumt(a,b,c) modsum(a,modsum(b,c))
ll modularExponentiation(ll x,ll n,ll M)
{
    ll result=1;
    while(n>0)
    {
        if(n % 2 ==1)
            result=modpro(result,x);
        x=modpro(x,x);
        n=n/2;
    }
    return result;
}
ll  modInverse(ll n, ll p) 
{ 
    return modularExponentiation(n, p - 2, p); 
} 

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector <ll> fact(2005);
        vector <ll> modf(2005);
        fact[0]=1;
        for(ll i=1;i<=2000;i++) fact[i]=(i*fact[i-1])%mod;
        for(ll i=0;i<=2000;i++) modf[i]=modInverse(fact[i],mod);
        ll sum=0;
        ll py=1;
        ll ans=0;
        int z=min(x,n);
        vector <ll> ways(z+1);
        for(ll i=1;i<=z;i++){
           ways[i]=modularExponentiation(i,n,mod);
           for(ll j=1;j<i;j++){
              ways[i]=moddif(ways[i],modpro(ways[j],modpro(fact[i],modpro(modf[j],modf[i-j]))));
           }
        }
        for(ll i=1;i<=z;i++){
            ll xci = modpro(fact[x],modpro(modf[i],modf[x-i]));
            py=modpro(py,y);
            ans = modsum(ans,modpro(xci,modpro(py,ways[i])));
        }
        int ans1=ans;
        return ans1;
    }
};",1420120226
Procodgok,Procodgok,618,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        ans.resize(nums.size());
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2) ans[i]=-1;
            else{
               int x=nums[i];
               for(int j=0;j<30;j++){
                  if(nums[i] & (1<<j)) {}
                  else{
                    x-=(1<<(j-1));
                    break;
                  }
               }
               ans[i]=x;
            }
        }
        return ans;
    }
};",1420006470
Procodgok,Procodgok,618,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        ans.resize(nums.size());
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2) ans[i]=-1;
            else{
               int x=nums[i];
               for(int j=0;j<30;j++){
                  if(nums[i] & (1<<j)) {}
                  else{
                    x-=(1<<(j-1));
                    break;
                  }
               }
               ans[i]=x;
            }
        }
        return ans;
    }
};",1420007770
Ajitesh Bharti,ajitesh98,619,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    vector<int> fac;
    vector<vector<int>> c;
    vector<vector<int>> sub;

    Solution() {
        fac = vector<int>(1002, 1);
        c = vector<vector<int>>(1002, vector<int>(1002, 0));
        sub = vector<vector<int>>(1002, vector<int>(1002, 0));
    }

    void fact(int n) {
        for (int i = 1; i <= n; i++) {
            fac[i] = (1ll * fac[i - 1] * i) % mod;
        }
    }

    void comb(int n) {
        for (int i = 0; i <= n; i++) {
            c[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
            }
        }
    }

    void subs(int n) {
        sub[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                sub[i][j] = (1ll * j * sub[i - 1][j] % mod + sub[i - 1][j - 1]) % mod;
            }
        }
    }

    long long modPow(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        fact(x);
        comb(x);
        subs(n);

        long long res = 0;
        for (int i = 1; i <= x; i++) {
            long long p = modPow(y, i, mod);
            res = (res + 1ll * c[x][i] * sub[n][i] % mod * fac[i] % mod * p % mod) % mod;
        }
        return res;
    }
};
",1420107556
Ajitesh Bharti,ajitesh98,619,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=nums[i];j++){
                int curr = j+1;
                if((j|curr)==nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420003977
Ajitesh Bharti,ajitesh98,619,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for (auto v:nums) {
            vector<int> temp;
            for (int i = 0; i < 32; ++i) {
                if (v & (1 << i)) {
                    int x = v & ~(1 << i);
                    if ((x | (x + 1)) == v) {
                        temp.push_back(x);
                    }
                }
            }
            if (temp.empty()) {
                ans.push_back(-1);
            } else {
                int minm = 1e9;
                for(auto v:temp) minm = min(minm, v);
                ans.push_back(minm);
            }
        }
        return ans;
    }
};",1420050582
Rahul Singh,Pirate-Emperor,620,3604,cpp,"#define ll long long
#define TxtIO   freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);

const int MAXN = 3e6 + 5; 
const int MAX_N = 2e5 + 1;
ll MOD = 1e9+7;
const ll MOD2 = 1073676287;
const ll MOD3 = 998244353;
const ll INF = 1e9;
const ll LINF = 1e18;

ll qexp(ll a, ll b, ll m) {
    ll res = 1;
    while (b) {
        if (b % 2) res = res * a % m;
        a = a * a % m;
        b /= 2;
    }
    return res;
}

vector<ll> fact, invf;

void precompute(int n) {
    fact.assign(n + 1, 1); 
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;
    invf.assign(n + 1, 1);
    invf[n] = qexp(fact[n], MOD - 2, MOD);
    for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;
}

ll nCk(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * invf[k] % MOD * invf[n - k] % MOD;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        precompute(1e4);
        long long res=0;
        for (int i=x;i>=1;i--)
        {
            if (n<i) continue;
            else
            {
                ll tem=0;
                int k=0;
                for (int j=i;j>=1;j--)
                {
                    ll t1 = (nCk(i,j)*qexp(j,n,MOD))%MOD;
                    if (k%2==0) tem=(tem+t1)%MOD;
                    else tem=(tem-t1+MOD)%MOD;
                    k++;
                }
                int temp = (nCk(x,i)*tem)%MOD;
                // temp = tem;
                temp = (temp*qexp(y,i,MOD))%MOD;
                
                // temp = (temp*nCk(n,i))%MOD;
                res=(res+temp)%MOD;
            }
        }
        int resu = res;
        return resu;
    }
};",1420120390
Rahul Singh,Pirate-Emperor,620,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> temp(2e3+10,-1);
        for (int i=1e3;i>=0;i--)
        {
            int tem = i | (i+1);
            temp[tem]=i;
        }
        int n=nums.size();
        vector<int> res(n);        
        for (int i=0;i<n;i++)
        {
            res[i]=temp[nums[i]];
        }
        return res;
    }
};",1420005171
Rahul Singh,Pirate-Emperor,620,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i=0;i<n;i++)
        {
            int x = nums[i];
            if (x==2) res[i]=-1;
            else
            {
                int temp=0;
                while(x>0)
                {
                    if (x%2==0) break;
                    else 
                    {
                        temp*=2;
                        temp++;
                    }
                    x/=2;
                }
                res[i] = nums[i]^temp;
                temp>>=1;
                res[i]^=temp;

            }
        }
        return res;
    }
};",1420016053
manohar-reddy-yaram,manohar-reddy-yaram,621,3604,cpp,"class Solution {
public:
    static const int MODULUS = 1e9 + 7;

    int numberOfWays(int totalItems, int groupCount, int multiplier) {
        
        std::vector<std::vector<int>> binomialCoeff(groupCount + 1, std::vector<int>(groupCount + 1, 0));
        for (int i = 0; i <= groupCount; ++i) {
            binomialCoeff[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                binomialCoeff[i][j] = (binomialCoeff[i - 1][j - 1] + binomialCoeff[i - 1][j]) % MODULUS;
            }
        } 
        std::vector<std::vector<int>> stirlingNumbers(totalItems + 1, std::vector<int>(groupCount + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalItems; ++i) {
            for (int j = 1; j <= groupCount; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MODULUS;
            }
        }
        std::vector<int> factorials(groupCount + 1, 1);
        for (int i = 1; i <= groupCount; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MODULUS;
        }
        long long result = 0;
        for (int k = 1; k <= groupCount; ++k) {
            long long multiplierPower = 1;
            for (int i = 0; i < k; ++i) {
                multiplierPower = (multiplierPower * multiplier) % MODULUS;
            }
            result = (result + (1LL * binomialCoeff[groupCount][k] * stirlingNumbers[totalItems][k] % MODULUS * factorials[k] % MODULUS * multiplierPower % MODULUS)) % MODULUS;
        }
        return result;
    }
};",1420107772
manohar-reddy-yaram,manohar-reddy-yaram,621,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # Initialize the output array with -1
        output = [-1] * len(nums)
        # Iterate over the indices of the input array
        for index in range(len(nums)):
            # Iterate over possible values of output[index]
            for candidate in range(nums[index]):
                # Check if the condition is satisfied
                if candidate | (candidate + 1) == nums[index]:
                    # Update the output array with the minimum possible value
                    output[index] = candidate
                    break
        # Return the output array
        return output",1420024401
manohar-reddy-yaram,manohar-reddy-yaram,621,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> inputList) {
        int length = inputList.size();
        int[] result = new int[length];
        
        for (int index = 0; index < length; index++) {
            int currentNum = inputList.get(index);
            int minValue = Integer.MAX_VALUE;
            boolean validFound = false;
            
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (((currentNum >> bitPosition) & 1) == 1) {
                    int potentialResult = currentNum & ~(1 << bitPosition);
                    
                    if (potentialResult < 0) continue;
                    
                    if ((potentialResult | (potentialResult + 1)) == currentNum) {
                        if (potentialResult < minValue) {
                            minValue = potentialResult;
                            validFound = true;
                        }
                    }
                }
            }
            
            result[index] = validFound ? minValue : -1;
        }
        
        return result;
    }
}
",1420081767
clashgamer1050,clashgamer1050,622,3604,cpp,"#include<iostream>
#include<vector>

#define ll long long 
#define NUM 1000000007

using namespace std;

class Solution {
private:
    ll ypowerk(int& y, int& k)
    {
        ll ans = 1;
        for(int i = 0; i<k; i++)
        {
            ans = (ans*y)%NUM ;
        }
        return ans;
    }

    ll xCk(int x, int k, vector<vector<int>>& binomial)
    {
        if(x<k) { return 0 ;}
        if(k==1) { return x ;}
        if(binomial[x][k]) { return binomial[x][k] ; }
        binomial[x][k] = (xCk(x-1, k, binomial) + xCk(x-1, k-1, binomial))%NUM ;
        return binomial[x][k] ;
    }

    ll  M(int n, int k, vector<vector<int>>& dp)
    {
        // We return modulo NUm
        if(k>n) { return 0 ;}
        if(dp[n][k]) { return dp[n][k] ; }
        dp[n][k] = (k*(M(n-1, k, dp) + M(n-1, k-1, dp)))%NUM ;
        return dp[n][k] ;
    }
public:
    int numberOfWays(int n, int x, int y)
    {
        // We iterate over number of stages used ie k
        vector<vector<int>> dp(n+1, vector<int>(x+1, 0)) ;
        vector<vector<int>> binomial(x+1, vector<int>(x+1, 0)) ;
        
        for(int i = 1; i<=n; i++) { dp[i][1] = 1 ; }
        // dp[n][k] represents M(n, k) ;
        ll w = 0 ;
        for(int k = 1; k<=x; k++)
        {
            w = (w + (((xCk(x, k, binomial)*M(n, k, dp))%NUM)*(ypowerk(y, k)))%NUM)%NUM ;
        }
        return w ;
    }
};

auto init = [](){
    std :: ios :: sync_with_stdio(false) ;
    std :: cin.tie(nullptr) ;
    std :: cout.tie(nullptr) ;
    return 0;
}() ;",1420120671
clashgamer1050,clashgamer1050,622,3605,cpp,"#include<iostream>
#include<vector>

using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums)
    {
        int n = nums.size() ;
        vector<int> M(n, -1);

        // only for 2 do we have no M[i]
        int t, sub;
        for(int i = 0; i<n; i++)
        {
            if(nums[i]==2) { continue ; }

            // If n 1's at the end in binary then nums[i] - 2^(n-1) is the min
            sub = 1;
            t = nums[i]>>1 ;
            while(t%2!=0)
            {
                t = t>>1 ;
                sub = 2*sub ;
            }
            M[i] = nums[i] - sub ;
        }

        return M ;
    }
};

auto init = [](){
    std :: ios :: sync_with_stdio(false) ;
    std :: cin.tie(nullptr) ;
    std :: cout.tie(nullptr) ;
    return 0;
}() ;",1420017892
clashgamer1050,clashgamer1050,622,3611,cpp,"#include<iostream>
#include<vector>

using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums)
    {
        int n = nums.size() ;
        vector<int> M(n, -1);

        // only for 2 do we have no M[i]
        int t, sub = 1;
        for(int i = 0; i<n; i++)
        {
            if(nums[i]==2) { continue ; }

            // If n 1's at the end in binary then nums[i] - 2^(n-1) is the min
            sub = 1;
            t = nums[i]>>1 ;
            while(t%2!=0)
            {
                t = t>>1 ;
                sub = 2*sub ;
            }
            M[i] = nums[i] - sub ;
        }

        return M ;
    }
};

auto init = [](){
    std :: ios :: sync_with_stdio(false) ;
    std :: cin.tie(nullptr) ;
    std :: cout.tie(nullptr) ;
    return 0;
}() ;",1420030810
Nirvana,soham_patwari,624,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();

        int[]  dp = new int[m +1];

        boolean [] isTarget = new boolean[n];

        for(int i = 0 ; i < m + 1 ; i++){
            dp[i] = Integer.MAX_VALUE;
        }

        dp[0] = 0;

        for(int now : targetIndices){
            isTarget[now] = true;
        }

        for(int i = 0 ; i < n ; i++){
            for(int j = m ; j > 0 ; j--){
                if(source.charAt(i)== pattern.charAt(j-1) && dp[j-1] != Integer.MAX_VALUE)
                 dp[j] = Math.min(dp[j] , dp[j-1] + (isTarget[i] ? 1 : 0));
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420118315
Nirvana,soham_patwari,624,3604,java,"class Solution {

    final int MOD = 1000000007;
    public int numberOfWays(int n, int x, int y) {
        int[][] comb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        int[][] stirling = new int[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (int) ((1L * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD);
            }
        }
        int[] factorial = new int[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (int) ((1L * factorial[i - 1] * i) % MOD);
        }
        long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1L * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return (int) total_ways;
    }
}",1420121382
Nirvana,soham_patwari,624,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int [] ans = new int[n];

        for(int i = 0 ; i < n ; i++){
            if(nums.get(i)==2){
                ans[i] = -1;
            }
            else{
                ans[i] = 1;
                while(true){
                    if((ans[i] | (ans[i] + 1 )) == nums.get(i)){
                        break;
                    }

                    ans[i]++;
                }
            }
        }

        return ans;
    }
}",1419999593
Jb1u4WvKYq,Jb1u4WvKYq,625,3604,cpp,"class Solution {
public:
    long long mod = 1e9+7;
    vector<long long> inv;
    int numberOfWays(int n, int x, int y) {
        long long ans=0,comb=1,power=1;
        vector<long long>collection(x+1,1);
        for(int i=0;i<x+1;i++){
            for(int j=0;j<n;j++){
                collection[i]*=i;
                collection[i]%=mod;
            }
        }
        inv.push_back(1);
        for(int i=1;i<=x;i++){
            long long x,y;
            extendedgcd(i,mod,x,y);
            inv.push_back(x);
        }
        for(int k=1;k<=x;k++){
            long long temp = help(k,n,collection);
            comb=(comb*(x-k+1))%mod;
            comb=(comb*inv[k])%mod;
            power*=y;
            power%=mod;
            long long t = comb*temp;
            t%=mod;
            t*=power;
            t%=mod;
            ans+=t;
            ans%=mod;
            
        }
        return ans;
    }
    long long help(long long k, long long n,vector<long long>&collection){
        long long val=collection[k],comb=1;
        for(int i=1;i<=k;i++){
            comb=(comb*(k-i+1))%mod;
            comb=(comb*inv[i])%mod;
            if(i&1){
                long long temp = comb*collection[k-i];
                temp%=mod;
                val=(val-temp+mod)%mod;
            }
            else {
                long long temp = comb*collection[k-i];
                temp%=mod;
                val+=temp;
                val%=mod;
            }
        }
        return val;
    }
    void extendedgcd(long long a,long long n,long long  &x,long long  &y){
        if(a==0){
            y=1;
            x=0;
            return;
        }
        long long x1,y1;
        extendedgcd(n%a,a,x1,y1);
        x=(y1-(((n/a)*x1)%mod)+3*mod)%mod;
        y=x1;
    }
};",1420108782
Jb1u4WvKYq,Jb1u4WvKYq,625,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            ans.push_back(help(nums[i]));
        }
        return ans;
    }
    int help(int x){
        if(x==2) return -1;
        int id=0;
        for(;id<31;id++){
            if((x&(1<<id))==0)break;
        }
        x^=1<<(id-1);
        return x;
    }
};",1420009866
Jb1u4WvKYq,Jb1u4WvKYq,625,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            ans.push_back(help(nums[i]));
        }
        return ans;
    }
    int help(int x){
        if(x==2) return -1;
        int id=0;
        for(;id<31;id++){
            if((x&(1<<id))==0)break;
        }
        x^=1<<(id-1);
        return x;
    }
};",1420009161
Anurag Narayan Jena,anj20,626,3604,cpp,"typedef long long ll;
class Solution {
private:
    const int MOD = 1e9 + 7;
    ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
    ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
    ll binpow(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}

    vector<ll> pre_fact(int x) 
    {
        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i)fact[i] =mod_mul(fact[i - 1], i, MOD);
        return fact;
    }
    vector<vector<ll>> pre_Part(int n, int x) 
    {
        vector<vector<ll>> part(n + 1, vector<ll>(x + 1, 0));
        part[0][0] = 1;
        for (int i = 1; i <= n; ++i) 
            for (int j = 1; j <= x; ++j)part[i][j] = mod_add(j * part[i - 1][j],part[i - 1][j - 1],MOD);
        return part;
    }
    vector<vector<ll>> pre_computeComb(int x)
    {
        vector<vector<ll>> comb(x + 1, vector<ll>(x + 1, 0));
        for(int i=0;i<=x;i++)comb[i][0]=1;
        for (int i = 0; i <= x; ++i) 
            for (int j = 1; j <= i; ++j)comb[i][j] = mod_add(comb[i-1][j],comb[i-1][j-1],MOD);
        return comb;
    }   

public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> comb =pre_computeComb(x);
        vector<vector<ll>> part =pre_Part(n, x);
        vector<ll> fact=pre_fact(x);
        ll ans = 0ll;
        for (int k = 1; k <= x; ++k) 
        {
            ll curr=mod_mul(comb[x][k],part[n][k],MOD);// c(x,k)*p(n,k)
            curr = mod_mul(mod_mul(curr,binpow(y,k,MOD),MOD),fact[k],MOD); // y^k*fact[k]
            ans= mod_add(ans,curr,MOD);
        }
        return (int)ans;
    }
};",1420121474
Anurag Narayan Jena,anj20,626,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2==0)continue;
            int k;
            for(k=0;k<31;k++)
            {
                if(((nums[i]>>k)&1ll)==0)
                {
                    // cout<<k<<' ';
                    break;
                }
            }
            k--;
            // cout<<k<<' ';
            ans[i]=nums[i]-(1ll<<k);
        }
        return ans;
    }
};",1420017332
Anurag Narayan Jena,anj20,626,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2==0)continue;
            int k;
            for(k=0;k<31;k++)
            {
                if(((nums[i]>>k)&1ll)==0)break;
            }
            k--;
            ans[i]=nums[i]-(1ll<<k);
        }
        return ans;
    }
};",1420019581
3905aj,3905aj,627,3604,cpp,"const long long mod = 1e9+7;
class Solution {
public:
    

    long long binpow(long long a, long long b){
        long long res = 1;
        while(b){
            if(b&1) res = (res*a)%mod;
            a = (a*a)%mod;
            b>>=1;
        }
        return res;
    }

    long long minv(long long x){
        return binpow(x, mod-2);
    }

    long long ncr(vector<long long> &fact, long long n, long long r){
        return ((fact[n]*minv(fact[r]))%mod)*minv(fact[n-r])%mod;
    }

    int numberOfWays(int n, int x, int y) {
        vector<long long> fact(max(n,x)+1,1);
        for(int i = 1; i<max(n,x)+1; i++) fact[i] = (i*fact[i-1])%mod;
        long long ans = 0;
        for(long long r = 1; r<=min(n,x); r++){
            long long t = 0;
            for(long long i = 0; i<=r; i++){
                if((i%2)==0) t+=binpow(r-i,n)*ncr(fact,r,i)%mod;
                else t-=binpow(r-i,n)*ncr(fact,r,i)%mod;
                t = (t%mod + mod)%mod;
            }
            t*=ncr(fact,x,r);
            t%=mod;
            ans = (ans + t*binpow(y,r)%mod)%mod;
        }
        return ans;
    }
};",1420121584
3905aj,3905aj,627,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto p : nums){
            if(p==2) ans.push_back(-1);
            else {
                int x = 0;
                while(p&(1<<x) && p&(1<<(x+1))) x++;
                ans.push_back(p-(1<<x));
            }
        }
        return ans;
    }
};",1420011486
3905aj,3905aj,627,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto p : nums){
            if(p==2) ans.push_back(-1);
            else {
                int x = 0;
                while(p&(1<<x) && p&(1<<(x+1))) x++;
                ans.push_back(p-(1<<x));
            }
        }
        return ans;
    }
};",1420010072
Aman pratap singh,aman_2721,628,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0        
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))        
        if dp[m] == float('inf'):
            return 0
        return len(targetIndices) - dp[m]
        ",1420121762
Aman pratap singh,aman_2721,628,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        
        while params:
            break
        
        
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420107530
Aman pratap singh,aman_2721,628,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        l=len(nums)
        ans=[]
        for i in range(0,l):
            ans.append(-1)
            for j in range(0,nums[i]):
                if (j|(j+1))==int(nums[i]):
                    ans[i]=j
                    break
                else:
                    j+1
        return ans
        ",1420089907
Kashyap Vekariya,kashyap1905,629,3604,python3,"class Solution:
    MOD = 10**9 + 7
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        pastri = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            pastri[i][0] = 1
            for j in range(1, i + 1):
                pastri[i][j] = (pastri[i-1][j-1] + pastri[i-1][j]) % self.MOD

        belnum = [[0] * (x + 1) for _ in range(n + 1)]
        belnum[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                belnum[i][j] = (j * belnum[i-1][j] + belnum[i-1][j-1]) % self.MOD

        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = (fact[i-1] * i) % self.MOD

        totalcom = 0
        for k in range(1, x + 1):
            scalfact = pow(y, k, self.MOD)
            curcomb = (
                pastri[x][k] *
                belnum[n][k] *
                fact[k] *
                scalfact
            ) % self.MOD
            totalcom = (totalcom + curcomb) % self.MOD

        return totalcom",1420115609
Kashyap Vekariya,kashyap1905,629,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n  
            
        for j in range(n):
            num = nums[j]
            min_ans = float('inf')
            found = False
            
            for i in range(31):
                if (num >> i) & 1 == 1:
                    candidate = num & ~(1 << i)
                    
                    if candidate < 0:
                        continue
                    
                    if (candidate | (candidate + 1)) == num:
                        if candidate < min_ans:
                            min_ans = candidate
                            found = True
            
            ans[j] = min_ans if found else -1
        
        return ans",1420055727
Kashyap Vekariya,kashyap1905,629,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for j in range(n):
            num = nums[j]
            min_ans = float('inf')
            found = False
            
            for i in range(31):
                if (num >> i) & 1 == 1:
                    candidate = num & ~(1 << i)
                    
                    if candidate < 0:
                        continue
                    
                    if (candidate | (candidate + 1)) == num:
                        if candidate < min_ans:
                            min_ans = candidate
                            found = True
            
            ans[j] = min_ans if found else -1
        
        return ans",1420056509
Dilworth,dilworth,630,3604,cpp,"class Solution {
    const int mod = 1e9 + 7;
    int add(int a, int b) {
        a += b;
        if (a >= mod) a -= mod;
        if (a < 0) a += mod;
        return a;
    }
    
    int mul(int a, int b) {
        a = (1LL * (a % mod) * (b % mod)) % mod;
        return a;
    }

    int mpow(int x, int y) {
        int res = 1;
        while (y > 0) {
            if (y & 1) res = mul(res, x);
            y >>= 1;
            x = mul(x, x);
        }
        return res;
    }

    vector<vector<int>> stirlingNumber(int n, vector<int> &fact) {
        vector<vector<int> > dp(
            n + 1, vector<int>(n + 1, 0));
    
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= min(i, n); j++) {
                if (j == 1 || j == i) dp[i][j] = 1;
                else dp[i][j] = add(dp[i - 1][j - 1], mul(j, dp[i - 1][j]));
            }
        }

        return dp;
    }

    vector<int> factorial(int n) {
        vector<int> fact(n + 1, 0);
        fact[0] = 1;
        for (int i = 1; i <= n; ++i) {
            fact[i] = mul(fact[i - 1], i);
        }
        return fact;
    }


    vector<vector<int>> nCr(int n) {
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= min(i, n); ++j) {
                if (j == 0 || j == i) dp[i][j] = 1;
                else dp[i][j] = add(dp[i - 1][j - 1], dp[i - 1][j]);
            }
        }
        return dp;
    }
public:
    int numberOfWays(int n, int x, int y) {
        int ans = mul(x, y);
        cout << ans << '\n';
        int v = max(n, x) + 1;
        auto fact = factorial(v);
        auto stir = stirlingNumber(v, fact);
        auto ncr = nCr(v);
        for (int i = 2; i <= min(n, x); ++i) {
            int cur = ncr[x][i];
            cout << ncr[x][i] << ' ';
            cur = mul(cur, fact[i]);
            cout << fact[i] << ' ';
            cur = mul(cur, stir[n][i]);
            cout << stir[n][i] << ' ';
            cout << cur << '\n';
            cur = mul(cur, mpow(y, i));
            ans = add(ans, cur);
        }
        cout << '\n';
        return ans;
    }
};",1420122146
Dilworth,dilworth,630,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); ++i) {
            int val = nums[i];
            int now = -1;
            for (int cur = 1; cur <= 2000; ++cur) {
                if ((cur | (cur + 1)) == val) {
                    now = cur; break;
                }
            }
            ans[i] = now;
        }
        return ans;
    }
};",1419994607
Dilworth,dilworth,630,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto x: nums) {
            int k = 0;
            while (x & (1 << k)) ++k;
            --k;
            if (k == -1) ans.push_back(-1);
            else {
                int rem = 0;
                int st = k + 1;
                while (st < 31) {
                    if (x & (1 << st)) rem |= (1 << st);
                    ++st;
                }
                int vl = (1 << k) | rem;
                if ((vl | (vl - 1)) == x) ans.push_back(vl - 1);
                else ans.push_back(x - 1);
            }
        }
        return ans;
    }
};",1420027656
Beats Stucker,Stuckers,631,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();  
        int m = pattern.length(); 

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;  
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;  
        }

       
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {  
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

       
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420088099
Beats Stucker,Stuckers,631,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420122167
Beats Stucker,Stuckers,631,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

    for (int num : nums) {
        bool found = false;

       
        for (int i = 0; i < num; ++i) {
            if ((i | (i + 1)) == num) {
                ans.push_back(i);
                found = true;
                break;
            }
        }

               if (!found) {
            ans.push_back(-1);
        }
    }

    return ans;

    }
};",1420036809
John Rigby,vanshkunwarji41,632,3604,cpp,"const long long M=1e9+7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        long long dp[n][x+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<=x;j++){
                if(i==0){
                    if(j==1){
                        dp[i][j]=x*y;
                    }
                    else{
                        dp[i][j]=0;
                    }
                }
                else{
                    dp[i][j]=(j*dp[i-1][j])%M;
                    if(j!=0){
                        dp[i][j]=(dp[i][j]+(dp[i-1][j-1]*(x-j+1)*y)%M)%M;
                    }
                }
                // cout<<i<<"" ""<<j<<"" ""<<dp[i][j]<<endl;
            }    
        }
        long long h=0;
        for(int i=0;i<=x;i++){
            // cout<<dp[n]
            h=(h+dp[n-1][i])%M;
        }
        return h;
    }
};",1420122640
John Rigby,vanshkunwarji41,632,3605,cpp,"class Solution {
public:
    int f(int x){
        if(x==1){
            return 0;
        }
        int u=0;
        for(int i=31;i>=0;i--){
            if(x&(1<<i)){
                u=i;
                break;
            }
        }
        if(((1<<u)|((1<<u)-1))==x){
            return (1<<u)-1;
        }
        // if(x==5){
        //     cout<<u<<endl;
        // }
        return (1<<u)+f(x-(1<<u));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(auto &i:nums){
            if(i==2){
                i=-1;
                continue;
            }
            i=f(i);
        }
        return nums;
    }
};",1420020416
John Rigby,vanshkunwarji41,632,3611,cpp,"class Solution {
public:
    int f(int x){
        if(x==1){
            return 0;
        }
        int u=0;
        for(int i=31;i>=0;i--){
            if(x&(1<<i)){
                u=i;
                break;
            }
        }
        if(((1<<u)|((1<<u)-1))==x){
            return (1<<u)-1;
        }
        // if(x==5){
        //     cout<<u<<endl;
        // }
        return (1<<u)+f(x-(1<<u));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(auto &i:nums){
            if(i==2){
                i=-1;
                continue;
            }
            i=f(i);
        }
        return nums;
    }
};",1420020246
Manish Kumar,yhYTzMtNQt,633,3604,cpp,"#define ff first
#define sz size()
#define ss second
#define ll long long 
#define pb push_back
#define vll vector<ll>
#define ump unordered_map
#define all(x) x.begin(),x.end()
#define vllp vector<pair<ll,ll>>  
int mod=1e9+7;
class Solution {
vll fact={1};
ll mmpinv(ll a, ll b) { return expo(a, b - 2, b); }
ll ncr(ll n, ll r){
    ll d1=mmpinv(fact[r],mod);
    ll d2=mmpinv(fact[n-r],mod);
    ll ans=mul(mul(fact[n],d1,mod),d2,mod);
    return ans;
}
    
public:
    int numberOfWays(int n, int x, int y) {
        
        for(int i=1;i<=max(n,x)+1;i++){
            fact.pb(mul(fact.back(),i,mod));
        }
        ll ans=0;
        ll pre=1;
        ll old=0;
        vll wo;
        for(ll stg=1;stg<=min(x,n);stg++){
            ll xCstg=ncr(x,stg);
            ll nDisOverstg=expo(stg,n,mod);
            
            // ll g=mul(old,stg,mod);
            int p=0;
            for(ll i=wo.size()-1;i>=0;i--){
                p++;
                ll xx=ncr(stg,stg-p);
                ll tempo=mul(wo[i],xx,mod);
            nDisOverstg=add(nDisOverstg,-1*tempo,mod);
            }
            
            
            
            wo.pb(nDisOverstg);
            ll ydis=expo(y,stg,mod);
            
            
            ll temp=mul(ydis,nDisOverstg,mod);
            
            temp=mul(temp,xCstg,mod);
            ans=add(ans,temp,mod);
            // old=0;
        }
       return ans;
        
    }
    
ll mul(ll a, ll b, ll m){
    a = a % m;
    b = b % m;
    return (((a * b) % m) + m) % m;}
ll expo(ll a, ll b, ll m){
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = (res * a) % m;
        a = (a * a) % m;
        b = b >> 1;
    }
    return res;
}
ll add(ll a, ll b, ll m){
    a = a % m;
    b = b % m;
    return (((a + b) % m) + m) % m;
}
};",1420116475
Manish Kumar,yhYTzMtNQt,633,3605,cpp,"#define ff first
#define sz size()
#define ss second
#define ll int
#define pb push_back
#define vll vector<ll>
#define ump unordered_map
#define all(x) x.begin(),x.end()
#define vllp vector<pair<ll,ll>> 


class Solution {
public:
    int fun(int num){
        int ans=0;
        vector<int> temp;
        while(num){
            temp.pb(num%2);
            num/=2;
        }
        int flag=1;
        for(int i=0;i<temp.size();i++){
            if(temp[i]==0){
                flag=0;
                temp[i-1]=0;break;
            } 
        }
        if(flag)temp.back()=0;
        reverse(all(temp));
        for(auto it:temp){
            ans=ans*2+it;
        }
        return ans;
        
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vll ans;
        for(auto it:nums){
            if(it==2)ans.pb(-1);
            else {
                int a=fun(it);
                ans.pb(a);
            }
        }
        return ans;
        
    }
};",1420013386
Manish Kumar,yhYTzMtNQt,633,3611,cpp,"#define ff first
#define sz size()
#define ss second
#define ll int
#define pb push_back
#define vll vector<ll>
#define ump unordered_map
#define all(x) x.begin(),x.end()
#define vllp vector<pair<ll,ll>> 


class Solution {
public:
    int fun(int num){
        int ans=0;
        vector<int> temp;
        while(num){
            temp.pb(num%2);
            num/=2;
        }
        int flag=1;
        for(int i=0;i<temp.size();i++){
            if(temp[i]==0){
                flag=0;
                temp[i-1]=0;break;
            } 
        }
        if(flag)temp.back()=0;
        reverse(all(temp));
        for(auto it:temp){
            ans=ans*2+it;
        }
        return ans;
        
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vll ans;
        for(auto it:nums){
            if(it==2)ans.pb(-1);
            else {
                int a=fun(it);
                ans.pb(a);
            }
        }
        return ans;
        
    }
};",1420013702
Raj Sen,rajsen_01,634,3604,cpp,"
class Solution 
{
public:
    long long MOD = 1e9 + 7;
    
    long long numberOfWays(long long n, long long x, long long y) 
    {
        vector<vector<long long>> v(x + 1, vector<long long>(x + 1, 0));
        for (long long i = 0; i <= x; i++) 
        {
            v[i][0] = 1;
            for (long long j = 1; j <= i; ++j)
                v[i][j] = (v[i - 1][j - 1]+v[i - 1][j]) % MOD;
        }

        vector<vector<long long>> v2(n + 1, vector<long long>(x + 1, 0));
        v2[0][0] = 1;
        for (long long i = 1; i <= n; i++)
            for (long long j = 1; j <= x; ++j)
                v2[i][j] = (j*v2[i - 1][j]+v2[i - 1][j - 1]) % MOD;

        vector<long long> fact(x + 1, 1);
        for (long long i = 1; i <= x; i++)
            fact[i] = (fact[i - 1]*i) % MOD;

        long long total = 0;
        for (long long k = 1; k <= x; ++k) 
        {
            long long power = 1;
            for (long long p = 0; p < k; ++p)
                power = (power * y) % MOD;
            total = (total + v[x][k]*v2[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return total;
    }
};

",1420123796
Raj Sen,rajsen_01,634,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n= nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<nums[i]; j++)
            {
                if((j|(j+1))==nums[i])
                {
                        ans[i]= j;
                        break;
                }
            }
        }    
        return ans;
    }
};",1419996909
Raj Sen,rajsen_01,634,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n=nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++)
        {
            int x= nums[i];
            bitset<31> arr(x);
            if(((x+1)&x) ==0)
                ans[i]= x>>1;
            else if(x==2)
                ans[i]=-1;
            else
            {
                int cnt=0;
                for(int k=0; k<31; k++)
                {
                    if(arr[k])
                        cnt++;
                    else
                        break;
                }
                ans[i]= (x-(1<<(cnt-1)));
            }
        }
        return ans;
    }
};",1420033533
Tushar Solanki,Tusharsolanki077,635,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        
        int n = source.length();
        int m = pattern.length();
        
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        int kk = 0;
        for( int i=0;i<10000; i++ ){
            kk += 1;
        }

        vector<bool> isTarget(n, false);
        for (int k = 0; k < targetIndices.size(); k++) {
            int idx = targetIndices[k];
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            vector<int> new_dp = dp;

            for (int j = 1; j <= m; j++) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    int additionalCost = isTarget[i] ? 1 : 0;
                    new_dp[j] = min(new_dp[j], dp[j - 1] + additionalCost);
                }
            }

            dp = new_dp;
        }
        int mm = 0;
        for( int i=0;i<10000; i++ ){
            mm += 1;
        }

        if (dp[m] == INT_MAX) {
            return targetIndices.size();
        } else {
            return targetIndices.size() - dp[m];
        }
    }
};
",1420073476
Tushar Solanki,Tusharsolanki077,635,3604,cpp,"class Solution {
public:
    typedef unsigned long long ULL;
    const ULL MOD = 1e9 + 7;

    ULL numberOfWays(ULL n, ULL x, ULL y) {
        vector<ULL> params = {n, x, y};
        int kk=0;
        for( int i=0;i<10000;i++ ){
            kk+=1;
        }
        vector<vector<ULL>> fun(x + 1, vector<ULL>(x + 1, 0));
        ULL i = 0;
        do {
            fun[i][0] = 1;
            ULL j = 1;
            do {
                if (j <= i) {
                    fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
                }
                j++;
            } while (j <= i);
            i++;
        } while (i <= x);

        vector<vector<ULL>> stirling(n + 1, vector<ULL>(x + 1, 0));
        stirling[0][0] = 1;
        ULL m = 1;
        do {
            ULL j = 1;
            do {
                if (j <= x) {
                    stirling[m][j] = (j * stirling[m - 1][j] + stirling[m - 1][j - 1]) % MOD;
                }
                j++;
            } while (j <= x);
            m++;
        } while (m <= n);
        int mm=0;
        for( int i =0;i<10000;i++ ){
            mm+=1;
        }

        vector<ULL> mathFact(x + 1, 1);
        ULL f = 1;
        do {
            if (f <= x) {
                mathFact[f] = mathFact[f - 1] * f % MOD;
            }
            f++;
        } while (f <= x);
        int hh=0;
        for( int i =0;i<10000;i++ ){
            hh+=1;
        }
        ULL totalWays = 0;
        ULL k = 1;
        do {
            ULL power = 1;
            ULL p = 0;
            do {
                power = (power * y) % MOD;
                p++;
            } while (p < k);
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
            k++;
        } while (k <= x);
        int yy=0;
        for( int i =0;i<10000;i++ ){
            yy+=1;
        }
        return totalWays;
    }
};
",1420123991
Tushar Solanki,Tusharsolanki077,635,3605,cpp,"class Solution {
public:
int findAns(int num) {
    for (int ans = 0; ans <= num; ans++) {
        if ((ans | (ans + 1)) == num) {
            return ans;
        }
    }
    return -1;
}

vector<int> minBitwiseArray(const vector<int>& nums) {

    int n = nums.size();
    vector<int> ans(n); 
    int kk=0;
    for( int i=0;i<10000;i++ ){
        kk+=1;
    }
    for (int i = 0; i < n; i++) {
        ans[i] = findAns(nums[i]);
    }

    return ans; 
}
};",1420015971
Nishant Singh,nishant_7366,636,3604,cpp,"class Solution {
public:
    int MOD=1e9+7;
    int helper(int i,int j,int n,int x,int y,int dp[1001][1001])
    {
        if(i==n)
        return 1;

        if(dp[i][j]!=-1)
        return dp[i][j];

        long long take=0;
        long long not_take=0;

        take=((long long)j*(helper(i+1,j,n,x,y,dp)%MOD));
        not_take=((long long)y*(x-j)*(helper(i+1,j+1,n,x,y,dp)%MOD));
        //cout<<take<<"" ""<<not_take<<""\n"";
        return dp[i][j]=(take%MOD+not_take%MOD)%MOD;
    }
    int numberOfWays(int n, int x, int y) {
        int dp[1001][1001];
        memset(dp,-1,sizeof(dp));

        return helper(0,0,n,x,y,dp);
    }
};",1420118103
Nishant Singh,nishant_7366,636,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> sol;
        for(auto j:nums)
        {
            bool found=false;
            for(int i=0;i<=1000;i++)
            {
                if(found)
                continue;

                if((i|(i+1))==j)
                {
                    sol.push_back(i);
                    found=true;
                }
            }
            if(!found)
            sol.push_back(-1);
        }
        return sol;
    }
};",1419999081
Nishant Singh,nishant_7366,636,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> sol(n);

        for(int i=0;i<n;i++)
        {
            if(nums[i]%2==0)
            {
                sol[i]=-1;
            }
            else
            {
                int temp=nums[i];
                int val=0;
                int pos=0;
                //cout<<((temp>>pos)&1)<<"" ""<<((temp>>(pos+1))&1)<<"" "";
                while(((temp>>pos)&1)==1 && ((temp>>(pos+1))&1)==1)
                {
                    val=val|(1<<pos);
                    pos++;
                }
                //cout<<val<<"" "";
                temp=temp>>(pos+1);
                pos++;
                while(temp)
                {
                    val=val|((temp&1)<<pos);
                    temp=temp>>1;
                    pos++;
                }

                sol[i]=min(nums[i]-1,val);
            }
            //cout<<""\n"";
        }
        return sol;
    }
};",1420035805
AMIT PRATAP SINGH,amitpratapsingh1617,637,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string text, std::string pattern, std::vector<int>& removal_indices) {
        int text_length = text.size();
        int pattern_length = pattern.size();
        std::vector<int> dp(pattern_length + 1, INT_MAX);
        dp[0] = 0;
        std::vector<bool> is_removal_index(text_length, false);

        for (int index : removal_indices) {
            is_removal_index[index] = true;
        }

        for (int i = 0; i < text_length; ++i) {
            for (int j = pattern_length; j > 0; --j) {
                if (text[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (is_removal_index[i] ? 1 : 0));
                }
            }
        }

        return removal_indices.size() - (dp[pattern_length] == INT_MAX ? 0 : dp[pattern_length]);
    }
};",1420113971
AMIT PRATAP SINGH,amitpratapsingh1617,637,3604,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    
    vector<vector<long long>> computeCombinations(int size) {
        vector<vector<long long>> C(size + 1, vector<long long>(size + 1, 0));
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }
    
    vector<vector<long long>> computePartitions(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }
    
    vector<long long> computeFactorials(int size) {
        vector<long long> fact(size + 1, 1);
        for (int i = 1; i <= size; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

public:
    int numberOfWays(int n, int x, int y) {
        auto C = computeCombinations(x);
        auto S = computePartitions(n, x);
        auto fact = computeFactorials(x);
        
        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            long long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * fact[k]) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }
        
        return static_cast<int>(result);
    }
};",1420124360
AMIT PRATAP SINGH,amitpratapsingh1617,637,3605,cpp,"class Solution {
private:
    int calculateSmallestValue(int target) {
        for (int candidate = 1; candidate <= target; ++candidate) {
            if ((candidate | (candidate + 1)) == target) {
                return candidate;
            }
        }
        return -1;  // No valid value found
    }

public:
    vector<int> minBitwiseArray(vector<int>& inputArray) {
        vector<int> result(inputArray.size(), -1);
        
        for (size_t index = 0; index < inputArray.size(); ++index) {
            result[index] = calculateSmallestValue(inputArray[index]);
        }
        
        return result;
    }
};",1420111230
Vishnu Vardhan,Vishnu767,638,3604,cpp,"class Solution {
public:
    #define ll long long 
    const static ll MAXN = 1001;
    const static ll MOD = 1e9+7;
    ll fact[MAXN];
    ll inv[MAXN];
    ll binmod(ll a,ll b,ll m){a %= m;ll res = 1;while (b > 0) {if (b & 1)res = res * a % m;a = a * a % m;b >>= 1;}return res;}
    ll modinv(ll a,ll m){return binmod(a,m-2,m);}
    ll ncr(ll n, ll k) { return fact[n] * inv[k] % MOD * inv[n - k] % MOD; }
    ll get_val(ll n, ll m){
        ll ans = 0;
        for(int h=0; h<=m; h++){
            ll val = ncr(m,h)*(h%2 == 0 ? 1 : -1)*binmod(m-h,n,MOD);
            val += MOD;
            val %= MOD;
            ans += val;
            ans %= MOD;
            ans += MOD;
            ans %= MOD;
        }
        return ans;
    }
    ll numberOfWays(int n, int x, int y) {
        fact[0] = inv[0] = fact[1] = inv[1] = 1;
        for (int i = 2; i < MAXN; i++) {
            fact[i] = fact[i - 1] * i % MOD;
            inv[i] = modinv(fact[i],MOD);
        }
        ll ans = 0;
        for(ll i=1; i<=x; i++){
            ll val = ncr(x,i);
            val *= binmod(y,i,MOD);
            val %= MOD;
            val *= get_val(n,i);
            // cout<<get_val(n,i)<<endl;
            val %= MOD;
            ans += val;
            ans %= MOD;
            ans += MOD;
            ans %= MOD;
        }
        return ans;
    }
};",1420111856
Vishnu Vardhan,Vishnu767,638,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int j=0; j<nums.size(); j++){
            for(int i=1; i<=1000; i++){
                int x = i;
                x |= (i+1);
                if(x == nums[j]){
                    // cout<<x<<endl;
                    ans.push_back(i);
                    break;
                }
                if(i == 1000){
                    ans.push_back(-1);
                }
            }
        }
        return ans;
    }
};",1420001136
Vishnu Vardhan,Vishnu767,638,3611,cpp,"class Solution {
public:
    vector<int> getbin(int x){
        vector<int> v(32, 0);
        for(int i=0; i<32; i++){
            v[31-i] = x%2;
            x /= 2;
        }
        return v;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto i : nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }
            vector<int> v = getbin(i);
            for(int i=31; i>=0; i--){
                if(v[i] == 0){
                    v[i+1] = 0; 
                    break;
                }
            }
            int val = 0;
            for(int i=0; i<32; i++){
                val = val*2 + v[i];
            }
            ans.push_back(val);
        }
        return ans;
    }
};",1420019472
Himanshu 123,Iftms9Fk9x,639,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105473
Himanshu 123,Iftms9Fk9x,639,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420010473
Himanshu 123,Iftms9Fk9x,639,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420039662
Shah Santosh,Shah_Santosh,640,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int index : targetIndices) {
            isTarget[index] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420117990
Shah Santosh,Shah_Santosh,640,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; ++i) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; ++i) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; ++i) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420124904
Shah Santosh,Shah_Santosh,640,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result(nums.size());

        for (int i = 0; i < nums.size(); ++i) {
            bool found = false;

            for (int x = 0; x <= nums[i]; ++x) {
                if ((x | (x + 1)) == nums[i]) {
                    result[i] = x;
                    found = true;
                    break;
                }
            }

            if (!found) {
                result[i] = -1;
            }
        }

        return result;
    }
};
",1420120841
Stefan Seibel,seibel,641,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        MOD = 1000000007
        
        ans = 0
        
        prevStages = 0
        prevStagesSingle = 0
        #uniqueWays[i] = unique ways to arrage in exactly i stages
        totalSum = 0
        uniqueWays = [0]
        
        
        distribute = [[0] * (x+1) for _ in range(x+1)]
        
        for i in range(1,x+1):
            distribute[i][0] = 1
            distribute[i][i] = 1
            for j in range(1,i):
                
                distribute[i][j] = distribute[i - 1][j - 1] + distribute[i - 1][j]
        
        
        
        
        for numStagesUsed in range(1, x+1):
            
            
            stageCombinations = 1
            
            for performer in range(n):
                
                stageCombinations = (stageCombinations * numStagesUsed) % MOD
            
            for i in range(1,numStagesUsed):
                
                stageCombinations = (stageCombinations + MOD - uniqueWays[i] * distribute[ numStagesUsed][i]) % MOD
                
            uniqueWays.append(stageCombinations)
            
            
            total = (stageCombinations * distribute[x][numStagesUsed]) % MOD
            
            totalScores = 1
            
            for i in range(numStagesUsed):
                totalScores = (totalScores * y) % MOD
            
            ans += (total * totalScores) % MOD
            
        
        return ans % MOD
                
            
            
            ",1420105995
Stefan Seibel,seibel,641,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def isPow2(n):

            ct = 1
            while ct < n:
                ct *= 2
            
            return ct == n

        ans = []

        for n in nums:

            if isPow2(n):
                ans.append(-1)
            elif isPow2(n+1):
                ans.append(n//2)
            elif n % 2:
                b = list(bin(n)[2:])
                
                for i in range(len(b)-2,-1,-1):
                    if b[i] == '0':
                        b[i+1] = '0'
                        break
                
                ans.append(int(''.join(b),2))
            else:
                ans.append(-1)
        
        return ans",1420008538
Stefan Seibel,seibel,641,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def isPow2(n):

            ct = 1
            while ct < n:
                ct *= 2
            
            return ct == n

        ans = []

        for n in nums:

            if isPow2(n):
                ans.append(-1)
            elif isPow2(n+1):
                ans.append(n//2)
            elif n % 2:
                b = list(bin(n)[2:])
                
                for i in range(len(b)-2,-1,-1):
                    if b[i] == '0':
                        b[i+1] = '0'
                        break
                
                ans.append(int(''.join(b),2))
            else:
                ans.append(-1)
        
        return ans",1420008266
michaelwww,michaelwww,642,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        @cache
        def factorial(n):
            return 1 if n <= 1 else n * factorial(n - 1)
        def perm(n, k):
            return factorial(n) // factorial(n - k)
        
        # table for stirling_partition_number
        S = [[0] * (x + 1) for _ in range(n + 1)]
        # Base cases
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
        for j in range(1, x + 1):
            S[0][j] = 0
        # Fill the table using the recurrence relation
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = j * S[i - 1][j] + S[i - 1][j - 1]
        def stirling_partition_number(n, k):
            return S[n][k]
        
        ans = 0
        for i in range(1, x + 1):
            ans += stirling_partition_number(n, i) * perm(x, i) * y ** i
        return ans % (10 ** 9 + 7)",1420125494
michaelwww,michaelwww,642,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                # locate consecutive 1's
                t = num
                r = 0
                while t % 2 == 1:
                    t = t >> 1
                    r += 1
                if t == 0:
                    ans.append((1 << r - 1) - 1)
                else:
                    ans.append((t << r) + (1 << r - 1) - 1)
        return ans",1420063434
michaelwww,michaelwww,642,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                # locate consecutive 1's
                t = num
                r = 0
                while t % 2 == 1:
                    t = t >> 1
                    r += 1
                if t == 0:
                    ans.append((1 << r - 1) - 1)
                else:
                    ans.append((t << r) + (1 << r - 1) - 1)
        return ans",1420064205
Coder,AJ___001,643,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int numberOfWays(int n,int x,int y){
        vector<vector<int>> ncr(x+1,vector<int>(x+1,0));
        for(int i=0;i<=x;i++){
            ncr[i][0]=1;
            for(int j=1;j<=i;j++){
                ncr[i][j]=(ncr[i-1][j-1]+ncr[i-1][j])%MOD;
            }
        }
        vector<vector<int>> sit(n+1,vector<int>(x+1,0));
        sit[0][0]=1;
        for(int i=1;i<=n;i++){
            for (int j=1;j<=x;j++){
                sit[i][j]=(1ll*j*sit[i-1][j]+sit[i-1][j-1])%MOD;
            }
        }
        vector<int> fact(x+1,1);
        for(int i=1;i<=x;i++){
            fact[i]=(1ll*fact[i-1]*i)%MOD;
        }
        long long ans = 0;
        for (int i=0;i<=x;i++) {
            long long p=1;
            for (int j=0;j<i;j++) {
                p=(p*y)% MOD;
            }
            ans=(ans+((1ll*ncr[x][i]*sit[n][i]% MOD)*(fact[i]% MOD*p% MOD)))%MOD;
        }
        return ans;
    }
};
",1420112864
Coder,AJ___001,643,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    int n=nums.size();
    vector<int> ans(n,-1); 
    for(int i=0;i<n;i++){
        for(int j=0;j<=nums[i];j++){
            if ((j|(j+1))==nums[i]){
                ans[i]=j;
                break;
            }
        }
    }
    return ans;
    }
};",1420004723
Coder,AJ___001,643,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n, -1);
        for (int i=0;i<n;i++) {
            int ans1=INT_MAX,temp;
            for(int j=0;j<32;j++){
                if(((nums[i]>>j)&1)==1){
                    temp=nums[i]&~(1<<j);
                }
                if(temp>=0){
                    if((temp|(temp+1))==nums[i])ans1=min(ans1,temp);
                }
            }
            if(ans1==INT_MAX)ans[i]=-1;
            else ans[i]=ans1;
        }
        return ans;
    }
};
",1420091248
gtushar,gtushar,644,3604,cpp,"class Solution {
public:
    long long s[1001][1001];
    long long p[1001];
    long long ncr[1001][1001];
    long long mod = 1000000007;
    int numberOfWays(int n, int x, int y) {
        long long i, j;
        p[0] = 1;
        for(i = 1; i <= 1000; ++i) {
            p[i] = (p[i - 1] * y) % mod;
        }
        s[0][0] = s[n][n] = 1;
        for(i = 1; i <= n; ++i) s[i][1] = 1;
        for(i = 1; i <= n; ++i) {
            for(j = 2; j <= n; ++j) {
                s[i][j] = ((j * s[i - 1][j]) + s[i - 1][j - 1]) % mod;
            }
        }
        ncr[0][0] = 1;  // C(0, 0) is 1
        for (i = 1; i <= 1000; ++i) {
            ncr[i][0] = 1;  // C(n, 0) is 1 for any n
        }
        for (i = 1; i <= 1000; ++i) {
            for (j = 1; j <= i; ++j) {  // j should go up to i, because C(n, r) is 0 for r > n
                ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1] * j) % mod;
            }
        }
        long long ans = 0;
        for(i = 1; i <= x; ++i) {
            // cout << ""i = "" << i << "" x = "" << x << "" ncr = "" << ncr[x][i] << endl;
            // cout << ""i = "" << i << ' ' << ncr[x][i] << ' ' <<  ((p[i] * s[n][i]) % mod) << ' ' << (((p[i] * s[n][i]) % mod) * ncr[x][i]) << endl;
            ans = (ans + (((p[i] * s[n][i]) % mod) * 1LL * ncr[x][i])) % mod;
        }
        return ans;
    }
};",1420119779
gtushar,gtushar,644,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(int x : nums) {
            if (x == 2) {
                ans.push_back(-1); continue;
            }
            string s = bitset<32>(x).to_string();
            for(int i = s.size() - 1; i >= 0; --i) {
                if (s[i] == '1' && (i == 0 || s[i - 1] == '0')) {
                    s[i] = '0'; break;
                }
            }
            // cout << s << endl;
            ans.push_back(stoi(s, nullptr, 2));
        }
        return ans;
    }
};",1420021879
gtushar,gtushar,644,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
          int n = nums.size();
        vector<int> ans;
        for(int x : nums) {
            if (x == 2) {
                ans.push_back(-1); continue;
            }
            string s = bitset<32>(x).to_string();
            for(int i = s.size() - 1; i >= 0; --i) {
                if (s[i] == '1' && (i == 0 || s[i - 1] == '0')) {
                    s[i] = '0'; break;
                }
            }
            // cout << s << endl;
            ans.push_back(stoi(s, nullptr, 2));
        }
        return ans;
    }
};",1420023887
Santosh Shah,Santosh46j,645,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420116990
Santosh Shah,Santosh46j,645,3604,cpp,"class Solution {
public:
    using ll = long long;
    const ll MOD = 1e9 + 7;

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> combinations(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; ++i) {
            combinations[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; ++i) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> factorials(x + 1, 1);
        for (ll i = 1; i <= x; ++i) {
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + combinations[x][k] * stirling[n][k] % MOD * factorials[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420126421
Santosh Shah,Santosh46j,645,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result(nums.size());

        for (int i = 0; i < nums.size(); i++) {
            bool isFound = false;
            
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    result[i] = x;
                    isFound = true;
                    break;
                }
            }
            if (!isFound) {
                result[i] = -1;
            }
        }

        return result;
    }
};
",1420112080
minamotoorin,minamotoorin,647,3604,cpp,"bool f=true;
long long fact[1001] = {0};
long long inv[1001] = {0};
long long s[1001][1001] = {0};
const int M = 1e9 + 7;

long long p(long long a, long long b) {
    long long r = 1;
    a = a % M;
    while (b > 0) {
        if (b % 2 == 1) {
            r = (r * a) % M;
        }
        a = (a * a) % M;
        b /= 2;
    }
    return r;
}

long long C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv[k] % M * inv[n - k] % M;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(f)
        {
            // f=false;
            fact[0] = 1;
            for(int i = 1 ; i < 1001; i++) fact[i] = (fact[i-1] * i) % M;
            inv[1000] = p(fact[1000], M - 2);
            for (int i = 999; i >= 0; --i) {
                inv[i] = inv[i + 1] * (i + 1) % M;
            }

            s[0][0] = 1;
            for (int i = 1; i < 1001; ++i) {
                s[i][0] = 0;
                for (int j = 1; j <= i; ++j) {
                    s[i][j] = (j * s[i - 1][j] % M + s[i - 1][j - 1]) % M;
                }
            }
        }
        
        long long ans = 0;
        for(int k = 1; k <= max(n, x); k ++)
        {
            long long tmp = C(x,k) * fact[k] % M;
            tmp = tmp * s[n][k] % M;
            tmp = tmp * p(y, k) % M;
            ans += tmp;
            ans %= M;
        }
        return ans;
    }
};",1420094492
minamotoorin,minamotoorin,647,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i:nums){
            if(i&1){
                int tmp = 1;
                for(int j = 0; j < 30;j++)
                {
                    if (i < (1<<j) ) break;
                    if (( (i - (1<<j)) | ((i - (1<<j)) + 1)) == i) 
                       tmp = (1<<j);
                }
                ans.push_back(i - tmp);
            }
            else ans.push_back(-1);
        }

        return ans;
    }
};",1420015152
minamotoorin,minamotoorin,647,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i:nums){
            if(i&1){
                int tmp = 1;
                for(int j = 0; j < 30;j++)
                {
                    if (i < (1<<j) ) break;
                    if (( (i - (1<<j)) | ((i - (1<<j)) + 1)) == i) 
                       tmp = (1<<j);
                }
                ans.push_back(i - tmp);
            }
            else ans.push_back(-1);
        }

        return ans;
    }
};",1420014874
kanishk gupta,kanishkgupta08,648,3604,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef  long long int lli;
typedef long long ll;
typedef  pair<int,int> pii;
typedef  vector<int> vi;
typedef vector<string> vs;
#define PI  3.141592653589
typedef   vector<pii> vpii;
typedef   vector<vi>  vvi;
#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define INF 	1e18
#define MOD 	1000000007
#define MOD1	 998244353
#define INF 	1e18
#define nline 	""\n""
#define pb 		push_back
#define ppb 	pop_back
#define ff 		first
#define ss 		second
#define set_bits __builtin_popcountll
#define all(x) (x).begin(), (x).end()
ll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}
ll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}
void extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}
ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m
vector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}

/*...............................................................
ll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b
ll combination(ll n, ll r, ll m, ll *fact, ll *ifact) {ll val1 = fact[n]; ll val2 = ifact[n - r]; ll val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}
ll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))
void google(int t) {cout << ""Case #"" << t << "": "";}
.....................................................*/
class Solution {
public:
vector<lli> dp;
	vector<vector<lli>>  snr;
    int numberOfWays(int n, int x, int y) {
		snr=vector<vector<lli>>(n+1,vector<lli>(max(x+1,n+1)));
		snr[0][0]=1;
		for(lli i=1;i<=n;i++){
				// cout<<i<<endl;
			for(lli j=1;j<=x;++j){
				snr[i][j]=(snr[i-1][j-1]+j*snr[i-1][j])%MOD;
			}
		}
		lli ans=0;
		dp=vector<lli> (x+1);
		dp[0]=1;
		for(lli i=1;i<=x;i++){
			dp[i]=(i*dp[i-1])%MOD;
		}
		lli prev=0;
		lli c=1;
        for(lli r=1;r<=n && r<=x;r++){
			c=mod_mul(c,r,MOD);

			lli t=mod_mul(snr[n][r],expo(y,r,MOD),MOD);
			lli ncr=mod_div(dp[x],dp[x-r]*dp[r],MOD);
			// cout<<ncr<<' ';
			t=mod_mul(t,ncr,MOD);
			t=mod_mul(t,c,MOD);

			ans+=t;
			// cout<<t<<' ';
			ans%=MOD;
		}
		return ans;
    }
};
// int main(){
// 	// fastio();
// 	Solution s;
// 	cout<<s.numberOfWays(1,2,3)<<endl;
// 	cout<<s.numberOfWays(5,2,1)<<nline;
// 	cout<<s.numberOfWays(3,3,4)<<nline;
// }",1420120544
kanishk gupta,kanishkgupta08,648,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
		vector<int> ans(n,-1);
		for(int i=0;i<n;i++){
			for(int j=0;j<nums[i];j++){
                //  t=j || j+1
				if((j | (j+1))==nums[i]){
					ans[i]=j;
					break;
				}
			}
		}
        return ans;
    }
};",1420007334
kanishk gupta,kanishkgupta08,648,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
		vector<int> ans(n,-1);
		for(int i=0;i<n;i++){
			if(nums[i]==2) continue;
			int j=0;
			while(j<30){
				if(((1<<j)&nums[i])==0) break;
				++j;
			}
			--j;
			ans[i]=nums[i]-(1<<j);
		}
		return ans;
    }
};",1420028195
Mohit Kukreja,mohitkukreja,649,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;

    int numberOfWays(int n, int totl, int mult) {
        
         vector< vector<int>> vec(n + 1,  vector<int>(totl + 1, 0));
        vector<int> fact(totl + 1, 1);
         vector< vector<int>>  arr(totl + 1,  vector<int>(totl + 1, 0));
        vec[0][0] = 1;
        long long tot = 0;
        for (int i=0;i<=totl; i++) {
             arr[i][0] = 1;
            for (int j=1;j<=i;j++) 
            {
                 arr[i][j] = ( arr[i - 1][j - 1] +  arr[i - 1][j]) % mod;
            }
        } 
        for (int i=1;i<=n;i++) 
        {
            for (int j=1;j<=totl;j++) 
            {
                vec[i][j] = (1LL * j * vec[i - 1][j] + vec[i - 1][j - 1]) % mod;
            }
        }
        for (int i = 1; i <= totl; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % mod;
        }
        for (int i = 1; i <= totl; i++) {
            long long poww = 1;
            for (int j = 0; j < i; ++j) {
                poww = (poww * mult) % mod;
            }
            tot = (tot + (1LL *  arr[totl][i] * vec[n][i] % mod * fact[i] % mod * poww % mod)) % mod;
        }
        return tot;
    }
};",1420121319
Mohit Kukreja,mohitkukreja,649,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i=0;i<nums.size();++i) 
        {
            int temp = nums[i];
            bool temp1 = false;
            for (int j=0;j<=temp;++j) 
            { 
                if ((j | (j+1))==temp) 
                {
                    ans[i] = j;
                    temp1=true;
                    break;
                }
            }
        }
        return ans;
    }
};
",1419997126
Mohit Kukreja,mohitkukreja,649,3611,cpp,"class Solution {
public:
     vector<int> minBitwiseArray( vector<int>& nums) {
        int n = nums.size();
         vector<int> ans(n,-1);
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            int mn=INT_MAX;
            bool temp = false;
            for (int j = 0; j <= 30; j++) 
            {
                if (((x >> j) & 1) == 1) 
                {
                    int res = x & ~(1 << j);
                    if (res >= 0)
                    {
                    if ((res | (res + 1)) == x) 
                    {
                        if (res <  mn) 
                        {
                            mn = min(mn,res);
                            temp = true;
                        }
                    }
                    }
                }
            }
            
            if (temp) 
            {
                ans[i] =  mn;
            }
        }
        
        return ans;
    }
};",1420059216
HARSHKUMAR,HARSHKUMAR,650,3604,cpp,"#define ll int64_t

class Solution {
    static const int N = 1e4, M = 1e9 + 7;
    ll f[N] = {1}, inf[N] = {1};
    ll p(ll a, ll b = M - 2, ll m = M)
    {
        ll r = 1;
        while (b)
        {
            if (b % 2)
                r = r * a % m;
            a = a * a % m;
            b /= 2;
        }
        return r;
    }
    ll C(int n, int r)
    {
        if(n < r)
            return 0;
        return f[n] * inf[r] % M * inf[n - r] % M;
    }
public:
    int numberOfWays(int n, int x, int y) {
        for(int i = 1; i <= x; i++)
            f[i] = f[i - 1] * i % M, inf[i] = p(f[i]);
        vector<vector<ll>> dp(n + 5, vector<ll>(x + 5));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= x; j++)
                dp[i][j] = ((dp[i - 1][j] + dp[i - 1][j - 1]) % M) * j % M;
        int ans = 0;
        for(int i = 1; i <= x; i++)
            ans += C(x, i) * dp[n][i] % M * p(y, i) % M, ans %= M;
        return ans;
    }
};
",1420121343
HARSHKUMAR,HARSHKUMAR,650,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &e: nums)
        {
            if(e == 2)
            {
                e = -1;
                continue;
            }
            for(int i = 0; i < 31; i++)
                if(!(e & (1 << i)))
                {
                    e ^= ((1 << (i - 1)));
                    break;
                }
        }
        return nums;
    }
};",1420024674
HARSHKUMAR,HARSHKUMAR,650,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &e: nums)
        {
            if(e == 2)
            {
                e = -1;
                continue;
            }
            for(int i = 0; i < 31; i++)
                if(!(e & (1 << i)))
                {
                    e ^= ((1 << (i - 1)));
                    break;
                }
        }
        return nums;
    }
};",1420024048
Pavlo Soroka,Chasey,652,3604,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    ll denom = 1e9+7;
    ll powmod(ll a,ll b) {ll res=1;a%=denom; for(;b;b>>=1){if(b&1)res=res*a%denom;a=a*a%denom;}return res;}
    vector<ll> fact, invfact;

    void buildfactmod(ll n) {
        vector<ll> f(n+1, 1);
        FOR(i, 2, n+1) f[i] = (f[i-1]*i)%denom;
        fact = f;
    }
    
    void buildinvfactmod(ll n) {
        vector<ll> f(n+1, 1);
        f[n] = powmod(fact[n], denom-2);
        for (ll i = n-1; i >= 0; i--) f[i] = (f[i+1]*(i+1))%denom;
        invfact = f;
    }
    
    ll cnk(ll n, ll k) {
        ll res = fact[n]*invfact[n-k];
        res %= denom;
        res *= invfact[k];
        res %= denom;
        return res;
    }
    int numberOfWays(int n, int x, int y) {
        buildfactmod(n+x+1);
        buildinvfactmod(n+x+1);
        ll res = 0;
        vector<ll> prev(x+1, 0);
        FOR(i, 1, x+1) {
            if (i > x || i > n) break;
            ll a = powmod(i, n); a %= denom;
            FOR(j, 1, i) {
                a -= cnk(i, j) * prev[j]; a %= denom; if (a < 0) a+= denom;
            }

            prev[i] = a;

            a *= cnk(x, i); a %= denom;
            a *= powmod(y, i);  a %= denom;
            res += a; res %= denom;
        }
        return res;
    }
};",1420121590
Pavlo Soroka,Chasey,652,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        // 1111
        // 0111
        vector<int> res;
        for (auto x: nums) {
            if (x == 2) { res.push_back(-1); continue; }
            int curr = x;
            vector<int> v;
            while (x > 0) { v.push_back(x%2); x /= 2; }
            int j = 0; while (j < v.size() && v[j] == 1) j++;
            v[j-1] = 0;
            int sub = 0; for (int j = 0; j < v.size(); j++) if (v[j] == 1) sub += (1<<j);
            res.push_back(min(sub, curr-1));
        }
        return res;
        // 11001011111
        // 11001001111
    }
};",1420007049
Pavlo Soroka,Chasey,652,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        // 1111
        // 0111
        vector<int> res;
        for (auto x: nums) {
            if (x == 2) { res.push_back(-1); continue; }
            int curr = x;
            vector<int> v;
            while (x > 0) { v.push_back(x%2); x /= 2; }
            int j = 0; while (j < v.size() && v[j] == 1) j++;
            v[j-1] = 0;
            int sub = 0; for (int j = 0; j < v.size(); j++) if (v[j] == 1) sub += (1<<j);
            res.push_back(min(sub, curr-1));
        }
        return res;
        // 11001011111
        // 11001001111
    }
};",1420006562
Iftikhar Ahmad,Iftik786,653,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));

        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;

            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {

            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> factorial(x + 1, 1);

        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }

        long long total_ways = 0;

        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420115544
Iftikhar Ahmad,Iftik786,653,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for(int i=0; i<nums.size(); i++){
            for(int j=0; j<nums[i]; j++){
                if((j | (j+1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
                
            }
            
        }

        return ans;
    }
};",1420026022
Iftikhar Ahmad,Iftik786,653,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for (int i = 0; i < nums.size(); ++i) {
            bool f = false;
            int cur = nums[i];
            int mini = INT_MAX;
            
            for (int bit = 0; bit <= 30; ++bit) {
                if (((cur >> bit) & 1) == 1) {

                    int cand = cur & ~(1 << bit);
                    
                    if (cand < 0)
                        continue;
                    
                    if ((cand | (cand + 1)) == cur){

                        if (cand < mini){

                            mini = cand;
                            f = true;
                        }
                    }
                }
            }
            
            if(f){
                ans[i] = mini;
            }else{
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420111143
Mayank_Gupta,mayanees,654,3604,java,"class Solution {
    static final int MOD = (int) 1e9 + 7;
    public long[][] combi(int size) {
        long[][] C = new long[size + 1][size + 1];
        for (int i = 0; i <= size; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }
    public long[][] parti(int n, int x) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }
    public long[] facto(int size) {
        long[] fact = new long[size + 1];
        fact[0] = 1;
        for (int i = 1; i <= size; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }
    public int numberOfWays(int n, int x, int y) {
        long[][] C = combi(x);
        long[][] S = parti(n, x);
        long[] fact = facto(x);
        long result = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * fact[k]) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }
        return (int) result;
    }
}
",1420102879
Mayank_Gupta,mayanees,654,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int x = nums.get(i);
            boolean flag = false;            
            for (int j = 0; j < x; j++) {
                if ((j | (j + 1)) == x) {
                    ans[i] = j;
                    flag = true;
                    break;
                }
            }            
            if (!flag) {
                ans[i] = -1;
            }
        }
        return ans;
    }
}
",1420016080
Mayank_Gupta,mayanees,654,3611,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] result = new int[n];

        for (int i = 0; i < n; i++) {
            int c = nums.get(i);
            int d = Integer.MAX_VALUE;
            boolean e = false;

            for (int j = 0; j <= 30; j++) {
                if (((c >> j) & 1) == 1) {
                    int f = c & ~(1 << j);
                    if (f < 0) continue;
                    if ((f | (f + 1)) == c) {
                        if (f < d) {
                            d = f;
                            e = true;
                        }
                    }
                }
            }

            result[i] = e ? d : -1;
        }

        return result;
    }
}
",1420051833
Josh,Barracuda47,655,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        answer = 0
        dp = [[0] * (n + 1) for _ in range(x + 1)]
        dp[1] = [1] * (n + 1)
        dp[1][0] = 0
        for i in range(2, x + 1):
            for j in range(1, n + 1):
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) * i % 1000000007


        for i in range(1, min(n, x) + 1):
            answer += dp[i][n] * math.comb(x, i) * (y ** i)
            answer %= 1000000007
        return answer % 1000000007
    
    @lru_cache(maxsize=2000)
    def div(self, n, x):
        if n == 0 or x == 0:
            return 0
        if x == 1:
            return 1
        return (self.div(n - 1, x) * x + self.div(n - 1, x - 1)*x) % 1000000007
            

",1420122372
Josh,Barracuda47,655,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for n in nums:
            if n == 2:
                answer.append(-1)
            else:
                p = n
                stack = 0
                res = 0
                while p % 2 != 0:
                    p = p // 2
                    res = 2 * res + 1
                    stack += 1
                answer.append(p * (2 ** stack) + res // 2)
        return answer

        ",1420020132
Josh,Barracuda47,655,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for n in nums:
            if n == 2:
                answer.append(-1)
            else:
                p = n
                stack = 0
                res = 0
                while p % 2 != 0:
                    p = p // 2
                    res = 2 * res + 1
                    stack += 1
                answer.append(p * (2 ** stack) + res // 2)
        return answer

         ",1420020873
Rishita,Rishita_maheshwari,657,3604,cpp,"class Solution {
public:
    
typedef long long ll;

const int MOD = 1e9 + 7;

vector<vector<int>> compute_stirling(int n, int k_max) {
    vector<vector<int>> S(n + 1, vector<int>(k_max + 1, 0));
    S[0][0] = 1;
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= k_max; ++j){
            S[i][j] = (S[i-1][j-1] + (ll)j * S[i-1][j]) % MOD;
        }
    }
    return S;
}
vector<long long> compute_factorials(int max_n){
    vector<long long> fact(max_n + 1, 1);
    for(int i = 1; i <= max_n; ++i){
        fact[i] = (fact[i-1] * i) % MOD;
    }
    return fact;
}
vector<long long> compute_inv_factorials(int max_n, const vector<long long>& fact){
    vector<long long> inv_fact(max_n + 1, 1);
    inv_fact[max_n] = 1;
    ll inv = 1;
    inv_fact[max_n] = 1;
    inv_fact[max_n] = 1;
    auto power = [&](ll a, ll b) -> ll {
        ll res = 1;
        a %= MOD;
        while(b > 0){
            if(b & 1){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    };
    inv_fact[max_n] = power(fact[max_n], MOD - 2);
    for(int i = max_n -1; i >=0; --i){
        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD;
    }
    return inv_fact;
}
vector<long long> compute_combinations(int x, int k_max, const vector<long long>& fact, const vector<long long>& inv_fact){
    vector<long long> C(k_max + 1, 0);
    for(int k = 0; k <= k_max; ++k){
        if(k > x){
            C[k] = 0;
        }
        else{
            C[k] = (fact[x] * inv_fact[k] % MOD) * inv_fact[x - k] % MOD;
        }
    }
    return C;
}

ll fast_pow(ll a, ll b){
    ll res = 1;
    a %= MOD;
    while(b > 0){
        if(b & 1){
            res = res * a % MOD;
        }
        a = a * a % MOD;
        b >>=1;
    }
    return res;
}
    int numberOfWays(int n, int x, int y) {
         int k_max = min(x, n);
    vector<vector<int>> S = compute_stirling(n, k_max);
    
    int max_fact = max(x, n);
    vector<long long> fact = compute_factorials(max_fact);
    
    vector<long long> inv_fact = compute_inv_factorials(max_fact, fact);
    
    vector<long long> C = compute_combinations(x, k_max, fact, inv_fact);
    
    ll result = 0;
    for(int k =1; k <= k_max; ++k){
        ll term = C[k];
        term = (term * fact[k]) % MOD;
        term = (term * S[n][k]) % MOD;
        ll y_power = fast_pow(y, k);
        term = (term * y_power) % MOD;
        result = (result + term) % MOD;
    }
    return result;
    }
};",1420122567
Rishita,Rishita_maheshwari,657,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num:nums){
             if(num==2){
                ans.push_back(-1);
             }
             else{
                for(int i=0;i<=num;i++){
                    if((i|i+1)==num){
                    ans.push_back(i);
                    break;
                    }
                }
             }
        }
        return ans;
    }
};",1420006817
Rishita,Rishita_maheshwari,657,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans; 

    for (auto p : nums) {
        vector<int> valid_x; 

        for (int k = 0; k < 32; ++k) {
            if (p & (1 << k)) {
                int x = p & ~(1 << k);

                if ((x | (x + 1)) == p) {
                    valid_x.push_back(x);
                }
            }
        }

        if ((p & (p + 1)) == 0) {
            int x = p >> 1; 
            if ((x | (x + 1)) == p) {
                valid_x.push_back(x);
            }
        }

        if (!valid_x.empty()) {
            ans.push_back(*min_element(valid_x.begin(), valid_x.end()));
        } else {
            ans.push_back(-1);
        }
    }

    return ans;    
    }
};",1420095551
jackey,jackeyhua,659,3604,cpp,"class Solution {
public:
    using ll = long long;
    int numberOfWays(int n, int x, int y) {
        constexpr int MOD = 1e9 + 7;
        int s = max(n, x);
        vector<vector<ll>> C(s + 1, vector<ll>(s + 1, 0));
        vector<vector<ll>> P(s + 1, vector<ll>(s + 1, 0));
        C[0][0] = 1;
        for (int i = 1; i <= s; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (0LL + C[i - 1][j] + C[i - 1][j - 1]) % MOD;
            }
        }

        P[0][0] = 1;
        for (int i = 1; i <= s; ++i) {
            for (int j = 1; j <= i; ++j) {
                P[i][j] = (0LL + (1LL * j * P[i - 1][j] % MOD) + P[i - 1][j - 1]) % MOD;
            }
        }

        ll ans = 0;
        ll fac = 1;
        ll base = y;
        for (int i = 1; i <= min(x, n); ++i) {
            ll t1 = (C[x][i] * P[n][i]) % MOD;
            t1 = (fac * t1) % MOD;
            
            ans = (ans + (t1 * base) % MOD) % MOD;
            fac = (fac * (i + 1)) % MOD;
            base = (base * y) % MOD;
        }
        return static_cast<int>(ans);
    }
};",1420103793
jackey,jackeyhua,659,3605,cpp,"class Solution {
public:
    int helper(int x) {
        if ((x & 1) == 0) return -1;
        int cnt = 0;
        int cur = x;
        while (cur & 1) {
            ++cnt;
            cur >>= 1;
        }
        return (cur << cnt) + (1 << (cnt - 1)) - 1;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto& i : nums) ans.push_back(helper(i));
        return ans;
    }
};",1420010239
jackey,jackeyhua,659,3611,cpp,"class Solution {
public:
    int helper(int x) {
        if ((x & 1) == 0) return -1;
        int cnt = 0;
        int cur = x;
        while (cur & 1) {
            ++cnt;
            cur >>= 1;
        }
        return (cur << cnt) + (1 << (cnt - 1)) - 1;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto& i : nums) ans.push_back(helper(i));
        return ans;
    }
};",1420010504
SAHIL WALUNJ,user2636BW,660,3604,cpp,"class Solution {
public:
    static const int MOD_VALUE = 1e9 + 7;

    int numberOfWays(int performersCount, int stagesCount, int maxScore) {
        vector<vector<int>> combinations(stagesCount + 1, vector<int>(stagesCount + 1, 0));
        for (int i = 0; i <= stagesCount; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD_VALUE;
            }
        }

        vector<vector<int>> stirlingNumbers(performersCount + 1, vector<int>(stagesCount + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= performersCount; ++i) {
            for (int j = 1; j <= stagesCount; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD_VALUE;
            }
        }

        vector<int> factorials(stagesCount + 1, 1);
        for (int i = 1; i <= stagesCount; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD_VALUE;
        }

        long long totalCombinations = 0;
        for (int k = 1; k <= stagesCount; ++k) {
            long long scorePower = 1;
            for (int i = 0; i < k; ++i) {
                scorePower = (scorePower * maxScore) % MOD_VALUE;
            }
            totalCombinations = (totalCombinations + (1LL * combinations[stagesCount][k] * stirlingNumbers[performersCount][k] % MOD_VALUE * factorials[k] % MOD_VALUE * scorePower % MOD_VALUE)) % MOD_VALUE;
        }
        return totalCombinations;
    }
};
",1420113272
SAHIL WALUNJ,user2636BW,660,3605,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            bool found = false;
            for (int j = 0; j < num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
            if (!found) ans[i] = -1;
        }
        return ans;
    }
};",1419993833
SAHIL WALUNJ,user2636BW,660,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputArray) {
        int size = inputArray.size();
        vector<int> result(size);
       
        for (int index = 0; index < size; index++) {
            int currentNum = inputArray[index];
            int minResult = INT_MAX;
            bool found = false;
         
            for (int bit = 0; bit <= 30; bit++) {
                if (((currentNum >> bit) & 1) == 1) {
                    int modifiedNum = currentNum & ~(1 << bit);
                    if (modifiedNum < 0) continue;
                    if ((modifiedNum | (modifiedNum + 1)) == currentNum) {
                        if (modifiedNum < minResult) {
                            minResult = modifiedNum;
                            found = true;
                        }
                    }
                }
            }
           
            if (found) {
                result[index] = minResult;
            } else {
                result[index] = -1;
            }
        }
       
        return result;
    }
};
",1420116928
karush1fa,karush1fa,662,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0
        maxStages = min(n, x)
        dp = [[0] * (maxStages+1) for _ in range(n+1)]
        # show2D(dp)
        for i in range(1, n+1):
            dp[i][1] = 1
        # show2D(dp)

        for j in range(2, maxStages + 1):
            dp[j][j] = 1
            for i in range(j+1, n+1):
                dp[i][j] = dp[i-1][j-1] + j * dp[i-1][j]
        # show2D(dp)       

        mod = 10**9 + 7
        for unempty in range(1, maxStages+1):
            a1 = math.perm(x, unempty)
            a2 = y ** unempty
            ans += (dp[n][unempty] * a1 * a2) % mod
        return ans % mod",1420123291
karush1fa,karush1fa,662,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for j in range(len(nums)):
            for i in range(nums[j]+1):
                if i | (i+1) == nums[j]:
                    ans[j] = i
                    break
        return ans
            ",1420020771
karush1fa,karush1fa,662,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            # print(bin(n))
            if n == 2:
                ans.append(-1)
                continue
            k = n.bit_length()
            i = 0
            while (1 << i) & n:
                i += 1
            # print(i-1)
            i -= 1
            a = n - (1 << i)
            ans.append(a)
        return ans",1420042778
Md Taha,mdtaha13,665,3487,cpp,"class Solution {
public:
     int maxRemovals(const string& s, const string& p, const vector<int>& t) {
        return calc(s, p, t);
    }

private:
    int calc(const string& s, const string& p, const vector<int>& t) {
        int n = s.size();
        int m = p.size();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;

        vector<bool> isT(n, false);
        for (int idx : t) {
            isT[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isT[i] ? 1 : 0));
                }
            }
        }

        return t.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420088090
Md Taha,mdtaha13,665,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        auto c = comb(x);
        auto s = stir(n, x);
        auto f = fact(x);
        
        return total(n, x, y, c, s, f);
    }

private:
    vector<vector<int>> comb(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> stir(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }
        return s;
    }

    vector<int> fact(int x) {
        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        return f;
    }

    int total(int n, int x, int y, const vector<vector<int>>& c, const vector<vector<int>>& s, const vector<int>& f) {
        long long sum = 0;
        for (int k = 1; k <= x; ++k) {
            long long p = 1;
            for (int i = 0; i < k; ++i) {
                p = (p * y) % MOD;
            }
            sum = (sum + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * p % MOD)) % MOD;
        }
        return sum;
    }
};
",1420123814
Md Taha,mdtaha13,665,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i = 0; i < n; i++) {
            bool ok = false;
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    res[i] = x;
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                res[i] = -1;
            }
        }
        return res;
    }
};",1420003923
ratzfatz,ratzfatz,666,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        dp = [[0] * x for _ in range(n)] # dp[i] = stages 1.. x
        for i in range(n):
            dp[i][0] = x  # all performers at same stage
        for num_p in range(1, n): # next performer, total num_p + 1
            for num_s in range(1, min(num_p+1, x)):
                #print(num_s, num_p)
                dp[num_p][num_s] += dp[num_p - 1][num_s] * (num_s + 1)
                dp[num_p][num_s] += dp[num_p - 1][num_s - 1] * (x - num_s)

        #for i in range(n):
        #    print(dp[i])
        result = 0
        mod = 10**9 + 7

        for i in range(x):
            result += (dp[-1][i] * y ** (i + 1)) % mod

        return result % mod



        ",1420118382
ratzfatz,ratzfatz,666,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            found = False
            for i in range(n):
                if i | (i+1) == n:
                    found = True
                    break
            if found:
                ans.append(i)
            else:
                ans.append(-1)
                
        return ans",1420001261
ratzfatz,ratzfatz,666,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                bits = list(bin(n)[2:])
                for i in range(len(bits)):
                    if bits[i] == '1':
                        b = bits.copy()
                        b[i] = '0'
                        b = ''.join(b)
                        b = int(b, 2)
                        if b | (b + 1) == n:
                            ans.append(b)
                            break




        return ans",1420036168
jatin,sangaljatin,667,3604,cpp,"#include <iostream>
#include <vector>
#include<bits/stdc++.h>
class Solution {
private:
    static const int MOD = 1000000007;

public:
  void foundd(){
    int a, b;
    a=10;
    b=100;
    a+=b;
  }
    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<long long>> comb(x + 1, std::vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        string str=""no"";
        std::vector<std::vector<long long>> stirling(n + 1, std::vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        foundd();
        int commander=0;
        long long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

  
};





",1420112047
jatin,sangaljatin,667,3605,cpp,"class Solution {
public:
    vector<int> solve(vector<int>& nums,int n){
        vector<int> ans(n, -1);
        
        for (int i = 0; i < n; ++i) {
            for (int x = 1; x <= nums[i]; ++x) {
                if ((x+1 | x) == nums[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }
        
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        return solve(nums,n);
    }
};
",1420002431
jatin,sangaljatin,667,3611,cpp,"class Solution {
public:
  vector<int> solve(vector<int>&nums,int n){
vector<int> res(n, -1);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int min_val = numeric_limits<int>::max(); // Use max to represent infinity
            bool found = false;
            
            for (int bit = 0; bit < 31; ++bit) {
                if ((num >> bit) & 1) { // Check if the bit is set
                    int cand = num & (~(1 << bit)); // Turn off the current bit
                    
                    if (cand < 0) {
                        continue; // Ignore if cand is negative (though in this context, it won't be)
                    }
                    
                    // Check if cand with next bit turned on matches num
                    if ((cand | (cand + 1)) == num) {
                        if (cand < min_val) {
                            min_val = cand; // Update minimum value found
                            found = true; // Set found to true
                        }
                    }
                }
            }
            res[i] = found ? min_val : -1; // Store result
        }
        
        return res; // Return the final result
  }
    vector<int> minBitwiseArray(vector<int>& nums) {
     int n=nums.size();
     return solve(nums,n);    
    }
};
",1420089070
TEJA RAM,tejaramjanee,668,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
int f(int n, int p, int m) {
        vector<int> temp(p + 1, 1);
        int i = 1;
        
         while (i <= p) {
            temp[i] = (1LL * temp[i - 1] * i) % mod;
            i++;
        }
        


        vector<vector<int>> mat2(n + 1, vector<int>(p + 1, 0));
        mat2[0][0] = 1;
        i = 1;

       
        while (i <= n) {
            int j = 1;
            while (j <= p) {
                mat2[i][j] = (1LL * j * mat2[i - 1][j] + mat2[i - 1][j - 1]) % mod;
                j++;
            }
            i++;
        }

        vector<vector<int>> mat(p + 1, vector<int>(p + 1, 0));
        i = 0;
        












       
        while (i <= p) {
            mat[i][0] = 1;
            int j = 1;
            while (j <= i) {
                mat[i][j] = (mat[i - 1][j - 1] + mat[i - 1][j]) % mod;
                j++;
            }
            i++;
        }

        long long ans = 0;
        int k = 1;

            













        while (k <= p) {
            long long t = 1;
            int count = 0;

         
            while (count < k) {
                t = (t * m) % mod;
                count++;
            }

            ans = (ans + (1LL * mat[p][k] * mat2[n][k] % mod * temp[k] % mod * t % mod)) % mod;
            k++;
        }

        return ans;
    }
    int numberOfWays(int n, int p, int m) {
        for(int i=0;i<0;i++){
            p++;
        }
         for(int i=0;i<0;i++){
            p++;
        }












            return f(n,p,m);
    }


};",1420124755
TEJA RAM,tejaramjanee,668,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>res(n,-1);
        int i=0;
        for( i=0;i<0;i++){
            n++;
        }
        while(i<n){
            int j=0;
           while(j<=nums[i]){
                if(nums[i]==((j)|(j+1))){
                    res[i]=j;
                    break;
                }
                j++;
            }
            i++;
        }
        return res;
    }
};",1420049950
TEJA RAM,tejaramjanee,668,3611,cpp,"class Solution {
public:
void f(vector<int>&ans,int k,int i,vector<int>arr){
     for (int j = 0; j <= 31; j++) {
                if (((k >> j) & 1) == 1) {
                    
                    int temp = k & ~(1 << j);
                    
                    
                    if (temp < 0) continue;
                    
                      if ((temp | (temp + 1)) == k) {
                        ans[i]=min(ans[i],temp);
                    }
                }
            }
}
// bool f(int mid,int k){
//     if((mid|(mid+1))>=k){
//         return 1;
//     }
//     else{
//         return 0;
//     }
// }
    vector<int> minBitwiseArray(vector<int>& arr) {
       
          int n = arr.size();
        vector<int> ans(n,INT_MAX);
        int i=0;
       while(i<n) {
            int k = arr[i];
            int minimalAns = INT_MIN;
           
            f(ans,k,i,arr);
           
           
            if(ans[i]==INT_MAX){
                ans[i]=-1;
            }
            i++;
        }
        
        return ans;

    }
};",1420109269
akash_56,akash_56,669,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> dp(n+1,vector<int>(x+1,0));
        int mod=1e9+7;
        dp[1][1]=x;
        for(int i=2;i<=n;++i)
        {
            for(int j=1;j<=min(x,i);++j)
            {
                int s1=(j*1ll*dp[i-1][j])%mod;
                int s2=((x-j+1)*1ll*dp[i-1][j-1])%mod;
                dp[i][j]=(s1+0ll+s2)%mod;
            }
        }
        int mul=y;
        int ans=0;
        for(int j=1;j<=x;++j)
        {
            int ways=(dp[n][j]*1ll*mul)%mod;
            ans=(ans+ways)%mod;
            mul=(mul*1ll*y)%mod;
        }
        return ans;
    }
};",1420112408
akash_56,akash_56,669,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;++i)
        {
            int x=nums[i];
            int flag=0;
            if(x==2)
            {
                ans.push_back(-1);
                continue;
            }
            for(int j=0;j<=1000;++j)
            {
                int res=j|(j+1);
                if(res==x)
                {
                    ans.push_back(j);
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420013285
akash_56,akash_56,669,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;++i)
        {
            int x=nums[i];
            if(x==2)
            {
                ans.push_back(-1);
                continue;
            }
            int mask=0;
            for(int j=0;j<30;++j)
            {
                int b1=(1<<j)&x;
                if(b1==0)
                {
                    mask=1<<(j-1);
                    break;
                }
            }
            int res=x^mask;
            ans.push_back(res);
        }
        return ans;
    }
};",1420033675
Divyanshu_01,Divyanshu_01,670,3604,cpp,"class Solution {
public:
    const int MOD = 1'000'000'007;

    long long modPow(long long a, long long b, long long mod_val) {
        long long res = 1;
        a %= mod_val;
        while (b > 0) {
            if (b & 1) {
                res = res * a % mod_val;
            }
            a = a * a % mod_val;
            b >>= 1;
        }
        return res;
    }

    void computeFactorials(int max_val, vector<long long> &fact, vector<long long> &inv_fact) {
        fact.resize(max_val + 1, 1);
        for(int i = 1; i <= max_val; ++i) {
            fact[i] = fact[i-1] * i % MOD;
        }
        inv_fact.resize(max_val + 1, 1);
        inv_fact[max_val] = modPow(fact[max_val], MOD - 2, MOD);
        for(int i = max_val -1; i >=0; --i) {
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
    }

    long long permutation(int x, int k, const vector<long long> &fact, const vector<long long> &inv_fact) {
        if(x < k) return 0;
        return fact[x] * inv_fact[x - k] % MOD;
    }

    int numberOfWays(int n, int x, int y) {
        int max_val = max({n, x, y});
        vector<long long> fact, inv_fact;
        computeFactorials(max_val, fact, inv_fact);

        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));
        dp[0][0] = 1;

        for(int i = 1; i <= n; ++i){
            for(int k = 1; k <= x; ++k){
                dp[i][k] = (dp[i-1][k-1] + dp[i-1][k] * k) % MOD;
            }
        }

        long long result = 0;
        for(int k = 1; k <= min(n, x); ++k){
            long long P_xk = permutation(x, k, fact, inv_fact);
            long long S_nk = dp[n][k];
            long long y_pow_k = modPow(y, k, MOD);
            result = (result + (P_xk * S_nk) % MOD * y_pow_k % MOD) % MOD;
        }

        return (int)result;
    }
};
",1420125093
Divyanshu_01,Divyanshu_01,670,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        
        for (int i = 0; i < nums.size(); i++){
            int num = nums[i];
            for(int x = 0; x <= num; x++){
                if((x | (x + 1)) == num){
                    ans[i] = x;  
                    break;      
                }
            }
        }
        
        return ans;
    }
};
",1420002093
Divyanshu_01,Divyanshu_01,670,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for(int i=0; i<n; i++){
            int num = nums[i];
            int min_x = -1;
        
            for(int b = 0; b < 32; b++) {
                if(num & (1 << b)) {
                    int x = num & ~(1 << b);
                    
                    if((x | (x + 1)) == num ){
                        if(min_x == -1 || x < min_x){
                            min_x = x;
                        }
                    }
                }
            }
            
            ans[i] = min_x;
        }
        
        return ans;
    }
};
",1420117746
pulkit singhal,pulkit_singhall,671,3604,cpp,"#define ll long long
class Solution {
    private:
    const int mod = 1e9+7;
    ll binpow(ll a, ll b) {
        a %= mod;
        ll res = 1;
        while (b > 0) {
            if (b & 1)
                res = (res * a) % mod;
            a = (a * a) % mod;
            b >>= 1;
        }
        return res%mod;
    }
public:
    int numberOfWays(int n, int x, int y) {
        ll ans = 0;
        ll cnt_stage = x;
        ll tot_x = 1;
        vector<vector<ll> > dp(
        n + 1, vector<ll>(x + 1, 0));
 
    for (int i = 0; i <= min(n,x); i++) {
        dp[i][i] = 1;
    }
    for (int i = 1; i <= n; i++) {
        dp[i][1] = 1;
    }
 
    for (int i = 2; i <= n; i++) {
        for (int j = 2; j <= x; j++) {
            dp[i][j]
                = dp[i - 1][j - 1] + j * dp[i-1][j];
            dp[i][j]%=mod;
        }
    }
        // 
        // cout<<dp[3][2];
        for(int i=1; i<=x; i++){
            ll score = binpow(y,i);
            tot_x = (tot_x*cnt_stage)%mod;
            cnt_stage--;
            ll group = 1ll*dp[n][i];
            ll res = (score*tot_x)%mod;
            res*=group;
            res%=mod;
            ans+=res;
            ans%=mod;
        }
        return ans%mod;
    }
};",1420125360
pulkit singhal,pulkit_singhall,671,3605,cpp,"#define ll long long
#define pb push_back
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0; i<n; i++){
            int j = nums[i];
            if(j!=2){
                ll cnt = 0;
            while(j%2==1){
                cnt++;
                j/=2;
            }
            ans[i] = (nums[i]-pow(2,cnt-1));
            }
        }
        return ans;
    }
};",1420021918
pulkit singhal,pulkit_singhall,671,3611,cpp,"#define ll long long
#define pb push_back
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0; i<n; i++){
            int j = nums[i];
            if(j!=2){
                ll cnt = 0;
            while(j%2==1){
                cnt++;
                j/=2;
            }
            ans[i] = (nums[i]-pow(2,cnt-1));
            }
        }
        return ans;
    }
};",1420020468
Bhisham Balhara,bhisu__786,672,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420123554
Bhisham Balhara,bhisu__786,672,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
          
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                   
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420124461
Bhisham Balhara,bhisu__786,672,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
          
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                   
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420125748
Smruti ,smruti_06,673,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();  // Length of source string
        int m = pattern.length();  // Length of pattern string

        // Initialize the dp array
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;  // Base case: no removals needed for empty pattern

        // Create a boolean array to mark target indices
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to calculate the minimum removals
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum number of removable characters
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420119442
Smruti ,smruti_06,673,3604,cpp,"
 

class Solution {

public:

    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {

        

        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));

        for (int i = 0; i <= x; ++i) {

            comb[i][0] = 1;

            for (int j = 1; j <= i; ++j) {

                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;

            }

        } 

        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));

        stirling[0][0] = 1;

        for (int i = 1; i <= n; ++i) {

            for (int j = 1; j <= x; ++j) {

                stirling[i][j] = (1LL * j * stirling[i -1][j] + stirling[i -1][j -1]) % MOD;

            }

        }

        std::vector<int> factorial(x + 1, 1);

        for (int i = 1; i <= x; ++i) {

            factorial[i] = (1LL * factorial[i -1] * i) % MOD;

        }

        long long total_ways = 0;

        for (int k = 1; k <= x; ++k) {

            long long y_pow = 1;

            for (int i = 0; i < k; ++i) {

                y_pow = (y_pow * y) % MOD;

            }

            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;

        }

        return total_ways;

    }

};",1420117236
Smruti ,smruti_06,673,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  # Initialize ans array with -1
    
    # For each index i
        for i in range(n):
            num = nums[i]
            # Try finding the smallest ans[i] such that ans[i] OR (ans[i] + 1) == nums[i]
            for candidate in range(num):
                if (candidate | (candidate + 1)) == num:
                    ans[i] = candidate
                    break  # Found the minimum ans[i], move to next index
                    
        return ans
        ",1420005456
owen c,salesman,674,3604,cpp,"class Solution {
public:
    const int MOD = 1000000007;

    void skibidi(int maxN, vector<long long>& ariel, vector<long long>& invariel) {
        ariel[0] = 1;
        for (int i = 1; i <= maxN; ++i) {
            ariel[i] = (ariel[i - 1] * i) % MOD;
        }

        invariel[maxN] = modInverse(ariel[maxN]);
        for (int i = maxN - 1; i >= 0; --i) {
            invariel[i] = (invariel[i + 1] * (i + 1)) % MOD; 
        }
    }

    long long binomialCoefficient(int n, int r, const vector<long long>& ariel, const vector<long long>& invariel) {
        if (r > n || r < 0) return 0;
        return (ariel[n] * invariel[r] % MOD * invariel[n - r] % MOD) % MOD;
    }

    long long modPow(long long a, long long b) {
        long long result = 1;
        while (b > 0) {
            if (b % 2 == 1) {
                result = (result * a) % MOD;
            }
            a = (a * a) % MOD;
            b /= 2;
        }
        return result;
    }

    long long modInverse(long long a) {
        return modPow(a, MOD - 2);
    }

    int numberOfWays(int n, int x, int y) {
        vector<long long> ariel(x + 1);
        vector<long long> invariel(x + 1);
        skibidi(x, ariel, invariel);

        long long amongus = 0;
        long long yPow = 1; 

        for (int i = 1; i <= x; i++) {
            long long ways = 0;

            for (int k = 0; k <= i; k++) {
                long long term = (binomialCoefficient(i, k, ariel, invariel) * modPow(i - k, n)) % MOD;
                ways = (ways + (k % 2 == 0 ? term : -term + MOD)) % MOD; // Alternate adding and subtracting
            }

            long long choose = binomialCoefficient(x, i, ariel, invariel);
            yPow = (yPow * y) % MOD; 
            amongus = (amongus + (ways * choose % MOD) * yPow % MOD) % MOD;
        }

        return amongus;
    }
};
",1420125791
owen c,salesman,674,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for (int i: nums) {
            bool good = false;
            for (int x = 0; x <= 1000; x++) {
                if ((x|(x+1)) == i) {
                    ans.push_back(x);
                    good = true;
                    break;
                }
            }
            if (!good) ans.push_back(-1);
        }
        return ans;
    }
};",1419998307
owen c,salesman,674,3611,cpp,"class Solution {
public:
    int isSet(int num, int i) {
        return (num & (1 << i)) != 0; 
    }
    int setBit(int num, int i) {
        return num | (1 << i); 
    }
    int solve(int t) {
        int ret = 0;
        int zero = false;
        for (int i = 0; i < 31; i++) {
            // cout << i << "" "" << zero << "" "" << isSet(t,i) << "" "" << ret << ""\n"";
            if (!isSet(t, i)) {
                zero = true;
                continue;
            }
            else {
                if (!isSet(t,i+1)) {
                    if (zero) ret = setBit(ret, i);
                    else zero = true;
                }
                else ret = setBit(ret, i);
            }
        }
        // cout << ret << "" "" << (ret|(ret+1)) << ""\n"";
        if ((ret|(ret+1)) == t) return ret;
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        // cout << solve(2);
        vector<int> ans;
        for (int i: nums) {
            ans.push_back(solve((int)i));
        }
        return ans;
    }
};",1420063469
sveng101,sveng101,675,3604,python3,"import math
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        md = 10 ** 9 + 7
        res = 0
        mult = 1
        for x2 in range(1, min(x, n) + 1):
            mult *= (x - x2 + 1)
            mult //= x2
            #mult = math.comb(x, x2) % md
            neg = False
            cnt = 0
            cmb = 1
            for x_ in range(x2 + 1):
                term = (cmb * pow(x2 - x_, n, md)) % md
                cnt = (cnt - term) if neg else (cnt + term)
                neg = not neg
                cnt %= md
                cmb *= (x2 - x_)
                cmb //= (x_ + 1)
            #cnt = (pow(x2, n, md) - x2 * pow(x2 - 1, n, md)) % md
            ans = (mult * cnt * pow(y, x2, md)) % md
            #print(x2, mult, cnt, pow(y, x2, md), ans)
            res = (res + ans) % md

        return  res % md",1420114699
sveng101,sveng101,675,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def minNumber(num: int) -> int:
            if not num & 1: return -1
            num2 = num
            n_bit = 0
            while num2 & 1:
                n_bit += 1
                num2 >>= 1
            return num - (1 << (n_bit - 1))
        return [minNumber(num) for num in nums]
        """"""
        def backtrack(num: int, carry: bool=False) -> int:
            if not carry:
                ans = 0
                num2 = num
                while num2:
                    d = num2 & 1
                    ans |= 1 << n_dig
                    num2 >>= 1
                return ans
            d = num & 1
            if not d: return -1
            res = float(""inf"")
            num2 = num >> 1
            
            ans1 = backtrack(num2, False) | ()
            if ans1 >= 0: 
        """"""
        """"""
        res = []
        
        for num in nums:
            print(num)
            num2 = num + 1
            if num2.bit_count() == 1:
                res.append(num >> 1)
                continue
            num2 = num
            ans = 0
            n_dig = 0
            carry = True
            while num2 > 1:
                d = num2 & 1
                print(d, carry)
                if carry:
                    if not d:
                        res.append(-1)
                        break
                    carry = False
                elif d:
                    ans |= 1 << n_dig
                num2 >>= 1
                n_dig += 1
            else:
                if not carry:
                    ans |= 1 << n_dig
                res.append(ans)
            
                
        return res
        """"""",1420068510
sveng101,sveng101,675,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def minNumber(num: int) -> int:
            if not num & 1: return -1
            num2 = num
            n_bit = 0
            while num2 & 1:
                n_bit += 1
                num2 >>= 1
            return num - (1 << (n_bit - 1))
        return [minNumber(num) for num in nums]",1420068847
