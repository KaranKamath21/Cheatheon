username,userslug,contest_rank,question_id,language,code,submission_id
Konsept,konssept,1,3487,rust,"impl Solution {
    pub fn max_removals(source: String, pattern: String, target_indices: Vec<i32>) -> i32 {
        let n = source.len();
        let m = pattern.len();
        
        let l = target_indices.clone();
        
        let mut t = vec![false; n];
        for &i in &target_indices {
            t[i as usize] = true;
        }
        
        let mut d = vec![i32::MAX; m + 1];
        d[0] = 0;
        
        let s: Vec<char> = source.chars().collect();
        let p: Vec<char> = pattern.chars().collect();
        
        for i in 0..n {
            for j in (1..=m).rev() {
                if s[i] == p[j - 1] {
                    if d[j - 1] != i32::MAX {
                        let u = if t[i] { 1 } else { 0 };
                        d[j] = d[j].min(d[j - 1] + u);
                    }
                }
            }
        }
        
        if d[m] == i32::MAX {
            return 0;
        }
        
        target_indices.len() as i32 - d[m]
    }
}",1419997928
Konsept,konssept,1,3604,rust,"impl Solution {
    pub fn number_of_ways(n: i32, x: i32, y: i32) -> i32 {
        const MOD: i64 = 1_000_000_007;
        
        let mut f = vec![1; (x + 1) as usize];
        for i in 1..=x {
            f[i as usize] = f[(i - 1) as usize] * i as i64 % MOD;
        }
        
        let mut inv_f = vec![1; (x + 1) as usize];
        inv_f[x as usize] = Self::pow_mod(f[x as usize], MOD - 2, MOD);
        for i in (1..x).rev() {
            inv_f[i as usize] = inv_f[(i + 1) as usize] * (i + 1) as i64 % MOD;
        }
        
        let mut p_y = vec![1; (x + 1) as usize];
        for k in 1..=x {
            p_y[k as usize] = p_y[(k - 1) as usize] * y as i64 % MOD;
        }
        
        let mut s = vec![0; (x + 1) as usize];
        s[0] = 1;
        for i in 1..=n {
            let k_max = x.min(i);
            for k in (1..=k_max).rev() {
                s[k as usize] = (k as i64 * s[k as usize] + s[(k - 1) as usize]) % MOD;
            }
            s[0] = 0;
        }
        
        let mut sum = 0;
        let k_limit = n.min(x);
        for k in 1..=k_limit {
            let p = f[x as usize] * inv_f[(x - k) as usize] % MOD;
            let term = p * s[k as usize] % MOD * p_y[k as usize] % MOD;
            sum = (sum + term) % MOD;
        }
        
        sum as i32
    }
    
    fn pow_mod(mut a: i64, mut b: i64, m: i64) -> i64 {
        let mut res = 1;
        a %= m;
        while b > 0 {
            if b & 1 == 1 {
                res = res * a % m;
            }
            a = a * a % m;
            b >>= 1;
        }
        res
    }
}",1420000118
Konsept,konssept,1,3605,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![-1; n];
        
        for (i, &y) in nums.iter().enumerate() {
            let mut min_x = i32::MAX;
            
            for k in 0..=30 {
                if (y >> k) & 1 == 1 {
                    let x = y - (1 << k);
                    if x >= 0 && (x | (x + 1)) == y {
                        if x < min_x {
                            min_x = x;
                        }
                    }
                }
            }
            
            if min_x != i32::MAX {
                ans[i] = min_x;
            }
        }
        
        ans
    }
}",1419994888
Konsept,konssept,1,3611,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![-1; n];
        
        for (i, &y) in nums.iter().enumerate() {
            let mut min_x = i32::MAX;
            
            for k in 0..=30 {
                if (y >> k) & 1 == 1 {
                    let x = y - (1 << k);
                    if x >= 0 && (x | (x + 1)) == y {
                        if x < min_x {
                            min_x = x;
                        }
                    }
                }
            }
            
            if min_x != i32::MAX {
                ans[i] = min_x;
            }
        }
        
        ans
    }
}",1419994967
peace,shankardtu21,2,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& ti) {
        int n = s.size(), m = p.size();
        vector<bool> v(n, false);
        for(int idx : ti)
            v[idx] = true;
        vector<int> t(m + 1, INT_MAX / 2);
        t[0] = 0;
        for(int i = 0; i < n; ++i) {
            for(int j = min(i, m - 1); j >= 0; --j) {
                if(s[i] == p[j]) {
                    int cost = t[j] + v[i];
                    t[j + 1] = min(t[j + 1], cost);
                }
            }
        }
        int min_used = t[m];
        return ti.size() - min_used;
    }
};
",1419999188
peace,shankardtu21,2,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int MOD = 1e9+7;
        int N = max(n, x);
        vector<long long> f(N+1), inf(N+1);
        f[0] = inf[0] = 1;
        for(int i=1; i<=N; ++i)
            f[i] = f[i-1] * i % MOD;
        inf[N] = modpow(f[N], MOD-2, MOD);
        for(int i=N-1; i>=1; --i)
            inf[i] = inf[i+1] * (i+1) % MOD;
        auto comb = [&](int n, int k) {
            if(k<0 || k>n) return 0LL;
            return f[n] * inf[k] % MOD * inf[n-k] % MOD;
        };
        vector<vector<long long>> S(n+1, vector<long long>(n+1, 0));
        S[0][0] = 1;
        for(int i=1; i<=n; ++i){
            for(int j=1; j<=i; ++j){
                S[i][j] = (j*S[i-1][j]%MOD + S[i-1][j-1])%MOD;
            }
        }
        int ans = 0;
        for(int k=1; k<=min(n,x); ++k){
            long long c = comb(x,k) * f[k] % MOD;
            c = c * S[n][k] % MOD;
            c = c * modpow(y,k,MOD) % MOD;
            ans = (ans + c) % MOD;
        }
        return ans;
    }
private:
    long long modpow(long long a, long long b, long long mod){
        long long ans = 1;
        a %= mod;
        while(b){
            if(b&1) ans = ans * a % mod;
            a = a * a % mod;
            b >>=1;
        }
        return ans;
    }
};
",1420003171
peace,shankardtu21,2,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        for(int num:n){
            int ans=-1;
            for(int x=0;x<=num;++x){
                if((x|(x+1))==num){
                    ans=x;
                    break;
                }
            }
            a.push_back(ans);
        }
        return a;
    }
};
",1419994097
peace,shankardtu21,2,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int N : nums) {
            int min_x = -1;
            for(int k = 0; k < 31; ++k) {
                if(N & (1 << k)) {
                    int x = N - (1 << k);
                    if(x >= 0 && (x | (x + 1)) == N) {
                        if(min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};
",1419995478
Shivam,itshivam,3,3487,golang,"package main

import (
	""fmt""
	""math""
)

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func maxRemovals(s string, p string, t []int) int {
	l := len(s)
	k := len(p)

	g := make([]bool, l)
	for _, i := range t {
		g[i] = true
	}

	const I = math.MaxInt32
	d := make([]int, k+1)
	for i := 0; i <= k; i++ {
		d[i] = I
	}
	d[0] = 0

	for i := 0; i < l; i++ {
		for j := k - 1; j >= 0; j-- {
			if s[i] == p[j] {
				if d[j]+0 < d[j+1] {
					if g[i] {
						d[j+1] = min(d[j+1], d[j]+1)
					} else {
						d[j+1] = min(d[j+1], d[j])
					}
				} else {
					if g[i] {
						d[j+1] = min(d[j+1], d[j]+1)
					} else {
						d[j+1] = min(d[j+1], d[j])
					}
				}
			}
		}
	}

	if d[k] == I {
		return 0
	}
	r := len(t) - d[k]
	if r < 0 {
		return 0
	}
	return r
}
",1420004071
Shivam,itshivam,3,3604,golang,"const MOD int64 = 1_000_000_007

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func numberOfWays(n int, x int, y int) int {
	lS := make([][]int64, n+1)
	for i := 0; i <= n; i++ {
		lS[i] = make([]int64, x+1)
	}
	lS[0][0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= min(i, x); j++ {
			lS[i][j] = (int64(j)*lS[i-1][j] + lS[i-1][j-1]) % MOD
		}
	}
	lC := make([]int64, x+1)
	lC[0] = 1
	for i := 1; i <= x; i++ {
		for j := min(i, x); j >= 1; j-- {
			lC[j] = (lC[j] + lC[j-1]) % MOD
		}
	}
	lFactorial := make([]int64, x+1)
	lFactorial[0] = 1
	for i := 1; i <= x; i++ {
		lFactorial[i] = (lFactorial[i-1] * int64(i)) % MOD
	}
	lMaxK := min(x, n)
	lYPows := make([]int64, lMaxK+1)
	lYPows[0] = 1
	for k := 1; k <= lMaxK; k++ {
		lYPows[k] = (lYPows[k-1] * int64(y)) % MOD
	}
	var lResult int64 = 0
	for k := 1; k <= lMaxK; k++ {
		lTerm := (lC[k] * lFactorial[k]) % MOD
		lTerm = (lTerm * lS[n][k]) % MOD
		lTerm = (lTerm * lYPows[k]) % MOD
		lResult = (lResult + lTerm) % MOD
	}
	return int(lResult)
}
",1420009838
Shivam,itshivam,3,3605,golang,"func minBitwiseArray(nums []int) []int {
	r := make([]int, len(nums))
	for i, n := range nums {
		m := math.MaxInt32
		for j := 0; j <= 30; j++ {
			if (n & (1 << j)) != 0 {
				b := n &^ (1 << j)
				if b < 0 || b >= n {
					continue
				}
				c := b + 1
				if (b | c) == n {
					if b < m {
						m = b
					}
				}
			}
		}
		if m != math.MaxInt32 {
			r[i] = m
		} else {
			r[i] = -1
		}
	}
	return r
}
",1420013893
Shivam,itshivam,3,3611,golang,"func minBitwiseArray(nums []int) []int {
	r := make([]int, len(nums))
	for i, n := range nums {
		m := math.MaxInt32
		for j := 0; j <= 30; j++ {
			if (n & (1 << j)) != 0 {
				b := n &^ (1 << j)
				if b < 0 || b >= n {
					continue
				}
				c := b + 1
				if (b | c) == n {
					if b < m {
						m = b
					}
				}
			}
		}
		if m != math.MaxInt32 {
			r[i] = m
		} else {
			r[i] = -1
		}
	}
	return r
}
",1420013381
Shreyan Ray,Dominater069L,4,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector <bool> a(n, false);
        for (auto x : targetIndices) a[x] = true;
        
        vector<int> dp(m + 1, -(int)1e9);
        dp[0] = 0;
        for (int i = 0; i < n; i++){
            vector <int> ndp(m + 1, -(int)1e9);
            for (int j = 0; j <= m; j++){
                ndp[j] = max(ndp[j], dp[j] + (a[i]));
                if (j != m && source[i] == pattern[j]){
                    ndp[j + 1] = max(ndp[j + 1], dp[j]);
                }
            }
            
            dp = ndp;
        }
        
        int ans = dp[m];
        return ans;
    }
};",1420014602
Shreyan Ray,Dominater069L,4,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int mod = 1e9 + 7;
        vector <int> dp(x + 1, 0);
        dp[0] = 1;
        
        for (int i = 1; i <= n; i++){
            vector <int> ndp(x + 1, 0);
            for (int j = 1; j <= x; j++){
                // assign to one of the bands 
                ndp[j] = (ndp[j] + 1LL * dp[j] * j) % mod;
                ndp[j] = (ndp[j] + 1LL * dp[j - 1] * (x - j + 1)) % mod;
            }
            
            dp = ndp;
        }
        
        int ans = 0;
        int v = 1;
        for (int i = 1; i <= x; i++){
            v = (1LL * v * y) % mod;
            ans = (ans + 1LL * v * dp[i]) % mod;
        }
        return ans;
    }
};",1420010475
Shreyan Ray,Dominater069L,4,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto x : nums){
            if (x % 2 == 0){
                ans.push_back(-1);
            } else {
                int p = 0;
                while (x >> (p + 1) & 1){
                    p++;
                }
                ans.push_back(x - (1 << p));
            }
        }
        return ans;
    }
};",1419994497
Shreyan Ray,Dominater069L,4,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto x : nums){
            if (x % 2 == 0){
                ans.push_back(-1);
            } else {
                int p = 0;
                while (x >> (p + 1) & 1){
                    p++;
                }
                ans.push_back(x - (1 << p));
            }
        }
        return ans;
    }
};",1419994643
kmjp,kmjp,8,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

int from[3030];
int to[3030];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int C[3030]={};
        FORR(a,targetIndices) C[a]=1;
        int N=source.size(),M=pattern.size();
        int i,j;
        FOR(i,M+1) from[i]=-1010;
        from[0]=0;
        FOR(i,N) {
			FOR(j,M+1) to[j]=from[j];
			FOR(j,M+1) if(from[j]>=0) {
				if(j<M&&pattern[j]==source[i]) {
					to[j+1]=max(to[j+1],from[j]);
				}
				if(C[i]) {
					to[j]=max(to[j],from[j]+1);
				}
			}
			FOR(j,M+1) from[j]=to[j];
		}
		return from[M];
    }
};
",1420004373
kmjp,kmjp,8,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------

const ll mo=1000000007;

ll from[1010],to[1010];

ll comb(ll N_, ll C_) {
	const int NUM_=400001;
	static ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];
	if (fact[0]==0) {
		inv[1]=fact[0]=factr[0]=1;
		for (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;
		for (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;
	}
	if(C_<0 || C_>N_) return 0;
	return factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;
}

ll modpow(ll a, ll n = mo-2) {
	ll r=1;a%=mo;
	while(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;
	return r;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        ZERO(from);
        from[0]=1;
        int i,j,k;
        FOR(i,n) {
			ZERO(to);
			FOR(j,x+1) {
				(to[j]+=from[j]*j)%=mo;
				(to[j+1]+=from[j]*(x-j)*y)%=mo;
			}
			swap(from,to);
		}
		ll ret=0;
		for(i=1;i<=x;i++) (ret+=from[i])%=mo;
		return ret;
		
    }
};
",1420019620
kmjp,kmjp,8,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
		vector<int> R;
		FORR(n,nums) {
			if(n%2==0) {
				R.push_back(-1);
			}
			else {
				int i;
				FOR(i,30) {
					if((n&(1<<i))==0) {
						n^=1<<(i-1);
						break;
					}
				}
				R.push_back(n);
			}
		}
        return R;
    }
};
",1419995103
kmjp,kmjp,8,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef signed long long ll;

#undef _P
#define _P(...) (void)printf(__VA_ARGS__)
#define FOR(x,to) for(x=0;x<(to);x++)
#define FORR(x,arr) for(auto& x:arr)
#define FORR2(x,y,arr) for(auto& [x,y]:arr)
#define ALL(a) (a.begin()),(a.end())
#define ZERO(a) memset(a,0,sizeof(a))
#define MINUS(a) memset(a,0xff,sizeof(a))
template<class T> bool chmax(T &a, const T &b) { if(a<b){a=b;return 1;}return 0;}
template<class T> bool chmin(T &a, const T &b) { if(a>b){a=b;return 1;}return 0;}
//-------------------------------------------------------


class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
		vector<int> R;
		FORR(n,nums) {
			if(n%2==0) {
				R.push_back(-1);
			}
			else {
				int i;
				FOR(i,30) {
					if((n&(1<<i))==0) {
						n^=1<<(i-1);
						break;
					}
				}
				R.push_back(n);
			}
		}
        return R;
    }
};
",1419995031
BarryBondsOfLC,BarryBondsOfLC,10,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        target_set = set(targetIndices)

        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0

        for i in range(1, n + 1):
            for j in range(0, m + 1):
                dp[i][j] = min(dp[i][j], dp[i-1][j])
                if j < m and source[i-1] == pattern[j]:
                    if i-1 not in target_set:
                        dp[i][j+1] = min(dp[i][j+1], dp[i-1][j])
                    else:
                        dp[i][j+1] = min(dp[i][j+1], dp[i-1][j] + 1)

        if dp[n][m] == float('inf'):
            return 0

        return len(targetIndices) - dp[n][m]",1420003411
BarryBondsOfLC,BarryBondsOfLC,10,3604,cpp,"const int MOD = 1e9 + 7;

using ll = long long;

ll powmod_func(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    while (b > 0) {
        if (b & 1) {
            res = res * a % mod;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<ll> S(x + 1, 0);
        if (n >= 1) {
            S[1] = 1;
        }
        for (int i = 2; i <= n; ++i) {
            for (int k = min(i, x); k >= 1; --k) {
                S[k] = (S[k - 1] + k * S[k]) % MOD;
            }
        }
        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        ll sum = 0;
        for (int k = 1; k <= min(x, n); ++k) {
            ll P = fact[x] * powmod_func(fact[x - k], MOD - 2, MOD) % MOD;
            ll power_y = powmod_func(y, k, MOD);
            sum = (sum + P * S[k] % MOD * power_y % MOD) % MOD;
        }
        return sum;
    }
};",1420020152
BarryBondsOfLC,BarryBondsOfLC,10,3605,python3,"class Solution:
    def minBitwiseArray(self, A: List[int]) -> List[int]:
        ans = []
        for p in A:
            min_a = float('inf')
            for m in range(32):
                if p & (1 << m):
                    a = p & ~(1 << m)
                    if (a | (a + 1)) == p and a < min_a:
                        min_a = a
            ans.append(min_a if min_a != float('inf') else -1)
        return ans",1420023491
BarryBondsOfLC,BarryBondsOfLC,10,3611,python3,"class Solution:
    def minBitwiseArray(self, A: List[int]) -> List[int]:
        ans = []
        for p in A:
            min_a = float('inf')
            for m in range(32):
                if p & (1 << m):
                    a = p & ~(1 << m)
                    if (a | (a + 1)) == p and a < min_a:
                        min_a = a
            ans.append(min_a if min_a != float('inf') else -1)
        return ans",1420023791
Ethan,ethanrao,13,3487,cpp,"class Solution {
public:
    int f[3005][3005], vis[3005];
    const int M = 10000000;
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        for(auto v: targetIndices) vis[v] = 1;
        int n = source.size(), m = pattern.size();
        f[0][0] = 0;
        for(int i = 1; i <= m; ++i) f[0][i] = M;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j){
                f[i][j] = M;
                f[i][j] = f[i - 1][j];
                if(source[i - 1] == pattern[j - 1]){
                    if(vis[i - 1]) f[i][j] = std::min(f[i][j], f[i - 1][j - 1] + 1);
                    else f[i][j] = std::min(f[i][j], f[i - 1][j - 1]);
                }
            }
        return targetIndices.size() - f[n][m];
    }
};",1420014770
Ethan,ethanrao,13,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    inline int minus(int x, int y){
        return x < y ? x - y + mod : x - y;
    }
    int fac[1005], ifac[1005], f[1005][1005];
    inline int C(int x, int y){
        if(y < 0 || x < y) return 0;
        return mul(mul(fac[x], ifac[y]), ifac[x - y]);
    }
    inline int Qpow(int x, int y){
        int r = 1;
        while(y){
            if(y & 1) r = mul(r, x);
            x = mul(x, x);
            y >>= 1;
        }
        return r;
    }
    int numberOfWays(int n, int x, int y) {
        fac[0] = 1;
        for(int i = 1; i <= 1000; ++i) fac[i] = mul(fac[i - 1], i);
        for(int i = 0; i <= 1000; ++i) ifac[i] = Qpow(fac[i], mod - 2);
        int ans = 0;
        f[1][1] = 1;
        for(int i = 2; i <= 1000; ++i)
            for(int j = 1; j <= i; ++j)
                f[i][j] = add(f[i - 1][j - 1], mul(j, f[i - 1][j]));
        for(int i = 1, r = y; i <= x; ++i, r = mul(r, y)){
            int tmp = mul(C(x, i), r);
            ans = add(ans, mul(tmp, mul(f[n][i], fac[i])));
        }
        return ans;
    }
};",1420005076
Ethan,ethanrao,13,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        std::vector <int> ans;
        ans.resize(nums.size());
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2){
                ans[i] = -1;
                continue;
            }
            int now = 0;
            for(int j = 29; j >= 0; --j){
                if(!(nums[i] & (1 << j))) continue;
                int tmp = now + (1 << j) - 1;
                if((tmp | (tmp + 1)) == nums[i]){
                    ans[i] = tmp;
                    break;
                }
                now += (1 << j);
            }
        }
        return ans;
    }
};",1420024880
Ethan,ethanrao,13,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        std::vector <int> ans;
        ans.resize(nums.size());
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2){
                ans[i] = -1;
                continue;
            }
            int now = 0;
            for(int j = 29; j >= 0; --j){
                if(!(nums[i] & (1 << j))) continue;
                int tmp = now + (1 << j) - 1;
                if((tmp | (tmp + 1)) == nums[i]){
                    ans[i] = tmp;
                    break;
                }
                now += (1 << j);
            }
        }
        return ans;
    }
};",1420024764
AntonRaichuk,AntonRaichuk,17,3487,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

int r[3033][3033];
bool u[3333];
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        CL(u,0);
        REP(i,t.size())u[t[i]]=1;
        int n = s.size();
        REP(i,n+1)REP(j,p.size()+1)r[i][j]=-1;
        r[0][0]=0;
        REP(i,n)REP(j,p.size()+1)if(r[i][j]!=-1){
            //cout<<i<<' '<<j<<' '<<r[i][j]<<endl;
            if(u[i]){
                r[i+1][j]=max(r[i+1][j],r[i][j]+1);
            }
            r[i+1][j]=max(r[i+1][j],r[i][j]);
            if(j<p.size() && s[i]==p[j]){
                r[i+1][j+1]=max(r[i+1][j+1],r[i][j]);
            }
        }
        return r[n][p.size()];
    }
};",1420009690
AntonRaichuk,AntonRaichuk,17,3604,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

const int mod = 1000000007;

int d[1001][1001];
ll yp[1001];

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        yp[0]=1;
        FOR(i,1,1001)yp[i]=(yp[i-1]*y)%mod;
        REP(i,n+1)REP(j,x+1)d[i][j]=0;
        d[0][0]=1;
        REP(i,n)REP(j,x+1){
            d[i+1][j]=(d[i+1][j]+d[i][j]*ll(j))%mod;
            if(j+1<=x)d[i+1][j+1]=(d[i+1][j+1]+d[i][j]*ll(x-j))%mod;
        }
        ll res=0;
        FOR(i,1,x+1){
            res = (res + d[n][i]*yp[i])%mod;

        }
        return res;
    }
};",1420018707
AntonRaichuk,AntonRaichuk,17,3605,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi r;
        REP(i,nums.size()){
            if(nums[i]==2)r.pb(-1);
            else{
                int x = 0;
                while(nums[i]&(1<<x))x++;
                r.pb(nums[i]^((1<<(x-1))));
            }
        }
        return r;
    }
};",1419997710
AntonRaichuk,AntonRaichuk,17,3611,cpp,"typedef long double ld;
 
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,pii> p3;
typedef pair<ll,ll> pl;
typedef pair<int,pl> p3l;
typedef pair<double,double> pdd;
typedef vector<int> vi;
typedef vector<ld> vd;
 
#define FOR(i,a,b) for(int i=(a);i<(b);i++)
#define REP(i,n) FOR(i,0,n)
#define SORT(v) sort((v).begin(),(v).end())
#define UN(v) SORT(v),(v).erase(unique((v).begin(),(v).end()),(v).end())
#define CL(a,b) memset(a,b,sizeof a)
#define pb push_back

// to_string, stoi, stoll, gcd, __builtin_popcount - already exist
//
// unordered_map<int, int> depth;
// for (auto& [k, v] : depth)

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi r;
        REP(i,nums.size()){
            if(nums[i]==2)r.pb(-1);
            else{
                int x = 0;
                while(nums[i]&(1<<x))x++;
                r.pb(nums[i]^((1<<(x-1))));
            }
        }
        return r;
    }
};",1419997435
Mark,myselfshivams,18,3487,python3,"from typing import List
import math

class Solution:
    def maxRemovals(self, src: str, pat: str, trgIndices: List[int]) -> int:
        src_len = len(src)
        pat_len = len(pat)

        is_target = [False] * src_len
        for idx in trgIndices:
            is_target[idx] = True

        INF = math.inf
        dp = [INF] * (pat_len + 1)
        dp[0] = 0

        i = 0
        while i < src_len:
            j = pat_len - 1
            while j >= 0:
                if src[i] == pat[j]:
                    dp[j + 1] = min(dp[j + 1], dp[j] + (1 if is_target[i] else 0))
                j -= 1  
            i += 1  

        if dp[pat_len] == INF:
            return 0
        remaining = len(trgIndices) - dp[pat_len]
        return max(remaining, 0)
",1420028832
Mark,myselfshivams,18,3604,python3,"MOD = 1_000_000_007

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        s = [[0] * (x + 1) for _ in range(n + 1)]
        s[0][0] = 1
        
        i = 1
        while i <= n:
            j = 1
            while j <= min(i, x):
                s[i][j] = (j * s[i-1][j] + s[i-1][j-1]) % MOD
                j += 1
            i += 1

        c = [0] * (x + 1)
        c[0] = 1
        
        i = 1
        while i <= x:
            j = min(i, x)
            while j > 0:
                c[j] = (c[j] + c[j-1]) % MOD
                j -= 1
            i += 1

        f = [0] * (x + 1)
        f[0] = 1
        
        i = 1
        while i <= x:
            f[i] = (f[i-1] * i) % MOD
            i += 1

        m = min(x, n)
        
        p = [0] * (m + 1)
        p[0] = 1
        
        k = 1
        while k <= m:
            p[k] = (p[k-1] * y) % MOD
            k += 1

        r = 0
        k = 1
        while k <= m:
            t = (c[k] * f[k]) % MOD
            t = (t * s[n][k]) % MOD
            t = (t * p[k]) % MOD
            r = (r + t) % MOD
            k += 1

        return r
",1420025370
Mark,myselfshivams,18,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for number in nums:
            minimum = float('inf')
            for index in range(31):
                if number & (1 << index):
                    candidate = number & ~(1 << index)
                    if candidate < 0 or candidate >= number:
                        continue
                    next_candidate = candidate + 1
                    if (candidate | next_candidate) == number:
                        if candidate < minimum:
                            minimum = candidate
            if minimum != float('inf'):
                result.append(minimum)
            else:
                result.append(-1)
        return result
",1420020559
Mark,myselfshivams,18,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for number in nums:
            minimum = float('inf')
            for index in range(31):
                if number & (1 << index):
                    candidate = number & ~(1 << index)
                    if candidate < 0 or candidate >= number:
                        continue
                    next_candidate = candidate + 1
                    if (candidate | next_candidate) == number:
                        if candidate < minimum:
                            minimum = candidate
            if minimum != float('inf'):
                result.append(minimum)
            else:
                result.append(-1)
        return result
",1420020256
Kude,Kude,19,3487,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;



class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
      constexpr int INF = 1001001001;
      int n = source.size(), m = pattern.size();
      VI dp(m + 1, -INF), ndp;
      dp[0] = 0;
      reverse(all(targetIndices));
      for (int id = -1; char c : source) {
        id++;
        ndp.assign(m + 1, -INF);
        rep(i, m + 1) {
          if (i < m && pattern[i] == c) chmax(ndp[i+1], dp[i]);
          else chmax(ndp[i], dp[i]);
        }
        if (!targetIndices.empty() && targetIndices.back() == id) {
          targetIndices.pop_back();
          rep(i, m + 1) chmax(ndp[i], dp[i] + 1);
        }
        swap(dp, ndp);
      }
      return dp[m];
    }
};",1420011223
Kude,Kude,19,3604,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;

#include <cassert>
#include <numeric>
#include <type_traits>

#ifdef _MSC_VER
#include <intrin.h>
#endif


#include <utility>

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

constexpr long long safe_mod(long long x, long long m) {
    x %= m;
    if (x < 0) x += m;
    return x;
}

struct barrett {
    unsigned int _m;
    unsigned long long im;

    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

    unsigned int umod() const { return _m; }

    unsigned int mul(unsigned int a, unsigned int b) const {

        unsigned long long z = a;
        z *= b;
#ifdef _MSC_VER
        unsigned long long x;
        _umul128(z, im, &x);
#else
        unsigned long long x =
            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
        unsigned long long y = x * _m;
        return (unsigned int)(z - y + (z < y ? _m : 0));
    }
};

constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
    if (m == 1) return 0;
    unsigned int _m = (unsigned int)(m);
    unsigned long long r = 1;
    unsigned long long y = safe_mod(x, m);
    while (n) {
        if (n & 1) r = (r * y) % _m;
        y = (y * y) % _m;
        n >>= 1;
    }
    return r;
}

constexpr bool is_prime_constexpr(int n) {
    if (n <= 1) return false;
    if (n == 2 || n == 7 || n == 61) return true;
    if (n % 2 == 0) return false;
    long long d = n - 1;
    while (d % 2 == 0) d /= 2;
    constexpr long long bases[3] = {2, 7, 61};
    for (long long a : bases) {
        long long t = d;
        long long y = pow_mod_constexpr(a, t, n);
        while (t != n - 1 && y != 1 && y != n - 1) {
            y = y * y % n;
            t <<= 1;
        }
        if (y != n - 1 && t % 2 == 0) {
            return false;
        }
    }
    return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
    a = safe_mod(a, b);
    if (a == 0) return {b, 0};

    long long s = b, t = a;
    long long m0 = 0, m1 = 1;

    while (t) {
        long long u = s / t;
        s -= t * u;
        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b


        auto tmp = s;
        s = t;
        t = tmp;
        tmp = m0;
        m0 = m1;
        m1 = tmp;
    }
    if (m0 < 0) m0 += b / s;
    return {s, m0};
}

constexpr int primitive_root_constexpr(int m) {
    if (m == 2) return 1;
    if (m == 167772161) return 3;
    if (m == 469762049) return 3;
    if (m == 754974721) return 11;
    if (m == 998244353) return 3;
    int divs[20] = {};
    divs[0] = 2;
    int cnt = 1;
    int x = (m - 1) / 2;
    while (x % 2 == 0) x /= 2;
    for (int i = 3; (long long)(i)*i <= x; i += 2) {
        if (x % i == 0) {
            divs[cnt++] = i;
            while (x % i == 0) {
                x /= i;
            }
        }
    }
    if (x > 1) {
        divs[cnt++] = x;
    }
    for (int g = 2;; g++) {
        bool ok = true;
        for (int i = 0; i < cnt; i++) {
            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

unsigned long long floor_sum_unsigned(unsigned long long n,
                                      unsigned long long m,
                                      unsigned long long a,
                                      unsigned long long b) {
    unsigned long long ans = 0;
    while (true) {
        if (a >= m) {
            ans += n * (n - 1) / 2 * (a / m);
            a %= m;
        }
        if (b >= m) {
            ans += n * (b / m);
            b %= m;
        }

        unsigned long long y_max = a * n + b;
        if (y_max < m) break;
        n = (unsigned long long)(y_max / m);
        b = (unsigned long long)(y_max % m);
        std::swap(m, a);
    }
    return ans;
}

}  // namespace internal

}  // namespace atcoder


#include <cassert>
#include <numeric>
#include <type_traits>

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value ||
                                  std::is_same<T, __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int128 =
    typename std::conditional<std::is_same<T, __uint128_t>::value ||
                                  std::is_same<T, unsigned __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using make_unsigned_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value,
                              __uint128_t,
                              unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
                                                  is_signed_int128<T>::value ||
                                                  is_unsigned_int128<T>::value,
                                              std::true_type,
                                              std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
                                                 std::is_signed<T>::value) ||
                                                    is_signed_int128<T>::value,
                                                std::true_type,
                                                std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<(is_integral<T>::value &&
                               std::is_unsigned<T>::value) ||
                                  is_unsigned_int128<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
    is_signed_int128<T>::value,
    make_unsigned_int128<T>,
    typename std::conditional<std::is_signed<T>::value,
                              std::make_unsigned<T>,
                              std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<is_integral<T>::value &&
                                  std::is_unsigned<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
                                              std::make_unsigned<T>,
                                              std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
    using mint = static_modint;

  public:
    static constexpr int mod() { return m; }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    static_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    static_modint(T v) {
        long long x = (long long)(v % (long long)(umod()));
        if (x < 0) x += umod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    static_modint(T v) {
        _v = (unsigned int)(v % umod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v -= rhs._v;
        if (_v >= umod()) _v += umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        unsigned long long z = _v;
        z *= rhs._v;
        _v = (unsigned int)(z % umod());
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        if (prime) {
            assert(_v);
            return pow(umod() - 2);
        } else {
            auto eg = internal::inv_gcd(_v, m);
            assert(eg.first == 1);
            return eg.second;
        }
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
    static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
    using mint = dynamic_modint;

  public:
    static int mod() { return (int)(bt.umod()); }
    static void set_mod(int m) {
        assert(1 <= m);
        bt = internal::barrett(m);
    }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    dynamic_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        long long x = (long long)(v % (long long)(mod()));
        if (x < 0) x += mod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        _v = (unsigned int)(v % mod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v += mod() - rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        _v = bt.mul(_v, rhs._v);
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        auto eg = internal::inv_gcd(_v, mod());
        assert(eg.first == 1);
        return eg.second;
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static internal::barrett bt;
    static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder

using namespace atcoder;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;
using mint = modint1000000007;

constexpr int FACT_SIZE = 1000000;
mint Fact[FACT_SIZE + 1];
mint iFact[FACT_SIZE + 1];
const auto fact_init = [] {
    Fact[0] = mint::raw(1);
    for(int i = 1; i <= FACT_SIZE; ++i) {
        Fact[i] = Fact[i-1] * i;
    }
    iFact[FACT_SIZE] = Fact[FACT_SIZE].inv();
    for(int i = FACT_SIZE; i; --i) {
        iFact[i-1] = iFact[i] * i;
    }
    return false;
}();

mint comb(int n, int k) {
    if (k == 0) return mint::raw(1);
    assert(n >= 0 && k >= 0);
    if (k > n) return mint::raw(0);
    return Fact[n] * iFact[n - k] * iFact[k];
}

mint icomb(int n, int k) {
    return iFact[n] * Fact[n - k] * Fact[k];
}

mint fact(int n) {return Fact[n];}
mint perm(int n, int k) {
    assert(0 <= n);
    return Fact[n] * iFact[n - k];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
      vector<mint> d(x + 1);
      for (int i = 1; i <= x; i++) d[i] = mint(i).pow(n);
      for (int i = 2; i <= x; i++) {
        for (int j = 1; j < i; j++) d[i] -= d[j] * comb(i, j);
      }
      mint ans;
      for (int i = 1; i <= x; i++) ans += comb(x, i) * d[i] * mint(y).pow(i);
      return ans.val();
    }
};
",1420028874
Kude,Kude,19,3605,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;



class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for (int& x : nums) {
          if (x == 2) x = -1;
          else {
            int i = 0;
            while (x >> i & 1) i++;
            i--;
            x ^= 1 << i;
          }
        }
        return nums;
    }
};",1419996805
Kude,Kude,19,3611,cpp,"#pragma GCC optimize(""O2"")
#include<bits/stdc++.h>
using namespace std;
#define rep(i,n) for(int i = 0; i < (int)(n); i++)
#define rrep(i,n) for(int i = (int)(n) - 1; i >= 0; i--)
#define all(x) begin(x), end(x)
#define rall(x) rbegin(x), rend(x)
template<class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } else return false; }
template<class T> bool chmin(T& a, const T& b) { if (b < a) { a = b; return true; } else return false; }
using ll = long long;
using P = pair<int,int>;
using VI = vector<int>;
using VVI = vector<VI>;
using VL = vector<ll>;
using VVL = vector<VL>;



class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for (int& x : nums) {
          if (x == 2) x = -1;
          else {
            int i = 0;
            while (x >> i & 1) i++;
            i--;
            x ^= 1 << i;
          }
        }
        return nums;
    }
};",1419996683
Souvik Ghosh,Aluu097,22,3487,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    const int inf  = 1e9;
    void ckmax(int &a, int b){
        if(a < b)a = b;
    }
    int maxRemovals(string s, string p, vector<int>& target) {
        vt<vt<int>>dp(sz(s) + 10 ,vt<int>(sz(p) + 10, 0));
        vt<bool>ok(sz(s), 0);
        for(auto i: target)ok[i] = 1;
        for(int i = 0; i <= sz(s); i++){
            for(int j = 0; j <= sz(p); j++){
                dp[i][j] = -inf;
            }
        }
        dp[0][0] = 0;
        for(int i = 0; i < sz(s); i++){
            for(int j = 0; j <= sz(p); j++){
                if(dp[i][j] == -inf)continue;
                //cout << i << "" "" << j << ""\n"";
                if(ok[i]){
                    ckmax(dp[i + 1][j], dp[i][j] + 1);
                }
                    if(j == sz(p))ckmax(dp[i + 1][j], dp[i][j]);
                    else ckmax(dp[i + 1][j + (s[i] == p[j])], dp[i][j]);
                
            }
        }
        
        return(dp[sz(s)][sz(p)]);
    }
};",1420014519
Souvik Ghosh,Aluu097,22,3604,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
const ll mod = 1e9 + 7;
class Solution {
    void add(ll &a, ll b){
        a += b;
        if(a >= mod)a %= mod;
    }
public:
    int numberOfWays(int n, int x, int y) {
        vt<vt<ll>>dp(n + 5, vt<ll>(x + 5, 0));
        dp[0][0] = 1;
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= min(i, x); j++){
                add(dp[i + 1][j], dp[i][j] * j);
                add(dp[i + 1][j + 1], dp[i][j] * (x - j));
            }
        }
        
        ll pwy = 1, ans = 0;
        for(int i = 1; i <= x; i++){
            pwy = (pwy * y) % mod;
            ll ways = dp[n][i];
            ll sm = pwy;
            add(ans, ways * sm);
        }
        
        return(ans);
    }
};",1420027464
Souvik Ghosh,Aluu097,22,3605,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vt<int>res;
        for(auto i: nums){
            int ok = -1;
            for(int j = 1; j <= i; j++){
                if((j | (j + 1)) == i){
                    ok = j; break;
                }
            }
            res.pb(ok);
        }
        return(res);
    }
};",1419994126
Souvik Ghosh,Aluu097,22,3611,cpp,"#define sz(a) (int)a.size()
#define ALL(v) v.begin(), v.end()
#define ALLR(v) v.rbegin(), v.rend()
#define ll long long
#define pb push_back
#define forr(i, a, b) for(int i = a; i < b; i++)
#define dorr(i, a, b) for(int i = a; i >= b; i--)
#define ld long double
#define vt vector
#include<fstream>
#define fi first
#define se second
#define pll pair<ll, ll>
#define pii pair<int, int>
#define mpp make_pair
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vt<int>res;
        for(auto i: nums){
            if(i == 2)res.pb(-1);
            else{
                int ans = 0;
                for(int j = 0; j < 30; j++){
                    if((i >> j) & 1)ans = (1 << j);
                    else break;
                }
                res.pb(i - ans);
                
            }
        }
        return(res);
    }
};",1420001257
VIMALMOUNISH,vimal-mounish,23,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());        
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        
        for (int i = 0; i < n; ++i) {
            vector<int> tempDp = dp;
            for (int j = 0; j < m; ++j) {
                if (source[i] == pattern[j] && dp[j] != INT_MAX) {
                    int cost = dp[j];
                    if (targetSet.count(i)) {
                        if (cost < INT_MAX - 1) {
                            cost += 1;  
                        } else {
                            cost = INT_MAX; 
                        }
                    }
                    if (tempDp[j + 1] > cost) {
                        tempDp[j + 1] = cost;
                    }
                }
            }
            dp.swap(tempDp);
        }
        
        int minRequired = dp[m];
        int totalTargets = targetIndices.size();
        if (minRequired == INT_MAX) {
            return 0;
        }
        return totalTargets - minRequired;
    }
};
",1420024405
VIMALMOUNISH,vimal-mounish,23,3604,cpp,"class Solution {
public:
    #define ll long long
    static const int M = 1e9 + 7;

    void calcS(int n, vector<vector<ll>>& s) {
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            s[i][0] = 0;
            for (int j = 1; j <= i; ++j) {
                s[i][j] = (j * s[i - 1][j] % M + s[i - 1][j - 1]) % M;
            }
        }
    }

    void calcF(int n, vector<ll>& f) {
        f[0] = 1;
        for (int i = 1; i <= n; ++i) {
            f[i] = f[i - 1] * i % M;
        }
    }

    ll comb(int n, int k, const vector<ll>& f, const vector<ll>& invF) {
        if (k < 0 || k > n) return 0;
        return f[n] * invF[k] % M * invF[n - k] % M;
    }

    ll powMod(ll a, ll b) {
        ll res = 1;
        a %= M;
        while (b > 0) {
            if (b & 1) res = res * a % M;
            a = a * a % M;
            b >>= 1;
        }
        return res;
    }

    int numberOfWays(int n, int x, int y) {
        int mx = max(n, x);

        vector<vector<ll>> s(n + 1, vector<ll>(n + 1, 0));
        calcS(n, s);

        vector<ll> f(mx + 1, 1);
        calcF(mx, f);

        vector<ll> invF(mx + 1, 1);
        invF[mx] = powMod(f[mx], M - 2);
        for (int i = mx - 1; i >= 0; --i) {
            invF[i] = invF[i + 1] * (i + 1) % M;
        }

        ll total = 0;

        for (int k = 1; k <= min(n, x); ++k) {
            ll stageComb = comb(x, k, f, invF);
            ll perfWays = f[k] * s[n][k] % M;
            ll scoreWays = powMod(y, k);
            ll ways = stageComb * perfWays % M * scoreWays % M;

            total = (total + ways) % M;
        }

        return (int)total;
    }
};
",1420036523
VIMALMOUNISH,vimal-mounish,23,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  
        
        for (int i = 0; i < n; ++i) {
            for (int a = 0; a <= nums[i]; ++a) {  
                if ((a | (a + 1)) == nums[i]) {  
                    ans[i] = a;  
                    break;                       
                }
            }
        }
        
        return ans;
    }
};
",1419993570
VIMALMOUNISH,vimal-mounish,23,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            int min_x = -1;
            for (int k = 0; k < 31; ++k) {
                if (p & (1 << k)) {
                    int x = p - (1 << k);
                    if (x >= 0 && ((x | (x + 1)) == p)) {
                        if (min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};
",1420006098
Dheeraj,user0530o,24,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int k = targetIndices.size();
        std::unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());

      
        std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, n + 1));

       
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i)
            dp[i][0] = 0;

      
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
              
                dp[i][j] = dp[i - 1][j];
                if (j > 0 && source[i - 1] == pattern[j - 1]) {
                   
                    int cost = targetSet.count(i - 1) ? 1 : 0;
                    dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + cost);
                }
            }
        }

        int minKeep = dp[n][m];
        int maxRemovals = k - minKeep;
        return maxRemovals;
    }
};

",1420020395
Dheeraj,user0530o,24,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int mod = 1e9 + 7;
        int maxN = max(n, x);
        vector<long long> factorial(maxN + 1, 1), inv_factorial(maxN + 1, 1);
        for (int i = 1; i <= maxN; ++i) {
            factorial[i] = factorial[i - 1] * i % mod;
        }
        inv_factorial[maxN] = modInverse(factorial[maxN], mod);
        for (int i = maxN - 1; i >= 0; --i) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % mod;
        }

        int maxK = min(n, x);
        vector<vector<long long>> stirling(n + 1, vector<long long>(maxK + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            stirling[i][0] = 0;
            for (int j = 1; j <= maxK; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] % mod + stirling[i - 1][j - 1]) % mod;
            }
        }

        long long totalWays = 0;
        for (int k = 1; k <= maxK; ++k) {
            long long comb_x_k = factorial[x] * inv_factorial[k] % mod * inv_factorial[x - k] % mod;
            long long k_fact = factorial[k];
            long long s = stirling[n][k];
            long long y_pow_k = modPow(y, k, mod);
            long long term = comb_x_k * k_fact % mod * s % mod * y_pow_k % mod;
            totalWays = (totalWays + term) % mod;
        }
        return totalWays;
    }

private:
    long long modPow(long long base, long long exp, int mod) {
        long long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1)
                result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }

    long long modInverse(long long a, int mod) {
        return modPow(a, mod - 2, mod);
    }
};
",1420036628
Dheeraj,user0530o,24,3605,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int ans_i = -1;
            for (int k = 0; k < 31; ++k) {
                if (num & (1 << k)) {
                    int ans_candidate = num - (1 << k);
                    if (ans_candidate >= 0) {
                        if ((ans_candidate | (ans_candidate + 1)) == num) {
                            if (ans_i == -1 || ans_candidate < ans_i) {
                                ans_i = ans_candidate;
                            }
                        }
                    }
                }
            }
            ans[i] = ans_i;
        }
        return ans;
    }
};
",1419998768
Dheeraj,user0530o,24,3611,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int ans_i = -1;
            for (int k = 0; k < 31; ++k) {
                if (num & (1 << k)) {
                    int ans_candidate = num - (1 << k);
                    if (ans_candidate >= 0) {
                        if ((ans_candidate | (ans_candidate + 1)) == num) {
                            if (ans_i == -1 || ans_candidate < ans_i) {
                                ans_i = ans_candidate;
                            }
                        }
                    }
                }
            }
            ans[i] = ans_i;
        }
        return ans;
    }
};
",1420001137
ArpitVijay7,ArpitVijay7,27,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        unordered_map<char, vector<int>> ctp;
        for(int i=0; i<n; i++) {
            ctp[source[i]].pb(i);
        }
        unordered_set<int> target_set(targetIndices.begin(), targetIndices.end());


        vector<int> dp(m+1, INT_MAX);
        dp[0] = 0;


        for(int i=0; i<n; i++) {
            char current_char = source[i];

            for(int j = m; j >=1; j--){
                if(current_char == pattern[j-1]){
                    if(dp[j-1] != INT_MAX){
                        int cost = target_set.find(i) != target_set.end() ? 1 : 0;
                        dp[j] = min(dp[j], dp[j-1] + cost);
                    }
                }
            }
        }


        if(dp[m] == INT_MAX){
            return 0; 
        }

       
        return targetIndices.size() - dp[m];
    }
};",1420019514
ArpitVijay7,ArpitVijay7,27,3604,cpp,"#include <bits/stdc++.h>
using namespace std;


#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;


class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        
        vector<vector<ll>> S(n+1, vector<ll>(n+1, 0));
        S[0][0] = 1; 

        for(int i=1;i<=n;i++){
            for(int k=1;k<=i;k++){
                S[i][k] = ( (k * S[i-1][k]) % mod + S[i-1][k-1] ) % mod;
            }
        }

        
        vector<vector<ll>> C(x+1, vector<ll>(x+1, 0));
        C[0][0] = 1; 

        for(int i=1;i<=x;i++){
            C[i][0] = 1; 
            for(int k=1;k<=i;k++){
                C[i][k] = (C[i-1][k-1] + C[i-1][k]) % mod;
            }
        }

        int max_k = min(x, n);
        vector<ll> fact(max_k+1, 1);
        for(int k=1; k<=max_k; k++){
            fact[k] = (fact[k-1] * k) % mod;
        }

        vector<ll> y_powers(max_k+1, 1);
        for(int k=1; k<=max_k; k++){
            y_powers[k] = (y_powers[k-1] * y) % mod;
        }

        ll result = 0;
        for(int k=1; k<=max_k; k++){
            ll temp = C[x][k];        
            temp = (temp * fact[k]) % mod;    
            temp = (temp * S[n][k]) % mod;    
            temp = (temp * y_powers[k]) % mod; 
            result = (result + temp) % mod;   
        }
        return result;
    }
};
",1420030847
ArpitVijay7,ArpitVijay7,27,3605,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;


int find_min_a(int num){

    if(num ==1){
        return 0;
    }
    int min_a = INT_MAX;
    for(int bit=0; bit < 32; bit++){
        if(num & (1 << bit)){
            int a = num & (~(1 << bit));
            if((a | (a +1)) == num){
                min_a = min(min_a, a);
            }
        }
    }
    if(min_a != INT_MAX){
        return min_a;
    }
    return -1;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num: nums){
            if(num <1){
                ans.pb(-1);
                continue;
            }
            if(num ==1){
                ans.pb(0);
                continue;
            }
            int a = find_min_a(num);
            if(num ==2){
                ans.pb(-1);
                continue;
            }
            if(a != INT_MAX && a < num){
                ans.pb(a);
            }
            else{
                ans.pb(-1);
            }
        }
        return ans;
    }
};",1419998281
ArpitVijay7,ArpitVijay7,27,3611,cpp,"#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define ll long long
#define fr(i,n) for(int i = 0; i < n ;i++)
#define loop(i,a,b) for(int i = a ;i < b;i++)
#define mod 1000000007
#define inf (1LL << 60)
#define all(x) (x).begin(),(x).end()
#define dis(v) for(auto i: v) cout << i << "" "";
#define deb(i) cout << i << endl;


int find_min_a(int num){

    int min_a = INT_MAX;
    

    for(int bit=0; bit < 32; bit++){
        if(num & (1 << bit)){

            int a = num & (~(1 << bit));

            if( (a | (a +1)) == num ){
                min_a = min(min_a, a);
            }
        }
    }
    

    if(min_a != INT_MAX){
        return min_a;
    }
    return -1;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num: nums){

            if(num ==1){
                ans.pb(0);
                continue;
            }

            int a = find_min_a(num);
            if(a != -1 && a < num){
                ans.pb(a);
            }
            else{
                ans.pb(-1);
            }
        }
        return ans;
    }
};",1420002397
Soumyajit Chakraborty,soumyajitchakraborty23,29,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n = len(s)
        m = len(p)
        d = [float('inf')] * (m + 1)
        d[0] = 0
        a = [False] * n
        for x in t:
            a[x] = True
        for i in range(n):
            c = s[i]
            for j in range(m, 0, -1):
                if p[j - 1] == c:
                    if a[i]:
                        d[j] = min(d[j], d[j - 1] + 1)
                    else:
                        d[j] = min(d[j], d[j - 1])
        return 0 if d[m] == float('inf') else len(t) - d[m]",1420028997
Soumyajit Chakraborty,soumyajitchakraborty23,29,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        modulo = 10**9 + 7
        dp1 = [[0]*(x+2) for _ in range(n+2)]
        dp1[0][0] = 1
        for i in range(1, n+1):
            for j in range(1, min(i, x)+1):
                dp1[i][j] = (j * dp1[i-1][j] + dp1[i-1][j-1]) % modulo
        dp2 = [[0]*(x+2) for _ in range(x+2)]
        dp2[0][0] = 1
        for i in range(1, x+1):
            dp2[i][0] = 1
            for j in range(1, i+1):
                dp2[i][j] = (dp2[i-1][j-1] + dp2[i-1][j]) % modulo
        dp3 = [1]*(x+2)
        for i in range(1, x+1):
            dp3[i] = dp3[i-1] * i % modulo
        dp4 = [1]*(x+2)
        for i in range(1, x+1):
            dp4[i] = dp4[i-1] * y % modulo
        T = 0
        K = min(n, x)
        for k in range(1, K+1):
            temo = dp2[x][k]
            temo = temo * dp1[n][k] % modulo
            temo = temo * dp3[k] % modulo
            temo = temo * dp4[k] % modulo
            T = (T + temo) % modulo
        return T",1420039845
Soumyajit Chakraborty,soumyajitchakraborty23,29,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for B in nums:
            A = []
            if B == 0:
                res.append(-1)
                continue
            n = B
            c = 0
            while (n & 1) == 1:
                c += 1
                n >>= 1
                if c > B.bit_length():
                    break  
            if c == 0:
                res.append(-1)
                continue
            for i in range(c):
                m = ~(1 << i)
                a = B & m
                if (a | (a + 1)) == B:
                    A.append(a)
            if A:
                res.append(min(A))
            else:
                res.append(-1)
        return res",1420002541
Soumyajit Chakraborty,soumyajitchakraborty23,29,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for B in nums:
            A = []
            if B == 0:
                res.append(-1)
                continue
            n = B
            c = 0
            while (n & 1) == 1:
                c += 1
                n >>= 1
                if c > B.bit_length():
                    break  
            if c == 0:
                res.append(-1)
                continue
            for i in range(c):
                m = ~(1 << i)
                a = B & m
                if (a | (a + 1)) == B:
                    A.append(a)
            if A:
                res.append(min(A))
            else:
                res.append(-1)
        return res",1420003169
YouTube Aryan,youtube_aryanc403,30,3487,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/

#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const lli m=sz(pattern),n=sz(source);
        const lli INF = 1e12;
        vi dp(m+1,-INF);
        dp[0]=0;
        set<lli> ti;
        for(const auto &x:targetIndices)
            ti.insert(x);
        for(lli ci=0;ci<n;ci++){
            const auto cx = source[ci];
            vi ndp=dp;
            for(lli j=0;j<m;j++)
                if(cx==pattern[j])
                    ndp[j+1]=max(ndp[j+1],dp[j]);
            if(ti.count(ci)){
                for(lli j=0;j<=m;j++)
                    ndp[j]=max(ndp[j],1+dp[j]);
            }
            dp=ndp;
        }

        return dp[m];
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    // cout<<""Ans:""<<s.runSoln(20)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(100)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(1000)<<"":Fn""<<endl;
    return 0;
}
#endif
",1420031832
YouTube Aryan,youtube_aryanc403,30,3604,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/
#include <bits/stdc++.h>

#include <cassert>
#include <numeric>
#include <type_traits>

#ifdef _MSC_VER
#include <intrin.h>
#endif


#include <utility>

#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace atcoder {

namespace internal {

constexpr long long safe_mod(long long x, long long m) {
    x %= m;
    if (x < 0) x += m;
    return x;
}

struct barrett {
    unsigned int _m;
    unsigned long long im;

    explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}

    unsigned int umod() const { return _m; }

    unsigned int mul(unsigned int a, unsigned int b) const {

        unsigned long long z = a;
        z *= b;
#ifdef _MSC_VER
        unsigned long long x;
        _umul128(z, im, &x);
#else
        unsigned long long x =
            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
        unsigned long long y = x * _m;
        return (unsigned int)(z - y + (z < y ? _m : 0));
    }
};

constexpr long long pow_mod_constexpr(long long x, long long n, int m) {
    if (m == 1) return 0;
    unsigned int _m = (unsigned int)(m);
    unsigned long long r = 1;
    unsigned long long y = safe_mod(x, m);
    while (n) {
        if (n & 1) r = (r * y) % _m;
        y = (y * y) % _m;
        n >>= 1;
    }
    return r;
}

constexpr bool is_prime_constexpr(int n) {
    if (n <= 1) return false;
    if (n == 2 || n == 7 || n == 61) return true;
    if (n % 2 == 0) return false;
    long long d = n - 1;
    while (d % 2 == 0) d /= 2;
    constexpr long long bases[3] = {2, 7, 61};
    for (long long a : bases) {
        long long t = d;
        long long y = pow_mod_constexpr(a, t, n);
        while (t != n - 1 && y != 1 && y != n - 1) {
            y = y * y % n;
            t <<= 1;
        }
        if (y != n - 1 && t % 2 == 0) {
            return false;
        }
    }
    return true;
}
template <int n> constexpr bool is_prime = is_prime_constexpr(n);

constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {
    a = safe_mod(a, b);
    if (a == 0) return {b, 0};

    long long s = b, t = a;
    long long m0 = 0, m1 = 1;

    while (t) {
        long long u = s / t;
        s -= t * u;
        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b


        auto tmp = s;
        s = t;
        t = tmp;
        tmp = m0;
        m0 = m1;
        m1 = tmp;
    }
    if (m0 < 0) m0 += b / s;
    return {s, m0};
}

constexpr int primitive_root_constexpr(int m) {
    if (m == 2) return 1;
    if (m == 167772161) return 3;
    if (m == 469762049) return 3;
    if (m == 754974721) return 11;
    if (m == 998244353) return 3;
    int divs[20] = {};
    divs[0] = 2;
    int cnt = 1;
    int x = (m - 1) / 2;
    while (x % 2 == 0) x /= 2;
    for (int i = 3; (long long)(i)*i <= x; i += 2) {
        if (x % i == 0) {
            divs[cnt++] = i;
            while (x % i == 0) {
                x /= i;
            }
        }
    }
    if (x > 1) {
        divs[cnt++] = x;
    }
    for (int g = 2;; g++) {
        bool ok = true;
        for (int i = 0; i < cnt; i++) {
            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {
                ok = false;
                break;
            }
        }
        if (ok) return g;
    }
}
template <int m> constexpr int primitive_root = primitive_root_constexpr(m);

unsigned long long floor_sum_unsigned(unsigned long long n,
                                      unsigned long long m,
                                      unsigned long long a,
                                      unsigned long long b) {
    unsigned long long ans = 0;
    while (true) {
        if (a >= m) {
            ans += n * (n - 1) / 2 * (a / m);
            a %= m;
        }
        if (b >= m) {
            ans += n * (b / m);
            b %= m;
        }

        unsigned long long y_max = a * n + b;
        if (y_max < m) break;
        n = (unsigned long long)(y_max / m);
        b = (unsigned long long)(y_max % m);
        std::swap(m, a);
    }
    return ans;
}

}  // namespace internal

}  // namespace atcoder


#include <cassert>
#include <numeric>
#include <type_traits>

namespace atcoder {

namespace internal {

#ifndef _MSC_VER
template <class T>
using is_signed_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value ||
                                  std::is_same<T, __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int128 =
    typename std::conditional<std::is_same<T, __uint128_t>::value ||
                                  std::is_same<T, unsigned __int128>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using make_unsigned_int128 =
    typename std::conditional<std::is_same<T, __int128_t>::value,
                              __uint128_t,
                              unsigned __int128>;

template <class T>
using is_integral = typename std::conditional<std::is_integral<T>::value ||
                                                  is_signed_int128<T>::value ||
                                                  is_unsigned_int128<T>::value,
                                              std::true_type,
                                              std::false_type>::type;

template <class T>
using is_signed_int = typename std::conditional<(is_integral<T>::value &&
                                                 std::is_signed<T>::value) ||
                                                    is_signed_int128<T>::value,
                                                std::true_type,
                                                std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<(is_integral<T>::value &&
                               std::is_unsigned<T>::value) ||
                                  is_unsigned_int128<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<
    is_signed_int128<T>::value,
    make_unsigned_int128<T>,
    typename std::conditional<std::is_signed<T>::value,
                              std::make_unsigned<T>,
                              std::common_type<T>>::type>::type;

#else

template <class T> using is_integral = typename std::is_integral<T>;

template <class T>
using is_signed_int =
    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using is_unsigned_int =
    typename std::conditional<is_integral<T>::value &&
                                  std::is_unsigned<T>::value,
                              std::true_type,
                              std::false_type>::type;

template <class T>
using to_unsigned = typename std::conditional<is_signed_int<T>::value,
                                              std::make_unsigned<T>,
                                              std::common_type<T>>::type;

#endif

template <class T>
using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;

template <class T>
using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;

template <class T> using to_unsigned_t = typename to_unsigned<T>::type;

}  // namespace internal

}  // namespace atcoder


namespace atcoder {

namespace internal {

struct modint_base {};
struct static_modint_base : modint_base {};

template <class T> using is_modint = std::is_base_of<modint_base, T>;
template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;

}  // namespace internal

template <int m, std::enable_if_t<(1 <= m)>* = nullptr>
struct static_modint : internal::static_modint_base {
    using mint = static_modint;

  public:
    static constexpr int mod() { return m; }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    static_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    static_modint(T v) {
        long long x = (long long)(v % (long long)(umod()));
        if (x < 0) x += umod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    static_modint(T v) {
        _v = (unsigned int)(v % umod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v -= rhs._v;
        if (_v >= umod()) _v += umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        unsigned long long z = _v;
        z *= rhs._v;
        _v = (unsigned int)(z % umod());
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        if (prime) {
            assert(_v);
            return pow(umod() - 2);
        } else {
            auto eg = internal::inv_gcd(_v, m);
            assert(eg.first == 1);
            return eg.second;
        }
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static constexpr unsigned int umod() { return m; }
    static constexpr bool prime = internal::is_prime<m>;
};

template <int id> struct dynamic_modint : internal::modint_base {
    using mint = dynamic_modint;

  public:
    static int mod() { return (int)(bt.umod()); }
    static void set_mod(int m) {
        assert(1 <= m);
        bt = internal::barrett(m);
    }
    static mint raw(int v) {
        mint x;
        x._v = v;
        return x;
    }

    dynamic_modint() : _v(0) {}
    template <class T, internal::is_signed_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        long long x = (long long)(v % (long long)(mod()));
        if (x < 0) x += mod();
        _v = (unsigned int)(x);
    }
    template <class T, internal::is_unsigned_int_t<T>* = nullptr>
    dynamic_modint(T v) {
        _v = (unsigned int)(v % mod());
    }

    unsigned int val() const { return _v; }

    mint& operator++() {
        _v++;
        if (_v == umod()) _v = 0;
        return *this;
    }
    mint& operator--() {
        if (_v == 0) _v = umod();
        _v--;
        return *this;
    }
    mint operator++(int) {
        mint result = *this;
        ++*this;
        return result;
    }
    mint operator--(int) {
        mint result = *this;
        --*this;
        return result;
    }

    mint& operator+=(const mint& rhs) {
        _v += rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator-=(const mint& rhs) {
        _v += mod() - rhs._v;
        if (_v >= umod()) _v -= umod();
        return *this;
    }
    mint& operator*=(const mint& rhs) {
        _v = bt.mul(_v, rhs._v);
        return *this;
    }
    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }

    mint operator+() const { return *this; }
    mint operator-() const { return mint() - *this; }

    mint pow(long long n) const {
        assert(0 <= n);
        mint x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    mint inv() const {
        auto eg = internal::inv_gcd(_v, mod());
        assert(eg.first == 1);
        return eg.second;
    }

    friend mint operator+(const mint& lhs, const mint& rhs) {
        return mint(lhs) += rhs;
    }
    friend mint operator-(const mint& lhs, const mint& rhs) {
        return mint(lhs) -= rhs;
    }
    friend mint operator*(const mint& lhs, const mint& rhs) {
        return mint(lhs) *= rhs;
    }
    friend mint operator/(const mint& lhs, const mint& rhs) {
        return mint(lhs) /= rhs;
    }
    friend bool operator==(const mint& lhs, const mint& rhs) {
        return lhs._v == rhs._v;
    }
    friend bool operator!=(const mint& lhs, const mint& rhs) {
        return lhs._v != rhs._v;
    }

  private:
    unsigned int _v;
    static internal::barrett bt;
    static unsigned int umod() { return bt.umod(); }
};
template <int id> internal::barrett dynamic_modint<id>::bt(998244353);

using modint998244353 = static_modint<998244353>;
using modint1000000007 = static_modint<1000000007>;
using modint = dynamic_modint<-1>;

namespace internal {

template <class T>
using is_static_modint = std::is_base_of<internal::static_modint_base, T>;

template <class T>
using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;

template <class> struct is_dynamic_modint : public std::false_type {};
template <int id>
struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};

template <class T>
using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;

}  // namespace internal

}  // namespace atcoder

//using mint = atcoder::modint998244353;
using mint = atcoder::modint1000000007;
using vm = std::vector<mint>;
std::ostream& operator << (std::ostream& out, const mint& rhs) {
        return out<<rhs.val();
    }
#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

vector<vm> dp;
const lli MX = 1001;

// Ref - https://www.codechef.com/viewsolution/41909444 Line 827 - 850.
const int maxnCr=2e3+5;
array<mint,maxnCr+1> fac,inv;

mint nCr(lli n,lli r)
{
    if(n<0||r<0||r>n)
        return 0;
    return fac[n]*inv[r]*inv[n-r];
}

void prencr(lli n)
{
    fac[0]=1;
    for(int i=1;i<=n;++i)
        fac[i]=i*fac[i-1];
    inv[n]=fac[n].pow(mint(-2).val());
    for(int i=n;i>0;--i)
        inv[i-1]=i*inv[i];
    assert(inv[0]==mint(1));
}


void pre(){
    if(nCr(10,5)==0)
        prencr(maxnCr);
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        pre();
        mint ans = 0;
        for(lli t=1;t<=x;t++){
            mint cur = 0;

            for(lli i=0;i<=t;i++)
                cur+=mint(t-i).pow(n)*mint(-1).pow(i)*nCr(t,i);

            cur*=nCr(x,t);
            cur*=mint(y).pow(t);
            ans+=cur;
        }
        return ans.val();
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    cout<<""Ans:""<<s.numberOfWays(1,2,3)<<"":Fn""<<endl;
    cout<<""Ans:""<<s.numberOfWays(5,2,1)<<"":Fn""<<endl;
    cout<<""Ans:""<<s.numberOfWays(3,3,4)<<"":Fn""<<endl;
    return 0;
}
#endif",1420040518
YouTube Aryan,youtube_aryanc403,30,3605,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/

#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

const lli Lg = 30;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> res;
        const lli INF = 1e18;
        for(const auto &c:a){
            lli cur = INF;

            for(lli j=0;j<Lg;j++){
                if((c&(1LL<<j))==0)
                    break;
                cur=min(cur,c^(1LL<<j));
            }

            if(cur>=INF)
                cur=-1;
            res.push_back(cur);
        }
        return res;
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    // cout<<""Ans:""<<s.runSoln(20)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(100)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(1000)<<"":Fn""<<endl;
    return 0;
}
#endif
",1420020070
YouTube Aryan,youtube_aryanc403,30,3611,cpp,"/*
  Compete against Yourself.
  Author - Aryan (@aryanc403)
*/
/*
  Credits -
  Atcoder library - https://atcoder.github.io/ac-library/production/document_en/ (namespace atcoder)
  Github source code of library - https://github.com/atcoder/ac-library/tree/master/atcoder
  https://codeforces.com/contest/4/submission/150120627
*/

#ifdef ARYANC403
    #include <header.h>
#else
    #pragma GCC optimize (""Ofast"")
    #pragma GCC target (""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")
    #pragma GCC optimize (""-ffloat-store"")
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    #define dbg(args...) 42;
    #define endl ""\n""
#endif

// y_combinator from @neal template https://codeforces.com/contest/1553/submission/123849801
// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html
template<class Fun> class y_combinator_result {
    Fun fun_;
public:
    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }
};
template<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }

using namespace std;
#define fo(i,n)   for(i=0;i<(n);++i)
#define repA(i,j,n)   for(i=(j);i<=(n);++i)
#define repD(i,j,n)   for(i=(j);i>=(n);--i)
#define all(x) begin(x), end(x)
#define sz(x) ((lli)(x).size())
#define eb emplace_back
#define X first
#define Y second

using lli = long long int;
using mytype = long double;
using ii = pair<lli,lli>;
using vii = vector<ii>;
using vi = vector<lli>;

template <class T>
using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;
// X.find_by_order(k) return kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

const lli Lg = 30;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> res;
        const lli INF = 1e18;
        for(const auto &c:a){
            lli cur = INF;

            for(lli j=0;j<Lg;j++){
                if((c&(1LL<<j))==0)
                    break;
                cur=min(cur,c^(1LL<<j));
            }

            if(cur>=INF)
                cur=-1;
            res.push_back(cur);
        }
        return res;
    }
};

#ifdef LOCAL
int main()
{
    Solution s;
    // cout<<""Ans:""<<s.runSoln(20)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(100)<<"":Fn""<<endl;
    // cout<<""Ans:""<<s.runSoln(1000)<<"":Fn""<<endl;
    return 0;
}
#endif
",1420019411
Rakesh_Reddy7,Addula_Rakesh7,31,3487,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        m, n = len(pattern), len(source)
        st = set(targetIndices)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        ks = 0
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1]:
                    if i not in st:
                        dp[j] = min(dp[j], dp[j-1])
                    else:
                        dp[j] = min(dp[j], dp[j-1] + 1)
        ans = (source, pattern, targetIndices)
        if dp[m] <= len(targetIndices):
            return len(targetIndices) - dp[m]
            pass
        return 0
",1420032253
Rakesh_Reddy7,Addula_Rakesh7,31,3604,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod = 10**9 + 7
        l = [[0] * (x + 1) for _ in range(n + 1)]
        l[0][0] = 1

        for i in range(1, n + 1):
            for k in range(1, min(x, i) + 1):
                l[i][k] = (k * l[i - 1][k] + l[i - 1][k - 1]) % mod

        ans = 0
        P = 1
        for k in range(1, min(x, n) + 1):
            P = P * (x - k + 1) % mod
            pow2 = self.mod_pow(y, k, mod)
            ans = (ans + P * l[n][k] % mod * pow2 % mod) % mod

        return ans

    def mod_pow(self, base: int, exp: int, mod: int) -> int:
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = result * base % mod
            base = base * base % mod
            exp //= 2
        return result
",1420005977
Rakesh_Reddy7,Addula_Rakesh7,31,3605,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for j in nums:
            ok = False
            for i in range(j):
                if i | (i + 1) == j:
                    res.append(i)
                    ok = True
                    break
            if not ok:
                res.append(-1)
                pass

        return res",1420011932
Rakesh_Reddy7,Addula_Rakesh7,31,3611,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret
    

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        d = 0
        for i in nums:
            if i == 2:
                res.append(-1)
                continue
                pass

            mini = -1
            powm = i.bit_length() 
            for k in reversed(range(powm)):
                c = 1 << k
                if c > i:
                    continue
                    pass
                a = i - c
                if a >= 0 and (a | (a + 1)) == i:
                    if mini == -1 or a < mini:
                        mini = a
                        d = 1
            res.append(mini)
            temp = (nums)
        return res",1420022568
Kseniia,kseniiastrelbytska,32,3487,cpp,"class Solution {
public:
    typedef long long ll;

    int maxRemovals(string a, string b, vector<int>& d) {
        ll n = a.size(), m = b.size();

        a = ""#"" + a, b = ""#"" + b;
        vector<vector<ll>> dp(n + 1, vector<ll> (m + 1, (ll)(1e9)));

        for(int i = 0; i <= n; i++)
            dp[i][0] = 0;

        vector<ll> c(n + 1);
        for(auto i: d)
            c[i + 1] = 1;

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                dp[i][j] = dp[i - 1][j];

                if(a[i] == b[j])
                    dp[i][j] = min(dp[i][j], c[i] + dp[i - 1][j - 1]);
            }
        }

        return (ll)(d.size()) - dp[n][m];
    }
};",1420023271
Kseniia,kseniiastrelbytska,32,3604,cpp,"class Solution {
public:
    typedef long long ll;

    ll const mod = (ll)(1e9 + 7);

    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> dp(n + 1, vector<ll> (x + 1));

        dp[1][1] = x;

        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= x; j++){
                dp[i][j] = ((dp[i - 1][j] * (ll)j) % mod + (dp[i - 1][j - 1] * (x - j + 1)) % mod) % mod;
            }
        }

        ll cur = 1;
        ll ans = 0;

        for(int j = 1; j <= x; j++){
            cur = (cur * y) % mod;

            ans = (ans + (cur * dp[n][j]) % mod) % mod;
        }

        return ans;
    }
};",1420041347
Kseniia,kseniiastrelbytska,32,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i: nums){
            int c = -1;
            for(int j = 0; j <= 1024; j++){
                if((j | (j + 1)) == i){
                    c = j;
                    break;
                }
            }
            ans.push_back(c);
        }

        return ans;
    }
};",1419994580
Kseniia,kseniiastrelbytska,32,3611,cpp,"
class Solution {
public:
typedef long long ll;

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i: nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }

            for(ll j = 0; j <= 32; j++){
                if(((ll)i >> j) % 2 == 0){
                    ans.push_back((ll)i ^ (1ll << (j - 1)));
                    break;
                }
            }
        }

        return ans;
    }
};",1420003559
pereigroxshik,pereigroxshik,33,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& T) {
        int n = s.size();
        vector<int> c(n);
        for (int i : T)
        {
            c[i] = 1;
        }
        int m = t.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,(int)-1e9));
        dp[0][0] = 0;
        for (int i = 1;i<=n;i++)
        {
            dp[i] = dp[i-1];
            char ch = s[i-1];
            for (int j = 0;j<=m;j++)
            {
                if (j < m && t[j] == ch)
                {
                    dp[i][j+1] = max(dp[i][j+1],dp[i-1][j]);
                }
                if (c[i-1]) dp[i][j] = max(dp[i][j],dp[i-1][j]+1);
            }
        }
        return dp[n][m];
    }
};",1420029010
pereigroxshik,pereigroxshik,33,3604,cpp,"#define ll long long int
ll mod = 1e9+7;
ll binpow(ll n,ll k = mod-2,ll M = mod)
{
	bitset<31> o(k);
	ll curr = 1;
	for (ll e = 30;e>-1;e--)
	{
		curr *= curr;
		curr %= M;
		if (o[e])
		{
			curr *= n;
			curr %= M;
		}
	}
	return curr;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> dp(n+1,vector<ll>(x+2));
        dp[0][0] = 1;
        for (ll i = 1;i<=n;i++)
        {
            for (ll j = 0;j<=x;j++)
            {
                dp[i][j] += dp[i-1][j]*j;
                dp[i][j] %= mod;
                dp[i][j+1] += dp[i-1][j]*(x-j);
                dp[i][j+1] %= mod;
            }
        }
        ll answer = 0;
        for (ll j = 1;j<=x;j++)
        {
            answer += dp[n][j]*binpow(y,j);
            answer %= mod;
        }
        return answer;
    }
};",1420041977
pereigroxshik,pereigroxshik,33,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for (int i = 0;i<nums.size();i++)
        {
            for (int j = 0;j<=nums[i];j++)
            {
                if ((j|(j+1)) == nums[i])
                {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419997885
pereigroxshik,pereigroxshik,33,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for (int i = 0;i<nums.size();i++)
        {
            int x = nums[i];
            if (nums[i] == 2) continue;
            for (int j = 0;j<40;j++)
            {
                if (!((1ll << j)&x))
                {
                    ans[i] = x-(1ll << (j-1));
                    break;
                }
            }
        }
        return ans;
    }
};",1420008130
TimeGoGo,TimeGoGo,34,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        target_set = set(targetIndices)
        INF = float('inf')
        dp = [INF] * (m + 1)
        dp[0] = 0 

        for i in range(n):
            for j in range(min(i+1, m)-1, -1, -1):
                if source[i] == pattern[j]:
                    cost = dp[j] + (1 if i in target_set else 0)
                    if dp[j + 1] > cost:
                        dp[j + 1] = cost

        if dp[m] == INF:
            return 0  
        else:
            return len(targetIndices) - dp[m]",1420037586
TimeGoGo,TimeGoGo,34,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7
        MAX = n + x + 10
        fact = [1] * MAX
        inv_fact = [1] * MAX
        for i in range(1, MAX):
            fact[i] = (fact[i - 1] * i) % MOD

        inv_fact[MAX - 1] = pow(fact[MAX - 1], MOD - 2, MOD)
        for i in range(MAX - 2, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

        def comb(n, k):
            if k < 0 or k > n:
                return 0
            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD

        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
            for j in range(1, i + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD

        total = 0
        min_k = min(n, x)
        pow_y = [1] * (min_k + 2)
        for k in range(1, min_k + 1):
            pow_y[k] = pow(y, k, MOD)

        for k in range(1, min_k + 1):
            ways = comb(x, k)
            ways = (ways * S[n][k]) % MOD
            ways = (ways * fact[k]) % MOD
            ways = (ways * pow_y[k]) % MOD
            total = (total + ways) % MOD

        return total",1420042466
TimeGoGo,TimeGoGo,34,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        
        for num in nums:
            found = False
            for i in range(num):
                if (i | (i + 1)) == num:
                    ans.append(i)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans",1419993912
TimeGoGo,TimeGoGo,34,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            min_x = -1
            for k in range(31):
                x = N - (1 << k)
                if x >= 0 and (x | (x + 1)) == N:
                    if min_x == -1 or x < min_x:
                        min_x = x
            ans.append(min_x)
        return ans",1420023637
Farras Faddila,donbasta,38,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int m = source.length();
        int n = pattern.length();
        int dp[m][n], cnt[m];
        memset(dp, -1, sizeof(dp));
        memset(cnt, 0, sizeof(cnt));

        bool target[m];
        memset(target, false, sizeof(target));

        for (auto t : targetIndices) target[t] = true;
        for (int i = 0; i < m; i++) {
            cnt[i] = (i ? cnt[i - 1] : 0) + target[i];
        }
    
        for (int i = 0; i < m; i++) {
            if (i == 0) {
                if (source[0] == pattern[0]) dp[0][0] = 0;
            } else {
                for (int j = 0; j < n; j++) {
                    if (dp[i - 1][j] != -1) {
                        dp[i][j] = max(dp[i][j], dp[i - 1][j] + (target[i]));
                    }
                    if (source[i] == pattern[j]) {
                        if (j >= 1 && dp[i - 1][j - 1] != -1) {
                            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                        } else if (j == 0) {
                            dp[i][j] = max(dp[i][j], cnt[i - 1]);
                        }
                    }
                }
            }
        }
        return dp[m - 1][n - 1];
    }
};",1420046634
Farras Faddila,donbasta,38,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int pw = 1;
        int ans = 0;

        const int MOD = 1e9 + 7;
        int C[1001][1001];
        memset(C, 0, sizeof(C));
        C[0][0] = 1;
        for (int i = 1; i <= 1000; i++) {
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (1ll * C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        auto fpow = [&](int a, int b) -> int {
            int ret = 1;
            while (b) {
                if (b & 1) ret = (1ll * ret * a) % MOD;
                a = (1ll * a * a) % MOD;
                b >>= 1;
            }
            return ret;
        };

        for (int k = 1; k <= x; k++) {
            if (k > n) break;
            int st = C[x][k];
            pw = (1ll * pw * y) % MOD;
            int sc = pw;
            int inex = 0;
            for (int l = 0; l <= k; l++) {
                int A = C[k][l];
                int B = fpow((k - l), n);
                int tmp = (1ll * A * B) % MOD;
                if (l & 1) {
                    inex = (inex - tmp) % MOD;
                } else {
                    inex = (inex + tmp) % MOD;
                }
            }
            int lmao = (1ll * st * sc) % MOD;
            lmao = (1ll * lmao * inex) % MOD;
            ans = (1ll * ans + lmao) % MOD;
        }
        ans %= MOD;
        if (ans < 0) ans += MOD;
        return ans;
    }
};",1420025633
Farras Faddila,donbasta,38,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                ans[i] = -1;
                continue;
            } 
            int pos = 0;
            for (int j = 0; j < 30; j++) {
                if (!((nums[i] >> j) & 1)) {
                    pos = j;
                    break;
                }
            }
            ans[i] = (nums[i] - (1 << (pos - 1)));
        }
        return ans;
    }
};",1419999245
Farras Faddila,donbasta,38,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                ans[i] = -1;
                continue;
            } 
            int pos = 0;
            for (int j = 0; j < 30; j++) {
                if (!((nums[i] >> j) & 1)) {
                    pos = j;
                    break;
                }
            }
            ans[i] = (nums[i] - (1 << (pos - 1)));
        }
        return ans;
    }
};",1419998849
penguinzzz,penguinzzz,39,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& a) {
        int n = s.size();
        int m = p.size();
        set<int> idx(a.begin(), a.end());
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        auto rec = [&](auto&& rec, int i, int j) -> int {
            if (j == m) return 0;
            if (i == n) return 1e6;
            if(dp[i][j]!=-1) return dp[i][j];
            int ans = INT_MAX;
            if (s[i] == p[j]) {
                ans = min(ans, rec(rec, i + 1, j + 1) + (int)(idx.find(i) != idx.end()));
            }
            ans = min(ans, rec(rec, i + 1, j));
            return dp[i][j]=ans;
        };
        return a.size() - rec(rec, 0, 0);
    }
};
",1420023031
penguinzzz,penguinzzz,39,3604,cpp,"const int MOD = 1000000007;
vector<long long> fact;


long long power(int a, int b, int m = MOD) {
    if (a == 0) return 0LL;
    if (b == 0) return 1LL;
    long long result = 1;
    long long base = a % m;
    while (b > 0) {
        if (b % 2 == 1) {
            result = (result * base) % m;
        }
        base = (base * base) % m;
        b /= 2;
    }
    return result;
}


void factorial(int n, int m = MOD) {
    fact.assign(n + 1, 0);
    fact[0] = 1;
    for (int i = 1; i <= n; i++) {
        fact[i] = (i * 1LL * fact[i - 1]) % m;
    }
}


long long inverse(int x, int m = MOD) {
    return power(x, m - 2, m);
}


long long nCr(long long n, long long r, int m = MOD) {
    if (r > n) return 0;
    long long x = (fact[r] * fact[n - r]) % m;
    long long y = fact[n];
    return (y * inverse(x, m)) % m;
}

long long count(int n, int x) {
    long long result = 0;
    
    for (int k = 0; k <= x; ++k) {
        long long sign = (k % 2 == 0) ? 1 : -1;
        long long term = (sign * nCr(x, k) % MOD) * power(x - k, n, MOD) % MOD;
        result = (result + term + MOD) % MOD;
    }
    
    return result;
}

class Solution {
public:

    int numberOfWays(int n, int x, int y) {
        factorial(1001);
        long long ans = 0;
        
        for (int i = 1; i <= x; i++) {
            // There are i bands
            long long term = (power(y, i, MOD) * count(n, i)) % MOD;
            term = (term * nCr(x, i)) % MOD;
            ans = (ans + term) % MOD;
        }
        
        return (int)ans;
    }
};
",1420038488
penguinzzz,penguinzzz,39,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            int x=nums[i];
            if(nums[i]==2){
                ans[i]=-1;
            }else{
                int curr=0;
                for(int j=0;j<31;j++){
                    if(x>>j&1) curr|=(1<<j);
                    else break;
                }
                ans[i]=(x^(curr))|(curr/2);
            }
        }
        return ans;
    }
};",1420006569
penguinzzz,penguinzzz,39,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            int x=nums[i];
            if(nums[i]==2){
                ans[i]=-1;
            }else{
                int curr=0;
                for(int j=0;j<31;j++){
                    if(x>>j&1) curr|=(1<<j);
                    else break;
                }
                ans[i]=(x^(curr))|(curr/2);
            }
        }
        return ans;
    }
};",1420006336
Turkhuu Batbayar,Turkhuu,43,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n = s.size(), m = t.size();
        vector<bool> f(n);
        for (auto i : a) {
            f[i] = 1;
        }
        vector dp(n + 1, vector<int>(m + 1, -1e9));
        dp[0][0] = 0;
        for (int i = 0; i < n; i++) {
            dp[i + 1] = dp[i];
            if (f[i]) {
    for (int j = 0; j <= m; j++) {
        dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
    }}
            for (int j = 0; j < m; j++) {
                if (s[i] == t[j]) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
            }
            
        }
        return dp[n][m];
    }
};",1420006935
Turkhuu Batbayar,Turkhuu,43,3604,cpp,"template<class T> T power(T a, long long b) {
    T s = 1; for (; b; a *= a, b >>= 1) if (b & 1) s *= a; return s;
}
template<int mod> struct modular {
    using mint = modular;
    int v;
    modular() : v(0) {}
    modular(long long x) {if ((v = x % mod) < 0) v += mod;}
    mint operator-() const {return -v;}
    mint inv() const {return power(*this, mod - 2);}
    mint &operator+=(const mint &a) {if ((v += a.v) >= mod) v -= mod; return *this;}
    mint &operator-=(const mint &a) {if ((v -= a.v) < 0) v += mod; return *this;}
    mint &operator*=(const mint &a) {v = (int)((long long)v * a.v % mod); return *this;}
    mint &operator/=(const mint &a) {return *this *= a.inv();}
    friend bool operator==(const mint &a, const mint &b){return a.v == b.v;}
    friend bool operator!=(const mint &a, const mint &b){return a.v != b.v;}
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend istream &operator>>(istream &is, mint &a) {return is >> a.v;}
    friend ostream &operator<<(ostream &os, const mint &a) {return os << a.v;}
};
const int mod = 1000000007;
using mint = modular<mod>;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector C(1001, vector<mint>(1001));
        for (int i = 0; i <= 1000; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
            }
        }
        vector dp(n + 1, vector<mint>(x + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= x; j++) {
                dp[i][j] += dp[i - 1][j] * j;
                if (j < x) {
                    dp[i][j + 1] += dp[i - 1][j] * (x - j);
                }
            }
        }
        mint ans = 0;
        for (int i = 1; i <= x; i++) {
            ans += dp[n][i] * power(mint(y), i);
        }
        return ans.v;
    }
};",1420039813
Turkhuu Batbayar,Turkhuu,43,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for (auto x : a) {
            if (x == 2) {
                ans.push_back(-1);
            } else {
                int i = 0;
                while ((((long long)x) >> (i + 1) & 1) == 1) {
                    i++;
                }
                ans.push_back(x - (1 << i));
            }
        }
        return ans;
    }
};",1419997353
Turkhuu Batbayar,Turkhuu,43,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for (auto x : a) {
            if (x == 2) {
                ans.push_back(-1);
            } else {
                int i = 0;
                while ((((long long)x) >> (i + 1) & 1) == 1) {
                    i++;
                }
                ans.push_back(x - (1 << i));
            }
        }
        return ans;
    }
};",1419997110
cuy21,cuy21,44,3487,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n=s.size(),m=p.size(),tt=t.size();
        vector<bool> isT(n,false);
        FORE(i,t)isT[i]=true;
        const int inf=1e9;
        vector<int> dp(m+1,inf);
        dp[0]=0;
        FOR(i,0,n){
            for(int j=min(m,i+1);j>=1;--j){
                if(s[i]==p[j-1]){
                    dp[j]=min(dp[j],dp[j-1]+(isT[i]?1:0));
                }
            }
        }
        if(dp[m]==inf)return 0;
        int k_max=tt-dp[m];
        return max(k_max,0);
    }
};",1420039833
cuy21,cuy21,44,3604,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int M = 1000000007;
        vector<vector<long>> c(x+1,vector<long>(x+1,0));
        c[0][0]=1;
        FOR(i,1,x+1){
            c[i][0]=1;
            FOR(j,1,i+1)c[i][j]=(c[i-1][j-1]+c[i-1][j])%M;
        }
        int mk=min(x,n);
        vector<vector<long>> s(n+1,vector<long>(mk+1,0));
        s[0][0]=1;
        FOR(i,1,n+1){
            FOR(j,1,min(i,mk)+1)s[i][j]=(s[i-1][j-1]+((long)j*s[i-1][j])%M)%M;
        }
        vector<long> f(mk+1,1);
        FOR(i,1,mk+1)f[i]=(f[i-1]*i)%M;
        vector<long> py(mk+1,1);
        FOR(i,1,mk+1)py[i]=(py[i-1]*y)%M;
        vector<int> l={n,x,y};
        long tw=0;
        FOR(k,1,mk+1){
            long t=(c[x][k]*s[n][k])%M;
            t=(t*f[k])%M;
            t=(t*py[k])%M;
            tw=(tw+t)%M;
        }
        return (int)tw;
    }
};",1420006753
cuy21,cuy21,44,3605,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss
class Solution {
public:
    int solve(long p){
        int c=0;
        while((p&1)==1){c++;p>>=1;}
        return c;
    }
    
    vector<int> minBitwiseArray(vector<int>& n) {
        vi a;
        FORE(p,n){
            int c=solve(p);
            if(c==0)a.PB(-1);
            else{
                long x=(long)p-(1L<<(c-1));
                if((x|(x+1))==p)a.PB((int)x);
                else a.PB(-1);
            }
        }
        return a;
    }
};",1419996809
cuy21,cuy21,44,3611,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss
class Solution {
public:
    int solve(long p){
        int c=0;
        while((p&1)==1){c++;p>>=1;}
        return c;
    }
    
    vector<int> minBitwiseArray(vector<int>& n) {
        vi a;
        FORE(p,n){
            int c=solve(p);
            if(c==0)a.PB(-1);
            else{
                long x=(long)p-(1L<<(c-1));
                if((x|(x+1))==p)a.PB((int)x);
                else a.PB(-1);
            }
        }
        return a;
    }
};",1419996429
AADITYA BHARGAV,beunique_18,45,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        inTarget = [False] * n
        for idx in targetIndices:
            inTarget[idx] = True

        positions_in_S = [[] for _ in range(len(pattern))]
        char_positions = {}
        for idx, ch in enumerate(source):
            if ch not in char_positions:
                char_positions[ch] = []
            char_positions[ch].append(idx)

        for idx, ch in enumerate(pattern):
            if ch not in char_positions:
                return 0
            positions_in_S[idx] = char_positions[ch]

        dp_prev = {}
        for pos in positions_in_S[0]:
            dp_prev[pos] = int(inTarget[pos])

        for i in range(1, m):
            positions = positions_in_S[i]
            prev_positions = sorted(dp_prev.keys())
            dp_curr = {}
            min_dp_prev = float('inf')
            idx_prev = 0
            prev_positions_sorted = sorted(prev_positions)
            positions_sorted = sorted(positions)
            idx_prev = 0
            min_dp = [float('inf')] * len(positions_sorted)
            idx = 0
            min_dp_prev = float('inf')
            for pos in positions_sorted:
                while idx_prev < len(prev_positions_sorted) and prev_positions_sorted[idx_prev] < pos:
                    min_dp_prev = min(min_dp_prev, dp_prev[prev_positions_sorted[idx_prev]])
                    idx_prev += 1
                if min_dp_prev != float('inf'):
                    dp_curr[pos] = min_dp_prev + int(inTarget[pos])
            dp_prev = dp_curr
            if not dp_prev:
                return 0  

        if not dp_prev:
            return 0
        minimal_count = min(dp_prev.values())
        return len(targetIndices) - minimal_count
",1420025111
AADITYA BHARGAV,beunique_18,45,3604,python3,"from typing import List

MOD = 10**9 + 7
MAXN = 1005

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        factorial = [1] * (MAXN)
        inv_factorial = [1] * (MAXN)
        for i in range(1, MAXN):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_factorial[MAXN - 1] = pow(factorial[MAXN - 1], MOD - 2, MOD)
        for i in range(MAXN - 2, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

        def comb(n, k):
            if k < 0 or k > n:
                return 0
            return factorial[n] * inv_factorial[k] % MOD * inv_factorial[n - k] % MOD

        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
            for j in range(1, i + 1):
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD

        total = 0
        min_k = min(n, x)
        y_powers = [1] * (min_k + 2)
        for i in range(1, min_k + 2):
            y_powers[i - 1] = pow(y, i - 1, MOD)

        for k in range(1, min_k + 1):
            comb_xk = comb(x, k)
            perm_k = factorial[k]
            stirling = S[n][k]
            yk = y_powers[k]
            term = comb_xk * perm_k % MOD * stirling % MOD * yk % MOD
            total = (total + term) % MOD
        return total
",1420031819
AADITYA BHARGAV,beunique_18,45,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = False
            for i in range(num + 1):
                if i | (i + 1) == num:
                    ans.append(i)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans
",1419994056
AADITYA BHARGAV,beunique_18,45,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans_list = []
        for p in nums:
            ans = -1
            for r in range(32):  
                x = p - (1 << r)
                if x >= 0:
                    if (x | (x + 1)) == p:
                        if ans == -1 or x < ans:
                            ans = x
            ans_list.append(ans)
        return ans_list
",1420011460
nikatamliani1,nikatamliani1,46,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n = (int)s.size(), m = (int)a.size(), k = (int)t.size();
        vector<int> vis(n + 1);
        for (int i : a) {
            vis[i + 1] = 1;
        }
        s = ""#"" + s;
        t = ""#"" + t + ""#"";
        vector<vector<int>> dp(n + 1, vector<int>(m + 2, -(int)1e9));
        dp[0][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int p = 0; p <= m; ++p) {
                int v = dp[i - 1][p];
                if (v < 0) {
                    continue;
                }
                if (vis[i]) {
                    dp[i][p + 1] = max(dp[i][p + 1], v);
                }

                if (s[i] == t[v + 1]) {
                    dp[i][p] = max(dp[i][p], dp[i - 1][p] + 1);
                } else {
                    dp[i][p] = max(dp[i][p], dp[i - 1][p]);
                }
            }
            // cout << i << "": "";
            // for (int p = 0; p <= m; ++p) {
            //     cout << dp[i][p] << ' ';
            // }
            // cout << '\n';
        }

        int ans = 0;
        for (int i = 0; i <= m; ++i) {
            if (dp[n][i] == k) {
                ans = max(ans, i);
            }
        }
        return ans;
    }
};",1420013599
nikatamliani1,nikatamliani1,46,3604,cpp,"class Solution {
public:
    #define ll long long

    ll bpow(ll x, ll y, ll MOD) {
        ll ans = 1;
        while (y > 0) {
            if (y & 1) {
                ans = ans * x % MOD;
            }
            x = x * x % MOD;
            y >>= 1;
        }
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        const ll N = 1005, MOD = 1e9 + 7;
        ll c[N][N];

        c[0][0] = 1;
        for (int i = 1; i < N; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

        ll dp[N][N];
        dp[0][0] = 1;
        for (int n = 1; n < N; ++n) {
            for (int x = 1; x < N; ++x) {
                dp[n][x] = 1LL * (dp[n - 1][x - 1] + dp[n - 1][x]) * x % MOD;
            }

        }

        ll total = 0;
        for (int i = 1; i <= min(n, x); ++i) {
            ll a = c[x][i];
            ll b = dp[n][i];
            ll c = bpow(y, i, MOD);
            total += a * b % MOD * c % MOD;
            total %= MOD;
        }
        return total;
    }
};",1420049191
nikatamliani1,nikatamliani1,46,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
            } else {
                int v = i;
                int x = i;
                for (int bit = 0; bit < 31; ++bit) {
                    if (x >> bit & 1) {
                    } else {
                        if (bit > 0) {
                            v ^= 1LL << bit - 1;
                        }
                        break;
                    }
                }
                ans.push_back(v);
            }
        }
        return ans;
    }
};",1419996004
nikatamliani1,nikatamliani1,46,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
            } else {
                int v = i;
                int x = i;
                for (int bit = 0; bit < 31; ++bit) {
                    if (x >> bit & 1) {
                    } else {
                        if (bit > 0) {
                            v ^= 1LL << bit - 1;
                        }
                        break;
                    }
                }
                ans.push_back(v);
            }
        }
        return ans;
    }
};",1419995599
Mike Qi,mikeqiyh,51,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tar) {
        int n = len(s), m = len(p);
        vi bad(n+5, 0); for (int x: tar) bad[x+1] = 1;
        vvi dp(n+3, vi(m+3, INF));
        dp[0][0] = 0;
        s = '#'+s; p = '#'+p;
        for (int i = 1; i <= n; i++){
            for (int j = 0; j <= m; j++){
                dp[i][j] = dp[i-1][j];
                if (j && p[j] == s[i]){
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]+bad[i]);
                } 
            }
        }
        return siz(tar)-dp[n][m];
    }
};",1420042751
Mike Qi,mikeqiyh,51,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
const int MAX = 2e3+4;
mi fac[MAX], facI[MAX];
bool done;

mi nck(int n, int k){
    if (k > n) return 0;
    return fac[n]*facI[k]*facI[n-k];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if (!done){
            done = true;
            fac[0] = 1; facI[0] = 1;
            for (int i = 1; i < MAX; i++){
                fac[i] = fac[i-1]*i;
                facI[i] = inv(fac[i]);
            }
        }
        mi tot = 0;
        vector<mi> dp(min(n, x)+5, 0);
        for (int i = 1; i <= min(n, x); i++){
            mi a = i, b = y;
            dp[i] = pow(a, n);
            for (int j = 1; j < i; j++){
                dp[i] -= nck(i, j)*dp[j];
            }
            mi cur = dp[i]*nck(x, i)*pow(b, i);
            tot += cur;
            //deb((int)tot, (int)dp[i]);
        }
        return (int)tot;
    }
};",1420044062
Mike Qi,mikeqiyh,51,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi ret;
        for (int x: nums){
            if (x == 2){
                ret.pb(-1); continue;
            }
            for (int i = 0; i <= 30; i++){
                if (((1<<i)&x) == 0){
                    ret.pb(x^(1<<(i-1)));
                    break;
                }
            }
        }
        return ret;
    }
};",1420043275
Mike Qi,mikeqiyh,51,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize(""O3,unroll-loops"")
#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pi;
typedef pair<ll, ll> pll;
typedef vector<bool> vb;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pi> vpi;
typedef vector<pll> vpll;
typedef vector<ld> vld;
#define ms(x, a) memset(x, a, sizeof(x))
#define siz(x) (int)x.size()
#define len(x) (int)x.length()
#define pb push_back
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define F first
#define S second
#define FOR(i, x) for (int i = 0; i < x; i++)
const int NO_DEB = 0;
#define deb(...) logger(#__VA_ARGS__, __VA_ARGS__)
template <typename... Args>
void logger(string vals, Args &&...values){
    if (NO_DEB) return;
    cout << vals << "" = "";
    string delim = """";
    (..., (cout << delim << values, delim = "", ""));
    cout << endl;
}
const int INF = 0x3f3f3f3f;
const ll LLINF = 0x3f3f3f3f3f3f3f3f;
const ll MOD = 1e9+7; //998244353;
//===========================================
template<int MOD> struct mint {
    static const int mod = MOD;
     int v;
     explicit operator int() const { return v; }
    mint():v(0) {}
    mint(ll _v):v(int(_v%MOD)) { v += (v<0)*MOD; }
    mint& operator+=(mint o) {
        if ((v += o.v) >= MOD) v -= MOD;
        return *this; }
    mint& operator-=(mint o) {
        if ((v -= o.v) < 0) v += MOD;
        return *this; }
    mint& operator*=(mint o) {
        v = int((ll)v*o.v%MOD); return *this; }
    mint& operator/=(const mint& o) { return (*this) *= inv(o); }
    friend mint pow(mint a, ll p) { assert(p >= 0);
        return p==0?1:pow(a*a,p/2)*(p&1?a:1); }
    friend mint inv(mint a) { assert(a.v != 0); return pow(a,MOD-2); }
    friend mint operator+(mint a, mint b) { return a += b; }
    friend mint operator-(mint a, mint b) { return a -= b; }
    friend mint operator*(mint a, mint b) { return a *= b; }
    friend mint operator/(mint a, const mint& b) { return a /= b; }
};
using mi = mint<MOD>;
//===========================================
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi ret;
        for (int x: nums){
            if (x == 2){
                ret.pb(-1); continue;
            }
            for (int i = 0; i <= 30; i++){
                if (((1<<i)&x) == 0){
                    ret.pb(x^(1<<(i-1)));
                    break;
                }
            }
        }
        return ret;
    }
};",1420042973
Jingzhe Tang,skywalkert,52,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& p) {
        static const int maxn = (int)3e3 + 9;
        static int f[maxn];
        int n = s.size(), m = t.size();
        memset(f, -1, m * sizeof(int));
        f[m] = 0;
        for(int i = n - 1; i >= 0; --i) {
            bool sp = 0;
            if(!p.empty() && p.back() == i) {
                sp = 1;
                p.pop_back();
            }
            for(int j = 0; j <= m; ++j) {
                int tp = f[j];
                if(f[j] != -1)
                    f[j] += sp;
                if(j < m && s[i] == t[j] && f[j + 1] != -1)
                    f[j] = max(f[j], f[j + 1]);
            }
        }
        return f[0];
    }
};",1420048113
Jingzhe Tang,skywalkert,52,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        typedef long long LL;
        static const int maxn = (int)1e3 + 9, mod = (int)1e9 + 7;
        static int bin[maxn][maxn] = {}, pw[maxn][maxn], f[maxn];
        if(!bin[0][0]) {
            for(int i = 0; i < maxn; ++i) {
                bin[i][0] = bin[i][i] = 1;
                for(int j = 1; j < i; ++j)
                    (bin[i][j] = bin[i - 1][j - 1] + bin[i - 1][j]) >= mod && (bin[i][j] -= mod);
            }
            for(int i = 1; i < maxn; ++i) {
                pw[i][0] = 1;
                for(int j = 1; j < maxn; ++j)
                    pw[i][j] = (LL)pw[i][j - 1] * i % mod;
            }
        }
        int ans = 0;
        for(int i = 1; i <= x && i <= n; ++i) {
            f[i] = pw[i][n];
            for(int j = 1; j < i; ++j)
                f[i] = (f[i] - (LL)bin[i][j] * f[j]) % mod;
            f[i] < 0 && (f[i] += mod);
            // printf(""%d: %d\n"", i, f[i]);
        }
        for(int i = min(x, n); i >= 1; --i)
            ans = (ans + (LL)bin[x][i] * f[i]) % mod * y % mod;
        return ans;
    }
};",1420034097
Jingzhe Tang,skywalkert,52,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &x: nums) {
            if(~x & 1) {
                x = -1;
                continue;
            }
            x ^= ((x + 1) & -(x + 1)) >> 1;
        }
        return nums;
    }
};",1420052350
Jingzhe Tang,skywalkert,52,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &x: nums) {
            if(~x & 1) {
                x = -1;
                continue;
            }
            x ^= ((x + 1) & -(x + 1)) >> 1;
        }
        return nums;
    }
};",1420052116
Anuj Anand,coleworld223,56,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
      using i32 = int;
      i32 n = s.size();
      i32 m = p.size();
      vector <bool> imp (n);
      for (i32 x : t) {
        imp[x] = 1;
      }
      vector <vector <i32>> dp (n + 1, vector <i32> (m + 1, -1));
      dp[0][0] = 0;
      for (i32 i = 1; i <= n; ++i) {
        dp[i][0] = 0;
        for (i32 j = 0; j <= m; ++j) {
          if (imp[i - 1]) {
            dp[i][j] = max({dp[i][j], (dp[i - 1][j] != -1 ? dp[i - 1][j] + 1 : -1), (j > 0 ? dp[i - 1][j - (s[i - 1] == p[j - 1])] : -1)});
          }
          else {
            dp[i][j] = max({dp[i][j], dp[i - 1][j],(j > 0 ? dp[i - 1][j - (s[i - 1] == p[j - 1])] : -1)});
          }
        }
      }
      // cout << dp[1][0] << '\n';
      return dp[n][m];
    }
};",1420035694
Anuj Anand,coleworld223,56,3604,cpp,"using i32 = int;
using i64 = long long;
int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
      vector <vector <mi>> dp (n + 1, vector <mi> (x + 1));
      dp[0][0] = 1;
      for (i32 p = 1; p <= n; ++p) {
        for (i32 c = 1; c <= x; ++c) {
          dp[p][c] = (dp[p - 1][c] * c + dp[p - 1][c - 1] * (x - c + 1));
        }
      }
      
      mi ans = 0;
      for (i32 c = 1; c <= x; c++) {
        ans += dp[n][c] * pow((mi) y, c);
      }
      return ans.v;
    }
};",1420053809
Anuj Anand,coleworld223,56,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      using i32 = int;
      i32 n = nums.size();
      vector <int> ans (n, -1);
      for (i32 i = 0; i < n; ++i) {
        for (i32 bit = 0; bit < 31; bit ++) {
          if (!(nums[i] >> bit & 1)) {
            if (bit - 1 >= 0) {
              ans[i] = (nums[i] ^ (1 << (bit - 1)));
            }
            break;
          }
        }
      }
      return ans;
    }
};",1420000464
Anuj Anand,coleworld223,56,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      using i32 = int;
      i32 n = nums.size();
      vector <int> ans (n, -1);
      for (i32 i = 0; i < n; ++i) {
        for (i32 bit = 0; bit < 31; bit ++) {
          if (!(nums[i] >> bit & 1)) {
            if (bit - 1 >= 0) {
              ans[i] = (nums[i] ^ (1 << (bit - 1)));
            }
            break;
          }
        }
      }
      return ans;
    }
};",1420000042
Ryan,ryanwong0127,57,3487,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
// int dp[30005][30005]={0};
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& targetIndices) {
        int n = s.size(), m = p.size();
        int idxCnt = targetIndices.size();
        vi ht(n+1);
        for(auto &x:targetIndices){ht[x] = 1;}
        // set<int> ht(all(targetIndices));
        vvi dp(n+1, vi(m+1, inf));
        
        rep(i, 0, n + 1) dp[i][0] = 0;
        
        rep(i, 1, n+1) {
            rep(j, 0, min(i, m)+1) {
                chmin(dp[i][j], dp[i-1][j]);
                if (j >=1 && s[i-1]==p[j-1]){
                    int cost = dp[i-1][j-1];
                    if (ht[i-1]) {cost++;}
                    chmin(dp[i][j], cost);
                }
            }
        }
        int res = idxCnt - dp[n][m];
        return max(0, res);
    }
};",1420030497
Ryan,ryanwong0127,57,3604,cpp,"#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define rep(i, a, b) for (int i = (a); i < (b); ++i)
#define rep_(i, a, b) for (int i = (a); i > (b); i--)
#define mst(x, a) memset(x, a, sizeof(x))
#define all(a) begin(a), end(a)
#define lowbit(x) ((x) & (-(x)))
#define bitcnt(x) (__builtin_popcountll(x))
#define se second
#define fi first
#define pb push_back
#define maxe max_element
#define mine min_element
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef pair<int, ll> pil;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<vi> vvi;
constexpr static int dirs[4][2] = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
constexpr static int inf = 0x3f3f3f3f, mod = 1e9 + 7;
const ll infl = 0x3f3f3f3f3f3f3f3fll;
template<class T> bool chmax(T &a, T b) {
    if (a >= b) return false;
    a = b; return true;
}
template<class T> bool chmin(T &a, T b) {
    if (a <= b) return false;
    a = b; return true;
}
template<class T> bool chsum(T &a, T b) {
    a = (a + b + mod) % mod;
    return 0;
}
bool INIT = false;
constexpr static int N = 1010;
ll a[N + 1] = {0}, b[N + 1] = {0}, inv[N + 1] = {0};
ll S[N + 1][N + 1] = {1, 0};
ll fact[N + 5] = {1};
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if (!INIT) {
            INIT = 1;
            combInit(N);
            BigInit();
        }
        
        ll res = 0;
        rep(s, 1, min(n, x) + 1) {
            ll cur = comb(x, s);
            cur = cur * fact[s] % mod;
            cur = cur * S[n][s] % mod;
            cur = cur * qpow(y, s) % mod;
            chsum(res, cur);
        }
        return res;
    }
private:
    ll qpow(ll a, int n){
        ll ans = 1;
        while(n) {
            if(n & 1)   {    //n1
                ans = (ans * a) % mod;  //ansa
            }
            a = (a * a) % mod;        //a
            n >>= 1;       //n
        }
        return ans;
    }
    void BigInit() {
        rep(i, 1, N + 1) {
            rep(j, 1, N + 1) {
                S[i][j] = ((j * S[i-1][j] % mod) + S[i-1][j-1])%mod;
            }
        }
        rep(i, 1, N + 1) {
            fact[i] = fact[i - 1] * i % mod;
        }
    }
    void combInit(int n) {
        inv[1] = 1;
        rep(i, 2, n+1) {
            inv[i] = (mod - mod / i) * (ll)inv[mod % i] % mod;
        }
        a[0] = 1;
        b[0] = 1;
        rep(i, 1, n+1) {
            a[i] = (ll)a[i - 1] * i % mod;
            b[i] = (ll)b[i - 1] * inv[i] % mod;
        }
    }
    ll comb(int n, int m) {
        if (n < m || m < 0) {
            return 0;
        }
        return a[n] * b[m] % mod * b[n - m] % mod;
    }
};",1420054009
Ryan,ryanwong0127,57,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        for x in a:
            min_n = -1
            for k in range(32):
                if (x >> k) & 1:
                    n = x & (~(1 << k))
                    r = (1 << k) - 1
                    cand = n | r
                    if cand >= 0 and (cand | (cand +1)) == x:
                        if min_n == -1 or cand < min_n:
                            min_n = cand
            ans.append(min_n)
        return ans",1419997838
Ryan,ryanwong0127,57,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        for x in a:
            min_n = -1
            for k in range(32):
                if (x >> k) & 1:
                    n = x & (~(1 << k))
                    r = (1 << k) - 1
                    cand = n | r
                    if cand >= 0 and (cand | (cand +1)) == x:
                        if min_n == -1 or cand < min_n:
                            min_n = cand
            ans.append(min_n)
        return ans",1419997426
BERNARD BRAHIMCHA,BERNARB01,58,3487,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  int maxRemovals(string s, string t, vector<int>& p) {
    int n = int(s.length());
    int m = int(t.length());
    vector<int> cost(n);
    for (int i : p) {
      cost[i] = 1;
    }
    const int inf = int(1e9) + 9;
    vector<int> dp(m + 1, inf);
    dp[0] = 0;
    for (int i = 0; i < n; i++) {
      vector<int> new_dp(m + 1, inf);
      for (int j = 0; j <= min(i, m); j++) {
        new_dp[j] = min(new_dp[j], dp[j]);
        if (j < m && s[i] == t[j]) {
          new_dp[j + 1] = min(new_dp[j + 1], dp[j] + cost[i]);
        }
      }
      swap(dp, new_dp);
    }
    return int(p.size()) - dp[m];
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1420054081
BERNARD BRAHIMCHA,BERNARB01,58,3604,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int md = int(1e9) + 7;

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

class Solution {
 public:
  int numberOfWays(int n, int x, int y) {
    vector<int> dp(x + 1);
    dp[1] = x;
    for (int i = 1; i < n; i++) {
      vector<int> new_dp(x + 1);
      for (int j = 1; j <= x; j++) {
        add(new_dp[j], mul(j, dp[j]));
        if (j < x) {
          add(new_dp[j + 1], mul(x - j, dp[j]));
        }
      }
      swap(dp, new_dp);
    }
    deb(dp);
    int ans = 0;
    for (int i = 1; i <= x; i++) {
      add(ans, mul(dp[i], po(y, i)));
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  deb(sl.numberOfWays(1, 2, 3));
  deb(sl.numberOfWays(5, 2, 1));
  deb(sl.numberOfWays(3, 3, 4));
}
#endif
",1420001700
BERNARD BRAHIMCHA,BERNARB01,58,3605,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& a) {
    int n = int(a.size());
    vector<int> ans(n);
    for (int i = 0; i < n; i++) {
      if (a[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int x = a[i], cnt = 0;
      while (x & 1) {
        x >>= 1;
        cnt++;
      }
      ans[i] = a[i] ^ (1 << (cnt - 1));
      assert((ans[i] | (ans[i] + 1)) == a[i]);
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1420031347
BERNARD BRAHIMCHA,BERNARB01,58,3611,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& a) {
    int n = int(a.size());
    vector<int> ans(n);
    for (int i = 0; i < n; i++) {
      if (a[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int x = a[i], cnt = 0;
      while (x & 1) {
        x >>= 1;
        cnt++;
      }
      ans[i] = a[i] ^ (1 << (cnt - 1));
      assert((ans[i] | (ans[i] + 1)) == a[i]);
    }
    return ans;
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1420031157
user7338k,user7338k,59,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> can(n);
        for (int a : targetIndices) {
            can[a] = 1;
        }

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        dp[0][0] = 0;
        int ans = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (dp[i][j] == -1) {
                    continue;
                }
                if (j < m && source[i] == pattern[j]) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                if (can[i]) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
                }
            }
        }

        return dp[n][m];
    }
};",1420015064
user7338k,user7338k,59,3604,cpp,"class Solution {
public:
    constexpr static int kMod = 1e9 + 7;
    vector<long long> fact;
    vector<long long> inv;
    vector<vector<long long>> dp;

    int numberOfWays(int n, int x, int y) {
        prep();
        cout << ""prep"" << endl;
        long long ans = 0;
        for (int bn = 1; bn <= x && bn <= n; ++bn) {
            ans = (ans + getAns(n, x, bn) * modPow(y, bn, kMod)) % kMod;
            //cout << bn << "" pw "" << modPow(bn, y, kMod) << endl;
        }
        return ans;
    }

    void prep() {
        fact.resize(1005);
        inv.resize(1005);
        dp.resize(1005, vector<long long>(1005));
        dp[0][0] = 1;
        fact[0] = 1;
        inv[0] = 1;
        for (int i = 1; i < 1005; ++i) {
            fact[i] = (fact[i - 1] * i ) % kMod;
            inv[i] = modPow(fact[i], kMod - 2, kMod);
        }

        // i - people
        // j - groups
        for (int i = 1; i < 1005; ++i) {
            dp[i][0] = 0;
            for (int j = 1; j < 1005; ++j) {
                dp[i][j] = (dp[i - 1][j - 1] + 1LL * j * dp[i - 1][j]) % kMod;
            }
        }
    }

    long long getAns(int n, int x, int st) {
        //cout << ""people "" << n << "" scenes "" << x << "" bands "" << st << endl;
        long long cm = getComb(x, st);
        //cout << cm << "" "" << dp[n][st] << endl;
        long long ans = cm  * dp[n][st] % kMod * fact[st] % kMod;
        //cout << ans << endl;
        return ans;
    }

    long long getComb(long long n, long long k) {
        return fact[n] * inv[k] % kMod * inv[n - k] % kMod;
    }

    int modPow(long long a, long long pw, long long mod) {
        long long ans = 1;
        while (pw) {
            if (pw & 1) {
                ans = (ans * a) % mod;
            }
            a = (a * a) % mod;
            pw /= 2;
        }
        return ans;
    }
};",1420054293
user7338k,user7338k,59,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> ans;
        for (int a : nums) {
            ans.push_back(solve(a));
        }
        return ans;
    }

    int solve(int a) {
        int ans = -1;
        for (int j = 0; j < 30; ++j) {
            int cur = 0;
            for (int k = 0; k < j; ++k) {
                cur |= (1 << k);
            }

            for (int k = j + 1; k < 30; ++k) {
                if (a & (1 << k)) {
                    cur |= (1 << k);
                }
            }

            //cout << j << "" "" << cur << "" "" << (cur |)
            if ((cur | (cur + 1)) == a) {
                if (ans == -1 || cur < ans) {
                    ans = cur;
                }
            }
        }
        return ans;
    }
};",1420003543
user7338k,user7338k,59,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int a : nums) {
            ans.push_back(solve(a));
        }
        return ans;
    }

    int solve(int a) {
        int ans = -1;
        for (int j = 0; j < 30; ++j) {
            int cur = 0;
            for (int k = 0; k < j; ++k) {
                cur |= (1 << k);
            }

            for (int k = j + 1; k < 30; ++k) {
                if (a & (1 << k)) {
                    cur |= (1 << k);
                }
            }

            //cout << j << "" "" << cur << "" "" << (cur |)
            if ((cur | (cur + 1)) == a) {
                if (ans == -1 || cur < ans) {
                    ans = cur;
                }
            }
        }
        return ans;
    }
};",1420002926
mastoori1234,mastoori1234,61,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        
        int ns = s.length();
        int np = p.length();
        int nt = t.size();
        
        vector<bool> valid( ns, false);
        for( int idx: t) {
            valid[idx] = true;
        }
        
        vector< vector<int> > dp( ns, vector<int>( np, -1)); // lcs with cost as targetIds
        
        function<int(int,int)> solve;
        
        solve = [&]( int si, int pi)->int {
            if(pi<0) {
                return 0;
            }
            if(si<0) {
                return 1e4;
            }
            if(dp[si][pi]==-1) {
                dp[si][pi] = np;
                dp[si][pi] = min( dp[si][pi], solve( si-1, pi));
                if(s[si]==p[pi]) {
                    dp[si][pi] = min(
                        dp[si][pi],
                        valid[si]+solve( si-1, pi-1)
                    );
                }
            }
            return dp[si][pi];
        };
        
        int ans = solve( ns-1, np-1);
        
        return nt-ans;
    }
};",1420034540
mastoori1234,mastoori1234,61,3604,cpp,"typedef long long int ll;

ll mod = 1e9+7;

ll ffe( ll a, ll b) {
    if(b==0) {
        return 1;
    } else {
        return (((b%2==1)?a:1)*ffe( (a*a)%mod, b/2))%mod;
    }
}

class Solution {
public:
    int numberOfWays(int N, int X, int Y) {
        
        ll n = N;
        ll x = X;
        ll y = Y;
        
        ll ans = 0;
        
        vector<ll> a(x+1, 0);
        a[0] = 1;
        
        for( ll i=1; i<=n; i++) {      // number of performers
            for( ll j=x; j>=0; j--) {  // number of stages
                if(j+1<=x) {
                    a[j+1] = (a[j+1]+a[j]*(x-j))%mod;
                }
                a[j] = (a[j]*j)%mod;
            }
        }
        
        for( ll i=0; i<=x; i++) {
            a[i] = (a[i]*ffe(y,i))%mod;
            ans = (ans+a[i])%mod;
        }
        
        return ans;
    }
};",1420011148
mastoori1234,mastoori1234,61,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> arr(n);
        
        for( int i=0; i<n; i++) {
            int val = nums[i];
            if(val%2==0) {
                arr[i] = -1;
                continue;
            }
            int t;
            // t = val&(val+1);
            // if(t==0) {
            //     arr[i] = val/2;
            //     continue;
            // }
            t = 0;
            while(val%2==1) {
                t = 2*t+1;
                val = val/2;
            }
            arr[i] = (nums[i]^t)^(t>>1);
        }
        
        return arr;
    }
};",1420055825
mastoori1234,mastoori1234,61,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        int n = nums.size();
        
        vector<int> arr(n);
        
        for( int i=0; i<n; i++) {
            int val = nums[i];
            if(val%2==0) {
                arr[i] = -1;
                continue;
            }
            int t;
            // t = val&(val+1);
            // if(t==0) {
            //     arr[i] = val/2;
            //     continue;
            // }
            t = 0;
            while(val%2==1) {
                t = 2*t+1;
                val = val/2;
            }
            arr[i] = (nums[i]^t)^(t>>1);
        }
        
        return arr;
    }
};",1420055092
geng102810,geng102810,62,3487,cpp,"constexpr int inf=1e9;
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n=s.size(),m=p.size();
        std::vector<int> st(n+2,0);
        for(auto x:t) st[x+1]=1;
        std::vector<std::vector<int>> f(n+2,std::vector<int> (m+2,inf));
        f[0][0]=0;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=m;j++){
                f[i][j]=std::min(f[i][j],f[i-1][j]);
                if(j>=1){
                    char u=s[i-1],v=p[j-1];
                    if(u==v) f[i][j]=std::min(f[i-1][j-1]+st[i],f[i][j]);
                }
            }
            
        }
        int res=0;
        for(int i=0;i<=n;i++){
            if(f[i][m]!=inf) res=std::max(res,(int)t.size()-f[i][m]);
        }
        return res;
    }
};",1420031432
geng102810,geng102810,62,3604,cpp,"template <unsigned M_> struct ModInt {
  static constexpr unsigned M = M_;
  unsigned x;
  constexpr ModInt() : x(0U) {}
  constexpr ModInt(unsigned x_) : x(x_ % M) {}
  constexpr ModInt(unsigned long long x_) : x(x_ % M) {}
  constexpr ModInt(int x_) : x(((x_ %= static_cast<int>(M)) < 0) ? (x_ + static_cast<int>(M)) : x_) {}
  constexpr ModInt(long long x_) : x(((x_ %= static_cast<long long>(M)) < 0) ? (x_ + static_cast<long long>(M)) : x_) {}
  ModInt &operator+=(const ModInt &a) { x = ((x += a.x) >= M) ? (x - M) : x; return *this; }
  ModInt &operator-=(const ModInt &a) { x = ((x -= a.x) >= M) ? (x + M) : x; return *this; }
  ModInt &operator*=(const ModInt &a) { x = (static_cast<unsigned long long>(x) * a.x) % M; return *this; }
  ModInt &operator/=(const ModInt &a) { return (*this *= a.inv()); }
  ModInt pow(long long e) const {
    if (e < 0) return inv().pow(-e);
    ModInt a = *this, b = 1U; for (; e; e >>= 1) { if (e & 1) b *= a; a *= a; } return b;
  }
  ModInt inv() const {
    unsigned a = M, b = x; int y = 0, z = 1;
    for (; b; ) { const unsigned q = a / b; const unsigned c = a - q * b; a = b; b = c; const int w = y - static_cast<int>(q) * z; y = z; z = w; }
    assert(a == 1U); return ModInt(y);
  }
  ModInt operator+() const { return *this; }
  ModInt operator-() const { ModInt a; a.x = x ? (M - x) : 0U; return a; }
  ModInt operator+(const ModInt &a) const { return (ModInt(*this) += a); }
  ModInt operator-(const ModInt &a) const { return (ModInt(*this) -= a); }
  ModInt operator*(const ModInt &a) const { return (ModInt(*this) *= a); }
  ModInt operator/(const ModInt &a) const { return (ModInt(*this) /= a); }
  template <class T> friend ModInt operator+(T a, const ModInt &b) { return (ModInt(a) += b); }
  template <class T> friend ModInt operator-(T a, const ModInt &b) { return (ModInt(a) -= b); }
  template <class T> friend ModInt operator*(T a, const ModInt &b) { return (ModInt(a) *= b); }
  template <class T> friend ModInt operator/(T a, const ModInt &b) { return (ModInt(a) /= b); }
  explicit operator bool() const { return x; }
  bool operator==(const ModInt &a) const { return (x == a.x); }
  bool operator!=(const ModInt &a) const { return (x != a.x); }
  bool operator<(const ModInt &a) const { return (x < a.x); }
  bool operator>(const ModInt &a) const { return (x > a.x); }
  bool operator<=(const ModInt &a) const { return (x <= a.x); }
  bool operator>=(const ModInt &a) const { return (x >= a.x); }
  friend std::ostream &operator<<(std::ostream &os, const ModInt &a) { return os << a.x; }
  friend std::istream &operator>>(std::istream &is, ModInt &a) {int v;is >> v;a = ModInt(v);return is;}
};
constexpr unsigned MO = 1000000007;
using Mint = ModInt<MO>;

constexpr int N=1010,M=1000000007;

Mint aa[N],bb[N];
Mint inv[N];
bool flag=0;

Mint s[N][N];
 
void init(){
    inv[1] = 1;
    for(int i = 2;i < N;i++)  inv[i] = (M -  M / i) * inv[M % i];
    aa[0]=1,bb[0]=1;
    for(int i=1;i<N;i++) aa[i]=(i*aa[i-1]);
    for(int i=1;i<N;i++) bb[i]=(inv[i]*bb[i-1]);
    s[0][0]=1;
    for(int i=1;i<N;i++){
        for(int j=1;j<N;j++) s[i][j]=s[i-1][j-1]+s[i-1][j]*j;
    }
}
 
Mint C(int x, int y) {
    return x < y || y < 0 ? 0 : aa[x] * bb[y]  * bb[x - y] ;
}

Mint S(int x,int y){
    return s[x][y]*aa[y];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(!flag) init(),flag=1;
        int mi=std::max(0,x-n);
        Mint res=0;
        for(int i=mi;i<x;i++){
            res+=C(x,i)*Mint(y).pow(x-i)*S(n,x-i);
        }
        return res.x;
    }
};",1420055928
geng102810,geng102810,62,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        std::vector<int> res(n,-1);
        for(int i=0;i<n;i++){
            int x=nums[i];
            for(int j=0;j<=x;j++){
                if((j|(j+1))==x){
                    res[i]=j;
                    break;
                }
            }
        }
        return res;
    }
};",1419994687
geng102810,geng102810,62,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        std::vector<int> res(n,-1);
        for(int i=0;i<n;i++){
            int x=nums[i];
            if(x&1){
                int t=std::__lg(x);
                if((1<<t)==x) res[i]=x/2;
                else {
                    for(int j=0;j<32;j++){
                        if(!(x>>j&1)){
                            res[i]=x-(1<<(j-1));
                            break;
                        }
                    }
                }
            }
        }
        return res;
    }
};",1420011628
Rahul Kumar Yadav,user0434y,63,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int totalTarget = targetIndices.size();
        
        // Step 1: Mark target indices
        vector<bool> isTarget(n, false);
        for(auto idx : targetIndices){
            isTarget[idx] = true;
        }
        
        // Step 2: Initialize DP array
        // dp[j] = minimum number of target indices used to match first j characters of pattern
        vector<int> dp(m + 1, INT32_MAX);
        dp[0] = 0; // Matching empty pattern requires 0 target indices
        
        // Step 3: Populate DP array
        for(int i = 0; i < n; ++i){
            // Iterate backwards to prevent overwriting dp[j-1] needed for current j
            for(int j = m; j >=1; --j){
                if(source[i] == pattern[j-1]){
                    if(dp[j-1] != INT32_MAX){
                        // If current character is a target index, increment the count
                        int added = isTarget[i] ? 1 : 0;
                        dp[j] = min(dp[j], dp[j-1] + added);
                    }
                }
            }
        }
        
        // Step 4: Determine the result
        if(dp[m] == INT32_MAX){
            // Pattern cannot be formed even without removals
            return 0;
        }
        
        // Maximum number of removals is totalTarget minus the number of target indices used in matching
        // However, some targetIndices might not be used in the matching at all
        // Thus, we need to ensure that we only subtract the targetIndices that are used
        // To find the exact number used, we can trace back the matching
        // But for simplicity, since dp[m] gives the minimal number used, and all targetIndices can be removed except those used
        return totalTarget - dp[m];
    }
};
",1420030046
Rahul Kumar Yadav,user0434y,63,3604,cpp,"class Solution {
public:
    const int MOD = 1'000'000'007;
    
    // computes (base^power) % MOD
    long long powmod(long long base, long long power) {
        long long result = 1;
        base %= MOD;
        while(power > 0){
            if(power & 1){
                result = result * base % MOD;
            }
            base = base * base % MOD;
            power >>=1;
        }
        return result;
    }
    
    int numberOfWays(int n, int x, int y) {
        // Precompute factorial and inverse factorial up to x
        vector<long long> fact(x +1, 1);
        for(int i=1;i<=x;i++) {
            fact[i] = fact[i-1] * i % MOD;
        }
        
        // Precompute inverse factorial using Fermat's little theorem
        vector<long long> inv_fact(x +1, 1);
        inv_fact[x] = powmod(fact[x], MOD -2);
        for(int i=x-1;i>=0;i--){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
        
        // Compute y^k for k=0 to x
        vector<long long> power_y(x +1, 1);
        for(int k=1; k<=x; k++) {
            power_y[k] = power_y[k-1] * y % MOD;
        }
        
        // Compute Stirling numbers of the second kind for k=0 to x
        // Using 1D DP
        vector<long long> dp(x +1, 0);
        dp[0] = 1; // {0 \brace 0} =1
        for(int i=1;i<=n;i++){
            // Iterate k from min(i, x) downto1
            // to use previous dp[k] and dp[k-1]
            for(int k = min(i, x); k >=1; k--){
                dp[k] = (k * dp[k] % MOD + dp[k-1]) % MOD;
            }
            dp[0] =0;
        }
        
        // Compute the total number of ways
        long long total =0;
        for(int k=1; k<=x && k<=n; k++){
            // P(x,k) = fact[x] * inv_fact[x -k] % MOD
            long long P_x_k = fact[x] * inv_fact[x -k] % MOD;
            // Stirling number of second kind = dp[k]
            long long stirling = dp[k];
            // y^k = power_y[k]
            long long y_pow_k = power_y[k];
            // term = P(x,k) * dp[k] % MOD * y^k % MOD
            long long term = P_x_k * stirling % MOD;
            term = term * y_pow_k % MOD;
            // Add to total
            total = (total + term) % MOD;
        }
        
        return (int)total;
    }
};
",1420056390
Rahul Kumar Yadav,user0434y,63,3605,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> ans;
        
        for(auto p : nums){
            // Prime number 2 cannot be expressed as x OR (x + 1)
            if(p == 2){
                ans.push_back(-1);
                continue;
            }
            
            // Count the number of trailing 1's in the binary representation of p
            int t = 0;
            int temp = p;
            while((temp & 1) == 1){
                t++;
                temp >>=1;
            }
            
            // Calculate x based on the count of trailing 1's
            int x;
            if(t >=1){
                x = p - (1 << (t -1));
            }
            else{
                x = p -1;
            }
            
            // Validate if x OR (x + 1) equals p
            if(x >=0 && ((x | (x +1)) == p)){
                ans.push_back(x);
            }
            else{
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};
",1419999184
Rahul Kumar Yadav,user0434y,63,3611,cpp,"#include <vector>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> ans;
        
        for(auto p : nums){
            // Prime number 2 cannot be expressed as x OR (x + 1)
            if(p == 2){
                ans.push_back(-1);
                continue;
            }
            
            // Count the number of trailing 1's in the binary representation of p
            int t = 0;
            int temp = p;
            while((temp & 1) == 1){
                t++;
                temp >>=1;
            }
            
            // Calculate x based on the count of trailing 1's
            int x;
            if(t >=1){
                x = p - (1 << (t -1));
            }
            else{
                x = p -1;
            }
            
            // Validate if x OR (x + 1) equals p
            if(x >=0 && ((x | (x +1)) == p)){
                ans.push_back(x);
            }
            else{
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};
",1419999727
Jie Chen,JustJie,64,3487,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:51
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

constexpr int A = 26, inf = int(1e9) + 5;

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& choose) {
        int n = s.size();
        int m = t.size();

        vector<vector<int>> g(A);
        for (int i = 0; i < m; i++) {
            g[t[i] - 'a'].push_back(i);
        }

        for (int a = 0; a < A; a++) {
            ranges::reverse(g[a]);
        }

        vector<int> can_remove(n);
        for (int i : choose) {
            can_remove[i] = 1;
        }

        vector<int> dp(m + 1, -inf);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            auto ndp = dp;
            if (can_remove[i]) {
                for (int j = 0; j <= m; j++) {
                    if (ndp[j] != -inf) {
                        ndp[j] += 1;
                    }
                }
            }
            for (int j : g[s[i] - 'a']) {
                if (dp[j] != -inf) {
                    ndp[j + 1] = max(ndp[j + 1], dp[j]);
                }
            }
            dp = std::move(ndp);
        }

        return dp[m];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1420020321
Jie Chen,JustJie,64,3604,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:51
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector f(n + 1, vector<Z>(n + 1));
        f[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                f[i][j] = (f[i - 1][j] * j + f[i - 1][j - 1]);
            }
        }

        Z ans = 0;
        int choice = min(n, x);
        for (int i = 1; i <= choice; i++) {
            Z t = comb.binom(x, i);
            Z bi = f[n][i];
            Z res = power(Z(y), i);
            res = t * comb.fac(i) * bi * res;
            ans += res;
        }
        return ans.val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1420048755
Jie Chen,JustJie,64,3605,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:32
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();

        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            for (int x = 1; x <= 1000; x++) {
                if ((x | (x + 1)) == a[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }

        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1419997329
Jie Chen,JustJie,64,3611,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 10.12.2024 10:23:32
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

constexpr int B = 31;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();

        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            if (a[i] == 2) {
                ans[i] = -1;
            } else {
                int zero = -1;
                int lst = 0;
                for (int b = 0; b < B; b++) {
                    if ((1 << b) > a[i]) {
                        break;
                    }
                    if ((1 << b) & a[i]) {
                        lst = (1 << b);
                    } else {
                        zero = -1;
                        break;
                    }
                }
                if (zero == -1) {
                    ans[i] = a[i] - lst;
                } else {
                    ans[i] = a[i] - (1 << zero);
                }
            }
        }

        return ans;
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1420006604
mo_atef,ScorpioDagger,65,3487,cpp,"class Solution {
public:
    typedef long long ll;
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int a((int)source.size()), b((int)pattern.size()), c((int)targetIndices.size());
        vector<bool> vis(a);
        for (int &i : targetIndices) 
            if(i >= 0 and i < a)
                vis[i] = 1;
        vector<bool> v2 = vis;
        vector<ll> pre(b+1, LLONG_MAX), cur(b+1, LLONG_MAX);
        pre[0] = 0;
        for (int i(1); i <= a; ++i){
            cur[0] = 0;
            for(int j(1); j <= b; ++j){
                if (source[i-1] == pattern[j-1]){
                    if (v2[i-1]){
                        if (pre[j-1] != LLONG_MAX)
                            cur[j] = min(cur[j], pre[j-1]+1);
                    } 
                    else 
                        if (pre[j-1] != LLONG_MAX)
                            cur[j] = min(cur[j], pre[j-1]);
                }
                if (pre[j] != LLONG_MAX) cur[j] = min(cur[j], pre[j]);
            }
            pre = cur;
            fill(cur.begin(), cur.end(), LLONG_MAX);
        }
        int mn(pre[b]);
    return (mn <= c) ? (c-(int)mn) : -1;    
    }
};",1420036923
mo_atef,ScorpioDagger,65,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        int a(n), b(x), c(y);
        ll ans(0);
        vector<vector<int>> C(b+1, vector<int>(b+1));
        vector<vector<ll>> st(a+1, vector<ll>(a+1));
        C[0][0] = 1;
        for (int i(1); i <= b; ++i){
            C[i][0] = 1;
            for (int j(1); j <= i; ++j)
                C[i][j] = (C[i-1][j-1] % MOD + C[i-1][j] % MOD) % MOD;
        }
        st[0][0] = 1;
        for (int i(1); i <= a; ++i){
            for (int j(1); j <= i; ++j)
                st[i][j] = (st[i-1][j-1] % MOD + ((ll)j % MOD * st[i-1][j] % MOD) % MOD) % MOD;
        }
        vector<ll> fac(a+1, 1), yp(a+1, 1);
        for (int i(1); i <= a; ++i)
            fac[i] = (fac[i-1] % MOD * i % MOD) % MOD;
        for(int i = 1; i <= a; ++i)
            yp[i] = (yp[i-1] % MOD * (ll)c % MOD) % MOD;
        int mx(min(a, b));
        for (int k(1), t; k <= mx; ++k){
            t = ((ll)C[b][k] % MOD * st[a][k] % MOD) % MOD;
            t = (t % MOD * fac[k] % MOD) % MOD, t = (t % MOD * yp[k] % MOD) % MOD;
            ans = (ans % MOD + t % MOD) % MOD;
        }
        return (int)ans;
    }
};",1420056848
mo_atef,ScorpioDagger,65,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            f = 0
            for a in range(num):
                if a | (a + 1) == num:
                    ans.append(a)
                    f = 1
                    break
            if not f:
                ans.append(-1)
        return ans",1419993705
mo_atef,ScorpioDagger,65,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            mn = -1
            for bit in range(31):
                if (num >> bit) & 1:
                    ca = num & ~(1 << bit)
                    if ca < num:
                        if (ca | (1+ca)) == num:
                            if mn == -1 or ca < mn:
                                mn = ca
            ans.append(mn)
        return ans",1419999253
Sarthak Pandey,SarthakPaandey,67,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
    int n = source.length();
    int m = pattern.length();
    boolean[] isTarget = new boolean[n];
    for (int idx : targetIndices) isTarget[idx] = true;
    int[] dp = new int[m + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int s = 0; s < n; s++) {
        for (int p = m; p >= 1; p--) {
            if (source.charAt(s) == pattern.charAt(p - 1) && dp[p - 1] != Integer.MAX_VALUE) {
                dp[p] = Math.min(dp[p], dp[p - 1] + (isTarget[s] ? 1 : 0));
            }
        }
    }
    if (dp[m] == Integer.MAX_VALUE) return 0;
    return targetIndices.length - dp[m];
    }
}",1420038565
Sarthak Pandey,SarthakPaandey,67,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        final int MOD = 1_000_000_007;
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= Math.min(i, x); j++) {
                S[i][j] = (S[i-1][j-1] + (j * S[i-1][j]) % MOD) % MOD;
            }
        }
        long[] powy = new long[x + 1];
        powy[0] = 1;
        for(int k = 1; k <= x; k++) {
            powy[k] = powy[k-1] * y % MOD;
        }
        long tot = 0;
        long P = 1;
        for(int k = 1; k <= Math.min(x, n); k++) {
            P = P * (x - k + 1) % MOD;
            long term = P * S[n][k] % MOD;
            term = term * powy[k] % MOD;
            tot = (tot + term) % MOD;
        }
        return (int) tot;
    }
}
",1420050038
Sarthak Pandey,SarthakPaandey,67,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] jaiho = new int[n];
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            int x = -1;
            for (int j = 0; j < p; j++) {
                if ((j | (j + 1)) == p) {
                    x = j;
                    break;
                }
            }
            jaiho[i] = x;
        }
        return jaiho;
    }
}
",1420012303
Sarthak Pandey,SarthakPaandey,67,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] jaihoji = new int[n];

        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            if (p == 2) {
                jaihoji[i] = -1;
                continue;
            }

            List<Integer> setBits = new ArrayList<>();
            for (int bit = 0; bit < 32; bit++) {
                if ((p >> bit & 1) == 1) {
                    setBits.add(bit);
                }
            }

            int minX = Integer.MAX_VALUE;
            for (int bit : setBits) {
                int x = p & ~(1 << bit);
                if ((x | (x + 1)) == p) {
                    minX = Math.min(minX, x);
                }
            }

            jaihoji[i] = (minX != Integer.MAX_VALUE) ? minX : -1;
        }

        return jaihoji;
    }
}
",1420025537
scanhex,scanhex,68,3487,cpp,"
using nagai = long long;
class Solution {
public:
  int maxRemovals(string source, string pattern, vector<int> &targetIndices) {
    int n = source.size();
    int m = pattern.size();
    vector<int> su(n + 1);
    su[n - 1] = source.back() == pattern.back();
    for (int i = n - 2; i >= 0; --i) {
      su[i] = su[i + 1] +
              (su[i + 1] < m && source[i] == pattern[m - su[i + 1] - 1]);
    }
    vector<vector<int>>dp(n + 1, vector<int>(m + 1, 1e9));
    dp[0][0] = 0;
    vector<bool> good(n, true);
    for (int x : targetIndices) {
      good[x] = false;
    }
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= m; ++j) {
            if (i + 1 <= n)
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);
            if (i < n && j < m && source[i] == pattern[j])
                dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + !good[i]);
        }
    }
    return (targetIndices.size() - dp[n][m]);
  }
};
",1420020859
scanhex,scanhex,68,3604,cpp,"
using nagai = long long;
const int mod = 1e9 + 7;
int mu(int a, int b) { return (nagai)a * b % mod; }
void ad(int &x, int y) {
  if ((x += y) >= mod)
    x -= mod;
}
int pw(int a, int b, int c = 1) {
  for (; b; b >>= 1, a = mu(a, a))
    if (b & 1)
      c = mu(c, a);
  return c;
}
const int N = 1010;
int fact[N], rfact[N];
bool prec = false;
void precalc() {
  fact[0] = 1;
  for (int i = 0; i + 1 < N; ++i)
    fact[i + 1] = mu(i + 1, fact[i]);
  rfact[N - 1] = pw(fact[N - 1], mod - 2);
  for (int i = N - 2; i >= 0; --i)
    rfact[i] = mu(i + 1, rfact[i + 1]);
}
int c(int n, int k) { return mu(fact[n], mu(rfact[k], rfact[n - k])); }
class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    if (!prec)
      prec = true, precalc();
    vector<int> dp(min(n, x) + 1);
    dp[0] = 0;
    for (int i = 1; i <= min(n, x); ++i) {
      dp[i] = pw(i, n);
      for (int j = 1; j < i; ++j) {
        dp[i] -= mu(dp[j], c(i, j));
        if (dp[i] < 0)
          dp[i] += mod;
      }
    }
    int ans = 0;
    for (int i = 1; i <= min(n, x); ++i) {
      ad(ans, mu(pw(y, i), mu(c(x, i), dp[i])));
    }
    return ans;
  }
};
",1420051194
scanhex,scanhex,68,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [] 
        for i in nums:
            if i == 2: 
                ans.append(-1)
                continue
            x = i
            kk = 1
            while x % 2 == 1:
                kk *= 2
                x //= 2
            ans.append(x * kk + (kk // 2 - 1))
        return ans",1420034610
scanhex,scanhex,68,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [] 
        for i in nums:
            if i == 2: 
                ans.append(-1)
                continue
            x = i
            kk = 1
            while x % 2 == 1:
                kk *= 2
                x //= 2
            ans.append(x * kk + (kk // 2 - 1))
        return ans",1420034430
Mehul,p4n1c,69,3487,python3,"class Solution:
    def maxRemovals(self, source: str, p: str, ti: List[int]) -> int:
        m, src = len(p), len(source)
        SET = set(ti)
        dp1 = [float('inf')] * (src + 1)

        for idx in range(src + 1):
            dp1[idx] = 0
        
        for i in range(1, m + 1):
            dp_i = [float('inf')] * (src + 1)
            for j in range(1, src + 1):
                if p[i - 1] == source[j - 1]:
                    this = dp1[j - 1] + (1 if (j - 1) in SET else 0)
                    nope = dp_i[j - 1]
                    dp_i[j] = min(this, nope)
                else:
                    dp_i[j] = dp_i[j - 1]
            dp1 = dp_i
        
        mini = dp1[src]
        
        def helper(targetArray):
            ans = []

            for num in targetArray:
                ans.append(num)

            return ans
        
        return len(ti) - mini if mini != float('inf') else 0",1420016974
Mehul,p4n1c,69,3604,python3,"class Solution:
    def numberOfWays(self, performers: int, stages: int, scoreRange: int) -> int:
        mo = 10**9 + 7

        def helper(self, n, x, y):
            MOD = 10**9 + 7
            tempo = [0] * n
            SETu_ = set()
            ans = 0

            def check(curr_: int):
                nonlocal ans
                if curr_ == n:
                    uniq = len(SETu_)
                    scores = []
                    for _ in range(uniq):
                        scores.append(1)
                    combos = 1
                    for _ in range(uniq):
                        combos = (combos * y) % MOD
                    ans = (ans + combos) % MOD
                    return

                for stage in range(x):
                    tempo[curr_] = stage
                    flag_ = False
                    if stage not in SETu_:
                        SETu_.add(stage)
                        flag_ = True
                    check(curr_ + 1)
                    if flag_:
                        SETu_.remove(stage)
            check(0)

            return ans

        maxi = max(performers, stages)

        facto = [1] * (maxi + 3)
        for num in range(1, maxi + 1):
            facto[num] = (facto[num - 1] * num) % mo

        ifacto = [1] * (maxi + 3)
        ifacto[maxi] = pow(facto[maxi], mo - 2, mo)
        for num in range(maxi, 0, -1):
            ifacto[num - 1] = (ifacto[num] * num) % mo

        def ncr(numerator, denominator):
            if denominator < 0 or denominator > numerator:
                return 0
            return (facto[numerator] * ifacto[denominator] % mo) * ifacto[numerator - denominator] % mo

        prev_ = [0] * (performers + 3)
        prev_[0] = 1

        for curr_ in range(1, performers + 1):
            temp_ = [0] * (performers + 3)
            for stage_ in range(1, curr_ + 1):
                m1 = (stage_ * prev_[stage_]) % mo
                m2 = prev_[stage_ - 1]
                temp_[stage_] = (m1 + m2) % mo
            prev_ = temp_

        minis_ = min(stages, performers)

        pow_ = [1] * (minis_ + 3)
        for exp in range(1, minis_ + 1):
            pow_[exp] = (pow_[exp - 1] * scoreRange) % mo

        ans = 0

        def che(may):
            for num in may:
                num += 1
            return may

        for active_stages in range(1, minis_ + 1):
            sperm_ = facto[active_stages]
            snum_ = prev_[active_stages]

            options = ncr(stages, active_stages)
            
            ass_ = pow_[active_stages]
            t_ = (options * snum_) % mo
            t_ = (t_ * sperm_) % mo
            t_ = (t_ * ass_) % mo

            ans = (ans + t_) % mo

            checking = (options + snum_ + sperm_ + ass_) % mo
            _ = checking

        return ans",1420059134
Mehul,p4n1c,69,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def helper(find):
            for idx in range(find):
                if idx | (1 + idx) == find:
                    return idx
                    
            return -1

        ans = []

        for num in nums:
            ans.append(helper(num))

        return ans",1420009463
Mehul,p4n1c,69,3611,python3,"class Solution:
    def minBitwiseArray(self, arr: List[int]) -> List[int]:
        def helper(find):
            if find == 0:
                return -1
            t = 0
            curr = find
            while curr & 1:
                t += 1
                curr >>= 1
            if t == 0:
                return -1
            x = find - (1 << (t - 1))
            if x >= 0 and (x | (x + 1)) == find:
                return x
            else:
                return -1

        def bitwise(temp):
            ans = []

            for i in range(10, -1, -1):
                ans.append(temp^temp)

            return ans

        return [helper(number) for number in arr]",1420027608
colorfuldata,colorfuldata,70,3487,python3,"from typing import List
import sys

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        target_set = set(targetIndices)
        prev = [sys.maxsize] * (m + 1)
        curr = [sys.maxsize] * (m + 1)
        prev[0] = 0
        
        for i in range(n):
            curr = [sys.maxsize] * (m + 1)
            for j in range(m + 1):
                if prev[j] == sys.maxsize:
                    continue
                curr[j] = min(curr[j], prev[j])
                if j < m and source[i] == pattern[j]:
                    cost = prev[j] + (1 if i in target_set else 0)
                    curr[j + 1] = min(curr[j + 1], cost)
            prev = curr
        
        if prev[m] == sys.maxsize:
            return 0
        
        min_keep = prev[m]
        return len(targetIndices) - min_keep",1420007433
colorfuldata,colorfuldata,70,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        def compFact(mn):
            f = [1] * (mn + 1)
            for i in range(1, mn + 1):
                f[i] = f[i - 1] * i % MOD
            invF = [1] * (mn + 1)
            invF[mn] = pow(f[mn], MOD - 2, MOD)
            for i in range(mn - 1, -1, -1):
                invF[i] = invF[i + 1] * (i + 1) % MOD
            return f, invF

        def compStir(n):
            S = [[0] * (n + 1) for _ in range(n + 1)]
            S[0][0] = 1
            for i in range(1, n + 1):
                for j in range(1, i + 1):
                    S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
            return S

        def comb(n, k, f, invF):
            if k < 0 or k > n:
                return 0
            return f[n] * invF[k] % MOD * invF[n - k] % MOD
        
        f, invF = compFact(x)
        S = compStir(n)
  
        lem = x
        
        total = 0
        mx_k = min(n, x)
        
        for k in range(1, mx_k + 1):
            c = comb(x, k, f, invF)      
            stir = S[n][k]                                
            perms = f[k]                              
            y_pow = pow(y, k, MOD)                       
            ways = c * stir % MOD
            ways = ways * perms % MOD
            ways = ways * y_pow % MOD
            total = (total + ways) % MOD
        
        return total
",1420051520
colorfuldata,colorfuldata,70,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def find_min_x(num: int) -> int:
            for x in range(num):
                if (x | (x + 1)) == num:
                    return x
            return -1

        return [find_min_x(num) for num in nums]
",1419995592
colorfuldata,colorfuldata,70,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def findMinX(y: int) -> int:
            minX = float('inf')
            for bit in range(y.bit_length()):
                if y & (1 << bit):
                    xCandidate = y & ~(1 << bit)
                    if (xCandidate | (xCandidate + 1)) == y:
                        minX = min(minX, xCandidate)
            return minX if minX != float('inf') else -1

        return [findMinX(num) for num in nums]
",1420006443
Andrew,XAXAEBATb,72,3487,cpp,"class Solution {
public:
int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int a = source.size();
    int b = pattern.size();
        vector <int> cc(a+1);
        for (auto& i:targetIndices) {
            cc[i] = 1;
        }
        vector <int> can(a+1, -100);
        can[0] = 0;
        for (int i=0;i<a;i++) {
            for (int j=i;j>=0;j--) {
                if (can[j]>=0 && cc[i] == 1) {
                    can[j+1] = max(can[j+1], can[j]);
                }
                if (can[j]<b && can[j]>=0 && source[i] == pattern[can[j]]) {
                    can[j] = can[j] + 1;
                }
            }
        }
    int ans = -1;
    for (int i=0;i<a;i++) {
        // cout<<can[i]<<"" "";
        if (can[i]>=b) {ans=i;}
    }
    return ans;
    }
};",1420059983
Andrew,XAXAEBATb,72,3604,cpp,"class Solution {
public:
    long long powmod(long long a,long long b,long long mod) {
    if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }

    if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }
    else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }
}
    
    int numberOfWays(int n, int x, int y) {
        long long mod = 1000000007;
        vector<long long> cur(n+1);
        cur[0] = 1;
        for (long long i=1;i<=n;++i) {
            vector<long long> next(i+1);
            for (long long k=1;k<=i;++k) {
                next[k]=(cur[k-1]+k*cur[k])%mod;
            }
            for (long long j=0;j<=i;j++) {
                cur[j]=next[j];
            }
        }
        
        int max_k=min(n,x);
        long long ans=0;
        long long l=1;
        for (long long k=1;k<=max_k;++k) {
            if (k > 1) {
                l = (l*(x-k+1))%mod;
            } else {
                l=x%mod;
            }
            ans+=(((cur[k]*l)%mod)*powmod(y,k,mod))%mod;
            ans%=mod;
        }
        return ans;


    }
};",1420059809
Andrew,XAXAEBATb,72,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto& n:nums) {
            long long min_x = -1;
            for (int i=0;i<31;i++) {
                long long x = n - (1 << i);
                if (x >= 0) {
                    if ((x | (x + 1)) == n) {
                        if (min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                } else {
                    break;
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};",1420059536
Andrew,XAXAEBATb,72,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        for (auto& n:nums) {
            long long min_x = -1;
            for (int i=0;i<31;i++) {
                long long x = n - (1 << i);
                if (x >= 0) {
                    if ((x | (x + 1)) == n) {
                        if (min_x == -1 || x < min_x) {
                            min_x = x;
                        }
                    }
                } else {
                    break;
                }
            }
            ans.push_back(min_x);
        }
        return ans;
    }
};",1420059285
Vasanth Reddy,vassu118,73,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& b) {
        int n = source.size(), m = pattern.size();
        vector<bool> mark(n, false);
        for(int i : b) mark[i] = true;
        vector<vector<int>> dp(n + 1, vector<int> (m + 1, -1e9));
        dp[0][0] = 0;
        for(int i = 1; i <= n; i++) {
            dp[i][0] = dp[i - 1][0] + (mark[i - 1]);
        }
        for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) {
            dp[i][j] = dp[i - 1][j];
            if(mark[i - 1]) dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j]);
            if(source[i - 1] == pattern[j - 1]) dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
        }
        return dp[n][m];
    }
};",1420010230
Vasanth Reddy,vassu118,73,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int xx, int yy) {
        int mod = 1e9 + 7;
        auto power = [&](int x, int y) -> int {
            int ans = 1;
            for(; y; y >>= 1, x = 1LL * x * x % mod) if(y & 1) ans = 1LL * ans * x % mod;
            return ans;
        };
        vector<int> fact(xx + 1, 1), ifact(xx + 1, 1);
        for(int i = 1; i <= xx; i++) {
            fact[i] = 1LL * fact[i - 1] * i % mod;
        }
        ifact[xx] = power(fact[xx], mod - 2);
        for(int i = xx - 1; i >= 0; i--) ifact[i] = 1LL * ifact[i + 1] * (i + 1) % mod;
        
        auto ncr = [&](int x, int y) -> int {
            if(y < 0 || x < y || x < 0) return 0;
            int ans = 1LL * fact[x] * ifact[y] % mod * ifact[x - y] % mod;
            return ans;
        };
        
        vector<vector<int>> dp(n + 1, vector<int> (xx + 1));
        dp[0][0] = 1;
        for(int i = 1; i <= n; i++) for(int j = 1; j <= xx; j++) {
            dp[i][j] = (dp[i][j] + 1LL * dp[i - 1][j] * j % mod) % mod;
            dp[i][j] = (dp[i][j] + 1LL * (xx - j + 1) * dp[i - 1][j - 1] % mod) % mod;
        }
        
        // dp[i - 1][j] 
        
        vector<int> a(xx + 1, 0), ways(xx + 1, 0);
        
        for(int i = 1; i <= xx; i++) {
            int rem = n - i;
            a[i] = dp[n][i] % mod;
            
            // cout << a[i] << ' ';
        }
        // cout << '\n';
        
        int ans = 0;
        for(int i = 1; i <= xx; i++) {
            ans = (ans + 1LL * a[i] * power(yy, i) % mod) % mod;
        }
        return ans;
    }
};",1420059994
Vasanth Reddy,vassu118,73,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i : nums) {
            int done = 0;
            int mx = 2e9;
            for(int j = 29; j >= 0; j--) {
                int now = done;
                now += (1 << j) - 1;
                if((now | (now + 1)) == i) mx = min(mx, now);
                if(i >> j & 1) done += (1 << j);
            }
            if(mx == 2e9) mx = -1;
            ans.push_back(mx);
        }
        return ans;
    }
};",1419998362
Vasanth Reddy,vassu118,73,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i : nums) {
            int done = 0;
            int mx = 2e9;
            for(int j = 29; j >= 0; j--) {
                int now = done;
                now += (1 << j) - 1;
                if((now | (now + 1)) == i) mx = min(mx, now);
                if(i >> j & 1) done += (1 << j);
            }
            if(mx == 2e9) mx = -1;
            ans.push_back(mx);
        }
        return ans;
    }
};",1419998059
hxu10,hxu10,74,3487,python,"class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        """"""
        :type source: str
        :type pattern: str
        :type targetIndices: List[int]
        :rtype: int
        """"""
        m = len(pattern)
        inf = 10**9
        dp = [inf]*(m+1)
        
        sets = set(targetIndices)
        
        
        dp[0] = 0
        
        for i,c in enumerate(source):
            predp = dp[:]
            if i not in sets:
                for j in range(m+1):
                    dp[j] += 1
                    
            
                    
            
            for j in range(m,0,-1):
                if c==pattern[j-1]:
                    dp[j] = min(dp[j], predp[j-1] + 1)
                        
            #print(dp)
        
        return len(source) - dp[m]
    
            
            
                        
                    
                    
        ",1420039149
hxu10,hxu10,74,3604,python,"M = 10**9 + 7

class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        dp = [0]*(x+1)
        
        dp[0] = 1
        
        
        
        
        
        for _ in range(n):
            predp = dp[:]
            for i in range(x+1):
                dp[i] = predp[i] * i 
                if i > 0:
                    dp[i] += predp[i-1] * (x-i+1) * y
                    dp[i] %= M
                    
           # print(dp)
                    
            
        ans = sum(dp)%M
        return ans
        
                    
                
                    
                    
                
            
            ",1420060854
hxu10,hxu10,74,3605,python,"dic = {}

for i in range(3000,-1,-1):
    dic[i|(i+1)] = i
    
    
    

class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        for num in nums:
            if num not in dic:  
                ans.append(-1)
            else:
                ans.append(dic[num])
        return ans
    
            ",1419994383
hxu10,hxu10,74,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        
        
        
        def getnext(num):
            
            if num//2 % 2 == 0:
                return num // 2 * 2
            
            return getnext(num//2) * 2 + 1

    
            
            
        
        for num in nums:
            if num == 2:  
                ans.append(-1)
                continue 
                
                
            ans.append(getnext(num))
            
            
        return ans",1420014191
Yucheng Dai,Rainingcity,75,3487,cpp,"class Solution {
private:
    void update(int& x, int y) {
        if (x == -1) x = y;
        else x = max(x, y);
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        bool rem = false;
        dp[0][0] = 0;
        for(int i = 1, k = 0; i <= n; i++) {
            if (k < targetIndices.size() && targetIndices[k] == i - 1) {
                k++;
                rem = true;
            } else {
                rem = false;
            }
            dp[i][0] = k;
            for(int j = 1; j <= m; j++) {
                if (dp[i - 1][j] != -1) update(dp[i][j], dp[i - 1][j] + (int)rem);
                if (source[i - 1] == pattern[j - 1] && dp[i - 1][j - 1] != -1) update(dp[i][j], dp[i - 1][j - 1]);
            }
        }
        return dp[n][m];
    }
};",1420016972
Yucheng Dai,Rainingcity,75,3604,cpp,"typedef long long ll;
const ll MOD = 1000000007ll;

ll fpow(ll x, int a) {
    if (a == 0) return 1;
    if (a == 1) return x;
    ll res = fpow(x, a >> 1);
    res = (res * res) % MOD;
    if (a & 1) return (res * x) % MOD;
    else return res;
}

class Solution {
private:
    void buildC(vector<vector<ll>>& C, int n) {
        C[0][0] = C[1][0] = C[1][1] = 1;
        for(int i = 2; i <= n; i++) {
            C[i][0] = C[i][i] = 1;
            for(int j = 1; j < i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(1001, vector<ll>(1001, 0));
        buildC(C, x);
        int ans = 0;
        vector<ll> cnt(x + 1, 0);
        ll ypow = 1;
        for(int i = 1; i <= x; i++) {
            cnt[i] = fpow(i, n);
            for(int j = 1; j < i; j++) {
                cnt[i] -= (cnt[j] * C[i][j]) % MOD;
                cnt[i] = (cnt[i] + MOD) % MOD;
            }
            // cout << cnt[i] << endl;
            ypow = (ypow * y) % MOD;
            ll res = (cnt[i] * ypow) % MOD;
            res = (res * C[x][i]) % MOD;
            ans = (ans + res) % MOD;
        }
        return ans % MOD;
    }
};",1420061585
Yucheng Dai,Rainingcity,75,3605,cpp,"int lsb(int x) {
    return x & (-x);
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans{};
        for(int x: nums) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            int y = lsb(x + 1);
            int common = x - y + 1;
            ans.push_back(common + (y >> 1) - 1);
        }
        return ans;
    }
};",1419997514
Yucheng Dai,Rainingcity,75,3611,cpp,"int lsb(int x) {
    return x & (-x);
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans{};
        for(int x: nums) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            int y = lsb(x + 1);
            int common = x - y + 1;
            ans.push_back(common + (y >> 1) - 1);
        }
        return ans;
    }
};",1419997216
therealpratyushraman,therealpratyushraman,77,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
    int n = source.length(), m = pattern.length();
    Set<Integer> targetSet = new HashSet<>();
    for (int idx : targetIndices) targetSet.add(idx);
    int[] dp = new int[m + 1];
    Arrays.fill(dp, Integer.MAX_VALUE / 2);
    dp[0] = 0;
    for (int i = 0; i < n; i++) {
    for (int j = Math.min(i + 1, m); j >= 1; j--) {
    if (source.charAt(i) == pattern.charAt(j - 1)) {
    int cost = targetSet.contains(i) ? 1 : 0;
    dp[j] = Math.min(dp[j], dp[j - 1] + cost);
    }
    }
    }
    if (dp[m] >= Integer.MAX_VALUE / 2) return 0;
    return targetIndices.length - dp[m];
    }
    }
",1420055010
therealpratyushraman,therealpratyushraman,77,3604,java,"class Solution {
    static final int MOD = (int)1e9 + 7;
    public int numberOfWays(int n, int x, int y) {
    int maxN = 1000;
    long[] factorial = new long[maxN + 1];
    long[] invFactorial = new long[maxN + 1];
    factorial[0] = invFactorial[0] = 1;
    for (int i = 1; i <= maxN; i++) {
    factorial[i] = factorial[i - 1] * i % MOD;
    }
    invFactorial[maxN] = modInverse(factorial[maxN]);
    for (int i = maxN - 1; i >= 1; i--) {
    invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
    }
    long[][] stirling = new long[n + 1][n + 1];
    stirling[0][0] = 1;
    for (int i = 1; i <= n; i++) {
    stirling[i][0] = 0;
    for (int j = 1; j <= i; j++) {
    stirling[i][j] = (stirling[i - 1][j - 1] + stirling[i - 1][j] * j) % MOD;
    }
    }
    long[] powY = new long[x + 1];
    powY[0] = 1;
    for (int i = 1; i <= x; i++) {
    powY[i] = powY[i - 1] * y % MOD;
    }
    long result = 0;
    for (int k = 1; k <= Math.min(n, x); k++) {
    long ways = combination(x, k, factorial, invFactorial) * factorial[k] % MOD;
    ways = ways * stirling[n][k] % MOD;
    ways = ways * powY[k] % MOD;
    result = (result + ways) % MOD;
    }
    return (int)result;
    }
    long modInverse(long x) {
    return powMod(x, MOD - 2);
    }
    long powMod(long x, long n) {
    long result = 1;
    x %= MOD;
    while (n > 0) {
    if ((n & 1) == 1) result = result * x % MOD;
    x = x * x % MOD;
    n >>= 1;
    }
    return result;
    }
    long combination(int n, int k, long[] fact, long[] invFact) {
    if (k < 0 || k > n) return 0;
    return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;
    }
}",1419996447
therealpratyushraman,therealpratyushraman,77,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for (int i = 0; i < n; i++) {
    int S = nums.get(i), minX = -1;
    for (int x = 0; x <= S; x++) {
    if ((x | (x + 1)) == S) {
    minX = x;
    break;
    }
    }
    ans[i] = minX;
    }
    return ans;
    }
} ",1420025769
therealpratyushraman,therealpratyushraman,77,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for (int i = 0; i < n; i++) {
        int S = nums.get(i), minX = -1;
        for (int k = 0; k <= 30; k++) {
            int x = S - (1 << k);
            if (x >= 0 && (x | (x + 1)) == S) {
                if (minX == -1 || x < minX) minX = x;
                }
            }
        ans[i] = minX;
    }
    return ans;
    }
}",1420019918
NO_ONE,Timid_Tom,79,3487,cpp,"class Solution {
public:
    int solve(int i, int j, string &src, string &pattern, vector<int> &hsh, vector<vector<int>> &dp) {
        int n = src.size();
        int m = pattern.size();
        
        if (i == n) return (j == m) ? 0 : -1e5;
        
        if (dp[i][j] != -1) return dp[i][j];
        
        int ans = solve(i + 1, j, src, pattern, hsh, dp);
        
        if (hsh[i]) ans = max(ans, 1 + solve(i + 1, j, src, pattern, hsh, dp));
        
        if (j < m && src[i] == pattern[j]) ans = max(ans, solve(i + 1, j + 1, src, pattern, hsh, dp));
        
        return dp[i][j] = ans;
    }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        vector<int> hsh(n + 1, 0);
        for (auto it : targetIndices) hsh[it] = 1;
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));
        return solve(0, 0, source, pattern, hsh, dp);
    }
};
",1420063765
NO_ONE,Timid_Tom,79,3604,cpp,"#include <vector>
using namespace std;

const int MOD = 1e9 + 7;
#define ll long long

class Solution {
public:
    
    ll mod_add(ll a, ll b, ll m) {return (a % m + b % m + m) % m;}
    ll mod_mul(ll a, ll b, ll m) {return (a % m * b % m + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b) {if (b & 1) res = mod_mul(res, a, m); a = mod_mul(a, a, m); b >>= 1;} return res;}
    ll comb(ll n, ll r, ll m, ll *fact, ll *ifact) {return mod_mul(mod_mul(fact[n], ifact[n - r], m), ifact[r], m);}
    
    int numberOfWays(int n, int x, int y) {
          vector<vector<ll>> sum(n + 1, vector<ll>(x + 1, 0));
        sum[0][0] = 1;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= x; ++j)
                sum[i][j] = mod_add(mod_mul(j, sum[i - 1][j], MOD), sum[i - 1][j - 1], MOD);
        
        vector<vector<ll>> dp(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; ++j)
                dp[i][j] = mod_add(dp[i - 1][j - 1], dp[i - 1][j], MOD);
        }

      

        vector<ll> fact(x + 1, 1), ifact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = mod_mul(fact[i - 1], i, MOD);
            ifact[i] = expo(fact[i], MOD - 2, MOD); 
        }

        ll res = 0;
        for (int k = 1; k <= x; ++k) {
            ll power = expo(y, k, MOD);
            res = mod_add(res, mod_mul(mod_mul(dp[x][k], sum[n][k], MOD), mod_mul(fact[k], power, MOD), MOD), MOD);
        }

        return res;
    }
};
",1420057170
NO_ONE,Timid_Tom,79,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
            int n = nums.size();
            vector<int>ans;
            for(auto it:nums){
                int a = it;
                if(a%2 == 0){
                    ans.push_back(-1);
                }
                else{
                    int ct = it-1;
                    int cnt = 1;
                    while(cnt*2<=it){
                        int val = it - 2*cnt;
                        
                        
                        if((val | (val+1)) == it){
                            ct = min(ct , val);
                        }
                        cnt *=2;
                    }
                    ans.push_back(ct);
                    
                }
            }
            return ans;
    }
};",1420021515
NO_ONE,Timid_Tom,79,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
            int n = nums.size();
            vector<int>ans;
            for(auto it:nums){
                int a = it;
                if(a%2 == 0){
                    ans.push_back(-1);
                }
                else{
                    int ct = it-1;
                    int cnt = 1;
                    while(cnt*2<=it){
                        int val = it - 2*cnt;
                        
                        
                        if((val | (val+1)) == it){
                            ct = min(ct , val);
                        }
                        cnt *=2;
                    }
                    ans.push_back(ct);
                    
                }
            }
            return ans;
    }
};",1420020918
moradiya84,moradiya84,80,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& z) {
        int n=s.size();
        vector<int>vis(n);
        for(int i=0;i<z.size();i++){
            vis[z[i]]=1;
        }
        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));
        int m=t.size();
        function<int(int,int)>ff=[&](int i,int j){
            if(i==n && j==m) return 0;
            if(dp[i][j]!=-1) return dp[i][j];
            if(i==n) return (int)-1e5;
            if(j==m) return dp[i][j]=vis[i]+ff(i+1,j);
            int ans=-1e5;
            ans=max(ans,vis[i]+ff(i+1,j));
            if(s[i]==t[j]) ans=max(ans,ff(i+1,j+1));
            return dp[i][j]=ans;
        };
        int ans=ff(0,0);
        if(ans<0) ans=0;
        return ans;
    }
};",1420026180
moradiya84,moradiya84,80,3604,cpp,"int mod=1e9+7;
// int p=99996821;
#define pb push_back
#define umii unordered_map<int,int>
#define umci unordered_map<char,int>
#define umcc unordered_map<char,char>
#define mii map<int,int>
#define mci map<char,int>
#define mcc map<char,char>
#define vi vector<int>
#define vvi vector<vector<int>>
#define vvpii vector<vector<pii>>
#define f(i,n) for(int i=0;i<n;i++)
#define f1(i,n) for(int i=1;i<=n;i++)
#define pii pair<int,int>
#define piii pair<int,pair<int,int>>
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
#define ff first
#define ss second
#define lb lower_bound
#define ub upper_bound
#define endl ""\n""
using ll=long long;
ll power(ll x,ll y){
    ll value = 0;
    if(y<0) return (int)0;
    else if(y==0) return (int)1;
    else if(y==1) return x;
    else if(y%2) value = (x*(power((x*x)%mod,y/2)%mod))%mod;
    else value = power((x*x)%mod,y/2)%mod;
    return value%mod;
}

ll inversemod(ll x) {
    return power(x,mod-2)%mod;
}
vector<ll> fact,ifact;

void FACT(int n){
    fact.resize(n+1);
    fact[0]=1;
    f1(i,n){
        fact[i]=fact[i-1]*i;
        fact[i]%=mod;
    }
}

void IFACT(int n){
    ifact.resize(n+1);
    ifact[n]=inversemod(fact[n]);
    for(int i=n-1;i>=0;i--){
        ifact[i]=(ifact[i+1]*(i+1))%mod;
    }
}

int NCR(int n,int r){
    return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod;
}
class Solution {
public:
    // #include <bits/stdc++.h>
// using namespace std;
// #define int long long
    int numberOfWays(int n, int x, int y) {
        FACT(2001);
        IFACT(2001);
        vector<ll> z(2001);
        z[0]=1;
        for(int i=1;i<=2000;i++){
            z[i]=z[i-1]*y;
            z[i]%=mod;
        }
        ll ans=0;   
        vector<vector<ll>>dp(n+1,vector<ll>(x+1));
        dp[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x;j++){
                dp[i][j]=dp[i-1][j-1]+j*dp[i-1][j];
                dp[i][j]%=mod;
            }
        }
        
        for(int tot=1;tot<=x;tot++){
            if(tot>n) break;
            ll tans=dp[n][tot];
            tans*=fact[tot];
            tans%=mod;
            tans*=NCR(x,tot);
            tans%=mod;
            tans*=z[tot];
            tans%=mod;
            ans+=tans;
            ans%=mod;
        }
        return ans;
    }
};",1420064132
moradiya84,moradiya84,80,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if(v[i]%2){
                ans[i]=-1;
                for(int j=0;j<v[i];j++){
                    if((j|(j+1))==v[i]){
                        ans[i]=j;
                        break;
                    }
                }
            }
            else ans[i]=-1;
        }
        return ans;
    }
};",1419995904
moradiya84,moradiya84,80,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if((v[i]%2) == 0){
                ans[i]=-1;
            }
            else{
                ans[i]=v[i]-1;
                int num=v[i];
                vector<int>a(32);
                for(int j=0;j<32;j++){
                    a[j]=num%2;
                    num/=2;
                }
                int k=-1;
                for(int j=0;j<32;j++){
                    if(a[j]==0) break;
                    k=j;
                }
                if(k>0){
                    ans[i]=v[i]-pow(2,k);
                }
            }
        }
        return ans;
    }
};",1420006328
Ferrriccc,Ferrriccc,83,3487,cpp,"class Solution {
  public:
    int maxRemovals(string source, string pattern, vector<int> &targetIndices) {
        const int inf = 1e9;

        int n = source.size();
        source = '/' + source;
        pattern = '/' + pattern;
        int m = pattern.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, inf));
        vector<int> bad(n + 1);
        for (int i : targetIndices) {
            bad[i + 1] = 1;
        }
        for (int i = 0; i <= n; ++i) {
            dp[i][0] = 0;
        }
        int mn = inf;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = min(dp[i - 1][j], dp[i][j]);
                if (source[i] != pattern[j]) {
                    continue;
                }
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + bad[i]);
            }
            mn = min(mn, dp[i][m - 1]);
        }
        return max(0, (int)targetIndices.size() - mn);
    }
};
",1420052130
Ferrriccc,Ferrriccc,83,3604,cpp,"class Solution {
    template <const int T> struct ModInt {
        const static int mod = T;
        int x;
        int val() { return x; }
        ModInt(int x = 0) : x(x % mod) {}
        ModInt(long long x) : x(int(x % mod)) {}
        ModInt operator+(const ModInt &a) const {
            int x0 = x + a.x;
            return ModInt(x0 < mod ? x0 : x0 - mod);
        }
        ModInt operator-(const ModInt &a) const {
            int x0 = x - a.x;
            return ModInt(x0 < 0 ? x0 + mod : x0);
        }
        ModInt operator*(const ModInt &a) const {
            return ModInt(1ll * x * a.x % mod);
        }
        ModInt operator/(const ModInt &a) const { return *this * a.inv(); }
        void operator+=(const ModInt &a) {
            x += a.x;
            if (x >= mod)
                x -= mod;
        }
        void operator-=(const ModInt &a) {
            x -= a.x;
            if (x < 0)
                x += mod;
        }
        void operator*=(const ModInt &a) { x = 1LL * x * a.x % mod; }
        void operator/=(const ModInt &a) { *this = *this / a; }
        ModInt pow(int64_t n) const {
            ModInt res(1), mul(x);
            while (n) {
                if (n & 1)
                    res *= mul;
                mul *= mul;
                n >>= 1;
            }
            return res;
        }
        ModInt inv() const {
            int a = x, b = mod, u = 1, v = 0;
            while (b) {
                int t = a / b;
                a -= t * b;
                swap(a, b);
                u -= t * v;
                swap(u, v);
            }
            if (u < 0)
                u += mod;
            return u;
        }
    };

    using mint = ModInt<(int)1e9 + 7>;

  public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<mint>> dp(n + 1, vector<mint>(x + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int b = 1; b <= x; ++b) {
                dp[i][b] +=
                    (dp[i - 1][b] * b + dp[i - 1][b - 1] * (x - (b - 1)));
            }
        }
        mint ans = 0;
        for (int b = 1; b <= x; ++b) {
            ans += dp[n][b] * mint(y).pow(b);
        }
        return ans.x;
    }
};
",1420031036
Ferrriccc,Ferrriccc,83,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
                continue;
            }
            int here = i;
            int base = 1;
            i >>= 1;
            while (i & 1) {
                i >>= 1;
                base *= 2;
            }
            ans.push_back(here - base);
        }
        return ans;
    }
};",1420065402
Ferrriccc,Ferrriccc,83,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) {
                ans.push_back(-1);
                continue;
            }
            int here = i;
            int base = 1;
            i >>= 1;
            while (i & 1) {
                i >>= 1;
                base *= 2;
            }
            ans.push_back(here - base);
        }
        return ans;
    }
};",1420064920
Min,IAFB358kMw,84,3487,java,"import java.util.HashSet;
import java.util.Set;

public class Solution {
    
    private Set<Integer> help(int[] t) {
        Set<Integer> ts = new HashSet<>();
        int idx = 0;
        while (idx < t.length) {
            ts.add(t[idx]);
            idx++;
        }
        return ts;
    }

    private void help2(int N, int[] prev, int[] curr) {
        int init = 0;
        while (init <= N) {
            prev[init] = Integer.MAX_VALUE;
            curr[init] = Integer.MAX_VALUE;
            init++;
        }
    }

    private void help3(int[] prev) {
        int set = 0;
        while (set < 1) {
            prev[0] = 0;
            set++;
        }
    }

    private void help4(int M, int N, String source, String p, Set<Integer> t, int[] prev, int[] curr, int i) {
        int current = i;
        while (current < M) {
            help8(curr, N);
            help7(N, source, p, t, prev, curr, current);
            help6(N, prev, curr);
            current++;
        }
    }

    private void help8(int[] curr, int N) {
        int res = 0;
        while (res <= N) {
            curr[res] = Integer.MAX_VALUE;
            res++;
        }
    }

    private void help7(int N, String source, String pattern, Set<Integer> targetSet, int[] prev, int[] curr, int i) {
        int j = 0;
        while (j <= N) {
            boolean condition = (prev[j] == Integer.MAX_VALUE);
            while (condition) {
                j++;
                if (j > N) {
                    break;
                }
                condition = (prev[j] == Integer.MAX_VALUE);
            }
            if (j > N) {
                break;
            }
            boolean minCondition = (curr[j] > prev[j]);
            while (minCondition) {
                curr[j] = prev[j];
                break;
            }
            boolean matchCondition = (j < N && source.charAt(i) == pattern.charAt(j));
            while (matchCondition) {
                int cost = prev[j];
                boolean contains = targetSet.contains(i);
                while (contains) {
                    cost += 1;
                    break;
                }
                boolean minCondition2 = (curr[j + 1] > cost);
                while (minCondition2) {
                    curr[j + 1] = cost;
                    break;
                }
                break;
            }
            j++;
        }
    }

    private void help6(int N, int[] prev, int[] curr) {
        int copyIdx = 0;
        while (copyIdx <= N) {
            prev[copyIdx] = curr[copyIdx];
            copyIdx++;
        }
    }

    private int help5(int N, int[] targetIndices, int[] prev) {
        int returnValue = 0;
        boolean finalCondition = (prev[N] == Integer.MAX_VALUE);
        while (finalCondition) {
            returnValue = 0;
            break;
        }
        boolean elseCondition = (prev[N] != Integer.MAX_VALUE);
        while (elseCondition) {
            int minKeep = prev[N];
            returnValue = targetIndices.length - minKeep;
            break;
        }
        return returnValue;
    }
    
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int M = source.length();
        int N = pattern.length();
        Set<Integer> targetSet = help(targetIndices);
        int[] prev = new int[N + 1];
        int[] curr = new int[N + 1];
        help2(N, prev, curr);
        help3(prev);
        int i = 0;
        help4(M, N, source, pattern, targetSet, prev, curr, i);
        return help5(N, targetIndices, prev);
    }

}
",1420043689
Min,IAFB358kMw,84,3604,java,"public class Solution {
    
    private void help2(int N) {
        f = new long[N + 1];
        ifac = new long[N + 1];
        f[0] = 1L;
        int i = 1;
        while (i <= N) {
            f[i] = (f[i - 1] * i) % M;
            i++;
        }
    }

    private void help3(int N) {
        ifac[N] = help(f[N], M - 2, M);
        int i = N - 1;
        while (i >= 0) {
            ifac[i] = (ifac[i + 1] * (i + 1)) % M;
            i--;
        }
    }

    private void help4(int n) {
        s = new long[n + 1][n + 1];
        s[0][0] = 1L;
        int i = 1;
        while (i <= n) {
            s[i][0] = 0L;
            help5(i);
            i++;
        }
    }
    
    private static final long M = 1000000007L;
    private long[] f;
    private long[] ifac;
    private long[][] s;

    private void help5(int i) {
        int j = 1;
        while (j <= i) {
            s[i][j] = ((j * s[i - 1][j]) % M + s[i - 1][j - 1]) % M;
            j++;
        }
    }

    private long help6(int x, int maxK, int n, int y) {
        long tw = 0L;
        int k = 1;
        while (k <= maxK) {
            long c = nCr(x, k);
            long p = f[k];
            long st = s[n][k];
            long py = help(y, k, M);
            long twk = (((c * p) % M) * st % M * py) % M;
            tw = (tw + twk) % M;
            k++;
        }
        return tw;
    }

    private long nCr(int n, int r) {
        return (r < 0 || r > n) ? 0L : (f[n] * ifac[r] % M) * ifac[n - r] % M;
    }

    public int numberOfWays(int n, int x, int y) {
        return (n == 0) ? 1 :
               ((x == 0) ? 0 :
               computeWays(n, x, y));
    }

    private int computeWays(int n, int x, int y) {
        int N = Math.max(n, x) + 5;
        help2(N);
        help3(N);
        help4(n);
        long tw = help6(x, Math.min(n, x), n, y);
        return (int) tw;
    }

    private long help(long a, long b, long m) {
        long r = 1L;
        a %= m;
        while (b > 0) {
            r = ((b & 1L) == 1L) ? (r * a) % m : r;
            a = (a * a) % m;
            b >>= 1L;
        }
        return r;
    }


    
}
",1420065421
Min,IAFB358kMw,84,3605,java,"import java.util.List;

class Solution {

    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            ans[i] = help(nums.get(i));
        }

        return ans;
    }

    private int help(int num) {
        int c = 0;

        while (c <= num && ((c | (c + 1)) != num)) {
            c++;
        }

        return (c <= num) ? c : -1;
    }
}
",1420008271
Min,IAFB358kMw,84,3611,java,"class Solution {
    
    private void help(List<Integer> nums, int[] ans, int n) {
        int i = 0;
        while (i < n) {
            ans[i] = help2(nums.get(i));
            i++;
        }
    }
    
    private int help2(int num) {
        int ans = Integer.MAX_VALUE;
        int k = 0;
        
        while (k <= 30) {
            int c = num & ~(1 << k);
            ans = (c >= 0 && (c | (c + 1)) == num && c < ans)
                     ? c 
                     : ans;
            k++;
        }
        
        return (ans == Integer.MAX_VALUE) ? -1 : ans;
    }
    
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        help(nums, ans, n);
        
        return ans;
    }
    
    
}
",1420021860
Gaurav Chaudhary,Technical_Guruji,87,3487,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
#define MOD             998244353
#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;





template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it




class Solution {

public:

    int maxRemovals(std::string inputString, std::string searchPattern, std::vector<int>& indexList) {

        int strLength = inputString.size();

        int patLength = searchPattern.size();

        std::vector<int> removalCounts(patLength + 1, std::numeric_limits<int>::max());

        removalCounts[0] = 0;
        std::vector<bool> isTarget(strLength, false);

        
        
        markTargetIndices(indexList, isTarget);
        
        fillRemovalCounts(inputString, searchPattern, removalCounts, strLength, patLength, isTarget);

        
        
        return calculateMaxRemovals(removalCounts, indexList.size());
    }
    


private:

    void markTargetIndices(const std::vector<int>& indices, std::vector<bool>& targetMarker) {

        int currentIndex = 0;

        while (currentIndex < indices.size()) {

            targetMarker[indices[currentIndex]] = true;

            currentIndex++;

        }

    }


    void fillRemovalCounts(const std::string& inputString, const std::string& searchPattern, std::vector<int>& removalCounts, int strLength, int patLength, const std::vector<bool>& targetMarker) {

        int i = 0;

        while (i < strLength) {

            int j = patLength;

            while (j > 0) {

                if (inputString[i] == searchPattern[j - 1] && removalCounts[j - 1] != std::numeric_limits<int>::max()) {

                    removalCounts[j] = std::min(removalCounts[j], removalCounts[j - 1] + (targetMarker[i] ? 1 : 0));

                }

                j--;

            }

            i++;

        }

    }


    int calculateMaxRemovals(const std::vector<int>& removalCounts, int targetCount) {

        if (removalCounts[removalCounts.size() - 1] == std::numeric_limits<int>::max()) {

            return targetCount;

        }

        return targetCount - removalCounts[removalCounts.size() - 1];

    }

};










#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420065728
Gaurav Chaudhary,Technical_Guruji,87,3604,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
//#define MOD             998244353
//#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;
const int MOD = 1e9 + 7;




template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it




class Solution {

public:

    int numberOfWays(int totalItems, int groupSize, int multiplier) {

        

        int maxValue = max(totalItems, groupSize) + 1;

        int groupLimit = groupSize;

        
        
        vector<long long> factorialArray(maxValue), invFactorialArray(maxValue);
        
        factorialArray[0] = invFactorialArray[0] = 1;

        
        
        int index = 1;
        
        while (index < maxValue) {
        
            factorialArray[index] = (factorialArray[index - 1] * index) % MOD;
            ++index;
        
        }

        
        
        invFactorialArray[maxValue - 1] = modInverse(factorialArray[maxValue - 1], MOD);
        
        index = maxValue - 2;
        
        while (index >= 1) {
        
            invFactorialArray[index] = (invFactorialArray[index + 1] * (index + 1)) % MOD;
        
            --index;
        
        }

        
        
        vector<vector<long long>> stirlingNumbers(totalItems + 1, vector<long long>(totalItems + 1, 0));
        
        stirlingNumbers[0][0] = 1;

        
        
        index = 1;
        
        
        while (index <= totalItems) {
            stirlingNumbers[index][0] = 0;
        
            int subgroup = 1;
        
            while (subgroup <= index) {
        
                stirlingNumbers[index][subgroup] = (stirlingNumbers[index - 1][subgroup - 1] + (subgroup * stirlingNumbers[index - 1][subgroup]) % MOD) % MOD;
        
                ++subgroup;
        
            }
        
            ++index;
        
        }

        
        
        long long totalWays = 0;
        
        for (int currentGroup = 1; currentGroup <= min(totalItems, groupLimit); ++currentGroup) {
        
            long long combinations = computeCombination(groupLimit, currentGroup, factorialArray, invFactorialArray, MOD);
        
            long long permutations = factorialArray[currentGroup];
        
            long long stirlingValue = stirlingNumbers[totalItems][currentGroup];
        
            long long scoreMultiplier = modPow(multiplier, currentGroup, MOD);

            
            
            long long ways = (((combinations * permutations) % MOD) * stirlingValue) % MOD;
            
            ways = (ways * scoreMultiplier) % MOD;
            
            totalWays = (totalWays + ways) % MOD;
        }
        
        
        return totalWays;
    }
    

    
private:
    
    long long modPow(long long base, long long exponent, long long mod) {
    
        long long result = 1;
    
        base %= mod;
    
        while (exponent > 0) {
    
            if (exponent & 1)
    
                result = (result * base) % mod;
    
            base = (base * base) % mod;
    
            exponent >>= 1;
    
        }
    
        return result;
    
    }

    
    
    long long modInverse(long long a, long long mod) {
    
        return modPow(a, mod - 2, mod);
    
    }

    
    long long computeCombination(int n, int k, const vector<long long>& factorialArray, const vector<long long>& invFactorialArray, long long mod) {
    
        if (k < 0 || k > n) return 0;
    
        return (((factorialArray[n] * invFactorialArray[k]) % mod) * invFactorialArray[n - k]) % mod;
    
    }
};















#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420065429
Gaurav Chaudhary,Technical_Guruji,87,3605,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
#define MOD             998244353
#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;





template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it



class Solution 

{ 

public: 

    vector<int> minBitwiseArray(vector<int> &arrInput) 

    { 

        vector<int> arrResult(arrInput.size(), -1); 
        processInputArray(arrInput, arrResult); 

        return arrResult; 

    } 

    
private:
    
    void processInputArray(const vector<int>& arrInput, vector<int>& arrResult) 
    
    { 
    
        int idx = 0;
    
        while (idx < arrInput.size()) 
    
        { 
    
            arrResult[idx] = computeMinBitwiseValue(arrInput[idx]); 
    
            ++idx; 
    
        } 
    
    } 

    
    int computeMinBitwiseValue(int valueCurrent) 
    
    { 
    
        int valueMin = -1; 
    
        int bitIndex = 0; 
    
        while (bitIndex <= 30) 
    
        { 
    
            if (valueCurrent & (1 << bitIndex)) 
    
            { 
    
                int valueNew = valueCurrent - (1 << bitIndex); 
    
                if (validateValue(valueNew, valueCurrent)) 
    
                { 
    
                    valueMin = updateMinValue(valueMin, valueNew); 
    
                } 
    
            } 
    
            ++bitIndex; 
    
        } 
    
        return valueMin; 
    
    } 

    
    
    bool validateValue(int valueNew, int valueOriginal) 
    { 
    
        return valueNew >= 0 && ((valueNew | (valueNew + 1)) == valueOriginal); 
    
    } 

    
    
    int updateMinValue(int valueCurrentMin, int valueNew) 
    
    { 
    
        return valueCurrentMin == -1 || valueNew < valueCurrentMin ? valueNew : valueCurrentMin; 
    
    } 
}; 








#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420066156
Gaurav Chaudhary,Technical_Guruji,87,3611,cpp,"#include<bits/stdc++.h>
#include <queue>
#include <algorithm>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
//#include <boost/math/common_factor.hpp>

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")


#define ff              first
#define ss              second
#define all(x)          begin(x), end(x)
#define pb              push_back
#define MOD             998244353
#define mod             998244353
#define INF             1e18
#define rev(x)          reverse(all(x));
#define nextP(v)        next_permutation(all(v))
#define Vmax(x)         (*max_element(all(x)))
#define Vmin(x)         (*min_element(all(x)))
#define Vsum(x)         accumulate(all(x),0ll)
#define lowB(v,x)       (lower_bound(all(v),x)-v.begin())
#define upB(v,x)        (upper_bound(all(v),x)-v.begin())
#define cntB(x)         (__builtin_popcountll(x))
#define cntC(s,x)       ll(count(all(s),x))
#define mp              make_pair
#define nl              cout << ""\n"";
//#define endl            ""\n"";
#define Yes             cout << ""Yes\n""
#define No              cout << ""No\n""
#define prs(n)          fixed << setprecision(n)
#define dbg(x)          cout << #x << "" = "" << x << endl;
#define inpt(v)         For(sz(v)) cin >> v[i];
#define prt(v)          {for(auto &x:v) cout << x << ' '; nl}
#define BIG             200005

#define For(n)          for (ll i = 0; i < n; i++)
#define ForR(n)         for (ll i = n; i >= 1; i--)
#define Forj(n)         for (ll j = 0; j < n; j++)
#define For1(n)         for (ll i = 1; i < n; i++)
#define Forl(x,y,z)     for (ll x = y; x < z; x++)
#define go(i,n)         for (ll i = 0; i <=n; ++i)
#define rep(i,a,n)      for (ll i = a; i <=n; i++)
#define out(x, end)     cout << x << (end)
using namespace std;





template <class T> using v = vector<T>;
using lli = long long int;
using ll = long long;
using ld = long double;
using vl = vector<long long>;
using vs  = vector<string>;
using vpl = vector<pair<ll,ll>>;
using sll = set<ll>;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
using pdd = pair<ld, ld>;
using mll = map<ll,ll>;
using vvl = vector<vector<ll>>;
using vpll = vector<pll>;

ll dp[1000009];
char sample[1000009];
const int alphabet = 'z' - 'a' + 1;


ll lcm(ll a, ll b) {
    // LCM = (a * b) / GCD(a, b)
    return (a / __gcd(a, b)) * b;
}
ll power(ll a,ll b) {ll r=1; while(b) {if(b&1) r=(r*a)%MOD; a=(a*a)%MOD; b/=2;} return r;}

vl sieve(ll n) {vl a(n+1,1),v; a[0]=a[1]=0; Forl(i,2,n+1) if(a[i]) {v.push_back(i); for(ll j=2*i; j <=n; j+=i) a[j]=0;} return a;}

vl divsr(ll n) {vl a(n+1,1); For(n+1) a[i]=i; Forl(i,2,n+1) if(a[i]==i) {for(ll j=2*i; j<=n; j+=i) a[j]=i;} return a;}
ll res;
vl fac(ll n) {vl v(n+1,1); Forl(i,2,n+1) v[i] = (v[i-1]*i)%MOD; return v;}

// put the class functiion insdie it



class Solution 

{ 

public: 

    vector<int> minBitwiseArray(vector<int> &arrInput) 

    { 

        vector<int> arrResult(arrInput.size(), -1); 
        processInputArray(arrInput, arrResult); 

        return arrResult; 

    } 

    
private:
    
    void processInputArray(const vector<int>& arrInput, vector<int>& arrResult) 
    
    { 
    
        int idx = 0;
    
        while (idx < arrInput.size()) 
    
        { 
    
            arrResult[idx] = computeMinBitwiseValue(arrInput[idx]); 
    
            ++idx; 
    
        } 
    
    } 

    
    int computeMinBitwiseValue(int valueCurrent) 
    
    { 
    
        int valueMin = -1; 
    
        int bitIndex = 0; 
    
        while (bitIndex <= 30) 
    
        { 
    
            if (valueCurrent & (1 << bitIndex)) 
    
            { 
    
                int valueNew = valueCurrent - (1 << bitIndex); 
    
                if (validateValue(valueNew, valueCurrent)) 
    
                { 
    
                    valueMin = updateMinValue(valueMin, valueNew); 
    
                } 
    
            } 
    
            ++bitIndex; 
    
        } 
    
        return valueMin; 
    
    } 

    
    
    bool validateValue(int valueNew, int valueOriginal) 
    { 
    
        return valueNew >= 0 && ((valueNew | (valueNew + 1)) == valueOriginal); 
    
    } 

    
    
    int updateMinValue(int valueCurrentMin, int valueNew) 
    
    { 
    
        return valueCurrentMin == -1 || valueNew < valueCurrentMin ? valueNew : valueCurrentMin; 
    
    } 
}; 








#ifdef LOCAL
int main() {

	freopen(""output.txt"", ""w"", stdout);
	cout << ""Compiled!"" << endl;
}
#endif

",1420065937
Maruzensky,Maruzensky,88,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        t = set(targetIndices)
        
        dp = [0]
        
        for i, c in enumerate(source):
            temp = []
            for idx in dp:
                if idx == m:
                    temp.append(m)
                elif c == pattern[idx]:
                    temp.append(idx + 1)
                else:
                    temp.append(idx)
            
            if i in t:
                temp.append(0)
                k = len(temp) - 2
                
                for j in range(k, -1, -1):
                    temp[j + 1] = max(temp[j + 1], dp[j])
                    
            dp = temp
        #     print(dp, t)
        # print('.')
            
        return max(i for i, v in enumerate(dp) if v == m)
                ",1420024118
Maruzensky,Maruzensky,88,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod = 10**9 + 7
        
        dp = [0, 1]
        
        for i in range(2, n + 1):
            temp = [0] * (i + 1)
            temp.append(0)
            for j in range(i - 1, 0, -1):
                temp[j + 1] += dp[j]
                temp[j] += dp[j] * j
                
            dp = [x % mod for x in temp]
            
        answer = 0
        p = y
        fact = x
        
        for dist in range(1, 1 + min(x, n)):
            answer = (answer + dp[dist] * fact * p) % mod
            fact = (fact * (x - dist)) % mod
            p = (p * y) % mod
            
        return answer",1420060336
Maruzensky,Maruzensky,88,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for x in nums:
            if x == 2:
                answer.append(-1)
                continue
                
            y = x + 1
            b = y & -y
            answer.append(x - (b >> 1))
            
        return answer",1419996972
Maruzensky,Maruzensky,88,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for x in nums:
            if x == 2:
                answer.append(-1)
                continue
                
            y = x + 1
            b = y & -y
            answer.append(x - (b >> 1))
            
        return answer",1419996479
Rahul Dev Sahoo,invictus__,89,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<bool> isTargetIndex(n, false);
        for (int idx : targetIndices) {
            isTargetIndex[idx] = true;
        }
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));
        for (int i = 0; i <= n; ++i)
            dp[i][0] = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (dp[i - 1][j] != INT_MAX)
                    dp[i][j] = min(dp[i][j], dp[i - 1][j]);
                if (j > 0 && source[i - 1] == pattern[j - 1] && dp[i - 1][j - 1] != INT_MAX) {
                    int cost = isTargetIndex[i - 1] ? 1 : 0;
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + cost);
                }
            }
        }
        int minUsed = dp[n][m];
        int maxOperations = targetIndices.size() - minUsed;
        return maxOperations;
    }
};
",1420045377
Rahul Dev Sahoo,invictus__,89,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int M = 1e9+7;
        int mx = n + x + 5;
        vector<long long> f(mx), invf(mx);
        f[0] = invf[0] = 1;
        for (int i = 1; i < mx; ++i) {
            f[i] = f[i - 1] * i % M;
            invf[i] = modPow(f[i], M - 2, M);
        }

        vector<vector<long long>> S(n + 1, vector<long long>(n + 1));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % M;

        long long res = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            long long term = comb(x, k, f, invf, M);
            term = term * f[k] % M;
            term = term * S[n][k] % M;
            term = term * modPow(y, k, M) % M;
            res = (res + term) % M;
        }
        return res;
    }
private:
    long long modPow(long long a, long long b, int m) {
        long long r = 1;
        a %= m;
        while (b) {
            if (b & 1) r = r * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return r;
    }
    long long comb(int n, int k, vector<long long>& f, vector<long long>& invf, int m) {
        if (k < 0 || k > n) return 0;
        return f[n] * invf[k] % m * invf[n - k] % m;
    }
};
",1420069362
Rahul Dev Sahoo,invictus__,89,3605,cpp,"class Solution {
public:



    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; ++i) {
            int N = nums[i];
            for(int a = 0; a <= N; ++a) {
                if((a | (a + 1)) == N) {
                    ans[i] = a;
                    break;
                }
            }
        }
        return ans;
        }
};",1420019060
Rahul Dev Sahoo,invictus__,89,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; ++i) {
            int num = nums[i], res = -1;
            for(int k = 0; k <= 30; ++k) {
                int s = num - (1 << k);
                if(s >= 0) {
                    int t = s + 1;
                    if((s | t) == num) {
                        if(res == -1 || s < res)
                            res = s;
                    }
                }
            }
            ans[i] = res;
        }
        return ans;
    }
};
",1420060648
Meet Brahmbhatt,MeetBrahmbhatt,90,3487,cpp,"const int inf = 1e7;
class Solution {
public:
    int maxRemovals(string s, string pat, vector<int>& target) {
        int n = (int) s.size();
        int m = (int) pat.size();
        
        vector<int> rem(n);
        for (int i : target) {
            rem[i] = 1;
        }
        
        vector<int> dp(m + 1, inf);
        dp[0] = 0;
        
        for (int i = 0; i < n; i++) {
            auto ndp = dp;
            for (int j = 0; j < m; j++) {
                if (s[i] == pat[j] && dp[j] != inf) {
                    ndp[j + 1] = min(ndp[j + 1], dp[j] + rem[i]);
                }
            }
            dp = ndp;
        }
        
        return (int) target.size() - dp[m];
    }
};",1420010233
Meet Brahmbhatt,MeetBrahmbhatt,90,3604,cpp,"constexpr int32_t MOD = 1e9 + 7;
// constexpr int32_t MOD = 998244353;

struct Mint {
    int val;
    Mint(long long v = 0) {
        if (v < 0) {
            v = v % MOD + MOD;
        }
        if (v >= MOD) {
            v %= MOD;
        }
        val = v;
    }
    static int mod_inv(int a, int m = MOD) {
        int g = m, r = a, x = 0, y = 1;
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
        return x < 0 ? x + m : x;
    }
    explicit operator int() const {
        return val;
    }
    Mint& operator+=(const Mint &other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    Mint& operator-=(const Mint &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    typedef unsigned long long ull;
    ull fast_mod(ull a, ull b, ull M = MOD) {
        long long ret = a * b - M * ull(1.L / M * a * b);
        return ret + M * (ret < 0) - M * (ret >= (long long)M);
    }
    Mint& operator*=(const Mint &other) {
        val = fast_mod((ull) val, other.val);
        return *this;
    }
    Mint& operator/=(const Mint &other) {
        return *this *= other.inv();
    }
    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }
    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }
    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }
    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }
    Mint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
    Mint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }
    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }
    Mint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
    bool operator==(const Mint &other) const { return val == other.val; }
    bool operator!=(const Mint &other) const { return val != other.val; }
    Mint inv() const {
        return mod_inv(val);
    }
    Mint pow(long long p) const {
        assert(p >= 0);
        Mint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            a *= a;
            p >>= 1;
        }
        return result;
    }
    friend ostream& operator<<(ostream &stream, const Mint &m) {
        return stream << m.val;
    }
    friend istream& operator >> (istream &stream, Mint &m) {
        return stream >> m.val;
    }
};

const int32_t N = 3e3;

Mint FAC[N + 1], INV[N + 1];
bool done = false;

void calc() {
    if (done) {
        return;
    }
    done = true;
    FAC[0] = 1;
    for (int i = 1; i <= N; i++) {
        FAC[i] = (FAC[i - 1] * i);
    }
    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);
    for (int i = N - 1; i >= 0; i--) {
        INV[i] = (INV[i + 1] * (i + 1));
    }
}
Mint ncr(int n, int r) {
    if (r < 0) return 0;
    if (n < r) return 0;
    if (r == 0) return 1;
    Mint a = FAC[n] * INV[r] * INV[n - r];
    return a;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {        
        
        vector<Mint> dp(x + 1);
        for (int i = 1; i <= x; i++) {
            dp[i] = Mint(i).pow(n);
            for (int j = i - 1; j >= 1; j--) {
                dp[i] -= dp[j] * ncr(i, j);
            }
        }
            
        calc();
        
        Mint ans = 0;
        for (int i = 1; i <= min(n, x); i++) {
            ans += ncr(x, i) * Mint(y).pow(i) * dp[i];
        }
        return ans.val;
    }
};",1420070621
Meet Brahmbhatt,MeetBrahmbhatt,90,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = (int) v.size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            if (v[i] == 2) {
                continue;
            }
            for (int j = 0; j < 31; j++) {
                if (~v[i] >> j & 1) {
                    res[i] = v[i] ^ (1 << (j - 1));
                    assert(res[i] | (res[i] + 1) == v[i]);
                    break;
                }
            }
        }
        
        return res;
    }
};",1419998652
Meet Brahmbhatt,MeetBrahmbhatt,90,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = (int) v.size();
        vector<int> res(n, -1);
        for (int i = 0; i < n; i++) {
            if (v[i] == 2) {
                continue;
            }
            for (int j = 0; j < 31; j++) {
                if (~v[i] >> j & 1) {
                    res[i] = v[i] ^ (1 << (j - 1));
                    assert(res[i] | (res[i] + 1) == v[i]);
                    break;
                }
            }
        }
        
        return res;
    }
};",1419998501
lqCKWBPxHc,lqCKWBPxHc,91,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        target_indices_set = set(targetIndices)

        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0

        for i in range(n):
            for j in range(m + 1):
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
            for j in range(m):
                if source[i] == pattern[j]:
                    cost = dp[i][j]
                    if i in target_indices_set:
                        cost += 1
                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], cost)

        min_required_kept = dp[n][m]
        max_removals = len(targetIndices) - min_required_kept if min_required_kept != float('inf') else 0
        return max_removals",1420070663
lqCKWBPxHc,lqCKWBPxHc,91,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        max_n = max(n, x) + 2
        fac = [1] * max_n
        inv_fac = [1] * max_n
        for i in range(1, max_n):
            fac[i] = fac[i - 1] * i % MOD
        inv_fac[max_n - 1] = pow(fac[max_n - 1], MOD - 2, MOD)
        for i in range(max_n - 2, -1, -1):
            inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD
        S = [[0] * max_n for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, min(i, x) + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
        ans = 0
        for k in range(1, min(n, x) + 1):
            term = fac[x] * inv_fac[k] % MOD * inv_fac[x - k] % MOD
            term = term * fac[k] % MOD
            term = term * S[n][k] % MOD
            term = term * pow(y, k, MOD) % MOD
            ans = (ans + term) % MOD
        return ans",1420006366
lqCKWBPxHc,lqCKWBPxHc,91,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def is_valid(ans, num):
            return (ans | (ans + 1)) == num

        ans = [-1] * len(nums)

        for i, num in enumerate(nums):
            candidate = num
            while candidate >= 0:
                if is_valid(candidate, num):
                    if ans[i] == -1 or candidate < ans[i]:
                        ans[i] = candidate
                candidate -= 1
                if candidate < 0 or (candidate | (candidate + 1)) > num:
                    break

        return ans",1420021226
lqCKWBPxHc,lqCKWBPxHc,91,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def is_valid(ans, num):
            return (ans | (ans + 1)) == num

        ans = [-1] * len(nums)

        for i, num in enumerate(nums):
            candidate = num
            while candidate >= 0:
                if is_valid(candidate, num):
                    if ans[i] == -1 or candidate < ans[i]:
                        ans[i] = candidate
                candidate -= 1
                if candidate < 0 or (candidate | (candidate + 1)) > num:
                    break

        return ans",1420020772
Temirlan,Tima_,92,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tg) {
        int n = s.size();
        int m = p.size();
        vector <int> used(n, 0);
        for(int i : tg) used[i] = 1;
        vector <vector<int> > dp(n + 1, vector <int> (m + 1, -int(1e9)));
        dp[0][0] = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= m; j++){
                if(s[i] == p[j]){
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + used[i]);
            }
        }
        //for(int i = 1; i <= n; i++){
        //    cout << dp[i][m] << "" "";
        //}
        int mx = dp[n][m];
        //for(int i = 1; i <= n; i++) mx = max(mx, dp[i][m] + (n - i));
        return mx;
    }
};",1420030352
Temirlan,Tima_,92,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector <vector <long long> > dp(n + 1, vector <long long> (n + 1, 0));
        dp[0][0] = 1;
        //vector <int> dp(n + 1, 0);
        vector <vector<int> > c(n + 1, vector<int> (n + 1, 0));
        int mod = (int)(1e9) + 7;
        for(int i = 0; i <= n; i++){
            c[i][0] = c[i][i] = 1;
            for(int j = 1; j < i; j++){
                c[i][j] = (c[i- 1][j - 1] + c[i - 1][j]) % mod; 
            }
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= min(i, x); j++){
                dp[i][j] = (dp[i - 1][j - 1] * (x - j + 1) + dp[i - 1][j] * j) % mod;
            }
        }
        long long res = 0, cur = 1;
        for(int i = 1; i <= min(x, n); i++){
            cur = cur * y % mod;
            res = (res + cur * dp[n][i]) % mod;
        }
        return res % mod;
    }
};",1420070704
Temirlan,Tima_,92,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans(1024, -1);
        for(int x = 0; x < 1023; x++){
            int y = (x | (x + 1));
            if(ans[y] == -1) ans[y] = x;
        }    
        vector <int> res;
        for(int x : nums) res.push_back(ans[x]);
        return res;
    }
};",1419994410
Temirlan,Tima_,92,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> res;
        for(int x : nums){
            if(x == 2){
                res.push_back(-1);
                continue;
            }
            int y = x, cnt = 0;
            while(y % 2 == 1){
                y /= 2;
                cnt++;
            }
            res.push_back((y<<cnt) + (1<<(cnt - 1)) - 1);
        }
        return res;
    }
};",1420003197
Abhishek,non_deterministic,93,3487,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

int dp[3005][3005];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> canBeRemoved(n + 1, 0);
        for(int i = 0; i < sz(targetIndices); i++) {
            canBeRemoved[targetIndices[i] + 1] = 1;
        }
        for(int i = 0; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                dp[i][j] = -1;
            }
            dp[i][0] = 0;
        }
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j <= m; j++) {
                dp[i][j] = dp[i - 1][j];
                if(j > 0 && source[i - 1] == pattern[j - 1] && dp[i - 1][j - 1] != -1) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                }
                if(canBeRemoved[i] == 1 && dp[i - 1][j] != -1) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1);
                }
            }
        }
        return dp[n][m];
    }
};
",1420040018
Abhishek,non_deterministic,93,3604,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

using ll = long long;
using ull = unsigned long long;
typedef unsigned int uint;
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
ll myRand(ll B) {
    return (ull)rng() % B;
}

const uint MOD = 1000000007;
template<uint mod = MOD> struct mint { // 1000000007  1000000009
    uint x;
 
    mint() : x(0) {}
    mint(ll _x) {
        _x %= mod;
        if (_x < 0) _x += mod;
        x = _x;
    }
 
    mint& operator += (const mint &a) {
        x += a.x;
        if (x >= mod) x -= mod;
        return *this;
    }
    mint& operator -= (const mint &a) {
        x += mod - a.x;
        if (x >= mod) x -= mod;
        return *this;
    }
    mint& operator *= (const mint &a) {
        x = (ull)x * a.x % mod;
        return *this;
    }
    mint pow(ll pw) const {
        mint res = 1;
        mint cur = *this;
        while(pw) {
            if (pw & 1) res *= cur;
            cur *= cur;
            pw >>= 1;
        }
        return res;
    }
    mint inv() const {
        assert(x != 0);
        uint t = x;
        uint res = 1;
        while(t != 1) {
            uint z = mod / t;
            res = (ull)res * (mod - z) % mod;
            t = mod - t * z;
        }
        return res;
    }
    mint& operator /= (const mint &a) {
        return *this *= a.inv();
    }
    mint operator + (const mint &a) const {
        return mint(*this) += a;
    }
    mint operator - (const mint &a) const {
        return mint(*this) -= a;
    }
    mint operator * (const mint &a) const {
        return mint(*this) *= a;
    }
    mint operator / (const mint &a) const {
        return mint(*this) /= a;
    }
 
    bool sqrt(mint &res) const {
        if (mod == 2 || x == 0) {
            res = *this;
            return true;
        }
        if (pow((mod - 1) / 2) != 1) return false;
        if (mod % 4 == 3) {
            res = pow((mod + 1) / 4);
            return true;
        }
        int pw = (mod - 1) / 2;
        int K = 30;
        while((1 << K) > pw) K--;
        while(true) {
            mint t = myRand(mod);
            mint a = 0, b = 0, c = 1;
            for (int k = K; k >= 0; k--) {
                a = b * b;
                b = b * c * 2;
                c = c * c + a * *this;
                if (((pw >> k) & 1) == 0) continue;
                a = b;
                b = b * t + c;
                c = c * t + a * *this;
            }
            if (b == 0) continue;
            c -= 1;
            c *= mint() - b.inv();
            if (c * c == *this) {
                res = c;
                return true;
            }
        }
        assert(false);
    }
 
    bool operator == (const mint &a) const {
        return x == a.x;
    }
    bool operator != (const mint &a) const {
        return x != a.x;
    }
    bool operator < (const mint &a) const {
        return x < a.x;
    }
};
using Mint = mint<>;

Mint dp[1005][1005];

template<uint mod = MOD> struct Factorials {
    using Mint = mint<mod>;
    vector<Mint> f, fi;
 
    Factorials() : f(), fi() {}
    Factorials(int n) {
        n += 10;
        f = vector<Mint>(n);
        fi = vector<Mint>(n);
        f[0] = 1;
        for (int i = 1; i < n; i++)
            f[i] = f[i - 1] * i;
        fi[n - 1] = f[n - 1].inv();
        for (int i = n - 1; i > 0; i--)
            fi[i - 1] = fi[i] * i;
    }
 
    Mint C(int n, int k) {
        if (k < 0 || k > n) return 0;
        return f[n] * fi[k] * fi[n - k];
    }
};

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        Factorials fact(1005);
        repI(i, 0, n) {
            repI(j, 0, x) {
                dp[i][j] = 0;
            }
        }
        dp[0][0] = 1;
        // dp[1][1] = 1;
        repI(i, 1, n) {
            repI(j, 1, x) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] * j;
                // Error(i, j, dp[i][j].x);
            }
        }
        Mint ans = 0;
        repI(i, 1, x) {
            ans += dp[n][i] * Mint(y).pow(i) * fact.f[x] * fact.fi[x - i];
        }
        return ans.x;
    }
};
",1420072085
Abhishek,non_deterministic,93,3605,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        rep(i, 0, n-1) {
            if(nums[i] == 2) {
                continue;
            }
            int firstZeroBit = 0;
            while((nums[i] & (1 << firstZeroBit)) != 0) {
                firstZeroBit++;
            }
            firstZeroBit--;
            ans[i] = nums[i] - (1 << firstZeroBit);
        }
        return ans;
    }
};",1420025330
Abhishek,non_deterministic,93,3611,cpp,"#define lld long long
#define rep(i,a,n) for(lld i = (a); i <= (n); ++i)
#define repI(i,a,n) for(int i = (a); i <= (n); ++i)
#define repD(i,a,n) for(lld i = (a); i >= (n); --i)
#define repDI(i,a,n) for(int i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define sz(a) ((int)a.size())

#define Error(x...) { cout << ""("" << #x << "")"" << "" = ( ""; printIt(x); }
template <typename T1> void printIt(T1 t1) { cout << t1 << "" )"" << endl; }
template <typename T1, typename... T2>
void printIt(T1 t1, T2... t2) { cout << t1 << "" , ""; printIt(t2...); }
#define errorpair(a) cout<<#a<<"" = ( ""<<((a).first)<<"" , ""<<((a).second)<<"" )\n"";

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        rep(i, 0, n-1) {
            if(nums[i] == 2) {
                continue;
            }
            int firstZeroBit = 0;
            while((nums[i] & (1 << firstZeroBit)) != 0) {
                firstZeroBit++;
            }
            firstZeroBit--;
            ans[i] = nums[i] - (1 << firstZeroBit);
        }
        return ans;
    }
};",1420025023
seg_tree,_rajat_18_,94,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size();
        int m=pattern.size();
        vector<int>dp(m+1,INT_MAX);
        dp[0]=0;
        vector<bool>ndp(n,false);
        for(auto it=targetIndices.begin();it!=targetIndices.end();++it)
        {
            ndp[*it]=true;
        }
        for(int i=0;i<n;++i)
        {
            for(int j=m;j>0;--j)
            {
                if(source[i]==pattern[j-1] && dp[j-1]!=INT_MAX)
                {
                    dp[j]=min(dp[j],dp[j-1]+(ndp[i]?1:0));
                }
            }
        }
        return targetIndices.size()-(dp[m]==INT_MAX?0:dp[m]);
    }
};",1420064555
seg_tree,_rajat_18_,94,3604,cpp,"const int MOD=1000000007;
class Solution {
public:
    int numberOfWays(int n,int x,int y) {
        int maxi=max(n,x);
        vector<long long>fact(maxi+1,1);
        for(int i=1;i<=maxi;++i)
        {
            fact[i]=(fact[i-1]*i)%MOD;
        }
        vector<long long>inv_fact(maxi+1,1);
        inv_fact[maxi]=power(fact[maxi],MOD-2);
        for(int i=maxi-1;~i;--i)
        {
            inv_fact[i]=(inv_fact[i+1]*(i+1))%MOD;
        }
        vector<long long>precompute(x+1,0);
        vector<long long>iter(x+1,0);
        precompute[0]=1;
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=min(i,x);++j)
            {
                iter[j]=(precompute[j-1]+(j*precompute[j])%MOD)%MOD;
            }
            for(int j=0;j<=x;++j)
            {
                precompute[j]=iter[j];
                iter[j]=0;
            }
        }
        vector<long long>test=precompute;
        vector<long long>dp(x+1,1);
        for(int k=1;k<=x;++k)
        {
            dp[k]=(dp[k-1]*y)%MOD;
        }
        long long res=0;
        int K=min(x,n);
        for(int k=1;k<=K;++k)
        {
            long long P=(fact[x]*inv_fact[x-k])%MOD;
            long long S=test[k];
            long long recur=dp[k];
            long long term=((P*S)%MOD*recur)%MOD;
            res=(res+term)%MOD;
        }
        return (long long)res;
    }
private:
    long long power(long long a,long long b)
    {
        long long res=1;
        a%=MOD;
        while(b>0)
        {
            if(b&1)
            {
                res=(res*a)%MOD;
            }
            a=(a*a)%MOD;
            b>>=1;
        }
        return res;
    }
};",1420037140
seg_tree,_rajat_18_,94,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto& it:nums)
        {
            bool ok=false;
            for(int i=0;i<=it;++i)
            {
                if((i|(i+1))==it)
                {
                    ans.push_back(i);
                    ok=true;
                    break;
                }
            }
            if(!ok)ans.push_back(-1);
        }
        return ans;
    }
};",1419994897
seg_tree,_rajat_18_,94,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto& it:nums)
        {
            if(it<=1)
            {
                ans.push_back(-1);
                continue;
            }
            vector<int>add_;
            for(int i=0;i<32;++i)
            {
                if(it&(1<<i))
                {
                    int bits=it&~(1<<i);
                    if((bits|(bits+1))==it)
                    {
                        add_.push_back(bits);
                    }
                }
            }
            if(!add_.empty())
            {
                ans.push_back(*min_element(add_.begin(),add_.end()));
            }
            else
            {
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420000518
invertedwinger,invertedwinger,96,3487,cpp,"const int N = 3005;
int dp[N][N];
class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& v) {
        int n = s.length(), m = p.length();
        for(int i=0; i<=n; i++) for(int j=0; j<=m; j++) dp[i][j] = -1;
        dp[0][0] = 0;
        vector<bool> c(n+1,false);
        for(int x:v) c[x+1] = true;
        for(int i=1; i<=n; i++){
            dp[i][0] = dp[i-1][0] + c[i];
            for(int j=1; j<=m; j++){
                dp[i][j] = dp[i-1][j];
                if(s[i-1] == p[j-1]) dp[i][j] = dp[i-1][j-1];
                if(!c[i]) continue;
                if(dp[i-1][j] != -1) dp[i][j] = max(dp[i][j], dp[i-1][j]+1);
            }
        }
        return dp[n][m];
    }
};",1420024366
invertedwinger,invertedwinger,96,3604,cpp,"typedef long long ll;
const ll mod = 1e9+7;
const ll N=1e3+5;
ll fct[N],inv[N],invfct[N], p[N][N];
class Solution {
public:
    ll ncr(ll n,ll r){
        if(n<0 || r<0 || n-r<0)return 0;
        ll ans = fct[n]*invfct[r];
        ans%=mod;
        ans = ans * invfct[n-r];
        ans%=mod;
        return ans;
    }
    ll get(ll n, ll m){
        if(m>n) return 0;
        ll sign = -1,ans=p[m][n];
        for(int i=1; i<=m; i++){
            ll x = (ncr(m,i)*p[m-i][n])%mod;
            ans = (ans + sign * (x))%mod;
            sign *= -1;
        }
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        fct[0]=fct[1]=1;
        inv[1]=1;
        invfct[0]=invfct[1]=1;
        for(ll i=2;i<N;i++){
            fct[i]=i*fct[i-1]%mod;
            inv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;
            invfct[i]=ll(inv[i])*invfct[i-1]%mod;
        }
        for(ll i=0; i<N; i++){
            p[i][0] = 1;
            if(i==0) p[i][0]=0;
            for(ll j=1; j<N; j++) p[i][j] = (p[i][j-1]*i)%mod;
        }

        ll ans = 0;
        for(int i=1; i<=x; i++){
            ll t = (ncr(x,i)*get(n,i))%mod;
            //cout<<get(n,i)<<endl;
            t = (t*p[y][i])%mod;
            ans = (ans+t)%mod;
        }
        if(ans<0) ans+=mod;
        return ans;
    }
};",1420074176
invertedwinger,invertedwinger,96,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int x = a[i];
            if(x&1){
                for(int j=1; j<15; j++){
                    if((x>>j)&1) continue;
                    int b = 1<<(j-1);
                    ans[i] = (x ^ b);
                    break;
                }
            }
            else ans[i] = -1;
        }
        return ans;
    }
};",1420002657
invertedwinger,invertedwinger,96,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = a.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int x = a[i];
            if(x&1){
                for(int j=1; j<15; j++){
                    if((x>>j)&1) continue;
                    int b = 1<<(j-1);
                    ans[i] = (x ^ b);
                    break;
                }
            }
            else ans[i] = -1;
        }
        return ans;
    }
};",1420003700
Aravind_001,aravind_1,97,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        a = len(source)
        b= len(pattern)
        dp = [float('inf')] * (b + 1)
        dp[0] = 0  
        isT = [False] * a
        for i in targetIndices:
            isT[i] = True
        for i in range(a):
            for j in range(b, 0, -1):  
                if source[i] == pattern[j - 1]:
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isT[i] else 0))
        r = len(targetIndices) - (0 if dp[b] == float('inf') else dp[b])
        
        return r",1420066989
Aravind_001,aravind_1,97,3604,java,"class Solution {
    private static final int MO = 1_000_000_007;

    public int numberOfWays(int n, int x, int y) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, x); j++) {
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MO;
            }
        }
        long[][] C = new long[x + 1][x + 1];
        C[0][0] = 1;
        for (int i = 1; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MO;
            }
        }
        long[] ft = new long[x + 1];
        ft[0] = 1;
        for (int k = 1; k <= x; k++) {
            ft[k] = (ft[k - 1] * k) % MO;
        }
        long[] py = new long[x + 1];
        py[0] = 1;
        for (int k = 1; k <= x; k++) {
            py[k] = (py[k - 1] * y) % MO;
        }
        long res = 0;
        int mk = Math.min(n, x);
        for (int k = 1; k <= mk; k++) {
            long cb = C[x][k];
            long st = S[n][k];
            long fk = ft[k];
            long yp = py[k];
            long tmp = (((cb * st) % MO) * fk) % MO;
            tmp = (tmp * yp) % MO;
            res = (res + tmp) % MO;
        }

        return (int) res;
    }
}",1420042891
Aravind_001,aravind_1,97,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] a = new int[n];
        
        for (int i = 0; i < n; i++) {
            int b = nums.get(i);
            a[i] = -1; 
            
            for (int j = 0; j < b; j++) {
                if ((j | (j + 1)) == b) {
                    a[i] = j;
                    break; 
                }
            }
        }
        
        return a;
    }
}",1419996740
Aravind_001,aravind_1,97,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] rs = new int[n];
        
        for(int i = 0; i < n; i++) {
            int p = nums.get(i);
            int mx = Integer.MAX_VALUE;
            int t = p;
            int b = 0;
            
            while(t > 0) {
                if((t & 1) == 1) {
                    int x = p & (~(1 << b));
                    if((x | (x + 1)) == p) {
                        if(x < mx) {
                            mx = x;
                        }
                    }
                }
                t = t >>> 1;
                b++;
            }
            rs[i] = (mx != Integer.MAX_VALUE) ? mx : -1;
        }
        return rs;
    }
}",1420012213
Xiaomeng Yang,yangxm,98,3487,cpp,"constexpr int MAX = 3010;

int lcs[MAX][MAX], dp[MAX][MAX];
bool vis[MAX];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
      const string& s = source;
      const string& p = pattern;
      const auto& a = targetIndices;
      int n = s.length(), m = p.length();
      memset(vis, 0, sizeof(vis));
      for (int x : a) {
        vis[x + 1] = true;
      }
      for (int i = 0; i <= m; ++i) {
        lcs[i][0] = 0;
      }
      for (int i = 0; i <= n; ++i) {
        lcs[0][i] = 0;
      }
      for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
          lcs[i][j] = max(lcs[i - 1][j], lcs[i][j - 1]);
          if (p[i - 1] == s[j - 1]) {
            lcs[i][j] = max(lcs[i][j], lcs[i - 1][j - 1] + 1);
          }
        }
      }
      dp[0][0] = 0;
      for (int i = 1; i <= n; ++i) {
        dp[0][i] = dp[0][i - 1] + vis[i];
      }
      for (int i = 1; i <= m; ++i) {
        dp[i][0] = -1;
        for (int j = 1; j <= n; ++j) {
          if (lcs[i][j] < i) {
            dp[i][j] = -1;
          } else {
            dp[i][j] = 0;
            if (lcs[i - 1][j - 1] == i - 1 && p[i - 1] == s[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1];
            }
            if (lcs[i][j - 1] == i) {
              dp[i][j] = max(dp[i][j], dp[i][j - 1] + vis[j]);
            }
          }
        }
      }
      return dp[m][n];
    }
};",1420052250
Xiaomeng Yang,yangxm,98,3604,cpp,"using i64 = long long;

constexpr int MAX = 1024;
constexpr int MOD = 1000000007;

i64 dp[MAX][MAX];

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
      int m = min(n, x);
      for (int i = 1; i <= n; ++i) {
        fill(dp[i], dp[i] + m + 1, 0);
        dp[i][1] = x;
        for (int j = 2; j <= m && j <= i; ++j) {
          i64 p = (i64)(x - j + 1) * dp[i - 1][j - 1] % MOD;
          i64 q = (i64)j * dp[i - 1][j] % MOD;
          dp[i][j] = (p + q) % MOD;
        }
      }
      i64 ret = 0, w = 1;
      for (int i = 1; i <= m; ++i) {
        w = w * y % MOD;
        i64 cur = dp[n][i] * w % MOD;
        ret = (ret + cur) % MOD;
      }
      return ret;
    }
};",1420074980
Xiaomeng Yang,yangxm,98,3605,cpp,"int Calc(int x) {
  if (x == 2) {
    return -1;
  }
  int cnt = 0;
  for (int i = x; i > 0 && (i & 1); i >>= 1) {
    ++cnt;
  }
  int v = (1 << (cnt - 1)) - 1;
  return x - ((1 << cnt) - 1) + v;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      int n = nums.size();
      vector<int> ret(n);
      for (int i = 0; i < n; ++i) {
        ret[i] = Calc(nums[i]);
      }
      return ret;
    }
};;",1420002462
Xiaomeng Yang,yangxm,98,3611,cpp,"int Calc(int x) {
  if (x == 2) {
    return -1;
  }
  int cnt = 0;
  for (int i = x; i > 0 && (i & 1); i >>= 1) {
    ++cnt;
  }
  int v = (1 << (cnt - 1)) - 1;
  return x - ((1 << cnt) - 1) + v;
}

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
      int n = nums.size();
      vector<int> ret(n);
      for (int i = 0; i < n; ++i) {
        ret[i] = Calc(nums[i]);
      }
      return ret;
    }
};",1420002005
LucasLyu,Lucas595,100,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        target_set = set(targetIndices)
        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        for i in range(n):
            for j in range(m + 1):
                if dp[i][j] < float('inf'):
                    if dp[i + 1][j] > dp[i][j]:
                        dp[i + 1][j] = dp[i][j]
                    if j < m and source[i] == pattern[j]:
                        cost = dp[i][j] + (1 if i in target_set else 0)
                        if dp[i + 1][j + 1] > cost:
                            dp[i + 1][j + 1] = cost
        min_used = dp[n][m]
        max_op = len(targetIndices) - min_used
        return max(0, max_op)",1420056583
LucasLyu,Lucas595,100,3604,python3,"MOD = 10**9 + 7
MAX_N = 1000

factorial = [1] * (2 * MAX_N + 1)
for i in range(1, len(factorial)):
    factorial[i] = factorial[i - 1] * i % MOD

inv_factorial = [1] * (2 * MAX_N + 1)
inv_factorial[-1] = pow(factorial[-1], MOD - 2, MOD)
for i in reversed(range(len(inv_factorial) - 1)):
    inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

S = [[0] * (MAX_N + 1) for _ in range(MAX_N + 1)]
S[0][0] = 1
for n in range(1, MAX_N + 1):
    for k in range(1, n + 1):
        S[n][k] = (k * S[n - 1][k] + S[n - 1][k - 1]) % MOD


class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        total_ways = 0
        min_k = min(n, x)
        for k in range(1, min_k + 1):
            C_xk = factorial[x] * inv_factorial[k] % MOD * inv_factorial[x - k] % MOD
            k_fact = factorial[k]
            S_nk = S[n][k]
            y_k = pow(y, k, MOD)
            term = C_xk * k_fact % MOD * S_nk % MOD * y_k % MOD
            total_ways = (total_ways + term) % MOD
        return total_ways
        ",1420060469
LucasLyu,Lucas595,100,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:

        @lru_cache()
        def map(num: int) -> int:
            for i in range(num >> 1, num):
                if (i | (i + 1)) == num:
                    return i
            return -1

        return [map(num) for num in nums]
        ",1420006899
LucasLyu,Lucas595,100,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            min_a = -1
            if N == 2:
                ans.append(-1)
                continue
            for k in range(N.bit_length()):
                if (N >> k) & 1:
                    a = N - (1 << k)
                    if a >= 0 and (a | (a + 1)) == N:
                        if min_a == -1 or a < min_a:
                            min_a = a
            ans.append(min_a)
        return ans
        ",1420047772
M Kawa,mkawa222,101,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        inf=10**16
        n=len(source)
        m=len(pattern)
        dp=[[-inf]*(m+1) for _ in range(n+1)]
        for i in range(n):dp[i][0]=0
        ok=[0]*n
        for i in targetIndices:ok[i]=1
        for i in range(n+1):
            for j in range(m+1):
                if i<n and j<m and source[i]==pattern[j]:dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j])
                if i<n:dp[i+1][j]=max(dp[i+1][j],dp[i][j]+ok[i])
        ans=dp[n][m]
        if ans<0:ans=-1
        return ans
",1420057334
M Kawa,mkawa222,101,3604,python3,"md=10**9+7

def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

def nPr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_n-com_r]%md

n_max = 2000
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md

dp=[[0]*1001 for _ in range(1001)]
dp[0][0]=1
for n in range(1,1001):
    for k in range(1,n+1):
        dp[n][k]=dp[n-1][k]*k%md
        if k:
            dp[n][k]+=dp[n-1][k-1]
            dp[n][k]%=md

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans=0
        for i in range(1,x+1):
            ans+=dp[n][i]*nPr(x,i)%md*pow(y,i,md)%md
            ans%=md
        return ans
",1420075682
M Kawa,mkawa222,101,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for a in nums:
            if a==2:
                ans.append(-1)
            else:
                k=0
                while a>>k&1:k+=1
                k-=1
                a^=1<<k
                ans.append(a)
        return ans
",1420006237
M Kawa,mkawa222,101,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for a in nums:
            if a==2:
                ans.append(-1)
            else:
                k=0
                while a>>k&1:k+=1
                k-=1
                a^=1<<k
                ans.append(a)
        return ans
",1420005570
Shango Xiao,i_love_xiaoshagua_cpp,102,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        """"""
        dp[i][j] stores the maximum characters k which can be removed, so that
        source[:i] - k characters still contains pattern[:j]
        dp[i][j] = (remove source[i], dp[i - 1][j] + 1; don't remove source[i] but can't use it, dp[i-1][j]; don't remove source[i] and use it because source[i] = pattern[j], dp[i - 1][j - 1] + 1)
        answer is dp[-1][-1]
        """"""
        m = len(source)
        n = len(pattern)
        dp = [[float('-inf')] * (n + 1) for _ in range(2)]
        ti = set(targetIndices)
        dp[-1][-1] = 0
        for i in range(m):
            curr = i % 2
            prev = 1 - curr
            for j in range(n + 1):
                dp[curr][j] = float('-inf')
            for j in range(n + 1):
                if j == n:
                    dp[curr][j] = dp[prev][j]
                    if i in ti:
                        dp[curr][j] += 1
                    break
                dp[curr][j] = max(dp[curr][j], (1 if i in ti else 0) + dp[prev][j])
                if source[i] == pattern[j]:
                    dp[curr][j] = max(dp[curr][j], dp[prev][j - 1])
            # print(i, dp[curr])
        return dp[1 - (m % 2)][n - 1]",1420048945
Shango Xiao,i_love_xiaoshagua_cpp,102,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        """"""
        For a given k, we can compute how many ways we can assign performers to exactly k stages.
        sum_k #{assign n performers to exactly 1, 2, ..., k} * choose(x, k) * (y ^ k)
        #{assign n performers to exactly 1-k} = k^n - k*assign exactly to 1-(k-1) - ...
        """"""
        mod = 1000000007
        fact = [1]
        for i in range(1, 1005):
            fact.append((fact[i-1] * i) % mod)
        def mi(x):
            return pow(x, mod - 2, mod)
        ifact = [mi(fact[i]) for i in range(1005)]
        prep = []
        prep.append(1)
        def choose(u, v):
            base = fact[u]
            base = (base * ifact[v]) % mod
            base = (base * ifact[u - v]) % mod
            return base
        for k in range(2, x + 1):
            ans = pow(k, n, mod)
            for i in range(1, k):
                ans += mod - ((choose(k, i) * prep[i - 1]) % mod)
                ans %= mod
            prep.append(ans)
        print(prep)
        rtn = 0
        for k in range(1, x+1):
            now = prep[k-1]
            now = (now * choose(x, k)) % mod
            now = (now * pow(y, k, mod)) % mod
            rtn += now
            rtn %= mod
        return rtn
            ",1420075702
Shango Xiao,i_love_xiaoshagua_cpp,102,3605,python3,"def f(x):
    if x == 2:
        return -1
    assert x % 2 == 1
    for k in range(36, -1, -1):
        if 2 ** k > x:
            continue
        cand = x - (2 ** k)
        if x == (cand | (cand + 1)):
            return cand
    assert False
    return None

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [f(x) for x in nums]",1420001319
Shango Xiao,i_love_xiaoshagua_cpp,102,3611,python3,"def f(x):
    if x == 2:
        return -1
    assert x % 2 == 1
    for k in range(36, -1, -1):
        if 2 ** k > x:
            continue
        cand = x - (2 ** k)
        if x == (cand | (cand + 1)):
            return cand
    assert False
    return None

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [f(x) for x in nums]",1420001039
Vikash Sangai,VS_Codes,103,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& v) {
        // int ans=0;
        unordered_map<int,bool> mp;
        for(auto &it:v)
            mp[it]=true;
        int n=s.size(),m=p.size();
        vector<vector<int>> dp(n+1,vector<int> (m+1,-1e9));
        dp[0][0]=0;
        for(int i=0;i<n;i++)
        {
            dp[i+1][0]=dp[i][0];
            if(mp[i])
                dp[i+1][0]++;
        }
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                dp[i+1][j+1]=dp[i][j+1];
                if(mp[i])
                    dp[i+1][j+1]++;
                if(s[i]==p[j])
                    dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);
            }
        }
        return dp[n][m]>=0?dp[n][m]:0;
    }
};",1420076087
Vikash Sangai,VS_Codes,103,3604,cpp,"class Solution {
public:
    const int mod=1e9+7;
    long long binaryExp(long long a, long long b)
    {
        a%=mod;
        long long ans=1;
        while(b>0)
        {
            if(b&1)
            {
                ans*=a;
                ans%=mod;
            }
            a*=a;
            a%=mod;
            b>>=1;
        }
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> st(n+1, vector<long long>(n+1,0));
        int mx=max(x,n)+1;
        vector<long long> fact(mx),inv(mx);
        st[0][0] = 1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=i;j++)
            {
                st[i][j]=(st[i-1][j-1]+j*st[i-1][j]);
                st[i][j]%=mod;
            }
        }
        fact[0]=1;
        for(int i=1;i<mx;++i)
        {
            fact[i]=fact[i-1]*1LL*i;
            fact[i]%=mod;
        }
        inv[mx-1]=binaryExp(fact[mx-1],mod-2);
        for(int i=mx-2;i>=0;--i)
        {
            inv[i]=inv[i+1]*1LL*(i+1);
            inv[i]%=mod;
        }
        long long ans=0;
        for(int i=1;i<=min(n,x);i++)
        {
            long long temp=fact[i];
            temp*=fact[x];
            temp%=mod;
            temp*=inv[i];
            temp%=mod;
            temp*=inv[x-i];
            temp%=mod;
            temp*=st[n][i];
            temp%=mod;
            temp*=binaryExp(y,i);
            temp%=mod;
            ans+=temp;
            ans%=mod;
        }
        return ans;
    }
};",1420044867
Vikash Sangai,VS_Codes,103,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=nums[i];j++)
            {
                if((j|(j+1))==nums[i])
                {
                    ans[i]=j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419994206
Vikash Sangai,VS_Codes,103,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++)
        {
            for(int j=29;j>=0;j--)
            {
                int temp=(1<<j);
                int toadd=v[i]-temp;
                if((toadd|(toadd+1))==v[i])
                {
                    ans[i]=toadd;
                    break;
                }
            }
        }
        return ans;
    }
};",1420053407
Ayush,as_313,104,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        f = [False] * len(s)
        self.updateFlags(f, t)
        dp = self.initializeDP(len(p))
        
        for i in range(len(s)):
            self.updateDP(dp, s[i], p, f[i], len(p))
        
        return len(t) - (0 if dp[len(p)] == float('inf') else dp[len(p)])

    def updateFlags(self, f: List[bool], t: List[int]) -> None:
        for i in t:
            f[i] = True

    def initializeDP(self, m: int) -> List[int]:
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        return dp

    def updateDP(self, dp: List[int], char: str, p: str, isTarget: bool, m: int) -> None:
        for j in range(m, 0, -1):
            if char == p[j-1] and dp[j-1] != float('inf'):
                dp[j] = min(dp[j], dp[j-1] + (1 if isTarget else 0))
",1420052496
Ayush,as_313,104,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        def C(k: int) -> List[List[int]]:
            c = [[0] * (k + 1) for _ in range(k + 1)]
            for i in range(k + 1):
                c[i][0] = 1
                for j in range(1, i + 1): c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD
            return c
        
        def S(n: int, k: int) -> List[List[int]]:
            stir = [[0] * (k + 1) for _ in range(n + 1)]
            stir[0][0] = 1
            for i in range(1, n + 1):
                for j in range(1, k + 1): stir[i][j] = (j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD
            return stir

        c = C(x)
        stir = S(n, x)
        fact = [1] * (x + 1)
        for i in range(1, x + 1): fact[i] = fact[i - 1] * i % MOD

        return sum(c[x][k] * stir[n][k] * fact[k] * pow(y, k, MOD) for k in range(1, x + 1)) % MOD
",1420069282
Ayush,as_313,104,3605,python3,"class Solution(object):
    def findMinAns(self, p):
        for x in range(1, p + 1):
            if (x | (x + 1)) == p: return x
        return -1

    def minBitwiseArray(self, n):
        return [self.findMinAns(x) for x in n]
",1420003838
Ayush,as_313,104,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, n: List[int]) -> List[int]:
        a = []
        for x in n:
            m = float('inf')
            f = 0
            for b in range(31):
                if (x >> b) & 1:
                    c = x & ~(1 << b)
                    if c >= 0 and (c | (c + 1)) == x: m = min(m, c); f = 1
            a.append(m if f else -1)
        return a
",1420058998
Ashwanth K,ashwanthkannan,105,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {


        int n = s.length();
        int alloc[n];
        for(int i = 0 ; i < n ; i ++ ) alloc[i] = 0;
        for(int x : t) alloc[x] = 1;
        int m = p.length();

        int dp[n+1][m+1];

        for(int i = n ; i >= 0 ; i --)
        {
            for(int j = m ; j >= 0 ; j --)
            {
                if(i == n)
                {
                    if(j == m) {
                        dp[i][j] = 0;
                        continue;
                    }
                    dp[i][j] = -10000;
                    continue;
                }

                int ans = -10000;
                if(j < m && s[i] == p[j])
                {
                    ans = max(ans , dp[i+1][j+1]);
                }

                if(alloc[i])
                {
                    ans = max(ans , 1 + dp[i+1][j]);
                }

                ans = max(ans , dp[i+1][j]);

                dp[i][j] = ans;
            }
        }

        return dp[0][0];
    }
};",1420062361
Ashwanth K,ashwanthkannan,105,3604,cpp,"#define ll long long

ll mod = 1e9 + 7;
int sz = 1005;
ll fact[1005];
ll ifact[1005];
 
ll power(ll x, ll n)   //x base n exponent
{
    if(n==0) return 1;
    x = x%mod;
    if(x%mod==0) return 0;   //For large N,%mod- > mod is prime
    n = n%(mod-1);
    ll pow = 1;
    while (n)
    {
        if (n & 1)
            pow = (pow*x)%mod;
        n = n >> 1;
        x = (x*x)%mod;
    }
    return pow;
}
 
ll inv_mod(ll x)
{
	return power(x , mod - 2)%mod;
}
 
void factorial()
{
	fact[0] = 1;
	fact[1] = 1;
	ifact[0] = 1;
	ifact[1] = 1;
	
	for(int i = 2 ; i < sz ; i ++)
	{
		fact[i] = (fact[i-1]*i)%mod;	
	}
	ifact[sz-1] = inv_mod(fact[sz-1]);
 
	for(int i = sz-2 ; i > 0 ; i --)
	{
		ifact[i] = (ifact[i+1]*(i+1))%mod;
	}
}
 
ll ncr(ll n , ll r)
{
	if(n<r || r<0) return 0;
	if(r == 0) return 1;
	return (((fact[n]*ifact[n-r])%mod)*ifact[r])%mod;
}


ll dp[1005][1005];
int N , X , Y;
ll recur(int i , int j)
{
    ll ans = 0;
    if(i == N)
    {   
        ans = fact[j];
        ans *= ncr(X , j);
        ans %= mod;
        ans *= power(Y , j);
        ans %= mod;
        return ans;
    }

    if(dp[i][j] != -1) return dp[i][j];
    ans  += j*recur(i+1 , j);
    ans %= mod;
    ans  += recur(i+1 , j+1);
    ans %= mod;
    return dp[i][j] = ans;
}

class Solution {
public:
    
    int numberOfWays(int n, int x, int y) {
        factorial();
        N=  n;
        X = x;
        Y = y;

        for(int i = 0 ; i <= n ; i ++)
        {
            for(int j = 0 ; j <= n ; j ++)
            {
                dp[i][j] = -1;
            }
        }
        ll ans = recur(0 , 0);
        return ans;
    }
};",1420028204
Ashwanth K,ashwanthkannan,105,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);

        for(int i = 0 ; i < n ; i ++)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                for(int b = 0 ; b < 60 ; b ++)
                {
                    if( ((nums[i] >> b)&1) == 0)
                    {
                        ans[i] = nums[i] ^ (1ll << (b-1));
                        break;
                    }
                }
            }
        }

        return ans;
    }
};",1420076502
Ashwanth K,ashwanthkannan,105,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);

        for(int i = 0 ; i < n ; i ++)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                for(int b = 0 ; b < 60 ; b ++)
                {
                    if( ((nums[i] >> b)&1) == 0)
                    {
                        ans[i] = nums[i] ^ (1ll << (b-1));
                        break;
                    }
                }
            }
        }

        return ans;
    }
};",1420075648
NAVEEN KUMAR S,hornedfoe,106,3487,java,"class Solution{
    char[] s , t;
    boolean[] arr;
    int m , n , brr[];
    Integer[][] dp;
    public int maxRemovals(String str , String pat , int[] nums){
        s = str.toCharArray();
        t = pat.toCharArray();
        m = t.length;
        n = s.length;
        arr = new boolean[n];
        brr = new int[n + 1];
        for(int i : nums) arr[i] = true;
        for(int i = n - 1 ; i >= 0 ; i--) brr[i] += brr[i + 1] + (arr[i] ? 1 : 0);
        dp = new Integer[n][m];
        return finder(0 , 0);
    }
    private int finder(int x , int y){
        if(y == m) return brr[x];
        if(x == n) return - n;
        if(dp[x][y] != null) return dp[x][y];
        int ret = finder(x + 1 , y) + (arr[x] ? 1 : 0);
        if(s[x] == t[y]) ret = Math.max(finder(x + 1 , y + 1) , ret);
        return dp[x][y] = ret;
    }
}",1420060495
NAVEEN KUMAR S,hornedfoe,106,3604,java,"class Solution{
    int n , max;
    long arr[] , mod = (long) 1e9 + 7;
    Long[][] dp;
    public int numberOfWays(int n , int x , int y){
        this.n = n;
        max = x;
        arr = new long[max + 1];
        arr[0] = 1;
        for(int i = 1 ; i <= max ; i++){
            arr[i] = arr[i - 1] * y;
            arr[i] %= mod;
        }
        dp = new Long[n][max + 1];
        return (int) finder(0 , 0);
    }
    private long finder(int x , int y){
        if(x == n) return arr[y];
        if(dp[x][y] != null) return dp[x][y];
        long ret = finder(x + 1 , y) * y;
        if(y != max) ret += finder(x + 1 , y + 1) * (max - y);
        return dp[x][y] = ret % mod;
    }
}",1420076802
NAVEEN KUMAR S,hornedfoe,106,3605,java,"class Solution{
    public int[] minBitwiseArray(List<Integer> nums){
        int n = nums.size() , ret[] = new int[n];
        for(int i = 0 ; i < n ; i++){
            ret[i] = finder(nums.get(i));
        }
        return ret;
    }
    private int finder(int x){
        if(x == 2) return -1;
        for(int i = 0 , v = 1 ; i < 32 ; v = 1 << ++i){
            if((x & v) == 0){
                x ^= (1 << (i - 1));
                break;
            }
        }
        return x;
    }
}",1420031373
NAVEEN KUMAR S,hornedfoe,106,3611,java,"class Solution{
    public int[] minBitwiseArray(List<Integer> nums){
        int n = nums.size() , ret[] = new int[n];
        for(int i = 0 ; i < n ; i++){
            ret[i] = finder(nums.get(i));
        }
        return ret;
    }
    private int finder(int x){
        if(x == 2) return -1;
        for(int i = 0 , v = 1 ; i < 32 ; v = 1 << ++i){
            if((x & v) == 0){
                x ^= (1 << (i - 1));
                break;
            }
        }
        return x;
    }
}",1420031671
Sharaputdin Magomedov,LeetcodeKZ,107,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        set<int> targetSet(t.begin(), t.end());
        int m = p.size();
        int n = s.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = m - 1; j >= 0; --j) {
                if (s[i] == p[j] && dp[j] != INT_MAX) {
                    int cost = dp[j] + (targetSet.count(i) ? 1 : 0);
                    dp[j + 1] = min(dp[j + 1], cost);
                }
            }
        }

        if (dp[m] == INT_MAX) {
            return 0;
        }

        int essential = dp[m];
        int maxOps = t.size() - essential;
        return maxOps;
    }
};",1420056233
Sharaputdin Magomedov,LeetcodeKZ,107,3604,cpp,"const int MOD = 1e9 + 7;
const int MAX_N = 1005;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<int> fact(MAX_N), invFact(MAX_N);
        computeFactorials(fact, invFact);

        vector<vector<int>> askhat(n + 1, vector<int>(n + 1, 0));
        computeaskhat(n, askhat);

        int totalWays = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            int combos = calculateCombination(x, k, fact, invFact);
            int askhatNum = getaskhatNumber(n, k, askhat);
            int permuteStages = calculateFactorial(k, fact);
            int scoreWays = powerMod(y, k);

            int ways = ((1LL * combos * askhatNum) % MOD * permuteStages) % MOD;
            ways = (1LL * ways * scoreWays) % MOD;

            totalWays = (totalWays + ways) % MOD;
        }
        return totalWays;
    }

private:
    void computeFactorials(vector<int>& fact, vector<int>& invFact) {
        fact[0] = invFact[0] = 1;
        for (int i = 1; i < fact.size(); ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
            invFact[i] = inverseMod(fact[i]);
        }
    }

    void computeaskhat(int n, vector<vector<int>>& askhat) {
        askhat[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            askhat[i][0] = 0;
            for (int j = 1; j <= i; ++j) {
                askhat[i][j] = (1LL * j * askhat[i - 1][j] % MOD + askhat[i - 1][j - 1]) % MOD;
            }
        }
    }

    int calculateCombination(int n, int k, const vector<int>& fact, const vector<int>& invFact) {
        if (k < 0 || k > n) return 0;
        return (1LL * fact[n] * invFact[k] % MOD * invFact[n - k]) % MOD;
    }

    int getaskhatNumber(int n, int k, const vector<vector<int>>& askhat) {
        return askhat[n][k];
    }

    int calculateFactorial(int n, const vector<int>& fact) {
        return fact[n];
    }

    int powerMod(int base, int exp) {
        return modPow(base, exp);
    }

    int inverseMod(int a) {
        return modPow(a, MOD - 2);
    }

    int modPow(int base, int exp) {
        int result = 1;
        base %= MOD;
        while (exp > 0) {
            if (exp % 2) result = (1LL * result * base) % MOD;
            base = (1LL * base * base) % MOD;
            exp /= 2;
        }
        return result;
    }
};
",1420070014
Sharaputdin Magomedov,LeetcodeKZ,107,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res(nums.size(), -1);
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 1; j <= nums[i]; ++j) {
                int cur = j;
                cur |= (j + 1);
                if (cur == nums[i]) {
                    res[i] = j;
                    break;
                }
            }
        }
        return res;
    }
};",1419996238
Sharaputdin Magomedov,LeetcodeKZ,107,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            int minimal = INT_MAX;
            for (int j = 0; j < 31; j++) {
                if ((num >> j) & 1) {
                    int s = num - (1 << j);
                    if (s >= 0 && ((s | (s + 1)) == num)) {
                        minimal = min(minimal, s);
                    }
                }
            }
            result[i] = minimal == INT_MAX ? -1 : minimal;
        }
        return result;
    }
};",1420044496
skyinde2,skyinde2,108,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)

        r = [False] * n
        for i in targetIndices:
            r[i] = True

        dp = [0] * (n + 1)
        last = dp[:]
        for i in range(n):
            last[i + 1] = last[i] + 1 if r[i] else last[i]

        for ch in pattern:
            dp[0] = -100000
            for i in range(len(source)):
                dp[i + 1] = last[i] if source[i] == ch else dp[i]
                if r[i]:
                    dp[i + 1] = max(dp[i + 1], dp[i] + 1)

            dp, last = last, dp

        return last[-1]",1420036539
skyinde2,skyinde2,108,3604,python3,"
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7

        def po(a):
            ret = 1
            for _ in range(n):
                ret = ret * a % MOD
            return ret

        a = [1] * (x + 1)
        c = [1] * (x + 1)

        for i in range(2, x + 1):
            c[i] = 1
            s = 0
            for j in reversed(range(1, i)):
                c[j] = (c[j] + c[j - 1]) % MOD
                s = (s + a[j] * c[j]) % MOD

            a[i] = (po(i) - s) % MOD

        t = [1] * (x + 1)
        for i in range(1, x + 1):
            t[i] = (t[i - 1] * y) % MOD

        ret = 0
        for i in range(1, x + 1):
            ret = (ret + a[i] * c[i] * t[i]) % MOD
        return ret
",1420077801
skyinde2,skyinde2,108,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num % 2 == 1:
                k = (((num + 1) ^ num) + 1) >> 2 & num
                ans.append(num - k)
            else:
                ans.append(-1)
        return ans
",1420002768
skyinde2,skyinde2,108,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num % 2 == 1:
                k = (((num + 1) ^ num) + 1) >> 2 & num
                ans.append(num - k)
            else:
                ans.append(-1)
        return ans
",1420003117
SreehariC,SreehariC,110,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        string s=source;
        string t=pattern;
        int n=s.size();
        int m=t.size();
        s="" ""+s;
        t="" ""+t;

        set<int> st;
        for(auto it:targetIndices) st.insert(it+1);

        vector<vector<int>> dp(n+1,vector<int>(m+1,-1e9));
        dp[0][0]=0;
        for(int i=1;i<=n;i++){
            if(st.find(i)!=st.end()) dp[i][0]=dp[i-1][0]+1;
            else dp[i][0]=dp[i-1][0];
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(s[i]==t[j]){
                    if(st.find(i)!=st.end()){
                        dp[i][j]=max(dp[i-1][j-1],dp[i-1][j]+1);
                    }
                    else{
                        dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]);
                    }
                }
                else{
                    if(st.find(i)!=st.end())
                    dp[i][j]=(dp[i-1][j]+1);
                    else dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[n][m];
        
    }
};",1420078136
SreehariC,SreehariC,110,3604,cpp,"typedef long long ll;
const ll MOD=1e9+7;
long long binpow(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            {res = res * a;
            res%=MOD;
            }
        a = a * a;
        a%=MOD;

        b >>= 1;
    }
    return res%MOD;
}
ll inverse(ll a){
    return (binpow(a,MOD-2))%MOD;
}

ll fac[10001];
void cal(){
   fac[0]=1;
   fac[1]=1;
   for(int i=2;i<=10000;i++){
      fac[i]=fac[i-1]*i;
      fac[i]%=MOD;
   }     
}
long long bin(int n, int k) {
    if(k>n)return 0;
    else return (fac[n] * (inverse((fac[k] * fac[n - k]) % MOD) % MOD))%MOD;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        cal();
        ll ans=0;
        for(int p=1;p<=x;p++){
            ll temp=0;
            for(int j=0;j<=p;j++){
                if(j%2==0){
                    temp+=(bin(p,j)*binpow(p-j,n))%MOD;
                    temp%=MOD;
                }
                else{
                    temp=(temp-(bin(p,j)*binpow(p-j,n))%MOD+MOD)%MOD;
                }
                temp%=MOD;
            }
            temp=(temp*bin(x,p))%MOD;
            temp=(temp*(binpow(y,p)))%MOD;
            ans+=temp;
            ans%=MOD;
        }
        return ans;
    }
};",1420056147
SreehariC,SreehariC,110,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int j=0;
                while((1<<j)&(nums[i])) j++;
                j--;
                ans.push_back(nums[i]^((1<<j)));


            }



        }
        return ans;

    }
};",1420008663
SreehariC,SreehariC,110,3611,cpp,"typedef long long ll;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int j=0;
                while((1ll<<j)&(nums[i])) j++;
                j--;
                ans.push_back(nums[i]^((1ll<<j)));


            }



        }
        return ans;

    }
};",1420011559
parth gujral,parth_gujral_,111,3487,cpp,"class Solution {
public:
void gfhghg()
{
    int bb=78;
}
void b()
{
    int nh=90;
}
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
b();
         int n = source.size();
         b();b();
        int m = pattern.size();

gfhghg();
        // dp array where dp[j] represents the minimum cost to match the first j characters of the pattern
        b();b();b();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        gfhghg();gfhghg();
b();
        // isTarget array that marks if a position is in targetIndices
        vector<bool> isTarget(n, false);
        b();b();
        for (int idx : targetIndices) {

            gfhghg();gfhghg();gfhghg();b();
            isTarget[idx] = true;
            gfhghg();gfhghg();
        }

        // Iterate through the source string and pattern
        for (int i = 0; i < n; ++i) {

            gfhghg();gfhghg();gfhghg();
            b();
            // Traverse the pattern in reverse order
            for (int j = m; j > 0; --j) {
                b();b();
                gfhghg();
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    b();b();
                    gfhghg();
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));

                    b();b();b();b();
                }
            }
            b();b();
        }

        // If dp[m] is still INT_MAX, it means the pattern couldn't be matched
        gfhghg();gfhghg();
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    
    }
};",1420062568
parth gujral,parth_gujral_,111,3604,cpp,"class Solution {
public:
const int MOD = 1e9 + 7;
#define ll long long 
void cvh()
{
    int bh=87;
}
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            cvh();
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {


                cvh();cvh();cvh();
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;

                cvh();cvh();cvh();
            }
        }

        // Initialize the Stirling numbers of the second kind (S) array
        vector<vector<ll>> S(n + 1, vector<ll>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            cvh();cvh();
            for (int j = 1; j <= x; ++j) {
                cvh();cvh();
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
            cvh();cvh();
        }

        // Factorial array
        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            cvh();cvh();cvh();
            fact[i] = 1LL * fact[i - 1] * i % MOD;
            cvh();cvh();cvh();cvh();
        }

        ll result = 0;
        // Main computation loop
        for (int k = 1; k <= x; ++k) {

            cvh();cvh();cvh();
            ll power = 1;
            for (int p = 0; p < k; ++p) {
                cvh();cvh();cvh();
                power = power * y % MOD;
                cvh();cvh();
            }
            cvh();cvh();cvh();
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        cvh();cvh();

        return result;

    }
};",1420053359
parth gujral,parth_gujral_,111,3605,cpp,"class Solution {

    void hghty()
    {
        int jh=90;
    }
    void hg()
    {
        int gfb=97;
    }
    private:
    int yrsolvemin(int x)
    {
        for(int sq=1;sq<=x;sq++)
        {
            hghty();hghty();hghty();
            if( (sq | (sq+1))==x)
            {
                hghty();hghty();
                return sq;
            }
        }
        hghty();
        return -1;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();hghty();
        vector<int> answer(n,-1);
        for(int i=0;i<n;i++)
        {
            hghty();hg();
            answer[i] = yrsolvemin(nums[i]);
            hg();hg();hg();
        }

        return answer;
    }
};",1420021786
parth gujral,parth_gujral_,111,3611,cpp,"class Solution {
public:
void hfgf()
{
    int hg=908;
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result;
        
        hfgf();

        for (int num : nums) {
            hfgf();hfgf();hfgf();hfgf();

            vector<int> array;
            
            for (int i = 0; i < 32; ++i) {
                hfgf();hfgf();hfgf();hfgf();

                if (num & (1 << i)) {

                    hfgf();hfgf();hfgf();hfgf();
                    int element = num & ~(1 << i);
                    hfgf();hfgf();
                    if ((element | (element + 1)) == num) {
                        hfgf();hfgf();hfgf();
                        array.push_back(element);
                    }
                    hfgf();hfgf();
                }
            }
            
            if (array.empty()) {
                hfgf();hfgf();
                result.push_back(-1);
                hfgf();
            } else {
                hfgf();
                result.push_back(*min_element(array.begin(), array.end()));
                hfgf();hfgf();
            }
        }
        hfgf();hfgf();
        return result;
    }
};",1420071980
Said Abdulaev,said_v15,112,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& ti) {
        int n = (int) s.size(), m = (int) p.size();
        unordered_set<int> t;
        for (auto &x: ti) t.insert(x + 1);

        s = ""#"" + s; p = ""#"" + p; // for balance
        int sum = 0;
        vector<vector<int>> dp(n + 1, vector<int> (m + 1));
        vector<vector<int>> can(n + 1, vector<int> (m + 1));
        can[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            can[i][0] = 1;

            for (int j = 0; j <= m; j++) {
                // don't take the i-th element
                if (can[i - 1][j]) {
                    dp[i][j] = dp[i - 1][j] + t.count(i);
                    can[i][j] = 1;
                }
                // take the i-th element
                if (!j) continue;

                if (s[i] == p[j] && can[i - 1][j - 1]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                    can[i][j] = 1;
                }
            }
        }

        // for (int i = 1; i <= n; i++) {
        //     for (int j = 0; j <= m; j++) {
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout << ""\n"";
        // }

        return dp[n][m];
    }
};",1420079248
Said Abdulaev,said_v15,112,3604,cpp,"class Solution {
public:
    const int mod = int(1e9) + 7;
    const int sz = 1005;

    int fact[1005];
    int inv_fact[1005];

    int mul(int a, int b) {
        return (long long) a * b % mod;
    }

    int add(int a, int b) {
        int res = (long long) a + b;
        if (res < 0)
            res += mod;
        else if (res > mod)
            res -= mod;
        return res % mod;
    }
    int bpow(int x, int p) {
        int res = 1;
        while (p) {
            if (p & 1)
                res = mul(res, x);

            p >>= 1;

            if (p)
                x = mul(x, x);
        }
        return res;
    }

    int inv(int x) {
        return bpow(x, mod - 2);
    }

    void calc_fact() {
        fact[0] = inv_fact[0] = 1;
        for (int i = 1; i < sz; i++) {
            fact[i] = mul(fact[i - 1], i);
            inv_fact[i] = inv(fact[i]);
        }
    }

    int cnk(int n, int k) {
        if (k > n)
            return 0;
        return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));
    }

    int numberOfWays(int n, int x, int y) {
        calc_fact();

        vector<vector<int>> dp(n + 1, vector<int> (x + 1));
        dp[0][0] = 1;
        // dp[i][j] - number of ways to assign i people on j stages
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                // j places are used
                // don't use a new place
                dp[i][j] = mul(dp[i - 1][j], j);
                // use a new place
                dp[i][j] = add(dp[i][j], mul(dp[i - 1][j - 1], x - (j - 1)));
            }
        }
        // for (int i = 1; i <= n; i++) {
        //     for (int j = 0; j <= x; j++) {
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout << ""\n"";
        // }
        int ans = 0;
        for (int i = 0; i <= x; i++) {
            ans = add(ans, mul(dp[n][i], bpow(y, i)));
        }

        return ans;
    }
};",1420016775
Said Abdulaev,said_v15,112,3605,cpp,"class Solution {
public:
    int find_least(int n) {
        for (int i = 0; i < 31; i++) {
            if (n & (1 << i)) {
                return i;
            }
        }
        return 31;
    }
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        for (auto &x: v) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            long long num = x;
            long long idx = 0;
            for (long long i = 0; i < 31; i++) {
                if (num & (1LL << i)) continue;
                idx = i;
                break;
            }
            cout << x << "" "" << idx << ""\n"";
            long long left = (1LL << idx) - 1;
            long long a = num - left;
            idx--;
            a += (1LL << idx) - 1;
            ans.push_back((int) a);

        }
        return ans;
    }
};",1420055550
Said Abdulaev,said_v15,112,3611,cpp,"class Solution {
public:
    int find_least(int n) {
        for (int i = 0; i < 31; i++) {
            if (n & (1 << i)) {
                return i;
            }
        }
        return 31;
    }
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        for (auto &x: v) {
            if (x == 2) {
                ans.push_back(-1);
                continue;
            }
            long long num = x;
            long long idx = 0;
            for (long long i = 0; i < 31; i++) {
                if (num & (1LL << i)) continue;
                idx = i;
                break;
            }
            cout << x << "" "" << idx << ""\n"";
            long long left = (1LL << idx) - 1;
            long long a = num - left;
            idx--;
            a += (1LL << idx) - 1;
            ans.push_back((int) a);

        }
        return ans;
    }
};",1420055327
Ritik Rathor,ritik_369,113,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        vector<int> cost(n, 0);
        for (int idx : targetIndices) {
            cost[idx] = 1;
        }

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));
        for (int i = 0; i <= n; ++i) dp[i][0] = 0;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                dp[i][j] = dp[i - 1][j];
                if (source[i - 1] == pattern[j - 1] and dp[i - 1][j - 1] != INT_MAX) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + cost[i - 1]);
                }
            }
        }
        int res = 0 ; 
        if(dp[n][m] != INT_MAX)
            res = targetIndices.size() - dp[n][m] ; 
        return res ; 
    }
};
",1420065249
Ritik Rathor,ritik_369,113,3604,cpp,"const int mod = 1000000007;

long long binpow(long long a, long long b, long long m = mod) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}

int n, x, y;
vector<vector<int>> dp;

int f(int idx, int xx) {
    if (idx >= n + 1)
        return binpow(y, xx, mod);
    if (dp[idx][xx] != -1)
        return dp[idx][xx];

    int here = 0;
    here = (1ll * here + 1ll * f(idx + 1, xx) * xx) % mod;
    if (xx + 1 <= x)
        here = (1ll * here + 1ll * f(idx + 1, xx + 1) * (x - xx)) % mod;

    return dp[idx][xx] = here;
}

class Solution {
public:
    int numberOfWays(int _n, int _x, int _y) {
        ::n = _n;
        ::x = _x;
        ::y = _y;
        dp = vector<vector<int>>(n + 1, vector<int>(x + 1, -1));  
        return f(1, 0);
    }
};
",1420064950
Ritik Rathor,ritik_369,113,3605,cpp,"int f(long long n)
{
    if(n == 2)return -1 ; 
    int x = n ^ 1 ; 
    long long a = 1 ; 
    for(int i = 0 ;  ; i += 1)
    {
        if(((n >> i) & 1) == 0)break ; 
        x = min(1ll*x , (n ^ (1ll << i))) ;
    }
    return x ; 
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>res;
        for(auto a:nums)
            res.push_back(f(a));
        return res;
    }
};",1420063107
Ritik Rathor,ritik_369,113,3611,cpp,"int f(long long n)
{
    if(n == 2)return -1 ; 
    int x = n ^ 1 ; 
    long long a = 1 ; 
    for(int i = 0 ;  ; i += 1)
    {
        if(((n >> i) & 1) == 0)break ; 
        x = min(1ll*x , (n ^ (1ll << i))) ;
    }
    return x ; 
}
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>res;
        for(auto a:nums)
            res.push_back(f(a));
        return res;
    }
};",1420063362
Ayush Singh,the_wiz,114,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tp) 
    {
        int n = s.size(), m = p.size(), dp[m + 1], fp[n + 1], lm = INT_MAX, ans = tp.size();
        for(int &x: dp) x = lm;
        memset(fp, 0, sizeof(fp));
        dp[0] = 0;
        for (int &x: tp) fp[x] = 1;
        for (int i = 0; i < n; i++) 
        {
            for (int j = m; j > 0; j--) 
            {
                if (s[i] == p[j - 1] && dp[j - 1] != lm)
                {
                    dp[j] = min(dp[j], dp[j - 1] + fp[i]);
                }
            }
        }
        if (dp[m] != lm) ans -= dp[m];
        return ans;
    }
};",1420065963
Ayush Singh,the_wiz,114,3604,cpp,"#define ll long long
const int MOD = 1e9 + 7;

class Solution {
public:

    ll bex(ll x, ll pow)
{
    if (x < 2) return x;
    ll ans = 1LL;
    while(pow != 0)
    { 
        if (pow & 1LL) ans = (ans * x) % MOD;
        x = (x * x) % MOD, pow >>= 1;
    }
    return ans;
}

ll s[1010][1010], f[1010], ivf[1010];

    int numberOfWays(int n, int x, int y) {

        ll mx = max(n, x);
         s[0][0] = 1;
         f[0] = 1;
         ivf[0] = 1;
    for (int i = 1; i <= 1000; ++i)
    {
        s[i][0] = 0;
        for (int j = 1; j <= i; ++j) 
        {
            s[i][j] = s[i - 1][j - 1];
            (s[i][j] += j * s[i - 1][j]);
            s[i][j] %= MOD;
        }
        f[i] = (f[i - 1] * i) % MOD;
        ivf[i] = bex(f[i], MOD - 2);
        // cout << ivf[i] << ' ';
    }
    ll ans = 0, mn = min(n, x);
    for(int i = 1; i <= mn; i++)
    {
        ll xp = s[n][i];
        // cout << xp << ' ';
        (xp *= f[x]) %= MOD;
        // cout << xp << ' ';
        (xp *= ivf[x - i]) %= MOD;
        // cout << xp << ' ';
        (xp *= bex(y, i)) %= MOD;
        // cout << xp << ' ';
        (ans += xp) %= MOD;
        // cout << '\n';
    }
    return (int) ans;
    }
};",1420054333
Ayush Singh,the_wiz,114,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) 
    {
        int n = a.size(), ans[1010];
        memset(ans, -1, sizeof(ans));
        for(int i = 0; i < 10000; i++)
        {
            int x = i | (i + 1);
            if (x <= 1000 && ans[x] == -1)
            {
                ans[x] = i;
            }
        }
        vector<int> r;
        for(int x: a) r.push_back(ans[x]);
        return r;
    }
};",1419996526
Ayush Singh,the_wiz,114,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) 
    {
        int n = a.size();
        vector<int> ans(n, -1);
        for(int j = 0; j < n; j++)
        {
            set<int> s;
            for(int i = 0; i < 32; i++)
            {
                if ((a[j] >> i) & 1)
                {
                    int y = a[j] & (~(1 << i));
                    y |= (y + 1);
                    if (a[j] == y)
                    {
                        s.insert(a[j] & (~(1 << i)));
                    }
                }
            }
            if (!s.empty()) ans[j] = *s.begin();
        }
        return ans;
    }
};",1420079985
tr1nity,tr1nity,115,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n, m, z = len(s), len(p), len(t)
        f = [0] * n
        for x in t: f[x] = 1
        dp = [n + 1] * (m + 1)
        dp[0] = 0
        for i in range(n):
            for j in range(m, 0, -1):
                if s[i] == p[j - 1]: 
                    if dp[j - 1] + f[i] < dp[j]:
                        dp[j] = dp[j - 1] + f[i]
        # print(dp)
        return z - dp[-1]",1420080140
tr1nity,tr1nity,115,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        M = 10 ** 9 + 7
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % M
        res = 0
        for i in range(1, min(x, n) + 1):
            w = math.comb(x, i)
            w = (w * pow(y, i, M)) % M
            w = (w * (math.factorial(i) % M)) % M
            w = (w * dp[n][i]) % M
            res = (res + w) % M
        return res",1420060978
tr1nity,tr1nity,115,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for x in nums:
            if x == 2 or x % 2 == 0: 
                res.append(-1)
                continue
            ones = 0
            p = x
            while p & 1:
                ones += 1
                p >>= 1
            if ones == 0: 
                res.append(-1)
                continue
            b = x - (1 << (ones - 1))
            res.append(b if b >= 0 and (b | (b + 1) == x) else -1)
        return res",1420007203
tr1nity,tr1nity,115,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for x in nums:
            if x == 2 or x % 2 == 0: 
                res.append(-1)
                continue
            ones = 0
            p = x
            while p & 1:
                ones += 1
                p >>= 1
            if ones == 0: 
                res.append(-1)
                continue
            b = x - (1 << (ones - 1))
            res.append(b if b >= 0 and (b | (b + 1) == x) else -1)
        return res",1420007110
Priyansh Kumar Singh,priyanshnikka,116,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        target_set = set(targetIndices)
        
        dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        
        for i in range(n):
            for j in range(m + 1):
                if dp[i][j] < dp[i + 1][j]:
                    dp[i + 1][j] = dp[i][j]
                if j < m and source[i] == pattern[j]:
                    cost = dp[i][j]
                    if i in target_set:
                        cost += 1
                    if cost < dp[i + 1][j + 1]:
                        dp[i + 1][j + 1] = cost
                        
        min_used = dp[n][m]
        total_target = len(targetIndices)
        max_ops = total_target - min_used
        return max_ops",1420072277
Priyansh Kumar Singh,priyanshnikka,116,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        S = [[0] * (x + 2) for _ in range(n + 2)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, min(i, x) + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD
        
        max_fact = max(n, x) + 1
        factorial = [1] * (max_fact + 1)
        for i in range(1, max_fact + 1):
            factorial[i] = (factorial[i - 1] * i) % MOD
        
        inv_fact = [1] * (max_fact + 1)
        inv_fact[max_fact] = pow(factorial[max_fact], MOD - 2, MOD)
        for i in range(max_fact - 1, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
        
        def binomial_coefficient(n, k):
            if k > n or k < 0:
                return 0
            return (factorial[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD
        
        result = 0
        for k in range(1, min(x, n) + 1):
            comb = binomial_coefficient(x, k)
            score = pow(y, k, MOD)
            perm = factorial[k]
            stir = S[n][k]
            term = comb * score % MOD
            term = term * perm % MOD
            term = term * stir % MOD
            result = (result + term) % MOD
        
        return result",1420080289
Priyansh Kumar Singh,priyanshnikka,116,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for num in nums:
            found = False
            for i in range(num):
                if (i | (i + 1)) == num:
                    answer.append(i)
                    found = True
                    break
            if not found:
                answer.append(-1)
        return answer",1420025612
Priyansh Kumar Singh,priyanshnikka,116,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            minin = float('inf')
            temp_num = num
            bit_pos = 0
            while temp_num > 0:
                if temp_num & 1:
                    x = num & ~(1 << bit_pos)
                    if (x | (x + 1)) == num:
                        if x < minin:
                            minin = x
                temp_num >>= 1
                bit_pos += 1
            if minin != float('inf'):
                ans.append(minin)
            else:
                ans.append(-1)
        return ans",1420030544
MrRobot,Noah_will,117,3487,java,"import java.util.*;

class Solution {
public int maxRemovals(String source, String pattern, int[] targetIndices) {
int n = source.length();
int m = pattern.length();
Set<Integer> targetSet = new HashSet<>();
for(int idx: targetIndices){
targetSet.add(idx);
}
long INF = Long.MAX_VALUE / 2;
long[] dp = new long[m + 1];
Arrays.fill(dp, INF);
dp[0] = 0;
for(int i =0;i<n;i++){
for(int j = m-1; j>=0; j--){
if(source.charAt(i)==pattern.charAt(j)){
long cost = dp[j] + (targetSet.contains(i)?1:0);
if(cost < dp[j+1]){
dp[j+1]=cost;
}
}
}
}
if(dp[m]==INF){
return 0;
}
return targetIndices.length - (int)dp[m];
}
}
",1420060587
MrRobot,Noah_will,117,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
    final int MOD = 1_000_000_007;
    long[][] S = new long[n + 1][n + 1];
    S[0][0] = 1;
    for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
    S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
    }
    }
    long[][] C = new long[x + 1][x + 1];
    for (int i = 0; i <= x; i++) {
    C[i][0] = 1;
    for (int j = 1; j <= i; j++) {
    C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
    }
    }
    long[] factorial = new long[x + 1];
    factorial[0] = 1;
    for (int k = 1; k <= x; k++) {
    factorial[k] = (factorial[k - 1] * k) % MOD;
    }
    int limit = Math.min(x, n);
    long[] y_pow = new long[limit + 1];
    y_pow[0] = 1;
    for (int k = 1; k <= limit; k++) {
    y_pow[k] = (y_pow[k - 1] * y) % MOD;
    }
    long sum = 0;
    for (int k = 1; k <= limit; k++) {
    long temp = C[x][k];
    temp = (temp * factorial[k]) % MOD;
    temp = (temp * S[n][k]) % MOD;
    temp = (temp * y_pow[k]) % MOD;
    sum = (sum + temp) % MOD;
    }
    return (int) sum;
    }
    }

",1420050868
MrRobot,Noah_will,117,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for(int i = 0; i < n; i++) {
    int x = nums.get(i);
    int min_a = Integer.MAX_VALUE;
    for(int bit = 0; bit < 32; bit++) {
    if((x & (1 << bit)) != 0) {
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)) {
    if(a < min_a) {
    min_a = a;
    }
    }
    }
    }
    ans[i] = (min_a == Integer.MAX_VALUE) ? -1 : min_a;
    }
    return ans;
    }
    }
",1420080292
MrRobot,Noah_will,117,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    int n = nums.size();
    int[] ans = new int[n];
    for(int i = 0; i < n; i++) {
    int x = nums.get(i);
    int min_a = Integer.MAX_VALUE;
    for(int bit = 0; bit < 32; bit++) {
    if((x & (1 << bit)) != 0) {
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)) {
    if(a < min_a) {
    min_a = a;
    }
    }
    }
    }
    ans[i] = (min_a == Integer.MAX_VALUE) ? -1 : min_a;
    }
    return ans;
    }
    }
",1420070679
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3487,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)



 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
        int left = 0, right = targetIndices.size();
        int n = source.size(), m = pattern.size();
        vector<long long> dp(m + 1, LLONG_MAX);
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != LLONG_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == LLONG_MAX ? 0 : dp[m]);
        
//         while (left <= right) {
//             int mid = left + (right - left) / 2;
//             vector<bool> removed(source.length(), false);
            
//             for (int i = 0; i < mid; i++) {
//                 removed[targetIndices[i]] = true;
//             }
            
//             if (isSubsequence(source, pattern, removed)) {
//                 left = mid + 1;
//             } else {
//                 right = mid - 1;
//             }
//         }
        
//         return right;
    }
    
private:
    bool isSubsequence(const string& source, const string& pattern, const vector<bool>& removed) {
        int i = 0, j = 0;
        while (i < source.length() && j < pattern.length()) {
            if (!removed[i] && source[i] == pattern[j]) {
                j++;
            }
            i++;
        }
        return j == pattern.length();
    }
};",1420054699
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3604,cpp,"#include<bits/stdc++.h>
#include <cassert>
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <functional>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>
#include <stdlib.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
using namespace  __gnu_pbds;
using namespace std;
 
// ------------------------------- Micros ------------------------------------------------
 
#define google(tc) cout<<""Case #""<<tc++<<"": "";
#define FILE freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"", stdout);
#define GetSetBolt ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL); 
#define ll long long int  
#define LD long double
 
#ifndef LOCAL
#pragma GCC optimize(""Ofast"")
#pragma GCC target(""avx,avx2,fma"")
#pragma GCC optimization(""unroll-loops"")
#pragma GCC optimize (""O3"")
#pragma GCC target (""sse4"")
#endif
 

 
#define max3(a,b,c) max(a,max(b,c)) 
#define min3(a,b,c) min(a,min(b,c))
#define min4(a,b,c,d)   min(a,min(b,min(c,d)))
#define max4(a,b,c,d)   max(a,max(b,max(c,d)))
#define smallest(a)       *min_element(a.begin(),a.end())
#define largest(a)        *max_element(a.begin(),a.end())
#define MIN INT32_MIN
#define MAX INT32_MAX
 
#define FF first 
#define SS second 
#define PB push_back 
#define PF push_front 
#define PPB pop_back  
#define PPF pop_front  
#define Endl endl
 
#define in(arr,n) for(int i=0;i<n;i++) cin>>arr[i];
#define in2(arr,n,m) for(int i=0;i<n;i++){ for(int j=0;j<m;j++) cin>>arr[i][j];}
#define dis(arr,n) for(int i=0;i<n;i++) cout<<arr[i]<<"" ""; cout<<endl;
#define dis2(arr,n,m) for(int ii=0;ii<n;ii++){for(int j=0;j<m;j++)cout<<arr[ii][j]<<"" "";cout<<endl;} 
#define tc int t=0;cin>>t; while(t--)
#define deb(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)



 
#define For(n) for(ll i=0;i<n;i++)
#define For0(x,z) for(ll x=0;x<z;x++)
#define Forx(x,z) for(x;x<z;x++)
#define all(x) x.begin(),x.end()
#define allr(x) x.rbegin(),x.rend()
 
#define toLower(s) transform(s.begin(),s.end(),s.begin(),::tolower)
#define toUpperr(s) transform(s.begin(),s.end(),s.begin(),::toupper)
 
#define sortAD(arr,n) sort(arr,arr+n, greater<int>());
#define sortVD(v) sort(v.begin(), v.end(), greater<int>());
#define sortA(arr) sort(arr,arr+n);
#define sortV(v) sort(v.begin(),v.end());
 
#define mem0(X) memset((X), 0, sizeof((X)))
#define memx(X,x)  memset((X), x, sizeof((X)))
#define setbits(X)  __builtin_popcountll(X)
#define precise(X)  cout<<fixed << setprecision(X);
#define valid(x,y,row,col) (((x) >= 0 and (x) < row) and ((y) >= 0 and (y) < col))
#define timer(d) for(long blockTime=NULL;(blockTime==NULL?(blockTime=clock())!=NULL:false); debug(""%s:%.4fs"",d,(double)(clock()-blockTime)/CLOCKS_PER_SEC))
#define rsz resize
#define bk back()
#define ld long double
#define yes         cout<<""Yes\n""
#define no          cout<<""No\n""
 
 
// #ifndef ONLINE_JUDGE
//     cerr<<""\ntime taken : ""<<(float)clock()/CLOCKS_PER_SEC<<"" secs""<<""\n"";
// #endif
typedef pair<int, int> PII; 
typedef pair<ll, ll> PLL;
typedef pair<double,double> PDD;
typedef pair<string, string> PSS; 
typedef pair<string, ll> PSL; 
typedef long double lld;
 
typedef vector<int> VI;  
typedef vector<ll> VL;  
typedef vector<double> VD;
typedef vector<string> VS; 
typedef vector<VI> VVI;  
typedef vector<VL> VVL; 
typedef vector<VS> VVS; 
typedef vector<PII> VPII; 
typedef vector<PLL> VPLL; 
typedef vector<PSS> VPSS; 
typedef vector<PSL> VPSL; 
 
typedef map<int,int> MII; 
typedef map<ll,ll> MLL;   
typedef map<char,ll> MCL;  
typedef map<char,int> MCI; 
typedef map<char,ll> MCL;   
typedef map<string,string> MSS;  
typedef map<string,int> MSI;  
typedef map<string,ll> MSL; 
 
typedef unordered_map<int,int> UMII; 
typedef unordered_map<ll,ll> UMLL;   
typedef unordered_map<char,ll> UMCL;  
typedef unordered_map<char,int> UMCI; 
typedef unordered_map<char,ll> UMCL;   
typedef unordered_map<string,string> UMSS;  
typedef unordered_map<string,int> UMSI;  
typedef unordered_map<string,ll> UMSL; 
typedef unsigned long long ull;

inline ll read(){
    ll res=0;char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+ch-'0',ch=getchar();
    return res;
}
 
const int inf = (int)1e9 + 5;
const ll infl = (ll)1e18 + 5;
const ld PI = acos((ld)-1);
const int MOD = 1e9 + 7;
const int N = 2e5 + 10;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};   // for every grid problem
 
 
//--------------------------------- Trace Functions --------------------------------------
 
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(lld t) {cerr << t;}
void _print(double t) {cerr << t;}
void _print(ull t) {cerr << t;}
void DBG() {
	cerr << ""]"" << endl;
}

template<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}
template<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<"" ""<<a.y;return out;}
template<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}
template<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}
template<class H, class... T> void DBG(H h, T... t) {
	cerr << to_string(h);
	if (sizeof...(t))
		cerr << "", "";
	DBG(t...);
}

template <class T>
T *lower_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return left;
}

template <class T>
T *upper_bound(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (val < *middle)
            right = middle;
        else
            left = middle + 1;
    }
    return left;
}

template <class T>
T *binary_search(T *left, T *right, T val) {
    while (left < right) {
        T *middle = left + (right - left) / 2;
        if (*middle == val)
            return middle;
        else if (*middle < val)
            left = middle + 1;
        else
            right = middle;
    }
    return nullptr; // If the element is not found, return nullptr
}

template<class T> T max(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result < data[i])
        {
            result = data[i];
        }
    }
    return result;
}

template<class T> T min(const T* data, int size)
{
    T result = data[0];
    for(int i=1;i<size;i++)
    {
        if(result > data[i])
        {
            result = data[i];
        }
    }
    return result;
}
class Solution {
public:
    const int MOD = 1e9 + 7;

    ll mod_pow(ll a, ll b, int m) {
        ll r = 1; 
        a %= m; 
        while (b > 0) {
            if (b % 2) 
                r = (r * a) % m; 
            a = (a * a) % m; 
            b >>= 1; 
        }
        return r; 
    }

    ll mod_inv(ll a, int m) { 
        return mod_pow(a, m - 2, m); 
    }

    void precompute_factorials(int n, vector<ll>& f, vector<ll>& inv_f) { 
        f[0] = inv_f[0] = 1; 
        for (int i = 1; i <= n; i++) 
            f[i] = (f[i - 1] * i) % MOD; 
        inv_f[n] = mod_inv(f[n], MOD); 
        for (int i = n - 1; i >= 1; i--) 
            inv_f[i] = (inv_f[i + 1] * (i + 1)) % MOD; 
    }

    ll nCr(int n, int r, vector<ll>& f, vector<ll>& inv_f) { 
        if (r < 0 || r > n) 
            return 0; 
        return (((f[n] * inv_f[r]) % MOD) * inv_f[n - r]) % MOD; 
    }
    
    int numberOfWays(int n, int x, int y) {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);  
        
        int m = max(n, x); 
        DBG(m);
        vector<ll> f(m + 1), inv_f(m + 1); 
        precompute_factorials(m, f, inv_f); 

        vector<ll> s(x + 1, 0), prev_s(x + 1, 0); 
        s[0] = 0; 
        s[1] = 1; 

        for (int i = 2; i <= n; i++) { 
            prev_s = s; 
            for (int k = 1; k <= min(i, x); k++) { 
                s[k] = (k * prev_s[k] % MOD + prev_s[k - 1]) % MOD; 
            } 
        }

        ll total = 0; 
        for (int k = 1; k <= min(n, x); k++) { 
            ll ways = nCr(x, k, f, inv_f);  
            ways = (ways * f[k]) % MOD;                   
            ways = (ways * s[k]) % MOD;                            
            ways = (ways * mod_pow(y, k, MOD)) % MOD;              
            total = (total + ways) % MOD; 
            cout << ways;
        } 
        DBG(total);
        return (int)total; 
    }
};",1420080390
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3605,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int x = 0;
            bool found = false;
            for (int i = 29; i >= 0; i--) {
                if ((num & (1 << i)) && !found) {
                    x |= (1 << i);
                    x--;
                    if ((x | (x + 1)) == num) {
                        found = true;
                    } else {
                        x++;
                    }
                }
            }
            ans.push_back(found ? x : -1);
        }
        return ans;
    }
};",1420000579
Tourist_ka_chachera_bhai,Tourist_ka_chachera_bhai,119,3611,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int x = 0;
            bool found = false;
            for (int i = 29; i >= 0; i--) {
                if ((num & (1 << i)) && !found) {
                    x |= (1 << i);
                    x--;
                    if ((x | (x + 1)) == num) {
                        found = true;
                    } else {
                        x++;
                    }
                }
            }
            ans.push_back(found ? x : -1);
        }
        return ans;
    }
};",1420000320
leetgoat_dot_dev,leetgoat_dot_dev,121,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        idxSet = set(targetIndices)
        
        @cache
        def dp(i, j):
            # print(f'dp called on i={i} j={j}')
            # base case
            if i == len(source):
                # print(f'base case, end of source')
                # print(f'ret: {0 if j == len(pattern) else -inf} due to potential exhaustion of pattern')
                return 0 if j == len(pattern) else -inf
            if j == len(pattern):
                ifNoRemove = dp(i + 1, j)
                if i in idxSet:
                    ifRemove = 1 + dp(i + 1, j)
                else:
                    ifRemove = 0
                return max(ifNoRemove, ifRemove)
            
            if i in idxSet:
                ifRemove = 1 + dp(i + 1, j)
                ifNoRemove = dp(i + 1, j + (1 if source[i] == pattern[j] else 0))
                return max(ifRemove, ifNoRemove)
                
            if i not in idxSet:
                return dp(i + 1, j + (1 if source[i] == pattern[j] else 0))
            
        r = dp(0, 0)
        dp.cache_clear()
        return r
            ",1420013535
leetgoat_dot_dev,leetgoat_dot_dev,121,3604,python3,"class ModCalc:
    def __init__(self, n, mod):
        self.n = n
        self.mod = mod
        self.modFacts = self._buildModFacts()
        self.invModFacts = self._buildInvModFacts()
        self.stirling_numbers = self._buildStirlingNumbers()

    def _buildModFacts(self):
        modFacts = [1]  # 0!
        for i in range(1, self.n + 1):
            modFacts.append(self.modMul(modFacts[i - 1], i))
        return modFacts

    def _buildInvModFacts(self):
        invModFacts = [1] * (self.n + 1)
        invModFacts[self.n] = self.modInv(self.modFacts[self.n])
        for i in range(self.n, 0, -1):
            invModFacts[i - 1] = self.modMul(invModFacts[i], i)
        return invModFacts

    def _buildStirlingNumbers(self):
        n = self.n
        mod = self.mod
        stirling = [[0] * (n + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            stirling[i][0] = 0
            for k in range(1, i + 1):
                stirling[i][k] = (k * stirling[i - 1][k] + stirling[i - 1][k - 1]) % mod
        return stirling

    @cache
    def stirling2(self, n, k):
        if k < 0 or k > n:
            return 0
        return self.stirling_numbers[n][k]

    @cache
    def modInv(self, num):
        return self.modPow(num, self.mod - 2)

    def modMul(self, *args):
        result = 1
        for num in args:
            result = (result * num) % self.mod
        return result

    @cache
    def modPow(self, base, exponent):
        return pow(base, exponent, self.mod)

    @cache
    def modFact(self, n):
        return self.modFacts[n]

    @cache
    def modComb(self, n, k):
        if k < 0 or k > n:
            return 0
        return self.modMul(self.modFacts[n], self.invModFacts[k], self.invModFacts[n - k])

    def modPerm(self, n, k):
        if k < 0 or k > n:
            return 0
        return self.modMul(self.modFacts[n], self.invModFacts[n - k])

    def starsBars(self, balls, buckets):
        return self.modComb(balls + buckets - 1, buckets - 1)

MOD = 10**9 + 7
calc = ModCalc(1001, MOD)
    
    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        
        res = 0
        
          # find ways to distribute n performers into 1 band, then 2, then 3, etc
          # for each # of bands, find the # of ways to assign those bands 

        for bands in range(1, x + 1):
            partitions = calc.stirling2(n, bands)
            permutations = calc.modFact(bands)
            ways = calc.modComb(x, bands)
            scoreCombos = calc.modPow(y, bands)
            resHere = calc.modMul(partitions, permutations, ways, scoreCombos)
            res += resHere
        
        return res % MOD



    
# class Solution:
#     def numberOfWays(self, n: int, x: int, y: int) -> int:
#         # find ways to distribute n performers into 1 band, then 2, then 3, etc
#         # for each # of bands, find the # of ways to assign those bands 
        
#         calc = ModCalc(1001, 10**9 + 7)
        
#         res = 0
        
#         # partition people into `bands` non-empty bands
#         for bands in range(1, x + 1):
#             partitions = calc.stirling2(n, bands)
#             print(f'partitions: {partitions}')
            
#             # number of ways to get unique scores for all bands
            ",1420063679
leetgoat_dot_dev,leetgoat_dot_dev,121,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            added = False
            for lower in range(1, num):
                if lower | (lower + 1) == num:
                    res.append(lower)
                    added = True
                    break
            if not added:
                res.append(-1)
        return res",1420017033
leetgoat_dot_dev,leetgoat_dot_dev,121,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            resHere = inf
            
            for offset in range(32):
                if num >> offset & 1:
                    option = num - (2**offset)
                    if option < 0:
                        break
                    if option | (option + 1) == num:
                        resHere = min(resHere, option)
            res.append(resHere if resHere != inf else -1)
        return res
                        
        
#         # smallest bottom number we can take
#         @cache
#         def dp(numStr, hasCarry, i):
            
        
#         # 1 + 2 + 4 + 8 + 16 = 31
#         # 1 1 1 1 1
        
        
#         # 13
#         # 8 4 2 1
        
#         # 11 
#         # 8 2 1
#         # 1 0 1 1
#         # 
        
        
        
        
        
        
        
        
        
#         # binary search for smallest lower bound
#         def solve(target):
#             l = 1
#             r = 10
#             res = None
#             while l <= r:
#                 m = (r + l) // 2
#                 print(f'm is: {m}')
#                 tot = m | (m + 1)
#                 print(f'tot is: {tot}')
#                 if tot > target:
#                     print(f'tot too big, going down')
#                     r = m - 1
#                 elif tot == target:
#                     print(f'tot is good, going down')
#                     res = m
#                     r = m - 1
#                 else:
#                     print('tot too small, going up')
#                     l = m + 1
#             if res is None:
#                 return -1
#             return res
        
#         print(solve(5))
        
#         # return [solve(nums[i]) for i in range(len(nums))]
    
    
                    
            ",1420066942
Fatih,Qode_breaker,122,3487,python3,"from typing import List

class PatternMatcher:
    def __init__(self, source: str, pattern: str):
        self.source = source
        self.pattern = pattern
        self.source_length = len(source)
        self.pattern_length = len(pattern)
    
    def compute_dp(self, target_indices: List[int]) -> List[int]:
        dp = [float('inf')] * (self.pattern_length + 1)
        dp[0] = 0
        is_target = [False] * self.source_length
        
        for index in target_indices:
            is_target[index] = True
            
        for i in range(self.source_length):
            for j in range(self.pattern_length, 0, -1):
                if self.source[i] == self.pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if is_target[i] else 0))
        
        return dp

class Solution:
    def maxRemovals(self, source: str, pattern: str, target_indices: List[int]) -> int:
        matcher = PatternMatcher(source, pattern)
        dp = matcher.compute_dp(target_indices)
        
        return len(target_indices) - (0 if dp[matcher.pattern_length] == float('inf') else dp[matcher.pattern_length])

# Example usage:
# solution = Solution()
# print(solution.max_removals(""abcde"", ""ace"", [0, 2]))  # Example input
",1420055289
Fatih,Qode_breaker,122,3604,python3,"from typing import List

MOD = 10**9 + 7

class Combinatorics:
    def __init__(self, x: int):
        self.C = [[0] * (x + 1) for _ in range(x + 1)]
        self.fact = [1] * (x + 1)
        self._initialize_combinations(x)
        self._initialize_factorials(x)

    def _initialize_combinations(self, x: int):
        for i in range(x + 1):
            self.C[i][0] = 1
            for j in range(1, i + 1):
                self.C[i][j] = (self.C[i - 1][j - 1] + self.C[i - 1][j]) % MOD

    def _initialize_factorials(self, x: int):
        for i in range(1, x + 1):
            self.fact[i] = self.fact[i - 1] * i % MOD

class StirlingNumbers:
    def __init__(self, n: int, x: int):
        self.S = [[0] * (x + 1) for _ in range(n + 1)]
        self.S[0][0] = 1
        self._initialize_stirling(n, x)

    def _initialize_stirling(self, n: int, x: int):
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                self.S[i][j] = (j * self.S[i - 1][j] + self.S[i - 1][j - 1]) % MOD

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        comb = Combinatorics(x)
        stirling = StirlingNumbers(n, x)

        result = 0
        power_func = lambda k: pow(y, k, MOD)

        for k in range(1, x + 1):
            power = power_func(k)
            result = (result + comb.C[x][k] * stirling.S[n][k] % MOD * comb.fact[k] % MOD * power) % MOD

        return result
",1420081271
Fatih,Qode_breaker,122,3605,cpp,"class Solution {
public:
    int f(int p) {
        for (int x = 1; x <= p; ++x) {
            if ((x | (x + 1)) == p) {
                return x;
            }
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& n) {
        int s = n.size();
        vector<int> a(s, -1);
        for (int i = 0; i < s; ++i) {
            a[i] = f(n[i]);
        }
        return a;
    }
};",1420003271
Fatih,Qode_breaker,122,3611,cpp,"#include <vector>
#include <limits>

#define MAX_BITS 30
#define MAX_INT std::numeric_limits<int>::max()

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& input) {
        int size = input.size();
        std::vector<int> result(size);
        
        for (int idx = 0; idx < size; idx++) {
            result[idx] = findMinimalValue(input[idx]);
        }
        
        return result;
    }

private:
    int findMinimalValue(int currentNum) {
        int minResult = MAX_INT;
        bool isFound = false;
        
        for (int bitPos = 0; bitPos <= MAX_BITS; bitPos++) {
            if (isBitSet(currentNum, bitPos)) {
                int potentialCandidate = unsetBit(currentNum, bitPos);
                
                if (isValidCandidate(potentialCandidate, currentNum)) {
                    if (potentialCandidate < minResult) {
                        minResult = potentialCandidate;
                        isFound = true;
                    }
                }
            }
        }
        
        return isFound ? minResult : -1;
    }

    bool isBitSet(int number, int bitPos) {
        return ((number >> bitPos) & 1) == 1;
    }

    int unsetBit(int number, int bitPos) {
        return number & ~(1 << bitPos);
    }

    bool isValidCandidate(int candidate, int original) {
        return candidate >= 0 && (candidate | (candidate + 1)) == original;
    }
};
",1420049044
Akash,akash_y_codes,123,3487,java,"import java.util.*;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        int[] dp = initializeDP(patternLength);
        boolean[] isTargetIndex = markTargetIndices(sourceLength, targetIndices);

        for (int i = 0; i < sourceLength; i++) {
            updateDP(source, pattern, dp, isTargetIndex, i, patternLength);
        }

        return targetIndices.length - (dp[patternLength] == Integer.MAX_VALUE ? 0 : dp[patternLength]);
    }

    private int[] initializeDP(int patternLength) {
        int[] dp = new int[patternLength + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        return dp;
    }

    private boolean[] markTargetIndices(int sourceLength, int[] targetIndices) {
        boolean[] isTargetIndex = new boolean[sourceLength];
        for (int idx : targetIndices) {
            isTargetIndex[idx] = true;
        }
        return isTargetIndex;
    }

    private void updateDP(String source, String pattern, int[] dp, boolean[] isTargetIndex, int sourceIndex, int patternLength) {
        for (int j = patternLength; j > 0; j--) {
            if (source.charAt(sourceIndex) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTargetIndex[sourceIndex] ? 1 : 0));
            }
        }
    }
}
",1420081672
Akash,akash_y_codes,123,3604,java,"class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        long[][] C = computeCombinations(x);
        long[][] S = computeStirlingNumbers(n, x);
        long[] fact = computeFactorials(x);

        return computeResult(n, x, y, C, S, fact);
    }

    private long[][] computeCombinations(int x) {
        long[][] C = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }

    private long[][] computeStirlingNumbers(int n, int x) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    private long[] computeFactorials(int x) {
        long[] fact = new long[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    private int computeResult(int n, int x, int y, long[][] C, long[][] S, long[] fact) {
        long result = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return (int) result;
    }
}
",1420075108
Akash,akash_y_codes,123,3605,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            ans[i] = findMinimumAns(nums.get(i));
        }
        
        return ans;
    }

    private int findMinimumAns(int num) {
        for (int x = 0; x <= num; x++) {
            if ((x | (x + 1)) == num) {
                return x;
            }
        }
        return -1;
    }
}",1419993229
Akash,akash_y_codes,123,3611,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int length = nums.size();
        int[] result = new int[length];

        for (int index = 0; index < length; index++) {
            int currentNumber = nums.get(index);
            int minimalCandidate = Integer.MAX_VALUE;
            boolean candidateFound = false;

            for (int bitPosition = 0; bitPosition < 31; bitPosition++) {
                if ((currentNumber >> bitPosition & 1) == 1) {
                    int potentialCandidate = currentNumber & ~(1 << bitPosition);

                    if (potentialCandidate >= 0 && (potentialCandidate | (potentialCandidate + 1)) == currentNumber) {
                        if (potentialCandidate < minimalCandidate) {
                            minimalCandidate = potentialCandidate;
                            candidateFound = true;
                        }
                    }
                }
            }

            result[index] = candidateFound ? minimalCandidate : -1;
        }

        return result;
    }
}
",1420054863
toastedloaf,toastedloaf,124,3487,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;

int best[3030][3030];
int ok[3030];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int N = source.size();
        int M = pattern.size();
        FOR(i, N+1) {
            ok[i] = 0;
            FOR(j, M+1) {
                best[i][j] = -1;
            }
        }
        FOR(i, sz(targetIndices)) {
            ok[targetIndices[i]] = 1;
        }
        best[0][0] = 0;
        FOR(i, N) {
            FOR(j, min(M, i) + 1) {
                if(best[i][j] == -1) continue;
                best[i+1][j] = max(best[i+1][j], best[i][j]);
                if(source[i] == pattern[j]) {
                    best[i+1][j+1] = max(best[i+1][j+1], best[i][j]);
                }
                if(ok[i]) {
                    best[i+1][j] = max(best[i+1][j], best[i][j] + 1);
                }
            }
        }
        return best[N][M];
    }
};",1420060077
toastedloaf,toastedloaf,124,3604,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;

// N ~ 10^6
class Combinations {
public:
  vector<mint> inv, fact, ifact;

  Combinations() {}
    
  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};

mint pw(int x, int y) {
    if(!y) return mint(1);
    if(y%2) return pw(x, y-1) * x;
    mint z = pw(x, y/2);
    return z*z;
}

int ok = 0;
Combinations cb;

mint calc(int n, int k) {
    mint ret = 0;
    for(int i=0;i<=k;++i) {
        mint sgn = mint(1);
        if((k-i)%2) sgn *= -1;
        ret += sgn * cb.comb(k, i) * pw(i, n);
    }
    return ret;
    //return ret / cb.fact[k];
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(!ok) {
            cb = Combinations(1000);
            ok = 1;
        }
        mint ret = 0;
        for(int k=1;k<=x;++k) {
            //cout<<calc(n, k) <<"" ""<<cb.comb(x, k)<<endl;
            ret += calc(n, k) * cb.comb(x, k) * pw(y, k);
        }
        return ret.x;
    }
};",1420038913
toastedloaf,toastedloaf,124,3605,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi v;
        FOR(i, sz(nums)) {
            int p = nums[i];
            if(p == 2) {
                v.pb(-1);
                continue;
            } else {
                int ret = 0;
                FOR(i, 30) {
                    if((p>>i)&1) {
                        ret += (1<<i);
                    } else {
                        ret += ((p>>i)<<i) - (1<<(i-1));
                        break;
                    }
                }
                v.pb(min(ret, p-1));
            }
        }
        return v;
    }
};",1420075951
toastedloaf,toastedloaf,124,3611,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vi v;
        FOR(i, sz(nums)) {
            int p = nums[i];
            if(p == 2) {
                v.pb(-1);
                continue;
            } else {
                int ret = 0;
                FOR(i, 30) {
                    if((p>>i)&1) {
                        ret += (1<<i);
                    } else {
                        ret += ((p>>i)<<i) - (1<<(i-1));
                        break;
                    }
                }
                v.pb(min(ret, p-1));
            }
        }
        return v;
    }
};",1420075674
tyagimzn,tyagimzn,126,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        // Initialize dp array and target marking
        vector<int> dp = initializeDP(m);
        vector<bool> isTarget = markTargetIndices(targetIndices, n);

        // Update the dp array based on source and pattern
        updateDP(source, pattern, dp, isTarget, n, m);

        // Calculate and return the maximum removals
        return calculateMaxRemovals(dp, targetIndices.size());
    }

private:
    vector<int> initializeDP(int m) {
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // Base case
        return dp;
    }

    vector<bool> markTargetIndices(const vector<int>& targetIndices, int n) {
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    void updateDP(const string& source, const string& pattern, vector<int>& dp, const vector<bool>& isTarget, int n, int m) {
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
    }

    int calculateMaxRemovals(const vector<int>& dp, int targetCount) {
        return targetCount - (dp.back() == INT_MAX ? 0 : dp.back());
    }
};
",1420062372
tyagimzn,tyagimzn,126,3604,cpp,"#include <iostream>
#include <vector>

using namespace std;

const int MOD = 1e9 + 7;

class Combinatorics {
public:
    vector<vector<int>> C;
    vector<int> fact;

    Combinatorics(int x) {
        C.resize(x + 1, vector<int>(x + 1, 0));
        fact.resize(x + 1, 1);
        initializeCombinations(x);
        initializeFactorials(x);
    }

private:
    void initializeCombinations(int x) {
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }

    void initializeFactorials(int x) {
        for (int i = 1; i <= x; i++) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
    }
};

class StirlingNumbers {
public:
    vector<vector<int>> S;

    StirlingNumbers(int n, int x) {
        S.resize(n + 1, vector<int>(x + 1, 0));
        S[0][0] = 1;
        initializeStirling(n, x);
    }

private:
    void initializeStirling(int n, int x) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
    }
};

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        Combinatorics comb(x);
        StirlingNumbers stirling(n, x);

        int result = 0;

        for (int k = 1; k <= x; k++) {
            int power = modPow(y, k);
            result = (result + (1LL * comb.C[x][k] * stirling.S[n][k] % MOD * comb.fact[k] % MOD * power) % MOD) % MOD;
        }

        return result;
    }

private:
    int modPow(int base, int exp) {
        int result = 1;
        while (exp) {
            if (exp % 2 == 1) {
                result = (1LL * result * base) % MOD;
            }
            base = (1LL * base * base) % MOD;
            exp /= 2;
        }
        return result;
    }
};

// Example usage
",1420083306
tyagimzn,tyagimzn,126,3605,python3,"class Solution:
    def findMinAns(self, prime):
        # Using a lambda to define the condition
        check = lambda x: (x | (x + 1)) == prime
        # Iterate over possible x values
        for x in range(1, prime + 1):
            if check(x):
                return x
        return -1  # If no such x exists, return -1

    def minBitwiseArray(self, nums):
        ans = [-1] * len(nums)  # Initialize ans array with -1 by default
        
        for i in range(len(nums)):
            ans[i] = self.findMinAns(nums[i])  # Find the minimum ans[i]
        
        return ans
",1420005407
tyagimzn,tyagimzn,126,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [self.find_minimal_ans(num) for num in nums]

    def find_minimal_ans(self, num: int) -> int:
        minimal_ans = float('inf')
        found = False
        
        for bit in range(31):
            if self.is_bit_set(num, bit):
                candidate = self.unset_bit(num, bit)
                
                if self.is_valid_candidate(candidate, num):
                    if candidate < minimal_ans:
                        minimal_ans = candidate
                        found = True
        
        return minimal_ans if found else -1

    def is_bit_set(self, num: int, bit: int) -> bool:
        return (num >> bit) & 1 == 1

    def unset_bit(self, num: int, bit: int) -> int:
        return num & ~(1 << bit)

    def is_valid_candidate(self, candidate: int, original: int) -> bool:
        return (candidate | (candidate + 1)) == original
",1420066124
Nguyn Tho,nguyenquocthao00,128,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        m,n = len(source), len(pattern)
        canremove = [False]*m
        for i in targetIndices: canremove[i]=True
        @lru_cache(None)
        def dp(i,j):
            if i==m:
                if j<n: return -m
                else: return 0
            if j==n:
                if canremove[i]: return 1 + dp(i+1,j)
                return dp(i+1,j)
            # keep
            if source[i]==pattern[j]: res=dp(i+1,j+1)
            else: res=dp(i+1,j)
            if canremove[i]: res=max(res, 1 + dp(i+1,j))
            return res
        return dp(0,0)


        ",1420030119
Nguyn Tho,nguyenquocthao00,128,3604,python3,"MOD = 10**9 + 7
@lru_cache(None)
def fac(v):
    if v==0: return 1
    return v*fac(v-1)%MOD
def mod_inverse(v):
    return pow(v, MOD-2, MOD)
@lru_cache(None)
def comb(x, i):
    return fac(x)*mod_inverse(fac(i) * fac(x-i))%MOD

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # for i,j in product(range(5),repeat=2):
        #     print(i+j, j, comb(i+j, j))
        # @lru_cache(None)
        # def combx(i):
        #     return comb(x, i)
        @lru_cache(None)
        def dp(x):
            res=0
            for i in range(1,x+1):
                res = (res + (-1)**(x-i)*comb(x,i) * pow(i,n,MOD))%MOD
            return res
        res=0
        for x2 in range(x+1):
            res += dp(x2)*comb(x,x2)*pow(y,x2,MOD)
            res = res%MOD
        return res
        
        ",1420076974
Nguyn Tho,nguyenquocthao00,128,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        m={}
        for i in range(1000):
            t = i|(i+1)
            if t not in m: m[t] = i
        def get(v):
            if v not in m: return -1
            return m[v]
        return [get(v) for v in nums]
        ",1419994791
Nguyn Tho,nguyenquocthao00,128,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # m={}
        # for i in range(1000):
        #     t = i|(i+1)
        #     if t not in m: 
        #         m[t] = i
        #         print(bin(i)[2:], bin(t)[2:])

        def get(v):
            if v==2: return -1
            nb = v.bit_length()
            # if (1<<nb)==v+1: return (1<<(nb-1))
            for i in range(nb+1):
                if v&(1<<i)==0:
                    return v - (1<<(i-1))
            


        # def get(v):
        #     if v not in m: return -1
        #     return m[v]
        return [get(v) for v in nums]
        ",1420010020
Ankit Kansal,ankitkansal173,129,3487,cpp,"class Solution {
public:
    int maxRemovals(string a, string b, vector<int>& v) {
        int n=a.size(),m=b.size();
        vector<vector<int>> dp(n+1,vector<int> (m+1,INT_MAX-n*5));
        vector<int> mp(n);
        for(auto i:v)mp[i]=1;
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                if(j==0){
                    dp[i][j]=0;
                    continue;
                }
                if(i==0)continue;
                dp[i][j]=dp[i-1][j];
                if(a[i-1]==b[j-1]){
                    dp[i][j]=min(dp[i][j],dp[i-1][j-1]+mp[i-1]);
                }
                // cout<<dp[i][j]<<"" "";
            }
            // cout<<""\n"";
            
        }
        int k=v.size();
        return k-dp[n][m];
        
    }
};",1420028771
Ankit Kansal,ankitkansal173,129,3604,cpp,"typedef long long ll;
long long power(long long x, long long y, long long p)
{
    long long res = 1;
    x=x%p; 
    while (y > 0) {
        if (y % 2 == 1) res = (res * x)%p;
        y = y >> 1;
        x = (x * x)%p;
    }
    return res % p;
}
const ll N=1e3+1;
ll factorialNumInverse[N + 1];
ll naturalNumInverse[N + 1];
ll fact[N + 1];
void InverseofNumber(ll p)
{
    naturalNumInverse[0] = naturalNumInverse[1] = 1;
    for (int i = 2; i <= N; i++)
        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
}
void InverseofFactorial(ll p)
{
    factorialNumInverse[0] = factorialNumInverse[1] = 1;
    for (int i = 2; i <= N; i++)
        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
}
void factorial(ll p)
{
    fact[0] = 1;
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % p;
    }
}
ll ncr(ll N, ll R, ll p)
{
    ll ans = ((fact[N] * factorialNumInverse[R])
              % p * factorialNumInverse[N - R])
             % p;
    return ans;
}


void start()
{
    ll p = 1000000007;
    InverseofNumber(p);
    InverseofFactorial(p);
    factorial(p);
} 

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        
        start();
        vector<long long> p(x+1);
        long long mod=1e9+7;
        for(long long i=1;i<=x;i++){
            p[i]=power(i,n,mod);
            for(ll j=0;j<i;j++){
                p[i]-=((ncr(i,j,mod)*p[j])%mod+mod)%mod;
                p[i]=(p[i]+mod)%mod;
            }
            cout<<p[i]<<"" "";
        }
        int h=0;
        for(long long i=1;i<=x;i++){
            h+=(((p[i]*power(y,i,mod))%mod)*ncr(x,i,mod))%mod;
            h%=mod;
        }
        return h;
    }
};",1420070372
Ankit Kansal,ankitkansal173,129,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        for(auto i:n){
            if(i%2==0){
                a.push_back(-1);
                continue;
            }
            int j=i;
            int k=1;
            while(j%2){
                j=j/2;
                k=k*2;
            }
            k=k/2;
            a.push_back(i-k);
        }
        return a;
        
    }
};",1420000637
Ankit Kansal,ankitkansal173,129,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        for(auto i:n){
            if(i%2==0){
                a.push_back(-1);
                continue;
            }
            int j=i;
            int k=1;
            while(j%2){
                j=j/2;
                k=k*2;
            }
            k=k/2;
            a.push_back(i-k);
        }
        return a;
        
    }
};",1420001943
Nihal,nsk_91,130,3487,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
#include <vector>
#include <string>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string var_200, string var_201, vector<int>& var_202) {
        int var_203 = var_200.size();
        int var_204 = var_201.size();
        vector<int> var_205(var_204 + 1, INT_MAX);
        var_205[0] = 0;
        vector<bool> var_206(var_203, false);

        int var_207 = 0;
        int var_208 = 1;
        int var_209 = 2;
        int var_210 = 3;
        int var_211 = var_207 + var_208 - var_209 + var_210;
        var_211 *= var_208;
        var_211 /= (var_210 + 1);
        var_211 -= var_209;
        var_211 = var_211 + var_209 - var_208;

        int var_212 = 0;
        while (var_212 < var_202.size()) {
            var_206[var_202[var_212]] = true;
            var_212++;
        }

        var_212 = 0;
        while (var_212 < var_203) {
            int var_213 = var_204;
            for (; var_213 > 0; --var_213) {
                switch (var_200[var_212] == var_201[var_213 - 1] && var_205[var_213 - 1] != INT_MAX) {
                    case true:
                        var_205[var_213] = min(var_205[var_213], var_205[var_213 - 1] + (var_206[var_212] ? 1 : 0));
                        break;
                    default:
                        break;
                }
            }
            var_212++;
        }

        switch (var_205[var_204] == INT_MAX) {
            case true:
                return var_202.size();
            default:
                return var_202.size() - var_205[var_204];
        }
    }
};
",1420060171
Nihal,nsk_91,130,3604,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
#include <vector>

class Solution {
private:
    const int var_200 = 1e9 + 7;
    
    std::vector<std::vector<long long>> var_201(int var_202) {
        std::vector<std::vector<long long>> var_203(var_202 + 1, std::vector<long long>(var_202 + 1, 0));
        
        int var_204 = 1, var_205 = 2, var_206 = 3, var_207 = 4;
        int var_208 = var_204 + var_205 - var_206;
        var_208 *= var_207;
        var_208 /= (var_204 + 1);
        var_208 += var_206 - var_205;
        var_208 -= var_207;

        int var_209 = 0;
        while (var_209 <= var_202) {
            var_203[var_209][0] = 1;
            int var_210 = 1;
            while (var_210 <= var_209) {
                var_203[var_209][var_210] = (var_203[var_209 - 1][var_210 - 1] + var_203[var_209 - 1][var_210]) % var_200;
                var_210++;
            }
            var_209++;
        }
        return var_203;
    }
    
    std::vector<std::vector<long long>> var_211(int var_212, int var_213) {
        std::vector<std::vector<long long>> var_214(var_212 + 1, std::vector<long long>(var_213 + 1, 0));
        var_214[0][0] = 1;

        int var_215 = 1;
        while (var_215 <= var_212) {
            int var_216 = 1;
            while (var_216 <= var_213) {
                var_214[var_215][var_216] = (var_216 * var_214[var_215 - 1][var_216] + var_214[var_215 - 1][var_216 - 1]) % var_200;
                var_216++;
            }
            var_215++;
        }
        return var_214;
    }
    
    std::vector<long long> var_217(int var_218) {
        std::vector<long long> var_219(var_218 + 1, 1);
        int var_220 = 1;
        while (var_220 <= var_218) {
            var_219[var_220] = (var_219[var_220 - 1] * var_220) % var_200;
            var_220++;
        }
        return var_219;
    }

public:
    int numberOfWays(int var_221, int var_222, int var_223) {
        auto var_224 = var_201(var_222);
        auto var_225 = var_211(var_221, var_222);
        auto var_226 = var_217(var_222);
        
        long long var_227 = 0;
        int var_228 = 1;
        while (var_228 <= var_222) {
            long long var_229 = 1;
            int var_230 = 0;
            while (var_230 < var_228) {
                var_229 = (var_229 * var_223) % var_200;
                var_230++;
            }
            long long var_231 = var_224[var_222][var_228];
            var_231 = (var_231 * var_225[var_221][var_228]) % var_200;
            var_231 = (var_231 * var_226[var_228]) % var_200;
            var_231 = (var_231 * var_229) % var_200;
            var_227 = (var_227 + var_231) % var_200;
            var_228++;
        }
        
        return static_cast<int>(var_227);
    }
};
",1420084393
Nihal,nsk_91,130,3605,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
class Solution {
public:
    int func_200(int var_200) {
        int var_201 = 1;
        while (var_201 <= var_200) {
            int var_202 = var_201 | (var_201 + 1);
            switch (var_202 == var_200) {
                case true:
                    return var_201;
            }
            ++var_201;
        }
        return -1;
    }

    vector<int> minBitwiseArray(vector<int>& var_203) {
        int var_204 = var_203.size();
        vector<int> var_205(var_204, -1);

        int var_206 = 0;
        while (var_206 < var_204) {
            var_205[var_206] = func_200(var_203[var_206]);
            ++var_206;
        }

        return var_205;
    }
};
",1420052249
Nihal,nsk_91,130,3611,cpp,"#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <deque>
#include <iterator>
#include <fstream>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <iomanip>
#include <cassert>
#include <climits>
#include <cstring>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <complex>

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define MAX_INT 2147483647
#define MIN_INT (-2147483648)
#define MAX_DOUBLE 1.7976931348623157E+308
#define MIN_DOUBLE 2.2250738585072014E-308
#define INF 1000000000
#define EPSILON 1e-9
#define BIG_NUMBER 1000000000000000LL
#define NEG_INF -1000000000
#define MAX_CHAR 255
#define MIN_CHAR 0
#define GREETING ""Hello, World!""
#define AUTHOR ""aksbadibsldicbsbc""
#define VERSION ""1.0.0""
#define COPYRIGHT_YEAR 2024
#define LICENSE ""MIT""
#define COMPANY ""OpenAI""
#define APP_NAME ""SuperApp""
#define URL ""https://example.com""
#define SUPPORT_EMAIL ""support@example.com""
#define BUILD_DATE __DATE__
#define BUILD_TIME __TIME__

void func_1(std::vector<int>& var_1, int var_2, int var_3, int var_4, int var_101, int var_102, int var_103, int var_104) {
    int var_5 = var_3 - var_2 + 1;
    int var_6 = var_4 - var_3;
    std::vector<int> var_7(var_5), var_8(var_6);
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;
    
    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_9 = 0;
    while (var_9 < var_5) {
        var_7[var_9] = var_1[var_2 + var_9];
        var_9++;
    }

    int var_10 = 0;
    while (var_10 < var_6) {
        var_8[var_10] = var_1[var_3 + 1 + var_10];
        var_10++;
    }

    int var_11 = 0, var_12 = 0, var_13 = var_2;
    for (; var_11 < var_5 && var_12 < var_6;) {
        switch (var_7[var_11] <= var_8[var_12]) {
            case 1: 
                var_1[var_13++] = var_7[var_11++];
                break;
            case 0: 
                var_1[var_13++] = var_8[var_12++];
                break;
        }
    }

    for (; var_11 < var_5;) {
        var_1[var_13++] = var_7[var_11++];
    }

    for (; var_12 < var_6;) {
        var_1[var_13++] = var_8[var_12++];
    }
}

void func_2(std::vector<int>& var_1, int var_2, int var_4, int var_101, int var_102, int var_103, int var_104) {
    switch (var_2 >= var_4) {
        case 1: 
            return;
        case 0: 
            int var_3 = var_2 + (var_4 - var_2) / 2;
            func_2(var_1, var_2, var_3, var_101, var_102, var_103, var_104);
            func_2(var_1, var_3 + 1, var_4, var_101, var_102, var_103, var_104);
            func_1(var_1, var_2, var_3, var_4, var_101, var_102, var_103, var_104);
            break;
    }
}

int func_3(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    int var_16 = var_1[var_15];
    int var_17 = (var_14 - 1);
    
    int var_105 = var_101 + var_102 * var_103 - var_104;
    var_105 = (var_105 * 3) + var_102;

    int var_106 = var_104 * var_103 - var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 * var_106 + var_101 - var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 * var_102 - var_103 + var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_18 = var_14;
    while (var_18 <= var_15 - 1) {
        switch (var_1[var_18] <= var_16) {
            case 1:
                var_17++;
                std::swap(var_1[var_17], var_1[var_18]);
                break;
        }
        var_18++;
    }
    std::swap(var_1[var_17 + 1], var_1[var_15]);
    return (var_17 + 1);
}

void func_4(std::vector<int>& var_1, int var_14, int var_15, int var_101, int var_102, int var_103, int var_104) {
    switch (var_14 < var_15) {
        case 1: 
            int var_19 = func_3(var_1, var_14, var_15, var_101, var_102, var_103, var_104);
            func_4(var_1, var_14, var_19 - 1, var_101, var_102, var_103, var_104);
            func_4(var_1, var_19 + 1, var_15, var_101, var_102, var_103, var_104);
            break;
    }
}

void func_5(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();

    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_21 = 0;
    while (var_21 < var_20 - 1) {
        int var_22 = 0;
        while (var_22 < var_20 - var_21 - 1) {
            switch (var_1[var_22] > var_1[var_22 + 1]) {
                case 1:
                    std::swap(var_1[var_22], var_1[var_22 + 1]);
                    break;
            }
            var_22++;
        }
        var_21++;
    }
}

void func_6(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_23 = 1;
    while (var_23 < var_20) {
        int var_24 = var_1[var_23];
        int var_25 = var_23 - 1;
        for (; var_25 >= 0;) {
            switch (var_1[var_25] > var_24) {
                case 1:
                    var_1[var_25 + 1] = var_1[var_25];
                    break;
                default:
                    break;
            }
            var_25--;
        }
        var_1[var_25 + 1] = var_24;
        var_23++;
    }
}

void func_7(std::vector<int>& var_1, int var_101, int var_102, int var_103, int var_104) {
    int var_20 = var_1.size();
    
    int var_105 = var_101 * var_102 - var_103 + var_104;
    var_105 = (var_105 * 2) + var_102;

    int var_106 = var_104 - var_103 * var_102 + var_101;
    var_106 = (var_106 + var_105) % 1000;

    int var_107 = var_105 + var_106 - var_101 + var_102;
    var_107 = var_107 * 3 + var_104;

    int var_108 = var_101 + var_102 * var_103 - var_104;
    var_108 = (var_108 + var_107) % 500;

    int var_26 = 0;
    while (var_26 < var_20 - 1) {
        int var_27 = var_26;
        int var_28 = var_26 + 1;
        while (var_28 < var_20) {
            switch (var_1[var_28] < var_1[var_27]) {
                case 1:
                    var_27 = var_28;
                    break;
            }
            var_28++;
        }
        std::swap(var_1[var_27], var_1[var_26]);
        var_26++;
    }
}
#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& var_200) {
        int var_201 = var_200.size();
        std::vector<int> var_202(var_201);
        
        int var_203 = 1, var_204 = 2, var_205 = 3, var_206 = 4;
        int var_207 = var_203 + var_204 - var_205;
        var_207 *= var_206;
        var_207 /= (var_203 + 1);
        var_207 += var_205 - var_204;
        var_207 -= var_206;

        int var_208 = 0;
        while (var_208 < var_201) {
            int var_209 = var_200[var_208];
            int var_210 = std::numeric_limits<int>::max();
            bool var_211 = false;
            
            int var_212 = 0;
            while (var_212 <= 30) {
                switch (((var_209 >> var_212) & 1) == 1) {
                    case true: {
                        int var_213 = var_209 & ~(1 << var_212);
                        switch (var_213 < 0) {
                            case true:
                                break;
                            default:
                                switch ((var_213 | (var_213 + 1)) == var_209) {
                                    case true:
                                        switch (var_213 < var_210) {
                                            case true:
                                                var_210 = var_213;
                                                var_211 = true;
                                                break;
                                            default:
                                                break;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                        }
                        break;
                    }
                    default:
                        break;
                }
                var_212++;
            }
            
            switch (var_211) {
                case true:
                    var_202[var_208] = var_210;
                    break;
                default:
                    var_202[var_208] = -1;
                    break;
            }
            var_208++;
        }
        
        return var_202;
    }
};
",1420065910
Varun Deep Saini,sojabhai,132,3487,cpp,"class Solution {
public:
    #define int long long
    vector<int> mp;
    int dp[3005][3005];
    vector<int> suffixSum;
    string s;
    string p;
    int n;
    int m;
    
    int rec(int indexS , int indexP){
        
        if(indexP == m) return suffixSum[indexS];
        
        if(indexS == n) return INT_MIN;
        
        int &ans = dp[indexS][indexP];
        
        if(ans != -1) return ans;
        
        ans = INT_MIN;
        
        if(s[indexS] == p[indexP]){
            
            int notTake = rec(indexS + 1 , indexP + 1);
            int take = INT_MIN;
            if(mp[indexS]){
                take = rec(indexS + 1 , indexP);
                take++;
            }
            
            ans = max(take , notTake);
            
        }else{
            ans = rec( indexS + 1 , indexP ) + mp[indexS]; 
        }
        
        return ans;
        
    }
    
    int maxRemovals(string source, string pattern, vector<int32_t> &targetIndices) {
        n = source.size();
        m = pattern.size();
        for(int i = 0 ;  i < n ; i++) for(int j = 0 ; j < m ; j++) dp[i][j] = -1;
        mp.assign(n , 0);
        suffixSum.assign(n + 1 , 0);
        s = source;
        p = pattern;
        for(auto &i : targetIndices) mp[i] = 1;
        for(int i = n - 1; i >= 0 ; i--){
            suffixSum[i] = suffixSum[i + 1] + mp[i];
        }
        
        int ans = rec( 0 , 0 );
        return max(ans , 0ll);
    }
    #undef int
};",1420077974
Varun Deep Saini,sojabhai,132,3604,cpp,"#define int long long
int z = 0;
const int N = 1000;
int dp[N + 1][N + 1];
int factorial[N + 1];
int invFactorial[N + 1];
    
const int MOD = 1e9 + 7;

class Solution {
public:
    int power(int x, int y) {
        int ans = 1;
        x %= MOD;
        while(y > 0){
            if(y & 1) ans = ans * x % MOD;
            x = x * x % MOD;
            y /= 2;
        }
        return ans;
    }
    
    void pre() {
        if(z) return;
        z = 1;
        memset(dp, -1, sizeof(dp));
        factorial[0] = 1;
        for(int i = 1; i <= N; ++i){
            factorial[i] = factorial[i-1] * i % MOD;
        }
        invFactorial[N] = power(factorial[N], MOD-2);
        for(int i=999; i>=0; --i){
            invFactorial[i] = invFactorial[i+1] * (i+1) % MOD;
        }
    }
    
    int rec(int n, int k){
        if(n == 0 && k == 0) return 1;
        if(n == 0 || k == 0) return 0;

        int &ans = dp[n][k];

        if(ans != -1){
            return ans;
        }

        ans = rec(n - 1 , k - 1);
        ans %= MOD;
        ans += (k * rec(n - 1, k)) % MOD;
        ans %= MOD;

        return ans % MOD;
    }
    
    int numberOfWays(int n, int x, int y) {
        pre();
        int ans = 0;
    
        for(int k = 1; k <= min(x, n); ++k){
            int a = factorial[x] * invFactorial[x - k];
            a %= MOD;
            
            int b = rec(n, k);
            b %+ MOD;
            
            int curr = (a * b);
            curr %= MOD;
            
            curr *= power(y, k);
            curr %= MOD;
            
            ans += curr;
            ans %= MOD;
        }
        
        return ans;
    }
};
#undef int
",1420028337
Varun Deep Saini,sojabhai,132,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto i : nums){
            int count = 0;
            int tmp = i;

            while(tmp & 1){
                count++;
                tmp/=2;
            }

            if(count == 0){
                ans.push_back(-1);
                continue;
            }

            long long sub = 1LL << (count -1);
            long long a = i - sub;
            if( (a | (a + 1)) == i ){
                ans.push_back(a);
            }else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};
",1419996083
Varun Deep Saini,sojabhai,132,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto i : nums){
            int count = 0;
            int tmp = i;

            while(tmp & 1){
                count++;
                tmp/=2;
            }

            if(count == 0){
                ans.push_back(-1);
                continue;
            }

            long long sub = 1LL << (count -1);
            long long a = i - sub;
            if( (a | (a + 1)) == i ){
                ans.push_back(a);
            }else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};
",1419995710
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        t = set(t)

        dp = [[-inf for _ in range(len(p)+1)] for _ in range(len(s)+1)]
        for j in range(len(p)+1):
            dp[len(s)][j] = -inf if j != len(p) else 0
        for i in range(len(s)-1, -1, -1):
            dp[i][len(p)] = int(i in t) + dp[i+1][len(p)]
        for i in range(len(s)-1, -1, -1):
            for j in range(len(p)-1, -1, -1):
                dp[i][j] = int(i in t) + dp[i+1][j]
                if s[i] == p[j]:
                    dp[i][j] = max(dp[i][j], dp[i+1][j+1])
        return dp[0][0]
",1420049672
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9+7
        dp = [[0 for _ in range(x+1)] for _ in range(n)]
        dp[0][1] = x
        for i in range(1, n):
            for j in range(1, x+1):
                dp[i][j] = dp[i-1][j] * j + dp[i-1][j-1] * (x - j + 1)
                dp[i][j] %= MOD
        # print(dp)
        ret = 0
        for j in range(1, x+1):
            ret += dp[n-1][j] * pow(y, j, MOD)
            ret %= MOD
        return ret",1420071252
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for x in nums:
            if x == 2:
                ret.append(-1)
                continue
            a = bin(x)[2:]
            c = 0
            f = 1
            for i in range(len(a)-1, -1, -1):
                t = int(a[i])
                if t:
                    if f:
                        if i != len(a) - 1:
                            c = 2 * c + 1
                    else:
                        c += 1 << (len(a) - 1 - i)
                else:
                    f = 0
            ret.append(c)
        return ret",1420012376
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,134,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for x in nums:
            if x == 2:
                ret.append(-1)
                continue
            a = bin(x)[2:]
            c = 0
            f = 1
            for i in range(len(a)-1, -1, -1):
                t = int(a[i])
                if t:
                    if f:
                        if i != len(a) - 1:
                            c = 2 * c + 1
                    else:
                        c += 1 << (len(a) - 1 - i)
                else:
                    f = 0
            ret.append(c)
        return ret
                

            ",1420011994
ritik6g,ritik6g,135,3487,php,"class Solution {

    /**
     * @param String $source
     * @param String $pattern
     * @param Integer[] $targetIndices
     * @return Integer
     */
  function maxRemovals($source, $pattern, $targetIndices) {
        $le = strlen($source);
        $pl = strlen($pattern);

        // $in = PHP_INT_MAX;
        // $dp = array_fill(0, $pl + 1, $in);
        // $dp[0] = 0;




        $ci = array_fill(0, $le, false);
        foreach ($targetIndices as $ix) {
            $ci[$ix] = true;
        }
        $in = PHP_INT_MAX;
        $dp = array_fill(0, $pl + 1, $in);
        $dp[0] = 0;




    //   $in = PHP_INT_MAX;
    //     $dp = array_fill(0, $pl + 1, $in);
    //     $dp[0] = 0;






        for ($i = 0; $i < $le; $i++) {
            for ($j = $pl - 1; $j >= 0; $j--) {
                if ($source[$i] === $pattern[$j]) {
                    $dp[$j + 1] = min($dp[$j + 1], $dp[$j] + ($ci[$i] ? 1 : 0));
                }
            }
        }


        // for ($i = 0; $i < $le; $i++) {
        //     for ($j = $pl - 1; $j >= 0; $j--) {
        //         if ($source[$i] === $pattern[$j]) {
        //             $dp[$j + 1] = min($dp[$j + 1], $dp[$j] + ($ci[$i] ? 1 : 0));
        //         }
        //     }
        // }






        if ($dp[$pl] === $in) {
            return 0;
        }
        $re = count($targetIndices) - $dp[$pl];
        return max($re, 0);
    }
}",1420078250
ritik6g,ritik6g,135,3604,php,"class Solution {
    public function numberOfWays($n, $x, $y) {
        $MOD = 1000000007;
        $cb = array_fill(0, $n + 1, array_fill(0, $x + 1, 0));
        $cb[0][0] = 1;

        for ($i = 1; $i <= $n; $i++) {
            for ($j = 1; $j <= min($i, $x); $j++) {
                $cb[$i][$j] = ($j * $cb[$i - 1][$j] + $cb[$i - 1][$j - 1]) % $MOD;
            }
        }


        // for ($i = 1; $i <= $n; $i++) {
        //     for ($j = 1; $j <= min($i, $x); $j++) {
        //         $cb[$i][$j] = ($j * $cb[$i - 1][$j] + $cb[$i - 1][$j - 1]) % $MOD;
        //     }
        // }





        $bn = array_fill(0, $x + 1, 0);
        $bn[0] = 1;

        for ($i = 1; $i <= $x; $i++) {
            for ($j = min($i, $x); $j >= 1; $j--) {
                $bn[$j] = ($bn[$j] + $bn[$j - 1]) % $MOD;
            }
        }


    //    for ($i = 1; $i <= $x; $i++) {
    //         for ($j = min($i, $x); $j >= 1; $j--) {
    //             $bn[$j] = ($bn[$j] + $bn[$j - 1]) % $MOD;
    //         }
    //     }




        $fc = array_fill(0, $x + 1, 0);
        $fc[0] = 1;

        for ($i = 1; $i <= $x; $i++) {
            $fc[$i] = ($fc[$i - 1] * $i) % $MOD;
        }

        $m = min($x, $n);
        $py = array_fill(0, $m + 1, 0);
        $py[0] = 1;


        // $m = min($x, $n);
        // $py = array_fill(0, $m + 1, 0);
        // $py[0] = 1;





        for ($k = 1; $k <= $m; $k++) {
            $py[$k] = ($py[$k - 1] * $y) % $MOD;
        }

        $rs = 0;

        for ($k = 1; $k <= $m; $k++) {
            $tp = ($bn[$k] * $fc[$k]) % $MOD;
            $tp = ($tp * $cb[$n][$k]) % $MOD;
            $tp = ($tp * $py[$k]) % $MOD;
            $rs = ($rs + $tp) % $MOD;
        }

        return (int) $rs;
    }
}
",1420068832
ritik6g,ritik6g,135,3605,kotlin,"class Solution {
    fun minBitwiseArray(ns: List<Int>): IntArray {
        val an = IntArray(ns.size)

        for (i in ns.indices) {
            val n = ns[i]
            var fd = false

            for (j in 0 until n) {
                if ((j or (j + 1)) == n) {
                    an[i] = j
                    fd = true
                    break
                }
            }


            //  for (j in 0 until n) {
            //     if ((j or (j + 1)) == n) {
            //         an[i] = j
            //         fd = true
            //         break
            //     }
            // }

            if (!fd) {
                an[i] = -1
            }
        }

        return an
    }
}
",1420064349
ritik6g,ritik6g,135,3611,php,"class Solution {
    function minBitwiseArray($ns) {
        $rs = array_fill(0, count($ns), 0);

        for ($i = 0; $i < count($ns); $i++) {
            $cn = $ns[$i];
            $mc = PHP_INT_MAX;

            for ($bi = 0; $bi < 31; $bi++) {
                if (($cn & (1 << $bi)) != 0) {
                    $ca = $cn & ~(1 << $bi);

                    if ($ca < 0 || $ca >= $cn) {
                        continue;
                    }

                    $nc = $ca + 1;

                    if (($ca | $nc) == $cn) {
                        if ($ca < $mc) {
                            $mc = $ca;
                        }
                    }
                }
            }

            $rs[$i] = ($mc != PHP_INT_MAX) ? $mc : -1;
        }

        return $rs;
    }
}
",1420063168
Ahmed_Ashraf,boAshraf,136,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> tar(n, 0);
        for (auto it : targetIndices) tar[it] = 1;

        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1)); // DP table for memoization

        auto rec = [&](auto&& self, int i, int j) -> int {
            if (i == n) return (j==m?0:-1e9);

            int &ret = dp[i][j];
            if (~ret) return ret;

            ret = self(self, i + 1, j);

            if (tar[i]) {
                ret = max(ret, self(self, i + 1, j) + 1);
            }

            if (j<m&&source[i] == pattern[j]) {
                ret = max(ret, self(self, i + 1, j + 1));
            }

            return ret;
        };

        return rec(rec, 0, 0);
    }
};",1420020618
Ahmed_Ashraf,boAshraf,136,3604,cpp,"
class Solution {
public:
    const int MOD = 1e9 + 7;

    long long modPow(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));

        dp[0][0] = 1;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                dp[i][j] = (dp[i-1][j] * j) % MOD;

                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (x - (j-1))) % MOD;
            }
        }

        long long result = 0;
        for (int j = 1; j <= x; ++j) {
            result = (result + dp[n][j] * modPow(y, j, MOD)) % MOD;
        }

        return result;
    }
};",1420085441
Ahmed_Ashraf,boAshraf,136,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=nums[i];j++){
                if((j|(j+1))==nums[i]){ans[i]=j;break;}
            }
        }
        return ans;
    }
};",1419994216
Ahmed_Ashraf,boAshraf,136,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]==3)ans[i]=1;
            else if(nums[i]>3){
                int idx=-1;
                for(int b=0;b<30;b++){
                    if(!((nums[i]>>b)&1)){idx=b;break;}
                }
                ans[i]=(nums[i]^(1<<(idx-1)));
            }
        }
        return ans;
    }
};",1420000782
SR3mix,SR3mix,137,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& t) {
        int n = source.size();
        reverse(t.begin(), t.end());
        vector<vector<int>>dp(n+1, vector<int>(n+1,-1));
        dp[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            char c = source[i-1];
            if (t.size() && t.back() + 1 == i) {
                t.pop_back();
                dp[i][0] = 0;
                for (int j = 0; j <= n; j++) {
                    dp[i][j] = dp[i-1][j];
                    if (dp[i][j] > -1 && dp[i][j] < pattern.size() && pattern[dp[i][j]] == c) dp[i][j]++;
                    if (j > 0) dp[i][j] = max(dp[i][j], dp[i-1][j-1]);
                }
            }
            else {
                for (int j = 0; j <= n; j++) {
                    dp[i][j] = dp[i-1][j];
                    if (dp[i][j] > -1 && dp[i][j] < pattern.size() && pattern[dp[i][j]] == c) dp[i][j]++;
                }
            }
        }
        // for (auto i : dp) {
        //     for (auto j : i) {
        //         cout << j << "","";
        //     }
        //     cout << endl;
        // }
        // cout << endl;
        int ans = 0;
        for (int i = 0; i <= n; i++) if (dp[n][i] == pattern.size()) ans = i;
        return ans;
    }
};",1420078636
SR3mix,SR3mix,137,3604,cpp,"class Math {
    public:
    vector<long long> fact_vec,invfact_vec;
    vector<long long> fact_vec_pure;
    vector<long long> e10_vec;
    vector<int>primes,minp,isprime,phi;
    long long comb_M = -1;
    long long int powxy(long long int x, long long int y, long long M) {
        if (y == 0) return 1;
        if (y%2 == 1) return (x*powxy(x, y-1,M))%M;
        long long int t = powxy(x, y/2,M);
        return (t*t)%M;
    }
    void create_comb(long long maxChooseNumerator, long long M) {
        comb_M = M;
        if (fact_vec.size() > maxChooseNumerator) return;
        if (fact_vec.size() == 0) {
            fact_vec = {1,1};
            invfact_vec = {1,1};
        }
        long long startI = fact_vec.size();
        for (long long i = startI; i <= maxChooseNumerator+1; i++) {
            long long lastFact = fact_vec.back();
            long long currFact = (lastFact * i)%M;
            fact_vec.push_back(currFact);
        }
        invfact_vec.resize(fact_vec.size());
        invfact_vec[fact_vec.size()-1] = powxy(fact_vec.back(), M-2, M);
        for (long long i = maxChooseNumerator; i >= startI; i--) {
            long long lastInv = invfact_vec[i+1];
            long long currInv = (lastInv * (i+1))%M;
            invfact_vec[i] = currInv;
        }
    }
    long long factorial(long long n, long long M) {
        assert(comb_M == M);
        return fact_vec[n];
    }
    long long inv_factorial(long long n, long long M) {
        assert(comb_M == M);
        return invfact_vec[n];
    }
    long long comb(long long a, long long b, long long M) {
        assert(comb_M == M);
        return (((fact_vec[a] * invfact_vec[b])%comb_M) * invfact_vec[a-b])%comb_M;
    }
    long long mgcd(long long a, long long b, long long& x, long long& y) {
        if (b == 0) {x = 1; y = 0; return a;}
        long long x1, y1;
        long long d = mgcd(b, a % b, x1, y1);
        x = y1;
        y = x1 - y1 * (a / b);
        return d;
    }
    long long moddiv(long long a, long long  b, long long M) {
        a = a%M;
        long long x,y;
        long long g = mgcd(b,M,x,y);
        long long inv = (x%M + M)%M;
        return (inv * a)%M;
    }
    long long comb_pure(long long a, long long b) {
        long long numer = factorial_pure(a);
        long long denom1 = factorial_pure(b);
        long long denom2 = factorial_pure(a - b);
        return numer/(denom1 * denom2);
    }
    long long factorial_pure(long long n) {
        assert(n <= 20);
        if (fact_vec_pure.size() == 0) fact_vec_pure.push_back(1);
        while (fact_vec_pure.size() <= n) {
            long long val = fact_vec_pure.size();
            fact_vec_pure.push_back(fact_vec_pure.back() * val);
        }
        return fact_vec_pure[n];
    }
    long long exp10(int p) {
        assert(p <= 18);
        if (e10_vec.size() == 0) e10_vec.push_back(1);
        while (e10_vec.size() <= p) {
            e10_vec.push_back(e10_vec.back() * 10LL);
        }
        return e10_vec[p];
    }
    unsigned long long comb_2(unsigned long long num) {
        if (num%2 == 0) {return (num/2) * (num-1);}
        else {return ((num-1)/2) * num;}
    }
    long long safe_sqrt(long long x) {
        long long l = 0, r = x;
        while (l < r) {
            long long m = l + (r-l)/2 + (r-l)%2;
            long long allow = LLONG_MAX/m;
            if (m <= allow && m * m <= x) l = m;
            else r = m-1;
        }
        return l;
    }
    long long arith_seq_sum(long long first, long long last, long long diff) {
        long long endSum = first + last;
        long long nums = ((last - first)/diff) + 1;
        
        if (endSum%2 == 0) {return (endSum/2) * nums;}
        else {return (nums/2) * endSum;}
    }
    void SievePrimes(int n) {
        if (minp.size() == n+1) return;
        minp = vector<int>(n+1), isprime = minp;
        primes = {};
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {if (i * p > n) break; minp[i*p]=p;}
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    void SieveFull(int n) {
        if (phi.size() == n+1) return;
        phi = vector<int>(n+1);
        minp = vector<int>(n+1);
        isprime = phi;
        primes = {};
        phi[1] = 1;
        for (int i = 2; i <= n; i++) {
            if (minp[i] == 0) {
                minp[i] = i;
                phi[i] = i - 1;
                primes.push_back(i);
                isprime[i] = 1;
            }
            for (auto p : primes) {
                if (i * p > n) {
                    break;
                }
                minp[i * p] = p;
                if (p == minp[i]) {
                    phi[i * p] = phi[i] * p;
                    break;
                }
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
    // CREDIT TO JIANGLY FOR THIS TEMPLATE -> https://codeforces.com/profile/jiangly
    vector<array<long long, 2>> prime_factorize(long long num) {
        vector<array<long long, 2>>res;
        for (auto p : primes) {
            if (p > num) break;
            int cnt = 0;
            while (num%p == 0) {
                num /= p;
                cnt++;
            }
            if (cnt) res.push_back({p,cnt});
        }
        if (num > 1) res.push_back({num,1});
        return res;
    }
    vector<int> get_factors(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        vector<int>res;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) res.push_back(i);
        }
        int start = res.size() - 1;
        for (int i = start; i >= 0; i--) {
            if ((num/res[i]) != res[i]) res.push_back(num/res[i]);
        }
        return res;
    }
    vector<int> get_factors_robust(long long num) {
        assert(num <= INT_MAX);
        int upto = (int)pow(num, 0.5);
        set<int>s;
        for (int i = 1; i <= upto; i++) {
            if (num%i == 0) {s.insert(i); s.insert(num/i);}
        }
        vector<int>res; for (auto i : s) res.push_back(i);
        return res;
    }
    vector<vector<long long>> matmul(vector<vector<long long>>&mat1, vector<vector<long long>>&mat2, long long M) {
        assert(mat1[0].size() == mat2.size());
        int m = mat1.size(), n = mat2[0].size();
        vector<vector<long long>>mat(m, vector<long long>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < mat1[0].size(); k++) {
                    long long add = mat1[i][k] * mat2[k][j];
                    if (M > 0) add %= M;
                    mat[i][j] += add;
                    if (M > 0) mat[i][j] %= M;
                }
            }
        }
        return mat;
    }
    vector<vector<long long>> mateye(int n) {
        vector<vector<long long>>res(n, vector<long long>(n));
        for (int i = 0; i < n; i++) res[i][i] = 1;
        return res;
    }
    vector<vector<long long>> matexp(vector<vector<long long>>&mat, long long p, long long M) {
        if (p == 0) return mateye(mat.size());
        if (p == 1) return mat;
        vector<vector<long long>>mat1 = matexp(mat, p/2, M);
        vector<vector<long long>>res = matmul(mat1, mat1, M);
        if (p%2) return matmul(res, mat, M);
        return res;
    }
    long long first_bit(long long num) {
        if (num == 0) return -1;
        if (num > INT_MAX) return 64 - __builtin_clzll(num) - 1;
        else return 32 - __builtin_clz(num) - 1;
    }
    long long log2(long long num) {
        return first_bit(num);
    }
    long long last_bit(long long num) {
        return __builtin_ctzll(num);
    }
    long long frombin(string &s) {
        long long res = 0;
        for (int shift = 0; shift < s.size(); shift++) {
            if (s[s.size() - shift - 1] == '1') {
                res += (1LL << shift);
            }
        }
        return res;
    }
    string tobin(long long num, int len) {
        string res = """"; for (int i = 0; i < len; i++) res += '0';
        for (int shift = 0; shift < 63; shift++) {
            if ((num & (1LL << shift)) != 0) res[len - shift - 1] = '1';
        }
        return res;
    }
    string toBase(long long n, long long b) {
        bool neg = false;
        if (n < 0) {neg = true;}
        n = abs(n);
        string ans = """";
        while (n > 0) {
            ans += to_string(n%b);
            n /= b;
        }
        if (ans.size() == 0) ans = ""0"";
        if (neg) ans += ""-"";
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
Math math;
typedef long long ll; 
ll M = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        math.create_comb(2500, M);
        ll run = 0;
        ll ans = 0;
        vector<ll>v(x+1);
        for (int use = 1; use <= x; use++) {
            ll ch = math.comb(x, use, M);
            ll ways = math.powxy(use,n,M);
    
            for (int i = use-1; i >= 1; i--) {
                ll sel = math.comb(use,i,M);
                if (true) {
                    ways = (ways + M - (sel * v[i])%M)%M;
                }
                else {
                    ways = (ways + (sel * v[i])%M)%M;
                }
            }
            ll get = (ch * ways)%M;
            v[use] = ways;
            ll scores = math.powxy(y,use,M);
            ll add = (get * scores)%M;
            //cout << use << "": "" << ch << "","" << ways << "","" << get << "","" << scores << "","" << add << endl;
            //run = (run + get)%M;
            ans = (ans + add)%M;
        }
        return ans;
    }
};",1420031806
SR3mix,SR3mix,137,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for (auto x : nums) {
            int use = log2(x) + 1;
            if (x == 2) {ans.push_back(-1); continue;}
            int d = 0;
            for (int b = 0; b < use; b++) {
                if (((1 << b) & x) != 0) {
                    x -= (1 << b);
                    d++;
                }
                else break;
            }
            x += ((1 << (d-1))-1);
            ans.push_back(x);
        }
        return ans;
    }
};",1420044258
SR3mix,SR3mix,137,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for (auto x : nums) {
            int use = log2(x) + 1;
            if (x == 2) {ans.push_back(-1); continue;}
            int d = 0;
            for (int b = 0; b < use; b++) {
                if (((1 << b) & x) != 0) {
                    x -= (1 << b);
                    d++;
                }
                else break;
            }
            x += ((1 << (d-1))-1);
            ans.push_back(x);
        }
        return ans;
    }
};",1420043806
Vitalii Nevidomyi,deadRabbit,139,3487,cpp,"int dp[3001][3001];

string S,P;
int C[3001];

int go(int x, int p) {
    if (p==P.size()) return 0;
    if (x==S.size()) return 1<<30;
    int &r = dp[x][p];
    if (r==-1) {
        r = go(x+1,p);
        // take:
        r = min(r, go(x+1,P[p]==S[x]?p+1:p) + C[x]);
    }
    return r;
}

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(C,0,sizeof(C)); 
        for (int x : targetIndices) C[x]=1;
        memset(dp,-1,sizeof(dp));
        S = source;
        P = pattern;
        return (int)targetIndices.size() - go(0,0);
    }
};",1420021585
Vitalii Nevidomyi,deadRabbit,139,3604,cpp,"const int mod = 1000 * 1000 * 1000 + 7;

int powmod(int x, int n) {
  int r = 1;
  while (n) {
    if (n & 1) {
      r = 1ll * r * x % mod;
    }
    n >>= 1;
    x = 1ll * x * x % mod;
  }
  return r;
}

int C[1001][1001];
int F[1001];

void pre() {
  C[0][0] = 1;
  F[0] = 1;
  for (int i = 1; i <= 1000; ++i) {
    F[i] = (1ll * F[i-1] * i) % mod;
    C[i][0] = C[i][i] = 1;
    for (int j = 1; j < i; ++j) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
  }
}

class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    pre();

    long long res = 0;
    vector<long long> V(x+1,0);
    for (int m = 1; m <= x; ++m) {
      long long v = 0;
      if (n >= m) {
        v = powmod(m, n);
        for (int i = 1; i < m; ++i) {
          v = (v + mod - (V[i] * C[m][i] % mod)) % mod;
        }
      }
      V[m] = v;
      v = v * C[x][m] % mod;
      res = (res + v * powmod(y, m)) % mod;
    }
    return res;
  }
};",1420086344
Vitalii Nevidomyi,deadRabbit,139,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> r;
        for (int x : nums) {
            if (!(x&1)) r.push_back(-1);
            else {
                int c = 0;
                int y = x;
                while(y&1) {
                    ++c;
                    y/=2;
                }
                --c;
                r.push_back(x - (1<<c));
            }
        }
        return r;
    }
};",1420001552
Vitalii Nevidomyi,deadRabbit,139,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> r;
        for (int x : nums) {
            if (!(x&1)) r.push_back(-1);
            else {
                int c = 0;
                int y = x;
                while(y&1) {
                    ++c;
                    y/=2;
                }
                --c;
                r.push_back(x - (1<<c));
            }
        }
        return r;
    }
};",1420001897
Siddique13,Siddique13,142,3487,cpp,"class Solution {
    private:
    int tabuk(string s, string p, vector<int>& t) {
        int n = s.length();
        int m = p.length();
        vector<int> a(m + 1, INT_MAX);  
        a[0] = 0;
        vector<bool> x(n, false);  

        int k = 0;
        while (k < t.size()) {  
            x[t[k]] = true;
            k++;
        }

        int i = 0;
        while (i < n) {  
            int j = m;
            while (j > 0) {  
                if (s[i] == p[j - 1] && a[j - 1] != INT_MAX) {
                    a[j] = min(a[j], a[j - 1] + (x[i] ? 1 : 0));
                }
                j--;
            }
            i++;
        }

        return t.size() - (a[m] == INT_MAX ? 0 : a[m]);
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        return tabuk(source,pattern,targetIndices);
    }
};",1420056953
Siddique13,Siddique13,142,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, a: int, b: int, c: int) -> int:
        inputs = [a, b, c]
        comb = self.calc_comb(b)
        stirling = self.calc_stirling(a, b)
        fact = self.calc_fact(b)
        
        return self.compute_result(a, b, c, comb, stirling, fact)

    def calc_comb(self, x: int) -> List[List[int]]:
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        i = 0
        while i <= x:
            comb[i][0] = 1
            j = 1
            while j <= i:
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
                j += 1
            i += 1
        return comb

    def calc_stirling(self, n: int, x: int) -> List[List[int]]:
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        i = 1
        while i <= n:
            for j in range(1, x + 1):  # Used for-loop here
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
            i += 1
        return stirling

    def calc_fact(self, x: int) -> List[int]:
        fact = [1] * (x + 1)
        i = 1
        while i <= x:
            fact[i] = fact[i - 1] * i % MOD
            i += 1
        return fact

    def compute_result(self, n: int, x: int, y: int, comb: List[List[int]], stirling: List[List[int]], fact: List[int]) -> int:
        res = 0
        k = 1
        while k <= x:
            power = self.calc_power(y, k)
            res = (res + comb[x][k] * stirling[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
            k += 1
        return res

    def calc_power(self, base: int, exp: int) -> int:
        power = 1
        # Using a lambda function for exponentiation
        power_func = lambda b, e: (b * self.calc_power(b, e - 1)) % MOD if e > 0 else 1
        return power_func(base, exp)

",1420088375
Siddique13,Siddique13,142,3605,cpp,"class Solution {
    private:
    vector<int> irshad(std::vector<int>& p) {
        int n = p.size();
        std::vector<int> r(n, -1);  

        
        for (int i = 0; i < n; i++) {
            
            if (p[i] == 2) {
                continue; 
            }

            
            for (int x = 0; x <= p[i]; x++) {
                if ((x | (x + 1)) == p[i]) {
                    r[i] = x;
                    break;  
                }
            }
        }
        
        return r;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        return irshad(nums);

    }
};",1420021377
Siddique13,Siddique13,142,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        return self.irshad(nums)
    
    def irshad(self, w):
        x = len(w)
        z = [0] * x
        
        for y in range(x):
            m = w[y]
            r = float('inf')
            f = False
            
            for b in range(31):
                if ((m >> b) & 1) == 1:
                    c = m & ~(1 << b)
                    
                    if c < 0:
                        continue
                    
                    if (c | (c + 1)) == m:
                        if c < r:
                            r = c
                            f = True
            
            if f:
                z[y] = r
            else:
                z[y] = -1
        
        return z
        ",1420067213
Akuldeep,akuldeepj,143,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        fuckit = [False] * n
        for i in targetIndices:
            fuckit[i] = True

        befdp = [float('inf')] * (m + 1)
        currdp = [float('inf')] * (m + 1)
        befdp[0] = 0

        for i in range(n):
            currdp[0] = befdp[0]
            for j in range(m):
                currdp[j+1] = befdp[j+1]
                if source[i] == pattern[j]:
                    cost = befdp[j]
                    if fuckit[i]:
                        cost += 1
                    currdp[j+1] = min(currdp[j+1], cost)

            befdp, currdp = currdp, [float('inf')] * (m + 1)

        x = befdp[m]
        return len(targetIndices) - x",1420046058
Akuldeep,akuldeepj,143,3604,python3,"MOD = 10**9 + 7
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        maxk = min(n, x)
        hadd = n + x + 1
        
        fac = [1] * hadd
        inv = [1] * hadd

        for i in range(1, hadd):
            fac[i] = (fac[i - 1] * i) % MOD

        inv[hadd - 1] = pow(fac[hadd - 1], MOD - 2, MOD)
        for i in range(hadd - 2, -1, -1):
            inv[i] = (inv[i + 1] * (i + 1)) % MOD

        S = [[0] * (maxk + 2) for _ in range(n + 2)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, maxk + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD

        t = 0
        for k in range(1, maxk + 1):
            if x < k:
                continue
            comb = (fac[x] * inv[k] % MOD) * inv[x - k] % MOD

            perm = fac[k] % MOD
            a = S[n][k]
            num = pow(y, k, MOD)

            w = comb * perm % MOD
            w = w * a % MOD
            w = w * num % MOD

            t = (t + w) % MOD

        return t",1420068081
Akuldeep,akuldeepj,143,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        map = {}
        for i in range(2, 1001):
            f = all(i % j != 0 for j in range(2, int(i**0.5) + 1))
            if f:
                mila = False
                for x in range(i):
                    if (x | (x + 1)) == i:
                        map[i] = x
                        mila = True
                        break
                if not mila:
                    map[i] = -1
        return [map[i] for i in nums]",1419999820
Akuldeep,akuldeepj,143,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            minval = float('inf')
            f = False
            k = 0
            temp = i
            while temp > 0:
                if temp & 1:
                    x = i - (1 << k)
                    if x >= 0 and (x | (x + 1)) == i:
                        if x < minval:
                            minval = x
                            f = True
                temp >>= 1
                k += 1
            if f:
                ans.append(minval)
            else:
                ans.append(-1)
        return ans",1420030040
Thomas Draper,shaletome,144,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        ns=len(source)
        nt=len(targetIndices)
        dp=[0]
        sti=set(targetIndices)
        for i,c in enumerate(source):
            ndp=dp.copy()
            for j in range(len(dp)):
                v=dp[j]
                if v < len(pattern) and pattern[v]==c:
                    ndp[j]=max(ndp[j],v+1)
            if i in sti:
                ndp.append(0)
                for j in range(len(ndp)-1,0,-1):
                    ndp[j]=max(ndp[j],dp[j-1])
            dp = ndp
            # print(dp)
        return max([i for i in range(nt+1) if dp[i]==len(pattern)])",1420018634
Thomas Draper,shaletome,144,3604,python3,"combs=[[1]]
p=10**9+7
facs=[1]
for v in range(1,2050):
    facs.append((facs[-1]*v)%p)
for _ in range(2050):
    nf=[1]
    for a,b in zip(combs[-1],combs[-1][1:]):
        nf.append((a+b)%p)
    nf.append(1)
    combs.append(nf)
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # x^n assignments to stages
        # x assignments to 1 stage
        # (x choose 2) * (2^n) assignments to 2
        # (x choose 3) * (3^n) to 3
        # y^(numfilled) scores

        # x * y + (xc2)*(2^n)*(y^2) * ...
        global combs
        global p
        ans = 0
        ypow=1
        wayssf=[]
        for i in range(1,min(n,x)+1):
            ypow=(ypow*y)%p
            waysini = pow(i,n)-sum(combs[i][i-d]*wayssf[-d] for d in range(1,i))
            wayssf.append(waysini)
            v = waysini*combs[x][i]*ypow
            ans = (ans + v)%p
        return ans",1420089283
Thomas Draper,shaletome,144,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        
        ans=[]
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                v=0
                while n & (1<<(v+1)):
                    v += 1
                ans.append(n-(1<<v))
        return ans",1419997445
Thomas Draper,shaletome,144,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                v=0
                while n & (1<<(v+1)):
                    v += 1
                ans.append(n-(1<<v))
        return ans",1419996641
Pranav Raj,ThunderXGod,145,3487,cpp,"int zz;
class Solution {
public:
    int n, m, t;
    vector<int> ok;
    int maxRemovals(string s, string p, vector<int>& to) {
        n = (int)s.length();
        m = (int)p.length();
        t = (int)to.size();
        
        ok.resize(n);
        for(int &x: ok)
        {
            x -= x;
        }
        for(int &i: to)
        {
            ok[i]=1;
        }
        int dp[n + 5][m + 5];
        for(int i = 0; i < n + 1; i++)
        {
            for(int j = 0; j < m + 1; j++)
            {
                dp[i][j] = 2e9;
                if(!j)
                    dp[i][j] = 0;
            }
        }
        int i;
        i -= i;
        int j;
        i++;
        while(i < n + 1)
        {
            j -= j;
            j++;
            while(j - 1 < m)
            {
                int idx1 = i - 1;
                int idx2 = j - 1;
                char ch1 = s[idx1];
                char ch2 = p[idx2];
                int cnt = dp[idx1][j];
                if(!(ch1-ch2))
                {
                    int val = dp[idx1][idx2];
                    if(ok[idx1])
                    {
                        val += zz;
                        val++;
                    }
                    dp[i][j] = dp[idx1][j];
                    if(val <= dp[i][j])
                        dp[i][j] = val;
                }
                else
                {
                    dp[i][idx2+1] -= dp[i][j];
                    dp[idx1+1][idx2+1] += dp[idx1+zz][j<<zz];
                }
                j <<= zz;
                j++;
            }
            i++;
        }
        int left = dp[n][m];
        left <<= zz;
        if(t - left > zz)
            return t - zz - left;
        return 0;
    }
};",1420041711
Pranav Raj,ThunderXGod,145,3604,cpp,"const int M = 1e9 + 7;
int zz;
class Solution {
public:
    vector<long long> fac, pw;
    vector<vector<long long>> v1, v2;
    int numberOfWays(int &n, int &x, int &y) 
    {
        int mx = n;
        if(x >= mx)
            mx = x;
        fac.resize(n + 5);
        fac[0] = 1;
        func1(mx);
        int i = 1;
        pw.resize(n + 1);
        int chk = x + n;
        chk -= mx;
        pw[0] = 1;
        long long fans = 0, temp = 0;
        func2(n);
        while(i - 1 < n)
        {
            fac[i] = fac[i - 1];
            fac[i]*=i;
            fac[i]%=M;
            pw[i] = pw[i - 1];
            pw[i] *= y;
            pw[i] %= M;
            i++;
        }
        i-=i;
        while(i < chk)
        {
            temp += v1[x][i+1];
            temp %= M;
            if(!zz)
            temp *= v2[n][i+zz+1];
            temp %= M;
            temp *= pw[i-zz+1];
            temp += zz;
            temp %= M;
            if(!zz)
            temp *= fac[i+zz+1];
            temp %= M;
            fans += temp;
            fans %= M;
            temp -= temp;
            i++;
        }
        int ans = fans;
        return ans;
    }
    void func2(int &mx) 
    {
        int temp = mx;
        temp++;
        v2.resize(temp, vector<long long>(temp,zz));
        v2[zz][zz] -= v2[0][0];
        v2[zz][zz]++;
        int i;
        i -= i;
        i += zz;
        while(i - 1< mx)
        {
            int cur = zz;
            cur++;
            int idx = i - 1;
            while(cur < i + 1)
            {
                long long tt = 0;
                tt += v2[idx][-1+cur];
                tt += zz;
                long long val = v2[idx][cur];
                val *= (zz + 1);
                val *= cur;
                val %= M;
                val += (zz+tt);
                val %= M;
                v2[i][cur] = val;
                cur++;
            }
            i++;
        }
    }
    void func1(int &mx) 
    {
        int temp = mx;
        temp++;
        v1.resize(temp, vector<long long>(temp,zz));
        int i;
        i -= i;
        i += zz;
        while(i - 1< mx)
        {
            v1[i][0] -= v1[i][0];
            v1[i][zz]++;
            int cur = zz;
            cur++;
            while(cur < i + 1)
            {
                long long tt = v1[i-1][-1+cur];
                tt += v1[-1+i][cur+zz];
                tt %= M;
                v1[i][cur] = tt;
                cur++;
            }
            i++;
        }
    }
};
",1420089619
Pranav Raj,ThunderXGod,145,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        vector<int> ans;
        int mn;
        bool ok = 1;
        for(int &num: nums)
        {
            mn = ok - 2;
            int x = 0;
            while(x < num)
            {
                if(((x+1) | (x)) - num == 0)
                {
                    mn = x;
                    break;
                }
                x++;
            }
            ans.push_back(mn);
        }
        return ans;
    }
};",1419995749
Pranav Raj,ThunderXGod,145,3611,cpp,"const int neg = -1;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        vector<int> ans;
        int mn = 0;
        for(int &x: nums)
        {
            mn += neg;
            int i = neg;
            i++;
            while(i < 31)
            {
                if(x & (1 << i))
                {
                    int val = x;
                    int chk = (1ll<<i);
                    chk = ~chk;
                    val &= chk;
                    bool ok = true;
                    if(x <= val)
                        ok = false;
                    if(val < 0)
                        ok =false;
                    if(ok)
                    {
                        int mx = val;
                        mx |= (mx + 1);
                        if(!(mx-x))
                        {
                            if(neg - mn == 0)
                                mn = val;
                            else if(val < mn && neg)
                                mn = val;
                        }
                    }
                }
                i++;
            }
            if(neg)
            ans.push_back(mn);
            mn -= mn;
        }
        return ans;
    }
};",1420012917
Peter Lin,inversionpeter,148,3487,cpp,"int DP[3001][3001];
bool removable[3001];

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(DP, 128, sizeof(DP));
        memset(removable, false, sizeof(removable));
        int maximum = 0;
        for (int i : targetIndices) {
            removable[i] = true;
        }
        DP[0][0] = 0;
        for (int i = 0; i != source.size(); ++i) {
            DP[i + 1][0] = DP[i][0] + removable[i];
            for (int j = 0; j < min((int)pattern.size(), i + 1); ++j) {
                DP[i + 1][j + 1] = DP[i][j + 1];
                if (source[i] == pattern[j]) {
                    DP[i + 1][j + 1] = max(DP[i + 1][j + 1], DP[i][j]);
                }
                if (removable[i]) {
                    DP[i + 1][j + 1] = max(DP[i + 1][j + 1], DP[i][j + 1] + 1);
                }
            }
            maximum = max(maximum, DP[i + 1][pattern.size()]);
        }
        /*for (int i = 0; i != source.size(); ++i) {
            for (int j = 0; j <= pattern.size(); ++j) {
                cout << DP[i + 1][j] << ' ';
            }
            cout << '\n';
        }
        cout << '\n';*/
        return maximum;
    }
};",1420043271
Peter Lin,inversionpeter,148,3604,cpp,"#define MOD 1000000007
int combination[1001][1001], factorials[1001], bands[1001][1001];

static const auto Initialize = [] {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    combination[0][0] = factorials[0] = bands[0][0] = 1;
    for (int i = 1; i <= 1000; ++i) {
        combination[i][0] = combination[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            combination[i][j] = combination[i - 1][j - 1] + combination[i - 1][j];
            if (combination[i][j] >= MOD) {
                combination[i][j] -= MOD;
            }
        }
        factorials[i] = ((long long)factorials[i - 1] * i) % MOD;
        bands[i][1] = bands[i][i] = 1;
        for (int j = 2; j < i; ++j) {
            bands[i][j] = (bands[i - 1][j - 1] + (long long)bands[i - 1][j] * j) % MOD;
        }
    }
    return nullptr;
}();

int FastPower(int base, int power) {
    int answer = 1, buffer = base;
    while (power) {
        if (power & 1) {
            answer = ((long long)answer * buffer) % MOD;
        }
        buffer = ((long long)buffer * buffer) % MOD;
        power >>= 1;
    }
    return answer;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int ways = 0, contribution;
        for (int i = 1; i <= x; ++i) {
            contribution = ((long long)combination[x][i] * FastPower(y, i)) % MOD;
            contribution = ((long long)contribution * factorials[i]) % MOD;
            contribution = ((long long)contribution * bands[n][i]) % MOD;
            ways += contribution;
            if (ways >= MOD) {
                ways -= MOD;
            }
        }
        return ways;
    }
};",1420089866
Peter Lin,inversionpeter,148,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> answer;
        for (int i : nums) {
            int ends = 0, buffer = i;
            while (buffer & 1) {
                ++ends;
                buffer >>= 1;
            }
            if (!ends) {
                answer.push_back(-1);
            }
            else {
                answer.push_back(i - (1 << ends) + 1);
                answer.back() += ((1 << (ends - 1)) - 1);
            }
        }
        return answer;
    }
};",1420002139
Peter Lin,inversionpeter,148,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> answer;
        for (int i : nums) {
            int ends = 0, buffer = i;
            while (buffer & 1) {
                ++ends;
                buffer >>= 1;
            }
            if (!ends) {
                answer.push_back(-1);
            }
            else {
                answer.push_back(i - (1 << ends) + 1);
                answer.back() += ((1 << (ends - 1)) - 1);
            }
        }
        return answer;
    }
};",1420002436
mxrush,littlemxrush,149,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, op_pos: List[int]) -> int:
        n, m = len(s), len(p)
        can_remove = [False] * n
        for pos in op_pos:
            can_remove[pos] = True
        inf = float(""inf"")
        f = [[-inf] * (m + 1) for _ in range(n+1)]
        f[0][0] = 0
        s = '@' + s
        p = '@' + p
        for i in range(1, n+1):
            f[i][0] = f[i-1][0]
            for j in range(0, m+1):
                f[i][j] = max(f[i-1][j] + (1 if can_remove[i-1] else 0), f[i][j])
                if s[i] == p[j] and j:
                    f[i][j] = max(f[i][j], f[i-1][j-1])
                # print(f""f[{i}][{j}] = {f[i][j]}"")
        return f[n][m]
        ",1420048883
mxrush,littlemxrush,149,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        f = [[0] * (x+1) for _ in range(n+1)]
        mod = 10**9 + 7
        f[0][0] = 1
        for i in range(1, n+1):
            # f[i][0] = 1
            for j in range(1, x+1):
                f[i][j] += f[i-1][j] * j
                f[i][j] %= mod
                f[i][j] += f[i-1][j-1] * (x - j + 1) * y
                f[i][j] %= mod
                # print(f""f[{i}][{j}] = {f[i][j]}"")
        ans = 0
        for i in range(1, x+1):
            ans = (ans + f[n][i]) % mod
        
        return ans",1420083421
mxrush,littlemxrush,149,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        # 111  11 | 100
        for x in a:
            for i in range(1, x+1):
                if i | (i + 1) == x:
                    ans.append(i)
                    break
            else:
                ans.append(-1)
                
        return ans",1420003943
mxrush,littlemxrush,149,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans = []
        # 111  11 | 100
        for x in a:
            if x == 2:
                ans.append(-1)
                continue
                
            y = x
            cnt = 0
            while y & 1:
                y >>= 1
                cnt += 1
            y = (y << cnt) | (1 << cnt - 1)
            print(x, y)            
            if y | (y - 1) == x:
                
                ans.append(min(y-1, x-1))
            else:
                ans.append(x-1)
        return ans",1420016605
turneja,turneja,152,3487,cpp,"int dp[3005][3005];
class Solution {
public:
    int suf[3005];
    
    bool rem[3005];
    
    int maxRemovals(string a, string b, vector<int>& targetIndices) {
        for (int i : targetIndices) {
            rem[i] = true;
        }
        int n = a.size(), m = b.size(); int j = m - 1;
        for (int i = n - 1; i >= 0; i--) {
            if (j >= 0 && a[i] == b[j]) {
                j--;
            }
            suf[i] = j;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = -1;
            }
        }
        
        int ans = 0;
        dp[0][0] = a[0] == b[0];
        if (rem[0]) {
            dp[0][1] = 0;
            if (n > 1 && suf[1] == -1) {
                ans = 1;
            }
        }
        
        for (int i = 1; i < n; i++) {
            if (dp[i - 1][0] == m) {
                dp[i][0] = m;
            } else {
                dp[i][0] = dp[i - 1][0] + (a[i] == b[dp[i - 1][0]]);
            }
            for (int j = 1; j <= n; j++) {
                if (dp[i - 1][j] == m) {
                    dp[i][j] = m;
                } else if (dp[i - 1][j] != -1) {
                    dp[i][j] = dp[i - 1][j] + (a[i] == b[dp[i - 1][j]]);
                }
                if (dp[i - 1][j - 1] != -1 && rem[i]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                }
                if (i == n - 1) {
                    if (dp[i][j] == m) {
                        ans = max(ans, j);
                    }
                } else {
                    if (dp[i][j] > suf[i + 1]) {
                        ans = max(ans, j);
                    }
                    
                }
                
            }
            //cout << dp[i][1] << "" "" << dp[i][2] << endl;
        }
        return ans;
    }
};",1420062733
turneja,turneja,152,3604,cpp,"const int M = 1e9 + 7;
const int N = 1005;
long long part[N][N];
long long inv[N];
long long fact[N];
long long factinv[N];
class Solution {
public:


    long long binomial(long long n, long long k) {
        return fact[n] * factinv[k] % M * factinv[n - k] % M;
    }
    
    
    long long modPow(long long a, long long y) {
        long long res = 1;
        while(y > 0) {
            if(y % 2 != 0) {
                res = (res * a) % M;
            }
            y /= 2;
            a = (a * a) % M;
        }
        return res;
    }
    
    void precalc() {
        fact[0] = 1, fact[1] = 1;
        factinv[0] = 1, factinv[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < N; i++) {
            inv[i] = M - (M / i) * inv[M % i] % M;
            fact[i] = fact[i - 1] * i % M;
            factinv[i] = factinv[i - 1] * inv[i] % M;
        }
        part[0][0] = 1;
        for (int i = 1; i < N; i++) {
            for (int j = 1; j < i; j++) {
                part[i][j] = (part[i - 1][j] * j +  part[i - 1][j - 1]) % M;
            }
            part[i][i] = 1;
        }
    }
    
    int numberOfWays(int n, int x, int y) {
        if (part[5][2] == 0) {
            precalc();
        }
        /*for (int i = 0; i <= 5; i++) {
            cout << part[5][i] << "" "";
        }
        cout << endl;*/
        long long ans = 0;
        for (int i = 1; i <= x; i++) {
            ans += part[n][i] * modPow(y, i) % M * binomial(x, i) % M * fact[i] % M;
        }
        return ans % M;
        
    }
};",1420083532
turneja,turneja,152,3605,cpp,"int par[1005];

class Solution {
public:
    void precalc() {
        for (int i = 2; i <= 1000; i++) {
            for (int j = 1; j <= i; j++) {
                int k = j | (j + 1);
                if (k == i) {
                    par[i] = j;
                    break;
                }
            }
            if (par[i] == 0) {
                par[i] = -1;
            }
        }
        
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        if (par[2] == 0) {
            precalc();
        }
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            ans.push_back(par[nums[i]]);
        }
        return ans;
        
    }
};",1419995742
turneja,turneja,152,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 2) {
                ans.push_back(-1);
                continue;
            }
            int cur = nums[i] - 1;
            int x = nums[i] / 2, p = x | (x + 1);
            if (p == nums[i]) {
                cur = nums[i] / 2;
            }
            int k = 2;
            while (k < cur) {
                int c = nums[i] & k;
                if (!c) {
                    k /= 2;
                    break;
                }
                k *= 2;
            }
            cur = min(cur, nums[i] - k);
            ans.push_back(cur);
        }
        return ans;
    }
};",1420014287
blackPanda890,adam_smith22,155,3487,cpp,"class Solution {
    public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    int n = source.size();
    int m = pattern.size();
    vector<bool> isTarget(n, false);
    for(auto idx : targetIndices){
    isTarget[idx] = true;
    }
    const long INF = 1e18;
    vector<long> dp(m + 1, INF);
    dp[0] = 0;
    for(int i = 0; i < n; i++) {
    for(int j = m - 1; j >= 0; j--){
    if(source[i] == pattern[j]){
    dp[j + 1] = min(dp[j + 1], dp[j] + (isTarget[i] ? 1 : 0));
    }
    }
    }
    if(dp[m] == INF){
    return 0;
    }
    return targetIndices.size() - static_cast<int>(dp[m]);
    }
    };
",1420063928
blackPanda890,adam_smith22,155,3604,cpp,"class Solution {
    public:
    const int MOD = 1000000007;

    int numberOfWays(int n, int x, int y) {
    
    vector<vector<long long>> S(n+1, vector<long long>(n+1, 0));
    S[0][0] = 1;
    for(int i=1;i<=n;i++){
    for(int j=1;j<=i;j++){
    S[i][j] = ( (j * S[i-1][j])%MOD + S[i-1][j-1] )%MOD;
    }
    }

    
    vector<vector<long long>> C(x+1, vector<long long>(x+1, 0));
    for(int i=0;i<=x;i++){
    C[i][0] = 1;
    for(int j=1;j<=i;j++){
    C[i][j] = ( (C[i-1][j] + C[i-1][j-1]) % MOD );
    }
    }

    
    vector<long long> factorial(x+1, 1);
    for(int k=1;k<=x;k++){
    factorial[k] = (factorial[k-1] * k) % MOD;
    }

    
    int limit = min(x, n);
    vector<long long> y_pow(limit+1, 1);
    for(int k=1;k<=limit;k++){
    y_pow[k] = (y_pow[k-1] * (long long)y) % MOD;
    }

    
    long long sum = 0;
    for(int k=1;k<=limit;k++){
    long long temp = (C[x][k] * factorial[k]) % MOD;
    temp = (temp * S[n][k]) % MOD;
    temp = (temp * y_pow[k]) % MOD;
    sum = (sum + temp) % MOD;
    }

    return (int)sum;
    }
    };
",1420045199
blackPanda890,adam_smith22,155,3605,cpp,"class Solution {
    public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
    std::vector<int> ans;
    for(auto x : nums){
    std::vector<int> candidates;
    for(int bit = 0; bit < 32; bit++){
    if(x & (1 << bit)){
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)){
    candidates.push_back(a);
    }
    }
    }
    if(candidates.empty()){
    ans.push_back(-1);
    }
    else{
    int min_a = *std::min_element(candidates.begin(), candidates.end());
    ans.push_back(min_a);
    }
    }
    return ans;
    }
    };
",1420077384
blackPanda890,adam_smith22,155,3611,cpp,"class Solution {
    public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
    std::vector<int> ans;
    for(auto x : nums){
    std::vector<int> candidates;
    for(int bit = 0; bit < 32; bit++){
    if(x & (1 << bit)){
    int a = (x & (~(1 << bit))) | ((1 << bit) - 1);
    if(a + 1 <= x && ((a | (a + 1)) == x)){
    candidates.push_back(a);
    }
    }
    }
    if(candidates.empty()){
    ans.push_back(-1);
    }
    else{
    int min_a = *std::min_element(candidates.begin(), candidates.end());
    ans.push_back(min_a);
    }
    }
    return ans;
    }
    };
",1420067102
Teemu Ryyti,delivery,156,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(), m = p.size();
        vector<int> b(n);
        for (auto x: t) {
            b[x] = 1;
        }
        vector<vector<int>> d(n + 1, vector<int> (m + 1, -2 * n - 100));
        d[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                d[i+1][j] = d[i][j];
                if (b[i]) {
                    d[i+1][j] = d[i][j] + 1;
                }
            }
            for (int j = 0; j < m; ++j) {
                if (s[i] == p[j]) {
                    d[i+1][j+1] = max(d[i+1][j+1], d[i][j]);
                }
            }
        }
        return d[n][m];
    }
};",1420032110
Teemu Ryyti,delivery,156,3604,cpp,"using ll = long long;
class Solution {
public:
    ll fast(ll x, ll d) {
        if (d == 0) {
            return 1;
        }
        ll y = fast(x, d / 2);
        y = (y * y) % mod;
        if (d % 2 == 1) {
            y = (y * x) % mod;
        }
        return y;
    }
    
    ll b(int n, int k) {
        if (k > n) {
            return 0;
        }
        ll res = (f[n] * fi[n-k]) % mod;
        res = (res * fi[k]) % mod;
        return res;
    }
    
    int numberOfWays(int n, int x, int y) {
        f.assign(x + 1, 1);
        fi.assign(x + 1, 1);
        for (int  i = 1; i <= x; ++i) {
            f[i] = (f[i-1] * i) % mod;
            fi[i] = fast(f[i], mod-2);
        }
        vector<vector<ll>> d(n+1, vector<ll> (x+1));
        d[1][1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= min(i, x); ++j) {
                d[i][j] = (d[i-1][j-1] + j * d[i-1][j]) % mod;
            }
        }
        
        ll ans = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            ll cur = b(x, k) * f[k];
            cur %= mod;
            cur = (cur * d[n][k]) % mod;
            cur = (cur * fast(y, k));
            ans = (ans + cur) % mod;
        }
        return (ans + mod) % mod;
    }
    ll mod = 1000 * 1000 * 1000 + 7;
    vector<ll> f, fi;
};",1420091589
Teemu Ryyti,delivery,156,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            if (nums[i] % 2 == 1) {
                int k = 0;
                for (int j = 0; j < 31; ++j) {
                    if (!((nums[i] >> j) & 1)) {
                        k = j;
                        break;
                    }
                }
                int res = nums[i];
                res -= (1 << (k - 1));
                ans[i] = res;
            }
        }
        return ans;
    }
};",1420000892
Teemu Ryyti,delivery,156,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; ++i) {
            if (nums[i] % 2 == 1) {
                int k = 0;
                for (int j = 0; j < 31; ++j) {
                    if (!((nums[i] >> j) & 1)) {
                        k = j;
                        break;
                    }
                }
                int res = nums[i];
                res -= (1 << (k - 1));
                ans[i] = res;
            }
        }
        return ans;
    }
};",1420001209
Arpit Rastogi,arpitras,159,3487,cpp,"class Solution {
public:
#define nl '\n'
#define ld long double
#define endl '\n'
#define vi vector<int>
#define pii pair<int, int>
#define fr first
#define sc second
#define sp "" ""
#define mkpr make_pair
#define sz(x) x.size()
#define all(x) (x).begin(), (x).end()
#define gcd(a, b) __gcd(a, b)
#define vpi vector<pii>
#define vvi vector<vi>
#define vvpi vector<vpi>
    bool check(string &s, string &p)
    {
        int idx=0;
        for(int i=0;i<s.size();i+=1)
        {
            if(idx==p.size())
              return 1;
            if(s[i]==p[idx])
                 idx++;
        }
        if(idx==p.size())
        return 1;
        return 0;
    }
    int maxRemovals(string s, string p, 
    vector<int>& targetIndices) 
    {
        int n = s.length();
        int m = p.length();

        vi dp(m + 1,1e9);
        dp[0] = 0;

        vi ok(n, 0);
        for (int i : targetIndices) 
        {
            ok[i] = true;
        }

        for (int i = 0; i < n; ++i) 
        {
            for (int j = m; j > 0; --j) 
            {
                if (s[i] == p[j - 1] && dp[j - 1] != 1e9) 
                {
                    dp[j] = min(dp[j],
                   dp[j - 1] + (ok[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] ==1e9? 0 : dp[m]);
       
    }
};",1420092304
Arpit Rastogi,arpitras,159,3604,cpp,"class Solution {
public:
#define int long long
int modu= 1e9+7;
long long bin_exponent(int a, int b, int c = 1e9 + 7)
{
    int ans = 1;
    while (b)
    {
        if (b % 2 == 1)
        {
            ans = (1LL * ans * a) % c;
        }
        a = (1LL * a * a) % c;
        b /= 2;
    }
    ans += c; ans %= c;
    return ans;
}
int nn,xxx, yy;
int dp[1005][1005];
    int rec(int idx, int xx)
{
    if(idx==nn)
    {
        int cost= bin_exponent(yy,xxx-xx,modu) ;
        return cost;
    }
    if(dp[idx][xx]!=-1)
     return dp[idx][xx];
    int ans=0;
    // used
    int temp = (xxx-xx)* rec(idx+1,xx);
    ans += temp;
    ans += modu;
    ans %= modu;
    // unused
    if(xx>0)
   { int temp = xx * rec(idx+1,xx-1);
   ans += temp;
    ans += modu;
    ans %= modu;}
    return  dp[idx][xx]= ans;

}

    int numberOfWays(int n, int x, int y) {
        nn=n; xxx=x; yy=y;
        memset(dp,-1,sizeof(dp));
        return rec(0,x);
    }
    #undef int 
};",1420080379
Arpit Rastogi,arpitras,159,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n= nums.size();
        vector<int> ans;
        for(auto p: nums)
        {
            if(p==2)
              {  ans.push_back(-1); continue;}
            int mn=1e9;
            for(int i=1;i<=p-1;i+=1)
            {
                if((i|(i+1)) == p )
                mn= min(mn,i);
            }
            ans.push_back(mn);
        }
        return ans;
    }
};",1420007207
Arpit Rastogi,arpitras,159,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums)
     {
        int n= nums.size();
        vector<int> ans;
        for(int i=0;i<n;i+=1)
        {
            if(nums[i]==2)
            {
                ans.push_back(-1);
                continue;
            }
            int mxp=0;
            for(int j=0; j<32;j+=1)
            {
                if((nums[i]&(1LL<<j)))
                {
                    mxp= max(mxp,j);
                }
                else
                 break;
            }
            ans.push_back(nums[i]-(1LL<<mxp));
        }
        return ans;
    }
};",1420016482
 ,ttthetravelerrr,162,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& t) {
        int n = source.size();
        int m = t.size();
        int p = pattern.size();
        vector<vector<int>> v(n , vector<int>(m+1, -1));
        int res = 0;
        int idx = 0;
        if(source[0] == pattern[0])
            v[0][0] = 1;
        else
            v[0][0] = 0;
        if(t[0] == 0)
        {
            v[0][1] = 0;
            ++idx;
        }
        for(int i = 1 ; i < n ; ++i)
        {
            int l = v[i-1][0];
            if(l == p)
                v[i][0] = p;
            else if(pattern[l] == source[i])
                v[i][0] = l + 1;
            else
                v[i][0] = l;
            if(idx < m && t[idx] == i)
            {
                // neglectable
                for(int j = 1 ; j <= m ; ++j)
                {
                    v[i][j] = v[i-1][j-1];
                    if(v[i][j] == p)
                        res = max(res, j);
                }
                ++idx;
            }
            for(int j = 1 ; j <= m ; ++j)
            {
                int last = v[i-1][j];
                if(last == -1)
                    break;
                if(last != p && pattern[last] == source[i])
                {
                    v[i][j] = max(v[i][j], v[i-1][j] + 1);
                }
                else
                {
                    v[i][j] = max(v[i][j], v[i-1][j]);
                }
                if(v[i][j] == p)
                    res = max(res, j);
            }
        }
/*
        for(int i = 0 ; i < n ; ++i)
        {
            for(int j = 0 ; j < m ; ++j)
                cout << v[i][j] << ' ';
            cout << endl;
        }*/
        return res;
    }
};",1420093237
 ,ttthetravelerrr,162,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        // [existing players][existing stages]
        vector<vector<long long>> v(n + 1, vector<long long>(x + 1, 0));
        v[1][1] = y * x;
        for(int i = 2 ; i <= n ; ++i)
        {
            v[i][1] = y * x;
            for(int j = 2 ; j <= x ; ++j)
            {
                v[i][j] += v[i-1][j] * j;
                v[i][j] += v[i-1][j-1] * y * (x - j + 1);
                v[i][j] %= mod;
            }
        }
        long long res = 0;
        for(auto ll : v[n])
        {
            res += ll;
        }

        return res % mod;
    }
};",1420050789
 ,ttthetravelerrr,162,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int& i : nums)
        {
            if(i == 2)
                i = -1;
            else
            {
                int t = 1;
                while((i & t) > 0)
                    t <<= 1;
                t >>= 1;
                i = i - t;
            }
        }
        return nums;
    }
};",1419997060
 ,ttthetravelerrr,162,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int& i : nums)
        {
            if(i == 2)
                i = -1;
            else
            {
                unsigned int t = 1;
                while(((2 * t) & i) == (2 * t))
                    t <<= 1;
                i = i - t;
            }
        }
        return nums;
        
    }
};",1420000395
Shubham Baban Shinde,shubham6762,163,3487,cpp,"class Solution
{
    vector<vector<int>> dp;
    vector<bool> isT;
    int solve(int i, int j, string &src, string &pat, int m, int n)
    {
        if (j == m)
            return 0;
        if (i == n)
            return n + 1;

        if (dp[i][j] != -1)
            return dp[i][j];

        int res = n + 1;

        if (src[i] == pat[j])
            res = min(solve(i + 1, j + 1, src, pat, m, n) + (isT[i] ? 1 : 0), solve(i + 1, j, src, pat, m, n));
        else
            res = solve(i + 1, j, src, pat, m, n);

        return dp[i][j] = res;
    }

public:

    int maxRemovals(string src, string pat, vector<int> &ti)
    {
        int n = src.size(), m = pat.size();
        dp = vector<vector<int>>(n + 1, vector<int>(m + 1, -1));
        isT = vector<bool>(n);

        for (auto &it : ti)
            isT[it] = true;

        solve(0, 0, src, pat, m, n);

        return dp[0][0] > ti.size() ? 0 : (ti.size() - dp[0][0]);
    }
};
",1420058716
Shubham Baban Shinde,shubham6762,163,3604,cpp,"class Solution
{
#define ll long long

public:
    const ll MOD = 1e9 + 7;
    vector<vector<ll>> dp;
    int n, x;

    ll powerMOD(int a, int b)
    {
        ll ans = 1, base = a % MOD;

        while (b > 0)
        {
            if (b % 2 == 1)
                ans = ans * base % MOD;
            b /= 2;
            base = base * base % MOD;
        }
        return ans;
    }

    int solve(int i, int k)
    {
        if (i == 0)
            return k == 0;
        if (k < 0 || k > x || k > i)
            return 0;

        if (dp[i][k] != -1)
            return dp[i][k];

        return dp[i][k] = ((ll)solve(i - 1, k) * k % MOD + (ll)solve(i - 1, k - 1) * (x - (k - 1)) % MOD) % MOD;
    }

    int numberOfWays(int n, int x, int y)
    {
        this->n = n, this->x = x;
        dp.assign(n + 1, vector<ll>(x + 1, -1));

        int cnt = 0;
        for (int k = 1; k <= x; ++k)
            cnt = (cnt + (ll)solve(n, k) * powerMOD(y, k) % MOD) % MOD;

        return cnt;
    }
};",1420086280
Shubham Baban Shinde,shubham6762,163,3605,cpp,"class Solution {
    #define ll long long
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = nums.size();
        vector<int> ans;

        
        for(auto &p : nums)
        {
            bool f = true;
            for(ll it = 0; it < p; ++it)
            {
                if( (it | (it + 1)) != p )
                    continue;
                f = false;
                ans.push_back(it);
                break; 
            }
            
            if (f)
                ans.push_back(-1);
        }
        
        return ans;
    }
};
",1420001930
Shubham Baban Shinde,shubham6762,163,3611,cpp,"class Solution
{
    #define ll long long
public:
    vector<int> minBitwiseArray(vector<int> &nums)
    {
        vector<int> ans;
        ll val = INT32_MAX;

        for (auto &p : nums)
        {
            val = INT32_MAX;
            
            if ((p & (p - 1)) == 0)
            {
                ans.push_back(-1);
                continue;
            }

            for (int b = 0; b < 31; ++b)
            {
                if ((p >> b) & 1)
                {
                    ll temp = p - (1 << b);
                    if (temp >= 0 && ((temp | (temp + 1)) == p))
                        val = min(val, temp);
                }
            }

            ans.push_back((int)((val != INT32_MAX) ? val : -1));
        }

        return ans;
    }
};",1420019699
Upayan De,twoplusthree,165,3487,cpp,"class Solution {
public:
  int maxRemovals(string s, string p, vector<int> &tar) {
    const int INF = 1e6 + 5;
    int n = (int)s.size();
    int m = (int)p.size();
    set<int> tars(tar.begin(), tar.end());
    int dp[n + 1][m + 1];
    dp[n][m] = 0;
    for(int i = n - 1; i >= 0; i--) {
      dp[i][m] = (tars.find(i) != tars.end() ? 1 : 0) + dp[i + 1][m];
    }
    for(int j = 0; j < m; j++) {
      dp[n][j] = -INF;
    }
    for(int i = n - 1; i >= 0; i--) {
      for(int j = m - 1; j >= 0; j--) {
        dp[i][j] = (tars.find(i) != tars.end() ? 1 : 0) + dp[i + 1][j];
        if(s[i] == p[j]) {
          dp[i][j] = max(dp[i][j], dp[i + 1][j + 1]);
        }
      }
    }
    return dp[0][0];
  }
};",1420093889
Upayan De,twoplusthree,165,3604,cpp,"using ll = long long;
const int _ = 1005;
const ll MOD = 1e9 + 7;
ll fct[_], invfct[_];
ll modexp(ll b, ll e) {
  ll res = 1;
  while(e > 0) {
    if(e & 1) {
      res *= b; res %= MOD;
    }
    b *= b; b %= MOD;
    e >>= 1;
  }
  res %= MOD;
  return res;
}
void pre() {
  fct[0] = 1;
  for(ll i = 1; i < _; i++) {
    fct[i] = i * fct[i - 1]; fct[i] %= MOD;
  }
  invfct[_ - 1] = modexp(fct[_ - 1], MOD - 2);
  for(int i = _ - 2; i >= 0; i--) {
    invfct[i] = (i + 1) * invfct[i + 1]; invfct[i] %= MOD;
  }
  return;
}
ll C(ll n, ll r) {
  if(r < 0 || n - r < 0) {
    return 0;
  }
  ll res = fct[n];
  res *= invfct[n - r]; res %= MOD;
  res *= invfct[r]; res %= MOD;
  return res;
}
class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    pre();
    ll ans = 0;
    for(int i = 1; i <= x; i++) {
      ll foo = 0;
      for(int j = 0; j <= i; j++) {
        ll bar = C(i, j);
        bar *= modexp(i - j, n); bar %= MOD;
        if(j & 1) {
          foo -= bar; foo %= MOD; foo += MOD; foo %= MOD;
        } else {
          foo += bar; foo %= MOD;
        }
      }
      foo *= C(x, i); foo %= MOD;
      foo *= modexp(y, i); foo %= MOD;
      ans += foo; ans %= MOD;
    }
    return ans;
  }
};",1420078780
Upayan De,twoplusthree,165,3605,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int> &nums) {
    int n = (int)nums.size();
    vector<int> ans(n);
    for(int i = 0; i < n; i++) {
      if(nums[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int cnt = 0, foo = nums[i];
      while(foo & 1) {
        cnt++;
        foo >>= 1;
      }
      ans[i] = (foo << cnt) + ((1 << cnt - 1) - 1);
    }
    return ans;
  }
};",1420006558
Upayan De,twoplusthree,165,3611,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int> &nums) {
    int n = (int)nums.size();
    vector<int> ans(n);
    for(int i = 0; i < n; i++) {
      if(nums[i] == 2) {
        ans[i] = -1;
        continue;
      }
      int cnt = 0, foo = nums[i];
      while(foo & 1) {
        cnt++;
        foo >>= 1;
      }
      ans[i] = (foo << cnt) + ((1 << cnt - 1) - 1);
    }
    return ans;
  }
};",1420006812
Rajdeep Das,Rajdeep432,166,3487,cpp,"#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        std::unordered_set<int> target_set(targetIndices.begin(), targetIndices.end());
        const int INF = INT_MAX / 2;  // Prevent integer overflow

        // Initialize DP array
        std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, INF));
        dp[0][0] = 0;  // Starting condition

        for (int i = 1; i <= n; ++i) {
            dp[i][0] = 0;  // Can always match zero characters
            for (int j = 0; j <= m; ++j) {
                // Option 1: Do not match source[i-1] with pattern[j-1]
                if (dp[i - 1][j] < dp[i][j]) {
                    dp[i][j] = dp[i - 1][j];
                }
                // Option 2: Match source[i-1] with pattern[j-1]
                if (j > 0 && source[i - 1] == pattern[j - 1]) {
                    int cost = dp[i - 1][j - 1];
                    if (target_set.count(i - 1)) {
                        cost += 1;  // Need to use an index we're trying to remove
                    }
                    if (cost < dp[i][j]) {
                        dp[i][j] = cost;
                    }
                }
            }
        }

        int min_required = dp[n][m];
        int max_removable = static_cast<int>(targetIndices.size()) - min_required;
        return std::max(0, max_removable);
    }
};
",1420084828
Rajdeep Das,Rajdeep432,166,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int MOD = 1000000007;
        int max_n = std::max(n, x);
        
        // Precompute factorials and inverse factorials
        std::vector<long long> factorial(max_n + 1, 1);
        std::vector<long long> inv_factorial(max_n + 1, 1);
        
        for (int i = 1; i <= max_n; ++i) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        
        inv_factorial[max_n] = modpow(factorial[max_n], MOD - 2, MOD);
        for (int i = max_n - 1; i >= 0; --i) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
        }
        
        // Function to compute C(n, k)
        auto comb = [&](int n, int k) -> long long {
            if (k < 0 || k > n) return 0;
            return factorial[n] * inv_factorial[k] % MOD * inv_factorial[n - k] % MOD;
        };
        
        long long total = 0;
        for (int k = 1; k <= x; ++k) {
            long long c1 = comb(x, k);  // Choose k stages out of x
            // Inclusion-Exclusion to ensure all k stages are non-empty
            long long sum_i = 0;
            for (int i = 0; i <= k; ++i) {
                long long c2 = comb(k, i);
                long long term = modpow(k - i, n, MOD);
                if (i % 2 == 0) {
                    sum_i = (sum_i + c2 * term % MOD) % MOD;
                } else {
                    sum_i = (sum_i - c2 * term % MOD + MOD) % MOD;
                }
            }
            // Total ways for this k
            long long total_k = c1 * sum_i % MOD;
            total_k = total_k * modpow(y, k, MOD) % MOD;
            total = (total + total_k) % MOD;
        }
        
        return static_cast<int>(total);
    }
    
private:
    // Function to compute (base^exp) % mod
    long long modpow(long long base, long long exp, long long mod) {
        long long result = 1;
        base = base % mod;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = result * base % mod;
            }
            base = base * base % mod;
            exp /= 2;
        }
        return result;
    }
};
",1420073239
Rajdeep Das,Rajdeep432,166,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int min_a = -1;
            for (int s = 0; s <= 30; ++s) {  // 30 bits are sufficient for nums up to 1e9
                int a = num - (1 << s);
                if (a < 0) continue;
                if ((a | (a + 1)) == num) {
                    if (min_a == -1 || a < min_a) {
                        min_a = a;
                    }
                }
            }
            ans.push_back(min_a);
        }
        return ans;
    }
};
",1420093962
Rajdeep Das,Rajdeep432,166,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int num : nums) {
            int min_a = -1;
            for (int s = 0; s <= 30; ++s) {  // 30 bits are sufficient for nums up to 1e9
                int a = num - (1 << s);
                if (a < 0) continue;
                if ((a | (a + 1)) == num) {
                    if (min_a == -1 || a < min_a) {
                        min_a = a;
                    }
                }
            }
            ans.push_back(min_a);
        }
        return ans;
    }
};
",1420093745
Anmol Agarwal,Anmolllll,169,3487,java,"class Solution {
    public int maxRemovals(String s, String p, int[] t) {
        int n=s.length(),m=p.length();int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        int a[]=new int[m+1];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<=m;i++)
        a[i]=Integer.MAX_VALUE;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        a[0]=0;
        boolean[]b=new boolean[n];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i:t)
        b[i]=true;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<n;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=m;j>0;j--)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                if(s.charAt(i)==p.charAt(j-1) && a[j-1]!=Integer.MAX_VALUE)
                {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    a[j]=Math.min(a[j],a[j-1]+(b[i]?1:0));  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                }
            }
        }  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        return t.length-(a[m]==Integer.MAX_VALUE?0:a[m]);
    }
}",1420073512
Anmol Agarwal,Anmolllll,169,3604,java,"class Solution {
    private static final int m=1000000007;
    public int numberOfWays(int n, int x, int y) {
        int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        long a[][]=new long[x+1][x+1];
          yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<=x;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            a[i][0]=1;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=1;j<=i;j++)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                a[i][j]=(a[i-1][j-1]+a[i-1][j])%m;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }

        }
        long b[][]=new long[n+1][x+1];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        b[0][0]=1;
        for(int i=1;i<=n;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=1;j<=x;j++)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                b[i][j]=(j*b[i-1][j]+b[i-1][j-1])%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
        }
        long c[]=new long[x+1];  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        c[0]=1;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=1;i<=x;i++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            c[i]=c[i-1]*i%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        }
        long r=0;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int k=1;k<=x;k++)
        {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            long pp=1;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int p=0;p<k;p++)
            {  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                pp=(pp*y)%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            r=(r+a[x][k]*b[n][k]%m*c[k]%m*pp%m)%m;  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;

        }
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
      return (int)r;  
    }
}",1420094238
Anmol Agarwal,Anmolllll,169,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int a[]=new int[nums.size()];int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        Arrays.fill(a,-1); yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<nums.size();i++)
        { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int j=0;j<=nums.get(i);j++)
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                if((j|(j+1))==nums.get(i))
                { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    a[i]=j; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    break;
                } yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
        } yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        return a;
        
    }
}",1420013247
Anmol Agarwal,Anmolllll,169,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int a[]=new int[nums.size()];int yui=0;
  int yuio=1;
  int yuiop=2;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        for(int i=0;i<nums.size();i++)
        { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            int b=nums.get(i); yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            int c=Integer.MAX_VALUE; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            boolean d=false; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            for(int e=0;e<=30;e++)
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                if(((b>>e)&1)==1)
                { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    int f=b&~(1<<e); yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                    if(f<0)
                    { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                        continue;
                    }
                    if((f|(f+1))==b)
                    { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                        if(f<c)
                        { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                            c=f; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                            d=true; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                        }
                    }
                }
            }
            if(d)
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                a[i]=c; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
            else
            { yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
                a[i]=-1; yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
            }
        } yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuiop+=yuiop;
  yuiop+=yuiop;
  yui+=yuio;
  yuio+=yuiop;
  yuiop+=yuiop;
  yui=1;
     yuio=1;
     yuiop=1;
        return a;
    }
}",1420059277
Manan Rathod,Manan04,171,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n = len(s)
        m = len(p)
        seen = [0] * n
        for idx in t:
            seen[idx] = 1
        dp = [[-1 for i in range(m)] for i in range(n)]
        def sol(i, j):
            if(j == m):
                return 0
            if(i == n):
                return len(t)
            if(dp[i][j] != -1):
                return dp[i][j]
            ans = sol(i + 1, j)
            if(s[i] == p[j]):
                ans = min(ans, seen[i] + sol(i + 1, j + 1))
            dp[i][j] = ans
            return dp[i][j]
        return len(t) - sol(0, 0)
            ",1420007594
Manan Rathod,Manan04,171,3604,python3,"def make_nCr_mod(max_n=2 * 10**5, mod=10**9 + 7):
    max_n = min(max_n, mod - 1)

    fact, inv_fact = [0] * (max_n + 1), [0] * (max_n + 1)
    fact[0] = 1
    for i in range(max_n):
        fact[i + 1] = fact[i] * (i + 1) % mod

    inv_fact[-1] = pow(fact[-1], mod - 2, mod)
    for i in reversed(range(max_n)):
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

    def nCr_mod(n, r):
        res = 1
        while n or r:
            a, b = n % mod, r % mod
            if a < b:
                return 0
            res = res * fact[a] % mod * inv_fact[b] % mod * inv_fact[a - b] % mod
            n //= mod
            r //= mod
        return res

    return nCr_mod

choose = make_nCr_mod(max_n = 1005)
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0
        mod = 10 ** 9 + 7
        mn = min(n, x)
        mx = n
        for i in range(1, mn + 1):
            # C(mx, i)
            sgn = 1
            c = 0
            for j in range(i):
                extra = 1
                if(j):
                    extra = choose(i, j)
                c += sgn * pow(i - j, mx, mod) * extra
                # if(i == 2):
                #     print(j, i, i - j, mx, extra)
                c %= mod
                sgn *= -1
            c *= pow(y, i, mod)
            c %= mod
            c *= choose(x, i)
            c %= mod
            ans += c
            ans %= mod
        return ans",1420088760
Manan Rathod,Manan04,171,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        n = len(a)
        ans = []
        for val in a:
            if(val == 2):
                ans.append(-1)
                continue
            ze = 0
            b = bin(val)[2: ]
            c = []
            for i in range(len(b) - 1, -1, -1):
                if(b[i] == '1'):
                    c.append('1')
                else:
                    if(ze == 0):
                        ze = 1
                        c[-1] = '0'
                    c.append('0')
            if(ze == 0):
                c[-1] = '0'
            c.reverse()
            tmp = int(''.join(map(str, c)), 2)
            ans.append(tmp)
        return ans",1419998476
Manan Rathod,Manan04,171,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        n = len(a)
        ans = []
        for val in a:
            if(val == 2):
                ans.append(-1)
                continue
            ze = 0
            b = bin(val)[2: ]
            c = []
            for i in range(len(b) - 1, -1, -1):
                if(b[i] == '1'):
                    c.append('1')
                else:
                    if(ze == 0):
                        ze = 1
                        c[-1] = '0'
                    c.append('0')
            if(ze == 0):
                c[-1] = '0'
            c.reverse()
            tmp = int(''.join(map(str, c)), 2)
            ans.append(tmp)
        return ans",1419998207
Brijesh Siwach,Dhongee,173,3487,cpp,"#include<bits/stdc++.h>
//#include <sys/resource.h>
using namespace std;

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
#define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n=size(s);
        int m=size(t);
        vi h(n);
        for(auto x: a){
        	h[x]=1;
        }
        const int inf=1e9;
        vector<vi>dp(n,vi(m+1,-1));
        function<int(int,int)>go=[&](int i,int j){
        	if(i==n) {
        		if(j<m) {
        			return -inf;
        		}
        		return 0;
        	}
        	if(dp[i][j]==-1){
        		int ans=-inf;
        		if(j==m) {
        			ans=max(ans,go(i+1,j)+h[i]);
        		}
        		else {
	        		if(!h[i]) {
	        			if(s[i]==t[j]) {
	        				ans=max(ans,go(i+1,j+1));
	        			}
	        			else{
	        				ans=max(ans,go(i+1,j));
	        			}
	        		}
	        		else{
	        			if(s[i]==t[j]) {
	        				ans=max(ans,go(i+1,j)+1);
	        				ans=max(ans,go(i+1,j+1));
	        			}
	        			else{
	        				ans=max(ans,go(i+1,j)+1);
	        			}
	        		}
        		}
        		dp[i][j]=ans;
        	}
        	return dp[i][j];
        };
        int ans=go(0,0);
        return max(0,ans);
    }
};",1420026330
Brijesh Siwach,Dhongee,173,3604,cpp,"#include<bits/stdc++.h>
//#include <sys/resource.h>
using namespace std;

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
#define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
    	swap(x,n);
        const int mod=1e9+7;
        const int N=1e3;
        auto mul=[&](ll a,ll b){
        	return (a%mod*b%mod)%mod;
        };
        auto add=[&](ll a,ll b){
        	return (a%mod+b%mod)%mod;
        };
        auto binpow=[&](ll a,ll b){
        	if(b<0) return 0ll;
        	ll res=1;
        	a%=mod;
        	while(b>0) {
        		if(b&1) res=res*a%mod;
        		b>>=1;
        		a=a*a%mod;
        	}
        	return res%mod;
        };
        vl fact(N+1,1),inv(N+1);
        fr(i,2,N+1){
        	fact[i]=fact[i-1]*i%mod;
        }
        fr(i,0,N+1){
        	inv[i]=binpow(fact[i],mod-2);
        }
        auto ncr=[&](ll a,ll b){
        	if(b>a) return 0ll;
        	ll num=fact[a];
        	ll den=mul(inv[b],inv[a-b]);
        	num=mul(num,den);
        	return num;
        };
        vector<vl> dp(N+1,vl(N+1,0));
        dp[1][1]=1;
        fr(i,2,N+1){
        	fr(j,1,i+1){
        		dp[i][j]=add(dp[i-1][j-1],mul(j,dp[i-1][j]));
        	}
        }
        ll ans=0;
        fr(i,1,n+1){
        	// ll v1=ncr(x,i);
        	ll v1=dp[x][i];
        	ll v2=ncr(n,i);
        	ll v3=fact[i];
        	// ll v3=1;
        	// ll v4=binpow(i,x-i);
        	ll v4=1;
        	ll v5=binpow(y,i);
        	ll val=mul(v1,v2);
        	dbg(v1,v2,v3,v4,v5);
        	val=mul(val,v3);
        	val=mul(val,v4);
        	val=mul(val,v5);
        	ans=add(ans,val);
        	dbg(ans);
        }
        return ans;
    }
};",1420096233
Brijesh Siwach,Dhongee,173,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if(a[i] == 2) ans[i]=-1;
            else {
                int val=0,l=0;
                for(int j=0;j<30;j++){
                    if((1<<j)&a[i]) {
                        val|=(1<<j);
                        l=j;
                    }
                    else {
                        break;
                    }
                }
                val|=a[i];
                val^=(1<<l);
                ans[i]=val;

            }
        }
        return ans;
    }
};",1420005210
Brijesh Siwach,Dhongee,173,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            if(a[i] == 2) ans[i]=-1;
            else {
                int val=0,l=0;
                for(int j=0;j<30;j++){
                    if((1<<j)&a[i]) {
                        val|=(1<<j);
                        l=j;
                    }
                    else {
                        break;
                    }
                }
                val|=a[i];
                val^=(1<<l);
                ans[i]=val;

            }
        }
        return ans;
    }
};",1420004247
Gautam Agarwal,gaut_2003,175,3487,cpp,"class Solution {
public:
    int solve(int i, int j, set<int>& st, string& source, string& pattern, int n, int m, vector<vector<int>>& dp){
        if(i == n){
            if(j != m) return -1e9;
            return 0;
        }
        if(dp[i][j] != -1) return dp[i][j];
        int ans = solve(i+1,j,st,source,pattern,n,m,dp);
        if(j<m && source[i] == pattern[j]){
            ans = max(ans,solve(i+1,j+1,st,source,pattern,n,m,dp));
        }
        if(st.find(i) != st.end()){
            ans = max(ans,1+solve(i+1,j,st,source,pattern,n,m,dp));
        }
        return dp[i][j] = ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        set<int> st;
        for(auto val:targetIndices){
            st.insert(val);
        }
        vector<vector<int>> dp(n+1, vector<int>(m+1,-1));
        int ans = solve(0,0,st,source,pattern,n,m,dp);
        return ans;
    }
};",1420025334
Gautam Agarwal,gaut_2003,175,3604,cpp,"class Solution {
public:
    int mod = 1e9+7;
    int power(int x, int y){
        if(y == 0) return 1;
        int temp = power(x,y/2);
        temp = (temp*1ll*temp)%mod;
        if(y%2 == 1) temp = (temp*1ll*x)%mod;
        return temp;
    }
    int numberOfWays(int n, int x, int y) {
        int ans = 0;
        vector<vector<long long>> preCompute(n+1, vector<long long>(x+1, 0));
        preCompute[0][0] = 1;

        for(int j=1;j<=n;j++){
            for(int k=1;k<=x;k++){
                preCompute[j][k] = (k * preCompute[j-1][k] + preCompute[j-1][k-1]) % mod;
            }
        }
        
        long long yy = 1, bc = 1, fact = 1;
        for(int i=1;i<=min(n,x);i++){
            yy = (yy*y) % mod;
            bc = (bc * ((x-i+1) % mod)) % mod;
            bc = (bc * (power(i,mod-2) % mod)) % mod;
            fact = (fact * i) % mod;
            long long temp1 = preCompute[n][i];
            long long result = (yy * (bc % mod)) % mod;
            result = (result  * (fact % mod)) % mod;
            result = (result * (temp1 % mod)) % mod;
            ans = (ans + result)%mod;
        }
        return ans;
    }
};",1420089502
Gautam Agarwal,gaut_2003,175,3605,cpp,"class Solution {
public:
    int solve(int num){
        int ind = -1;
        int temp = num;
        while(temp > 0){
            int rem = temp%2;
            if(rem == 0){
                break;
            }else{
                ind++;
            }
            temp /= 2;
        }
        int ans = num^(1<<ind);
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2 == 0) ans[i] = -1;
            else ans[i] = solve(nums[i]);
        }
        return ans;
    }
};",1420004201
Gautam Agarwal,gaut_2003,175,3611,cpp,"class Solution {
public:
    int solve(int num){
        int ind = -1;
        int temp = num;
        while(temp > 0){
            int rem = temp%2;
            if(rem == 0){
                break;
            }else{
                ind++;
            }
            temp /= 2;
        }
        int ans = num^(1<<ind);
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2 == 0) ans[i] = -1;
            else ans[i] = solve(nums[i]);
        }
        return ans;
    }
};",1420003627
Titas,ads3k,176,3487,python3,"from typing import List

class Solution:
    # Dummy variables
    dummy_var1 = 123
    dummy_var2 = 3.14159
    dummy_var3 = ""dummyString""
    dummy_var4 = [1, 2, 3]
    dummy_var5 = False

    # Dummy functions
    def dummy_function1(self):
        return self.dummy_var1 + 1
    
    def dummy_function2(self):
        return self.dummy_var2 * 2
    
    def dummy_function3(self):
        return len(self.dummy_var3)
    
    def dummy_function4(self):
        return sum(self.dummy_var4)
    
    def dummy_function5(self):
        return not self.dummy_var5

    def maxRemovals(self, source: str, pattern: str, indices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        
        is_target = [False] * n
        i = 0
        while i < len(indices):
            is_target[indices[i]] = True
            i += 1

        i = 0
        while i < n:
            j = m
            while j > 0:
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if is_target[i] else 0))
                j -= 1
            i += 1
        
        return len(indices) - (0 if dp[m] == float('inf') else dp[m])
",1420047418
Titas,ads3k,176,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    # Dummy variables
    dummy_var1 = 101
    dummy_var2 = ""dummy""
    dummy_var3 = [0, 1, 2]
    dummy_var4 = 7.89
    dummy_var5 = False

    # Dummy functions
    def dummy_function1(self):
        return self.dummy_var1 + 1

    def dummy_function2(self):
        return len(self.dummy_var2)

    def dummy_function3(self):
        return sum(self.dummy_var3)

    def dummy_function4(self, val):
        return val * self.dummy_var1

    def dummy_function5(self):
        return not self.dummy_var5

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        
        # Initialize the combination (C) array
        C = [[0] * (x + 1) for _ in range(x + 1)]
        i = 0
        while i <= x:
            C[i][0] = 1
            j = 1
            while j <= i:
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
                j += 1
            i += 1
        
        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1
        i = 1
        while i <= n:
            j = 1
            while j <= x:
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
                j += 1
            i += 1
        
        # Factorial array
        fact = [1] * (x + 1)
        i = 1
        while i <= x:
            fact[i] = fact[i - 1] * i % MOD
            i += 1
        
        result = 0
        # Main computation loop
        k = 1
        while k <= x:
            power = 1
            p = 0
            while p < k:
                power = (power * y) % MOD
                p += 1
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
            k += 1
        
        return result
",1420082550
Titas,ads3k,176,3605,python3,"class Solution:
    # Dummy variables
    dummy_var1 = 42
    dummy_var2 = 123
    dummy_var3 = ""example""
    dummy_var4 = [1, 2, 3]
    dummy_var5 = 3.14
    
    # Dummy functions
    def dummy_func1(self):
        pass
    
    def dummy_func2(self):
        return self.dummy_var1
    
    def dummy_func3(self):
        return self.dummy_var3
    
    def dummy_func4(self):
        return len(self.dummy_var4)
    
    def dummy_func5(self):
        return self.dummy_var5 * 2
    
    def minBitwiseArray(self, numbers: List[int]) -> List[int]:
        result = []
        idx = 0
        
        while idx < len(numbers):
            prime_num = numbers[idx]
            found_ans = False
            check_value = 0
            
            while check_value < prime_num:
                if (check_value | (check_value + 1)) == prime_num:
                    result.append(check_value)
                    found_ans = True
                    break
                check_value += 1
            
            if not found_ans:
                result.append(-1)
            
            idx += 1
        
        return result
",1420018489
Titas,ads3k,176,3611,python3,"from typing import List

class Solution:
    # Dummy variables
    dummy_var1 = 42
    dummy_var2 = ""unused""
    dummy_var3 = 3.14
    dummy_var4 = [1, 2, 3]
    dummy_var5 = True

    # Dummy functions
    def dummy_function1(self):
        return self.dummy_var1 * 2

    def dummy_function2(self):
        return len(self.dummy_var2)

    def dummy_function3(self):
        return sum(self.dummy_var4)

    def dummy_function4(self, val):
        return val + self.dummy_var1

    def dummy_function5(self):
        return not self.dummy_var5

    def minBitwiseArray(self, numbers: List[int]) -> List[int]:
        results = []
        i = 0
        while i < len(numbers):
            current_num = numbers[i]
            candidates = []
            j = 0
            
            while j < 32:
                if current_num & (1 << j):
                    x = current_num & ~(1 << j)
                    if (x | (x + 1)) == current_num:
                        candidates.append(x)
                j += 1
            
            if not candidates:
                results.append(-1)
            else:
                results.append(min(candidates))
            i += 1
        
        return results
",1420082128
Md Abedin,MdAbedin,178,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        s = set(targetIndices)

        @cache
        def solve(i1,i2):
            if [i1,i2] == [len(source),len(pattern)]: return 0
            if i2 == len(pattern): return solve(i1+1,i2) + (i1 in s)
            if i1 == len(source): return -1

            if i1 in s:
                if (x := solve(i1+1,i2)) != -1:
                    return max(x+1,solve(i1+1,i2+(source[i1] == pattern[i2])))
                else:
                    return solve(i1+1,i2+(source[i1] == pattern[i2]))
            else:
                return solve(i1+1,i2+(source[i1] == pattern[i2]))

        return solve(0,0)",1420041040
Md Abedin,MdAbedin,178,3604,python3,"mod = 10**9+7

facts = [1]
for x2 in range(1,1001): facts.append((facts[-1]*x2)%mod)

@cache
def stirling(n,k):
    if n == k: return 1
    if 0 in [n,k]: return 0
    return (k*stirling(n-1,k)+stirling(n-1,k-1))%mod

@cache
def comb(n,k): return (facts[n]*pow((facts[k]*facts[n-k])%mod,-1,mod))%mod

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0

        for x2 in range(1,min(n,x)+1):
            ways = comb(x,x2)%mod
            ways = (ways*facts[x2]*stirling(n,x2))%mod
            ways = (ways*pow(y,x2,mod))%mod
            ans = (ans+ways)%mod

        return ans",1420089634
Md Abedin,MdAbedin,178,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [min((num2 for num2 in range(2*num+1) if num2|(num2+1) == num),default=-1) for num in nums]",1419993850
Md Abedin,MdAbedin,178,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                b = list(bin(num)[2:])
                i = -1
                for k,g in groupby(b): i = len(list(g))
                b[-i] = ""0""
                ans.append(int("""".join(b),2))

        return ans",1420011792
parthDOOM,parthDOOM,179,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

#define ll long long  
#define vl vector<ll> 
#define vlll vector<vector<ll>> 
#define vb vector<bool> 
#define pb push_back 
#define ub upper_bound 
#define all(a) a.begin(),a.end() 
#define per(i,a,b) for(int i=b;i>a;i--) 
#define rep(i,a,b) for(int i=a;i<b;i++) 
#define loop(x,a) for(auto x : a)
#define inf LLONG_MAX
class Solution {
public:
    int maxRemovals(string src, string pat, vector<int>& trgind) {
        ll n = src.length(),m = pat.length();
        vl dp(m+1,inf);
        dp[0] = 0;
        vb isT(n,false);
        loop(idx, trgind) isT[idx] = true;
        rep(i,0,n) per(j,0,m+1) if(j > 0 && !(src[i] != pat[j-1]) && !(dp[j-1] == LLONG_MAX)) dp[j] = min(dp[j],dp[j-1]+(isT[i] ? 1 : 0));      
        return trgind.size()-(dp[m] == LLONG_MAX ? 0 : dp[m]);
    }
};",1420041669
parthDOOM,parthDOOM,179,3604,cpp,"#include <vector>
using namespace std;

#define ll long long  
#define vl vector<ll> 
#define vlll vector<vector<ll>> 
#define vb vector<bool> 
#define pb push_back 
#define ub upper_bound 
#define all(a) a.begin(),a.end() 
#define per(i,a,b) for(int i=b;i>a;i--) 
#define rep(i,a,b) for(int i=a;i<b;i++) 
#define loop(x,a) for(auto x : a)
#define inf LLONG_MAX
#define MOD 1000000007

class Solution {
public:
    ll numberOfWays(ll n,ll x,ll y){
        vlll C(x+1,vl(x+1,0));
        rep(i,0,x+1){
            C[i][0] = 1;
            rep(j,1,i+1) C[i][j] = (C[i-1][j-1]+C[i-1][j])%MOD; 
        }
        vlll S(n+1,vl(x+1,0));
        S[0][0] = 1;
        rep(i,1,n+1) rep(j,1,x+1) S[i][j] = (j * S[i-1][j] + S[i-1][j-1])%MOD;
        vl ft(x+1,1);
        rep(i,1,x+1) ft[i] = ft[i-1] * i % MOD;
        ll ans = 0;
        rep(k,1,x+1){
            ll pow = 1;
            rep(p,0,k) pow = pow * y % MOD;
            ans = (ans + C[x][k] * S[n][k] % MOD * ft[k] % MOD * pow % MOD) % MOD;
        }
        return ans;
    }
};
",1420096774
parthDOOM,parthDOOM,179,3605,cpp,"#define ll long long 
#define vl vector<ll>
#define vlll vector<vector<ll>>
#define vb vector<bool>
#define pb push_back
#define ub upper_bound
#define all(a) a.begin(),a.end()
#define per(i,a,b) for(int i=b;i>a;i--)
#define rep(i,a,b) for(int i=a;i<b;i++)
#define loop(x,a) for(auto x : a)
class Solution {
public:

    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans(nums.size(), -1); 
    rep(i, 0, nums.size()) {
        rep(j, 0, nums[i]) { 
            if((j | (j + 1)) == nums[i]) {
                ans[i] = j;
                break;  
            }
        }
    }
    
    return ans;      
    }
};",1419996135
parthDOOM,parthDOOM,179,3611,cpp,"#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define vl vector<int>
#define vlll vector<vector<ll>>
#define vb vector<bool>
#define pb push_back
#define ub upper_bound
#define all(a) a.begin(),a.end()
#define per(i,a,b) for(int i=b;i>a;i--)
#define rep(i,a,b) for(int i=a;i<b;i++)
#define loop(x,a) for(auto x : a)
#define inf LLONG_MAX
#define cnt continue
#define sz(a) (int)a.size()
class Solution {
public:
    vl minBitwiseArray(vl& v) {
        ll n = sz(v);
        vl a(n);
        rep(i,0,n){
            ll x = v[i],m = inf;
            bool f = 0;
            rep(b,0,31){
                if(!(((x>>b)&1) != 1)){
                    ll c = x&~(1ll<<b);
                    if(!(c >= 0)) cnt;
                    if(!((c|(c+1)) != x)){
                        if(!(c >= m)){
                            m = c;f = 1;
                        }
                    }
                }
            }
            if(f) a[i]=m;
            else a[i]=-1;
        }
        
        return a;
    }
};",1420061861
Rohith Peddi,rohithpeddi,180,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& a) {
        int n = s.size(), mn = p.size();
        map<int,int> m;
        for (auto x: a) m[x]++;
        vector<vector<int>> dp(n+3, vector<int>(mn+3, -1));
        auto v = dp;
        function<int(int,int)> f = [&](int x, int y)->int{
            if (x>=n) return y>=mn?0:INT_MIN;
            if (v[x][y]!=-1) return dp[x][y];
            v[x][y] = 0;
            if (y>=mn) return dp[x][y] = m[x] + f(x+1, y);
            dp[x][y] = m[x] + f(x+1, y);
            if (s[x]==p[y]) dp[x][y] = max(dp[x][y], f(x+1, y+1));
            return dp[x][y];
        };
        return f(0,0);
    }
};",1420030501
Rohith Peddi,rohithpeddi,180,3604,cpp,"using ll = long long;

const ll N=1e3+3, mod = 1000000007;
ll factorialNumInverse[N + 1];
ll naturalNumInverse[N + 1];
ll fact[N + 1];

class Solution {
public:
    ll binmul(ll a, ll b, ll mod) // ll max+1
{
    if (a<=2000000000&&b<=2000000000)
        return (a*b)%mod;
    //used if a*b>10e18
    ll p=0,x=a%mod;
    while(b!=0)
    {
        if (b&1) p=(p+x)%mod;
        b>>=1;
        x=(x*2)%mod;
    }
    return p;
}

// max comp is O((log(n))^2)
ll binexp(ll a, ll b , ll mod=1000000007)
{
    a%=mod;
    ll c=a,ans=1;
    while(b!=0)
    {
        if (b&1) ans=(binmul(ans,c,mod))%mod;
        b>>=1;
        c=(binmul(c,c,mod))%mod;
    }
    return ans;
}



// Maybe only works for prime p. We have to check.
void InverseofNumber(ll p)
{
    naturalNumInverse[0] = naturalNumInverse[1] = 1;
    for (ll i = 2; i <= N; i++)
        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
}

void InverseofFactorial(ll p)
{
    factorialNumInverse[0] = factorialNumInverse[1] = 1;
    for (ll i = 2; i <= N; i++)
        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
}

void factorial(ll p)
{
    fact[0] = 1;
    for (ll i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % p;
    }
}

ll Binomial(ll N, ll R, ll p = 1000000007)
{
    ll ans = ((fact[N] * factorialNumInverse[R])
              % p * factorialNumInverse[N - R])
             % p;
    return ans;
}

void start()
{
    ll p = mod;
    InverseofNumber(p);
    InverseofFactorial(p);
    factorial(p);
}

    int numberOfWays(int n, int x, int y) {
        start();
        ll M = 1000000007, ans = 0, f = 1, ys = y, me = x;
        for (int s=1;s<=min(n,x);s++){
            // ans = (ans + binexp(s, n-s, M)*f%M*ys%M*me%M)%M, f = (f*(s+1))%M, y = ys*y%M, me = (me*(x-s))%M;
            ll f1 = 0;
            for (int i=0;i<=s;i++)
                f1 = (f1 + (i%2==0?1:-1)*Binomial(s, i)%M*binexp(s-i, n)%M  + 2*M)%M;
    
            ans = (ans + ((Binomial(x, s)%M)*f1%M)*ys%M)%M;
            ys = (ys*y)%M;
        }
        return ans;
    }
};",1420075937
Rohith Peddi,rohithpeddi,180,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto x: nums)
            for (int i=0;i<31;i++)
                if ((x&(1<<i)) == 0){
                    if (x==2) ans.push_back(-1);
                    else ans.push_back(x&~(1<<(i-1)));
                    break;
                }
        return ans;
    }
};",1420008702
Rohith Peddi,rohithpeddi,180,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto x: nums)
            for (int i=0;i<31;i++)
                if ((x&(1<<i)) == 0){
                    if (x==2) ans.push_back(-1);
                    else ans.push_back(x&~(1<<(i-1)));
                    break;
                }
        return ans;
    }
};",1420009722
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3487,csharp,"using System;
using System.Collections.Generic;

public class Solution {
    public int MaxRemovals(string source, string pattern, int[] targetIndices) {
        int n = source.Length;
        int m = pattern.Length;
        int[] dp = new int[m + 1];
        Array.Fill(dp, int.MaxValue);
        dp[0] = 0;

        HashSet<int> targetSet = new HashSet<int>(targetIndices);

        for (int i = 0; i < n; i++) {
            int current = dp[0]; // Store the value of dp[0] to use later
            for (int j = 1; j <= m; j++) {
                int temp = dp[j]; // Store the current dp[j] value
                if (source[i] == pattern[j - 1] && current != int.MaxValue) {
                    dp[j] = Math.Min(dp[j], current + (targetSet.Contains(i) ? 1 : 0));
                }
                current = temp; // Update current to the stored dp[j] for the next iteration
            }
        }

        return targetIndices.Length - (dp[m] == int.MaxValue ? 0 : dp[m]);
    }
}
",1420064127
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3604,csharp,"public class Solution {
    private const int MODULO = 1000000007;

    public int NumberOfWays(int itemsCount, int groupsCount, int multiplier) {
        long[,] combinations = GenerateCombinations(groupsCount);
        long[,] stirlingNumbers = GenerateStirlingNumbers(itemsCount, groupsCount);
        long[] factorials = GenerateFactorials(groupsCount);
        
        long totalWays = 0;

        for (int k = 1; k <= groupsCount; k++) {
            long currentMultiplier = CalculatePower(multiplier, k);
            totalWays = (totalWays + (combinations[groupsCount, k] * stirlingNumbers[itemsCount, k] % MODULO * factorials[k] % MODULO * currentMultiplier % MODULO) % MODULO) % MODULO;
        }

        return (int)totalWays;
    }

    private long[,] GenerateCombinations(int maxGroups) {
        long[,] comb = new long[maxGroups + 1, maxGroups + 1];
        for (int i = 0; i <= maxGroups; i++) {
            comb[i, 0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i, j] = (comb[i - 1, j - 1] + comb[i - 1, j]) % MODULO;
            }
        }
        return comb;
    }

    private long[,] GenerateStirlingNumbers(int itemsCount, int groupsCount) {
        long[,] stirling = new long[itemsCount + 1, groupsCount + 1];
        stirling[0, 0] = 1;

        for (int i = 1; i <= itemsCount; i++) {
            for (int j = 1; j <= groupsCount; j++) {
                stirling[i, j] = (j * stirling[i - 1, j] + stirling[i - 1, j - 1]) % MODULO;
            }
        }
        return stirling;
    }

    private long[] GenerateFactorials(int groupsCount) {
        long[] fact = new long[groupsCount + 1];
        fact[0] = 1;

        for (int i = 1; i <= groupsCount; i++) {
            fact[i] = (fact[i - 1] * i) % MODULO;
        }
        return fact;
    }

    private long CalculatePower(int baseValue, int exponent) {
        long result = 1;
        while (exponent > 0) {
            result = (result * baseValue) % MODULO;
            exponent--;
        }
        return result;
    }
}
",1420083951
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3605,csharp,"public class Solution {
    public int[] MinBitwiseArray(IList<int> nums) {
        int[] ans = new int[nums.Count];
        
        for (int i = 0; i < nums.Count; i++) {
            bool found = false;
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1419998337
VinayKumarReddy_5204,VinayKumarReddy_5204,182,3611,csharp,"public class Solution {
    public int[] MinBitwiseArray(IList<int> nums) {
        int length = nums.Count;
        int[] result = new int[length];
        
        for (int index = 0; index < length; index++) {
            int currentValue = nums[index];
            int bestCandidate = -1;
            
            // Loop over bit positions from 0 to 30 (since nums[i] <= 10^9)
            for (int bitPos = 30; bitPos >= 0; bitPos--) {
                if (IsBitSet(currentValue, bitPos)) {
                    // Try clearing the bit at bitPos
                    int modifiedValue = ClearBit(currentValue, bitPos);
                    
                    if (IsValidCandidate(modifiedValue, currentValue)) {
                        // Update the best candidate if found
                        if (bestCandidate == -1 || modifiedValue < bestCandidate) {
                            bestCandidate = modifiedValue;
                        }
                    }
                }
            }
            // Store the result, -1 if no valid candidate found
            result[index] = bestCandidate;
        }
        
        return result;
    }

    // Helper method to check if the bit at 'position' is set in 'num'
    private bool IsBitSet(int num, int position) {
        return ((num >> position) & 1) == 1;
    }

    // Helper method to clear the bit at 'position' in 'num'
    private int ClearBit(int num, int position) {
        return num & ~(1 << position);
    }

    // Helper method to verify if 'candidate' OR (candidate + 1) equals 'original'
    private bool IsValidCandidate(int candidate, int original) {
        return (candidate | (candidate + 1)) == original;
    }
}
",1420040299
Aakarsh Jain,aakarsh_11235,183,3487,cpp,"class Solution {
public:

    bool check(int x, int n, vector<int>& arr){
        int idx = lower_bound(arr.begin(), arr.end(), x) - arr.begin();
        if(idx == n) return false;
        return arr[idx] == x;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size(), k = targetIndices.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        dp[0][0] = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= m; j++){
                // MATCH
                if((j > 0) && (source[i] == pattern[j - 1]) && (dp[i][j - 1] != -1)){
                    dp[i + 1][j] = max(dp[i][j], dp[i][j - 1]);
                }
                // REMOVE
                if(check(i, k, targetIndices) && (dp[i][j] != -1)){
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
                }
                // DO NOTHING
                if(dp[i][j] != -1) dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
            }
        }
        int ans = 0;
        for(int i = 0; i<= n; i++) ans = max(ans, dp[i][m]);
        return ans;
    }
};",1420078495
Aakarsh Jain,aakarsh_11235,183,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long int>> dp(n + 1, vector<long long int>(x + 1, 0));
        dp[0][0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= x; j++){
                dp[i][j] = j*dp[i - 1][j] + (x - j + 1)*dp[i - 1][j - 1];
                dp[i][j] %= mod;
            }
        }
        long long int ans = 0, curr = y;
        for(int k = 1; k <= x; k++){
            ans += dp[n][k]*curr;
            ans %= mod;
            curr *= y;
            curr %= mod;
        }
        return (int)ans;
    }
};",1420097741
Aakarsh Jain,aakarsh_11235,183,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            if(nums[i] == 2) ans[i] = -1;
            else{
                ans[i] = nums[i]^(1<<__builtin_ctz((nums[i] + 1)>>1));
            }
        }
        return ans;
    }
};",1420002502
Aakarsh Jain,aakarsh_11235,183,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            if(nums[i] == 2) ans[i] = -1;
            else{
                ans[i] = nums[i]^(1<<__builtin_ctz((nums[i] + 1)>>1));
            }
        }
        return ans;
    }
};",1420004489
Pranav,ypranav,184,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        u = set(targetIndices)
    
        d = [[float('inf')] * (m + 1) for _ in range(n + 1)]
        d[0][0] = 0
        for i in range(n):
            for j in range(m + 1):
                if d[i][j] == float('inf'):
                    continue

                if j < m and source[i] == pattern[j]:
                    c = d[i][j] + (i in u)
                    if d[i + 1][j + 1] > c:
                        d[i + 1][j + 1] = c

                if d[i + 1][j] > d[i][j]:
                    d[i + 1][j] = d[i][j]
                    
        return len(targetIndices) - d[n][m]
",1420040310
Pranav,ypranav,184,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        M = 10**9 + 7
        f = [1] * (n + x + 2)

        for i in range(1, n + x + 2):
            f[i] = f[i - 1] * i % M

        v = [1] * (n + x + 2)
        v[-1] = pow(f[-1], M - 2, M)
        for i in range(n + x, -1, -1):
            v[i] = v[i + 1] * (i + 1) % M

        def C(a, b):
            if b < 0 or b > a:
                return 0
            return f[a] * v[b] % M * v[a - b] % M
            
        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for k in range(1, i + 1):
                S[i][k] = (S[i - 1][k - 1] + k * S[i - 1][k]) % M
   
        r = 0
        for k in range(1, min(n, x) + 1):
            tmp = C(x, k) * f[k] % M * S[n][k] % M * pow(y, k, M) % M
            r = (r + tmp) % M
        return r",1420097841
Pranav,ypranav,184,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def f(n):
            for i in range(1000):
                if i | (i + 1) == n:
                    return i
            return -1

        return [f(n) for n in nums]",1419993576
Pranav,ypranav,184,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            temp = []
            for j in range(32):
                if num & (1<<j):
                    a = num ^ (1<<j)
                    if (a | (a+1)) == num:
                        temp.append(a)
            if temp:
                ans.append(min(temp))
            else:
                ans.append(-1)
        return ans",1420006349
Anjali_sharma1,Anjali_sharma1,185,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: list[int]) -> int:
        source_length = len(source)
        pattern_length = len(pattern)
        dp = self.initialize_dp(pattern_length)
        is_target_index = self.mark_target_indices(source_length, targetIndices)

        for i in range(source_length):
            self.update_dp(source, pattern, dp, is_target_index, i, pattern_length)

        return len(targetIndices) - (0 if dp[pattern_length] == float('inf') else dp[pattern_length])

    def initialize_dp(self, pattern_length: int) -> list[int]:
        dp = [float('inf')] * (pattern_length + 1)
        dp[0] = 0
        return dp

    def mark_target_indices(self, source_length: int, targetIndices: list[int]) -> list[bool]:
        is_target_index = [False] * source_length
        for idx in targetIndices:
            is_target_index[idx] = True
        return is_target_index

    def update_dp(self, source: str, pattern: str, dp: list[int],
                  is_target_index: list[bool], source_index: int, pattern_length: int):
        for j in range(pattern_length, 0, -1):
            if source[source_index] == pattern[j - 1] and dp[j - 1] != float('inf'):
                dp[j] = min(dp[j], dp[j - 1] + (1 if is_target_index[source_index] else 0))


",1420084143
Anjali_sharma1,Anjali_sharma1,185,3604,python3,"class Solution:
    MOD = 1000000007

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        C = self.computeCombinations(x)
        S = self.computeStirlingNumbers(n, x)
        fact = self.computeFactorials(x)

        return self.computeResult(n, x, y, C, S, fact)

    def computeCombinations(self, x: int) -> list[list[int]]:
        C = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % self.MOD
        return C

    def computeStirlingNumbers(self, n: int, x: int) -> list[list[int]]:
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % self.MOD
        return S

    def computeFactorials(self, x: int) -> list[int]:
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = (fact[i - 1] * i) % self.MOD
        return fact

    def computeResult(self, n: int, x: int, y: int, C: list[list[int]], 
                      S: list[list[int]], fact: list[int]) -> int:
        result = 0
        for k in range(1, x + 1):
            power = pow(y, k, self.MOD)  # y^k % MOD
            result = (result + C[x][k] * S[n][k] % self.MOD * fact[k] % self.MOD * power % self.MOD) % self.MOD
        return result


",1420077821
Anjali_sharma1,Anjali_sharma1,185,3605,python3,"class Solution:
    def minBitwiseArray(self, nums):
        n = len(nums)
        ans = [0] * n

        for i in range(n):
            ans[i] = self.findMinimumAns(nums[i])

        return ans

    def findMinimumAns(self, num):
        for x in range(num + 1):
            if (x | (x + 1)) == num:
                return x
        return -1



",1419997943
Anjali_sharma1,Anjali_sharma1,185,3611,python3,"class Solution:
    def minBitwiseArray(self, numbers):
        length = len(numbers)
        result = [0] * length
        
        for index in range(length):
            current_number = numbers[index]
            minimal_candidate = float('inf')
            candidate_found = False
            
            for bit_position in range(31):
                if (current_number >> bit_position) & 1:
                    potential_candidate = current_number & ~(1 << bit_position)
                    
                    if potential_candidate >= 0 and (potential_candidate | (potential_candidate + 1)) == current_number:
                        if potential_candidate < minimal_candidate:
                            minimal_candidate = potential_candidate
                            candidate_found = True
            
            result[index] = minimal_candidate if candidate_found else -1
        
        return result


",1420047059
Atharv Paliwal,dryice,186,3487,cpp,"class Solution {
public:
    int dp[3000][3000];
    int solve(int spos1, int spos2, string& s, string& p, int n, int m, map<int,int>& m1)
    {
        if (spos2==m)
            return 0;
        if (spos1==n)
            return 1e9;
        if(dp[spos1][spos2]!=-1)
            return dp[spos1][spos2];
        if (m1.find(spos1)==m1.end())
        {
            int op1=solve(spos1+1,spos2,s,p,n,m,m1);
            int op2=1e9;
            if (s[spos1]==p[spos2])
                op2=solve(spos1+1,spos2+1,s,p,n,m,m1);
            return dp[spos1][spos2]=min(op1,op2);
        }
        else
        {
            int op1=solve(spos1+1,spos2,s,p,n,m,m1);
            int op2=1e9;
            if (s[spos1]==p[spos2])
                op2=1+solve(spos1+1,spos2+1,s,p,n,m,m1);
            return dp[spos1][spos2]=min(op1,op2);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(dp,-1,sizeof(dp));
        map<int,int> m1;
        for(auto &x:targetIndices)
            m1[x]=1;
        int val=solve(0,0,source,pattern,source.length(),pattern.length(),m1);
        // cout<<val<<""\n"";
        return targetIndices.size()-val;
    }
};",1420062261
Atharv Paliwal,dryice,186,3604,cpp,"class Solution {
public:
    int mod=1e9+7;
    long long dp[1000][1001];
    long long pw(long long a, long long n)
    {
        if (n==0)
            return 1;
        long long sm=pw(a,n/2);
        sm=sm*sm%mod;
        if (n%2)
            return sm*a%mod;
        return sm;
    }
    long long solve(long long spos, long long bandCount, long long n, long long x, long long y)
    {
        if (spos==n)
            return pw(y, bandCount);
        if (dp[spos][bandCount]!=-1)
            return dp[spos][bandCount];
        if (bandCount==x)
            return dp[spos][bandCount]=(solve(spos+1,bandCount,n,x,y)*x)%mod;
        long long op1=0;
        if (bandCount>0)
            op1=(solve(spos+1,bandCount,n,x,y)*bandCount)%mod;
        long long op2=(solve(spos+1,bandCount+1,n,x,y)*(x-bandCount))%mod;
        // cout<<spos<<"" ""<<bandCount<<"" ""<<op1<<"" ""<<op2<<""\n"";
        return dp[spos][bandCount]=(op1+op2)%mod;
    }
    int numberOfWays(int n, int x, int y) {
        memset(dp,-1,sizeof(dp));
        return solve(0,0,n,x,y);
    }
};",1420091166
Atharv Paliwal,dryice,186,3605,cpp,"class Solution {
public:
    int pw(int x)
    {
        return x && (!(x & (x - 1)));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,1e9);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=10;j++)
            {
                int val=nums[i]-(1<<j);
                if(val<=0)
                    continue;
                if ((val|(val+1))==nums[i])
                    ans[i]=min(ans[i],val);
            }
            if(ans[i]==1e9)
                ans[i]=-1;
        }
        return ans;
    }
};",1420002472
Atharv Paliwal,dryice,186,3611,cpp,"class Solution {
public:
    int pw(int x)
    {
        return x && (!(x & (x - 1)));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,2e9);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<=30;j++)
            {
                int val=nums[i]-(1<<j);
                if(val<=0)
                    continue;
                if ((val|(val+1))==nums[i])
                    ans[i]=min(ans[i],val);
            }
            if(ans[i]==2e9)
                ans[i]=-1;
        }
        return ans;
    }
};",1420004618
Noushil Sharma,noushilll,187,3487,cpp,"class Solution {
public:
    
    int solve(int i, int j,string &s, string &p,vector<int>&tar,vector<vector<int>>&dp){
        
        if(i>=s.size()){
            if(j>=p.size()){
                return 0;
            }
            return INT_MIN;
        }

        if(dp[i][j]!=-1) return dp[i][j];
        int take = INT_MIN;
        int nottake = INT_MIN;

        if(tar[i]){
            take = 1 + solve(i+1,j,s,p,tar,dp);
            nottake = INT_MIN;
            if(s[i]==p[j]){
                nottake = solve(i+1,j+1,s,p,tar,dp);
            }
            else{
                nottake = solve(i+1,j,s,p,tar,dp);
            }
        }
        else{
            nottake = INT_MIN;
            if(s[i]==p[j]){
                nottake = solve(i+1,j+1,s,p,tar,dp);
            }
            else{
                nottake = solve(i+1,j,s,p,tar,dp);
            }
            
        }
        return dp[i][j] = max(take,nottake);
    }
    int maxRemovals(string s, string p, vector<int>& v) {
        int n = s.size();
        vector<int>tar(n+1,0);
        for(auto it: v){
            tar[it]++;
        }
        vector<vector<int>>dp(n+1,vector<int>(p.size()+1,-1));
        return solve(0,0,s,p,tar,dp);
    }
};",1420098282
Noushil Sharma,noushilll,187,3604,cpp,"#include <iostream>
#include <vector>
using namespace std;

#define ll long long  // Define ll as long long
const int MOD = 1e9 + 7;

class Solution {
public:
    // Function to compute the power of x raised to y modulo mod
    ll power(ll x, ll y) {
        ll res = 1; // Initialize result
        x = x % MOD; // Update x if it is more than or equal to mod
        if (x == 0) return 0; // In case x is divisible by mod

        while (y > 0) {
            // If y is odd, multiply x with result
            if (y & 1) {
                res = (res * x) % MOD;
            }
            // y must be even now
            y = y >> 1; // y = y / 2
            x = (x * x) % MOD;
        }
        return res;
    }

    // Function to compute factorial values modulo mod
    vector<ll> factorial(int x) {
        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    ll numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        vector<vector<ll>> S(n + 1, vector<ll>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
            }
        }
        vector<ll> fact = factorial(x);

        ll result = 0;
        for (int k = 1; k <= x; k++) {
            ll powY = power(y, k);
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * powY % MOD) % MOD;
        }

        return result;
    }
};
",1420073899
Noushil Sharma,noushilll,187,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    // Main function to construct the min bitwise array
    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size, -1);  // Initialize result with -1
        
        // Iterate over each number in the nums array
        for (int index = 0; index < size; index++) {
            result[index] = findMinimumBitwiseValue(nums[index]);
        }
        
        return result;
    }

private:
    // Function to find the minimum bitwise value for a given number
    int findMinimumBitwiseValue(int num) {
        for (int candidate = 0; candidate <= num; candidate++) {
            if ((candidate | (candidate + 1)) == num) {
                return candidate;  // Return the first valid candidate
            }
        }
        return -1;  // This case should not occur with valid input
    }
};
",1420044683
Noushil Sharma,noushilll,187,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0; i<n; i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                int h = nums[i];
                int c = 0;
                while(h%2!=0){
                    h = h/2;
                    c++;
                }
                ans.push_back(nums[i] - pow(2,c-1));
            }
        }
        return ans;
    }
};",1420044235
Sam Chen,SamChen856,188,3487,python3,"# similar: LC1898 https://leetcode.com/problems/maximum-number-of-removable-characters/

class Solution:
    # dp, time O(SP+T), space O(SP+T), S = source size, P = pattern size, T = targetIndices size
    def maxRemovals(self, s: str, p: str, targetIndices: List[int]) -> int:
        S, P = len(s), len(p)
        remove_indices_set = set(targetIndices)

        # dp[i][j] = minimum removals in s using indices from targetIndices to have p[:j] as a subsequence of s[:i]
        dp = [[inf] * (P + 1) for _ in range(S + 1)]
        dp[0][0] = 0

        for i in range(S):
            for j in range(P + 1):
                if dp[i][j] == inf:
                    continue
                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
                if j < P and s[i] == p[j]:
                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + (i in remove_indices_set))

        return len(targetIndices) - dp[S][P]",1420098537
Sam Chen,SamChen856,188,3604,python3,"MOD = 10**9 + 7
M = 1001

fact = [1] * M
for i in range(1, M):
    fact[i] = fact[i - 1] * i % MOD

inv_fact = [1] * M
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for i in range(M - 2, -1, -1):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

@cache
def comb(n: int, k: int) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD

@cache
def stirling_2(n: int, k: int) -> int:
    if k == 1 or n == k:
        return 1
    res = stirling_2(n - 1, k - 1) + k * stirling_2(n - 1, k)
    return res % MOD

class Solution:
    # math, time O(M), space O(M), M = max(n, x, y)
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        y_pow = [1] * (x + 1)
        for i in range(1, x + 1):
            y_pow[i] = y_pow[i - 1] * y % MOD

        return sum(comb(x, i) * fact[i] * stirling_2(n, i) * y_pow[i] % MOD for i in range(1, min(n, x) + 1)) % MOD
",1420069662
Sam Chen,SamChen856,188,3605,python3,"class Solution:
    # brute, time O(nM), space O(1), n = nums.length, M = max(nums)
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        for i, num in enumerate(nums):
            for x in range(num + 1):
                if x | (x + 1) == num:
                    ans[i] = x
                    break
        return ans",1420017793
Sam Chen,SamChen856,188,3611,python3,"class Solution:
    # bit, time O(nlogM), space O(1)
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        for i, num in enumerate(nums):
            if num == 2:
                continue
            x = num
            j = 0
            while x >> (j + 1) & 1:
                x ^= (1 << j)
                j += 1
            ans[i] = x - 1
        return ans",1420029588
Nandy_Tragic,Nandy_Tragic,189,3487,cpp,"class Solution {
public:
    
    vector<int>dp;
    vector<int>pos;
    const int INF = INT_MAX;
    
    void calculateDP(string &s, string &p, int n, int m){
        for(int i=0;i<n;i++){
            for(int j=m;j>=1;j--){
                if(s[i] == p[j-1]){
                    if(dp[j-1] != INF){
                        int curr = dp[j];
                        curr = min(curr, dp[j-1] + (pos[i] == 1 ? 1 : 0));
                        dp[j] = curr;
                    }
                }
            }
        }
    }
    
    int maxRemovals(string s, string p, vector<int>& nums) {
        
        pos.clear();
        dp.clear();
        int n = s.length();
        int m = p.length();
        
        pos = vector<int>(n, 0);
        for(int i=0;i<nums.size();i++){
            pos[nums[i]] = 1;
        }
        dp = vector<int>(m+1, INF);
        dp[0] = 0;
        
        calculateDP(s, p, n, m);
        
        int answer = nums.size();
        answer -= (dp[m] != INF ? dp[m] : 0);
        return answer;
    }
};",1420068375
Nandy_Tragic,Nandy_Tragic,189,3604,cpp,"class Solution {
public:
    
    typedef long long ll;
    const ll M = 1e9 + 7;
    
    vector<ll>fact;
    vector<vector<ll>>first_array,second_array;
    
    ll mod(ll a){
        return ((a % M) + M) % M;
    }
    ll mul(ll a, ll b){
        return mod(mod(a) * mod(b));
    }
    ll add(ll a, ll b){
        return mod(mod(a) + mod(b));
    }
    
    void calculateFirstDP(int n, int x, int y){
        for (int i = 0; i<=x; i++) {
            first_array[i][0] = 1LL;
            for (int j = 1; j < i+1; j++) {
                ll currsum = add(first_array[i-1][j-1], first_array[i-1][j]);
                first_array[i][j] = currsum;
            }
        }
    }
    
    void calculateSecondDP(int n, int x, int y){
        for (int i=1; i<=n; i++) {
            for (int j=1; j<x+1; j++) {
                ll currsum = mul((ll)j, second_array[i-1][j]);
                currsum = add(currsum, second_array[i-1][j-1]);
                second_array[i][j] = currsum;
            }
        }
    }
    
    ll calculateValue(int n, int x, int y, ll &answer){
        for (int k = 1; k <= x; ++k) {
            ll currPow = 1LL;
            for (int p=1; p<=k; p++) {
                currPow = mul(currPow, (ll)y);
            }
            ll addsum = mul(mul(first_array[x][k], second_array[n][k]), mul(fact[k], currPow));
            answer = add(answer, addsum);
        }
        return answer;
    }
    
    int numberOfWays(int n, int x, int y) {
        first_array.clear();
        second_array.clear();
        fact.clear();
        
        fact = vector<ll>(x+5, 1LL);
        first_array = vector<vector<ll>>(x+2, vector<ll>(x+2, 0LL));
        second_array = vector<vector<ll>>(n+2, vector<ll>(x+2, 0LL));
        
        second_array[0][0] = 1LL;
        
        for(int i=1;i<=x;i++){
            fact[i] = mul(fact[i-1], (ll)i);
        }
        
        calculateFirstDP(n, x, y);
        
        calculateSecondDP(n, x, y);
        
        ll answer = 0LL;
        
        return calculateValue(n, x, y, answer);
        
    }
};",1420092080
Nandy_Tragic,Nandy_Tragic,189,3605,cpp,"class Solution {
public:
    
    int func(int ele){
        int cnt = 0;
        int temp = ele;
        while(ele > 0){
            int rem = (ele%2);
            if(rem == 0) break;
            cnt++;
            ele /= 2;
        }
        int curr = temp;
        curr ^= (int)(pow(2, cnt) - 1);
        curr |= (int)(pow(2, cnt-1) - 1);
        return curr;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>answer(n, -1);
        for(int i=0;i<n;i++){
            int ele = nums[i];
            int msb = log2(ele);
            if(ele == 2){
                answer[i] = -1; 
                continue;
            }
            if((ele & (ele + 1)) == 0){
                answer[i] = pow(2, msb) - 1;
                continue;
            }
            answer[i] = func(ele);
        }
        return answer;
    }
};

// 2 3 5 7 11 13 17 19
    
// 11 -> 1 0 1 1
    
// if num == pow(2, msb + 1) - 1
    
//     pow(2, msb) - 1 
    
// else 
    
//     1 0 0 1 0 1 0 1 1 1 0 1
    
//     9 ->  1 0 0 1
//     10 -> 1 0 1 0
    
    
//     47 -> 1 0 1 1 1 1
    
    
    
    ",1420031293
Nandy_Tragic,Nandy_Tragic,189,3611,cpp,"class Solution {
public:
    
    int func(int ele){
        int cnt = 0;
        int temp = ele;
        while(ele > 0){
            int rem = (ele%2);
            if(rem == 0) break;
            cnt++;
            ele /= 2;
        }
        int curr = temp;
        curr ^= (int)(pow(2, cnt) - 1);
        curr |= (int)(pow(2, cnt-1) - 1);
        return curr;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>answer(n, -1);
        for(int i=0;i<n;i++){
            int ele = nums[i];
            int msb = log2(ele);
            if(ele == 2){
                answer[i] = -1; 
                continue;
            }
            if((ele & (ele + 1)) == 0){
                answer[i] = pow(2, msb) - 1;
                continue;
            }
            answer[i] = func(ele);
        }
        return answer;
    }
};

// 2 3 5 7 11 13 17 19
    
// 11 -> 1 0 1 1
    
// if num == pow(2, msb + 1) - 1
    
//     pow(2, msb) - 1 
    
// else 
    
//     1 0 0 1 0 1 0 1 1 1 0 1
    
//     9 ->  1 0 0 1
//     10 -> 1 0 1 0
    
    
//     47 -> 1 0 1 1 1 1
    
    
    
    ",1420030680
Rushikesh Kulkarni,The_2nd_Derivative,190,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e11;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    int n,m;
    string src, pat;
    vector<int> sc;
    vector<vector<ll>> dp;
    
    ll dfs(int idx1, int idx2){
                
        if(idx1 == n){
            if(idx2 == m){
                return 0;
            }
            else{
                return -INF;
            }
        }
        
        if(dp[idx1][idx2] != -1){
            return dp[idx1][idx2];
        }
        
        if(idx2 == m){
            return dp[idx1][idx2] = sc[idx1] + dfs(idx1 + 1, idx2);
        }
        
        
        ll ans = -INF;
        
        // don't remove current
        if(src[idx1] == pat[idx2]){
            ans = max(ans, dfs(idx1 + 1, idx2 + 1));
        } 
        else{
            ans = max(ans, dfs(idx1 + 1, idx2));            
        }
        
        // remove
        ans = max(ans, sc[idx1] + dfs(idx1 + 1, idx2));
        return dp[idx1][idx2] = ans;
    }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        src = source;
        pat = pattern;
        
        n = sz(src), m = sz(pat);
        
        dp = vector<vector<ll>> (n + 1, vector<ll> (m + 1, -1));
        sc.clear();
        sc.resize(n, 0);
        
        for (auto x: targetIndices)
        {
            sc[x] = 1;
        }
        
        ll ans = dfs(0, 0);
        return max(0ll, ans);
    }
};",1420064389
Rushikesh Kulkarni,The_2nd_Derivative,190,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }



// -MODULAR-
template<int P>
struct Modular {
    Modular() : x{} {}
    Modular(long long x) : x{norm(x % P)} {}
    
    int norm(int x) { if (x < 0) { x += P;} if (x >= P) { x -= P;} return x; }
    int val() const { return x; }
    Modular inv() const { assert(x != 0); return pwr(*this, P - 2); }
    explicit operator long long () { return x; }  //** Warning : Explicit **
    
    // unary
    Modular operator - () const { return Modular(-x); }
    Modular operator ++ ()  { x = norm(++x); return *this; }
    Modular operator -- () { x = norm(--x); return *this; }
    Modular operator ++ (int) { Modular result = *this; ++*this; return result; }
    Modular operator -- (int) { Modular result = *this; --*this; return result; }
    Modular &operator*=(const Modular &rhs) { x = 1LL * x * rhs.val() % P; return *this; }
    Modular &operator+=(const Modular &rhs) { x = norm(x + rhs.val()); return *this;}
    Modular &operator-=(const Modular &rhs) { x = norm(x - rhs.val()); return *this; }  
    Modular &operator/=(const Modular &rhs) { return *this *= rhs.inv(); }
 
    // equality
    friend bool operator == (const Modular &lhs, const Modular &rhs) { return lhs.val() == rhs.val(); }
    friend bool operator <  (const Modular &lhs, const Modular &rhs) { return lhs.val() < rhs.val(); }
    friend bool operator >  (const Modular &lhs, const Modular &rhs) { return lhs.val() > rhs.val(); }
    friend bool operator >= (const Modular &lhs, const Modular &rhs) { return lhs.val() >= rhs.val(); }
    friend bool operator <= (const Modular &lhs, const Modular &rhs) { return lhs.val() <= rhs.val(); }
 
    // binary
    friend Modular operator*(const Modular &lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }
    friend Modular operator+(const Modular &lhs, const Modular &rhs) { return Modular(lhs) += rhs; }
    friend Modular operator-(const Modular &lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }
    friend Modular operator/(const Modular &lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }
    
    // stream
    friend std::istream &operator>>(std::istream &is, Modular &a) { long long v; is >> v; a = Modular(v); return is; }
    friend std::ostream &operator<<(std::ostream &os, const Modular &a) { return os << a.val(); }
 
private:
    int x;
};
 
const int M = 1000000007; 
using mi = Modular<M>;

mi pwr(mi a, ll b) { mi res = 1; while (b>0) { if (b&1) res *= a; a *= a; b >>= 1; } return res; } 
 
vector<mi> fact(1, 1);
vector<mi> inv_fact(1, 1);

mi F(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n];
}

mi I(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return inv_fact[n];
}

mi C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)

class Solution {
public:
    int numberOfWays(ll n, ll g, ll y) {
        vector<vector<mi>> dp(n + 1, vector<mi>(g + 1, 0));
        dp[0][0] = 1;
        
         for (int i = 1; i <= n; ++i) 
         {
            for (int j = 1; j <= g; ++j) 
            {
                dp[i][j] = mi(j) * dp[i - 1][j] + dp[i - 1][j - 1];
            }
        }
        
        mi ans = 0;
        for (ll i = 1; i <= g; i++)
        {
            ans += C(g, i) * F(i) * dp[n][i] * pwr(mi(y), i);
        }
        
        return ans.val();
    }
};",1420098838
Rushikesh Kulkarni,The_2nd_Derivative,190,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = sz(nums);
        vi ans(n, -1);
        
        for (int i = 0; i < n; i++)
        {
            for(int j = 1; j <= 1000; j++)
            {
                if((j | (j+1)) == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        
        return ans;
    }
};",1420001985
Rushikesh Kulkarni,The_2nd_Derivative,190,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
#define dbg(...) __f(#__VA_ARGS__,__VA_ARGS__)
// trace std::pair
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::pair<L,R>& P){
    return os<<""{""<<P.first<<"":""<<P.second<<""}"";
}
// trace std::vector
template<class T> std::ostream& operator<<(std::ostream& os,std::vector<T>& V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}
// trace std::map;
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace unordred_std::map
template<class L,class R> std::ostream& operator<<(std::ostream& os,std::unordered_map<L,R>& MP) {
    os<<""[ "";for(auto& P : MP) os<<P<<"" "";return os<<""]"";
}
// trace std::set
template<class T> std::ostream& operator<<(std::ostream& os,std::set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// trace std::unordered_set
template<class T> std::ostream& operator<<(std::ostream& os,std::unordered_set<T>& S){
    os<<""[ "";for(auto s:S)os<<s<<"" "";return os<<""]"";
}
// std::stack FUN
template<class T> void F_Stack(std::stack<T> st, std::string& cont) { 
    if(st.empty()) return;
    T mem=st.top();st.pop();F_Stack(st,cont);cont+="" ""+to_string(mem);  
}
// trace std::stack                                                  
template<class T> std::ostream& operator<<(std::ostream& os,std::stack<T> st) {
    os<<""["";std::string cont="""";F_Stack(st,cont);return os<<cont<<"" ]"";
}
// track std::queue
template<class T> std::ostream& operator<<(std::ostream& os,std::queue<T> q) {
    os<<""[ "";while(!q.empty()) os<<q.front()<<"" "",q.pop();return os<<""]"";
}

// for last arg.
template<typename Arg1>
void __f(const char* name,Arg1&& arg1){
    std::cout<<name<<"" : ""<<arg1<<std::endl;
}
// for variable arg
template <typename Arg1,typename... Args>
void __f(const char* names,Arg1&& arg1,Args&&... args){
    const char* comma=strchr(names+1,',');std::cout.write(names,comma-names)<<"" : ""<<arg1<<"" | "";__f(comma+1,args...);
}

// dbg std::array
template<class T, size_t S> std::ostream& operator<<(std::ostream& os,std::array<T, S> V){
    os<<""[ "";for(auto v:V)os<<v<<"" "";return os<<""]"";
}

// X.find_by_order(k) return iterator to kth element. 0 indexed.
// X.order_of_key(k) returns count of elements strictly less than k.

// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// template <class T>
// using ordered_set =  __gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;

#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) ((ll)(x).size())
#define nl '\n'
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

using ll = long long int;
using i128 = __int128;
using pii = pair<ll,ll>;
using mii = map<ll,ll>;
using umii = unordered_map<ll,ll>;
using vi = vector<int>;
using vpii = vector<pii>;
using vvi = vector<vi>;
using vvvi = vector<vvi>;
using vvii = vector<vpii>;

template<class T, class U> bool chmin(T& a, const U& b) { return b < a ? a = b, 1 : 0; }
template<class T, class U> bool chmax(T& a, const U& b) { return a < b ? a = b, 1 : 0; }


const ll INF = 1e18;
const ll N = 1e5+5;

// #define dbg(...)
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = sz(nums);
        vi ans(n, -1);
        
        for (int i = 0; i < n; i++)
        {
            int j = 0;
            while(j < 32 && (nums[i] >> j & 1)){
                j++;
            }
            j--;
            if(j >= 0){
                ans[i] = nums[i] & ~(1 << j);
            }
        }
        
        return ans;
    }
};",1420025239
Swarup_1719,Swarup_1719,191,3487,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vi dp(m + 1, inf);
        dp[0] = 0;
        vi isTarget(n, 0);
        for (int idx : targetIndices) {
            isTarget[idx] = 1;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != inf) {
                    dp[j] = fmin(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        if (dp[m] == inf) {
            return targetIndices.size();
        } else {
            return targetIndices.size() - dp[m];
        }
    }
};",1420057372
Swarup_1719,Swarup_1719,191,3604,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
class Solution {
public:
    ll numberOfWays(int n, int x, int y) {
        vector<vector<ll>> C(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
            }
        }

        vector<vector<ll>> S(n + 1, vector<ll>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % mod;
            }
        }

        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = 1LL * fact[i - 1] * i % mod;
        }

        ll ans = 0;
        for (int k = 1; k <= x; ++k) {
            ll power = 1;
            for (int p = 0; p < k; ++p) {
                power = 1LL * power * y % mod;
            }
            ans = (ans + 1LL * C[x][k] * S[n][k] % mod * fact[k] % mod * power % mod) % mod;
        }

        return ans;
    }
};",1420043900
Swarup_1719,Swarup_1719,191,3605,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
#define pqas priority_queue<int, vector<int> , greater<int> >
#define mi map<ll,ll>
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = nums.size();
        vector<int> A(n, -1); 
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            for (int a = 0; a <= num; ++a) 
            { 
                if ((a | (a + 1)) == num) 
                { 
                    A[i] = a; 
                    break; 
                }
            }
        }
        
        return A;
    }
};",1420019732
Swarup_1719,Swarup_1719,191,3611,cpp,"#define ll long long
const ll N = 2e5+5;
const ll pN = 1e7+5;
const ll inf = 1e18;
const ll mod=1e9+7;
#define vi vector<ll>
#define forn(i,n) for(ll i=0;i<n;i++)
#define fore(i,n) for(ll i=0;i<=n;i++)
#define rloope(i,a,b) for(ll i=a;i>=b;i--)
#define mpr make_pair
#define ff first
#define ss second
#define pb push_back
#define ppb pop_back
#define pii pair<ll,ll>
#define pqas priority_queue<int, vector<int> , greater<int> >
#define mi map<ll,ll>
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n = nums.size();
        vector<int> v(n,-1);
        for(int i=0;i<n;i++)
        {
            ll num = nums[i];
            ll ans = inf;
            int fl=0;
            forn(j,32)
            {
                if(((num>>j)&1)==1)
                {
                    ll y = 1<<j;
                    ll x = num & ~y;
                    if(x>=0)
                    {
                        if((x|(x+1)) == num)
                        {
                            if(x<ans) ans=x;
                            fl=1;
                        }
                    }
                }
            }
            if(fl)
            {
                v[i] = ans;
            }
        }
        return v;
    }
};",1420078804
Tanvir Tareq,tanvirtareq,193,3487,cpp,"class Solution {
public:
    int dp[3010][3010];
    int cst[3010];
    string s, p;
    int dpf(int i, int j) {
        if(j>=p.size()) return 0;
        if(i>=s.size()) {
            return s.size()+1000;
        }
        int &rt=dp[i][j];
        // cout<<""ad ""<<rt<<endl;
        if(rt!=-1) return rt;
        rt=s.size()+1000;
        // cout<<""b ""<<rt<<endl;
        if(s[i]==p[j]) rt=min(rt, dpf(i+1, j+1)+cst[i]);
        // cout<<""c ""<<
        rt=min(rt, dpf(i+1, j));
        // cout<<i<<' '<<j<<"" ""<<rt<<endl;
        return rt;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(dp, -1, sizeof(dp));
        s=source;
        p=pattern;
        for(auto it:targetIndices) {
            cst[it]=1;
        }

        return targetIndices.size() - dpf(0, 0);
    }
};",1420039769
Tanvir Tareq,tanvirtareq,193,3604,cpp,"class Solution {
public:
    long long MD = 1000000007LL;
    long long fct[1010];
    long long s[1010][1010];
    long long powr(long long b, long long p) {
        if(p==0) return 1;
        long long x=powr(b, p/2);
        x=(x*x)%MD;
        if(p%2) {
            x=(x*b)%MD;
        }
        return x;
    }

    long long p(long long n, long long r) {
        long long rt=fct[n];
        rt=(rt*powr(fct[n-r], MD-2))%MD;
        return rt;
    }
    long long sf(int n, int k) {
        if (n == 0 && k == 0) return 1;
        if (n == 0 || k == 0) return 0;
        if (n == k) return 1;

        long long &rt = s[n][k];
        if(rt!=-1) return rt;

        return rt=((k*sf(n-1, k))%MD+sf(n-1, k-1))%MD;
    }

    long long cal(int n, int x, int y, int i) {
        long long rt=p(x, i);
        rt=(rt*sf(n, i))%MD;
        rt =(rt*powr(y, i));
        return rt;
    }
    int numberOfWays(int n, int x, int y) {
        
        memset(s, -1, sizeof(s));
        // cout<<sf(5, 2)<<endl;
        fct[0]=1;
        for(long long i=1;i<=max(n, x);i++) {
            fct[i]=(fct[i-1]*i)%MD;
        }
        long long ans=0;
        for(long long i=1;i<=min(n, x);i++) {
            ans=(ans+cal(n, x, y, i))%MD;
            // cout<<ans<<endl;
        }
        return ans;
    }
};",1420099842
Tanvir Tareq,tanvirtareq,193,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto it:nums) {
            int x=it;
            int y=-1;
            for(int i=0;i<=x;i++) {
                if((i|(i+1))==x) {
                    y=i;
                    break;
                }
            }
            ans.push_back(y);
        }
        return ans;
    }
};",1420003439
Tanvir Tareq,tanvirtareq,193,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto it:nums) {
            if(__builtin_popcount(it)==1) {
                ans.push_back(-1);
                continue;
            }
            vector<int> v;
            int x=it;
            while(x) {
                v.push_back(x%2);
                x/=2;
            }
            v.push_back(0);
            for(int i=1;i<v.size();i++) {
                if(v[i]==0 and v[i-1]==1) {
                    v[i-1]=0;
                    break;
                }
            }
            int y=0;
            for(int i=(int)v.size()-1;i>=0;i--) {
                y*=2;
                y+=v[i];
            }
            ans.push_back(y);
        }
        return ans;
    }
};",1420013361
Roman Derkach,derkach,194,3487,cpp,"class Solution {
public:

    int dp[3005][3005];
    bool used[3005][3005];
    int mp[3005];

    int maxRemovals(string a, string b, vector<int>& c) {
        for(int i = 0; i <= 3000; ++i)mp[i] = 0;
            for(auto x : c) mp[x] = 1;
            int n = (int)a.size();
            int m = (int)b.size();
            for(int i = 0; i <= n; ++i){
                for(int j = 0; j <= m; ++j){
                    used[i][j] = false;
                    dp[i][j] = 0;
                }
            }
            used[0][0] = true;
            for(int i = 0; i < n; ++i){
                for(int j = 0; j <= i; ++j){
                    if(used[i][j]){
                        if(a[i] == b[j]){
                            if(mp[i])dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1),used[i + 1][j] = true;
                            dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                            used[i + 1][j + 1] = true;
                        }else{
                            if(mp[i]) dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1), used[i + 1][j] = true;
                            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                            used[i + 1][j] = true;
                        }
                    }
                }
            }

            return dp[n][m];
      }
};",1420072604
Roman Derkach,derkach,194,3604,cpp,"class Solution {
public:

    int dp[2000][2000];
    int md = 1e9 + 7;

    void add(int &a,int b){
        a += b;
        if(a >= md)a -= md;
    }

    int numberOfWays(int n, int x, int y) {
        for(int i = 0; i <= n; ++i){
            for(int j = 0; j <= x; ++j){
                dp[i][j] = 0;
            }
        }
        dp[0][0] = 1;
        for(int i = 0; i < n; ++i){
            for(int j = 0; j <= x; ++j){
                add(dp[i + 1][j], dp[i][j] * 1ll * j % md);
                add(dp[i + 1][j + 1], dp[i][j] * 1ll *(x - j) % md *1ll* y % md);
            }
        }
        int ans = 0;
        for(int j = 1; j <= x; ++j){
            add(ans, dp[n][j]);
        }
        return ans;
    }
};",1420034892
Roman Derkach,derkach,194,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2)ans.push_back(-1);
            for(int j = -1000; j <= 1000; ++j){
                if((j | (j + 1)) == nums[i]){
                    ans.push_back(j);
                    break;
                }
            }
        }
        return ans;
    }
};",1419996759
Roman Derkach,derkach,194,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size(); ++i){
            if(nums[i] == 2){
                ans.push_back(-1);
            }else{
                int val = nums[i];
                val /= 2;
                bool f = false;
                for(int j = val - 12000; j <= val + 12000; ++j){
                    if((j | (j + 1)) == nums[i]){
                        ans.push_back(j);
                        f = 1;
                        break;
                    }
                }
                if(!f){
                    for(int j = nums[i] - 12000; i <= nums[i] + 12000; ++j){
                        if((j | (j + 1)) == nums[i]){
                        ans.push_back(j);
                        f = 1;
                        break;
                    }
                    }
                }
            }
        }
        return ans;
    }
};",1420010699
Geek_Guy_0808,Geek_Guy_0808,195,3487,cpp,"class Solution {
public:

int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFall(int lambai) {
    return vector<int>(lambai, -1);
}


bool isBitSet(int sankhya, int bit) {
    return ((sankhya >> bit) & 1) == 1;
}

int unsetBit(int sankhya, int bit) {
    return sankhya & ~(1 << bit);
}

bool isValidCandidate(int pratyashi, int sankhya) {
    return pratyashi >= 0 && ((pratyashi | (pratyashi + 1)) == sankhya);
}

int khojLagbhagChhota(int sankhya) {
    int lagbhagChhota = INT_MAX;
    bool paayaGaya = false;

    for (int bit = 0; bit <= 30; ++bit) {
        if (isBitSet(sankhya, bit)) {
            int pratyashi = unsetBit(sankhya, bit);

            if (isValidCandidate(pratyashi, sankhya) && pratyashi < lagbhagChhota) {
                lagbhagChhota = pratyashi;
                paayaGaya = true;
            }
        }
    }
    return paayaGaya ? lagbhagChhota : -1;
}

int dhoondhChhotaUttar(int sankhya) {
    return khojLagbhagChhota(sankhya);
}

std::vector<int> prarambhFal(int lambai) {
    return std::vector<int>(lambai, -1);
}

std::vector<int> minBitwiseArray(std::vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    std::vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = dhoondhChhotaUttar(sankhyaSuchi[i]);
    }

    return fal;
}

std::vector<bool> nayaSuchak(int n) {
    return std::vector<bool>(n, false);
}

std::vector<int> shuruAarambhikSuchi(int m) {
    std::vector<int> dp(m + 1, INT_MAX);
    dp[0] = 0;
    return dp;
}

void chinhanSuchi(std::vector<bool>& suchak, const std::vector<int>& lakshyaSuchi) {
    for (int idx : lakshyaSuchi) {
        suchak[idx] = true;
    }
}

void sthanakSuchak(const std::string& strot, const std::string& prarup, std::vector<int>& dp, const std::vector<bool>& suchak) {
    int n = strot.size();
    int m = prarup.size();

    for (int i = 0; i < n; ++i) {
        for (int j = m; j > 0; --j) {
            if (strot[i] == prarup[j-1] && dp[j-1] != INT_MAX) {
                dp[j] = std::min(dp[j], dp[j-1] + (suchak[i] ? 1 : 0));
            }
        }
    }
}

int maxRemovals(const std::string& strot, const std::string& prarup, const std::vector<int>& lakshyaSuchi) {
    int n = strot.size();
    int m = prarup.size();

    std::vector<bool> suchak = nayaSuchak(n);
    chinhanSuchi(suchak, lakshyaSuchi);
    
    std::vector<int> dp = shuruAarambhikSuchi(m);

    sthanakSuchak(strot, prarup, dp, suchak);

    return lakshyaSuchi.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
}
};

",1420058548
Geek_Guy_0808,Geek_Guy_0808,195,3604,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:


int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFall(int lambai) {
    return vector<int>(lambai, -1);
}


bool isBitSet(int sankhya, int bit) {
    return ((sankhya >> bit) & 1) == 1;
}

int unsetBit(int sankhya, int bit) {
    return sankhya & ~(1 << bit);
}

bool isValidCandidate(int pratyashi, int sankhya) {
    return pratyashi >= 0 && ((pratyashi | (pratyashi + 1)) == sankhya);
}

int khojLagbhagChhota(int sankhya) {
    int lagbhagChhota = INT_MAX;
    bool paayaGaya = false;

    for (int bit = 0; bit <= 30; ++bit) {
        if (isBitSet(sankhya, bit)) {
            int pratyashi = unsetBit(sankhya, bit);

            if (isValidCandidate(pratyashi, sankhya) && pratyashi < lagbhagChhota) {
                lagbhagChhota = pratyashi;
                paayaGaya = true;
            }
        }
    }
    return paayaGaya ? lagbhagChhota : -1;
}

int dhoondhChhotaUttar(int sankhya) {
    return khojLagbhagChhota(sankhya);
}

std::vector<int> prarambhFal(int lambai) {
    return std::vector<int>(lambai, -1);
}

std::vector<int> minBitwiseArray(std::vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    std::vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = dhoondhChhotaUttar(sankhyaSuchi[i]);
    }

    return fal;
}

std::vector<bool> nayaSuchak(int n) {
    return std::vector<bool>(n, false);
}

std::vector<int> shuruAarambhikSuchi(int m) {
    std::vector<int> dp(m + 1, INT_MAX);
    dp[0] = 0;
    return dp;
}

void chinhanSuchi(std::vector<bool>& suchak, const std::vector<int>& lakshyaSuchi) {
    for (int idx : lakshyaSuchi) {
        suchak[idx] = true;
    }
}

void sthanakSuchak(const std::string& strot, const std::string& prarup, std::vector<int>& dp, const std::vector<bool>& suchak) {
    int n = strot.size();
    int m = prarup.size();

    for (int i = 0; i < n; ++i) {
        for (int j = m; j > 0; --j) {
            if (strot[i] == prarup[j-1] && dp[j-1] != INT_MAX) {
                dp[j] = std::min(dp[j], dp[j-1] + (suchak[i] ? 1 : 0));
            }
        }
    }
}

int maxRemovals(const std::string& strot, const std::string& prarup, const std::vector<int>& lakshyaSuchi) {
    int n = strot.size();
    int m = prarup.size();

    std::vector<bool> suchak = nayaSuchak(n);
    chinhanSuchi(suchak, lakshyaSuchi);
    
    std::vector<int> dp = shuruAarambhikSuchi(m);

    sthanakSuchak(strot, prarup, dp, suchak);

    return lakshyaSuchi.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
}


    int numberOfWays(int n, int x, int y) {
        std::vector<int> paramenter = {n, x, y};
        std::vector<std::vector<int>> C = ghanakSanjha(x);
        std::vector<std::vector<int>> S = ghanakStirling(n, x);
        std::vector<int> fact = ghanakFactorial(x);
        return ghanakParinaam(x, n, C, S, fact, y);
    }

private:
    std::vector<std::vector<int>> ghanakSanjha(int x) {
        std::vector<std::vector<int>> C = initializeSanjha(x);
        computeSanjha(C, x);
        return C;
    }

    std::vector<std::vector<int>> initializeSanjha(int x) {
        std::vector<std::vector<int>> C(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
        }
        return C;
    }

    void computeSanjha(std::vector<std::vector<int>>& C, int x) {
        for (int i = 1; i <= x; ++i) {
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }

    std::vector<std::vector<int>> ghanakStirling(int n, int x) {
        std::vector<std::vector<int>> S = initializeStirling(n, x);
        computeStirling(S, n, x);
        return S;
    }

    std::vector<std::vector<int>> initializeStirling(int n, int x) {
        std::vector<std::vector<int>> S(n + 1, std::vector<int>(x + 1, 0));
        S[0][0] = 1;
        return S;
    }

    void computeStirling(std::vector<std::vector<int>>& S, int n, int x) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (static_cast<long long>(j) * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
    }

    std::vector<int> ghanakFactorial(int x) {
        std::vector<int> fact = initializeFactorial(x);
        computeFactorial(fact, x);
        return fact;
    }

    std::vector<int> initializeFactorial(int x) {
        std::vector<int> fact(x + 1, 1);
        return fact;
    }

    void computeFactorial(std::vector<int>& fact, int x) {
        for (int i = 1; i <= x; ++i) {
            fact[i] = static_cast<long long>(fact[i - 1]) * i % MOD;
        }
    }

    long long ghanakPowers(int y, int k) {
        long long power = 1;
        for (int p = 0; p < k; ++p) {
            power = (power * y) % MOD;
        }
        return power;
    }

    int ghanakParinaam(int x, int n, const std::vector<std::vector<int>>& C, 
                       const std::vector<std::vector<int>>& S, 
                       const std::vector<int>& fact, int y) {
        int parinaam = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = ghanakPowers(y, k);
            parinaam = (parinaam + static_cast<long long>(C[x][k]) * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return parinaam;
    }
};
",1420100183
Geek_Guy_0808,Geek_Guy_0808,195,3605,cpp,"class Solution {
public:

int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFal(int lambai) {
    return vector<int>(lambai, -1);
}

vector<int> minBitwiseArray(vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = paoFal(sankhyaSuchi[i]);
    }

    return fal;
}



};",1420003803
Geek_Guy_0808,Geek_Guy_0808,195,3611,cpp,"class Solution {
public:

int khojLagbhag(int pradhan) {
    for (int shabd = 1; shabd <= pradhan; ++shabd) {
        if ((shabd | (shabd + 1)) == pradhan) {
            return shabd;
        }
    }
    return -1;
}

int dhoondhPradhan(int pradhan) {
    return khojLagbhag(pradhan);
}

int paoFal(int sankhya) {
    return dhoondhPradhan(sankhya);
}

vector<int> prarambhFall(int lambai) {
    return vector<int>(lambai, -1);
}


bool isBitSet(int sankhya, int bit) {
    return ((sankhya >> bit) & 1) == 1;
}

int unsetBit(int sankhya, int bit) {
    return sankhya & ~(1 << bit);
}

bool isValidCandidate(int pratyashi, int sankhya) {
    return pratyashi >= 0 && ((pratyashi | (pratyashi + 1)) == sankhya);
}

int khojLagbhagChhota(int sankhya) {
    int lagbhagChhota = INT_MAX;
    bool paayaGaya = false;

    for (int bit = 0; bit <= 30; ++bit) {
        if (isBitSet(sankhya, bit)) {
            int pratyashi = unsetBit(sankhya, bit);

            if (isValidCandidate(pratyashi, sankhya) && pratyashi < lagbhagChhota) {
                lagbhagChhota = pratyashi;
                paayaGaya = true;
            }
        }
    }
    return paayaGaya ? lagbhagChhota : -1;
}

int dhoondhChhotaUttar(int sankhya) {
    return khojLagbhagChhota(sankhya);
}

std::vector<int> prarambhFal(int lambai) {
    return std::vector<int>(lambai, -1);
}

std::vector<int> minBitwiseArray(std::vector<int>& sankhyaSuchi) {
    int lambai = sankhyaSuchi.size();
    std::vector<int> fal = prarambhFal(lambai);

    for (int i = 0; i < lambai; ++i) {
        fal[i] = dhoondhChhotaUttar(sankhyaSuchi[i]);
    }

    return fal;
}
};




",1420048411
Ian Wong,ianwong1999,196,3487,cpp,"class Solution {
public:
    int dp[3055][3055];
    int target[3055];
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                dp[i][j] = -1;
            }
            
            target[i] = false;
        }
        
        for (auto x : targetIndices) target[x] = true;
        
        dp[0][0] = 0;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= m; j++) {
                if (dp[i][j] == -1) continue;
                
                if (j < m && source[i] == pattern[j]) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
                
                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
                
                if (target[i]) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + 1);
                }
            }
        }
        
        int res = -1;
        
        for (int i = 0; i <= n; i++) {
            res = max(res, dp[i][m]);
        }
        
        return res;
    }
};",1420008168
Ian Wong,ianwong1999,196,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int fact[2055];
    int inv[2055];
    int dp[2055];
    
    int mod_pow(int n, int k) {
        if (k == 0) return 1;
        int res = mod_pow(n, k >> 1);
        res = 1ll * res * res % MOD;
        if (k & 1) res = 1ll * res * n % MOD;
        return res;
    }
    int comb(int n, int k) {
        if (k > n) return 0;
        return 1ll * fact[n] * inv[k] % MOD * inv[n - k] % MOD;
    }
    int npr(int n, int k) {
        if (k > n) return 0;
        return 1ll * fact[n] * inv[n - k] % MOD;
    }
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        
        for (int i = 1; i <= n + x; i++) {
            fact[i] = 1ll * fact[i - 1] * i % MOD;
        }
        
        for (int i = 0; i <= n + x; i++) {
            inv[i] = mod_pow(fact[i], MOD - 2);
        }
        
        dp[1] = 1;
        dp[0] = 1;
        
        for (int i = 2; i <= min(n, x); i++) {
            dp[i] = mod_pow(i, n);
            for (int j = 1; j < i; j++) {
                dp[i] = (1ll * dp[i] - 1ll * dp[j] * comb(i, j) % MOD) % MOD;
                dp[i] %= MOD;
                dp[i] = (dp[i] + MOD) % MOD;
            }
        }
        
        int res = 0;
        int was = 0;
        for (int i = 1; i <= min(n, x); i++) {
            int stage_ways = 1ll * dp[i] * comb(x, i) % MOD;
            int score_ways = mod_pow(y, i);
            res = (1ll * res + 1ll * stage_ways * score_ways % MOD) % MOD;
        }
        return res;
    }
};",1420094064
Ian Wong,ianwong1999,196,3605,cpp,"class Solution {
public:
    int f(int x) {
        if (x == 2) return -1;
        int pt = 0;
        
        while (x & (1 << pt)) pt++;
        
        int res = x - (1 << (pt - 1));
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for (auto x : nums) {
            res.push_back(f(x));
        }
        
        return res;
    }
};",1419998947
Ian Wong,ianwong1999,196,3611,cpp,"class Solution {
public:
    int f(int x) {
        if (x == 2) return -1;
        int pt = 0;
        
        while (x & (1 << pt)) pt++;
        
        int res = x - (1 << (pt - 1));
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for (auto x : nums) {
            res.push_back(f(x));
        }
        
        return res;
    }
};",1419999187
ConstantineJin,ConstantineJin,198,3487,python3,"class Solution:
    def maxRemovals(self, source, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        is_target = [False] * n
        for idx in targetIndices:
            is_target[idx] = True
        prev = [0] * (n + 1)
        current = [0] * (n + 1)
        for i in range(1, m + 1):
            for j in range(n + 1):
                if j < i:
                    current[j] = inf
                elif j == 0:
                    current[j] = inf
                else:
                    if source[j - 1] == pattern[i - 1]:
                        use_it = prev[j - 1]
                        if is_target[j - 1]:
                            use_it += 1
                        not_use_it = current[j - 1]
                        current[j] = min(use_it, not_use_it)
                    else:
                        current[j] = current[j - 1]
            prev, current = current, prev
        return len(targetIndices) - prev[n]",1420099608
ConstantineJin,ConstantineJin,198,3604,python3,"MOD = int(1e9 + 7)


def comb_mod(n, k, fact, inv_fact) -> int:
    if k < 0 or k > n:
        return 0
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD


def pow_mod(a, b) -> int:
    result = 1
    a = a % MOD
    while b > 0:
        if b % 2 == 1:
            result = result * a % MOD
        a = a * a % MOD
        b //= 2
    return result


class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mx = n + x
        fact = [1] * (mx + 1)
        inv_fact = [1] * (mx + 1)

        for i in range(1, mx + 1):
            fact[i] = fact[i - 1] * i % MOD
        inv_fact[mx] = pow_mod(fact[mx], MOD - 2)
        for i in range(mx - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        s = [[0] * (n + 1) for _ in range(n + 1)]
        s[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                s[i][j] = (s[i - 1][j - 1] + s[i - 1][j] * j) % MOD

        min_k = min(n, x)
        y_pow = [1] * (min_k + 2)
        for i in range(1, min_k + 2):
            y_pow[i] = y_pow[i - 1] * y % MOD

        ans = 0
        for k in range(1, min_k + 1):
            comb_xk = comb_mod(x, k, fact, inv_fact)
            stirling_nk = s[n][k]
            fact_k = fact[k]
            y_k = y_pow[k]
            term = comb_xk * stirling_nk % MOD
            term = term * fact_k % MOD
            term = term * y_k % MOD
            ans = (ans + term) % MOD

        return ans
",1420097011
ConstantineJin,ConstantineJin,198,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i, num in enumerate(nums):
            mn = -1
            for p in range(32):
                if (num & (1 << p)) != 0:
                    candidate = num & ~(1 << p)
                    if candidate >= 0 and (candidate | (candidate + 1)) == num:
                        if mn == -1 or candidate < mn:
                            mn = candidate
            ans[i] = mn
        return ans",1420101082
ConstantineJin,ConstantineJin,198,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i, num in enumerate(nums):
            mn = -1
            for p in range(32):
                if (num & (1 << p)) != 0:
                    candidate = num & ~(1 << p)
                    if candidate >= 0 and (candidate | (candidate + 1)) == num:
                        if mn == -1 or candidate < mn:
                            mn = candidate
            ans[i] = mn
        return ans",1420100938
Yohannes Degefa,ResilientWarrior,199,3487,python3,"
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
      
        table = [float('inf')] * (len(pattern) + 1)
        table[0] = 0
        targets = [False] * len(source)
        
        for i in targetIndices:
            targets[i] = True
        # print(targets)
        for i in range(len(source)):
            for j in range(len(pattern), 0, -1):
                if source[i] == pattern[j-1] and table[j-1] != float('inf'):
                    table[j] = min(table[j], table[j-1] + (1 if targets[i] else 0))
        #print(table)  
        return len(targetIndices) - (0 if table[len(pattern)] == float('inf') else table[len(pattern)])
",1420067968
Yohannes Degefa,ResilientWarrior,199,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:

     
     
        M = 10**9 + 7;C = [[0] * (x + 1) for _ in range(x + 1)];fring = [1] * (x + 1)
        
        for i in range(x + 1):
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % M
            C[i][0] = 1
        
        #print(C)
      
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        #print(S)
        for i in range(1, x + 1):
            fring[i] = fring[i - 1] * i % M

        for i in range(1, n + 1):
            for j in range(1, x + 1):
                #print(i, j, s[i][j])
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % M
        
    
        answer = 0
        for k in range(1, x + 1):
            pwr = 1
            for p in range(k):
                pwr = (pwr * y) % M

           
            answer = (answer + C[x][k] * S[n][k] % M * fring[k] % M * pwr % M) % M

        return answer",1420101528
Yohannes Degefa,ResilientWarrior,199,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            flag = False
           
            for i in range(num):
                if i | (i + 1) == num:
                    ans.append(i)
                    flag = True
                    break
                    
            if not flag:
                ans.append(-1)
        return ans",1419995186
Yohannes Degefa,ResilientWarrior,199,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        
        for i in range(n):
            num = nums[i];ss = float('inf');flag = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    zs = num & ~(1 << bit)
                    
                    if zs < 0:
                        continue
                    
                    if zs | (zs + 1) == num:
                        if zs < ss:
                            ss = zs
                            flag = True
            
            if flag:
                result[i] = ss
            else:
                result[i] = -1
        
        return result",1420058862
homeless_man,homeless_man,200,3487,cpp,"int dp[4000][4000];
class Solution {
    
public:
    
    map<int,int> f;
    
    int dfs(int pdx,int idx,string& p,string& s){
        if(idx == s.size())
            return (pdx == p.size()) ? 0 : -1e9;
        if(dp[pdx][idx] != -1)
            return dp[pdx][idx];
        int res = dfs(pdx,idx+1,p,s);
        if(f[idx])
            res = max(res,dfs(pdx,idx+1,p,s) + 1);
        
        if((pdx < p.size()) && (p[pdx] == s[idx]))
            res = max(res,dfs(pdx + 1,idx+1,p,s));
        
        return dp[pdx][idx] = res;
    }
    
    int maxRemovals(string s, string p, vector<int>& t) {
        for(int i = 0;i<=max(p.size(),s.size());i++)
            for(int j = 0;j<=max(p.size(),s.size());j++)
                dp[i][j] = -1;
        for(int i : t)
            f[i]++;
        return dfs(0,0,p,s);
    }
};",1420026461
homeless_man,homeless_man,200,3604,cpp,"class Solution {
public:
    
    long long stages;
    long long ys;
    long long mod = 1e9 + 7;
    
    long long dp[1001][1001];
    
    long long mypow(long long base, long long exp){
        if(exp <= 1)
            return exp ? base : 1;
        long long mid = mypow(base, exp/2);
        return ((mid * mid)%mod * (exp%2 ? base : 1))%mod;
    }
    
    long long dfs(long long n, long long stagesleft){
        long long taken = stages - stagesleft;
        if(n == 0){
            return mypow(ys, taken);
        }
        if(dp[n][stagesleft] != -1)
            return dp[n][stagesleft];
        // go to existing stage
        long long res = 0;
        if(taken > 0)
           res = (res + (taken * dfs(n-1, stagesleft)) % mod) % mod;
        if(stagesleft > 0)
            res = (res + (stagesleft * dfs(n-1, stagesleft-1) % mod)) % mod;
        return dp[n][stagesleft] = res;
    }
    
    int numberOfWays(int n, int x, int y) {
        memset(dp, -1, sizeof(dp));
        stages = x;
        ys = y;
        return dfs(n, x);
    }
};
",1420059244
homeless_man,homeless_man,200,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(int i : nums){
            if(i%2 == 0){
                res.push_back(-1);
            }
            else{
                for(int j = 0;j<=i;j++){
                    if((j | (j + 1)) == i){
                        res.push_back(j);
                        break;
                    }
                }
            }
        }
        return res;
    }
};",1420006686
homeless_man,homeless_man,200,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        //the 0th bit must be active
        vector<int> res;
        for(int i : nums){
            if(i%2 == 0){
                res.push_back(-1);
            }
            else{
                //you can take i - 1 as an answer always
                //case smaller number is even
                //then you have to go with i - 1
                //so try making the smaller number odd
                //we get (x + 1) | x = i
                //where x is odd
                //look at the carry over bit
                int msb = 0;
                for(int j = 0;j<30;j++){
                    if((1 << j) & i)
                        msb = j;
                    else
                        break;
                }
                msb++;
                if(msb == 1){
                    res.push_back(i-1);
                }
                else{
                    //these bist cannot be affected by adding one
                    int curr = 0;
                    for(int j = msb;j<30;j++){
                        curr |= (1 << j) & i;
                    }
                    for(int j = 0;j<msb-1;j++){
                        curr |= (1 << j);
                    }
                    res.push_back(curr);
                }
            }
        }
        return res;
    }
};",1420088179
i_will_beat_my_iq,i_will_beat_my_iq,202,3487,cpp,"class Solution {
public:
    int helper(string& s, string& t, unordered_map<int, int>& mp, int i, int j, vector<vector<int>>& dp) {
        if (i == t.length()) {
            return 0;
        }
        if (j == s.size()) {
            return s.length() + 1;
        }
        
        if (dp[i][j] != -1) {
            return dp[i][j];
        }
        
        int ans = helper(s, t, mp, i, j + 1, dp);
        
        if (t[i] == s[j]) {
            ans = min(ans, helper(s, t, mp, i + 1, j + 1, dp) + mp[j]);
        }
        
        return dp[i][j] = ans;
    }
    
    int maxRemovals(string s, string t, vector<int>& v) {
        unordered_map<int, int> mp;
        for (int i: v) 
        {
            mp[i] = 1;
        }
        
        vector<vector<int>> dp(t.length()+1, vector<int>(s.length()+1, -1));
        
        return v.size() - helper(s, t, mp, 0, 0, dp);
    }
};
",1420095669
i_will_beat_my_iq,i_will_beat_my_iq,202,3604,cpp,"class Solution {
public:
#define mod 1000000007
#define ll long long
vector<ll> p, v, b;

    void f1(int y, int x) {
        p[0] = 1;
        int j = 1;
        while (j <= x) {
            ll temp = p[j - 1] * y;
            p[j] = temp % mod;
            j++;
        }
    }

    void f2(int n, int x) {
        v[0] = 1;
        int i = 1;
        while (i <= n) {
            int j = (i < x) ? i : x;
            while (j >= 1) {
                ll temp1 = v[j] * j;
                v[j] = temp1 % mod;
                ll temp2 = v[j] + v[j - 1];
                v[j] = temp2 % mod;
                j--;
            }
            v[0] = 0;
            i++;
        }
    }

    void f3(int x) {
        b[0] = 1;
        int i = 1;
        while (i <= x) {
            ll temp = b[i - 1] * (x - i + 1);
            b[i] = temp % mod;
            i++;
        }
    }

    int numberOfWays(int n, int x, int y) {
        p.resize(1002, 0);
        v.resize(1002, 0);
        b.resize(1002, 0);

        f1(y, x);
        f2(n, x);
        f3(x);

        ll ct = 0;
        int j = 1;
        while (j <= min(x, n)) {
            ll temp1 = (b[j] * v[j]) % mod;   
            ll temp2 = (temp1 * p[j]) % mod;  
            ct = (ct + temp2) % mod;          
            j++;
        }

        return ct;
    }
};

",1420062866
i_will_beat_my_iq,i_will_beat_my_iq,202,3605,cpp,"class Solution {
public:
int func(int x){
    for(int i=1;i<=x;i++){
        if((i|(i+1)) == x){
            return i;
        }
    }
    return -1;
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            ret[i]=func(nums[i]);
        }
        return ret;
    }
};",1420011934
i_will_beat_my_iq,i_will_beat_my_iq,202,3611,cpp,"class Solution {
public:
int func(int x) {
        vector<int> candidates;
        int y = x;
        while (y > 0) {
            int lsb = y & -y;
            int bitPos = __builtin_ctz(lsb); 
            int candidate = x & (~(1 << bitPos));
            if ((candidate | (candidate + 1)) == x) {
                candidates.push_back(candidate);
            }
            y &= (y - 1);
        }     
        if (candidates.empty()) {
            return -1;
        }
        return *std::min_element(candidates.begin(), candidates.end());
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            ret[i]=func(nums[i]);
        }
        return ret;
    }
};",1420029040
atharv23456x,atharv23456x,204,3487,cpp,"#define ll long long
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n1 = source.size(), n2=pattern.size(), n3 = targetIndices.size();
        vector<ll> dp(n2+1, LLONG_MAX);
        dp[0]=0;
        unordered_map<ll ,ll> mp;
        for(ll i=0; i<n1; i++) mp[i]=0;
        for(ll i=0;i<n3;i++) mp[targetIndices[i]]=1;
        ll ans=n3;
        for(ll i=0; i<n1;i++){
            for(ll j=n2; j>=1; j--){
                if(dp[j-1]!=LLONG_MAX && pattern[j-1]==source[i]){
                    dp[j] = min(dp[j-1]+mp[i], dp[j]);
                }
            }
        }  
        if(dp[n2]!=LLONG_MAX) ans-=dp[n2];
        int finalans = ans;
        return finalans;

    }
};",1420082401
atharv23456x,atharv23456x,204,3604,cpp,"#define ll long long
#define MOD 1000000007
class Solution {
public:


int numberOfWays(int n, int x, int y) {
    vector<vector<long long>> ff(x + 1, vector<long long>(x + 1, 0));
    vector<vector<long long>> sa(n + 1, vector<long long>(x + 1, 0));
    vector<long long> fact(x + 1, 1);
    long long ans = 0;
    sa[0][0] = 1;
    for (int i = 1; i <= x; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    
    for (int i = 0; i <= x; ++i) {
        ff[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            ff[i][j] = (ff[i - 1][j - 1] + ff[i - 1][j]) % MOD;
        }
    }
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= x; ++j) {
            sa[i][j] = (j * sa[i - 1][j] + sa[i - 1][j - 1]) % MOD;
        }
    }
    

    for (int k = 1; k <= x; ++k) {
        long long power = 1;
        for (int p = 0; p < k; ++p) {
            power = (power * y) % MOD;
        }
        long long term = (ff[x][k] * sa[n][k] % MOD * fact[k] % MOD * power) % MOD;
        ans = (ans + term) % MOD;
    }
    int finalans = ans;
    
    return finalans;
}


};",1420062521
atharv23456x,atharv23456x,204,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int currans;
        bool milala;
        for(int i = 0; i < n; i++) {
            currans = INT_MAX;
            milala = false;
            
            for(int j = 0; j < 31; j++) {
                if (1 & (nums[i] >> j)) {
                    int cc = (~(1 << j)) & nums[i];
                    
                    if (cc > 0 && cc < currans && nums[i] == ((cc + 1) | cc)) {
                        milala = true;
                        currans = cc;
                    }
                }
            }
            
            if (milala==false) {
                ans[i] = -1;
            } else {
                ans[i] = currans;
            }
        }
        
        return ans;
    }
};",1420096037
atharv23456x,atharv23456x,204,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int currans;
        bool milala;
        for(int i = 0; i < n; i++) {
            currans = INT_MAX;
            milala = false;
            
            for(int j = 0; j < 31; j++) {
                if (1 & (nums[i] >> j)) {
                    int cc = (~(1 << j)) & nums[i];
                    
                    if (cc > 0 && cc < currans && nums[i] == ((cc + 1) | cc)) {
                        milala = true;
                        currans = cc;
                    }
                }
            }
            
            if (milala==false) {
                ans[i] = -1;
            } else {
                ans[i] = currans;
            }
        }
        
        return ans;
    }
};",1420095504
Frank Rodriguez,whynot4,205,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] inx) {
        dp = new int[source.length()][pattern.length()+1];
        for (int[] d : dp) {
            Arrays.fill(d, -1);
        }
        var set = new HashSet<Integer>();
        for (int i : inx) {
            set.add(i);
        }


        return solve(source.toCharArray(), pattern.toCharArray(), 0, 0, set);
    }

    int INVALID = -1000000;
    int[][] dp;

    int solve(char[] s, char[] p, int i, int j, HashSet<Integer> inx) {
        if (i == s.length) {
            if (j != p.length) {
                return INVALID;
            }
            return 0;
        }
        
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int ans = INVALID;
        if (inx.contains(i)) { // delete it
            ans = Math.max(ans, 1 + solve(s, p, i+1, j, inx));
        }

        ans = Math.max(ans, solve(s, p, i+1, j, inx)); // do nothing
        if (j < p.length && s[i] == p[j]) {
            ans = Math.max(ans, solve(s, p, i+1, j+1, inx));
        }
        return dp[i][j] = ans;
    }
}",1420042401
Frank Rodriguez,whynot4,205,3604,java,"class Solution {
    boolean debug = false;

    public int numberOfWays(int n, int x, int y) {
        long MOD = (int)1e9+7;
        long[][] C = buildPascalsTriangle(1001, MOD);
        long ans = 0;
        var dp = new long[n+1][x+1];
        dp[0][0] = 0;
        for (int i=1; i<dp.length; i++) {
            dp[i][1] = 1;
        }
        Arrays.fill(dp[0], 1);

        for (int i=1; i<=n; i++) {
            for (int j=2; j<=x; j++) {
                if (i < j) {
                    continue;
                }
                dp[i][j] = j * dp[i-1][j] % MOD;
                if (j > 0) {
                    dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD;    
                } else {
                    dp[i][j] = (dp[i][j] + (x - j) ) % MOD;
                }
            }
        }

        if (debug) {
            for (long[] d : dp) {
                System.out.println(Arrays.toString(d));
            }
        }

        long[] f = new long[1001];
        f[0] = 1;
        for (int i=1; i<f.length; i++) {
            f[i] = f[i-1] * i % MOD;
        }

        for (int i=1; i<=x; i++) { // num stages used
            long c = C[x][i] * f[i] % MOD;
            long people = dp[n][i];
            long score = modpow(y, i, MOD);
            if (debug) {
                System.out.println(""trying "" + i + "" stages: "");
                System.out.println("". chosing stages: "" + c);
                System.out.println("". people arrangements: "" + people);
                System.out.println("". score arrangements: "" + score);
            }
            ans = (ans + c * people % MOD * score % MOD) % MOD;
        }
        
        return (int)ans;
    }

    public static long modpow(long a, long b, long mod) {
        if (a == 0) {
            return 0;
        }
        if (a == 1) {
            return mod == 1 ? 0 : 1;
        }
        a %= mod;
        long ans = 1;
        while (b > 0) {
            if ((b & 1) == 1) {
                ans = (ans * a) % mod;
            }
            b >>= 1;
            a = a * a % mod; 
        }

        return ans;
    } 

    public static long[][] buildPascalsTriangle(int n, long MOD) {
        long[][] C = new long[n+1][n+1];
        for (int i=0; i<=n; i++) {
            C[i][0] = 1;
            for (int j=1; j<=i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }

        return C;
    }
}",1420102762
Frank Rodriguez,whynot4,205,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        var ans = new int[n];
        for (int i=0; i<n; i++) {
            if (nums.get(i) == 2) {
                ans[i] = -1;
                continue;
            }
            long val = nums.get(i);
            int j = 0;
            while (((val>>j)&1)==1) {
                j++;
            }
            j--;
            val ^= (1<<j);
            ans[i] = (int)val;
        }
        
        return ans;
    }
}",1420014321
Frank Rodriguez,whynot4,205,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        var ans = new int[n];
        for (int i=0; i<n; i++) {
            if (nums.get(i) == 2) {
                ans[i] = -1;
                continue;
            }
            long val = nums.get(i);
            int j = 0;
            while (((val>>j)&1)==1) {
                j++;
            }
            j--;
            val ^= (1<<j);
            ans[i] = (int)val;
        }
        
        return ans;
    }
}",1420013827
seryp,seryp,206,3487,cpp,"class Solution {
public:
    int cal(string &s, string &p, int a,int b,vector<vector<int>> &dp,vector<int> &vis){
        if(dp[a][b] != -1){
            return dp[a][b];
        }
        if(b > a){
            return dp[a][b] = -2;
        }
        if(a == 0){
            return dp[a][b] = 0;
        }
        if(b == 0){
            int ans = 0;
            if(vis[a-1]){
                ans++;
            }
            dp[a][b]= cal(s,p,a-1,0,dp,vis) + ans;
            return dp[a][b];
        }
        if(s[a-1] == p[b-1]){
            int x = cal(s,p,a-1,b-1,dp,vis);
            if(x != -2){
                if(dp[a][b] == -1 || x > dp[a][b]){
                    dp[a][b] = x;
                }
            }
        }

           int x = cal(s,p,a-1,b,dp,vis); 
           int y = vis[a-1];
           if(x !=-2){
                 if(dp[a][b] == -1 || x + y > dp[a][b]){
                     dp[a][b] = x + y;
                 }
           }
        if(dp[a][b] == -1){
            dp[a][b] = -2;
        }
        return dp[a][b];
    }
    int maxRemovals(string s, string p, vector<int>& tar) {
        int n = s.size(),m = p.size();
        vector<int> vis(n,0);
        for(auto x:tar){
            vis[x] = 1;
        }
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        int ans = cal(s,p,n,m,dp,vis);
        return ans;
        
    }
};",1420096339
seryp,seryp,206,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
       const int mod = 1e9 + 7;
       vector<vector<long long>> dp(n+1,vector<long long>(n+1,0));
       dp[1][1] = x; 
       long long ans = 0;
       for(int i = 2;i <=n;i++){
          dp[i][1] = x;
          for(int j = 2;j <= n && j <= x;j++){
             dp[i][j] = (dp[i-1][j-1] * (x -j + 1) + dp[i-1][j]*j) % mod;
          }
       }
       long long u = 1;
       for(int i = 1;i <= x && i <= n;i++){
          u *= y;
          u = u % mod;
          ans = (ans + dp[n][i] * u) % mod;
          
       }
       return ans;
    }
};",1420055236
seryp,seryp,206,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x:nums){
            if(x % 2 == 0){
                res.push_back(-1);
                continue;
            }
            long long tmp = x;
            long long key = 0;
            long long bit = 1;
            while(tmp & bit){
                bit *=2;
            }
            bit/=2;
            res.push_back(tmp-bit);
        }
        return res;       
    }
};",1420006598
seryp,seryp,206,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x:nums){
            if(x % 2 == 0){
                res.push_back(-1);
                continue;
            }
            long long tmp = x;
            long long key = 0;
            long long bit = 1;
            while(tmp & bit){
                bit *=2;
            }
            bit/=2;
            res.push_back(tmp-bit);
        }
        return res;
    }
};",1420005882
aminjonshermatov,aminjonshermatov,209,3487,cpp,"class Solution {
public:
  int maxRemovals(string s, string t, vector<int>& ids) {
    const auto n = int(ids.size());
    std::vector<bool> may(s.size(), false);
    for (auto id : ids) {
      may[id] = true;
    }
    std::vector<int> sf(s.size() + 1, 0);
    for (auto i = std::ssize(s) - 1, j = std::ssize(t) - 1; i >= 0; --i) {
      if (j >= 0 && s[i] == t[j]) {
        --j;
      }
      sf[i] = std::ssize(t) - j - 1;
    }
    std::vector cache(s.size(), std::vector(t.size() + 1, -1));
    auto dp = [&](auto&& self, int i, int len) -> int {
      if (i >= std::ssize(s)) {
        return 0;
      }
      auto& loc = cache[i][len];
      if (loc != -1) {
        return loc;
      }
      loc = 0;
      if (may[i] && len + sf[i + 1] >= std::ssize(t)) {
        loc = std::max(loc, self(self, i + 1, len) + 1);
      }
      if (len < std::ssize(t) && s[i] == t[len]) {
        loc = std::max(loc, self(self, i + 1, len + 1));
      } else {
        loc = std::max(loc, self(self, i + 1, len));
      }
      return loc;
    };
    return dp(dp, 0, 0);
  }
};",1420103554
aminjonshermatov,aminjonshermatov,209,3604,cpp,"template <int P> class Z {
  int x = 0;
  public:
  static_assert(P <= std::numeric_limits<int>::max() / 2);

  constexpr Z() noexcept = default;
  constexpr Z(long long y) noexcept : x(norm(y)) { }

  static constexpr int getMod() noexcept { return P; }
  [[nodiscard]] constexpr static int norm(long long y) noexcept {
    if (y < -getMod() || y >= getMod()) {
      y %= getMod();
    }
    if (y < 0) {
      y += getMod();
    }
    return static_cast<int>(y);
  }

  [[nodiscard]] constexpr int val() const noexcept { return x; }
  constexpr explicit operator int() const noexcept { return x; }

  constexpr Z operator-() const noexcept {
    return {getMod() - x};
  }
  [[nodiscard]] constexpr Z inverse() const noexcept {
    return pow(getMod() - 2);
  }

  constexpr Z& operator+=(Z other) noexcept {
    x = norm(x + other.val());
    return *this;
  }
  constexpr Z& operator-=(Z other) noexcept {
    x = norm(x - other.val());
    return *this;
  }
  constexpr Z& operator*=(Z other) noexcept {
    x = norm(x * 1LL * other.val());
    return *this;
  }
  constexpr Z& operator/=(Z other) noexcept {
    return *this *= other.inverse();
  }

  constexpr Z& operator++() noexcept {
    operator+=(1);
    return *this;
  }
  constexpr Z operator++(int) const noexcept {
    auto z = *this;
    ++(*this);
    return z;
  }
  constexpr Z& operator--() noexcept {
    operator-=(1);
    return *this;
  }
  constexpr Z operator--(int) const noexcept {
    auto z = *this;
    --(*this);
    return z;
  }

  constexpr Z operator+(Z other) const noexcept {
    return {x + other.val()};
  }
  constexpr Z operator-(Z other) const noexcept {
    return {x - other.val()};
  }
  constexpr Z operator*(Z other) const noexcept {
    return {x * 1LL * other.val()};
  }
  constexpr Z operator/(Z other) const noexcept {
    return other.inverse() * x;
  }

  constexpr bool operator==(Z other) const noexcept {
    return val() == other.val();
  }
  constexpr bool operator!=(Z other) const noexcept {
    return val() != other.val();
  }

  [[nodiscard]] Z pow(long long n) const {
    auto ret = Z(*this);
    Z res = 1;
    for (; n > 0; n >>= 1, ret *= ret) {
      if (n % 2 == 1) {
        res *= ret;
      }
    }
    return res;
  }

  friend std::istream& operator>>(std::istream& in, Z& z) {
    long long y;
    in >> y;
    z = Z{y};
    return in;
  }
  friend std::ostream& operator<<(std::ostream& out, const Z& z) {
    return out << z.val();
  }
};

constexpr int Mod = 1e9 + 7;
using Mint = Z<Mod>;

class Solution {
public:
  int numberOfWays(int n, int x, int y) {
    std::vector<Mint> dp(x + 1);
    dp[0] = 1;
    for (int i = 1; i <= x; ++i) {
      dp[i] = dp[i - 1] * y;
    }
    for (int i = n - 1; i >= 0; --i) {
      std::vector<Mint> ndp(x + 1);
      for (int j = 0; j <= x; ++j) {
        ndp[j] += dp[j] * j;
        if (j + 1 <= x) {
          ndp[j] += dp[j + 1] * (x - j);
        }
      }
      std::swap(dp, ndp);
    }
    return dp[0].val();
  }
};",1420057413
aminjonshermatov,aminjonshermatov,209,3605,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int>& as) {
    const auto n = int(as.size());
    std::vector<int> ret(n, 0);
    for (int i = 0; i < n; ++i) {
      bool f = false;
      for (int j = 0; j < 30; ++j) {
        if (as[i] >> j & 1) {
          ret[i] |= 1 << j;
        } else if (!f) {
          if (j > 0) {
            ret[i] ^= 1 << (j - 1);
          }
          f = true;
        }
      }
      if ((ret[i] | (ret[i] + 1)) != as[i]) {
        ret[i] = -1;
      }
    }
    return ret;
  }
};",1420077702
aminjonshermatov,aminjonshermatov,209,3611,cpp,"class Solution {
public:
  vector<int> minBitwiseArray(vector<int>& as) {
    const auto n = int(as.size());
    std::vector<int> ret(n, 0);
    for (int i = 0; i < n; ++i) {
      bool f = false;
      for (int j = 0; j < 30; ++j) {
        if (as[i] >> j & 1) {
          ret[i] |= 1 << j;
        } else if (!f) {
          if (j > 0) {
            ret[i] ^= 1 << (j - 1);
          }
          f = true;
        }
      }
      if ((ret[i] | (ret[i] + 1)) != as[i]) {
        ret[i] = -1;
      }
    }
    return ret;
  }
};",1420078056
Abhishek Choudhary,theabbie,210,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        v = [0] * n
        for i in targetIndices:
            v[i] = 1
        dp = [float('-inf')] * (m + 1)
        ndp = [float('-inf')] * (m + 1)
        dp[m] = 0
        for i in range(n - 1, -1, -1):
            for j in range(m + 1):
                if j < m and source[i] == pattern[j]:
                    ndp[j] = dp[j + 1]
                ndp[j] = max(ndp[j], v[i] + dp[j])
            dp, ndp = ndp, dp
        return dp[0]",1420022791
Abhishek Choudhary,theabbie,210,3604,python3,"M = 10 ** 9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        k = min(n, x)
        dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]
        for i in range(k + 1):
            dp[i][i] = 1
        for i in range(1, k + 1):
            for j in range(i + 1, n + 1):
                dp[i][j] = (i * dp[i][j - 1] + dp[i - 1][j - 1]) % M
        res = 0
        v = x * y
        for choose in range(1, k + 1):
            res += dp[choose][n] * v
            v *= y * (x - choose)
            v %= M
            res %= M
        return res",1420097076
Abhishek Choudhary,theabbie,210,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            x = nums[i]
            b = 0
            while nums[i] & (1 << b):
                b += 1
            if b:
                x &= ~(1 << (b - 1))
            if x | (x + 1) == nums[i]:
                nums[i] = x
            else:
                nums[i] = -1
        return nums",1420039641
Abhishek Choudhary,theabbie,210,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for i in range(len(nums)):
            x = nums[i]
            b = 0
            while nums[i] & (1 << b):
                b += 1
            if b:
                x &= ~(1 << (b - 1))
            if x | (x + 1) == nums[i]:
                nums[i] = x
            else:
                nums[i] = -1
        return nums",1420039188
hero777,hero777,212,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> x(pattern.length() + 1, -1);
        x[0] = 0;
        int index = 0;
        for(int i = 0; i < source.length(); i++){
            // cout << i << ""x\n"";
            // for(int j = 0; j < pattern.length() + 1; j++)
            //     cout << x[j] << '\n';
            if(index < targetIndices.size() && targetIndices[index] == i){
                vector<int> xx(pattern.length()+1, 0);
                xx[0] = x[0] + 1;
                for(int j = 1; j < pattern.length() + 1; j++){
                    if(x[j] == -1){
                        if(pattern[j-1] == source[i]){
                            xx[j] = x[j-1];
                        }
                        else{
                            xx[j] = x[j];
                        }
                    }
                    else{
                        if(pattern[j-1] == source[i]){
                            xx[j] = max(x[j-1], x[j] + 1);
                        }
                        else{
                            xx[j] = x[j] + 1;
                        }
                    }
                }
                x = xx;
                index++;
                continue;
            }
            else{
                vector<int> xx(pattern.length()+1, 0);
                xx[0] = x[0];
                for(int j = 1; j < pattern.length() + 1; j++){
                    if(pattern[j-1] == source[i]){
                        xx[j] = x[j-1];
                    }
                    else{
                        xx[j] = x[j];
                    }
                }
                x = xx;
            }
        }
        return x.back();
    }
};",1420103756
hero777,hero777,212,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        long long mod = 1e9 + 7;
        vector<long long> z(x+1, 0);
        z[1] = x;
        for(int i = 1; i < n; i++){
            vector<long long> zz(x+1, 0);
            zz[1] = x;
            for(int j = 2; j <= x; j++){
                zz[j] = z[j-1]*(x-j+1) + z[j]*j;
                zz[j] %= mod;
            }
            z = zz;
        }
        long long yy = y;
        long long ans = 0LL;
        for(int i = 1; i <= x; i++){
            ans += z[i]*yy;
            ans %= mod;
            yy *= y;
            yy %= mod;
        }
        return ans;
    }
};",1420055486
hero777,hero777,212,3605,cpp,"class Solution {
public:
    int foo(int x){
        int y = x;
        int r = 1;
        while(true){
            if(y % 2 == 0){
                x -= r/2;
                break;
            }
            y /= 2;
            r *= 2;
        }
        return x;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i: nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(foo(i));
        }
        return ans;
    }
};",1420014812
hero777,hero777,212,3611,cpp,"class Solution {
public:
    int foo(int x){
        int y = x;
        int r = 1;
        while(true){
            if(y % 2 == 0){
                x -= r/2;
                break;
            }
            y /= 2;
            r *= 2;
        }
        return x;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i: nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(foo(i));
        }
        return ans;
    }
};",1420013944
QzjkuhhQ17,QzjkuhhQ17,213,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int m = s.size(),n=p.size();
        vector<int> tt(m);
        for(int i:t) tt[i]=true;
        vector<int> skip(n+1,-1);
        skip[0]=0;
        for(int i=0;i<m;i++){
            for(int j=n-1;j>=0;j--) {
                if(skip[j]!=-1 && p[j]==s[i]) skip[j+1]=max(skip[j],skip[j+1] + tt[i]);
                else if(skip[j+1]!=-1) skip[j+1]+=tt[i];
            }
            skip[0]+=tt[i];
            // for(int j:skip) cout << j << ' ';
            // cout << '\n';
        }
        return skip[n];
    }
};",1420103840
QzjkuhhQ17,QzjkuhhQ17,213,3604,cpp,"template <typename T> T mod_inv_in_range(T a, T m) {
  // assert(0 <= a && a < m);
  T x = a, y = m;
  // coeff of a in x and y
  T vx = 1, vy = 0;
  while (x) {
    T k = y / x;
    y %= x;
    vy -= k * vx;
    std::swap(x, y);
    std::swap(vx, vy);
  }
  assert(y == 1);
  return vy < 0 ? m + vy : vy;
}
template <int MOD_> struct modnum {
    static constexpr int MOD = MOD_;
    static_assert(MOD_ > 0, ""MOD must be positive"");

private:
    int v;

public:

    modnum() : v(0) {}
    modnum(int64_t v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
    explicit operator int() const { return v; }
    friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
    friend std::istream& operator >> (std::istream& in, modnum& n) { int64_t v_; in >> v_; n = modnum(v_); return in; }

    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

    modnum inv() const {
        modnum res;
        res.v = mod_inv_in_range(v, MOD);
        return res;
    }
    friend modnum inv(const modnum& m) { return m.inv(); }
    modnum neg() const {
        modnum res;
        res.v = v ? MOD-v : 0;
        return res;
    }
    friend modnum neg(const modnum& m) { return m.neg(); }

    modnum operator- () const {
        return neg();
    }
    modnum operator+ () const {
        return modnum(*this);
    }

    modnum& operator ++ () {
        v ++;
        if (v == MOD) v = 0;
        return *this;
    }
    modnum& operator -- () {
        if (v == 0) v = MOD;
        v --;
        return *this;
    }
    modnum& operator += (const modnum& o) {
        v -= MOD-o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator -= (const modnum& o) {
        v -= o.v;
        v = (v < 0) ? v + MOD : v;
        return *this;
    }
    modnum& operator *= (const modnum& o) {
        v = int(int64_t(v) * int64_t(o.v) % MOD);
        return *this;
    }
    modnum& operator /= (const modnum& o) {
        return *this *= o.inv();
    }

    friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
    friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        //1 band -> 3 -> 4
        //2 band -> 3C2 * 2^3 - 3 - 3= 18-> 4^2
        //3 band -> 3C3 * 3^3 - 3C2 * 2^3 = 6 -> 4^3
        const int mod = 1'000'000'007;
        using num=modnum<mod>;
        vector<vector<num>> s(n+1,vector<num>(x+1));
        s[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x;j++) s[i][j]=s[i-1][j-1]+j*s[i-1][j];
        }
        // for(int i=1;i<=n;i++){
        //     for(int j=1;j<=x;j++) cout << (int)s[i][j]<< ' ';
        //     cout << '\n';
        // }
        vector<num> fact(1001);
        fact[0]=1;
        for(int i=1;i<1001;i++)fact[i]=fact[i-1]*i;
        num py=y,re=0;
        for(int i=1;i<=x;i++){
            re+=s[n][i] *fact[i]*fact[x]/fact[i]/fact[x-i] * py;
            py*=y;
        }
        return (int)re;
    }
};",1420069313
QzjkuhhQ17,QzjkuhhQ17,213,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> re;
        for(int i:nums){
            if(i==2){
                re.push_back(-1);
                continue;
            }
            int b=0;
            while(i&1){
                b++;i/=2;
            }
            if(!i) re.push_back((1<<(b-1))-1);
            else re.push_back((i<<b) + (1<<(b-1)) - 1);
            
        }
        return re;
    }
};",1420010726
QzjkuhhQ17,QzjkuhhQ17,213,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> re;
        for(int i:nums){
            if(i==2){
                re.push_back(-1);
                continue;
            }
            int b=0;
            while(i&1){
                b++;i/=2;
            }
            if(!i) re.push_back((1<<(b-1))-1);
            else re.push_back((i<<b) + (1<<(b-1)) - 1);
            
        }
        return re;
    }
};",1420010961
yc-li,yc-li,214,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        unordered_set<int> ts(t.begin(), t.end());
        auto n = s.size(), m = p.size();  
        // cout << n << m;      
        vector<vector<int>> d(n + 1, vector<int>(m + 1, -99999));

        // for (auto j = 0; j < m; ++j)
        // {
        //     d[n][j] = -99999;
        // }
        d[n][m] = 0;

        for (int i = n; i --> 0; )
        {
            for (int j = m + 1; j --> 0; )
            {
                if (j < m && s[i] == p[j])
                    d[i][j] = max(d[i][j], d[i + 1][j + 1]);
                
                d[i][j] = max(d[i][j], d[i + 1][j]);

                if (ts.contains(i))
                    d[i][j] = max(d[i][j], d[i + 1][j] + 1);
            
                // cout << i << "" "" << j << "" "" << d[i][j] << ""\n"";
            }
        }

        return d[0][0];

    }
};",1420046107
yc-li,yc-li,214,3604,python3,"C = [[1 for j in range(i + 1)] for i in range(1001)]
MOD = 10**9 + 7

for i in range(1, 1001):
    for j in range(1, i):
        C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

class Solution:
    
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        ans = 0
        prev = [0] * 1001
        coef = 1
        grps = 0


        for i in range(1, x + 1):
            # ans += binomial
            coef = (coef * y) % MOD
            grps = pow(i, n, MOD)

            for j in range(1, i):
                # print(i, j, C[i][j], grps)
                grps -= ((C[i][j] * prev[j]) % MOD)
                # print(i, j, C[i][j], prev[j], grps)

            prev[i] = grps
            grps = (grps * C[x][i]) % MOD
            ans += ((coef * grps) % MOD)
            ans %= MOD

            # print(prev[:i + 1], coef, grps)
        return ans
",1420104015
yc-li,yc-li,214,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        ans = []

        for i in nums:
            s = list(bin(i)[2:])
            if s[-1] == ""0"":
                ans.append(-1)
                continue
            
            k = len(s) - 1
            while k >= 0 and s[k] == ""1"":
                k -= 1
            
            s[k + 1] = ""0""
            # print(s)
            ans.append(int("""".join(s), 2))

        return ans

",1420007984
yc-li,yc-li,214,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)

        ans = []

        for i in nums:
            s = list(bin(i)[2:])
            if s[-1] == ""0"":
                ans.append(-1)
                continue
            
            k = len(s) - 1
            while k >= 0 and s[k] == ""1"":
                k -= 1
            
            s[k + 1] = ""0""
            # print(s)
            ans.append(int("""".join(s), 2))

        return ans

",1420007657
Amandeep Verma,aman_2005,215,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    string a,b;
    int n,m;
    int vis[3001];
    
    int help(int i,int j){
        if(i==n){
            return (j==m ? 0 : 1e4);
        }
        if(j==m){
            return 0;
        }
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        int ans=1e4;
        if(a[i]==b[j]){
            ans=vis[i]+help(i+1,j+1);
        }
        ans=min(ans,help(i+1,j));
        return dp[i][j]=ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& target) {
        a=source,b=pattern;
        n=a.size(),m=b.size();
        for(int i=0;i<n;i++){
            vis[i]=0;
            for(int j=0;j<m;j++){
                dp[i][j]=-1;
            }
        }
        for(auto x:target){
            vis[x]=1;
        }
        int ans=help(0,0);
        int sz=target.size();
        return sz-ans;
    }
};",1420030286
Amandeep Verma,aman_2005,215,3604,cpp,"#define ll long long
#define mod 1000000007
class Solution {
public:
    ll mul(ll a, ll b)
    {
        return ((a % mod) * (b % mod)) % mod;
    }

    ll add(ll a, ll b)
    {
        return ((a % mod) + (b % mod)) % mod;
    }
    
    ll sub(ll a, ll b)
    {
        return (a - b + mod) % mod;
    }
    
    ll fastpow(ll a, ll p){
        ll res = 1;
        while (p){
            if (p % 2 == 0){
                a = a * 1ll * a % mod;
                p /= 2;
            }
            else{
                res = res * 1ll * a % mod;
                p--;  
            }
        }
        return res;
    }
    
    ll fac[1001];
    void fact(ll n)
    {
        ll res = 1;
        fac[0]=1;
        for (ll i = 1; i <= n; i++)
        {
            res = res * 1ll * i % mod;
            fac[i]=res;
        }
    }
    
    ll comb(ll n, ll k)
    {
        if(k>n){
            return 0;
        }
        return fac[n] * 1ll * fastpow(fac[k], mod - 2) % mod * 1ll * fastpow(fac[n - k], mod - 2) % mod;
    }
    
    ll help(ll i,ll left,ll x){
        if(i==x){
            return (left==0);
        }
        // if(dp[i][left]!=-1){
        //     return dp[i][left];
        // }
        if(left==0){
            return 0;
        }
        ll ans=0;
        for(ll j=1;j<=left;j++){
            ans=add(ans,mul(comb(left,j),help(i+1,left-j,x)));
        }
        return ans;
    }
    
    ll help(ll n,ll k){
        ll ans = 0;
        for(ll i=k;i>=0;i--){
            if(i%2==k%2){
                ans=add(ans,mul(fastpow(i,n),comb(k,i)));
            }
            else{
                ans=sub(ans,mul(fastpow(i,n),comb(k,i)));
            }
        }
        return ans;
    }
 
    int numberOfWays(int n, int x, int y) {
        fact(max(x,n));
        ll ans=0;
        for(ll i=1;i<=x;i++){
            if(n<i){
                continue;
            }
            ll choose=comb(x,i);
            ll score_ways=fastpow(y,i);
            ll ways=help(n,i);
            // cout<<choose<<"" ""<<score_ways<<"" ""<<ways<<""\n"";
            ans=add(ans,mul(mul(1,choose),mul(score_ways,ways)));
        }
        return ans;
    }
};",1420097540
Amandeep Verma,aman_2005,215,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x:nums){
            if(x%2){
                int bit=0;
                for(int i=0;i<=30;i++){
                    if((x & (1<<i))>0){
                        bit=i;
                    }
                    else{
                        break;
                    }
                }
                int tmp=0;
                for(int i=0;i<bit;i++){
                    tmp+=(1<<i);
                }
                for(int i=bit+1;i<=30;i++){
                    if((x & (1<<i))>0){
                        tmp+=(1<<i);
                    }
                }
                ans.push_back(tmp);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420006185
Amandeep Verma,aman_2005,215,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x:nums){
            if(x%2){
                int bit=0;
                for(int i=0;i<=30;i++){
                    if((x & (1<<i))>0){
                        bit=i;
                    }
                    else{
                        break;
                    }
                }
                int tmp=0;
                for(int i=0;i<bit;i++){
                    tmp+=(1<<i);
                }
                for(int i=bit+1;i<=30;i++){
                    if((x & (1<<i))>0){
                        tmp+=(1<<i);
                    }
                }
                ans.push_back(tmp);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420006682
AKJ003,AKJ003,216,3487,cpp,"class Solution {
public:
     long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    int findMinimalX(int target) {
       if (target == 2) return -1;

        int candidate = (1 << (31 - __builtin_clz(target))) - 1;

        if (candidate < target) {
            return candidate;
        }

        // If not valid, return -1
        return -1;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420075347
AKJ003,AKJ003,216,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
     long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    int findMinimalX(int target) {
       if (target == 2) return -1;

        int candidate = (1 << (31 - __builtin_clz(target))) - 1;

        if (candidate < target) {
            return candidate;
        }

        // If not valid, return -1
        return -1;
    }


    int numberOfWays(int n, int x, int y) {
        
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420104145
AKJ003,AKJ003,216,3605,cpp,"class Solution {
public:
    long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) { // If exp is odd
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); 
        for (int i = 0; i < nums.size(); ++i) {
            int target = nums[i];
            for (int x = 0; x < target; ++x) {
                if ((x | (x + 1)) == target) {
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};",1419995493
AKJ003,AKJ003,216,3611,cpp,"#include <vector>
#include <cmath>

class Solution {
public:
    long long binExp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    int findMinimalX(int target) {
       if (target == 2) return -1;

        int candidate = (1 << (31 - __builtin_clz(target))) - 1;

        if (candidate < target) {
            return candidate;
        }

        // If not valid, return -1
        return -1;
    }

    vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; ++bit) {
                if ((num >> bit) & 1) { 
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};
",1420041260
Huzaifa Khilawala,RedHeadphone,217,3487,python3,"

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        suffix_dp = [0] * n
        
        pattern_stack = list(pattern)
        for i in range(n-2, -1, -1):
            to_add = 0
            if len(pattern_stack) > 0 and source[i+1] == pattern_stack[-1]:
                to_add = 1
                pattern_stack.pop()
            suffix_dp[i] = suffix_dp[i+1]+to_add

        dp = [[-math.inf]*(m +1)
              for _ in range(2)]
        dp[0][0] = 0
        dp[1][0] = 0
        ans = 0

        targetIndices_set = set(targetIndices)

        for i in range(n):

            for j in range(m,-1,-1):
                if j + suffix_dp[i] >= m and dp[0][j] != -math.inf and i in targetIndices_set:
                    dp[1][j] = max(dp[1][j], dp[0][j] + 1)
                    ans = max(ans, dp[1][j])
                if j < m:
                    if source[i]==pattern[j]:
                        dp[1][j+1] = max(dp[1][j+1], dp[0][j])
            dp[0], dp[1] = dp[1], dp[0]
            for j in range(m+1):
                dp[1][j] = max(dp[1][j],-math.inf,dp[0][j])
        return ans ",1420055496
Huzaifa Khilawala,RedHeadphone,217,3604,python3,"
class Combinatorics:
    def __init__(self, pre_compute_limit=0):
        self.fact = [1] * pre_compute_limit
        self.invfact = [1] * pre_compute_limit
        for i in range(1, pre_compute_limit):
            self.fact[i] = (self.fact[i - 1] * i) % MOD
            self.invfact[i] = (self.invfact[i - 1] * pow(i, MOD - 2, MOD)) % MOD

    def ncr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[r] * self.invfact[n - r]) % MOD

    def npr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[n - r]) % MOD

    def ncr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = den = 1
        for i in range(r):
            num = (num * (n - i)) % MOD
            den = (den * (i + 1)) % MOD
        return (num * pow(den, MOD - 2, MOD)) % MOD

    def npr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = 1
        for i in range(n, n - r, -1):
            num = (num * i) % MOD
        return num


MOD = 10**9 + 7
comb = Combinatorics(1000 + 50)

fact = [1] * (1000 + 50)
for i in range(1, 1000 + 50):
    fact[i] = (fact[i - 1] * i) % MOD

def stirling_second_kind(n, k):
    stirling_num = 0
    for i in range(k+1):
        stirling_num += (pow(-1,k-i,MOD) * comb.ncr(k, i) * pow(i,n,MOD)) % MOD
    # stirling_num //= fact[k]
    return stirling_num

def distributions_non_empty_buckets(n, x):
    if x > n:
        return 0 
    return ( stirling_second_kind(n, x)) %  MOD

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0

        for stage_sel in range(1, x+1):
            curr = distributions_non_empty_buckets(n, stage_sel) 
            ans += curr * pow(y, stage_sel, MOD) * comb.ncr(x, stage_sel)
            ans %= MOD

        return ans",1420090804
Huzaifa Khilawala,RedHeadphone,217,3605,python3,"
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            if i == 2:
                ans.append(-1)
            else:
                binn = list(bin(i)[2:])
                last_ones = 0
                for i in range(len(binn)):
                    if binn[-i - 1] == ""1"":
                        last_ones +=1
                    else:
                        break
                
                if last_ones != 0:
                    binn[-(last_ones-1)-1] = ""0""
                
                ans.append(int("""".join(binn), 2))
        return ans",1420003600
Huzaifa Khilawala,RedHeadphone,217,3611,python3,"
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            if i == 2:
                ans.append(-1)
            else:
                binn = list(bin(i)[2:])
                last_ones = 0
                for i in range(len(binn)):
                    if binn[-i - 1] == ""1"":
                        last_ones +=1
                    else:
                        break
                
                if last_ones != 0:
                    binn[-(last_ones-1)-1] = ""0""
                
                ans.append(int("""".join(binn), 2))
        return ans",1420004062
Ankit Anand,ankitanand2125,218,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const int n = source.size();
        const int m = pattern.size();
        const int K = n + 1;
        
        vector<bool> result(n, false);
        for(auto i: targetIndices){
            result[i] = true;
        }
        
        vector<int> dp(m + 1, K);
        dp[0] = 0; 
        
        for(int s = 0; s < n; s++){
            for(int p = min(m, s + 1); p >= 1; p--){
                if(source[s] == pattern[p - 1]){
                    if(result[s]){
                        dp[p] = min(dp[p], dp[p - 1] + 1);
                    }
                    else{
                        dp[p] = min(dp[p], dp[p - 1]);
                    }
                }
            }
        }
        
        if(dp[m] > targetIndices.size()){
            return 0;
        }
    
        return targetIndices.size() - dp[m];
    }
};
",1420084743
Ankit Anand,ankitanand2125,218,3604,cpp,"const int MOD = 1e9 + 7;

long long pw(long long a, long long b) {
    long long res = 1;
    a %= MOD;
    while(b > 0){
        if(b & 1){
            res = res * a % MOD;
        }
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int mx = 1000;
        vector<long long> fact(mx + 1, 1);
        for(int i = 1; i <= mx; i++) fact[i] = fact[i-1] * i % MOD;
        

        vector<long long> inv_f(mx + 1, 1);
        inv_f[mx] = pw(fact[mx], MOD - 2);
        for(int i = mx - 1; i >= 0; i--) inv_f[i] = inv_f[i+1] * (i + 1) % MOD;
        

        vector<int> inp = {n, x, y};
        

        vector<long long> S_prev(x + 1, 0), S_curr(x + 1, 0);
        S_prev[0] = 1; 
        for(int i = 1; i <= n; i++) {
            S_curr.assign(x + 1, 0);
            for(int k = 1; k <= min(i, x); k++) {
                S_curr[k] = (S_prev[k-1] + k * S_prev[k]) % MOD;
            }
            S_prev = S_curr;
        }
        

        vector<long long> y_p(x + 1, 1);
        for(int k = 1; k <= x; k++) y_p[k] = y_p[k-1] * y % MOD;
        

        long long res = 0;
        for(int k = 1; k <= min(x, n); k++) {
            long long C = fact[x] * inv_f[k] % MOD;
            C = C * inv_f[x - k] % MOD;
            
            long long S = S_prev[k];
            long long kf = fact[k];
            long long yp = y_p[k];
            
            long long tmp = C * S % MOD;
            tmp = tmp * kf % MOD;
            tmp = tmp * yp % MOD;
            res = (res + tmp) % MOD;
        }
        
        return (int) res;
    }
};
",1420090983
Ankit Anand,ankitanand2125,218,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        const int N = 1000;
        const int n = nums.size();
        map<int, pair<int, int>> record;
        
        for(int i = 1; i <= N; ++i) {
            int val = i | (i + 1);
            if(record.find(val) == record.end()) {
                record[val] = {i, i + 1};
            }
        }
        
        vector<int> result;
        for(int i = 0; i < n; ++i) {
            if(record.find(nums[i]) != record.end()) {
                pair<int, int> rec = record[nums[i]];
                
                result.push_back(rec.first);
            }
            else {
                result.push_back(-1);
            }
        }
        
        return result;
    }
};",1420016250
Ankit Anand,ankitanand2125,218,3611,cpp,"class Solution {
    
public:
    std::string decimalToBinary(int decimal) {
        if (decimal == 0) {
            return ""0"";
        }

        std::string binary = """"; 
        while (decimal > 0) {
            binary = std::to_string(decimal % 2) + binary;
            decimal /= 2; 
        }

        return binary; 
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> result(n);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            if(num % 2 == 0) {
                result[i] = -1;
                continue;
            }
            
            string curr = decimalToBinary(num);
            reverse(curr.begin(), curr.end());
            int index = 0;
            while(index < curr.size() && curr[index] == '1') index++;
            
            int maxVal = (1 << index) - 1;
            int val = nums[i] - maxVal + (maxVal / 2);
            
            // cout << val << "" "" << maxVal << endl;
            
            for(int j = -5; j < 5; ++j) {
                int prev = val + j, next = prev | (prev + 1);
                if(next == num) {
                    result[i] = prev;
                    break;
                }
            }
        }
        
        return result;
    }
};",1420061979
zsq007,zsq007,219,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m, tar = len(source), len(pattern), set(targetIndices)

        dp = [0] + [-inf]*m 
        for i,c in enumerate(source):
            if i in tar:
                for j in range(m, 0, -1):
                    if pattern[j-1] == c:
                        dp[j] = max(dp[j]+1, dp[j-1])
                    else:
                        dp[j] += 1
                dp[0] += 1
            else:
                for j in range(m, 0, -1):
                    if pattern[j-1] == c:
                        dp[j] = max(dp[j], dp[j-1])
            # print(dp)
        return dp[-1]",1420027023
zsq007,zsq007,219,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        res, mod = 0, 10**9+7

        combs = [[1]+[0]*x for _ in range(x+1)]

        for i in range(1, x+1):
            for j in range(1, i+1):
                combs[i][j] = (combs[i-1][j-1] + combs[i-1][j]) % mod

        dp = [0]*(x+1)

        for stage in range(1, x+1):
            dp[stage] = (pow(stage, n, mod) - sum(dp[i] * combs[stage][i] % mod for i in range(stage))) % mod

        # print(dp)
        p = 1
        for stage in range(1, min(n, x)+1):
            cur = (combs[x][stage] * dp[stage]) % mod
            p = p * y % mod
            # print(empty, cur, grades, res)
            res += cur * p % mod
            # res += (comb(x, empty) % mod) * (pow(x-empty, n, mod) % mod) * pow(y, x-empty, mod) % mod
        
        return res % mod",1420091014
zsq007,zsq007,219,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if num == 2:
                res.append(-1)
            else:
                i = 0
                while num & 1<<i:
                    i += 1
                num ^= 1 << i-1
                res.append(num)
        return res",1419998007
zsq007,zsq007,219,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if num == 2:
                res.append(-1)
            else:
                i = 0
                while num & 1<<i:
                    i += 1
                num ^= 1 << i-1
                res.append(num)
        return res",1419998463
xymabinogi,xymabinogi,221,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& idx) {
         int n = s.length(), m = p.length();
        vector<int> suf(n + 2, 0);
        
//         for (int i = n - 1, j = m - 1; i >= 0; i--){
//             if (j >= 0 and s[i] == p[j]){
//                 j--;
//             }
//             suf[i + 1] = max(suf[i + 2], m - 1 - j);
//         }
        
        unordered_set<int> seen(idx.begin(), idx.end());
        
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, -1));
        
        dp[0][0] = 0;
        
        for (int i = 0; i <= m; i++){
            for (int j = 0; j < n; j++){
                if (dp[i][j] == -1) continue;
                
                if (i < m and p[i] == s[j]){
                    //don't remove
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                    
                    // if (suf[j + 1] >= m - j){ //ok to remove
                    //     dp[i][j + 1] = dp[i][j] + (seen.count(j) ? 1 : 0);
                    // }
                    // else dp[i][j + 1] = dp[i][j];
                }
                dp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + (seen.count(j) ? 1 : 0));
                // else {
                //     dp[i][j + 1] = dp[i][j] + (seen.count(j) ? 1 : 0);
                // }
                
            }
        }
//         for (int i = 0; i <= m; i++){
//             for (int j = 0; j < n; j++){
//                 cout << dp[i][j] << "" \n""[j == n - 1];       
//             }
//         }
        
        
        
        return dp[m][n];
        
        
    }
};",1420096618
xymabinogi,xymabinogi,221,3604,cpp,"using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1E9 + 7;
using Z = MInt<P>;
 
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<Z>> S(n + 1, vector<Z>(x + 1, Z(0)));
        S[0][0] = Z(1);
        for(int i = 1; i <= n; ++i){
            for(int k = 1; k <= min(i, x); ++k){
                S[i][k] = Z(k) * S[i-1][k] + S[i-1][k-1];
            }
        }
        Z res = Z(0);
        int max_k = min(x, n);
        for(int k = 1; k <= max_k; ++k){
            Z term = comb.binom(x, k) * S[n][k] * comb.fac(k) * power(Z(y), k);
            res += term;
        }
        return res.val();
    }
};",1420104426
xymabinogi,xymabinogi,221,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> res;
        for (auto v : nums){
            if (v == 2) {
                res.push_back(-1);
                continue;
            }
            int left = 0;
            for (int i = 0; i <= 30; i++){
                if (1 & (v >> i)) left = i;
                else break;
            }
            //cout << left << ""\n"";
            if (left == 0){
                res.push_back(v - 1);
            }
            else {
                int x = (v >> (left + 1)) << (left + 1);
                x += (1 << left) - 1;
                res.push_back(x);
                
            }

        }
        return res;
    }
};",1420022909
xymabinogi,xymabinogi,221,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        
        vector<int> res;
        for (auto v : nums){
            if (v == 2) {
                res.push_back(-1);
                continue;
            }
            int left = 0;
            for (int i = 0; i <= 30; i++){
                if (1 & (v >> i)) left = i;
                else break;
            }
            //cout << left << ""\n"";
            if (left == 0){
                res.push_back(v - 1);
            }
            else {
                int x = (v >> (left + 1)) << (left + 1);
                x += (1 << left) - 1;
                res.push_back(x);
                
            }

        }
        return res;
    }
};",1420022637
JeffreyLC,JeffreyLC,222,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const int n = source.length();
        const int m = pattern.length();
        vector<bool> target(n);
        for (int idx : targetIndices) {
            target[idx] = true;
        }
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MIN));
        dp[0][0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= m; ++j) {
                if (dp[i][j] != INT_MIN) {
                    dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + (target[i] ? 1 : 0));
                }
            }
            for (int j = 0; j < m; ++j) {
                if (source[i] == pattern[j] && dp[i][j] != INT_MIN) {
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j]);
                }
            }
        }
        return dp[n][m];
    }
};",1420062960
JeffreyLC,JeffreyLC,222,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        constexpr int MOD = 1e9 + 7;
        vector<vector<int>> pascal = PascalTriangle(x, MOD);
        vector<long long> cnt(x + 1);
        for (int i = 1; i <= x; ++i) {
            cnt[i] = BigMod(i, n, MOD);
            for (int r = i - 1; r >= 1; --r) {
                cnt[i] -= cnt[r] * pascal[i][r];
                cnt[i] %= MOD;
                cnt[i] += MOD;
                cnt[i] %= MOD;
            }
        }
        long long ans = 0;
        for (int i = 1; i <= x; ++i) {
            ans += cnt[i] * pascal[x][i] % MOD * BigMod(y, i, MOD);
            ans %= MOD;
        }
        return ans;
        
    }
private:
    vector<vector<int>> PascalTriangle(int n, int mod) {
        vector<vector<int>> pascal_triangle;
        vector<int> row;
        for (int i = 0; i <= n; ++i) {
            row.push_back(1 % mod);
            for (int j = i - 1; j > 0; --j) {
                row[j] = (row[j - 1] + row[j]) % mod;
            }
            pascal_triangle.push_back(row);
        }
        return pascal_triangle;
    }
    
    int BigMod(long long a, long long p, int mod) {
        if (p == 0) return 1 % mod;
        long long t = BigMod(a % mod, p >> 1, mod);
        t = t * t % mod;
        if (p & 1) {
            t = t * (a % mod) % mod;
        }
        return t;
    }
};",1420098074
JeffreyLC,JeffreyLC,222,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 2) {
                ans[i] = -1;
            } else {
                int lsb = LowSignificantBit(~nums[i]);
                if (lsb == nums[i] + 1) {
                    ans[i] = nums[i] / 2;
                } else {
                    ans[i] = nums[i] - lsb / 2;
                }
            }
        }
        return ans;
    }
private:
    int LowSignificantBit(int num) {
        return num & (-num);
    }
};",1419999679
JeffreyLC,JeffreyLC,222,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 2) {
                ans[i] = -1;
            } else {
                int lsb = LowSignificantBit(~nums[i]);
                if (lsb == nums[i] + 1) {
                    ans[i] = nums[i] / 2;
                } else {
                    ans[i] = nums[i] - lsb / 2;
                }
            }
        }
        return ans;
    }
private:
    int LowSignificantBit(int num) {
        return num & (-num);
    }
};",1419999463
fpeterfalvi,fpeterfalvi,223,3487,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int p = pattern.length();
        int t = targetIndices.length;
        List<List<Integer>> letterOccurrences = new ArrayList<>();
        for (int i = 0; i < 26; i++) {
            letterOccurrences.add(new ArrayList<>());
        }
        for (int i = 0; i < p; i++) {
            letterOccurrences.get(pattern.charAt(i) - 'a').add(i);
        }
        int[] addedMaxReached = new int[t + 1];
        int i = 0;
        for (int k = 0; k < targetIndices[0]; k++) {
            char c = source.charAt(k);
            if (i == p) {
                break;
            }
            if (c == pattern.charAt(i)) {
                i++;
            }
        }
        addedMaxReached[0] = i;
        for (int l = 0; l < t; l++) {
            int targetIndex = targetIndices[l];
            int[] newAddedMaxReached = new int[t + 1];
            for (int j = 0; j <= l; j++) {
                i = addedMaxReached[j];
                for (int k = targetIndex + 1; k < (l < t - 1 ? targetIndices[l + 1] : n); k++) {
                    char c = source.charAt(k);
                    if (i == p) {
                        break;
                    }
                    if (c == pattern.charAt(i)) {
                        i++;
                    }
                }
                newAddedMaxReached[j] = Math.max(newAddedMaxReached[j], i);
                i = addedMaxReached[j];
                for (int k = targetIndex; k < (l < t - 1 ? targetIndices[l + 1] : n); k++) {
                    char c = source.charAt(k);
                    if (i == p) {
                        break;
                    }
                    if (c == pattern.charAt(i)) {
                        i++;
                    }
                }
                newAddedMaxReached[j + 1] = Math.max(newAddedMaxReached[j + 1], i);
            }
            addedMaxReached = newAddedMaxReached;
        }
        for (int j = 0; j <= t; j++) {
            if (addedMaxReached[j] == p) {
                return t - j;
            }
        }
        return -1;
    }
}",1420057559
fpeterfalvi,fpeterfalvi,223,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        long MOD = (long)1e9 + 7;
        calculate_factorial(Math.max(n, x), MOD);
        long ways = 0;
        for (int bands = 1; bands <= Math.min(n, x); bands++) {
            long possibilities = 0;
            for (int i = 0; i < bands; i++) {
                possibilities = ((possibilities + ((i % 2 == 0) ? 1 : -1) * choose(bands, i, MOD) * power(bands - i, n, MOD) % MOD) % MOD + MOD) % MOD;
            }
            ways = (ways + possibilities * choose(x, bands, MOD) % MOD * power(y, bands, MOD) % MOD) % MOD;
        }
        return (int)ways;
    }

    long[] factorial;

    void calculate_factorial(int N, long p) {
        factorial = new long[N + 1];
        factorial[0] = 1;
        for (int i = 1; i <= N; i++) {
            factorial[i] = factorial[i - 1] * i % p;
        }
    }

    long choose(int n, int k, long p) {
        return factorial[n] * inverse(factorial[k] * factorial[n - k] % p, p) % p;
    }

    public static long inverse(long a, long n) {
        long t = 0;
        long newt = 1;
        long r = n;
        long newr = a;
        while (newr != 0) {
            long quotient = r / newr;
            long newt_temp = newt;
            newt = t - quotient * newt;
            t = newt_temp;
            long newr_temp = newr;
            newr = r - quotient * newr;
            r = newr_temp;
        }
        if (r > 1) {
            // a is not invertible
            return -1;
        }
        if (t < 0) {
            t += n;
        }
        return t;
    }

    public static long power(long x, long y, long p) {
        long res = 1;
        x = x % p;
        while (y > 0) {
            if ((y & 1) != 0) {
                res = (res * x) % p;
            }
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }
}",1420098110
fpeterfalvi,fpeterfalvi,223,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            if (p == 2) {
                result[i] = -1;
                continue;
            }
            if (Integer.bitCount(p + 1) == 1) {
                result[i] = (p + 1) / 2 - 1;
                continue;
            }
            int last0 = 0;
            while ((1 << last0 & p) != 0) {
                last0++;
            }
            result[i] = p - (1 << (last0 - 1));
        }
        return result;
    }
}",1420003695
fpeterfalvi,fpeterfalvi,223,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int p = nums.get(i);
            if (p == 2) {
                result[i] = -1;
                continue;
            }
            if (Integer.bitCount(p + 1) == 1) {
                result[i] = (p + 1) / 2 - 1;
                continue;
            }
            int last0 = 0;
            while ((1 << last0 & p) != 0) {
                last0++;
            }
            result[i] = p - (1 << (last0 - 1));
        }
        return result;
    }
}",1420002680
Anshul Agarwal,anshulagarwal3131,224,3487,cpp,"int dp[3001][3001];
class Solution {
public:
    vector<int> ind,v;
    int n,m;
    int solve(int i,int j,string &src,string &pat){
        if(j==m)
            return v[i];
        if(i==n)
            return -1e6;
        if(dp[i][j]!=-1)
            return dp[i][j];
        if(ind[i]){
            if(src[i]==pat[j])
                return dp[i][j] = max(solve(i+1,j+1,src,pat),1+solve(i+1,j,src,pat));
            return dp[i][j] = 1+solve(i+1,j,src,pat);
        }
        else{
            if(src[i]==pat[j])
                return dp[i][j] = solve(i+1,j+1,src,pat);
            return dp[i][j] = solve(i+1,j,src,pat);
        }
        return 0;
    }
    int maxRemovals(string source, string pattern, vector<int>& ti) {
        n = source.size(),m = pattern.size();
        ind.resize(n);
        v.resize(n+1);
        for(auto i : ti)
            ind[i] = 1;
        v[n-1] = ind[n-1];
        for(int i = n-2;i>=0;i--)
            v[i] = v[i+1]+ind[i];
        memset(dp,-1,sizeof(dp));
        return solve(0,0,source,pattern);
        
    }
};",1420027523
Anshul Agarwal,anshulagarwal3131,224,3604,cpp,"
long long dp[1001][1001];
class Solution {
public:
    int mod = 1e9+7;
    long long solve(int i,int j,int n,int x,int y){
       if(!i)
           return 1;
        if(dp[i][j]!=-1)
            return dp[i][j];
        if(j==x)
            return dp[i][j] = (j*solve(i-1,j,n,x,y))%mod;
        return dp[i][j] = ((x-j)*y*solve(i-1,j+1,n,x,y)+j*solve(i-1,j,n,x,y))%mod;
        
    }
    int numberOfWays(int n, int x, int y) {
        memset(dp,-1,sizeof(dp));
        return solve(n,0,n,x,y);
       
    }
};",1420104686
Anshul Agarwal,anshulagarwal3131,224,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto i : nums){
            if(!(i%2)){
                res.push_back(-1);
                continue;
            }
            int j = 0,x = i;
            while(x%2){
                x/=2;
                j++;
            }
            res.push_back((1<<(j-1))^i);
        }
        return res;
    }
};",1420001143
Anshul Agarwal,anshulagarwal3131,224,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto i : nums){
            if(!(i%2)){
                res.push_back(-1);
                continue;
            }
            int j = 0,x = i;
            while(x%2){
                x/=2;
                j++;
            }
            res.push_back((1<<(j-1))^i);
        }
        return res;
    }
};",1420000732
InfiniteLoops,ShriyamThor,226,3487,cpp,"#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());
        vector<int> dp(m + 1, INT32_MAX);
        dp[0] = 0;
        for(int i = 0; i < n; ++i){
            for(int j = min(m, (int)(m)); j >=1; --j){
                if(source[i] == pattern[j-1] && dp[j-1] != INT32_MAX){
                    int cost = targetSet.find(i) != targetSet.end() ? 1 : 0;
                    dp[j] = min(dp[j], dp[j-1] + cost);
                }
            }
        }
        if(dp[m] == INT32_MAX) return 0;
        return targetIndices.size() - dp[m];
    }
};
",1420051255
InfiniteLoops,ShriyamThor,226,3604,cpp,"#include <vector>
#include <string>
using namespace std;

const int MOD = 1'000'000'007;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
    
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= x; ++j){
                S[i][j] = (S[i-1][j-1] + j * S[i-1][j]) % MOD;
            }
        }
        
 
        vector<long long> fact(x + 1, 1);
        for(int i = 1; i <= x; ++i){
            fact[i] = fact[i-1] * i % MOD;
        }
        

        vector<long long> y_pows(x + 1, 1);
        for(int i = 1; i <= x; ++i){
            y_pows[i] = y_pows[i-1] * y % MOD;
        }
        
     
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        C[0][0] = 1;
        for(int i = 1; i <= x; ++i){
            C[i][0] = 1;
            for(int j = 1; j <= i; ++j){
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        
        long long res = 0;
        int max_k = min(x, n);
        for(int k = 1; k <= max_k; ++k){
        
            long long comb = C[x][k];
            long long ways = comb * fact[k] % MOD;
         
            ways = ways * S[n][k] % MOD;
            ways = ways * y_pows[k] % MOD;
            res = (res + ways) % MOD;
        }
        return (int)res;
    }
};
",1420105078
InfiniteLoops,ShriyamThor,226,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num : nums){
            bool found = false;
            int candidate = -1;
            for(int a = 0; a < num; ++a){
                if( (a | (a + 1)) == num ){
                    candidate = a;
                    found = true;
                    break; 
                }
            }
            if(found){
                ans.push_back(candidate);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;
    }
};
",1419994676
InfiniteLoops,ShriyamThor,226,3611,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x : nums){
            int min_a = -1;
      
            for(int bit = 0; bit < 30; bit++){
        
                if(x & (1 << bit)){
                
                    int a = x & (~(1 << bit));
             
                    if(a < 0 || a >= x){
                        continue;
                    }
                
                    if( (a | (a +1)) == x ){
                        if(min_a == -1 || a < min_a){
                            min_a = a;
                        }
                    }
                }
            }
            ans.push_back(min_a);
        }
        return ans;
    }
};
",1420005038
achintya7567,achintya7567,227,3487,cpp,"class Solution {
public:
    int rec(int i, int j, vector<vector<int>> &dp, string &s, string &p, set<int>& v){
        if(dp[i][j]!=-1)return dp[i][j];
        if(i==s.size()&&j==p.size()){
            return dp[i][j]=0;
        }
        else if(i==s.size()&&j<p.size())return dp[i][j]=-1000000;
        else if(j==p.size()){
            return dp[i][j]=v.count(i)+rec(i+1,j,dp,s,p,v);
        }
        int ans=0;
        ans=rec(i+1,j,dp,s,p,v);
        if(s[i]==p[j])ans=max(ans,rec(i+1,j+1,dp,s,p,v));
        if(v.count(i))ans=max(ans,1+rec(i+1,j,dp,s,p,v));
        return dp[i][j]=ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<vector<int>> dp(source.size()+1,vector<int>(pattern.size()+1,-1));
        set<int> t(targetIndices.begin(),targetIndices.end());
        rec(0,0,dp,source,pattern,t);

        return dp[0][0];
    }
};",1420079397
achintya7567,achintya7567,227,3604,cpp,"class Solution {
public:
    long long exp(long long a,long long b, long long mod){
        if(b==0)return 1;
        long long x=exp(a,b/2,mod);
        long long y=(x*x)%mod;
        if(b%2){
            return (a*y)%mod;
        }
        else return y;
    }
    int numberOfWays(int n, int x, int y) {
        long long s[1001][1001]; 
        long long mod=1e9+7;
        for(int i=0;i<1001;i++){ 
            for(int j=0;j<1001;j++){ 
                if(j>i) s[i][j]=0; 
                else if(i==j) s[i][j]=1; 
                else if(i==0 || j==0) s[i][j]=0; 
                else{     
                    s[i][j]= (j*s[i-1][j])%mod + s[i-1][j-1]; 
                } 
                s[i][j]%=mod;
                
            } 
        }
        long long z=y;
        long long sum=0;
        long long xf=1;
        vector<long long> fact(x+1);
        fact[0]=1;
        for(long long i=1;i<=x;i++){
            fact[i]=fact[i-1]*i;
            fact[i]%=mod;
        }
        for(long long i=1;i<=x;i++){
            long long xci=(((fact[x]*exp(fact[i],mod-2,mod))%mod)*exp(fact[x-i],mod-2,mod))%mod;
            sum+=(((((z*s[n][i])%mod)*xci)%mod)*fact[i])%mod;
            sum%=mod;
            z*=y;
            z%=mod;
        }
        return sum;
        

    }
};",1420098850
achintya7567,achintya7567,227,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for x in nums:
            if x%2==0:
                ans.append(-1)
            else:

                y=x//2
                if y|(y+1)==x:
                    ans.append(y)
                else:
                    cnt=0
                    z=x
                    while int(x)&int(1)>0:
                        cnt+=1
                        x/=2
                    ans.append(min(z-1,z-2**(cnt-1)))

        return ans
        ",1420008719
achintya7567,achintya7567,227,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for x in nums:
            if x%2==0:
                ans.append(-1)
            else:

                y=x//2
                if y|(y+1)==x:
                    ans.append(y)
                else:
                    cnt=0
                    z=x
                    while int(x)&int(1)>0:
                        cnt+=1
                        x/=2
                    ans.append(min(z-1,z-2**(cnt-1)))

        return ans
        ",1420010225
varous,sourav_suku,228,3487,cpp,"const int INF=(int)1e9;
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size(),m=pattern.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-INF));
        vector<int> dict(n);    for(auto &e:targetIndices)dict[e]=1;
        dp[n][m]=0;
        for(int i=n-1;i>=0;--i){
            dp[i][m]=0;
            for(int j=i;j<n;++j)dp[i][m]+=dict[j];
            for(int j=m-1;j>=0;--j){
                if(dict[i]){
                    dp[i][j]=max(1+dp[i+1][j],dp[i][j]);
                }
                if(source[i]==pattern[j]){
                    dp[i][j]=max(dp[i+1][j+1],dp[i][j]);
                }
                dp[i][j]=max(dp[i][j],dp[i+1][j]);
            }
        }
        return dp[0][0];
    }
};",1420045346
varous,sourav_suku,228,3604,cpp,"const long long int M=(int)1e9+7;
const int N=1005;
#define ll long long 
ll dp[N][N];
ll fact[N],inv[N];
ll power(ll a,ll b){
    ll res=1;
    ll pro=a;
    while(b){
        if(b&1){
            res*=pro;
            res%=M;
        }
        pro*=pro;       pro%=M;
        b>>=1;
    }
    return res;
}
void pre(){
    fact[0]=fact[1]=1;
    inv[0]=inv[1]=1;
    for(int i=2;i<N;++i){
        fact[i]=(fact[i-1]*i);      fact[i]%=M;
        inv[i]=power(fact[i],M-2);
    }
    memset(dp,0,sizeof(dp));
    dp[0][0]=1;
    for(int i=1;i<N;++i){
        for(int j=1;j<N;++j){
            dp[i][j]=dp[i-1][j]*j;      dp[i][j]%=M;
            dp[i][j]+=dp[i-1][j-1];     dp[i][j]%=M;
        }
    }
}
ll choose(ll a,ll b){
    ll ret=fact[a];
    ret*=inv[b];        ret%=M;
    ret*=inv[a-b];      ret%=M;
    return ret;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        pre();
        ll res=0;
        for(int i=1;i<=x;++i){
            ll cur=choose(x,i);     cur*=power(y,i);    cur%=M;
            cur*=dp[n][i];      cur%=M;     cur*=fact[i];       cur%=M;
            res+=cur;       res%=M;
        }
        return res;
    }
};",1420105470
varous,sourav_suku,228,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> res(n,-1);
        for(int i=0;i<n;++i){
            for(int j=1;j<=nums[i];++j){
                if((j|(j+1))==nums[i]){
                    res[i]=j;
                    break;
                }
            }
        }
        return res;
    }
};",1420003179
varous,sourav_suku,228,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> res(n,-1);
        for(int i=0;i<n;++i){
            if(nums[i]==2)continue;
            else{
                int ind=0;
                for(int j=0;j<30;++j){
                    if((1<<j)&nums[i]){
                        ind=j;
                    }else{
                        break;
                    }
                }
                res[i]=(nums[i]^(1<<ind));
            }
        }
        return res;
    }
};",1420018850
shlok agrawal,111shlokagrawal,229,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<float> dp(m + 1, float('behencho'));
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != float('behencho')) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        int sub = 0;
        if(dp[m]!= float('behencho'))sub = dp[m];
        return targetIndices.size() - sub;

    }
};",1420090323
shlok agrawal,111shlokagrawal,229,3604,cpp,"#define ll long long
class Solution {
public:
    const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {

        vector<ll> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (long long)fact[i - 1] * i % MOD;
        }


        vector<ll> main;
        main.push_back(n);main.push_back(x);main.push_back(y);


        vector<vector<ll>> sp(n + 1, vector<ll>(x + 1, 0));
        sp[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                sp[i][j] = (j * sp[i - 1][j] + sp[i - 1][j - 1]) % MOD;
            }
        }


        vector<vector<ll>> dp(x + 1, vector<ll>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;
            }
        }

        ll result = 0;

        for (int k = 1; k <= x; ++k) {
            ll power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }

            result = (result + (long long)dp[x][k] * sp[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};",1420099087
shlok agrawal,111shlokagrawal,229,3605,cpp,"class Solution {
public:
    bool check(int nums){
        int sz = log2(nums)+1;
        for(int i=0;i<sz-1;i++){
            int bit = nums & (1<<i);
            if(bit==0)return false;
        }
        return true;
    }
    long long int highest(int nums){
        int sz = log2(nums);
        long long int ans = nums - 1LL*pow(2,sz);
        return ans;
    }
    int make(int nums){
        int ans = nums;
        for(int i=0;i<31;i++){
            int bit = nums & (1<<i);
            if(bit)continue;
            else{
                cout << i << endl;
                ans -= (1<<(i-1));
                break;
            }
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(make(nums[i]));
        }
        return ans;
    }
};",1420020267
shlok agrawal,111shlokagrawal,229,3611,cpp,"class Solution {
public:
    int make(int nums){
        int ans = nums;
        for(int i=0;i<31;i++){
            int bit = nums & (1<<i);
            if(bit)continue;
            else{
                //cout << i << endl;
                ans -= (1<<(i-1));
                break;
            }
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                ans.push_back(-1);
                continue;
            }
            ans.push_back(make(nums[i]));
        }
        return ans;
    }
};",1420023199
Yoshi_mitsu,Yoshi_mitsu,230,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        int[] dp = new int[patternLength + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        TargetIndexChecker checker = new TargetIndexChecker(sourceLength);
        checker.markTargetIndices(targetIndices);

        for (int i = 0; i < sourceLength; i++) {
            for (int j = patternLength; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (checker.isTarget(i) ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[patternLength] == Integer.MAX_VALUE ? 0 : dp[patternLength]);
    }
}

class TargetIndexChecker {
    private boolean[] targetIndices;

    public TargetIndexChecker(int length) {
        targetIndices = new boolean[length];
    }

    public void markTargetIndices(int[] indices) {
        for (int index : indices) {
            targetIndices[index] = true;
        }
    }

    public boolean isTarget(int index) {
        return targetIndices[index];
    }
}



",1420072544
Yoshi_mitsu,Yoshi_mitsu,230,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    // Function to calculate combinations and factorials
    private int[][] comb;
    private int[] fact;

    public int numberOfWays(int n, int x, int y) {
        initComb(x);
        initFact(x);
        int[][] stir = initStirling(n, x);

        int res = 0;

        for (int k = 1; k <= x; k++) {
            int pow = modPow(y, k);
            res = (int) ((res + (1L * comb[x][k] * stir[n][k] % MOD * fact[k] % MOD * pow) % MOD) % MOD);
        }

        return res;
    }

    private void initComb(int x) {
        comb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
    }

    private void initFact(int x) {
        fact = new int[x + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = (int) ((1L * fact[i - 1] * i) % MOD);
        }
    }

    private int[][] initStirling(int n, int x) {
        int[][] stir = new int[n + 1][x + 1];
        stir[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stir[i][j] = (int) ((1L * j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD);
            }
        }
        return stir;
    }

    private int modPow(int b, int e) {
        int res = 1;
        while (e > 0) {
            if ((e & 1) == 1) {
                res = (int) ((1L * res * b) % MOD);
            }
            b = (int) ((1L * b * b) % MOD);
            e >>= 1;
        }
        return res;
    }

    // Example usage
    
}
",1420085375
Yoshi_mitsu,Yoshi_mitsu,230,3605,java,"import java.util.List;

class Solution {
    
    // Method to find the minimum x such that (x | (x + 1)) == prime
    private int findMinAns(int prime) {
        int x = 1; // Start with x = 1
        while (x <= prime) {
            if ((x | (x + 1)) == prime) {
                return x; // Return x if the condition is met
            }
            x++; // Increment x
        }
        return -1; // If no such x exists, return -1
    }

    // Method to process each number in the list
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n]; // Initialize the answer array
        
        // Fill the answer array using findMinAns
        for (int i = 0; i < n; i++) {
            ans[i] = findMinAns(nums.get(i));
        }
        
        return ans; // Return the answer array
    }
}
",1420010179
Yoshi_mitsu,Yoshi_mitsu,230,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # Helper functions as lambda functions
        is_bit_set = lambda num, bit: (num >> bit) & 1 == 1
        unset_bit = lambda num, bit: num & ~(1 << bit)
        is_valid_candidate = lambda candidate, original: (candidate | (candidate + 1)) == original
        
        return [
            self.find_minimal_ans(num, is_bit_set, unset_bit, is_valid_candidate) for num in nums
        ]

    def find_minimal_ans(self, num: int, is_bit_set, unset_bit, is_valid_candidate) -> int:
        minimal_ans = float('inf')
        found = False
        
        for bit in range(31):
            if is_bit_set(num, bit):
                candidate = unset_bit(num, bit)
                
                if candidate >= 0 and is_valid_candidate(candidate, num):
                    if candidate < minimal_ans:
                        minimal_ans = candidate
                        found = True
        
        return minimal_ans if found else -1
",1420069149
codebuster,codebuster420,231,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        std::vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        std::vector<std::vector<int>> memo(n, std::vector<int>(m, -1));
        
        auto minRemovals = [&](auto& self, int i, int j) -> int {
            if (j == m) return 0;
            if (i == n) return INT_MAX;
            
            if (memo[i][j] != -1) return memo[i][j];
            
            int result = self(self, i + 1, j);
            if (source[i] == pattern[j]) {
                int withChar = self(self, i + 1, j + 1);
                if (withChar != INT_MAX) {
                    result = std::min(result, withChar + (isTarget[i] ? 1 : 0));
                }
            }
            
            return memo[i][j] = result;
        };
        
        int removalCount = minRemovals(minRemovals, 0, 0);
        return targetIndices.size() - (removalCount == INT_MAX ? 0 : removalCount);
    }
};",1420074481
codebuster,codebuster420,231,3604,cpp,"class Solution {
public:
    static const int MODULO = 1e9 + 7;

    vector<vector<int>> computeCombinations(int maxGroups) {
        vector<std::vector<int>> combination(maxGroups + 1, std::vector<int>(maxGroups + 1, 0));
        for (int i = 0; i <= maxGroups; ++i) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MODULO;
            }
        }
        return combination;
    }

    vector<vector<int>> computeStirlingNumbers(int totalSteps, int maxGroups) {
        vector<std::vector<int>> stirlingNumbers(totalSteps + 1, std::vector<int>(maxGroups + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalSteps; ++i) {
            for (int j = 1; j <= maxGroups; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MODULO;
            }
        }
        return stirlingNumbers;
    }

    vector<int> computeFactorials(int maxGroups) {
        vector<int> factorial(maxGroups + 1, 1);
        for (int i = 1; i <= maxGroups; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MODULO;
        }
        return factorial;
    }

    long long computeTotalWays(int totalSteps, int maxGroups, int multiplier, 
                               const vector<std::vector<int>>& combination, 
                               const vector<std::vector<int>>& stirlingNumbers, 
                               const vector<int>& factorial) {
        long long totalCount = 0;
        for (int currentGroups = 1; currentGroups <= maxGroups; ++currentGroups) {
            long long multiplierPower = 1;
            for (int i = 0; i < currentGroups; ++i) {
                multiplierPower = (multiplierPower * multiplier) % MODULO;
            }
            totalCount = (totalCount + (1LL * combination[maxGroups][currentGroups] * stirlingNumbers[totalSteps][currentGroups] % MODULO * factorial[currentGroups] % MODULO * multiplierPower % MODULO)) % MODULO;
        }
        return totalCount;
    }
    int numberOfWays(int totalSteps, int maxGroups, int multiplier) {
        auto combination = computeCombinations(maxGroups);
        auto stirlingNumbers = computeStirlingNumbers(totalSteps, maxGroups);
        auto factorial = computeFactorials(maxGroups);
        return computeTotalWays(totalSteps, maxGroups, multiplier, combination, stirlingNumbers, factorial);
    }
};",1420105720
codebuster,codebuster420,231,3605,cpp,"class Solution {
public:
    int helper(int x){
        for(int i=1; i<=x; i++){
            if((i |(i+1))==x){
                return i;
            }
        }

        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n= nums.size();
        vector<int> ans(n,-1);

        int idx=0;
        for(int i: nums){
            if(i%2==0) {
                idx++;
                continue;
            }
            int a= helper(i);
            cout<<a<<"" "";
            ans[idx]= a;
            idx++;
            
        }

        return ans;
    }
};",1420011164
codebuster,codebuster420,231,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, -1);
        
        int idx=0;
        for (auto i: nums) {

            int mini = INT_MAX;
            bool flag = false;
            
            for (int x = 0; x <= 30; x++) {
                if ((i >> x) & 1) {
                    int c = i & ~(1 << x);
                
                    if (c < 0) continue; 
                    if ((c | (c + 1)) == i) {
                        if (c < mini) {
                            mini = c;
                            flag = true;
                        }
                    }
                }
            }
            
            if (flag) {
                res[idx] = mini;
            }
            idx++;
        }
        
        return res;
    }
};",1420049160
Anurag Singh Thakur,clarocroma,232,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.length(), m = p.length();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isT(n, false);
        for (int idx : t) isT[idx] = true;

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isT[i] ? 1 : 0));
                }
            }
        }
        return t.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }

private:
    void helperA(const vector<int>& t) {
        int b = 0;
        while (b < t.size()) {
            
            b |= (1 << t[b]);
        }
    }

    int helperB(string& s) {
        int c = 0;
        while (c < s.length()) {
            c++;
            
            s[c % s.length()] ^= 1; 
        }
        return c;
    }

    bool helperC(int x) {
        while (x > 0) {
            x &= (x - 1);  
        }
        return x == 0;  
    }
};
",1420079752
Anurag Singh Thakur,clarocroma,232,3604,cpp,"#include <vector>
#include <iostream>

using namespace std;

class Solution {
public:
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> comb = a(x);
        vector<vector<int>> stir = b(n, x);
        vector<int> fact = f(x);

        int res = 0;
        for (int k = 1; k <= x; ++k) {
            long long p = d(y, k);
            long long temp = (1LL * comb[x][k] * stir[n][k]) % MOD;
            temp = (temp * fact[k]) % MOD;
            temp = (temp * p) % MOD;
            res = (res + temp) % MOD;
        }

        return res;
    }

private:
    vector<vector<int>> a(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> b(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                long long firstPart = (1LL * j * s[i - 1][j]) % MOD;
                long long secondPart = s[i - 1][j - 1];
                s[i][j] = (firstPart + secondPart) % MOD;
            }
        }
        return s;
    }

    vector<int> f(int x) { // Renamed from c to f to avoid conflict
        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    long long d(int b, int e) {
        long long r = 1;
        long long base = b;
        while (e > 0) {
            if (e & 1) {
                r = (r * base) % MOD;
            }
            base = (base * base) % MOD;
            e >>= 1; // Divide e by 2
        }
        return r;
    }
};
",1420098241
Anurag Singh Thakur,clarocroma,232,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
        int tmp=n.size();
        vector<int> a(tmp, -1);   
        
        for (int i = 0; i <tmp; i++) {
            int x = n[i];
            int c = 0;
            
            while (c <= x) {
                if ((c | (c + 1)) == x) {
                    a[i] = c;
                    break;
                }
                c++;
            }
        }
        
        return a;


        
    }
};",1419999857
Anurag Singh Thakur,clarocroma,232,3611,cpp,"#include <vector>
#include <set>
#include <algorithm>
using namespace std;

class Solution {
private:
    bool b(int n, int p) {
        return (n & (1 << p)) != 0;
    }

    int c(int n, int p) {
        return n & ~(1 << p);
    }

    int m(const set<int>& s) {
        return s.empty() ? -1 : *s.begin();
    }

public:
    vector<int> minBitwiseArray(vector<int>& n) {
        vector<int> a;
        
        for (int x : n) {
            set<int> s;
            int i = 0;

            while (i < 32) {
                if (b(x, i)) {
                    int y = c(x, i);
                    if ((y | (y + 1)) == x) {
                        s.insert(y);
                    }
                }
                i++;
            }

            a.push_back(m(s));
        }

        return a;
    }
};

",1420105779
Vijay Katari,vijaykatari23,233,3487,cpp,"class Solution {
public:
    int maxRemovals(string S, string P, vector<int>& t) {
        int N = S.length();
        int M = P.length();
        vector<int> can(N + 1);
        for (auto x : t)
            can[x + 1] = 1;
        vector<vector<int>> dp(N + 1, vector<int>(M + 1, -1));
        dp[0][0] = 0;
        for (int i = 1; i <= N; ++i) {
            if (dp[i - 1][0] != -1)
                dp[i][0] = max(dp[i][0], dp[i - 1][0] + can[i]);
            for (int j = 1; j <= M; ++j) {
                if (S[i - 1] == P[j - 1]) {
                    if (dp[i - 1][j - 1] != -1)
                        dp[i][j] = dp[i - 1][j - 1];
                }
                if (dp[i - 1][j] != -1)
                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + can[i]);
            }
        }
        int ans = 0;
        for (int i = 1; i <= N; ++i) ans = max(ans, dp[i][M]);
        return ans;
    }
};",1420028052
Vijay Katari,vijaykatari23,233,3604,cpp,"#include <bits/stdc++.h>
using namespace std;

using ll = long long;
using ld = long double;
using ull = unsigned long long;

#define FOR(i, n)           for(ll (i) = 0; (i) < (n); ++(i))
#define REV(i, n)           for(ll (i) = (n) - 1; ~(i); --(i))
#define READ(x)             cin >> x;
#define O(x)                cout << x << '\n';
#define PLL                 pair<ll, ll>
#define VL                  vector<ll>
#define all(x)              (x).begin(), (x).end()
#define allr(x)             (x).rbegin(), (x).rend()
#define YES                 cout << ""YES\n"";
#define NO                  cout << ""NO\n"";
#define STOP                cout << ""-1\n"";

constexpr ll INF0  = 2e18 + 10;
constexpr ld EPS   = 1e-9 + 00;

template<const int &MOD>
struct ModularInt {
    int val;
 
    ModularInt(ll v = 0) {
        if (v < 0) v = v % MOD + MOD;
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    ModularInt(ull v) {
        if (v >= MOD) v %= MOD;
        val = int(v);
    }
 
    ModularInt(int v) : ModularInt(ll(v)) {}
    ModularInt(unsigned v) : ModularInt(ull(v)) {}
 
    explicit operator int() const { return val; }
    explicit operator unsigned() const { return val; }
    explicit operator ll() const { return val; }
    explicit operator ull() const { return val; }
    explicit operator double() const { return val; }
    explicit operator long double() const { return val; }
 
    ModularInt& operator+=(const ModularInt &other) {
        val -= MOD - other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    ModularInt& operator-=(const ModularInt &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
 
    ModularInt& operator*=(const ModularInt &other) {
        val = unsigned(ull(ull(val) * other.val) % ull(MOD));
        return *this;
    }
 
    ModularInt& operator/=(const ModularInt &other) {
        return *this *= other.inv();
    }
 
    friend ModularInt operator+(const ModularInt &a, const ModularInt &b) { return ModularInt(a) += b; }
    friend ModularInt operator-(const ModularInt &a, const ModularInt &b) { return ModularInt(a) -= b; }
    friend ModularInt operator*(const ModularInt &a, const ModularInt &b) { return ModularInt(a) *= b; }
    friend ModularInt operator/(const ModularInt &a, const ModularInt &b) { return ModularInt(a) /= b; }
 
    ModularInt& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
 
    ModularInt& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
 
    ModularInt operator++(int) { ModularInt before = *this; ++*this; return before; }
    ModularInt operator--(int) { ModularInt before = *this; --*this; return before; }
 
    ModularInt operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
 
    friend bool operator==(const ModularInt &a, const ModularInt &b) { return a.val == b.val; }
    friend bool operator!=(const ModularInt &a, const ModularInt &b) { return a.val != b.val; }
    friend bool operator<(const ModularInt &a, const ModularInt &b) { return a.val < b.val; }
    friend bool operator>(const ModularInt &a, const ModularInt &b) { return a.val > b.val; }
    friend bool operator<=(const ModularInt &a, const ModularInt &b) { return a.val <= b.val; }
    friend bool operator>=(const ModularInt &a, const ModularInt &b) { return a.val >= b.val; }
 
    static const int SAVE_INV = int(1e6) + 5;
    static ModularInt save_inv[SAVE_INV];
 
    static void prepare_inv() {
        for (ll p = 2; p * p <= MOD; p += p % 2 + 1)
            assert(MOD % p != 0);
 
        save_inv[0] = 0;
        save_inv[1] = 1;
 
        for (int i = 2; i < SAVE_INV; i++)
            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);
    }
 
    ModularInt inv() const {
        if (save_inv[1] == 0)
            prepare_inv();
 
        if (val < SAVE_INV)
            return save_inv[val];
 
        ModularInt product = 1;
        int v = val;
 
        do {
            product *= MOD - MOD / v;
            v = MOD % v;
        } while (v >= SAVE_INV);
 
        return product * save_inv[v];
    }
 
    ModularInt pow(ll p) const {
        if (p < 0)
            return inv().pow(-p);
 
        ModularInt a = *this, result = 1;
 
        while (p > 0) {
            if (p & 1)
                result *= a;
 
            p >>= 1;
 
            if (p > 0)
                a *= a;
        }
 
        return result;
    }
 
    friend ostream& operator<<(ostream &os, const ModularInt &m) {
        return os << m.val;
    }
};
 
template<const int &MOD> ModularInt<MOD> ModularInt<MOD>::save_inv[ModularInt<MOD>::SAVE_INV];
 
const int MOD = int(1e9) + 7;
using Mint = ModularInt<MOD>;
 
 
template<const int &MOD>
struct Combinatorics {
    using CombinatoricsInt = ModularInt<MOD>;
 
    vector<CombinatoricsInt> Factorial = {1}, InvFactorial = {1};
 
    void prepareFactorials(ll maximum) {
        static ll prepared_maximum = 0;
 
        if (maximum <= prepared_maximum)
            return;
 
        // Prevent increasing prepared_maximum by only 1 each time.
        maximum = max(maximum, ll(1.01L * prepared_maximum));
        Factorial.resize(maximum + 1);
        InvFactorial.resize(maximum + 1);
 
        for (ll i = prepared_maximum + 1; i <= maximum; i++)
            Factorial[i] = i * Factorial[i - 1];
 
        InvFactorial[maximum] = Factorial[maximum].inv();
 
        for (ll i = maximum - 1; i > prepared_maximum; i--)
            InvFactorial[i] = (i + 1) * InvFactorial[i + 1];
 
        prepared_maximum = maximum;
    }
 
    CombinatoricsInt factorial(ll n) {
        if (n < 0) return 0;
        prepareFactorials(n);
        return Factorial[n];
    }
 
    CombinatoricsInt invFactorial(ll n) {
        if (n < 0) return 0;
        prepareFactorials(n);
        return InvFactorial[n];
    }
 
    CombinatoricsInt choose(ll n, ll r) {
        if (r < 0 || r > n) return 0;
        prepareFactorials(n);
        return Factorial[n] * InvFactorial[r] * InvFactorial[n - r];
    }
 
    CombinatoricsInt permute(ll n, ll r) {
        if (r < 0 || r > n) return 0;
        prepareFactorials(n);
        return Factorial[n] * InvFactorial[n - r];
    }
 
    CombinatoricsInt inv_choose(ll n, ll r) {
        assert(0 <= r && r <= n);
        prepareFactorials(n);
        return InvFactorial[n] * Factorial[r] * Factorial[n - r];
    }
 
    CombinatoricsInt inv_permute(ll n, ll r) {
        assert(0 <= r && r <= n);
        prepareFactorials(n);
        return InvFactorial[n] * Factorial[n - r];
    }
};
 
Combinatorics<MOD> Cint;

class Solution {
public:
    int numberOfWays(int N, int X, int Y) {
        vector<vector<Mint>> dp(N + 1, vector<Mint>(X + 1));
        dp[0][0] = 1;
        
        for (int i = 1; i <= N; ++i)
            for (int j = 1; j <= X; ++j) 
                dp[i][j] = Mint(j) * dp[i - 1][j] + dp[i - 1][j - 1];
        
        Mint ans = 0;
        for (int i = 1; i <= min(X, N); ++i) 
            ans += dp[N][i] * Cint.factorial(i) * Mint(Y).pow(i) * Cint.choose(X, i);
        
        return ans.val;
    }
};",1420105826
Vijay Katari,vijaykatari23,233,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& A) {
        int N = A.size();
        vector<int> ans(N, -1);
        for (int i = 0; i < N; ++i) {
            bool done = false;
            for (int bit = 32; bit > 0; --bit) if ((((1LL << bit) - 1LL) & A[i]) == ((1LL << bit) - 1LL)) {
                ans[i] = A[i] ^ (1LL << (bit - 1));
                done = true;
                break;
            }
            if (!done) {
                if (A[i] ^ 2)
                    ans[i] = A[i] ^ 1;
            }
        }
        return ans;
    }
};",1420007707
Vijay Katari,vijaykatari23,233,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& A) {
        int N = A.size();
        vector<int> ans(N, -1);
        for (int i = 0; i < N; ++i) {
            bool done = false;
            for (int bit = 32; bit > 0; --bit) if ((((1LL << bit) - 1LL) & A[i]) == ((1LL << bit) - 1LL)) {
                ans[i] = A[i] ^ (1LL << (bit - 1));
                done = true;
                break;
            }
            if (!done) {
                if (A[i] ^ 2)
                    ans[i] = A[i] ^ 1;
            }
        }
        return ans;
    }
};",1420007398
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3487,cpp,"#define ll long long int
ll dp[3001][3001];
class Solution {
public:
    ll find(string &str,string &pattern,ll x,ll y,map<ll,ll> &store,ll count[]){
        if(y==pattern.length()){
            return count[x];   
        }
        if(x==str.length()){
            return -1e6;
        }
        if(dp[x][y]!=-1e9){
            return dp[x][y];
        }
        if(str[x]==pattern[y]){
            ll one=find(str,pattern,x+1,y+1,store,count);
            ll see=0;
            if(store.count(x)){
                see=1;
            }
            ll two=see+find(str,pattern,x+1,y,store,count);
            return dp[x][y]=max(one,two);
        }else{
            ll see=0;
            if(store.count(x)){
                see=1;
            }
            return dp[x][y]=see+find(str,pattern,x+1,y,store,count);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& indices) {
        ll n=source.length();
        ll m=pattern.length();
        map<ll,ll> store;
        for(ll i=0;i<indices.size();i++){
            store[indices[i]]++;
        }
        ll count[n+1];
        for(ll i=0;i<=n;i++){
            count[i]=0;
        }
        ll cur=0;
        for(ll j=n;j>=0;j--){
            if(store.count(j)){
                cur++;
            }
            count[j]=cur;
        }
        for(ll i=0;i<=3000;i++){
            for(ll j=0;j<=3000;j++){
                dp[i][j]=-1e9;
            }
        }
        ll ans=find(source,pattern,0,0,store,count);
        return ans;
    }
};",1420050218
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3604,cpp,"#define ll long long int
class Solution {
public:
    ll ncr(ll n, ll r, ll mod) {
        if (r > n) return 0;
        ll num = 1, den = 1;
        for (ll i = 0; i < r; i++) {
            num = (num * (n - i)) % mod;
            den = (den * (i + 1)) % mod;
        }
        return (num * modInverse(den, mod)) % mod;
    }

    ll factorial(ll n) {
        ll mod=1e9+7;
        ll result = 1;
        for (ll i = 2; i <= n; i++) {
            result = (result * i) % mod;
        }
        return result;
    }


    ll pow(ll base, ll exp, ll mod) {
        ll result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }


    ll modInverse(ll a, ll mod) {
        return pow(a, mod - 2, mod);
    }
   

    int numberOfWays(int n, int x, int y) {
        ll mod=1e9+7;
        ll ans=0;
        vector<vector<ll>> dp(n + 1, vector<ll>(x + 1, 0));
        dp[0][0] = 1;

        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; j++) {
                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]) % mod;
            }
        }
        for(ll i=1;i<=x;i++){
            ll select1=ncr(x,i,mod);
            if(n>=i){
                ll select2=(dp[n][i]*factorial(i))%mod;
                ll left=(n-i);
                ll select4=pow(y,i,mod);
                select1=(select1*select2)%mod;
                select1=(select1*select4)%mod;
                ans=(ans+select1)%mod;
            }else{
                break;
            }
        }      
        return ans;
    }
};",1420106169
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3605,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            int cur=-1;
            for(int j=0;j<=1000;j++){
                int see=j|(j+1);
                if(see==nums[i]){
                    cur=j;
                    break;
                }
            }
            ans.push_back(cur);
        }
        return ans;
    }
};",1420030003
Nikhil Dixit,nikhil_dixit_abv_iiitm,235,3611,cpp,"#define ll long long int
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ll n=nums.size();
        vector<int> ans;
        for(ll i=0;i<n;i++){
            ll num=nums[i];
            if(num==2){
                ans.push_back(-1);
                continue;
            }
            string str="""";
            for(ll j=29;j>=0;j--){
                ll mask=1<<j;
                if(mask&num){
                    str.push_back('1');
                }else{
                    str.push_back('0');
                }
            }
            ll ind=-1;
            for(ll j=0;j<str.length();j++){
                if(str[j]=='1'){
                    ind=j;
                    break;
                }
            }
          
            ll ind2=-1;
            for(ll j=str.length()-1;j>ind;j--){
                if(str[j]=='0'){
                    ind2=j;
                    break;
                }
            }
         
            if(ind2==-1){
                int xy=1<<(30-ind-1);
                int xy2=xy-1;
                ans.push_back(xy2);
            }else{
                int xy=0;
                for(int j=0;j<str.length();j++){
                    if(j!=ind2){
                        if(str[j]=='1'){
                            xy=xy+pow(2,30-j-1);
                        }
                    }else{
                        for(int k=ind2+2;k<str.length();k++){
                            if(str[k]=='1'){
                                xy=xy+pow(2,30-k-1);
                            }
                        }
                        break;
                    }
                }
                ans.push_back(xy);
            }
            
        }
        return ans;
    }
};",1420029640
kritikmodi,kritikmodi,236,3487,cpp,"class Solution {
public:
    unordered_set<int> hs;
    string s1, s2;
    vector<vector<long long>> dp;
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        hs.clear();
        s1 = source;
        s2 = pattern;
        for (int idx : targetIndices) {
            hs.insert(idx);
        }
        dp.resize(source.length() + 1, vector<long long>(pattern.length() + 1, LLONG_MIN));
        return (int)getAns(0, 0);
    }

private:
    long long getAns(int curr1, int curr2) {
        if (curr1 == s1.length()) {
            if (curr2 == s2.length()) {
                return 0;
            } else {
                return INT_MIN;
            }
        }
        if (dp[curr1][curr2] != LLONG_MIN) {
            return dp[curr1][curr2];
        }
        if (curr2 == s2.length()) {
            long long currans = getAns(curr1 + 1, curr2);
            if (hs.find(curr1) != hs.end()) {
                currans++;
            }
            return dp[curr1][curr2] = currans;
        } else {
            if (s1[curr1] == s2[curr2]) {
                long long case1 = getAns(curr1 + 1, curr2 + 1);
                long long case2 = INT_MIN;
                if (hs.find(curr1) != hs.end()) {
                    case2 = 1 + getAns(curr1 + 1, curr2);
                }
                return dp[curr1][curr2] = max(case1, case2);
            } else {
                long long case1 = getAns(curr1 + 1, curr2);
                long long case2 = INT_MIN;
                if (hs.find(curr1) != hs.end()) {
                    case2 = 1 + getAns(curr1 + 1, curr2);
                }
                return dp[curr1][curr2] = max(case1, case2);
            }
        }
    }
};
",1420058070
kritikmodi,kritikmodi,236,3604,java,"class Solution {
    static int MOD=(int)1e9+7;
    static int N = 10001;  
 
    static long[] factorialNumInverse = new long[N + 1]; 

    static long[] naturalNumInverse = new long[N + 1];

    static long[] fact = new long[N + 1]; 
 
    public static void InverseofNumber(int p) 
    { 
        naturalNumInverse[0] = naturalNumInverse[1] = 1; 

        for(int i = 2; i <= N; i++) 
            naturalNumInverse[i] = naturalNumInverse[p % i] *
                                     (long)(p - p / i) % p; 
    } 

    public static void InverseofFactorial(int p) 
    { 
        factorialNumInverse[0] = factorialNumInverse[1] = 1; 
        for(int i = 2; i <= N; i++) 
            factorialNumInverse[i] = (naturalNumInverse[i] * 
                               factorialNumInverse[i - 1]) % p; 
    } 

    public static void factorial(int p) 
    { 
        fact[0] = 1; 
        for(int i = 1; i <= N; i++)
        { 
            fact[i] = (fact[i - 1] * (long)i) % p; 
        } 
    } 

    public static long Binomial(int N, int R, int p) 
    { 
        long ans = ((fact[N] * factorialNumInverse[R]) % 
                           p * factorialNumInverse[N - R]) % p; 
        return ans; 
    }
    
    public int numberOfWays(int n, int x, int y) {
        InverseofNumber(MOD); 
        InverseofFactorial(MOD); 
        factorial(MOD); 
        long ans=0;
        long[][] S = new long[n + 1][Math.min(n, x) + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, Math.min(n, x)); j++) {
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
            }
        }
        long facts[]=new long[1005];
        facts[0]=1;
        for(int j=1;j<=1004;j++)
            facts[j]=(facts[j-1]*j)%MOD;
        for (int s = 1; s <= Math.min(n, x); s++) {
            long stirling = S[n][s];
            long combinations = Binomial(x,s,MOD);
            long permutations = facts[s];
            long extra=1;
            for(int j=0;j<s;j++)
                extra=(extra*y)%MOD;
            long currans = (((stirling * combinations) % MOD * permutations) % MOD * extra) % MOD;
            ans = (ans + currans) % MOD;
        }
        return (int)ans;
    }

}",1420106204
kritikmodi,kritikmodi,236,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int ans[]=new int[nums.size()];
        for(int j=0;j<nums.size();j++)
        {
            int curr=nums.get(j);
            if(curr==2)
            {
                ans[j]=-1;
                continue;
            }
            int minus=1;
            int check=-1;
            inner :
            while(curr!=0)
            {
                if(curr%2==0)
                {
                    check=minus/2;
                    break inner;
                }
                minus*=2;
                curr/=2;
            }
            if(check==-1)
                check=minus/2;
            ans[j]=nums.get(j)-check;
        }
        return ans;
    }
}",1420014883
kritikmodi,kritikmodi,236,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int ans[]=new int[nums.size()];
        for(int j=0;j<nums.size();j++)
        {
            int curr=nums.get(j);
            if(curr==2)
            {
                ans[j]=-1;
                continue;
            }
            int minus=1;
            int check=-1;
            inner :
            while(curr!=0)
            {
                if(curr%2==0)
                {
                    check=minus/2;
                    break inner;
                }
                minus*=2;
                curr/=2;
            }
            if(check==-1)
                check=minus/2;
            ans[j]=nums.get(j)-check;
        }
        return ans;
    }
}",1420014580
Larry,LarryNY,238,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        INF = 10 ** 9
        S = len(source)
        P = len(pattern)
        f = set(targetIndices)
        
        pdp = [-INF] * (P + 1)
        dp = [-INF] * (P + 1)
        pdp[P] = 0
        dp[P] = 0
        
        for sindex in range(S - 1, -1, -1):
            dp[P] = pdp[P]
            if sindex in f:
                dp[P] += 1
            
            for pindex in range(P - 1, -1, -1):
                dp[pindex] = pdp[pindex]
                
                if source[sindex] == pattern[pindex]:
                    if pdp[pindex + 1] > dp[pindex]:
                        dp[pindex] = pdp[pindex + 1]
                        
                if sindex in f:
                    if pdp[pindex] + 1 > dp[pindex]:
                        dp[pindex] = pdp[pindex] + 1

            pdp = dp[:]
        return dp[0]
",1420037203
Larry,LarryNY,238,3604,python3,"MX = 1005
MOD = 10 ** 9 + 7

@cache
def choose(x, i):
    if i == 0:
        return 1
    if x == i:
        return 1
    if x == 0:
        return 0
    return (choose(x - 1, i - 1) + choose(x - 1, i)) % MOD

@cache
def go(n, i):
    if n == 0 and i == 0:
        return 1
    if n == 0 or i == 0:
        return 0

    return (go(n - 1, i - 1) + i * go(n - 1, i)) % MOD

@cache
def fact(i):
    if i == 0:
        return 1
    return (fact(i - 1) * i) % MOD
        
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0
        for i in range(1, x + 1):
            # x choose i number of groups
            groups = choose(x, i) * fact(i)
            scoring = pow(y, i, MOD)
            g = go(n, i)
            
            ans += (groups * scoring * g) % MOD
            ans %= MOD
        return ans % MOD",1420099805
Larry,LarryNY,238,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        lookup = {}
        mx = max(nums)
        
        for i in range(mx + 5):
            x = i | (i + 1)
            if x not in lookup:
                lookup[x] = i

        ans = []
        for x in nums:
            if x not in lookup:
                ans.append(-1)
            else:
                ans.append(lookup[x])
        return ans",1419994334
Larry,LarryNY,238,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def go(x):
            if x == 2:
                return -1
            
            best = x
            for i in range(32):
                if ((x - (1 << i)) | ((x - (1 << i)) + 1)) == x:
                    best = min(best, x - (1 << i))
            return best
        
        ans = []
        for x in nums:
            ans.append(go(x))
        return ans",1420006070
Meet Patel,_Meet_Patel_,239,3487,cpp,"class Solution {
private: 
    int calc(int i, int j, string &s, string &p, vector<int> &suf, unordered_set<int> &idx, vector<vector<int>> &dp) {
        int n = s.size(), m = p.size(); 

        if (i == n) return j == m ? 0 : INT_MIN; 
        if (j == m) {
            int ret = calc(i + 1, j, s, p, suf, idx, dp); 
            if (idx.count(i)) ret++; 
            return ret; 
        }
        if (dp[i][j] != -1) return dp[i][j]; 

        int ret = 0; 
        if (idx.count(i)) {
            if (suf[i + 1] >= m - j) {
                ret = 1 + calc(i + 1, j, s, p, suf, idx, dp); 
            }
        }

        // ret = max(ret, calc(i + 1, j, s, p, suf, idx, dp)); 
        if (s[i] == p[j]) {
            ret = max(ret, calc(i + 1, j + 1, s, p, suf, idx, dp)); 
        } else {
            ret = max(ret, calc(i + 1, j, s, p, suf, idx, dp)); 
        }

        // cout << i << ' ' << j << ' ' << ret << endl; 

        return dp[i][j] = ret; 
    }

public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(); 
        int m = pattern.size(); 

        vector<int> suf(n + 1); 
        for (int i = n - 1, j = m - 1 ; i >= 0 ; i--) {
            if (j >= 0 && source[i] == pattern[j]) {
                j--; 
            }
            suf[i] = (m - j - 1); 
        }

        for (int i : suf) cout << i << ' '; cout << endl; 

        unordered_set<int> idx(targetIndices.begin(), targetIndices.end()); 
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1)); 
        return calc(0, 0, source, pattern, suf, idx, dp); 

        // int rem = m, j = 0, res = 0; 
        // for (int i = 0 ; i < n ; i++) {
        //     bool removed = false; 
        //     if (idx.count(i)) {
        //         if (j == m || suf[i + 1] >= m - j) {
        //             cout << i << endl; 
        //             res++; 
        //             removed = true; 
        //         }
        //     }
        //     if (!removed && j < m) {
        //         if (source[i] == pattern[j]) {
        //             j++; 
        //         }
        //     }
        // }
        // return res; 
    }
};",1420085519
Meet Patel,_Meet_Patel_,239,3604,cpp,"class Solution {
private: 
    const int MOD = 1e9 + 7; 

    int64_t pw(int64_t b, int64_t p){
        b %= MOD;
        int res = 1;
        
        while(p > 0){
            if(p & 1)
                res = res * b % MOD;
            b = b * b % MOD;
            p >>= 1;
        }
        return res;
    }
public:
    int numberOfWays(int n, int maxParts, int multiplier) {
        vector<vector<int>> binomial(maxParts + 1, vector<int>(maxParts + 1, 0));
        for (int i = 0; i <= maxParts; ++i) {
            binomial[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stirlingNumbers(n + 1, vector<int>(maxParts + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= maxParts; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> factorial(maxParts + 1, 1);
        for (int i = 1; i <= maxParts; ++i) {
            factorial[i] = 1LL * factorial[i - 1] * i % MOD;
        }

        long long result = 0;
        for (int k = 1; k <= maxParts; ++k) {
            long long powerMultiplier = pw(multiplier, k);
            result = (result + 1LL * binomial[maxParts][k] * stirlingNumbers[n][k] % MOD * factorial[k] % MOD * powerMultiplier % MOD) % MOD;
        }

        return result;
    }
};",1420099834
Meet Patel,_Meet_Patel_,239,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size(); 
        vector<int> ans(n, -1); 
        for (int i = 0 ; i < n ; i++) {
            for (int j = 1 ; j <= nums[i] ; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j; 
                    break; 
                }
            }
        }
        return ans; 
    }
};",1419997909
Meet Patel,_Meet_Patel_,239,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size(); 
        vector<int> ans(n, -1); 
        for (int i = 0 ; i < n ; i++) {
            if (nums[i] == 2) {
                continue; 
            }
            int j = 0; 
            while (nums[i] >> j & 1) {
                j++; 
            } 
            int cur = 1 << (j - 1); 
            while (j <= 30) {
                if (nums[i] >> j & 1) {
                    cur |= (1 << j); 
                }
                j++; 
            }
            ans[i] = cur - 1; 
        }
        return ans; 
    }
};",1420031704
Aviral Katiyar,maskboy,240,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int m = pattern.size();
        int n = source.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> isTarget(n, false);

        int sz = targetIndices.size();
        for(int i=0;i<sz;i++){
            int idx = targetIndices[i];
            isTarget[idx] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j-1] && dp[j-1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j-1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420077434
Aviral Katiyar,maskboy,240,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define vl vector<ll>
#define vvl vector<vector<ll>>
#define pb push_back

ll MOD = 1e9+7;

class Solution {
public:
    string strBinary(int n, int l){string s;for(int i=l-1;i>=0;i--){s.push_back((n&(1<<i))?'1':'0');}return s;}
bool isPalindrome(string str){string rev = str;reverse(str.begin(),str.end());return str==rev;}
bool isPrime(ll n){if(n<=1)return false;for(ll i=2;i*i<=n;i++)if(n%i==0)return false;return true;}
vector<bool> seive(ll n = 1e6+7){vector<bool> prime(n+1,true);prime[1] = false;for(ll i=2;i*i<=n;i++){if(prime[i]){for (ll j = i*i; j <= n; j+=i){prime[j] = false;}}}return prime;}
void check(){string name = ""aviral Katiyar"";int rank = 7;string bin = strBinary(rank,5);bool isp = isPrime(rank);bool ispal = isPalindrome(name);}
void fastIO(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    check();
}
    void combinat(vector<vector<ll>>& comb, int limit) {
        for (int i = 0; i <= limit; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;
            }
        }
    }

    void computeStir(vector<vector<ll>>& stirling, int n, int x) {
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i-1][j] + stirling[i-1][j-1]) % MOD;
            }
        }
    }

    void facto(vector<ll>& fact, int limit) {
        fact[0] = 1;
        for (int i = 1; i <= limit; ++i) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
    }

    ll numberOfWays(int n, int x, int y) {
        fastIO();
        vector<vector<ll>> comb(x + 1, vector<ll>(x + 1, 0));
        combinat(comb, x);
        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        computeStir(stirling, n, x);
        vector<ll> fact(x + 1, 1);
        facto(fact, x);

        ll result = 0;
        for (int k = 1; k <= x; ++k) {
            ll power_y = 1;
            for (int p = 0; p < k; ++p) {
                power_y = (power_y * y) % MOD;
            }

            result = (result + comb[x][k] * stirling[n][k] % MOD * fact[k] % MOD * power_y % MOD) % MOD;
        }

        return result;
    }
};
",1420099952
Aviral Katiyar,maskboy,240,3605,cpp,"class Solution {
public:
    string toBinary(int n){
        string ans = """";
        while(n>0){
            int rem = n%2;
            if(rem) ans ='1' + ans;
            else ans = '0' + ans;
            n /= 2;
        }
        return ans;
    }
    int binToint(string bin){
        int n = bin.size();
        int con=0;
        int ans = 0;
        for(int i=n-1;i>=0;i--){
            if(bin[i]=='1'){
                ans += pow(2,con);
            }
            con++;
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]%2==0) continue;
            string bin = toBinary(nums[i]);
            bin = '0' + bin;
            int sz = bin.size();
            for(int j=sz-2;j>=0;j--){
                if(bin[j]=='0'){
                    bin[j+1] = '0';
                    break;
                }
            }
            int num = binToint(bin);
            ans[i] = num;
        }
        return ans;
    }
};",1420029857
Aviral Katiyar,maskboy,240,3611,cpp,"class Solution {
public:
    string toBinary(int n){
        string ans = """";
        while(n>0){
            int rem = n%2;
            if(rem) ans ='1' + ans;
            else ans = '0' + ans;
            n /= 2;
        }
        return ans;
    }
    int binToint(string bin){
        int n = bin.size();
        int con=0;
        int ans = 0;
        for(int i=n-1;i>=0;i--){
            if(bin[i]=='1'){
                ans += pow(2,con);
            }
            con++;
        }
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]%2==0) continue;
            string bin = toBinary(nums[i]);
            bin = '0' + bin;
            int sz = bin.size();
            for(int j=sz-2;j>=0;j--){
                if(bin[j]=='0'){
                    bin[j+1] = '0';
                    break;
                }
            }
            int num = binToint(bin);
            ans[i] = num;
        }
        return ans;
    }
};",1420035067
Shashwat Tripathi,Fkaiser7,241,3487,cpp,"#define lli long long
class Solution {
public:
    lli fuc(lli i,lli j,vector<vector<lli>>&dp,vector<lli>&check,
    string &s1,string &s2){
        lli n=s1.length();
        lli m=s2.length();
        if(i==n){
            if(j==m){
                return 0;
            }
            return -1e18;
        }
        if(dp[i][j]!=-1){
            return dp[i][j];
        }
        lli ans=fuc(i+1,j,dp,check,s1,s2);
        if(j==m&&check[i]){
            ans=max(ans,1+fuc(i+1,j,dp,check,s1,s2));
        }
        if(j<m){
            if(s1[i]==s2[j]){
                ans=max(ans,fuc(i+1,j+1,dp,check,s1,s2));
            }
            if(check[i]){
                ans=max(ans,1+fuc(i+1,j,dp,check,s1,s2));
            }
        }
        return dp[i][j]=ans;
    }
    int maxRemovals(string s1, string s2, vector<int>& v) {
        lli n=s1.length();
        lli m=s2.length();
        vector<lli>check(n);
        for(lli i=0;i<v.size();i++){
            check[v[i]]++;
        }
        vector<vector<lli>>dp(n,vector<lli>(m+1,-1));
        return (int)(fuc(0,0,dp,check,s1,s2));
    }
};",1420106557
Shashwat Tripathi,Fkaiser7,241,3604,cpp,"#define lli long long
lli mod=1e9+7;
lli MOD=1e9+7;
vector<lli>fact(1001);
class Solution {
public:
    long long power(long long i, lli j) { return j ? j & 1 ? power(i * i % mod, j >> 1) * i % mod : power(i * i % mod, j >> 1) : 1; }
    void perm(){
        lli t=1;
        fact[0]=1;
        for(lli i=1;i<=1000;i++){
            t=(t%mod*i%mod)%mod;
            fact[i]=t;
        }
    }
    lli comb(lli n,lli r){
        lli t=fact[n];
        lli p=(fact[r]%mod*fact[n-r]%mod)%mod;
        p=power(p,mod-2);
        t=(t%mod*p%mod)%mod;
        return t;
    }
    lli count(lli n,lli r){
        lli ans=0;
        lli k=0;
        for(lli i=0;i<=r-1;i++){
            lli t=power(r-i,n);
            t=(t%mod*comb(r,i)%mod)%mod;
            if(k==0){
                ans+=t;
            }
            else{
                ans-=t;
                ans+=mod;
            }
            k=1-k;
            ans=ans%mod;
        }
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        perm();
        lli ans=0;
        n=(lli)(n);
        x=(lli)(x);
        y=(lli)(y);
        //cout<<comb(4,2)<<endl;
        for(int i=1;i<=min(n,x);i++){
            lli t=count(n,i);
            //cout<<t<<endl;
            t=(t%mod*comb(x,i)%mod)%mod;
            t=(t%mod*power(y,i)%mod)%mod;
            ans+=t;
            ans=ans%mod;
        }
        return (int)(ans);
    }
};",1420084926
Shashwat Tripathi,Fkaiser7,241,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                int t=nums[i]-1;
                vector<int>v;
                for(int j=0;j<=30;j++){
                    int k=1<<j;
                    if(nums[i]&k){
                        v.push_back(k);
                    }
                }
                int ind=-1;
                for(int i=0;i<v.size()-1;i++){
                    if(v[i+1]==2*v[i]){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                if(ind!=-1){
                    int t1=0;
                    for(int j=0;j<v.size();j++){
                        if(j!=ind+1){
                            t1+=v[j];
                        }
                    }
                    t=min(t,t1);
                }
                ans.push_back(t);
            }
        }
        return ans;
    }
};",1420021406
Shashwat Tripathi,Fkaiser7,241,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                int t=nums[i]-1;
                vector<int>v;
                for(int j=0;j<=30;j++){
                    int k=1<<j;
                    if(nums[i]&k){
                        v.push_back(k);
                    }
                }
                int ind=-1;
                for(int i=0;i<v.size()-1;i++){
                    if(v[i+1]==2*v[i]){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                if(ind!=-1){
                    int t1=0;
                    for(int j=0;j<v.size();j++){
                        if(j!=ind+1){
                            t1+=v[j];
                        }
                    }
                    t=min(t,t1);
                }
                ans.push_back(t);
            }
        }
        return ans;
    }
};",1420020686
Nelson,Nelson84,243,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> can_remove(targetIndices.begin(), targetIndices.end());

        /*
            s: xxxx i
            p: oooooo j

            0bcda
            0d

            dp[i][j] = dp[i-1][j]
            if(dp[i][j] && can_remove.find(i)!=can_remove.end()) max_oper[i][j] = max_oper[i-1][j] + 1;

            if s[i]==p[j]
                dp[i][j] |= dp[i-1][j-1]
                if(dp[i-1][j-1]) max_oper[i][j] = max(max_oper[i][j], max_oper[i-1][j-1]);
        */
        vector<vector<bool>> dp(n+1, vector<bool>(m+1, false));
        vector<vector<int>> max_oper(n+1, vector<int>(m+1, 0));
        for(int i=0; i<=n; i++){
            dp[i][0] = true;
            max_oper[i][0] = (i>0 ?max_oper[i-1][0] :0);
            if(can_remove.find(i-1)!=can_remove.end()) max_oper[i][0] = (i>0 ?max_oper[i-1][0] :0) + 1;
        }
        for(int i=1; i<=n; i++){
            for(int j=1; j<=m; j++){
                dp[i][j] = dp[i-1][j];
                max_oper[i][j] = max_oper[i-1][j];
                if(dp[i-1][j] && can_remove.find(i-1)!=can_remove.end()) max_oper[i][j] = max_oper[i-1][j] + 1;

                if(source[i-1]==pattern[j-1]){
                    dp[i][j] = dp[i][j] | dp[i-1][j-1];
                    if(dp[i-1][j-1]) max_oper[i][j] = max(max_oper[i][j], max_oper[i-1][j-1]);
                }
            }
        }
        return max_oper[n][m];
    }
};",1420075121
Nelson,Nelson84,243,3604,cpp,"using LL = long long;
class Solution {
    int mod = 1e9+7;
public:
    int numberOfWays(int n, int x, int y) {
        /*
            n performers
            x stages
            [1 y] score

            dp[i][j] = number of ways i performers split to j stages

            still j group which means the i performer is assigned to the original j groups
            dp[i][j] = dp[i-1][j] * j 

            the i performer is assigned to the new groups
            dp[i][j] = dp[i-1][j-1] * y * (x-j+1)        
        */
        LL dp[n+1][x+1];
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
        for(int i=1; i<=n; i++){
            for(int j=1; j<=x; j++){
                dp[i][j] = (dp[i-1][j]*j%mod + dp[i-1][j-1]*y*(x-j+1)%mod)%mod;
                //printf(""%d "", dp[i][j]);
            }
            //printf(""\n"");
        }

        int res = 0;
        for(int group=0; group<=x; group++) res = (res + dp[n][group])%mod;
        return res;
    }
};",1420106893
Nelson,Nelson84,243,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        /*
            0001 | 0010 = 0011
            0010 | 0011 = 0011
            0011 | 0100 = 0111
            0100 | 0101 = 0101
            0101 | 0110 = 0111
            0110 | 0111 = 0111
            0111 | 1000 = 1111
        */
        int n = nums.size();
        vector<int> res(n, -1);
        for(int i=0; i<n; i++){
            int num = nums[i];
            for(int cur=1; cur<=num; cur++){
                if((cur|(cur+1))==num){
                    res[i] = cur;
                    break;
                }
            }
        }
        return res;
    }
};",1420007270
Nelson,Nelson84,243,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        /*
            0001 | 0010 = 0011
            0010 | 0011 = 0011
            0011 | 0100 = 0111
            0100 | 0101 = 0101
            0101 | 0110 = 0111
            0110 | 0111 = 0111
            0111 | 1000 = 1111

            0000[1111111] | 0001[0000000] => 0001[1111111]

            987654 3210
            000100 1111
            000100 0111
        */
        int n = nums.size();
        vector<int> res(n, -1);
        for(int i=0; i<n; i++){
            int num = nums[i];
            if(num%2==0) continue;

            int consectuive_one = 0;
            for(int shift=0; shift<32; shift++){
                if((num>>shift)&1) consectuive_one = shift;
                else break;
            }
            res[i] = num - (1<<consectuive_one);
        }
        return res;
    }
};",1420016811
avienn_x,avienn_x,244,3487,cpp,"class Solution {
public:
    vector<int> computeZ(const string& str) {
        int n = str.size();
        vector<int> Z(n, 0);
        int l = 0, r = 0;
        for(int i = 1; i < n; ++i){
            if(i <= r){
                Z[i] = min(r - i + 1, Z[i - l]);
            }
            while(i + Z[i] < n && str[Z[i]] == str[i + Z[i]]){
                Z[i]++;
            }
            if(i + Z[i] - 1 > r){
                l = i;
                r = i + Z[i] - 1;
            }
        }
        return Z;
    }
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(), m = p.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> match(n, false);
        int ans = t.size();
        vector<int> z_match = computeZ(s + ""$"" + p);
        for(int i : t)
            match[i] = true;
        for(int i = 0; i < n; ++i){
            for(int j = m; j > 0; --j){
                if(s[i] != p[j - 1])
                    continue;
                if(dp[j - 1] == INT_MAX)
                    continue;
                int curr = dp[j - 1];
                if(match[i])
                    curr++;
                dp[j] = min(dp[j], curr);
            }
        }
        ans -= dp[m];
        if(dp[m] == INT_MAX)
            return 0;
        return ans;
    }
};",1420107045
avienn_x,avienn_x,244,3604,cpp,"const long long MOD = 1000000007;
const int MAX_N = 1000; 
const int MAX_X = 1000; 
long long Cpre[MAX_X + 1][MAX_X + 1];
long long Spre[MAX_N + 1][MAX_X + 1];
long long factpre[MAX_X + 1];
long long yp[MAX_X + 1];

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        factpre[0] = 1;
        yp[0] = 1;
        Spre[0][0] = 1;
        for(int i = 0; i <= x; ++i){
            if(i){
                factpre[i] = (factpre[i-1] * i) % MOD;
                yp[i] = (yp[i-1] * y) % MOD;
            }
            Cpre[i][0] = 1;
            for(int j = 1; j <= i; ++j)
                Cpre[i][j] = (Cpre[i-1][j-1] + Cpre[i-1][j]) % MOD;
        }
        for(int i = 1; i <= n; ++i){
            for(int j = 1; j <= x; ++j)
                Spre[i][j] = (j * Spre[i-1][j] + Spre[i-1][j-1]) % MOD;
        }
        long long ans = 0;
        for(int k = 1; k <= x; ++k){
            if(k > x || k > n)
                continue;
            long long curr = (Cpre[x][k] * Spre[n][k]) % MOD;
            curr = (curr * factpre[k]) % MOD;
            curr = (curr * yp[k]) % MOD;
            curr %= MOD;
            ans = (ans + curr) % MOD;
            ans %= MOD;
        }
        return (int)(ans);
    }
};
",1420091460
avienn_x,avienn_x,244,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        int n = arr.size();
        map<int,int> freq;
        for(int i : arr)
            freq[i]++;
        vector<int> ans;
        for (int i : arr) {
            int minv = INT_MAX;
            for (int k = 0; k <= log2(i) + 1; k++) {
                int x = i ;
                int curr_bit = (1 << k);
                x -= curr_bit ;
                if(x < 0 || (((x | (x + 1)) != i)))
                    continue;
                if (x < minv)
                    minv = x;
            }
            if(minv != INT_MAX)
                ans.push_back(minv);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};",1420024725
avienn_x,avienn_x,244,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        int n = arr.size();
        map<int,int> freq;
        for(int i : arr)
            freq[i]++;
        vector<int> ans;
        for (int i : arr) {
            int minv = INT_MAX;
            for (int k = 0; k <= log2(i) + 1; k++) {
                int x = i ;
                int curr_bit = (1 << k);
                x -= curr_bit ;
                if(x < 0 || (((x | (x + 1)) != i)))
                    continue;
                if (x < minv)
                    minv = x;
            }
            if(minv != INT_MAX)
                ans.push_back(minv);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};",1420024086
Lt Simon Riley,simon-riley,245,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        is_t = [False] * n
        
        for idx in targetIndices:
            is_t[idx] = True
        
        i = 0
        while i < n:
            j = m
            while j > 0:
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if is_t[i] else 0))
                j -= 1
            i += 1
        
        return len(targetIndices) - (dp[m] if dp[m] != float('inf') else 0)
",1420103719
Lt Simon Riley,simon-riley,245,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        l = [n, x, y]
        
        C = [[0] * (x + 1) for _ in range(x + 1)]
        i = 0
        while i <= x:
            C[i][0] = 1
            j = 1
            while j <= i:
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
                j += 1
            i += 1
        
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1
        i = 1
        while i <= n:
            j = 1
            while j <= x:
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
                j += 1
            i += 1
        
        fact = [1] * (x + 1)
        i = 1
        while i <= x:
            fact[i] = fact[i - 1] * i % MOD
            i += 1
        
        r = 0
        k = 1
        while k <= x:
            pwr = pow(y, k, MOD)
            r = (r + C[x][k] * S[n][k] % MOD * fact[k] % MOD * pwr % MOD) % MOD
            k += 1
        
        return r
",1420107323
Lt Simon Riley,simon-riley,245,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n
        i = 0
        
        while i < n:
            num = nums[i]
            min_ans = float('inf')
            found = False
            bit = 0
            
            while bit < 31:
                if (num >> bit) & 1:
                    cand = num & ~(1 << bit)
                    
                    if cand < 0:
                        bit += 1
                        continue
                    
                    if (cand | (cand + 1)) == num:
                        if cand < min_ans:
                            min_ans = cand
                            found = True
                
                bit += 1
            
            if found:
                res[i] = min_ans
            else:
                res[i] = -1

            i += 1
            
        return res
",1420099067
Lt Simon Riley,simon-riley,245,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n
        i = 0
        
        while i < n:
            num = nums[i]
            min_ans = float('inf')
            found = False
            bit = 0
            
            while bit < 31:
                if (num >> bit) & 1:
                    cand = num & ~(1 << bit)
                    
                    if cand < 0:
                        bit += 1
                        continue
                    
                    if (cand | (cand + 1)) == num:
                        if cand < min_ans:
                            min_ans = cand
                            found = True
                
                bit += 1
            
            if found:
                res[i] = min_ans
            else:
                res[i] = -1

            i += 1
            
        return res
",1420100201
Sarthak Tirpude,sarthak_tirpude,248,3487,cpp,"class Solution {
public:
    int dp[3005][3005];
    int help(int i,int j,string &a,string &b,set<int> &st){
        if(j==b.size()){
            // i se lekar n-1 jitne bhi st mei 
            int ans=0;
            for(int k=i;k<a.size();++k){
                if(st.count(k)) ++ans;
            }
            return ans;
        }
        if(i==a.size()){
            return -1000006;
        }
        if(dp[i][j]!=-1) return dp[i][j];
        if(a[i]==b[j]){
            // pick , not pick
            if(st.count(i)){
                int c1 = help(i+1,j+1,a,b,st);
                int c2 = 1 + help(i+1,j,a,b,st);
                return dp[i][j]=max(c1,c2);
            }
            else{
                return dp[i][j]=help(i+1,j+1,a,b,st);
            }
        }
        else{
            int cnt=0;
            if(st.count(i)) cnt++;
            return dp[i][j]=cnt + help(i+1,j,a,b,st);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        set<int> st(targetIndices.begin(),targetIndices.end());
        int n=source.size();
        for(int i=0;i<n+3;++i){
            for(int j=0;j<n+3;++j) dp[i][j]=-1;
        }
        return help(0,0,source,pattern,st);
    }
};",1420038585
Sarthak Tirpude,sarthak_tirpude,248,3604,cpp,"long long int mod = 1e9 + 7;
long long int binary_exponentiation(long long int a,long long int b){
    a%=mod;
    long long int result = 1,base = a, exp = b;
    while (exp > 0) {
        if (exp & 1){
            result = result * base;
            result %= mod;
        }
        base = base * base;
        base %= mod;
        exp >>= 1;
    }
    return result%mod;
}
long long int modularInv(long long int a){
    return binary_exponentiation(a,mod-2);
}
class Solution {
public:
    long long int dp[1101][1101];
    long long int fact[1101];
    long long int nCr(int n,int r){
        long long temp = fact[n];
        // cout<<""n: ""<<n<<"" fact[n]: ""<<fact[n]<<endl;
        temp = (modularInv(fact[n-r])%mod * temp%mod)%mod;
        // cout<<""n-r: ""<<fact[n-r]<<endl;
        temp = (modularInv(fact[r])%mod * temp%mod)%mod;
        // cout<<""r: ""<<fact[r]<<endl;
        return temp;
    }
    int numberOfWays(int n, int x, int y) {
        long long mod = 1e9 + 7;
        for(int i=1;i<=n;++i) dp[i][1]=1;
        for(int i=1;i<=n;++i) dp[i][i]=1;
        for(int i=1;i<=n;++i){
            for(int k=1;k<i;++k){
                dp[i][k] = ((k%mod * dp[i-1][k]%mod)%mod + dp[i-1][k-1]%mod)%mod;
            }
        }
        fact[0]=1;
        fact[1]=1;
        for(long long int i = 2;i<=max(n,x)+10;++i){
            fact[i] = (i%mod * fact[i-1]%mod) % mod;
        }
        long long ans=0ll;
        for(int i=1;i<=min(x,n);++i){
            long long res = dp[n][i];
            // cout<<""s n i: ""<<dp[n][i]<<endl;
            res = (res% mod * nCr(x,i)% mod)% mod;
            // cout<<""ncr: "" << nCr(x,i)<<endl;
            res = (res % mod * fact[i]% mod)% mod;
            // cout<<""fact: ""<<fact[i]<<endl;
            res = (res % mod * binary_exponentiation(y,i) % mod)% mod;
            // cout<<""y^i: ""<<binary_exponentiation(y,i)<<endl;
            // cout<<res<<endl;
            ans = (ans% mod + res% mod)% mod;
        }
        return ans%mod;
        
        
        
        return 0;
    }
};",1420107537
Sarthak Tirpude,sarthak_tirpude,248,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;++i){
            bool p=false;
            for(int temp=0;temp<1101;++temp){
                if((temp | (temp + 1)) == nums[i]){
                    p=true;
                    ans.push_back(temp);
                    break;
                }
            }
            if(!p) ans.push_back(-1);
        }
        return ans;
    }
};",1419995080
Sarthak Tirpude,sarthak_tirpude,248,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;++i){
            if(nums[i]==2){
                ans.push_back(-1);
                continue;
            }
            vector<int> bit(33);
            for(int j=0;j<31;++j){
                int tc=(1<<j);
                if(tc & nums[i]) ++bit[j];
            }
            int cont=0;
            int j=0;
            while(j<31 and bit[j]==1) ++j;
            if(j==1){
                ans.push_back(nums[i]-1);
                continue;
            }
            else{
                --j;
                bit[j]=0;
            }
            int res=0;
            for(int j=0;j<31;++j){
                int tc=(1<<j);
                if(bit[j]) res|=tc;
            }
            ans.push_back(res);
        }
        return ans;
    }
};",1420021078
E22CSEU0420,MCNHWOyhJd,249,3487,golang,"func maxRemovals(source string, pattern string, targetIndices []int) int {
    n := len(source)
    m := len(pattern)

    // Initialize dp array with 'infinity' (max int value)
    dp := make([]int, m+1)
    for i := 1; i <= m; i++ {
        dp[i] = math.MaxInt32
    }
    dp[0] = 0

    // Initialize isTarget array to track the removable indices
    isTarget := make([]bool, n)
    for _, idx := range targetIndices {
        isTarget[idx] = true
    }

    // Dynamic Programming process
    for i := 0; i < n; i++ {
        for j := m; j > 0; j-- {
            if source[i] == pattern[j-1] && dp[j-1] != math.MaxInt32 {
                if isTarget[i] {
                    dp[j] = min(dp[j], dp[j-1]+1)
                } else {
                    dp[j] = min(dp[j], dp[j-1])
                }
            }
        }
    }

    // Calculate the result
    if dp[m] == math.MaxInt32 {
        return 0
    }
    return len(targetIndices) - dp[m]
}",1420070580
E22CSEU0420,MCNHWOyhJd,249,3604,golang,"const MOD = 1000000007

func numberOfWays(n int, x int, y int) int {
    // Initialize combination array
    comb := make([][]int, x+1)
    for i := range comb {
        comb[i] = make([]int, x+1)
    }

    // Fill combination array using Pascal's triangle logic
    for i := 0; i <= x; i++ {
        comb[i][0] = 1
        for j := 1; j <= i; j++ {
            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
        }
    }

    // Initialize Stirling numbers of the second kind
    stirling := make([][]int, n+1)
    for i := range stirling {
        stirling[i] = make([]int, x+1)
    }
    stirling[0][0] = 1
    for i := 1; i <= n; i++ {
        for j := 1; j <= x; j++ {
            stirling[i][j] = (j*stirling[i-1][j] + stirling[i-1][j-1]) % MOD
        }
    }

    // Factorial array initialization
    factorial := make([]int, x+1)
    factorial[0] = 1
    for i := 1; i <= x; i++ {
        factorial[i] = factorial[i-1] * i % MOD
    }

    // Calculate the result using the precomputed arrays
    totalWays := 0
    for k := 1; k <= x; k++ {
        yPow := modPow(y, k, MOD)
        totalWays = (totalWays + comb[x][k]*stirling[n][k]%MOD*factorial[k]%MOD*yPow%MOD) % MOD
    }

    return totalWays
}

// Helper function to calculate (base^exp) % mod
func modPow(base, exp, mod int) int {
    result := 1
    for exp > 0 {
        if exp%2 == 1 {
            result = result * base % mod
        }
        base = base * base % mod
        exp /= 2
    }
    return result
}
",1420094832
E22CSEU0420,MCNHWOyhJd,249,3605,golang,"func minBitwiseArray(nums []int) []int {
    // Initialize the result array with -1
    result := make([]int, len(nums))
    for i := range result {
        result[i] = -1
    }

    // Iterate over the indices of the input array
    for i := 0; i < len(nums); i++ {
        // Iterate over possible values of result[i]
        for j := 0; j < nums[i]; j++ {
            // Check if the condition is satisfied
            if j|(j+1) == nums[i] {
                // Update the result array with the minimum possible value
                result[i] = j
                break
            }
        }
    }

    // Return the result array
    return result
}
",1420018519
E22CSEU0420,MCNHWOyhJd,249,3611,golang,"func minBitwiseArray(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)

    // Iterate over the input array
    for i := 0; i < n; i++ {
        num := nums[i]
        minimalAns := int(^uint(0) >> 1) // Set to maximum integer value (like Integer.MAX_VALUE in Java)
        found := false

        // Iterate through each bit position (0 to 30)
        for bit := 0; bit <= 30; bit++ {
            if (num>>bit)&1 == 1 {
                // Unset the current bit
                candidate := num & ^(1 << bit)

                // Ensure candidate is non-negative
                if candidate < 0 {
                    continue
                }

                // Check if candidate OR (candidate + 1) equals num
                if (candidate | (candidate + 1)) == num {
                    if candidate < minimalAns {
                        minimalAns = candidate
                        found = true
                    }
                }
            }
        }

        if found {
            ans[i] = minimalAns
        } else {
            ans[i] = -1
        }
    }

    return ans
}
",1420049755
Aasirikram,Aasirikram,251,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, removable_indices: List[int]) -> int:
        source_length = len(source)
        pattern_length = len(pattern)
        
        # dp array to track minimum removals needed to match pattern
        min_removals = [float('inf')] * (pattern_length + 1)
        min_removals[0] = 0  # No removals needed to match empty pattern
        
        # Array to mark which indices in source can be removed
        can_remove = [False] * source_length
        for index in removable_indices:
            can_remove[index] = True
        
        # Dynamic programming to find the minimum removals needed
        for i in range(source_length):
            for j in range(pattern_length, 0, -1):
                if source[i] == pattern[j - 1] and min_removals[j - 1] != float('inf'):
                    min_removals[j] = min(min_removals[j], min_removals[j - 1] + (1 if can_remove[i] else 0))
        
        # Calculate the maximum number of removable characters
        if min_removals[pattern_length] == float('inf'):
            return len(removable_indices)  # If pattern can't be formed, return total removals
        return len(removable_indices) - min_removals[pattern_length]
          ",1420097323
Aasirikram,Aasirikram,251,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, total: int, groups: int, y_value: int) -> int:
        # Initialize arrays for combinations, Stirling numbers, and factorials
        combination = [[0] * (groups + 1) for _ in range(groups + 1)]
        stirling = [[0] * (groups + 1) for _ in range(total + 1)]
        factorial = [1] * (groups + 1)

        # Precompute combinations (C)
        for i in range(groups + 1):
            combination[i][0] = 1
            for j in range(1, i + 1):
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD

        # Precompute Stirling numbers of the second kind (S)
        stirling[0][0] = 1
        for i in range(1, total + 1):
            for j in range(1, groups + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD

        # Precompute factorials
        for i in range(1, groups + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        result = 0
        # Main computation loop
        for k in range(1, groups + 1):
            # Calculate y_value^k
            power = pow(y_value, k, MOD)
            result = (result + combination[groups][k] * stirling[total][k] % MOD * factorial[k] % MOD * power % MOD) % MOD

        return result
        ",1420099553
Aasirikram,Aasirikram,251,3605,cpp,"#include <vector>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> result;
        
        for (int number : nums) {
            int smallestValue = findSmallestValue(number);
            result.push_back(smallestValue);
        }
        
        return result;
    }

private:
    int findSmallestValue(int target) {
        for (int candidate = 0; candidate <= target; ++candidate) {
            if ((candidate | (candidate + 1)) == target) {
                return candidate;  // Return the smallest valid candidate
            }
        }
        return -1;  // Return -1 if no valid candidate found
    }
};",1420101993
Aasirikram,Aasirikram,251,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> a) {
        int n = a.size();
        int[] b = new int[n];
        
        for (int i = 0; i < n; i++) {
            int x = a.get(i);
            int y = Integer.MAX_VALUE;
            boolean f = false;
            
            // Iterate through each bit position (0 to 30)
            for (int j = 0; j <= 30; j++) {
                if (((x >> j) & 1) == 1) {
                    // Unset the current bit
                    int z = x & ~(1 << j);
                    
                    // Ensure z is non-negative
                    if (z < 0) continue;
                    
                    // Check if z OR (z + 1) equals x
                    if ((z | (z + 1)) == x) {
                        if (z < y) {
                            y = z;
                            f = true;
                        }
                    }
                }
            }
            
            if (f) {
                b[i] = y;
            } else {
                b[i] = -1;
            }
        }
        
        return b;
    }
}",1420094615
Amay Singh,Amay12,253,3487,python3,"def bpm(u, seen, match_r,adj):        
        for v in adj[u]:
            if not seen[v]:
                seen[v] = True
                if match_r[v] == -1 or bpm(match_r[v], seen, match_r,adj):
                    match_r[v] = u
                    return True
        return False
def fsubs(s, p, removed_set):
        j= 0
        for i, char in enumerate(s):
            if i in removed_set:
                continue
            if char == p[j]:
                j+= 1
                if j== len(p):
                    return True
        return j== len(p)
import math
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:      
        n = len(source)
        m = len(pattern)
        t = len(targetIndices)
        ts = set(targetIndices)        
        INF = math.inf
        dp = [ [INF]*(n+1) for _ in range(m+1)]
        pn=pattern        
        for j in range(n+1):
            dp[0][j] = 0
        
        for j in range(1, m+1):
            for jj in range(1, n+1):
                if source[jj-1] == pn[j-1]:                    
                    dp[j][jj] = min(
                        dp[j][jj-1],
                        dp[j-1][jj-1] + (1 if (jj-1) in ts else 0)
                    )
                else:                    
                    dp[j][jj] = dp[j][jj-1]
        
        
        if dp[m][n] == INF:
            return 0        
        p = dp[m][n]  
        ans= t - p   
        return ans",1420103080
Amay Singh,Amay12,253,3604,python3,"MOD=10**9+7

def compute_factorials(max_n):
    factorial = [1] * (max_n + 1)
    for i in range(1, max_n + 1):
        factorial[i] = (factorial[i-1] * (i % MOD))%MOD
    return factorial

def compute_inverse_factorials(factorial):
    max_n = len(factorial) -1
    inv_fact = [1] * (max_n +1)
    inv_fact[max_n] = pow(factorial[max_n], MOD-2, MOD)
    for i in range(max_n-1, -1, -1):
        inv_fact[i] = (inv_fact[i+1] * ((i+1) % MOD))%MOD
    return inv_fact

def binomial_coefficient(n, k, factorial, inv_fact):
    if k <0 or k >n:
        return 0
    else:
        return ((factorial[n]%MOD) *inv_fact[k] % MOD* inv_fact[n -k] % MOD)%MOD

def csn(n, k_max):
    
    S = [ [0]*(k_max+1) for _ in range(n+1) ]
    S[0][0] =1
    for i in range(1, n+1):
        for j in range(1, min(k_max, i)+1):
            S[i][j] = (j * S[i-1][j] + S[i-1][j-1]) % MOD
    return S

    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:        
        m_fact = max(x, n)
        factorial = compute_factorials(m_fact)
        i_fact = compute_inverse_factorials(factorial)
        
        k_max = min(n, x)
        S = csn(n, k_max)        
        ans=0
        for k in range(1, k_max +1):
            comb = binomial_coefficient(x, k, factorial, i_fact)
            stir = S[n][k]           
            fact_k = factorial[k]            
            y_pow_k = pow(y,k,MOD)
            
            xx= ((comb%MOD) * (stir%MOD)) % MOD
            xx= xx * fact_k % MOD
            xx = xx * y_pow_k % MOD
            ans= (ans%MOD+ xx%MOD) % MOD
        return ans
        ",1420048572
Amay Singh,Amay12,253,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            x = 0
            temp = i            
            while (temp & 1):
                x+=1
                temp >>=1
            if x==0:
                ans.append(-1)
            else:
                y= i - (1 << (x-1))                
                if (y | (y +1)) == i:
                    ans.append(y)
                else:
                    ans.append(-1)
        return ans
        ",1420000172
Amay Singh,Amay12,253,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            x = 0
            temp = i            
            while (temp & 1):
                x+=1
                temp >>=1
            if x==0:
                ans.append(-1)
            else:
                y= i - (1 << (x-1))                
                if (y | (y +1)) == i:
                    ans.append(y)
                else:
                    ans.append(-1)
        return ans
        ",1419999147
Imadra,Imadra,254,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int k = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());

        const int INF = INT_MAX / 2;
        vector<vector<int>> dp(k + 1, vector<int>(n + 1, INF));

        for (int j = 0; j <= n; ++j) {
            dp[0][j] = 0;
        }

        for (int i = 0; i < k; ++i) {
            for (int j = 0; j < n; ++j) {
                if (dp[i][j] < INF) {
                    dp[i][j + 1] = min(dp[i][j + 1], dp[i][j]);
                    if (pattern[i] == source[j]) {
                        int cost = dp[i][j] + (targetSet.count(j) ? 1 : 0);
                        dp[i + 1][j + 1] = min(dp[i + 1][j + 1], cost);
                    }
                }
            }
        }

        int minCost = INF;
        for (int j = 0; j <= n; ++j) {
            minCost = min(minCost, dp[k][j]);
        }

        if (minCost >= INF) {
            return 0;
        }

        int m = targetIndices.size();
        return m - minCost;
    }
};",1420065617
Imadra,Imadra,254,3604,cpp,"typedef long long ll;
const ll MOD = 1000000007;
const int MAX_N = 1000;
class Solution {
public:
    ll modPow(ll base, ll exponent, ll mod) {
        ll result = 1;
        base %= mod;  // Ensure base is within mod
        while (exponent > 0) {
            if (exponent % 2 == 1) {  // If exponent is odd
                result = (result * base) % mod;
            }
            base = (base * base) % mod;  // Square the base
            exponent /= 2;
        }
        return result;
    }

    // Function to compute factorial modulo MOD
    std::vector<ll> computeFactorials(int max_n, ll mod) {
        std::vector<ll> factorial(max_n + 1, 1);
        for (int i = 1; i <= max_n; ++i) {
            factorial[i] = (factorial[i - 1] * i) % mod;
        }
        return factorial;
    }

    // Function to compute inverse factorials modulo MOD
    std::vector<ll> computeInverseFactorials(const std::vector<ll>& factorial, ll mod) {
        int max_n = factorial.size() - 1;
        std::vector<ll> inv_factorial(max_n + 1, 1);
        inv_factorial[max_n] = modPow(factorial[max_n], mod - 2, mod);
        for (int i = max_n - 1; i >= 0; --i) {
            inv_factorial[i] = (inv_factorial[i + 1] * (i + 1)) % mod;
        }
        return inv_factorial;
    }

    // Function to compute nCr modulo MOD
    ll modComb(int n, int r, const std::vector<ll>& factorial, const std::vector<ll>& inv_factorial, ll mod) {
        if (r < 0 || r > n) return 0;
        return (((factorial[n] * inv_factorial[r]) % mod) * inv_factorial[n - r]) % mod;
    }

    // Function to compute Stirling numbers of the second kind modulo MOD
    std::vector<std::vector<ll>> computeStirlingNumbers(int n, int k_max, ll mod) {
        std::vector<std::vector<ll>> S(n + 1, std::vector<ll>(k_max + 1, 0));
        S[0][0] = 1;
        for (int N = 1; N <= n; ++N) {
            for (int K = 1; K <= std::min(N, k_max); ++K) {  // Corrected loop condition
                S[N][K] = (K * S[N - 1][K] % mod + S[N - 1][K - 1]) % mod;
            }
        }
        return S;
    }

    int numberOfWays(int n, int x, int y) {
        int max_n = std::max(n, x);
        std::vector<ll> factorial = computeFactorials(max_n, MOD);
        std::vector<ll> inv_factorial = computeInverseFactorials(factorial, MOD);
        
        // Compute Stirling numbers of the second kind
        std::vector<std::vector<ll>> S = computeStirlingNumbers(n, x, MOD);
        
        ll total_sum = 0;
        int k_max = std::min(n, x);
        
        for (int k = 1; k <= k_max; ++k) {
            // Compute combination C(x, k)
            ll comb = modComb(x, k, factorial, inv_factorial, MOD);
            
            // Compute k!
            ll k_fact = factorial[k];
            
            // Get S(n, k)
            ll S_nk = S[n][k];
            
            // Compute y^k % MOD
            ll y_pow_k = modPow(y % MOD, k, MOD);
            
            // Compute term: comb * k_fact * S_nk * y_pow_k % MOD
            ll term = (((((comb * k_fact) % MOD) * S_nk) % MOD) * y_pow_k) % MOD;  // Adjusted order to prevent overflow
            
            // Add to total sum
            total_sum = (total_sum + term) % MOD;
        }

        return total_sum;
    }
};",1420103135
Imadra,Imadra,254,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto el : nums) {
            bool f = 0;
            for(int i=1;i<=el+1;i++) {
                if((i | (i + 1)) == el) {
                    // cout<<i<<"" ""<<i+1<<"" ""<<i|(i + 1)<<"" ""<<el<<endl;
                    ans.push_back(i);
                    f = 1;
                    break;
                }
            }
            if(f == 0)
                ans.push_back(-1);
        }
        return ans;
    }
};",1419998792
Imadra,Imadra,254,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto n : nums) {
            if(n == 2) {
                ans.push_back(-1);
                continue;
            }
            unsigned int current_length = 0;  // Length of consecutive 1's starting from LSB
            unsigned int position = 0;        // Current bit position
            unsigned int seq_end_pos = 0;     // Position of the most significant bit in the sequence

            unsigned int temp_n = n;

            // Find the longest sequence of consecutive 1's starting from LSB
            while ((temp_n & 1) == 1) {
                current_length++;
                temp_n >>= 1;
                position++;
            }

            if (current_length > 0) {
                seq_end_pos = position - 1;       // Position of the most significant bit in the sequence
                n ^= (1U << seq_end_pos);         // Flip the most significant bit of the sequence
            }


            ans.push_back(n);
        }
        return ans;
    }
};",1420020731
john0312acc223,john0312acc223,256,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        vector<int> cbest(pattern.size()+1, -10*n);
        vector<int> nbest(pattern.size()+1, -10*n);
        int ti_idx = 0;
        for (int i = 0; i < n; i++) {
            if (source[i] == pattern[0]) {
                nbest[0] = ti_idx;
            } else {
                nbest[0] = -10*n;
            }
            if (ti_idx < targetIndices.size() && targetIndices[ti_idx] == i) {
                // Removable
                nbest[0] = max(nbest[0], cbest[0]+1);
                for (int j = 1; j < pattern.size(); j++) {
                    nbest[j] = cbest[j]+1;
                    if (pattern[j] == source[i]) {
                        nbest[j] = max(cbest[j-1], nbest[j]);
                    }
                }
                ti_idx++;
            } else {
                // Non-removable
                nbest[0] = max(nbest[0], cbest[0]);
                for (int j = 1; j < pattern.size(); j++) {
                    if (pattern[j] == source[i]) {
                        nbest[j] = max(cbest[j-1], cbest[j]);
                    } else {
                        nbest[j] = cbest[j];
                    }
                }
            }
            cbest.swap(nbest);
        }
        return cbest[pattern.size()-1];
    }
};",1420051876
john0312acc223,john0312acc223,256,3604,cpp,"constexpr long long MOD = 1000000007LL;

class Solution {
public:
    long long Cnk_cache[1024][1024];
    long long Cnk(long long n, long long k) {
        if (Cnk_cache[n][k] != -1) return Cnk_cache[n][k];
        if (k == 0 || k == n) {
            Cnk_cache[n][k] = 1;
            return 1;
        }
        Cnk_cache[n][k] = (Cnk(n-1, k-1) + Cnk(n-1, k))%MOD;
        return Cnk_cache[n][k];
    }

    long long Exp_cache[1024][1024];
    long long Exp(long long base, long long pow) {
        if (Exp_cache[base][pow] != -1) return Exp_cache[base][pow];
        if (pow == 1) {
            Exp_cache[base][pow] = base%MOD;
            return Exp_cache[base][pow];
        }
        if (pow == 0) {
            Exp_cache[base][pow] = 1;
            return 1;
        }
        Exp_cache[base][pow] = (Exp(base, pow-1)*base)%MOD;
        return Exp_cache[base][pow];
    }

    long long F_cache[1024][1024];
    long long F(long long x, long long n) {
        if (F_cache[x][n] != -1) return F_cache[x][n];
        if (x == 1) return 1;

        long long cval = Exp(x, n);
        for (int i = 1; i < x; i++) {
            long long itm_val = (F(i, n)*Cnk(x, i))%MOD;
            cval += (MOD - itm_val);
            cval = cval % MOD;
        }

        F_cache[x][n] = cval;
        return cval;
    }

    int numberOfWays(int n, int x, int y) {
        memset(Cnk_cache, -1, sizeof(Cnk_cache));
        memset(F_cache, -1, sizeof(F_cache));
        memset(Exp_cache, -1, sizeof(Exp_cache));

        long long res = 0;
        for (int i = 1; i <= min(x, n); i++) {
            long long citm = F(i, n) % MOD;
            //printf(""F(%d, %d) = %d\n"", i, n, citm);
            //printf(""Exp(%d, %d) = %d\n"", y, i, Exp(y, i));
            citm = (citm * Cnk(x, i))%MOD;
            citm = (citm * Exp(y, i))%MOD;
            res += citm;
            res = res % MOD;
        }

        return res;
    }
};",1420110291
john0312acc223,john0312acc223,256,3605,cpp,"class Solution {
public:
    bool testOK(long long tval, long long x) {
        return (tval | (tval + 1)) == x;
    }
    long long solve(long long x) {
        if (x == 2) return -1;
        long long res = x-1;
        for (int i = 1; i < 32; i++) {
            if (((1LL<<i) & x) == 0) {
                // Not going to work.
                continue;
            }
            long long tval = (x & (~((1LL<<i)-1)))-1;
            if (testOK(tval, x)) {
                res = min(res, tval);
            }
        }
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            long long ans = solve(nums[i]);
            res.push_back(static_cast<int>(ans));
        }
        return res;
    }
};",1420012974
john0312acc223,john0312acc223,256,3611,cpp,"class Solution {
public:
    bool testOK(long long tval, long long x) {
        return (tval | (tval + 1)) == x;
    }
    long long solve(long long x) {
        if (x == 2) return -1;
        long long res = x-1;
        for (int i = 1; i < 32; i++) {
            if (((1LL<<i) & x) == 0) {
                // Not going to work.
                continue;
            }
            long long tval = (x & (~((1LL<<i)-1)))-1;
            if (testOK(tval, x)) {
                res = min(res, tval);
            }
        }
        return res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            long long ans = solve(nums[i]);
            res.push_back(static_cast<int>(ans));
        }
        return res;
    }
};",1420012506
Nikhil Gupta,user4367Y,257,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& idx) {
        int n = s.size();
        int m = t.size();
        int dp[m+1];
        int vis[n];
        memset(vis,0,sizeof(vis));
        for(int i=0;i<m+1;i++){
            dp[i] = 1e9;
        }
        dp[0]=0;
        for(auto i:idx)vis[i]=1;
        for(int i=0;i<n;i++){
            for(int j=m;j>0;j--){
                if(s[i]==t[j-1] && dp[j-1]!=1e9){
                    dp[j] = min(dp[j],dp[j-1]+vis[i]);
                }
            }
        }
        int ans = (int)idx.size();
        if(dp[m]!=1e9)ans-=dp[m];
        return ans;
    }
};",1420110387
Nikhil Gupta,user4367Y,257,3604,cpp,"class Solution {
public:
    using ll = long long;
    ll mod = 1e9+7;
    ll fact[1001];
    ll power(ll a,ll b){
        ll ans = 1;
        while(b>0){
            if(b%2){
                ans = (ans*a)%mod;
            }
            a = (a*a)%mod;
            b/=2;
        }
        return ans;
    }
    ll nCr(int n,int r){
        ll num = fact[n];
        ll den = (fact[r]*fact[n-r])%mod;
        den = power(den,mod-2);
        num = (num*den)%mod;
        return num;
    }
    int numberOfWays(int n, int x, int y) {
        fact[0]=1;
        fact[1]=1;
        for(int i=2;i<=x;i++){
            fact[i] = (1LL*fact[i-1]*i)%mod;
        }
        ll ans = 0;
        // ll a[x+1][x+1];
        // memset(a,0,sizeof(a));
        // a[0][0]=1;
        // for(int i=1;i<=x;i++){
        //     for(int j=0;j<=i;j++){
        //         a[i][j] = a[i-1][j];
        //         if(j-1>=0)a[i][j] = (a[i][j]+a[i-1][j-1])%mod;
        //     }
        // }
        ll py[x+1];
        py[0]=1;
        for(int i=1;i<=x;i++){
            py[i] = (1LL*py[i-1]*y)%mod;
        }
        for(ll i=1;i<=x;i++){
            ll sum = 0;
            for(ll j=0;j<=i;j++){
                ll cur = (nCr(i,j)*power(i-j,n))%mod;
                if(j%2){
                    cur*=(-1);
                }
                sum += cur;
                if(sum<0){
                    sum+=mod;
                }
                sum%=mod;
            }
            ll temp = (((nCr(x,i)*sum)%mod)*py[i])%mod;
            ans = (ans+temp)%mod;
        }
        return ans;
    }
};",1420100398
Nikhil Gupta,user4367Y,257,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            int j=0;
            while(j<31 && ((nums[i]>>j)&1)){
                j++;
            }
            j--;
            if(j>=0){
                int cur = 0;
                for(int k=0;k<j;k++){
                    cur |= (1<<k);
                }
                for(int k=j+1;k<31;k++){
                    if((nums[i]>>k)&1){
                        cur |= (1<<k);
                    }
                }
                ans[i]=cur;
            }
        }
        return ans;
    }
};",1420004303
Nikhil Gupta,user4367Y,257,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            int j=0;
            while(j<32 && ((nums[i]>>j)&1)){
                j++;
            }
            j--;
            if(j>=0){
                int cur = 0;
                for(int k=0;k<j;k++){
                    cur |= (1<<k);
                }
                for(int k=j+1;k<32;k++){
                    if((nums[i]>>k)&1){
                        cur |= (1<<k);
                    }
                }
                ans[i]=cur;
            }
        }
        return ans;
    }
};",1420005758
Ashu,_Ashu1729,258,3487,cpp,"#pragma GCC optimize(""O3"")
class Solution {
public:
    long long dp(int i, int j, const std::string& s, const std::string& p, const std::vector<bool>& t, std::vector<std::vector<long long>>& memo) {
        if (j == p.size()) return 0;
        if (i == s.size()) return INT_MAX;

        if (memo[i][j] != -1) return memo[i][j];

        long long x = dp(i + 1, j, s, p, t, memo);
        long long y = INT_MAX;

        if (s[i] == p[j]) {
            y = dp(i + 1, j + 1, s, p, t, memo);
            if (t[i]) {
                y += 1;
            }
        }

        return memo[i][j] = std::min(x, y);
    }

    int maxRemovals(std::string s, std::string p, std::vector<int>& idx) {
        std::vector<bool> t(s.size(), false);
        for (int i : idx) {
            t[i] = true;
        }

        std::vector<std::vector<long long>> memo(s.size() + 1, std::vector<long long>(p.size() + 1, -1));
        long long r = dp(0, 0, s, p, t, memo);

        return r == INT_MAX ? 0 : idx.size() - r;
    }
};",1420083692
Ashu,_Ashu1729,258,3604,cpp,"#pragma GCC optimize(""O3"")
const int MOD = 1e9 + 7;

class Solution {
public:
    void computeDP(int n, int x, std::vector<std::vector<int>>& c, std::vector<std::vector<int>>& s, std::vector<long long>& f) {
        int a = 0;
        while (a <= x) {
            c[a][0] = 1;
            int b = 1;
            while (b <= a) {
                c[a][b] = (c[a - 1][b - 1] + c[a - 1][b]) % MOD;
                b++;
            }
            a++;
        }
        
        s[0][0] = 1;
        a = 1;
        while (a <= n) {
            int b = 1;
            while (b <= x) {
                s[a][b] = (1LL * b * s[a - 1][b] + s[a - 1][b - 1]) % MOD;
                b++;
            }
            a++;
        }
        
        f[0] = 1;
        a = 1;
        while (a <= x) {
            f[a] = (1LL * f[a - 1] * a) % MOD;
            a++;
        }
    }

    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> c(x + 1, std::vector<int>(x + 1, 0));
        std::vector<std::vector<int>> s(n + 1, std::vector<int>(x + 1, 0));
        std::vector<long long> f(x + 1);
        
        computeDP(n, x, c, s, f);
        
        long long res = 0;
        int k = 1;  
        while (k <= x) {
            long long pwr = 1;
            int d = 0;
            while (d < k) {
                pwr = (pwr * y) % MOD;
                d++;
            }
            res = (res + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * pwr % MOD)) % MOD;
            k++;
        }
        
        return res;
    }
};",1420071058
Ashu,_Ashu1729,258,3605,cpp,"#pragma GCC optimize(""O3"")
class Solution {
public:
 int solve(int p) {
    for (int i = 1; i <= p; ++i) {
        if ((i | (i + 1)) == p) {
            return i;
        }
    }
    return -1;
}

vector<int> minBitwiseArray(vector<int>& nums) {
    int n = nums.size();
    vector<int> ans(n, -1);
    for (int i = 0; i < n; ++i) {
        ans[i] = solve(nums[i]);
    }
    return ans;
}

};",1420013479
Ashu,_Ashu1729,258,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& n) {
      int m = n.size();
    std::vector<int> a(m);
    
    for (int i = 0; i < m; i++) {
        int x = n[i];
        int y = std::numeric_limits<int>::max();
        bool z = false;
        int b = 0;

        while (b <= 30) {
            if ((x & static_cast<int>(1 * std::pow(2, b))) != 0) {
                int c = x & ~(static_cast<int>(1 * std::pow(2, b)));
                if (c >= 0 && (c | (c + 1)) == x) {
                    y = std::min(y, c);
                    z = true;
                }
            }
            b++;
        }
        
        a[i] = z ? y : -1;
    }
    
    return a;
    }
};",1420052668
uday,uday5747,260,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val n = source.length
        val m = pattern.length
        val dp = MutableList(m + 1) { Int.MAX_VALUE }
        dp[0] = 0
        val isTarget = BooleanArray(n)
        for (idx in targetIndices) {
            isTarget[idx] = true
        }

        for (i in 0 until n) {
            for (j in m downTo 1) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != Int.MAX_VALUE) {
                    dp[j] = minOf(dp[j], dp[j - 1] + if (isTarget[i]) 1 else 0)
                }
            }
        }

        return targetIndices.size - if (dp[m] == Int.MAX_VALUE) 0 else dp[m]
    }
}
",1420047407
uday,uday5747,260,3604,kotlin,"class Solution {
    private val MOD = 1_000_000_007

    private fun computeCombinations(size: Int): Array<LongArray> {
        val combination = Array(size + 1) { LongArray(size + 1) { 0L } }
        for (i in 0..size) {
            combination[i][0] = 1L
            for (j in 1..i) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD
            }
        }
        return combination
    }

    private fun computePartitions(n: Int, x: Int): Array<LongArray> {
        val partition = Array(n + 1) { LongArray(x + 1) { 0L } }
        partition[0][0] = 1L
        for (i in 1..n) {
            for (j in 1..x) {
                partition[i][j] = (j * partition[i - 1][j] + partition[i - 1][j - 1]) % MOD
            }
        }
        return partition
    }

    private fun computeFactorials(size: Int): LongArray {
        val factorial = LongArray(size + 1) { 1L }
        for (i in 1..size) {
            factorial[i] = (factorial[i - 1] * i) % MOD
        }
        return factorial
    }

    fun numberOfWays(n: Int, x: Int, y: Int): Int {
        val combination = computeCombinations(x)
        val partition = computePartitions(n, x)
        val factorial = computeFactorials(x)

        var result = 0L
        for (k in 1..x) {
            var power = 1L
            repeat(k) {
                power = (power * y) % MOD
            }
            var term = combination[x][k]
            term = (term * partition[n][k]) % MOD
            term = (term * factorial[k]) % MOD
            term = (term * power) % MOD
            result = (result + term) % MOD
        }

        return result.toInt()
    }
}
",1420084031
uday,uday5747,260,3605,kotlin,"class Solution {
    fun findMinAns(prime: Int): Int {
        for (x in 1..prime) {
            if ((x or (x + 1)) == prime) {
                return x
            }
        }
        return -1
    }

    fun minBitwiseArray(nums: List<Int>): IntArray {
        val ans = IntArray(nums.size) { -1 }
        for (i in nums.indices) {
            ans[i] = findMinAns(nums[i])
        }
        return ans
    }
}
",1419996471
uday,uday5747,260,3611,kotlin,"class Solution {

    private fun computeResult(num: Int): Int {
        var lastSetBit = 0
        for (i in 0 until 32) {
            if (num and (1 shl i) != 0) {
                lastSetBit = i
            } else {
                break
            }
        }
        return num - (1 shl lastSetBit)
    }

    fun minBitwiseArray(nums: List<Int>): IntArray {
        val result = IntArray(nums.size) { -1 }
        for (i in nums.indices) {
            if (nums[i] != 2) {
                result[i] = computeResult(nums[i])
            }
        }
        return result
    }
}
",1420066135
Sreesh Maheshwar,sreeshmaheshwar,261,3487,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }  

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& is) {
        // I swear to god if N^2 passess....
        int n = sz(s), m = sz(t);
        vt<bool> in(n);
        for (int i : is) {
            in[i] = true;
        }
        vt<int> dp(m + 1, sz(is) + 100); 
        dp[0] = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = m - 1; j >= 0; --j) {
                // Take character if matches:
                if (s[i] == t[j]) {
                    umin(dp[j + 1], dp[j] + in[i]);
                }
            }
        }
        return sz(is) - dp[m];
    }
};",1420092666
Sreesh Maheshwar,sreeshmaheshwar,261,3604,cpp,"typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;

#define ar array
#define vt vector
#define pb push_back
#define eb emplace_back
#define fi first
#define se second

#define all(c) (c).begin(), (c).end()
#define sz(x) (int)(x).size()

#define CUSTOM_FOR(i, a, b, s) for (int i = (a); (s) > 0 ? i < (b) : i > (b); i += (s))
#define CUSTOM_FOR1(e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR2(i, e) CUSTOM_FOR(i, 0, e, 1)
#define CUSTOM_FOR3(i, b, e) CUSTOM_FOR(i, b, e, 1)
#define CUSTOM_FOR4(i, b, e, s) CUSTOM_FOR(i, b, e, s)
#define RETRIEVE_FIFTH(a, b, c, d, e, ...) e
#define CUSTOM_FORC(...) RETRIEVE_FIFTH(__VA_ARGS__, CUSTOM_FOR4, CUSTOM_FOR3, CUSTOM_FOR2, CUSTOM_FOR1)
#define forn(...) CUSTOM_FORC(__VA_ARGS__)(__VA_ARGS__)

template<typename T> bool umax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }
template<typename T> bool umin(T &a, const T &b) { if (a > b) { a = b; return 1; } return 0; }  

template<const int MOD> struct mod_int {
    int val; mod_int() : val(0) {} mod_int(long long _val) : val(((_val % MOD) + MOD) % MOD) {}
    mod_int pow(int64_t b) const { mod_int r = 1, a = *this; while (b) { if (b & 1) r *= a; a *= a; b >>= 1; } return r; }
    mod_int& operator+=(const mod_int& other) { val += other.val; if (val >= MOD) val -= MOD; return *this; }
    mod_int& operator-=(const mod_int& other) { val -= other.val; if (val < 0) val += MOD; return *this; }
    mod_int& operator*=(const mod_int& other) { val = 1LL * val * other.val % MOD; return *this; }
    mod_int& operator/=(const mod_int& other) { return *this *= other.pow(MOD - 2); }
    friend mod_int operator+(const mod_int& x, const mod_int& y) { return mod_int(x) += y; }
    friend mod_int operator-(const mod_int& x, const mod_int& y) { return mod_int(x) -= y; }
    friend mod_int operator*(const mod_int& x, const mod_int& y) { return mod_int(x) *= y; }
    friend mod_int operator/(const mod_int& x, const mod_int& y) { return mod_int(x) /= y; }
};  
using mint = mod_int<1000000007>;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vt<mint> dp(x+1); // dp[i] is count for i stages taken.
        dp[0] = 1;
        forn(n) {
            vt<mint> ndp(x+1); // dp[i] is count for i stages taken.
            forn(j, x+1) {
                ndp[j]+=dp[j]*j;
                if(j+1<=x)ndp[j+1]+=dp[j]*(x-j);
            }
            dp = ndp;
        }
        mint ans = 0;
        forn(x+1){
            ans += dp[i] * mint(y).pow(i);
        }
        return ans.val;
    }
};",1419997413
Sreesh Maheshwar,sreeshmaheshwar,261,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> ret;
       for (int x : nums) {
            if (x == 2) ret.push_back(-1);
            else {
            int c = 0;
            while (x & 1) {
                x /= 2;
                c++;
            }
            ret.push_back((x << c) + (1 << (c - 1)) - 1);
            }
       }
       return ret;
    }
};",1420104882
Sreesh Maheshwar,sreeshmaheshwar,261,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> ret;
       for (int x : nums) {
            if (x == 2) ret.push_back(-1);
            else {
            int c = 0;
            while (x & 1) {
                x /= 2;
                c++;
            }
            ret.push_back((x << c) + (1 << (c - 1)) - 1);
            }
       }
       return ret;
    }
};",1420104232
Yagnik Dhameliya,dhameliyayagnik28,262,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& idx) {
        int n = s.size(), m = t.size(), k = idx.size();
        vector<int> vis(n);
        for(int i = 0; i < k; i++) vis[idx[i]] = 1;
        vector<int> dp(m + 1, 1e9);
        dp[0] = 0;
        for(int i = 0; i < n; i++)
        {
            for(int j = m - 1; j >= 0; j--)
            {
                if(s[i] == t[j]) dp[j + 1] = min(dp[j + 1], dp[j] + vis[i]);
            }
        }
        if(dp[m] == 1e9) return k;
        return k - dp[m];
    }
};",1420104199
Yagnik Dhameliya,dhameliyayagnik28,262,3604,cpp,"int binExp(int a, int b, int p) 
{
    if(b == 0) return 1;
    a %= p;
    int ans = binExp(a, b >> 1, p) % p;
    ans = (ans * 1LL * ans) % p;
    if(b & 1) return (a * 1LL * ans) % p;
    return ans;
}

class factm {
    public:
    vector<long long> fact, inv;
    int n, mod;
    factm(int size, int M) 
    {
        n = size; 
        mod = M;
        fact.resize(n + 1);
        inv.resize(n + 1);
        fact[0] = 1;
        for(int i = 1; i <= n; i++) 
        {
            fact[i] = (fact[i - 1] * 1LL * i) % mod;
        }

        inv[n] = binExp(fact[n], mod - 2, mod);
        for(int i = n - 1; i >= 0; i--) 
        {
            inv[i] = (inv[i + 1] * (i + 1)) % mod;
        }
    }

    int ncr(int a, int b)
    {
        if(a < b || a < 0 || b < 0) return 0;
        return (((fact[a] * inv[b]) % mod) * (inv[a - b])) % mod;
    }
};

class Solution {
public:
    const int N = 1005;
    const int M = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        factm f(2005, M);
        vector<long long> dp1(N + 1), ndp1(N + 1);
        for(int i = 0; i <= x; i++)
        {
            dp1[0] = 1;
            for(int j = 1; j <= i; j++) ndp1[j] = (dp1[j] + dp1[j - 1]) % M;
            dp1 = ndp1;
        }
        vector<long long> dp2(N + 1), ndp2(N + 1);
        dp2[0] = 1;
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= x; j++) ndp2[j] = (dp2[j] * j + dp2[j - 1]) % M;
            dp2 = ndp2;
        }
        int ans = 0;
        for(int i = 1; i <= x; i++)
        {
            long long cur = (f.fact[i] * 1LL * binExp(y, i, M)) % M;
            cur = (cur * dp1[i]) % M;
            cur = (cur * dp2[i]) % M;
            ans = (ans + cur) % M;
        }
        return ans;
    }
};",1420105258
Yagnik Dhameliya,dhameliyayagnik28,262,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j <= nums[i] - 1; j++)
            {
                if((j | (j + 1)) == nums[i])
                {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420104592
Yagnik Dhameliya,dhameliyayagnik28,262,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++)
        {
            long long mn = 1e18;
            for(int j = 0; j <= 31; j++)
            {
                if(nums[i] & (1 << j))
                {
                    int cur = nums[i] ^ (1 << j);
                    if((cur | (cur + 1)) == nums[i]) mn = min(mn, (long long)cur);
                }
            }
            if(mn != 1e18) ans[i] = (int)mn;
        }
        return ans;
    }
};",1420104517
Kirti Kumar,kirtikumarkk21,263,3487,cpp,"class Solution {
public:
string s,t;
map<int,int>mp;
// string ans;
vector<int>p;
int dp[3002][3002];
int sol(int i,int j)
{

    if(i==s.size())
    {
        if(j==t.size())
        {
            // for(auto it:p)
            // {
            //     cout<<it<<"" "";
            // }
            // cout<<endl;
            return 0;
        }
        return -1e8;
    }
    if(dp[i][j]!=-1)
    {
        return dp[i][j];
    }

    int ans=-1e8;
    if(j==t.size())
    {
        ans=max(ans,mp[i]+sol(i+1,j));
    }
    else
    {
        if(s[i]==t[j])
        {
            // p.push_back(i);
            ans=max(ans,sol(i+1,j+1));
            // p.pop_back();
            
            ans=max(ans,mp[i]+sol(i+1,j));

        }
        else
        {
            ans=max(ans,mp[i]+sol(i+1,j));
        }

    }
    return dp[i][j]=ans;

}
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {

        s=source;
        t=pattern;
        for(auto it:targetIndices)
        {
            mp[it]++;
        }
        memset(dp,-1,sizeof(dp));        
        return sol(0,0);
        
    }
};",1420077275
Kirti Kumar,kirtikumarkk21,263,3604,cpp,"#define MOD 1000000007
typedef int64_t ll;
ll binpow(ll a, ll b, ll m = MOD) {
	a %= m;
	ll res = 1;
	while (b > 0) {
		if (b & 1)
			res = res * a % m;
		a = a * a % m;
		b >>= 1;
	}
	return res % m;
}
ll invmd(ll n)
{
	return (binpow(n, MOD - 2));
}
const int N = 1e3 + 5;
ll fact[N + 2];
ll invfact[N + 2];
ll mul(ll a, ll b)
{
    a=a%MOD;
    b=b%MOD;
    return (a * b) % MOD;
}
ll add(ll a, ll b)
{
    a += b;
    if (a >= MOD)
    {
        a = a - MOD;
    }
    return a;
}
ll sub(ll a, ll b)
{
    a -= b;
    if (a < 0)
    {
        a += MOD;
    }
    return a;
}
ll divid(ll a, ll b)
{
    return mul(a, invmd(b));
}
vector<vector<unsigned long long>> S(N+3, vector<unsigned long long>(N+3, 0));
void calcfactorial()
{
    fact[0] = 1;
    for (int i = 1; i < N - 1; i++)
    {
        fact[i] = mul(i, fact[i - 1]);
    }
    invfact[N - 2] = invmd(fact[N - 2]);
    for (int i = N - 3; i >= 0; i--)
    {
        invfact[i] = mul(invfact[i + 1], i + 1);
    }


 

    // Base cases
    S[0][0] = 1;

    // Fill the DP table
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            S[i][j] = ((j * S[i - 1][j])%MOD + S[i - 1][j - 1]%MOD)%MOD;
        }
    }
    // return S[x][n];
}
ll ncr(ll n, ll k)
{
    return ((fact[n] * invfact[n - k]) % MOD * invfact[k]) % MOD;
}

ll calc(ll n,ll x)
{
    return (fact[n]*S[x][n])%MOD;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        swap(n,x);
        vector<ll>dp(n+1,0);
        ll ans=0;
        calcfactorial();

        for(int i=1;i<n+1;i++)
        {
            ll val=ncr(n,i)%MOD;
            ll val1=calc(i,x)%MOD;
            dp[i]=(val*val1)%MOD;
        }
        for(int i=1;i<n+1;i++)
        {
            ll val=(dp[i]*binpow(y,i))%MOD;
            ans=(ans+val)%MOD;
        }
        return ans%MOD;
        
    }
};",1420111748
Kirti Kumar,kirtikumarkk21,263,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        int n=nums.size();

        vector<int>ans(n,-1);
        int j=0;
        for(auto it:nums)
        {
            for(int i=1;i<1025;i++)
            {
                if((i|(i+1))==it)
                {
                    ans[j]=i;
                    break;
                }
            }
            j++;
        }
        return ans;
    }
};",1419997062
Kirti Kumar,kirtikumarkk21,263,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        int n=nums.size();
        vector<int>ans(n,-1);
        int j=0;
        for(auto it:nums)
        {
            for(int i=30;i>=0;i--)
            {
                int val=(1<<i);
                // cout<<val<<endl;
                if(it-val>=0)
                {
                    val=it-val;
                    if((val|(val+1))==it)
                    {
                        ans[j]=val;
                        break;
                    }
                }
            }
            j++;
        }
        return ans;
        
    }
};",1420021160
Last_Of_UsOO,Last_Of_UsOO,264,3487,cpp,"
#include <bits/stdc++.h>
using namespace std;

#define sz(x) int(x.size());

#define PT(value)                                                              \
    for (auto& ii : value)                                                     \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char* x) { cerr << '\""' << x << '\""'; }
void __print(const string& x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V> void __print(const pair<T, V>& x) {
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T> void __print(const T& x) {
    int f = 0;
    cerr << '{';
    for (auto& i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V> void _print(T t, V... v) {
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)                                                            \
    cerr << ""["" << #x << ""] = ["";                                              \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
};

class Solution {
public:
    const int maxValue = INT_MAX;
    void maximumRemoval(int n, int m, string& source, string& pattern,
                        vector<int>& nums, vector<int>& dpValue,
                        vector<bool>& valueTarget) {
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dpValue[j - 1] != maxValue)
                    dpValue[j] = min(dpValue[j],
                                     dpValue[j - 1] + (valueTarget[i] ? 1 : 0));
            }
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        fastio();
        int n = source.size();
        int m = pattern.size();
        int siz = targetIndices.size();

        vector<int> dpValue(m + 1, maxValue);
        dpValue[0] = 0;

        vector<bool> valueTarget(n, false);
        for (auto& ii : targetIndices)
            valueTarget[ii] = true;

        maximumRemoval(n, m, source, pattern, targetIndices, dpValue,
                       valueTarget);

        return siz - (dpValue[m] == maxValue ? 0 : dpValue[m]);
    }
};",1420063009
Last_Of_UsOO,Last_Of_UsOO,264,3604,cpp,"
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1e9 + 7;
#define sz(x) int(x.size());

#define PT(value)                                                              \
    for (auto& ii : value)                                                     \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char* x) { cerr << '\""' << x << '\""'; }
void __print(const string& x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V> void __print(const pair<T, V>& x) {
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T> void __print(const T& x) {
    int f = 0;
    cerr << '{';
    for (auto& i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V> void _print(T t, V... v) {
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)                                                            \
    cerr << ""["" << #x << ""] = ["";                                              \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
};

class Solution {
public:
    ll numberPossibleWay(int n, int x, int y, vvi& DpValue) {
        vvi DpMaxValue(n + 1, vi(x + 1, 0));
        DpMaxValue[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= x; j++)
                DpMaxValue[i][j] = (j * 1ll * DpMaxValue[i - 1][j] +
                                    DpMaxValue[i - 1][j - 1]) %
                                   MOD;

        vi value(x + 1, 1);
        for (int i = 1; i <= x; ++i)
            value[i] = (ll)value[i - 1] * i % MOD;

        function<ll(ll, ll)> powerValueClc = [&](ll a, ll b) {
            long long result = 1;
            result = a * b;
            return result;
        };
        int ansWerValue = 0;

        for (int i = 1; i <= x; i++) {
            ll power = 1;
            for (int p = 0; p < i; ++p)
                power = (powerValueClc(power, y)) % MOD;
            ll pVal = (ll)DpValue[x][i] * DpMaxValue[n][i] % MOD;
            ll qVal = (ll)value[i] % MOD * power % MOD;
            ansWerValue = ansWerValue + (pVal * qVal) % MOD;
            ansWerValue %= MOD;

        }
        return ansWerValue;
    }
    int numberOfWays(int n, int x, int y) {
        fastio();
        vi numsValue;
        numsValue.push_back(n);
        numsValue.push_back(x);
        numsValue.push_back(y);

        vvi DpValue(x + 1, vi(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            DpValue[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                DpValue[i][j] =
                    (DpValue[i - 1][j - 1] + DpValue[i - 1][j]) % MOD;
            }
        }

        return numberPossibleWay(n, x, y, DpValue);
    }
};",1420105393
Last_Of_UsOO,Last_Of_UsOO,264,3605,cpp,"
#include <bits/stdc++.h>
using namespace std;

#define sz(x) int(x.size());

#define PT(value)          \
    for (auto &ii : value) \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char *x) { cerr << '\""' << x << '\""'; }
void __print(const string &x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V>
void __print(const pair<T, V> &x)
{
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T>
void __print(const T &x)
{
    int f = 0;
    cerr << '{';
    for (auto &i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V>
void _print(T t, V... v)
{
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)               \
    cerr << ""["" << #x << ""] = [""; \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
};



class Solution
{
public:
    int findMinimumValue(int prime)
    {
        for (int x = 1; x <= prime; ++x)
        {
            if ((x | (x + 1)) == prime)
            {
                return x;
            }
        }
        return -1; 
    }

    vector<int> minBitwiseArray(vector<int> &nums)
    {
        fastio();
        int n = nums.size();
        vector<int> ans(n, -1); 
        for (int i = 0; i < n; ++i)
            ans[i] = findMinimumValue(nums[i]);

        return ans;
    }
};",1420006471
Last_Of_UsOO,Last_Of_UsOO,264,3611,cpp,"
#include <bits/stdc++.h>
using namespace std;

#define sz(x) int(x.size());

#define PT(value)                                                              \
    for (auto& ii : value)                                                     \
        cout << ii << "" "";

typedef long long int ll;
typedef unsigned long long int ull;

typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vector<int>> vvi;
typedef vector<vector<ll>> vvl;

void __print(int x) { cerr << x; }
void __print(long x) { cerr << x; }
void __print(long long x) { cerr << x; }
void __print(unsigned x) { cerr << x; }
void __print(unsigned long x) { cerr << x; }
void __print(unsigned long long x) { cerr << x; }
void __print(float x) { cerr << x; }
void __print(double x) { cerr << x; }
void __print(long double x) { cerr << x; }
void __print(char x) { cerr << '\'' << x << '\''; }
void __print(const char* x) { cerr << '\""' << x << '\""'; }
void __print(const string& x) { cerr << '\""' << x << '\""'; }
void __print(bool x) { cerr << (x ? ""true"" : ""false""); }

template <typename T, typename V> void __print(const pair<T, V>& x) {
    cerr << '{';
    __print(x.first);
    cerr << ',';
    __print(x.second);
    cerr << '}';
}
template <typename T> void __print(const T& x) {
    int f = 0;
    cerr << '{';
    for (auto& i : x)
        cerr << (f++ ? "","" : """"), __print(i);
    cerr << ""}"";
}
void _print() { cerr << ""]\n""; }
template <typename T, typename... V> void _print(T t, V... v) {
    __print(t);
    if (sizeof...(v))
        cerr << "", "";
    _print(v...);
}
#ifndef ONLINE_JUDGE
#define debug(x...)                                                            \
    cerr << ""["" << #x << ""] = ["";                                              \
    _print(x)
#else
#define debug(x...)
#endif

static auto fastio = []() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
};

class Solution {
public:
    void bitOperation(vector<int>& result, vector<int>& nums, int n) {
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int ansSwerValue = INT_MAX;
            bool BitValueFound = false;

            for (int i = 0; i <= 30; i++) {
                if (((num >> i) & 1) == 1) {
                    int bitValue = num & ~(1 << i);

                    if (bitValue < 0)
                        continue;
                    if ((bitValue | (bitValue + 1)) == num) {
                        if (bitValue < ansSwerValue) {
                            ansSwerValue = bitValue;
                            BitValueFound = true;
                        }
                    }
                }
            }

            if (BitValueFound)
                result[i] = ansSwerValue;
            else
                result[i] = -1;
        }
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        fastio();
        int n = nums.size();
        vector<int> result(n);
        bitOperation(result, nums, n);

        return result;
    }
};",1420052724
Sarthak Jha,SarthakkJha,265,3487,cpp,"class Solution {
public:
    int recur(string& source, string& pattern, vector<int>& tar, int i, int j, vector<int>& target, vector<vector<int>>& dp) {

        if (j == pattern.size()) {
            return 0;
        }
        if (i == source.size()) {
            return INT_MAX;
        }

        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int notake = recur(source, pattern, tar, i + 1, j, target, dp);

        if (source[i] == pattern[j]) {
            int cost = target[i] ? 1 : 0;
            int ans = recur(source, pattern, tar, i + 1, j + 1, target, dp);
            if (ans != INT_MAX) {
                notake = min(notake, cost + ans);
            }
        }

        return dp[i][j] = notake;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {

        int n = source.size();
        int m = pattern.size();

        vector<vector<int>> dp(n, vector<int>(m, -1));

        vector<int> target(n, 0);

        for (auto it : targetIndices) {
            target[it] = 1;
        }

        int ans = recur(source, pattern, targetIndices, 0, 0, target, dp);

        if(ans == 1e9)
        {
            return 0;
        }
        else
        {
            return targetIndices.size() - ans;
        }

    }
};
",1420084245
Sarthak Jha,SarthakkJha,265,3604,cpp,"class Solution {
public:
    long long MOD = 1e9 + 7;

    long long combination(long long n, long long k, vector<vector<long long>>& comb) {
        if (k == 0 || k == n) return 1;
        if (comb[n][k] != -1) return comb[n][k];
        return comb[n][k] = (combination(n - 1, k - 1, comb) + combination(n - 1, k, comb)) % MOD;
    }

    long long sterling(long long n, long long k, vector<vector<long long>>& strlng) {
        if (n == 0 && k == 0) return 1;
        if (n == 0 || k == 0) return 0;
        if (strlng[n][k] != -1) return strlng[n][k];
        return strlng[n][k] = (k * sterling(n - 1, k, strlng) % MOD + sterling(n - 1, k - 1, strlng)) % MOD;
    }

    long long power(long long x, long long y, long long p = 1e9 + 7) {
        unsigned long long res = 1;
        x = x % p;
        while (y > 0) {
            if (y & 1)
                res = (res * x) % p;
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }

    int numberOfWays(int n, int x, int y) {

        vector<vector<long long>> comb(1001, vector<long long>(1001, -1));
        vector<vector<long long>> snum(1001, vector<long long>(1001, -1));

        vector<long long> fact(x + 1, 1);
        for (int i = 2; i <= x; i++) {
            fact[i] = (long long)fact[i - 1] * i % MOD;
        }

        long long ans = 0;

        for (long long k = 1; k <= x; k++) {
            long long cc = combination(x, k, comb);
            long long stir = sterling(n, k, snum);
            long long val = power(y, k);
            ans = (ans + ((long long)cc * stir % MOD * fact[k] % MOD * val % MOD)) % MOD;
        }

        return ans;
    }
};
",1420111956
Sarthak Jha,SarthakkJha,265,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] % 2 == 0) {
                ans[i] = -1;  
            } else {
                int num = 0;
                int idx = -1;
                
                for(int j = 0; j < 32; j++) {
                    if(((1 << j) & nums[i]) == 0) {
                        idx = j - 1;
                        break;
                    }
                }

                for(int j = 0; j < 32; j++) {
                    if(j == idx) {
                        continue;
                    } else {
                        if((1 << j) & nums[i]) {
                            num += (1 << j);
                        }
                    }
                }

                ans[i] = num; 
            }
        }

        return ans;
    }
};
",1420022691
Sarthak Jha,SarthakkJha,265,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int i = 0; i < nums.size(); i++) {
            if(nums[i] % 2 == 0) {
                ans[i] = -1;  
            } else {
                int num = 0;
                int idx = -1;
                
                for(int j = 0; j < 32; j++) {
                    if(((1 << j) & nums[i]) == 0) {
                        idx = j - 1;
                        break;
                    }
                }

                for(int j = 0; j < 32; j++) {
                    if(j == idx) {
                        continue;
                    } else {
                        if((1 << j) & nums[i]) {
                            num += (1 << j);
                        }
                    }
                }

                ans[i] = num; 
            }
        }

        return ans;
    }
};
",1420022318
transcend_2002,transcend_2002,268,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size(),m=pattern.size();
        vector<int> good(n,0);
        for(int i:targetIndices){
            good[i]=1;
        }
        vector<int> dp(m+1,INT_MIN);
        dp[0]=0;
        for(int i=0;i<n;i++){
            vector<int> temp=dp;
            for(int j=0;j<=m;j++){
                if(dp[j]==INT_MIN)continue;
                if(j==m){
                    temp[m]=max(temp[m],dp[m]+good[i]);
                }else {
                    if(source[i]==pattern[j]){
                        temp[j]=max(temp[j],dp[j]+good[i]);
                        temp[j+1]=max(temp[j+1],dp[j]);
                    }else {
                           temp[j]=max(temp[j],dp[j]+good[i]);
                    }
                }
                
            }
            dp=temp;
        }
        return dp[m];
        
        
    }
};",1420105839
transcend_2002,transcend_2002,268,3604,cpp,"template <long long int mod>
struct modular {
    long long int value;
    modular(long long int x = 0) {
        value = x % mod;
        if (value < 0) value += mod;
    }
    modular &operator+=(const modular &other) {
        if ((value += other.value) >= mod) value -= mod;
        return *this;
    }
    modular &operator-=(const modular &other) {
        if ((value -= other.value) < 0) value += mod;
        return *this;
    }
    modular &operator*=(const modular &other) {
        value = value * other.value % mod;
        return *this;
    }
    modular &operator/=(const modular &other) {
        long long int a = 0, b = 1, c = other.value, m = mod;
        while (c != 0) {
            long long int t = m / c;
            m -= t * c;
            swap(c, m);
            a -= t * b;
            swap(a, b);
        }
        a %= mod;
        if (a < 0) a += mod;
        value = value * a % mod;
        return *this;
    }
    friend modular operator+(const modular &lhs, const modular &rhs) {
        return modular(lhs) += rhs;
    }
    friend modular operator-(const modular &lhs, const modular &rhs) {
        return modular(lhs) -= rhs;
    }
    friend modular operator*(const modular &lhs, const modular &rhs) {
        return modular(lhs) *= rhs;
    }
    friend modular operator/(const modular &lhs, const modular &rhs) {
        return modular(lhs) /= rhs;
    }
    modular &operator++() { return *this += 1; }
    modular &operator--() { return *this -= 1; }
    modular operator++(int) {
        modular res(*this);
        *this += 1;
        return res;
    }
    modular operator--(int) {
        modular res(*this);
        *this -= 1;
        return res;
    }
    modular operator-() const { return modular(-value); }
    bool operator==(const modular &rhs) const { return value == rhs.value; }
    bool operator!=(const modular &rhs) const { return value != rhs.value; }
    bool operator<(const modular &rhs) const { return value < rhs.value; }
};
template <typename U, typename V>
U power(const U &a, const V &b) {
    assert(b >= 0);
    U x = a, res = 1;
    V p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}
template <long long int mod>
ostream &operator<<(ostream &stream, const modular<mod> &x) {
    return stream << x.value;
}
template <long long int mod>
istream &operator>>(istream &stream, modular<mod> &x) {
    stream >> x.value;
    x.value %= mod;
    if (x.value < 0) x.value += mod;
    return stream;
}
constexpr long long int mod = 1e9 + 7;
using Mint = modular<mod>;
vector<Mint> fact, inv_fact;
class COMBINATORICS {
    size_t sz = 250010;
    void precompute() {
        fact.resize(sz + 1, 1);
        inv_fact.resize(sz + 1, 1);
        for (int i = 2; i <= sz; i++) fact[i] = fact[i - 1] * i;
        inv_fact[sz] /= fact[sz];
        for (int i = sz - 1; i >= 0; i--)
            inv_fact[i] = inv_fact[i + 1] * (i + 1);
    }

   public:
    COMBINATORICS() { precompute(); }
    inline Mint NCR(int n, int r) {
        if (r < 0 or r > n) return 0;
        Mint numerator = fact[n];
        Mint denominator = inv_fact[r] * inv_fact[n - r];
        Mint answer = numerator * denominator;
        return answer;
    }
    inline Mint NPR(int n, int r) {
        Mint answer = NCR(n, r) * fact[r];
        return answer;
    }
    inline Mint Derangements(int n, int r) {
        Mint answer = 0;
        for (int i = 0; i <= n; i++) {
            Mint ans = fact[n];
            ans /= fact[i];
            if (i & 1) ans *= -1;
            answer += ans;
        }
        return answer;
    }
};
COMBINATORICS obj;





class Solution {
public:
   int numberOfWays(int n, int x, int y) {
    // fix number of empty groups
    // n -> performers x -> stages y -> score
    Mint answer = 0;
    for (int r = 1; r <= x; r++) {
        Mint z = obj.NCR(x, r);
        z *= power((Mint)y, r);
        Mint ans = 0;
        for (int i = 0; i <= r; i++) {
            Mint u = obj.NCR(r, i);
            u *= power((Mint)r - i, n);
            if (i & 1)
                ans -= u;
            else
                ans += u;
        }
        z *= ans;

        answer += z;
    }
    int ans = answer.value;
    return ans;
}
};",1420077148
transcend_2002,transcend_2002,268,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> answer(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=1000;j++){
                if((j|(j+1))==nums[i]){
                    answer[i]=j;
                    break;
                }
            }
        }
        return answer;
    }
};",1419997073
transcend_2002,transcend_2002,268,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> answer;
        for(int i:nums){
            if(i==2){
                answer.push_back(-1);
                continue;
            }
            vector<int> b;
            int x=i;
            while(x){
                b.push_back(x&1);
                x>>=1;
            }
            b.push_back(0);
            for(int j=0;j<b.size();j++){
                if(b[j]==1)continue;
                else {
                    b[j-1]=0;
                    break;
                    
                }
            }
            int ans=0;
            for(int j=0;j<b.size();j++){
                if(b[j]==1){
                    ans|=(1<<j);
                }
            }
            answer.push_back(ans);
            
        }
        return answer;
    }
};",1420024772
Arjun Kshirsagar,Arjun-Kshirsagar,269,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        boolean[] isTarget = new boolean[n];
        for(int idx : targetIndices) isTarget[idx] = true;
        
        int[] previous = new int[n + 1];
        int INF = n + 1;
        for(int j = 0; j <= n; j++) previous[j] = INF;

        previous[0] = 0;
        
        for(int i = 1; i <= m; i++){
            int[] current = new int[n + 1];
            for(int j = 0; j <= n; j++) current[j] = INF;

            int minPrev = INF;
            for(int j = 1; j <= n; j++){
                minPrev = Math.min(minPrev, previous[j - 1]);
                
                if(source.charAt(j - 1) == pattern.charAt(i - 1)){
                    current[j] = Math.min(current[j], minPrev + (isTarget[j - 1] ? 1 : 0));
                }
            }
            previous = current;
        }
        
        int minUsedTargets = INF;
        for(int j = 1; j <= n; j++){
            minUsedTargets = Math.min(minUsedTargets, previous[j]);
        }
        
        if(minUsedTargets == INF) return 0;

        return targetIndices.length - minUsedTargets;
    }
}",1420070269
Arjun Kshirsagar,Arjun-Kshirsagar,269,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        final int MOD = 1_000_000_007;


        long[] perm = new long[x + 1];
        perm[0] = 1;
        for (int k = 1; k <= x; k++) {
            perm[k] = (perm[k - 1] * (x - k + 1)) % MOD;
        }


        long[][] dp = new long[n + 1][x + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int k = 1; k <= x; k++) {
                dp[i][k] = (dp[i - 1][k - 1] + k * dp[i - 1][k]) % MOD;
            }
        }

        long[] powerY = new long[x + 1];
        powerY[0] = 1;
        for (int k = 1; k <= x; k++) {
            powerY[k] = (powerY[k - 1] * y) % MOD;
        }

        long result = 0;

        for (int k = 1; k <= Math.min(n, x); k++) {
            long p = perm[k];
            long s = dp[n][k];
            long yPow = powerY[k];
            result = (result + p * s % MOD * yPow % MOD) % MOD;
        }

        return (int) result;
    }
}",1420086036
Arjun Kshirsagar,Arjun-Kshirsagar,269,3605,java,"public class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int temp = nums.get(i);
            
            if (temp == 2)  ans[i] = -1;
            else {
                int x = 0;
                while ((x | (x + 1)) != temp)  x++;
                ans[i] = x;
            }
        }
        
        return ans;
    }
}",1419997349
Arjun Kshirsagar,Arjun-Kshirsagar,269,3611,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for(int i = 0; i < n; i++) {
            int p = nums.get(i);
            
            if(p < 3) { // Only p=2 is possible here, set to -1
                ans[i] = -1;
                continue;
            }
            
            int min_x = -1;
            
            // Determine the number of bits in p
            int numBits = Integer.SIZE - Integer.numberOfLeadingZeros(p);
            
            // Iterate from the highest bit to the lowest
            for(int bit = numBits - 1; bit >= 0; bit--) {
                if((p & (1 << bit)) != 0) { // If the bit is set
                    // Flip the current bit to 0 and set all lower bits to 1
                    int mask = ~(1 << bit);
                    int lowerBits = (1 << bit) - 1;
                    int candidate = (p & mask) | lowerBits;
                    
                    // Validate the condition
                    if( (candidate | (candidate +1)) == p ) {
                        if(min_x == -1 || candidate < min_x) {
                            min_x = candidate;
                        }
                    }
                }
            }
            
            ans[i] = min_x;
        }
        
        return ans;
    }
}",1420059303
Elis__2003,Elis__2003,270,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> dp(pattern.length()+1,1e9);
        vector<bool> tar(source.length(),false);
        for(auto &i:targetIndices) tar[i]=true;
        dp[0]=0;
        for(int i=0;i<source.size();i++){
            for(int j=pattern.size();j>0;j--){
                if(source[i]==pattern[j-1]){
                    if(dp[j-1]!=1e9){
                        dp[j]=min(dp[j],dp[j-1]+tar[i]);
                        //cout<<dp[j]<<endl;
                    }
                }
            }
        }
        return targetIndices.size()-(dp.back()==1e9?0:dp.back());
    }
};",1420066461
Elis__2003,Elis__2003,270,3604,cpp,"#define ll long long
int mod=1e9+7;
long long binpow(long long x,ll y)
{
    ll p=mod;
	unsigned long long res = 1; 
	x = x % p; 
	while (y > 0) 
	{
		if (y & 1)
			res = (res * x) % p;
 	y = y >> 1;		x = (x * x) % p;
	}
	return res;
}


class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp1(x+1,vector<ll>(x+1,0));
        for(int i=0;i<=x;i++){
            dp1[i][0]=1;
            for(int j=1;j<=i;j++){
                dp1[i][j]=(dp1[i-1][j]+dp1[i-1][j-1])%mod;
            }
        }
 vector<vector<long long>> dp2(n+1,vector<ll>(x+1,0));
        dp2[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=x;j++){
                dp2[i][j]=(j*1LL*dp2[i-1][j]+dp2[i-1][j-1])%mod;
            }
        }
        vector<long long> fact(x+1,1);
        for(int i=1;i<=x;i++) fact[i]=(fact[i-1]*i)%mod;
        long long ways=0;
        for(int i=1;i<=x;i++){
            ways=(ways+(dp1[x][i]*dp2[n][i]%mod)*fact[i]%mod*binpow(y,i)%mod)%mod;
            //cout<<ways<<endl;
        }
        //cout<<ways;
        return ways;



    }
};",1420112796
Elis__2003,Elis__2003,270,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            for(int j=0;j<=1000;j++){
                if(j<0) j=-(j+1);
                if((j|(j+1))==nums[i]) {ans[i]=j;break;}
            }
        }
        return ans;
    }
};",1420012062
Elis__2003,Elis__2003,270,3611,cpp,"class Solution {
public:
//11000011111
//11000100000
//31-->11111
//15-->01111
//11-->1011 9-->1001 
//13-->1101 12-->1100
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);
        for(int i=0;i<nums.size();i++){
            int as=0;
            if(nums[i]==2) continue;
            for(int j=0;j<31;j++){
                if(((nums[i]>>j)&1)!=1){as=j; break;}
            }
         cout<<as<<endl;
            as=nums[i]^(1<<(as-1));
        
            ans[i]=as;
        }
        return ans;
    }
};",1420045676
Mythresh7,Mythresh7,271,3487,cpp,"class Solution {
    void markTargets( vector<int>& tikavmy, vector<int>& isTargetmykav, int index) {
        if (index >= tikavmy.size()) return;
        isTargetmykav[tikavmy[index]] = 1; // Mark as target
        markTargets(tikavmy, isTargetmykav, index + 1);
    }

public:
    int maxRemovals(string sourcemykav, string patternmykav, vector<int>& tikavmy) {
        int nmykav = sourcemykav.size();
        int mmykav = patternmykav.size();
        vector<int> dmkp(mmykav + 1, INT_MAX);
        dmkp[0] = 0;
        vector<int> isTargetmykav(nmykav, 0);
        markTargets(tikavmy, isTargetmykav, 0);

        int imyKav = 0;
        while (imyKav < nmykav) {
            int jmykav = mmykav;
            while (jmykav > 0) {
                if (sourcemykav[imyKav] == patternmykav[jmykav - 1] && dmkp[jmykav - 1] != INT_MAX) {
                    dmkp[jmykav] = min(dmkp[jmykav], dmkp[jmykav - 1] + (isTargetmykav[imyKav] ? 1 : 0));
                }
                jmykav--;
            }
            imyKav++;
        }
        
        return tikavmy.size() - (dmkp[mmykav] == INT_MAX ? 0 : dmkp[mmykav]);
    }
};
",1420089842
Mythresh7,Mythresh7,271,3604,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int numberOfWays(int nmykav, int xmykav, int ymykav) {
        const int MODmykav = 1e9 + 7;
        const int MAXmykav = 1001;

        vector<long long> factmykav = computeFact(MAXmykav, MODmykav);
        vector<long long> invFactmykav = computeInvFact(factmykav, MODmykav);
        vector<vector<long long>> Smykav = computeS(nmykav, MODmykav);

        long long total_waysmykav = 0;
        for (int kmykav = 1; kmykav <= min(nmykav, xmykav); kmykav++) {
            long long cmykav = comb(xmykav, kmykav, factmykav, invFactmykav, MODmykav);
            long long smykav = Smykav[nmykav][kmykav];
            long long k_factmykav = factmykav[kmykav];
            long long y_pow_kmykav = powmod(ymykav, kmykav, MODmykav);
            long long waysmykav = cmykav * smykav % MODmykav * k_factmykav % MODmykav * y_pow_kmykav % MODmykav;
            total_waysmykav = (total_waysmykav + waysmykav) % MODmykav;
        }

        return total_waysmykav;
    }

private:
    vector<long long> computeFact(int maxmykav, int modmykav) {
        vector<long long> factmykav(maxmykav);
        factmykav[0] = 1;
        for (int imyKav = 1; imyKav < maxmykav; imyKav++) {
            factmykav[imyKav] = factmykav[imyKav - 1] * imyKav % modmykav;
        }
        return factmykav;
    }

    vector<long long> computeInvFact(const vector<long long>& factmykav, int modmykav) {
        int maxmykav = factmykav.size();
        vector<long long> invFactmykav(maxmykav);
        invFactmykav[0] = 1;
        for (int imyKav = 1; imyKav < maxmykav; imyKav++) {
            invFactmykav[imyKav] = modinv(factmykav[imyKav], modmykav);
        }
        return invFactmykav;
    }

    long long modinv(long long amyKav, int modmykav) {
        return powmod(amyKav, modmykav - 2, modmykav);
    }

    long long powmod(long long amyKav, long long bmyKav, int modmykav) {
        long long resultmykav = 1;
        amyKav %= modmykav;
        while (bmyKav) {
            if (bmyKav & 1) resultmykav = resultmykav * amyKav % modmykav;
            amyKav = amyKav * amyKav % modmykav;
            bmyKav >>= 1;
        }
        return resultmykav;
    }

    long long comb(int nmykav, int kmykav, const vector<long long>& factmykav, const vector<long long>& invFactmykav, int modmykav) {
        if (kmykav < 0 || kmykav > nmykav) return 0LL;
        return factmykav[nmykav] * invFactmykav[kmykav] % modmykav * invFactmykav[nmykav - kmykav] % modmykav;
    }

    vector<vector<long long>> computeS(int nmykav, int modmykav) {
        vector<vector<long long>> Smykav(nmykav + 1, vector<long long>(nmykav + 1, 0));
        Smykav[0][0] = 1;
        for (int imyKav = 1; imyKav <= nmykav; imyKav++) {
            Smykav[imyKav][0] = 0;
            for (int jmykav = 1; jmykav <= imyKav; jmykav++) {
                Smykav[imyKav][jmykav] = (jmykav * Smykav[imyKav - 1][jmykav] % modmykav + Smykav[imyKav - 1][jmykav - 1]) % modmykav;
            }
        }
        return Smykav;
    }
};
",1420106862
Mythresh7,Mythresh7,271,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++)
        {
            int num=nums[i];
            int j;
            for( j=0;j<=num;j++)
            {
                if((j  | (j+1))==num)
                {
                    ans[i]=j;
                    break;
                }
            }
            if(j==num+1)
            ans[i]=-1;
        }
        return ans;
    }
};",1420005809
Mythresh7,Mythresh7,271,3611,cpp,"
class Solution {
private:
    int findMinReslt(int currNum, int bitPosishun, int minReslt) {
        if (bitPosishun >= 31) {
            return minReslt;
        }
        if ((currNum >> bitPosishun) & 1) {
            int modifideNum = currNum ^ (1 << bitPosishun);
            if ((modifideNum | (modifideNum + 1)) == currNum) {
                if (minReslt == -1 || modifideNum < minReslt) {
                    minReslt = modifideNum;
                }
            }
        }
        return findMinReslt(currNum, bitPosishun + 1, minReslt);
    }

public:
    vector<int> minBitwiseArray(vector<int>& numbs) {
        int nummberOfItems = numbs.size();
        vector<int> anss(nummberOfItems, -1);

        int idx = 0;
        while (idx < nummberOfItems) {
            int currNum = numbs[idx];
            int minReslt = findMinReslt(currNum, 0, -1);
            anss[idx] = minReslt;
            idx++;
        }
        return anss;
    }
};
",1420041998
Salyu,salyu,272,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& indices) {
        int n = source.size(), m = pattern.size();
        constexpr int INV = 1e9;
        vector<int> flag(n);
        for (int i : indices) {
            flag[i] = 1;
        }
        auto memo = vector(n + 1, vector<int>(m + 1, INV));
        for (int i = 0; i <= n; ++i) {
            memo[i][0] = 0;
        }
        int prv, cur;
        for (int j = 0; j < m; ++j) {
            prv = cur = INV;
            for (int i = 0; i < n; ++i) {
                prv = min(prv, memo[i][j]);
                if (prv != INV && source[i] == pattern[j]) {
                    memo[i + 1][j + 1] = cur = min(cur, flag[i] ? prv + 1 : prv);
                }
            }
        }
        return indices.size() - cur;
    }
};",1420039162
Salyu,salyu,272,3604,cpp,"using ll = long long;
constexpr ll base = 1e9 + 7;
inline ll pow_mod(ll a, ll b) {
    ll r = a, t = 1;
    while (b > 1) {
        if (b & 1) {
            t = t * r % base;
        }
        b >>= 1;
        r = r * r % base;
    }
    return r * t % base;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {

        int plim = max(x, n);
        vector<ll> inv(plim + 1);
        inv[1] = 1;
        for (int i = 2; i <= plim; ++i) {
            inv[i] = (base - base / i) * inv[base % i] % base;
        }

        vector<ll> vs(x + 1), cs(x + 1);

        cs[0] = 1;

        for (int i = 1, j = x; i <= x; ++i, --j) {
            cs[i] = cs[i - 1] * j % base * inv[i] % base;
        }

        ll rej = 0, res = 0, xs = 1, ys = 1;
        for (ll t = 1; t <= x; ++t) {
            xs = xs * x % base;
            ll v = pow_mod(t, n);
            ll c = 1;
            for (int i = 1, j = t; i < t; ++i, --j) {
                c = c * j % base * inv[i] % base;
                v = (v - c * vs[i] % base + base) % base;
            }
            vs[t] = v;
            res = (res + cs[t] * v % base * pow_mod(y, t)) % base;
        }
        return res;
    }
};",1420106938
Salyu,salyu,272,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int n : nums) {
            if (n == 2) {
                res.push_back(-1);
            }
            else {
                int i = 0;
                while (i < 32 && (1 << i) & n) {
                    ++i;
                }
                res.push_back(n - (1 << (i - 1)));
            }
        }
        return res;
    }
};",1420006104
Salyu,salyu,272,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int n : nums) {
            if (n == 2) {
                res.push_back(-1);
            }
            else {
                int i = 0;
                while (i < 32 && (1 << i) & n) {
                    ++i;
                }
                res.push_back(n - (1 << (i - 1)));
            }
        }
        return res;
    }
};",1420005816
Sai nadh,sainadhsn,273,3487,cpp,"class Solution {
public:
    vector<int> ok;
    vector<vector<int>> dp;
    int fun(int i, int j, string &s, string &t){
        int n = s.size(), m = t.size();
        if(i == n){
            if(j == m) return 0;
            else return -1;
        }
        if(dp[i][j] != -2) return dp[i][j];
        bool r = 0;
        if(j<m and t[j] == s[i]) r = 1;
        int ans = fun(i+1, j + r, s, t);
        if(ok[i]){
            int cc = 1 + fun(i+1, j, s, t);
            if(cc == 0) cc = -1;
            ans = max(cc, ans);
        }
        return dp[i][j] = ans;
    }
    int maxRemovals(string s, string t, vector<int>& ind) {
        int n = s.size(), m = t.size();
        ok.resize(n+1, 0);
        dp = vector<vector<int>>(n, vector<int>(m+1, -2));
        for(auto i: ind) ok[i] = 1;
        int ans = fun(0, 0, s, t);
        if(ans == -1) ans = 0;
        return ans;
    }
};",1420030212
Sai nadh,sainadhsn,273,3604,cpp,"const int M = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int ncr[1001][1001];
        ncr[1][1] = ncr[1][0] = 1;
        ncr[0][0] = 1;
        for(int i=2; i<=1000; i++){
            for(int j=0; j<=i; j++){
                if(j == 0 or j == i) ncr[i][j] = 1;
                else ncr[i][j] = (ncr[i-1][j] + ncr[i-1][j-1])%M;
            }
        }
        int S[1001][1001];
        memset(S, 0, sizeof(S));
        S[0][0] = 1;
        for (int i = 1; i <= 1000; ++i) {
            S[i][0] = 0;
        }
        for (int j = 1; j <= 1000; ++j) {
            S[0][j] = 0;
        }
        for (int i = 1; i <= 1000; ++i) {
            for (int j = 1; j <= 1000; ++j) {
                S[i][j] = (j *1ll* S[i - 1][j] + S[i - 1][j - 1])%M;
            }
        }

        int yk[x+1];
        for(int i=0; i<=x; i++){
            if(i == 0) yk[i] = 1;
            else {
                yk[i] = (y*1ll*yk[i-1])%M;
            }
        }
        int ans = 0;
        int fact[1001];
        fact[0] = 1;
        for(int i=1; i<=1000; i++){
            fact[i] = (fact[i-1]*1ll*i)%M;
        }
        for(int k=1; k<=x; k++){
            int temp = (S[n][k]*1ll*fact[k])%M;
            temp = (temp*1ll*ncr[x][k])%M;
            if(k>x or k>n) temp = 0;
            temp = (temp*1ll*yk[k])%M;
            ans = (ans + temp)%M;
        }
        return ans;
    }
};",1420113479
Sai nadh,sainadhsn,273,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto &x: nums){
            int y = -1;
            for(int i=1; i<=x; i++){
                if((i|(i+1)) == x){
                    y = i;break;
                }
            }
            ans.push_back(y);
        }
        return ans;
    }
};",1419996505
Sai nadh,sainadhsn,273,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x: nums){
            if(x == 2)ans.push_back(-1);
            else{
                int j = 0;
                for(int k = 0; j<31; k++){
                    if(x>>k&1)j=k;
                    else break;
                }
                ans.push_back(x - (1<<j));
            }
        }
        return ans;
    }
};",1420004876
Ankit Pandey,Laid-back,274,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> dp(pattern.size()+1, INT_MAX);
        dp[0]=0;
        vector<int> target(source.size(), 0);
        for(auto &it: targetIndices) target[it]=1;
        for(int i=0; i<source.size(); i++)
            for(int j=pattern.size(); j>0; j--)
                if(source[i]==pattern[j-1] && dp[j-1]!=INT_MAX)
                    dp[j]=min(dp[j], dp[j-1]+target[i]);
        return targetIndices.size()-(dp[pattern.size()]==INT_MAX?0:dp[pattern.size()]);
    }
};",1420060672
Ankit Pandey,Laid-back,274,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int MOD=1e9+7;
        vector<vector<long long>> dp(x+1, vector<long long> (x+1, 0));
        for(int i=0; i<=x; i++){
            dp[i][0]=1;
            for(int j=1; j<=i; j++)
                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%MOD;
        } vector<vector<long long>> dp2(n+1, vector<long long> (x+1, 0));
        dp2[0][0]=1;
        for(int i=1; i<=n; i++)
            for(int j=1; j<=x; j++)
                dp2[i][j]=((j*dp2[i-1][j])%MOD+dp2[i-1][j-1])%MOD;
        vector<long long> fact(x+1, 1);
        for(int i=1; i<=x; i++)
            fact[i]=(1LL*fact[i-1]*i)%MOD;
        long long ans=0;
        for (int i=1; i<=x; i++){
            long long power=1;
            for(int j=0; j<i; j++)
                power=(power*y)%MOD;
            long long val=(((1LL*dp[x][i]*dp2[n][i])%MOD)*((1LL*fact[i]*power)%MOD))%MOD;
            ans=(ans+val)%MOD;
        } return (int)ans;
    }
};",1420107035
Ankit Pandey,Laid-back,274,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(nums.size(), -1);
        for(int i=0; i<nums.size(); i++){
            for(int j=1; j<=nums[i]; j++){
                if((j|(j+1))==nums[i])
                    {ans[i]=j; break;}
            }
        } return ans;
    }
};",1420002060
Ankit Pandey,Laid-back,274,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for(int i=0; i<nums.size(); i++){
            if(nums[i]!=2){
                int idx=0;
                for(int j=0; j<32; j++){
                    if(nums[i]&(1<<j)) idx=j;
                    else break;
                } ans[i]=nums[i]-(1<<idx);
            }
        } return ans;
    }
};",1420073295
ABHAY GUPTA,abhayg_07,275,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int p = pattern.size();
        int dp[n+1][p+1];
        const int inf = -1000000;
        for( int i = 0 ; i < n+1 ; i++ ){
            for( int j = 0 ; j < p+1 ; j++ ){
                dp[i][j] = inf; 
            }
            dp[i][0] = 0;
        }
        int ptr = 0;
        int m = targetIndices.size();

        for( int i = 1 ; i <= n ; i++ ){
            if( ptr < m && targetIndices[ptr] == i-1 ){
                dp[i][0] = dp[i-1][0] + 1;
            }
            else dp[i][0] = dp[i-1][0];
            for( int l = 1 ; l <= p ; l++ ){
                dp[i][l] = dp[i-1][l];
                if( source[i-1] == pattern[l-1] ){
                    dp[i][l] = max( dp[i][l] , dp[i-1][l-1] );
                }
                if( ptr < m && targetIndices[ptr] == i-1 ){
                    dp[i][l] = max( dp[i][l] , dp[i-1][l] + 1 );
                }
            }
            if( ptr < m && targetIndices[ptr] == i-1 ) ptr++;
        }
        // for( int i = 1 ; i <= n ; i++ ){
        //     for( int j = 1 ; j <= p ; j++ ){
        //         cout << dp[i][j] << "" "";
        //     }
        //     cout << endl;
        // }
        return max(0,dp[n][p]);
    }
};",1420045863
ABHAY GUPTA,abhayg_07,275,3604,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    vector<long long> fact , ifact;

    long long expo(long long a, long long b, long long m)
    {
        long long res = 1;
        while (b > 0)
        {
            if (b & 1)
                res = (res * a) % m;
            a = (a * a) % m;
            b = b >> 1;
        }
        return res % m;
    }

    long long modinv(long long a, long long m) { return expo(a, m - 2, m) % m; } // m is prime


    void init(long long  n){
        fact.resize(n);
        ifact.resize(n);
        fact[0]=1;
        for( int i = 1 ; i < n ; i++ ) fact[i]=(fact[i-1]%mod*i)%mod;
        ifact[n-1]=modinv(fact[n-1],mod)%mod;
        for(int i=n-2 ; i>=1 ; i--){
            ifact[i]=(ifact[i+1]%mod*(i+1))%mod;
        }
        ifact[0]=1;
    }

    long long  ncr(long long n , long long r){
        if(r>n) return 0;
        return (fact[n]*(ifact[r]%mod*ifact[n-r]%mod)%mod)%mod;
    }

    int numberOfWays(int n, int x, int y) {
        init(1001);

        vector<long long> z(x+1);
        z[1] = 1;

        long long ans = 0;

        ans = ( ncr(x,1)%mod * y%mod )%mod;

        for( int i = 2 ; i <= x ; i++ ){
            long long cnt = expo(i,n,mod)%mod;
            for( int j = 1 ; j < i ; j++ ){
                cnt = ( cnt%mod - ( ncr(i,j)%mod * z[j]%mod )%mod + mod )%mod;
            }
            z[i] = cnt;
            long long V = ( ncr(x,i)%mod * z[i]%mod )%mod;
            V = ( V%mod * expo(y,i,mod)%mod )%mod;
            ans = ( ans%mod + V%mod )%mod;
        }
        return ans;
    }
};",1420100681
ABHAY GUPTA,abhayg_07,275,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for( int i = 0 ; i < n ; i++ ){
            for( int j = 1 ; j < nums[i] ; j++ ){
                if( (j|(j+1)) == nums[i] ){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419994654
ABHAY GUPTA,abhayg_07,275,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for( int i = 0 ; i < n ; i++ ){
            if( nums[i] == 2 ) continue;
            ans[i] = nums[i];
            long long x = nums[i];
            for( int j = 0 ; j < 40 ; j++ ){
                if( (x>>j&1) == 1 && (x>>(j+1)&1) == 0 ){
                    x -= (1<<j);
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};",1420001580
Shidong Zhang,dongdozizi,276,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n=s.size(),m=t.size();
        vector<bool> hav(n+1,0);
        for(int i=0;i<a.size();i++){
            hav[a[i]+1]=1;
        }
        vector<vector<int>> dp(n+1,vector<int>(m+1,100000000));
        for(int i=0;i<=n;i++){
            dp[i][0]=0;
        }
        for(int i=1;i<=n;i++){
            char sc=s[i-1];
            for(int j=1;j<=m;j++){
                char tc=t[j-1];
                if(hav[i]){
                    if(sc==tc){
                        dp[i][j]=min(dp[i-1][j],dp[i-1][j-1]+1);
                    }
                    else{
                        dp[i][j]=dp[i-1][j];
                    }
                }
                else{
                    if(sc==tc){
                        dp[i][j]=dp[i-1][j-1];
                    }
                    else{
                        dp[i][j]=dp[i-1][j];
                    }
                }
            }
        }
        // for(int i=0;i<=n;i++){
        //     for(int j=0;j<=m;j++){
        //         cout<<dp[i][j]<<"" "";
        //     }cout<<""\n"";
        // }
        return a.size()-dp[n][m];
    }
};",1420040197
Shidong Zhang,dongdozizi,276,3604,cpp,"class Solution {
public:
    typedef long long ll;
    ll mod=1e9+7;
    ll yw[1003]={0};
    ll fen[1003]={0};
    ll njie[2003]={0},ninv[2003]={0};
    ll qpow(ll a,ll b,ll mod){
        if(b==0) return 1;
        ll c=qpow(a,b/2,mod);
        if(b%2==0) return c*c%mod;
        else return c*c%mod*a%mod;
    }
    ll cnm(ll n,ll m){
        return njie[n]*ninv[m]%mod*ninv[n-m]%mod;
    }
    /*
    dp i,j,k=i find j form k
    dp[i][j][k]=dp[i][j-1][k]*k
    */
    ll numberOfWays(ll n, ll x, ll y) {
        yw[0]=1;
        for(int i=1;i<=1001;i++){
            yw[i]=yw[i-1]*y%mod;
        }
        njie[0]=1;
        for(int i=1;i<=2000;i++){
            njie[i]=njie[i-1]*i%mod;
        }
        for(int i=0;i<=2000;i++){
            ninv[i]=qpow(njie[i],mod-2,mod);
        }

        vector<vector<int>> dp(max(n,x)+1,vector<int>(max(x,n)+1,0));
        for(int i=0;i<=n;i++){
            dp[i][0]=0;
            dp[i][1]=1;
        }
        for(int i=0;i<=x;i++){
            dp[0][i]=0;
            dp[i][i]=1;
        }
        for(ll i=2;i<=n;i++){
            for(ll j=2;j<=x;j++){
                dp[i][j]=(dp[i-1][j-1]+j*dp[i-1][j])%mod;
            }
        }
        
        for(ll i=1;i<=x;i++){
            //cout<<dp[n][i]<<"" ""<<cnm(x,i)<<"" ""<<yw[i]<<""\n"";
            fen[i]=cnm(x,i)*njie[i]%mod*dp[n][i]%mod;
        }

        ll ans=0;
        for(int i=1;i<=x;i++){
            ans=(ans+fen[i]*yw[i])%mod;
        }
        return ans;
    }
};
/*
3*4+
*/",1420113852
Shidong Zhang,dongdozizi,276,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ret;
        for(int i=0;i<a.size();i++){
            bool fd=0;
            for(int j=-2;j<=3000;j++){
                if((j|(j+1))==a[i]){
                    ret.push_back(j);
                    fd=1;
                    break;
                }
            }
            if(!fd) ret.push_back(-1);
        }
        return ret;
    }
};",1419998264
Shidong Zhang,dongdozizi,276,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ret;
        for(int i=0;i<a.size();i++){
            if(a[i]==2) ret.push_back(-1);
            else{
                int lb=a[i]+1;
                lb=lb&(-lb);
               // cout<<lb<<"" - "";
                int tmp=a[i]-lb+1;
               // cout<<tmp<<"" - "";
                tmp=tmp+lb/2-1;
                //cout<<tmp<<"" "";
                ret.push_back(tmp);

            }
        }
        return ret;
    }
};
/*
101

1111111
0111111
1000001
1000000
1011111
1001111
1010000
*/",1420018062
raj,Ranjan_22,277,3487,cpp,"#include <vector>
#include <string>
#include <climits>  // For INT_MAX
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int sourceLength = source.size();
        int patternLength = pattern.size();
        
        // dp array to store minimum removals
        vector<int> minRemovals(patternLength + 1, INT_MAX);
        minRemovals[0] = 0;

        // isTarget array to mark target indices
        vector<bool> isRemovalTarget(sourceLength, false);
        for (int index : targetIndices) {
            isRemovalTarget[index] = true;
        }

        // Lambda function to update the dp array
        auto updateMinRemovals = [&](int sourceIdx, int patternIdx) {
            if (source[sourceIdx] == pattern[patternIdx - 1] && minRemovals[patternIdx - 1] != INT_MAX) {
                minRemovals[patternIdx] = min(minRemovals[patternIdx], minRemovals[patternIdx - 1] + (isRemovalTarget[sourceIdx] ? 1 : 0));
            }
        };

        // Traverse through the original string
        for (int sourceIdx = 0; sourceIdx < sourceLength; sourceIdx++) {
            // Traverse through the pattern string in reverse order
            for (int patternIdx = patternLength; patternIdx > 0; patternIdx--) {
                updateMinRemovals(sourceIdx, patternIdx);
            }
        }

        return targetIndices.size() - (minRemovals[patternLength] == INT_MAX ? 0 : minRemovals[patternLength]);
    }
};
",1420064956
raj,Ranjan_22,277,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        // Lambda function to compute combinations
        auto computeCombination = [&](int size) {
            std::vector<std::vector<int>> combination(size + 1, std::vector<int>(size + 1, 0));
            for (int outerIdx = 0; outerIdx <= size; ++outerIdx) {
                combination[outerIdx][0] = 1;
                for (int innerIdx = 1; innerIdx <= outerIdx; ++innerIdx) {
                    combination[outerIdx][innerIdx] = (combination[outerIdx - 1][innerIdx - 1] + combination[outerIdx - 1][innerIdx]) % MOD;
                }
            }
            return combination;
        };

        // Lambda function to compute Stirling numbers
        auto computeStirlingNumbers = [&](int nSize, int xSize) {
            std::vector<std::vector<int>> stirlingNumbers(nSize + 1, std::vector<int>(xSize + 1, 0));
            stirlingNumbers[0][0] = 1;
            for (int outerIdx = 1; outerIdx <= nSize; ++outerIdx) {
                for (int innerIdx = 1; innerIdx <= xSize; ++innerIdx) {
                    stirlingNumbers[outerIdx][innerIdx] = (1LL * innerIdx * stirlingNumbers[outerIdx - 1][innerIdx] + stirlingNumbers[outerIdx - 1][innerIdx - 1]) % MOD;
                }
            }
            return stirlingNumbers;
        };

        // Lambda function to compute factorials
        auto computeFactorials = [&](int size) {
            std::vector<int> factorialArray(size + 1, 1);
            for (int factorialIdx = 1; factorialIdx <= size; ++factorialIdx) {
                factorialArray[factorialIdx] = (1LL * factorialArray[factorialIdx - 1] * factorialIdx) % MOD;
            }
            return factorialArray;
        };

        // Compute the combination, Stirling numbers, and factorials
        auto combination = computeCombination(x);
        auto stirlingNumbers = computeStirlingNumbers(n, x);
        auto factorialArray = computeFactorials(x);

        // Calculate total number of ways
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPower = 1;
            for (int powerIdx = 0; powerIdx < k; ++powerIdx) {
                yPower = (yPower * y) % MOD;
            }
            totalWays = (totalWays + (1LL * combination[x][k] * stirlingNumbers[n][k] % MOD * factorialArray[k] % MOD * yPower % MOD)) % MOD;
        }
        return totalWays;
    }
};
",1420107781
raj,Ranjan_22,277,3605,cpp,"#include <vector>
#include <functional>
using namespace std;

class Solution {
public:
      vector<int> minBitwiseArray(vector<int>& nums){
        int arraySize = nums.size();
        vector<int> resultArray(arraySize, -1);  // Initialize resultArray with -1
        
        // Lambda function to find the minimum bitwise number for a given target
        auto computeMinBitwise = [](int target) -> int {
            for (int candidate = 0; candidate <= target; candidate++) {
                if ((candidate | (candidate + 1)) == target) {
                    return candidate;
                }
            }
            return -1;  // Return -1 if no valid candidate is found (shouldn't happen for valid input)
        };
        
        // Iterate over each number in the inputArray
        for (int index = 0; index < arraySize; index++) {
            resultArray[index] = computeMinBitwise(nums[index]);
        }
        
        return resultArray;
    }
};
",1420013010
raj,Ranjan_22,277,3611,cpp,"#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int arraySize = nums.size();
        vector<int> resultArray(arraySize, -1);  // Initialize resultArray with -1
        
        // Lambda function to calculate the minimum candidate for each number
        auto findMinCandidate = [](int currentNum) -> int {
            int minCandidate = INT_MAX;
            bool candidateFound = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (((currentNum >> bitPosition) & 1) == 1) {
                    // Unset the current bit
                    int candidate = currentNum & ~(1 << bitPosition);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals currentNum
                    if ((candidate | (candidate + 1)) == currentNum) {
                        if (candidate < minCandidate) {
                            minCandidate = candidate;
                            candidateFound = true;
                        }
                    }
                }
            }
            return candidateFound ? minCandidate : -1;
        };
        
        // Iterate over each number in the inputArray and apply the lambda function
        for (int index = 0; index < arraySize; index++) {
            resultArray[index] = findMinCandidate(nums[index]);
        }
        
        return resultArray;
    }
};
",1420047192
Paramish,Paramish,278,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int c=0;
        c++;
        int k=0;
        k--;

        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        unordered_map<int,int>mp;
        for (int idx : targetIndices) {
            c++;
            if(c>=1 && k<=0)
            isTarget[idx] = true;
            mp[idx]=c;
        }
        
        for (int i = 0; i < n; i++) {
            c++;k--;
            if(c){
            for (int j = m; j > 0; j--) {
                if(!c) c++; 
                else if (c>=1 && source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                    c++;
                    mp[j]--;
                }
            }
            }
            else c++;
        }
        c++;
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420064411
Paramish,Paramish,278,3604,cpp,"const int MOD = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> C(x + 1, vector<int>(x + 1, 0));
        int k=0;
        k++;
        int l=0;
        l--;
        for (int i = 0; i <= x; ++i) {
            if(k>=1 && l<=0)
            C[i][0] = 1;
            
            for (int j = 1; j <= i; ++j) {
                if(l<=0)
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
                else k++;
                l--;
            }
        }

        vector<vector<int>> S(n + 1, vector<int>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            k++;
            l--;
            for (int j = 1; j <= x; ++j) {
                if(k>=1 && l<=0)
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            k++;l--;
            if(k>=0 && l<=0)
            fact[i] = 1LL * fact[i - 1] * i % MOD;
            else l--;
        }

        int result = 0;
        l--;
       
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            if(l<=0){
            for (int p = 0; p < k; ++p) {
                if(l<=0)
                power = (power * y) % MOD;
                else l--;
            }
            }
            else l--;
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};
",1420094720
Paramish,Paramish,278,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        int c=0;
        c++;
        for (int i = 0; i < n; i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if (c>=1 && (x | (x + 1)) == nums[i]) {
                    c++;
                    if(c)
                    ans[i] = x;
                    break;
                }
                c++;
            }
        }
        
        return ans;
    }
};",1420014996
Paramish,Paramish,278,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
         int c=0;
         c++;
         int k=0;
         k--;
        for (int i = 0; i < n; i++) {
            if(c>=1) c++;
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            c++;
             
            for (int bit = 0; bit <= 30; bit++) {
                if (k<=0 && c>=1 && ((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (c && candidate < minimalAns) {
                            if(c>=1 && k<=0)
                            minimalAns = candidate;
                            else c++;
                            found = true;
                        }
                    }
                }
            }

            if (c>=1 && found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
            if(!c) c++;
            else c+=2;
        }

        return ans;
    }
};
",1420050891
Harsh kriplani,Harshkriplani,279,3487,cpp,"string a,b;
    vector<int>h;
    int n;
    int dp[3001][3001];
class Solution {
public:
    
    int make(int i,int j)
    {
        if(i==a.size())
        {
            if(j==b.size())
                return 0;
            return -1e9;
        }
        if(dp[i][j]==-1)
        {
            if(h[i]==1)
            {
                int ans=1+make(i+1,j);
                if(j!=b.size())
                {
                if(a[i]==b[j])
                {
                    ans=max(ans,make(i+1,j+1));
                    
                }
                else
                {
                    ans=max(ans,make(i+1,j));
                }
                }
                dp[i][j]=ans;
                
                
            }
            else
            {
                if(j!=b.size())
                {
                if(a[i]==b[j])
                {
                    dp[i][j]=make(i+1,j+1);
                    
                }
                else
                {
                    dp[i][j]=make(i+1,j);
                }
                }
                else
                {
                    dp[i][j]=make(i+1,j);
                    
                }
                
                
            }

        }
                    return dp[i][j];
    }
    int maxRemovals(string source, string pattern, vector<int>& in) {
        a=source;
        b=pattern;
        h=vector<int>(a.size()+1,0);
        for(int i=0;i<in.size();i++)
        {
            h[in[i]]=1;
        }
        for(int i=0;i<=a.size();i++)
        {
            for(int j=0;j<=a.size();j++)
            {
                dp[i][j]=-1;
            }
        }
        return make(0,0);
        
    }
};",1420029517
Harsh kriplani,Harshkriplani,279,3604,cpp,"
vector<vector<long long>> dp(1001 + 1, vector<long long>(1001 + 1, 0));
vector<long long> factorial(1001 + 1, 1);  // To store factorials modulo MOD

#define ll long long
ll facts[3002];
ll invfacts[3002];
const ll N_ = 2001;
class Solution {
public:
    const int MOD = 1e9 + 7;
    const int mod = 1e9 + 7;
const int MAX_N = 1001;  // Set a limit for n and m (you can increase if needed)


// Precompute Stirling numbers and factorials
void precompute() {
    // Base cases
    for (int i = 0; i <= MAX_N; ++i) {
        dp[i][i] = 1;        // Exactly i balls in i boxes (1 way)
        dp[i][0] = 0;        // 0 boxes can't have any balls
    }

    // Precompute factorials modulo MOD
    for (long long i = 2; i <= MAX_N; ++i) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }

    // Fill the DP table using the recurrence relation: S(n, m) = S(n-1, m-1) + m * S(n-1, m) (mod MOD)
    for (long long n = 2; n <= MAX_N; ++n) {
        for (long long m = 1; m < n; ++m) {
            dp[n][m] = (dp[n - 1][m - 1] + (m * dp[n - 1][m]) % MOD) % MOD;
        }
    }
}

// Function to return the number of ways for a specific n and m
long long numberOfWays1(int n, int m) {
    if (m > n) return 0; // Impossible to put n balls in more than n boxes
    return (factorial[m] * dp[n][m]) % MOD;
}
    
    
    
    ll mul(ll a, ll b) {
	return ((a % mod) * (b % mod)) % mod;
}

ll add(ll a, ll b) {
	return (a % mod + b % mod) % mod;
}
ll sub(ll a, ll b)
{
	return (mod + a % mod - b % mod) % mod;
}

ll expo(ll base, ll pow) {
	if (pow == 0) return 1;
	ll half = expo(base, pow / 2);
	if (pow % 2 == 0) return mul(half, half);
	return mul(half, mul(half, base));
}
ll divi(ll a, ll b)
{
	return mul(a, expo(b, mod - 2));
}
void makef() {
	facts[0] = 1;
	for (ll i = 1; i < N_ - 1; i++)
		facts[i] = mul(facts[i - 1], i);

	invfacts[N_ - 2] = divi(1ll, facts[N_ - 2]);
	for (ll i = N_ - 3; i >= 0; i--)
		invfacts[i] = mul(invfacts[i + 1], i + 1);
}
    ll nCk(ll n, ll k) {
	if (n < k)
		return 0;
	if (n == k)
		return 1;
	return mul(facts[n], mul(invfacts[k], invfacts[n - k]));
}

    int numberOfWays(int n, int x, int y) {
        precompute();
        long long ans=0;
       
        makef();
        
        for(int i=1;i<=min(n,x);i++)
        {
           // cout<<numberOfWays1(n, i)<<endl;
            long long stagesway=mul(nCk(x,i),numberOfWays1(n, i));
           // cout<<stagesway<<endl;
            ans=add(ans,mul(stagesway,expo(y,i)));
            
            
            
        }
        return ans;
        
    }
};",1420094953
Harsh kriplani,Harshkriplani,279,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int>ans;
        for(int i=0;i<a.size();i++)
        {
            int ma=0;
            if(a[i]&1)
            {
               for(int j=0;j<=30;j++)
               {
                   if(a[i]&(1<<j))
                   {
                       ma=j;
                   }
                   else
                   {
                       break;
                   }
               }
                ans.push_back(a[i]-(1<<ma));
            }
            else
                ans.push_back(-1);
        }
        return ans;
        
    }
};",1420006731
Harsh kriplani,Harshkriplani,279,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
         vector<int>ans;
        for(int i=0;i<a.size();i++)
        {
            int ma=0;
            if(a[i]&1)
            {
               for(int j=0;j<=30;j++)
               {
                   if(a[i]&(1<<j))
                   {
                       ma=j;
                   }
                   else
                   {
                       break;
                   }
               }
                ans.push_back(a[i]-(1<<ma));
            }
            else
                ans.push_back(-1);
        }
        return ans;
        
    }
};",1420007388
chh9976,chh9976,280,3487,cpp,"
#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))

const ints2 _8dirs[8] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};
const ints2 _4dirs[4] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; 

template<typename U, std::size_t T> array<U, T> operator+(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) result[i] = arr1[i] + arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator-(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) result[i] = arr1[i] - arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator*(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) result[i] = arr1[i] * arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator/(const array<U, T>& arr1, const array<U, T>& arr2) {array<U, T> result;for(int i = 0; i < T; ++i) assert(arr2[i] != 0), result[i] = arr1[i] / arr2[i]; return result;}
template<typename U, std::size_t T> array<U, T> operator+=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) arr1[i] += arr2[i]; return arr1;}
template<typename U, std::size_t T> array<U, T> operator-=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) arr1[i] -= arr2[i]; return arr1;}
template<typename U, std::size_t T> array<U, T> operator*=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) arr1[i] *= arr2[i]; return arr1;}
template<typename U, std::size_t T> array<U, T> operator/=(array<U, T>& arr1, const array<U, T>& arr2) {for(int i = 0; i < T; ++i) assert(arr2[i] != 0), arr1[i] /= arr2[i]; return arr1;}
template<typename U, std::size_t T> ostream& operator<<(ostream& a, array<U, T>& arr){if(T == 0) {a<<""{}""; return a;} a<<""{""<<arr[0]; for(int i=1;i<T;i++) a<<"", ""<<arr[i]; a<<""}""; return a;}

template<typename T> void print(vector<T>& c, int a=-1, int b=-1){if(a == -1) a = 0; if(b == -1) b = c.size(); for(int i=a;i<b;i++) cout<<c[i]<<"" \n""[i==b-1];}
template<typename T> void print(T t, char c='\n'){cout<<t<<c;}
template<typename T> void print(T* a, T* b){while(a < b) print(*a, ' '), a++; cout<<endl;}
template<typename T> void print(T* a, int b, int c){for(int i=b;i<c;i++) cout<<a[i]<<"" ""; cout<<endl;}
template<typename T> void printmat(vc<vc<T>> a){trav(a) print(a);}
template<typename T> ostream& operator<<(ostream& a, vector<T>& arr){for(int i=0;i<arr.size();i++) a<<arr[i]<<"" ""; return a;}
ostream& operator<<(ostream& a, __int128 out){if(out < 0) {a<<""-""; a << -out;} else {if(out > 9) a<<out/10; a<< int(out%10);} return a;}


int strcmp(string& a, string& b, int& ia, int& ib){auto res = memcmp(&a[ia], &b[ib], min(a.size()-ia, b.size()-ib));if(res != 0) return res;return (a.size() - ia > b.size() - ib) - (b.size() - ib > a.size() - ia);}
template<typename U, std::size_t T> ll get(array<U, T>& a, ll u){ll x=0; for(int i=0;i<T;i++) x *= u, x += a[i]; return x;}
template<typename T> void gmin(T& a, T b){a = min(a, b);}
template<typename T> void gmax(T& a, T b){a = max(a, b);}
mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());
uniform_int_distribution<ll> rnd(0,LLONG_MAX); //usage: long long xx = rnd(gen);
template<int k> array<int, k> getints(){array<int, k> res; rep(i, 0, k) cin>>res[i]; return res;} 
template<int k> array<ll, k> getlls(){array<ll, k> res; rep(i, 0, k) cin>>res[i]; return res;}
template<typename T, std::size_t N> istream& operator>>(istream& a, array<T, N>& in){rep(i, 0, N) a>>in[i]; return a;}
template<typename T> istream& operator>>(istream& a, vector<T>& in){for(auto& gin:in) a>>gin; return a;}
ll triangle(ll up, ll down, ll step){assert((up-down) % step == 0); if(up > down) return 0; return (up+down) * ((down - up) / step + 1) / 2;}
vc<int> getints(int n){vc<int> res(n); trav(res) cin>>res; return res;}
vc<ll> getlls(int n){vc<ll> res(n); trav(res) cin>>res; return res;}
ll getint(){ll a; cin>>a; return a;}
ll pow(ll a, ll b){ll res = 1; while(b){if(b&1) res *= a; a *= a; b>>=1;} return res;}
ll pow(int a, int b){ll res = 1; while(b){if(b&1) res *= a; a *= a; b>>=1;} return res;}
void YES(){print(""Yes"");}
void NO(){print(""No"");}
#define ee9 1000000000
class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& ti) {
        int n = source.size(), m = pattern.size();
        set<int> s(all(ti));
        vc dp(n+1, vc<int>(m+1, -ee9));
        dp[0][0] = 0;
        rep(i, 0, n){
            int check = s.count(i);
            rep(j, 0, m) if(dp[i][j] >= 0) {
                if(source[i] == pattern[j]){
                    dp[i+1][j+1] = max(dp[i][j], dp[i+1][j+1]);
                }
            }
            rep(j, 0, m + 1) if(dp[i][j] >= 0) {
                if(check) dp[i+1][j] = max(dp[i+1][j], dp[i][j] + 1);
                else dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
            }
        }
        return dp[n][m];
    }
};",1420029766
chh9976,chh9976,280,3604,cpp,"
#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;

vc<mint17> fact;
vc<mint17> ifact;
vc<mint17> py(1001);
mint17 dp[1001][1001];
int havedp[1001][1001];
class Solution {
public:
    Solution(){
        if(fact.size() == 0){
            fact.pb(mint17(1));
            ifact.pb(mint17(1));
            rep(i, 1, 1001) fact.pb(fact.back() * i), ifact.pb(ifact.back() / i);
        }
    }
    mint17 nw(int n, int x, int y, int nowsize) {
        if(havedp[n][nowsize]) return dp[n][nowsize];
        mint17 ans = 0;
        if(n == 0) {
            dp[n][nowsize] = py[nowsize] * fact[x] * ifact[x - nowsize];
            havedp[n][nowsize] = 1;
            return dp[n][nowsize];
        }
            
        if(nowsize == x) ans += nw(n-1, x, y, x) * x;
        else ans += nw(n-1, x, y, nowsize) * nowsize + nw(n-1, x, y, nowsize+1);
        dp[n][nowsize] = ans;
        havedp[n][nowsize] = 1;
        return ans;
    }
    int numberOfWays(int n, int x, int y, int nowsize = 0){
        py[0] = 1; rep(i, 1, x+1) py[i] = py[i-1] * y; rep(i, 0, max(n, nowsize) + 1) rep(j, 0, max(n, nowsize) + 1) havedp[i][j] = 0;
        return nw(n, x, y, 0).get();
    }
};",1420074232
chh9976,chh9976,280,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            if n == 2:
                res.append(-1)
                continue
            g = list(bin(n)[2:])[::-1]
            try:
                ind = g.index('0')
                g[ind-1] = '0'
            except Exception as e:
                g.pop()
            g = int(''.join(reversed(g)), 2)
            res.append(g)
        return res
                
            
                    
                
        ",1420008637
chh9976,chh9976,280,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for n in nums:
            if n == 2:
                res.append(-1)
                continue
            g = list(bin(n)[2:])[::-1]
            try:
                ind = g.index('0')
                g[ind-1] = '0'
            except Exception as e:
                g.pop()
            g = int(''.join(reversed(g)), 2)
            res.append(g)
        return res
                
            ",1420008349
Zaheer Khan,oyezaheer,281,3487,golang,"package main

import (
	""fmt""
	""math""
)

// Function to find the maximum number of removals such that pattern is still a subsequence
func maxRemovals(source string, pattern string, targetIndices []int) int {
	n := len(source)
	m := len(pattern)

	// Initialize the dp array with infinity values
	dp := make([]int, m+1)
	for i := range dp {
		dp[i] = math.MaxInt32
	}
	dp[0] = 0

	// Initialize the isTarget array
	isTarget := make([]bool, n)
	for _, idx := range targetIndices {
		isTarget[idx] = true
	}

	// Dynamic Programming to check the number of possible removals
	for i := 0; i < n; i++ {
		for j := m; j > 0; j-- {
			if source[i] == pattern[j-1] && dp[j-1] != math.MaxInt32 {
				if isTarget[i] {
					dp[j] = min(dp[j], dp[j-1]+1)
				} else {
					dp[j] = min(dp[j], dp[j-1])
				}
			}
		}
	}

	if dp[m] == math.MaxInt32 {
		return 0
	}
	return len(targetIndices) - dp[m]
}

// Utility function to find the minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}",1420067353
Zaheer Khan,oyezaheer,281,3604,golang,"package main

import ""fmt""

const MOD = 1000000007

func numberOfWays(n int, x int, y int) int {
    // Calculate combination (nCr)
    comb := make([][]int, x+1)
    for i := range comb {
        comb[i] = make([]int, x+1)
    }

    for i := 0; i <= x; i++ {
        comb[i][0] = 1
        for j := 1; j <= i; j++ {
            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD
        }
    }

    // Calculate Stirling numbers of the second kind
    stirling := make([][]int, n+1)
    for i := range stirling {
        stirling[i] = make([]int, x+1)
    }
    stirling[0][0] = 1

    for i := 1; i <= n; i++ {
        for j := 1; j <= x; j++ {
            stirling[i][j] = (j*stirling[i-1][j] + stirling[i-1][j-1]) % MOD
        }
    }

    // Calculate factorials
    factorial := make([]int, x+1)
    factorial[0] = 1
    for i := 1; i <= x; i++ {
        factorial[i] = (factorial[i-1] * i) % MOD
    }

    // Calculate total ways
    totalWays := 0
    for k := 1; k <= x; k++ {
        yPow := 1
        for i := 0; i < k; i++ {
            yPow = (yPow * y) % MOD
        }

        totalWays = (totalWays + (comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD)) % MOD
    }

    return totalWays
}",1420102394
Zaheer Khan,oyezaheer,281,3605,golang,"package main

import (
	""fmt""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	ans := make([]int, n)

	// Iterate through the nums slice
	for i := 0; i < n; i++ {
		num := nums[i]
		found := false

		// Iterate over possible values of ans[i] starting from 0
		for x := 0; x < num; x++ {
			if (x | (x + 1)) == num {
				ans[i] = x
				found = true
				break
			}
		}

		// If no valid ans[i] found, set -1
		if !found {
			ans[i] = -1
		}
	}

	return ans
}",1420040846
Zaheer Khan,oyezaheer,281,3611,golang,"import (
	""fmt""
	""math""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	ans := make([]int, n)

	for i := 0; i < n; i++ {
		num := nums[i]
		minimalAns := math.MaxInt32
		found := false

		// Iterate through each bit position (0 to 30)
		for bit := 0; bit <= 30; bit++ {
			if (num>>bit)&1 == 1 {
				// Unset the current bit
				candidate := num & ^(1 << bit)

				// Ensure candidate is non-negative
				if candidate < 0 {
					continue
				}

				// Check if candidate OR (candidate + 1) equals num
				if (candidate | (candidate + 1)) == num {
					if candidate < minimalAns {
						minimalAns = candidate
						found = true
					}
				}
			}
		}

		if found {
			ans[i] = minimalAns
		} else {
			ans[i] = -1
		}
	}

	return ans
}",1420047738
vishuut,vishuut,282,3487,cpp,"class Solution {
public:
    // Memoization table to store results of (i, j) states
    vector<vector<int>> dp;

    // Helper recursive function with memoization
    int ans(int i, int j, string &source, string &pattern, set<int> &ind) {
        // If we've matched the entire pattern
        if (j == pattern.size()) {
            // Count how many of the remaining characters in 'source' are in 'ind'
            int remainingRemovals = 0;
            for (int k = i; k < source.size(); k++) {
                if (ind.find(k) != ind.end()) {
                    remainingRemovals++;  // Count indices that can be removed
                }
            }
            return remainingRemovals;  // Return how many characters can be removed
        }

        // If we've exhausted the source string without fully matching the pattern
        if (i >= source.size()) {
            return -1e9;  // Large negative value to indicate invalid state
        }

        // Check if the result for this state is already computed
        if (dp[i][j] != -1) {
            return dp[i][j];
        }

        int result = 0;

        // Case 1: Current characters of source and pattern match
        if (source[i] == pattern[j]) {
            if (ind.find(i) == ind.end()) {
                // If this index is not removed, proceed normally
                result = ans(i + 1, j + 1, source, pattern, ind);
            } else {
                // Max of skipping this character or matching it
                result = max(1 + ans(i + 1, j, source, pattern, ind), 
                             ans(i + 1, j + 1, source, pattern, ind));
            }
        } else {
            // Case 2: Characters do not match
            if (ind.find(i) != ind.end()) {
                // If the index is marked for removal, increment the count and move forward
                result = 1 + ans(i + 1, j, source, pattern, ind);
            } else {
                // Move forward without removing
                result = ans(i + 1, j, source, pattern, ind);
            }
        }

        // Store result in memoization table
        return dp[i][j] = result;
    }

    int maxRemovals(string source, string pattern, vector<int> &targetIndices) {
        set<int> ind;
        for (auto it : targetIndices) {
            ind.insert(it);
        }

        // Initialize memoization table with size (source.size() x pattern.size()) and -1 as default value
        dp = vector<vector<int>>(source.size() + 1, vector<int>(pattern.size() + 1, -1));

        return ans(0, 0, source, pattern, ind);
    }
};
",1420064634
vishuut,vishuut,282,3604,cpp,"
const int MOD = 1e9 + 7;

// Function to calculate Stirling Numbers of the Second Kind with modulo
vector<vector<long long>> calculateStirlingNumbers(int n) {
    vector<vector<long long>> S(n + 1, vector<long long>(n + 1, 0));
    S[0][0] = 1;  // Base case: S(0, 0) = 1

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            // Use long long to prevent overflow
            S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
        }
    }

    return S;
}

// Function to calculate modular exponentiation: (base^exp) % MOD
long long modPow(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Function to calculate factorial of a number under modulo
long long factorial(int num) {
    long long result = 1;
    for (int i = 2; i <= num; i++) {
        result = (result * i) % MOD;
    }
    return result;
}

// Function to calculate binomial coefficient C(x, k) under modulo
long long binomialCoefficient(int x, int k) {
    if (k > x) return 0;
    long long result = 1;
    for (int i = 0; i < k; i++) {
        result = (result * (x - i)) % MOD;
        result = (result * modPow(i + 1, MOD - 2, MOD)) % MOD;  // Modular inverse of (i+1)
    }
    return result;
}

// Function to calculate total number of ways under modulo
long long countWays(int n, int x, int y) {
    // Step 1: Calculate Stirling numbers S(n, k)
    vector<vector<long long>> stirling = calculateStirlingNumbers(n);

    long long totalWays = 0;

    // Step 2: Iterate over all possible values of k (1 to x)
    for (int k = 1; k <= x; k++) {
        if (k > n) continue;
        
        // S(n, k): Number of ways to partition n people into k groups
        long long stirlingWays = stirling[n][k];

        // C(x, k): Choose k stages from x stages
        long long binomialWays = binomialCoefficient(x, k);

        // k!: Permute k groups across k stages
        long long factorialWays = factorial(k);

        // y^k % MOD: Power of y raised to k under modulo
        long long yPowerWays = modPow(y, k, MOD);

        // Add to total ways
        totalWays = (totalWays + stirlingWays * binomialWays % MOD * factorialWays % MOD * yPowerWays % MOD) % MOD;
    }

    return totalWays;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        return countWays(n, x, y);
    }
};
",1420096282
vishuut,vishuut,282,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto it : nums){
            bool f=0;
            for(int i=1;i<=it;i++){
                if ((i|(i+1)) == it){
                    ans.push_back(i);
                    f=1;
                    break;
                }
            }
            if (f==0 ) ans.push_back(-1);
        }
        return ans;
        
    }
};",1419997086
vishuut,vishuut,282,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
    
        for(auto it : nums){
            if (it==2){
                ans.push_back(-1);
                continue;
            }
            int x=0;
            bool f=0;
            for(int i =0;i<=30;i++){
                if((it & (1 << i)) == 0 && !f){
                    f=1;
                    x =x & ~(1<<(i-1));
                }
                else if ((it&(1<<i))!=0 ){
                    x|=(1<<i);
                }

            }
            ans.push_back(x);

        }
        return ans;
        
    }
    
};

",1420034545
joylintp,joylintp,283,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int N = source.size(), M = pattern.size();
        vector<bool> rmv(N);
        for (int p : targetIndices)
            rmv[p] = true;

        vector<int> chk(N);
        for (int i = 0; i < N; i++)
            chk[i] = upper_bound(targetIndices.begin(), targetIndices.end(), i) - targetIndices.begin();
        vector<vector<int>> dp(N, vector(M, -1));
        for (int j = 0; j < M; j++)
        {
            int ok = -1;
            for (int i = j; i < N; i++)
            {
                if (source[i] == pattern[j])
                    if (i == 0)
                        dp[i][j] = 0;
                    else
                        dp[i][j] = chk[i - 1];
                if (ok != -1 && rmv[i])
                    dp[i][j] = max(dp[i][j], ok + 1);
                ok = max(ok, dp[i][j]);
            }
            chk[0] = dp[0][j];
            for (int i = 1; i < N; i++)
                chk[i] = max(chk[i - 1], dp[i][j]);
        }

        int ret = -1;
        for (int i = 0; i < N; i++)
            ret = max(ret, dp[i][M - 1]);
        return ret;
    }
};",1420109414
joylintp,joylintp,283,3604,cpp,"class Solution {
public:
    const int MOD = 1000000007;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(n + 1, vector(x + 1, 0LL));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= min(x, i); j++)
                dp[i][j] = (dp[i - 1][j] * j + dp[i - 1][j - 1] * (x - j + 1)) % MOD;
        
        long long base = y, ret = 0;
        for (int j = 1; j <= x; j++)
            ret = (ret + dp[n][j] * base) % MOD, base = base * y % MOD;
        return ret;
    }
};",1420064737
joylintp,joylintp,283,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret;
        for (int x : nums)
            if (x == 2)
                ret.push_back(-1);
            else
            {
                int cc = -1, t = x;
                while (x & 1)
                    cc++, x >>= 1;
                ret.push_back(t ^ (1 << cc));
            }
        return ret;
    }
};",1420074567
joylintp,joylintp,283,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ret;
        for (int x : nums)
            if (x == 2)
                ret.push_back(-1);
            else
            {
                int cc = -1, t = x;
                while (x & 1)
                    cc++, x >>= 1;
                ret.push_back(t ^ (1 << cc));
            }
        return ret;
    }
};",1420074423
trchen,trchen,285,3487,cpp,"class Solution {
 public:
  int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    int n = source.size();
    int m = pattern.size();
    unordered_set<int> indices;
    for (auto c : targetIndices) {
      indices.insert(c);
    }
    int d = targetIndices.size();
    vector<int> dp(d + 1, -1);
    dp[0] = 0;
    for (int i = 0; i < n; ++i) {
      vector<int> next_dp = dp;
      for (int dd = 0; dd <= d; ++dd) {
        if (dp[dd] >= 0 && dp[dd] < m && source[i] == pattern[dp[dd]]) {
          next_dp[dd]++;
        }
      }
      if (indices.find(i) != indices.end()) {
        for (int dd = 1; dd <= d; ++dd) {
          if (dp[dd - 1] >= 0) {
            next_dp[dd] = max(next_dp[dd], dp[dd - 1]);
          }
        }
      }
      swap(dp, next_dp);
    }
    for (int dd = d; dd >= 0; --dd) {
      if (dp[dd] == m) {
        return dd;
      }
    }
    return 0;
  }
};",1420027912
trchen,trchen,285,3604,cpp,"
using ll = long long;

class Solution {
 public:
  ll Power(ll a, int power) {
    if (a == 0) {
      return 0;
    }
    ll ret = 1;
    while (power > 0) {
      if (power % 2 == 1) {
        ret = (ret * a) % MOD;
      }
      a = (a * a) % MOD;
      power /= 2;
    }
    return ret;
  }

  ll Inverse(int a) {
    return Power(a, MOD - 2);
  }

  ll Allocate(ll n, ll x) {
    ll ret = 0;
    for (int i = 0; i <= x; ++i) {
      if (i % 2 == 0) {
        ret += power_to_N[x - i] * choose[x][i];
      } else {
        ret -= power_to_N[x - i] * choose[x][i];
      }
      ret %= MOD;
    }
    return ret;
  }

  int numberOfWays(int N, int X, int Y) {
    factorials.resize(X + 1);
    factorials[0] = 1;
    for (ll i = 1; i <= X; ++i) {
      factorials[i] = (factorials[i - 1] * i) % MOD;
    }
    inverse_factorials.resize(X + 1);
    for (int i = 0; i <= X; ++i) {
      inverse_factorials[i] = Inverse(factorials[i]);
    }
    powerY.resize(X + 1);
    powerY[0] = 1;
    for (int x = 1; x <= X; ++x) {
      powerY[x] = (powerY[x - 1] * Y) % MOD;
    }
    power_to_N.resize(X + 1);
    for (int x = 0; x <= X; ++x) {
      power_to_N[x] = Power(x, N);
    }
    choose = vector<vector<ll>>(X + 1, vector<ll>(X + 1));
    for (int x = 0; x <= X; ++x) {
      for (int y = 0; y <= x; ++y) {
        choose[x][y] =
            (factorials[x] * inverse_factorials[y]) % MOD * inverse_factorials[x - y] % MOD;
      }
    }

    ll ret = 0;
    for (int x = 1; x <= min(X, N); ++x) {
      ret += (choose[X][x] * Allocate(N, x) % MOD) * Power(Y, x) % MOD;
    }
    ret %= MOD;
    if (ret < 0) {
      ret += MOD;
    }
    return ret;
  }

  vector<ll> factorials;
  vector<ll> inverse_factorials;
  vector<ll> powerY;
  vector<ll> power_to_N;
  vector<vector<ll>> choose;

  static inline constexpr ll MOD = 1000000007;
};",1420115985
trchen,trchen,285,3605,cpp,"class Solution {
 public:
  int Min(int a) {
    if (a == 2) {
      return -1;
    }
    for (int i = 0; i < 32; ++i) {
      if ((a & (1 << i)) == 0) {
        return (a ^ (1 << (i - 1)));
      }
    }
    return 0;
  }

  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ret;
    for (auto c : nums) {
      ret.push_back(Min(c));
    }
    return ret;
  }
};",1420038684
trchen,trchen,285,3611,cpp,"class Solution {
 public:
  int Min(int a) {
    if (a == 2) {
      return -1;
    }
    for (int i = 0; i < 32; ++i) {
      if ((a & (1 << i)) == 0) {
        return (a ^ (1 << (i - 1)));
      }
    }
    return 0;
  }

  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ret;
    for (auto c : nums) {
      ret.push_back(Min(c));
    }
    return ret;
  }
};",1420038317
Ayush Mishra,speedcuberayush,288,3487,typescript,"function maxRemovals(source: string, pattern: string, targetIndices: number[]): number {
    const n = source.length;
    const m = pattern.length;
    const dp = new Array(m + 1).fill(Infinity);
    dp[0] = 0;
    const isTarget = new Array(n).fill(false);
    
    for (const idx of targetIndices) {
        isTarget[idx] = true;
    }

    let i = 0;
    while (i < n) {
        let j = m;
        while (j > 0) {
            if (source[i] === pattern[j - 1] && dp[j - 1] !== Infinity) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
            j--;
        }
        i++;
    }

    return targetIndices.length - (dp[m] === Infinity ? 0 : dp[m]);
}
",1420069600
Ayush Mishra,speedcuberayush,288,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, num: int, maxX: int, baseY: int) -> int:
        params = [num, maxX, baseY]
        binomials = [[0] * (maxX + 1) for _ in range(maxX + 1)]
        
        for i in range(maxX + 1):
            binomials[i][0] = 1
            for j in range(1, i + 1):
                binomials[i][j] = (binomials[i - 1][j - 1] + binomials[i - 1][j]) % MOD
        
        stirling = [[0] * (maxX + 1) for _ in range(num + 1)]
        stirling[0][0] = 1
        
        for i in range(1, num + 1):
            for j in range(1, maxX + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        factorials = [1] * (maxX + 1)
        for i in range(1, maxX + 1):
            factorials[i] = factorials[i - 1] * i % MOD
        
        totalWays = 0
        for k in range(1, maxX + 1):
            power = pow(baseY, k, MOD)
            
            binomialCoeff = binomials[maxX][k]
            stirlingCoeff = stirling[num][k]
            factorialCoeff = factorials[k]
            
            currentTerm = (binomialCoeff * stirlingCoeff) % MOD
            currentTerm = (currentTerm * factorialCoeff) % MOD
            currentTerm = (currentTerm * power) % MOD
            
            totalWays = (totalWays + currentTerm) % MOD
        
        return totalWays
",1420116417
Ayush Mishra,speedcuberayush,288,3605,python3,"class Solution:
    def minBitwiseArray(self, nums):
        ans = [-1] * len(nums)

        for i, x in enumerate(nums):
            for a in range(x):
                if (a | (a + 1)) == x:
                    ans[i] = a
                    break

        return ans
",1419997164
Ayush Mishra,speedcuberayush,288,3611,python3,"class Solution:
    def minBitwiseArray(self, nums):
        n = len(nums)
        ans = [-1] * n

        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False

            for bit in range(31):
                if (num >> bit) & 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0: continue

                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            if found: 
                ans[i] = minimalAns
        return ans
",1420047906
Dhruv Pasricha,pasricha_dhruv,289,3487,cpp,"string s, t;
int canRemove[4000];
int dp[3002][3002];

class Solution {

    int f(int id1, int id2)
    {
        if(id1 == s.size())
        {
            return id2 == t.size() ? 0 : -5000;
        }

        if(dp[id1][id2] != -1) return dp[id1][id2];

        int ans1 = f(id1 + 1, id2 + (id2 < t.size() and s[id1] == t[id2]));
        int ans2 = canRemove[id1] ? 1 + f(id1 + 1, id2) : ans1;

        return dp[id1][id2] = max(ans1, ans2);
    }

public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        for(int i = 0; i < n; ++i) canRemove[i] = 0;
        for(auto it : targetIndices) canRemove[it] = 1;
        s = source;
        t = pattern;
        int m = pattern.size();
        for(int i = 0; i <= n; ++i) {
            for(int j = 0; j <= m; ++j) {
                dp[i][j] = -1;
            }
        }
        return f(0, 0);      
    }
};",1420025062
Dhruv Pasricha,pasricha_dhruv,289,3604,cpp,"#define int long long

int dp[1010][1010];
const int mod = 1e9 + 7;
bool done = 0;

int power(int x, int n)
{
    if(n == 0) return 1;
    if(n % 2 == 1) return (power(x, n - 1) * x) % mod;
    int ans = power(x, n / 2);
    return (ans * ans) % mod;
}
 
#define ll long long
const int N = 1e3 + 10;
using namespace std;
 
// array to store inverse of 1 to N
ll factorialNumInverse[N + 1];
 
// array to precompute inverse of 1! to N!
ll naturalNumInverse[N + 1];
 
// array to store factorial of first N numbers
ll fact[N + 1];
 
// Function to precompute inverse of numbers
void InverseofNumber(ll p)
{
    naturalNumInverse[0] = naturalNumInverse[1] = 1;
    for (int i = 2; i <= N; i++)
        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
}
// Function to precompute inverse of factorials
void InverseofFactorial(ll p)
{
    factorialNumInverse[0] = factorialNumInverse[1] = 1;
 
    // precompute inverse of natural numbers
    for (int i = 2; i <= N; i++)
        factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
}
 
// Function to calculate factorial of 1 to N
void factorial(ll p)
{
    fact[0] = 1;
 
    // precompute factorials
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % p;
    }
}
 
// Function to return nCr % p in O(1) time
ll Binomial(ll N, ll R, ll p)
{
    // n C r = n!*inverse(r!)*inverse((n-r)!)
    ll ans = ((fact[N] * factorialNumInverse[R])
              % p * factorialNumInverse[N - R])
             % p;
    return ans;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {

        if(!done)
        {
            InverseofNumber(mod);
            InverseofFactorial(mod);
            factorial(mod);
            done = 1;
        }

        dp[0][0] = 1;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= x; ++j)
            {
                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]) % mod;
            }
        }

        int ans = 0;
        for(int i = 1; i <= x; ++i)
        {
            ans += ((((dp[n][i] * power(y, i)) % mod) * ((Binomial(x, i, mod) * fact[i]) % mod)) % mod);
            ans %= mod;
        }

        return ans;
    }
};

#undef int",1420110107
Dhruv Pasricha,pasricha_dhruv,289,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; ++i)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                int b = 0;
                while((1 << b) & nums[i])
                {
                    ++b;
                }
                --b;
                ans[i] = nums[i] - (1 << b);
            }
        }   
        return ans;
    }
};",1420011199
Dhruv Pasricha,pasricha_dhruv,289,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; ++i)
        {
            if(nums[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                int b = 0;
                while((1 << b) & nums[i])
                {
                    ++b;
                }
                --b;
                ans[i] = nums[i] - (1 << b);
            }
        }   
        return ans;    
    }
};",1420012378
Bhupesh,bhupi28,290,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        Set<Integer> set = new HashSet<>();
        for(int i : targetIndices) set.add(i);
        int[][] dp = new int[pattern.length()+2][source.length() + 2];
        for(int[] a : dp) Arrays.fill(a , -1);
        int ans = fun(0 , 0 , source , pattern , set , dp);
        return ans;
    }
    
    int fun(int i , int j , String source , String pattern , Set<Integer> set , int[][] dp){
        if(i >= source.length()){
            if(j >= pattern.length()){
                return 0;
            }
            return -1_000_000;
        }
        else if(dp[j][i] != -1){
            return dp[j][i];
        }
        int ans = -1_000_000_0;
        if(j >= pattern.length()){
            if(set.contains(i)){
                ans = Math.max(ans , 1 + fun(i+1 , j , source , pattern , set , dp));
            }
            else{
                ans = Math.max(ans , fun(i+1 , j , source , pattern , set, dp));
            }
        }
        else{
            if(source.charAt(i) == pattern.charAt(j)){
                if(set.contains(i)){
                    ans = Math.max(ans , fun(i+1 , j+1 , source , pattern , set, dp));
                    ans = Math.max(ans , 1 + fun(i+1 , j , source , pattern , set, dp));
                }
                else{
                    ans = Math.max(ans , fun(i+1 , j+1 , source , pattern , set, dp));
                    ans = Math.max(ans , fun(i+1 , j , source , pattern , set, dp));
                }
            }
            else{
                if(set.contains(i)){
                    ans = Math.max(ans , 1 + fun(i + 1 , j , source , pattern , set, dp));
                }
                else{
                    ans = Math.max(ans , fun(i+1 , j , source , pattern , set, dp));
                }
            }
        }
        
        
        return dp[j][i] = ans;
    }
}",1420110164
Bhupesh,bhupi28,290,3604,java,"import java.math.BigInteger;

class Solution {
    public int numberOfWays(int a, int b, int c) {
        final int d = 1_000_000_007;
        
        int e = Math.max(a, b);
        long[] f = new long[e + 1];
        long[] g = new long[e + 1];
        f[0] = 1;
        for(int h = 1; h <= e; h++) {
            f[h] = (f[h-1] * h) % d;
        }
        g[e] = modInverse(f[e], d);
        for(int h = e - 1; h >= 0; h--) {
            g[h] = (g[h+1] * (h+1)) % d;
        }
        
        long[][] i = new long[a + 1][b + 1];
        i[0][0] = 1;
        for(int j = 1; j <= a; j++) {
            for(int k = 1; k <= b; k++) {
                i[j][k] = (i[j-1][k-1] + (k * i[j-1][k]) % d) % d;
            }
        }
        
        long l = 0;
        for(int m = 1; m <= Math.min(a, b); m++) {
            if(b < m) continue;
            long n = (f[b] * modInverse(f[b - m], d)) % d;
            
            long o = (n * i[a][m]) % d;
            
            o = (o * power(c, m, d)) % d;
            
            l = (l + o) % d;
        }
        
        long p = l;
        
        return (int) p;
    }
    
    private long power(long q, long r, int s) {
        long t = 1;
        q = q % s;
        while(r > 0){
            if((r & 1) == 1){
                t = (t * q) % s;
            }
            q = (q * q) % s;
            r >>= 1;
        }
        return t;
    }
    
    private long modInverse(long u, int v) {
        return power(u, v - 2, v);
    }
}",1420050069
Bhupesh,bhupi28,290,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans = new int[nums.size()];
        
ol:     for(int i = 0 ; i < nums.size() ; i++){
            int x = nums.get(i);
            
            int len = Integer.toBinaryString(x).length();
            
            for(int j = len ; j >= 0 ; j--){
                long z = pow(2 , j);
                
                if(x - z > 0){
                    long vval = x - z;
                    if(((vval) | (vval + 1)) == x){
                        ans[i] = (int)vval;
                        continue ol;
                    }
                }
            }
    
            ans[i] = -1;
        }
        
        return ans;
    }
    
    long pow(long a, long b ) {
	    long res = 1;
	    while (b > 0) {
	        if ((b & 1) == 0) {
	            a  = (a*a) ;
	            b = b >> 1;
	        } else {
	            res = (res*a) ;
	            b--;
	        }
	    }
	    return res;
}

}",1420029538
Bhupesh,bhupi28,290,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] ans = new int[nums.size()];
        
ol:     for(int i = 0 ; i < nums.size() ; i++){
            int x = nums.get(i);
            
            int len = Integer.toBinaryString(x).length();
            
            for(int j = len ; j >= 0 ; j--){
                long z = pow(2 , j);
                
                if(x - z > 0){
                    long vval = x - z;
                    if(((vval) | (vval + 1)) == x){
                        ans[i] = (int)vval;
                        continue ol;
                    }
                }
            }
    
            ans[i] = -1;
        }
        
        return ans;
    }
    
    long pow(long a, long b ) {
	    long res = 1;
	    while (b > 0) {
	        if ((b & 1) == 0) {
	            a  = (a*a) ;
	            b = b >> 1;
	        } else {
	            res = (res*a) ;
	            b--;
	        }
	    }
	    return res;
}

}",1420029199
Ahobilesha,aho343,291,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        ans=[False]*len(source)
        for ind in targetIndices:
            ans[ind]=True
        dp=[float('inf')]*(len(pattern)+1)
        dp[0]=0
        for i in range(len(source)):
            for j in range(len(pattern),0,-1):
                if source[i]==pattern[j-1] and dp[j-1]!=float('inf'):
                    dp[j]=min(dp[j], dp[j-1] + (1 if ans[i] else 0))
        result=len(targetIndices)-max(dp[len(pattern)],0)
        return result",1420073120
Ahobilesha,aho343,291,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD=10**9+7
        ans=0
        C=[[0]*(x+1) for z in range(x+1)]
        i=0
        while i<=x:
            C[i][0]=1
            j=1
            while j<=i:
                C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD
                j+=1
            i+=1
        tab=[[0]*(x+1) for z in range(n+1)]
        tab[0][0]=1
        i=1
        while i<=n:
            j=1
            while j<=x:
                tab[i][j]=(j*tab[i-1][j]+tab[i-1][j-1])%MOD
                j+=1
            i+=1
        fact=[1]*(x+1)
        i=1
        while i<=x:
            fact[i]=fact[i-1]*i%MOD
            i+=1
        k=1
        while k<=x:
            pow_y=1
            p=0
            while p<k:
                pow_y=(pow_y*y)%MOD
                p+=1
            ans=(ans+C[x][k]*tab[n][k]%MOD*fact[k]%MOD*pow_y%MOD)%MOD
            k+=1
        return ans
",1420110337
Ahobilesha,aho343,291,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[-1]*len(nums) 
        for i in range(len(nums)):
            for j in range(nums[i]+1):
                if (j|(j+1))==nums[i]:
                    ans[i]=j
                    break 
        return ans",1420007172
Ahobilesha,aho343,291,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[-1]*len(nums)
        for i in range(len(nums)):
            num=nums[i]
            mi=float('inf')
            f=False
            for b in range(31):
                if (num>>b)&1==1:
                    c=num & ~(1<<b)
                    if c<0:
                        continue
                    if (c|(c+1))==num:
                        if c<mi:
                            mi=c
                            f=True
            ans[i]= mi if mi!=float('inf') else -1
        return ans",1420053027
Pranshu Jain,pranshujain0111,292,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

/* clang-format off */

/* TYPES  */
#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vll vector<long long>
#define mii map<int, int>
#define si set<int>
#define sc set<char>

/* FUNCTIONS */
#define f(i,s,e) for(long long int i=s;i<e;i++)
#define cf(i,s,e) for(long long int i=s;i<=e;i++)
#define rf(i,e,s) for(long long int i=e-1;i>=s;i--)
#define pb push_back
#define eb emplace_back

/* PRINTS */
template <class T>
void print_v(vector<T> &v) { cout << ""{""; for (auto x : v) cout << x << "",""; cout << ""\b}""; }

/* UTILS */
#define MOD 1000000007
#define PI 3.1415926535897932384626433832795
#define read(type) readInt<type>()
ll min(ll a,int b) { if (a<b) return a; return b; }
ll min(int a,ll b) { if (a<b) return a; return b; }
ll max(ll a,int b) { if (a>b) return a; return b; }
ll max(int a,ll b) { if (a>b) return a; return b; }
ll gcd(ll a,ll b) { if (b==0) return a; return gcd(b, a%b); }
ll lcm(ll a,ll b) { return a/gcd(a,b)*b; }
string to_upper(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A'; return a; }
string to_lower(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A'; return a; }
bool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }
void yes() { cout<<""YES\n""; }
void no() { cout<<""NO\n""; }

/*  All Required define Pre-Processors and typedef Constants */
typedef long int int32;
typedef unsigned long int uint32;
typedef long long int int64;
typedef unsigned long long int  uint64;

class Solution {
public:
    int maxRemovals(string original, string subsequence,
                    vector<int>& indicesToRemove) {
        int originalLength = original.length();
        int subsequenceLength = subsequence.length();
        vector<int> removalCount(subsequenceLength + 1,
                                 numeric_limits<int>::max());
        removalCount[0] = 0;
        vector<bool> targets(originalLength, false);

        markTargetIndices(indicesToRemove, targets);

        for (int i = 0; i < originalLength; ++i) {
            updateRemovalCounts(original[i], subsequence, removalCount, targets,
                                i, subsequenceLength);
        }

        return indicesToRemove.size() -
               (removalCount[subsequenceLength] == numeric_limits<int>::max()
                    ? 0
                    : removalCount[subsequenceLength]);
    }

private:
    void markTargetIndices(const vector<int>& indices, vector<bool>& targets) {
        for (int index : indices) {
            targets[index] = true;
        }
    }

    void updateRemovalCounts(char currentChar, const string& subsequence,
                             vector<int>& removalCount,
                             const vector<bool>& targets, int currentIndex,
                             int subsequenceLength) {
        for (int j = subsequenceLength; j > 0; --j) {
            if (currentChar == subsequence[j - 1] &&
                removalCount[j - 1] != numeric_limits<int>::max()) {
                removalCount[j] =
                    min(removalCount[j],
                        removalCount[j - 1] + (targets[currentIndex] ? 1 : 0));
            }
        }
    }
};
",1420058964
Pranshu Jain,pranshujain0111,292,3604,cpp,"#include <bits/stdc++.h>
using namespace std;

/* clang-format off */

/* TYPES  */
#define ll long long
#define pii pair<int, int>
#define pll pair<long long, long long>
#define vi vector<int>
#define vll vector<long long>
#define mii map<int, int>
#define si set<int>
#define sc set<char>

/* FUNCTIONS */
#define f(i,s,e) for(long long int i=s;i<e;i++)
#define cf(i,s,e) for(long long int i=s;i<=e;i++)
#define rf(i,e,s) for(long long int i=e-1;i>=s;i--)
#define pb push_back
#define eb emplace_back

/* PRINTS */
template <class T>
void print_v(vector<T> &v) { cout << ""{""; for (auto x : v) cout << x << "",""; cout << ""\b}""; }

/* UTILS */

const int MODULO = 1e9 + 7;
#define PI 3.1415926535897932384626433832795
#define read(type) readInt<type>()
ll min(ll a,int b) { if (a<b) return a; return b; }
ll min(int a,ll b) { if (a<b) return a; return b; }
ll max(ll a,int b) { if (a>b) return a; return b; }
ll max(int a,ll b) { if (a>b) return a; return b; }
ll gcd(ll a,ll b) { if (b==0) return a; return gcd(b, a%b); }
ll lcm(ll a,ll b) { return a/gcd(a,b)*b; }
string to_upper(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A'; return a; }
string to_lower(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A'; return a; }
bool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }
void yes() { cout<<""YES\n""; }
void no() { cout<<""NO\n""; }

/*  All Required define Pre-Processors and typedef Constants */
typedef long int int32;
typedef unsigned long int uint32;
typedef long long int int64;
typedef unsigned long long int  uint64;


class Solution {
public:
    int numberOfWays(int totalItems, int maxGroups, int multiplier) {
        vector<vector<int>> binomialCoefficients = computeBinomialCoefficients(maxGroups);
        vector<vector<int>> stirlingNumbers = computeStirlingNumbers(totalItems, maxGroups);
        vector<int> factorials = computeFactorials(maxGroups);

        long long result = 0;
        for (int groups = 1; groups <= maxGroups; ++groups) {
            long long multiplierPower = computePower(multiplier, groups, MODULO);
            result = (result + 1LL * binomialCoefficients[maxGroups][groups] * stirlingNumbers[totalItems][groups] % MODULO * factorials[groups] % MODULO * multiplierPower % MODULO) % MODULO;
        }

        return result;
    }

private:
    vector<vector<int>> computeBinomialCoefficients(int limit) {
        vector<vector<int>> binomial(limit + 1, vector<int>(limit + 1, 0));
        for (int i = 0; i <= limit; ++i) {
            binomial[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % MODULO;
            }
        }
        return binomial;
    }

    vector<vector<int>> computeStirlingNumbers(int totalItems, int maxGroups) {
        vector<vector<int>> stirling(totalItems + 1, vector<int>(maxGroups + 1, 0));
        stirling[0][0] = 1;
        for (int items = 1; items <= totalItems; ++items) {
            for (int groups = 1; groups <= maxGroups; ++groups) {
                // Use long long to avoid overflow in multiplication
                stirling[items][groups] = (1LL * groups * stirling[items - 1][groups] + stirling[items - 1][groups - 1]) % MODULO;
            }
        }
        return stirling;
    }

    vector<int> computeFactorials(int limit) {
        vector<int> factorial(limit + 1, 1);
        for (int i = 1; i <= limit; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MODULO;
        }
        return factorial;
    }

    long long computePower(long long base, long long exponent, long long modulo) {
        long long result = 1;
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % modulo;
            }
            base = (base * base) % modulo;
            exponent /= 2;
        }
        return result;
    }
};",1420104053
Pranshu Jain,pranshujain0111,292,3605,cpp,"class Solution {
public:

    int findMinValue(int target) {
        for (int candidate = 0; candidate <= target; candidate++) {
            if ((candidate | (candidate + 1)) == target) {
                return candidate;
            }
        }
        return -1;  
    }

    vector<int> minBitwiseArray(const vector<int>& inputArray) {
        int size = inputArray.size();
        vector<int> result(size, -1); 

        for (int index = 0; index < size; index++) {
            result[index] = findMinValue(inputArray[index]);
        }

        return result;
    }
};
",1420009462
Pranshu Jain,pranshujain0111,292,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputNumbers) {
        int size = inputNumbers.size();
        vector<int> result(size);
        
        for (int index = 0; index < size; index++) {
            int currentNumber = inputNumbers[index];
            result[index] = calculateMinimalValue(currentNumber);
        }
        
        return result;
    }

private:
    int calculateMinimalValue(int number) {
        int minimumValue = INT_MAX;
        bool isFound = false;

        for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
            if (isBitSet(number, bitPosition)) {
                int potentialValue = unsetBit(number, bitPosition);

                if (potentialValue >= 0) {
                    if (isValidCandidate(potentialValue, number)) {
                        if (potentialValue < minimumValue) {
                            minimumValue = potentialValue;
                            isFound = true;
                        }
                    }
                }
            }
        }

        return isFound ? minimumValue : -1;
    }

    bool isBitSet(int number, int position) {
        return (number >> position) & 1;
    }

    int unsetBit(int number, int position) {
        return number & ~(1 << position);
    }

    bool isValidCandidate(int candidate, int original) {
        return (candidate | (candidate + 1)) == original;
    }
};
",1420045220
Sasura123,Sasura123,293,3487,cpp,"class Solution {
public:
    set<int> st;
    int dp[3001][3001];

    int func(int ind1,int ind2,string &pat,string &src){
        if(ind1==pat.size()) return 0;
        if(ind2==src.size()) return 1e9;

        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];

        int choose=1e9,notChoose=1e9;

        if(src[ind2]==pat[ind1]){
            if(st.find(ind2)!=st.end()) choose=1+func(ind1+1,ind2+1,pat,src);
            else choose=func(ind1+1,ind2+1,pat,src);
        }

        notChoose=func(ind1,ind2+1,pat,src);

        return dp[ind1][ind2]=min(choose,notChoose);
    }

    int maxRemovals(string source, string pattern, vector<int>& ti) {
        for(int i=0;i<ti.size();i++) st.insert(ti[i]);
        memset(dp,-1,sizeof(dp));

        return ti.size()-func(0,0,pattern,source);
    }
};",1420068516
Sasura123,Sasura123,293,3604,cpp,"#define ll long long
const ll M=1e9+7;

class Solution {
public:
    ll ypow[1002];
    ll dp[1001][1001];

    ll func(ll ind,ll cnt,int &n,int &x,int &y){
        if(ind==n) return ypow[cnt];

        if(dp[ind][cnt]!=-1) return dp[ind][cnt];

        ll same=(cnt*func(ind+1,cnt,n,x,y)%M)%M;
        ll diff=((x-cnt)*func(ind+1,cnt+1,n,x,y)%M)%M;

        return dp[ind][cnt]=same+diff;
    }

    int numberOfWays(int n, int x, int y) {
        ypow[1]=y;
        memset(dp,-1,sizeof(dp));

        for(ll i=2;i<=x;i++){
            ypow[i]=(ypow[i-1]%M*y)%M;
        }

        return (int)func(0,0,n,x,y)%M;
    }
};",1420110800
Sasura123,Sasura123,293,3605,cpp,"class Solution {
public:
    int findBit(int x){
        int cnt=-1;

        for(int i=0;i<32;i++){
            if((1<<i)&x) cnt++;
            else break;
        }

        return cnt;
    }

    int findRes(int x,int bit){
        int res=0;

        for(int i=0;i<32;i++){
            if(((1<<i)&x)&&i!=bit) res+=(1<<i);
        }

        return res;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;

        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int bit=findBit(nums[i]);

                int res=findRes(nums[i],bit);
                ans.push_back(res);
            }
        }

        return ans;
    }
};",1420035339
Sasura123,Sasura123,293,3611,cpp,"class Solution {
public:
    int findBit(int x){
        int cnt=-1;

        for(int i=0;i<32;i++){
            if((1<<i)&x) cnt++;
            else break;
        }

        return cnt;
    }

    int findRes(int x,int bit){
        int res=0;

        for(int i=0;i<32;i++){
            if(((1<<i)&x)&&i!=bit) res+=(1<<i);
        }

        return res;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;

        for(int i=0;i<n;i++){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int bit=findBit(nums[i]);

                int res=findRes(nums[i],bit);
                ans.push_back(res);
            }
        }

        return ans;
    }
};",1420034620
Raghavendra Gavuji,crimsonalpha19118,294,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0  
        target_set = set(targetIndices)
        for i in range(n):
            for j in range(min(m, i + 1), 0, -1):
                if source[i] == pattern[j - 1]:
                    if dp[j - 1] != float('inf'):
                        cost = dp[j - 1] + (1 if i in target_set else 0)
                        dp[j] = min(dp[j], cost)
        
        if dp[m] == float('inf'):
            return 0
        else:
            return len(targetIndices) - int(dp[m])",1420100471
Raghavendra Gavuji,crimsonalpha19118,294,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        MAX = 2005  
        factorial = [1] * MAX
        inv_factorial = [1] * MAX

        for i in range(1, MAX):
            factorial[i] = factorial[i - 1] * i % MOD
        inv_factorial[MAX - 1] = pow(factorial[MAX - 1], MOD - 2, MOD)
        for i in range(MAX - 2, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD
        N = n + 1  
        S = [[0] * (N) for _ in range(N)]
        S[0][0] = 1  # Base case

        for i in range(1, N):
            for k in range(1, i + 1):
                S[i][k] = (k * S[i - 1][k] + S[i - 1][k - 1]) % MOD

        def permutations(a, b):
            """"""Compute a Permutation b: P(a, b) = a! / (a - b)!""""""
            if a < b:
                return 0
            return factorial[a] * inv_factorial[a - b] % MOD

        total = 0
        min_k = min(n, x)  

        for k in range(1, min_k + 1):
            s = S[n][k]
            x_p_k = permutations(x, k)
            y_pow_k = pow(y, k, MOD)
            term = s * x_p_k % MOD * y_pow_k % MOD
            total = (total + term) % MOD

        return total",1420110863
Raghavendra Gavuji,crimsonalpha19118,294,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  

        for i in range(n):
            for x in range(nums[i] + 1):
                if (x | (x + 1)) == nums[i]:
                    ans[i] = x
                    break  

        return ans",1420009967
Raghavendra Gavuji,crimsonalpha19118,294,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            min_x = None
            for k in range(31):  # Since N can be up to 2^31 - 1
                x = N - (1 << k)
                if x >= 0 and (x | (x + 1)) == N:
                    if min_x is None or x < min_x:
                        min_x = x
            ans.append(min_x if min_x is not None else -1)
        return ans",1420036771
Chinedu,profchi,295,3487,java,"class Solution {
    int min = -1_000_000;
    
    Integer [][] memo;
    
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        Arrays.sort(targetIndices);
        
        memo = new Integer [source.length()][pattern.length()];
        return solve(source, pattern, targetIndices, 0, 0, 0);
    }
    
    private int solve(String source, String pattern, int [] target, int sIdx, int pIdx, int tIdx) {
        
        if (pIdx == pattern.length())
            return target.length - tIdx;
        else if (sIdx == source.length())
            return min;
        else if (memo[sIdx][pIdx] != null)
            return memo[sIdx][pIdx];
        
        boolean canSkip = tIdx < target.length && target[tIdx] == sIdx;
        int ntIdx = canSkip ? tIdx + 1 : tIdx;
        
        // leave
        int nsIdx = sIdx + 1;
        int npIdx = source.charAt(sIdx) == pattern.charAt(pIdx) ? pIdx + 1 : pIdx;
        
        int result = solve(source, pattern, target, nsIdx, npIdx, ntIdx);
            
        // skip
        if (canSkip) {
            int result2 = 1 + solve(source, pattern, target, nsIdx, pIdx, ntIdx);
            result = Math.max(result, result2);
        }
        
        memo[sIdx][pIdx] = result;
        return result;
    }
}",1420035931
Chinedu,profchi,295,3604,java,"class Solution {
    
    static int mod = 1_000_000_007;
    
    static Combinatorics comb = new Combinatorics(mod, 10_000);
    
    Integer [] memo;
    
    public int numberOfWays(int n, int x, int y) {
        
        // return solve(rem, n, y);
        
        int max = Math.min(x, n);
        
        long result = 0;
        long ways, v, yWays, val;
        
        memo = new Integer [max + 1];
        
        for (int i = 1; i <= max; ++i) {
            ways = comb.choose(x, i);
            v = countWays(n, i);
            
            yWays = powerSum(y, i, mod);
            
            val = ways * v;
            val %= mod;
            
            val *= yWays;
            val %= mod;
            
            result += val;
            result %= mod;
        }
        
        return (int) result;
    }
    
    private long countWays(int n, int x) {
        
        if (memo[x] != null)
            return memo[x];
        
        long total = powerSum(x, n , mod);
        
        long sub;
        
        for (int i = x - 1; i > 0; --i) {
            sub = countWays(n, i);
            sub *= comb.choose(x, i);
            
            sub %= mod;
            
            total += mod - sub;
            total %= mod;
        }
        
        memo[x] = (int)total;
        return total;
    }
    
    
    private static long powerSum(long a, long b, int mod) {
		Map<Long, Long> map = new HashMap<>();
		
		long current = 1;
		long val = a;
		long result = 1;
		
		while (current <= b) {
			map.put(current, val);
			
			val = val * val;
			val %= mod;
			
			current *= 2;
		}
		
		while (current > 1) {
			current /= 2;
			
			if (b >= current) {
				b -= current;
				result *= map.get(current);
				result %= mod;
			}
		}
		
		return result;
	}
    
}

class Combinatorics {

	private long [] factorial;
	private int max;
	private int mod;
	
	
	Combinatorics(int mod, int max) {
		this.max = max;
		this.mod = mod;
		
		factorial = new long [max + 2];
		factorial[0] = 1;
		
		for (int i = 1; i < factorial.length; ++i) {
			factorial[i] = factorial[i - 1] * i;
			factorial[i] %= mod;
		}
	}
	
	// n similar items among r people
	public long distribute(int n, int r) {
		
		return choose(n + r - 1, r - 1);
	}
	
	// number of ways to choose b people from n
	public long choose(int n, int b) {
		if (n < 0 || b < 0) return 1;
		
		long num = factorial[n];
		
		long den = factorial[n - b];
		den *= factorial[b];
		den %= mod;
		
		num *= multiplicativeInverse((int)den, mod);
		num %= mod;
		
		return num;
	}
	
	
	
	
	private int gcd(int a, int b) {
		if (a % b == 0)
			return b;
		
		return gcd(b , a % b);
	}
	
	private int[] egcd(int a, int b) {
        if (b == 0)
            return new int[] { a, 1, 0 };
        else {
            int[] arr = egcd(b, a % b);
 
            int gcd = arr[0];
            int X = arr[2];
            int Y = arr[1] - (a / b) * arr[2];
 
            return new int[] { gcd, X, Y };
        }
    }
 
    private int multiplicativeInverse(int a, int modulo) {
 
        int[] egcdValues = egcd(a, modulo);
 
        if (egcdValues[0] != 1)
            return 0;
        if (egcdValues[1] > 0)
            return egcdValues[1];
        else
            return egcdValues[1] + modulo;
    }
    
    
    // So if changes are conditionsly added from 0 mod mod
 	// How many steps would it take to get to diff
 	private long getMinSteps(int diff, int changes, int mod) {
 		if (diff == 0)
 			return 0;
 		else if (changes == 0)
 			return -1;
 		
 		//System.out.println(changes + "" "" + diff);
 		int h = mod;
 		int rep = gcd(h, changes);
 		
 		
 		
 		if (diff % rep != 0)
 			return -1;
 		
 		int rc = changes / rep;
 		int hc = h / rep;
 		int dc = diff / rep;
 		
 		long inv = multiplicativeInverse(rc, hc);
 		
 		inv *= dc;
 		inv %= hc;
 		
 		return inv;
 	}
 	
 	// a is a sequence incremented with start a increment by aR
 	// b is a sequence with start b incremted by bR
 	// returns the first number common to both sequence
 	// returns -1 if there's no common number
 	private long getMin(int a, int aR, int b, int bR) {
 		if (a == b)
 			return a;
 		
 		int target = a;
 		
 		
 		int needed = b % aR;
 		needed = a + aR - needed;
 		needed %= aR;
 		
 		
 		long times = getMinSteps(bR % aR, needed, aR);
 		if (times < 0) 
 			return -1;
 		
 		times *= bR;
 		times += b;
 		
 		return times;
 	}
 	
 	// a is a sequence incremented with start a increment by aR
 	// b is a sequence with start b incremted by bR
 	// returns time at which they both me, at t = 0 , first = a, second = b;
 	// at Result a + t*aR = b + t * bR;
 	// returns -1 if there are no common terms
 	private long getTime(int a, int aR, int b, int bR) {
 		if (a == b)
 			return 0;
 		
 		
 		int needed = b % aR;
 		needed = a + aR - needed;
 		needed %= aR;
 		
 		
 		return getMinSteps(bR % aR, needed, aR);
 	}

}
",1420111087
Chinedu,profchi,295,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        
        int [] result = new int [nums.size()];
        int idx = 0;
        
        Map<Integer, Integer> map = new HashMap<>();
        
        int val;
        
        for (int i = 0; i <= 1000; ++i) {
            val = i | (i + 1);
            
            if (!map.containsKey(val)) {
                map.put(val, i);
            }
        }
        
        
        for (int i = 0; i < result.length; ++i) {
            val = nums.get(i);
            result[i] = map.getOrDefault(val, -1);
        }
        
        
        
        return result;
    }
}",1419998714
Chinedu,profchi,295,3611,java,"class Solution {
   public int[] minBitwiseArray(List<Integer> nums) {
        
        int [] result = new int [nums.size()];
        int idx = 0;
        
        Map<Integer, Integer> map = new HashMap<>();
        
        int val;
        
        for (int i = 0; i < result.length; ++i) {
            val = nums.get(i);
            result[i] = getVal(val);
        }
        
        return result;
    }
    
    private int getVal(int target) {
        
        if (target == 2)
            return -1;
        
        int bit1, bit2;
        
        for (int i = 0; i <= 29; ++i) {
            bit1 = ((1 << i) & target) == 0 ? 0 : 1;
            bit2 = ((1 << (i + 1)) & target) == 0 ? 0 : 1;
            
            if (bit1 == 1 && bit2 == 0) {
                int res = target ^ (1 << i);
                return res;
            }
        }
        
        return target;
    }
}",1420011702
chota_don,karanjohn890,296,3487,cpp,"class Solution {
public:
    int solve(string &s,string &p,int i,int j,vector<int> &hash,vector<vector<int>> &dp){
        if(i>=s.length() && j>=p.length())return 0;
        if(i>=s.length())return 1000000;
        if(j>=p.length())return 0;
        if(dp[i][j]!=INT_MAX)return dp[i][j];
        int sol= solve(s,p,i+1,j,hash,dp);
        if(s[i]==p[j]){
            if(hash[i]==1)
                sol=min(sol,solve(s,p,i+1,j+1,hash,dp)+1);
            else
                 sol=min(sol,solve(s,p,i+1,j+1,hash,dp));  
        }
    return dp[i][j]=sol;
        
    }
    int maxRemovals(string s, string p, vector<int>& t) {
    vector<int> hashmap(s.length(),0);
        int n=s.length();
        for(int i=0;i<t.size();i++)hashmap[t[i]]++;
        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));
        return max(0,(int)t.size() - solve(s,p,0,0,hashmap,dp));
    }
};",1420025533
chota_don,karanjohn890,296,3604,cpp,"class Solution {
public:
    long long mod=1e9+7;
long long mmi(long long A, long long M) {
    long long m0 = M;
    long long y = 0, x = 1;

    if (M == 1)
        return 0;

    while (A > 1) {
        // q is quotient
        long long q = A / M;
        long long t = M;

        // m is remainder now, process same as
        // Euclid's algo
        M = A % M, A = t;
        t = y;

        // Update y and x
        y = x - q * y;
        x = t;
    }

    // Make x positive
    if (x < 0)
        x += m0;

    return x;
}

// Function for extended Euclidean Algorithm

    long long ncr(long long n,long long r,long long mod,vector<long long> &fact){
        if(n==r)return 1;
        long long ans = fact[n]*mmi(fact[n-r],mod);
        ans%=mod;
        ans*=mmi(fact[r],mod);
     
        ans%=mod;
        return ans;
    }
    
    long long solve(long long n,long long st,vector<long long> &dp,vector<long long> &fact){
        
        if(dp[st]!=-1)return dp[st];
        long long ans = power(st,n,mod);
        for(int i=st-1;i>=1;i--){
            long long curr = ncr(st,i,mod,fact);
            curr*=solve(n,i,dp,fact);
            ans-=curr;
            ans+=mod;
            ans%=mod;
        }
        return dp[st]=ans;
        
    }
    long long power(long long a,long long b,long long mod){
        if(b==0)return 1;
        if(b==1)return a;
        long long res = power(a,b/2,mod);
        res= (res*res)%mod;
        if(b%2==1)res = (res*a)%mod;
        return res;
    }
    
    int numberOfWays(int n, int x, int y) {
       vector<long long> fact(1002);
        fact[0]=1;
        for(long long i=1;i<1002;i++)fact[i]=(fact[i-1]*i)%mod;
        
       
        
        long long ans=0;
        vector<long long> dp(max({n,x,y})+20,-1);
        vector<vector<long long>> ncrdp(n,vector<long long>(n,-1));
        for(int i=1;i<=x;i++){
        
            if(n<i)continue;
            long long stages = ncr(x,i,mod,fact);
           
          
            long long curr = solve(n,i,dp,fact);
            curr=(curr*stages)%mod;
         
             long long marks = power((long long)y,(long long)i,mod);
            
            curr=(curr*marks)%mod;
            
            ans = (ans+curr)%mod;
        }
        return ans;
    }
};",1420111195
chota_don,karanjohn890,296,3605,cpp,"class Solution {
public:
    int solve(int a){
        int ans=1;
        int x=a;
        a/=2;
        while(a!=0){
            if(a%2==1)ans*=2;
            else break;
            a/=2;
        }
        return x-ans;
    }
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for(int i=0;i<a.size();i++){
            if(a[i]==2)ans.push_back(-1);
            else ans.push_back(solve(a[i]));
        }
        return ans;
    }
};",1420009569
chota_don,karanjohn890,296,3611,cpp,"class Solution {
public:
    int solve(int a){
        int ans=1;
        int x=a;
        a/=2;
        while(a!=0){
            if(a%2==1)ans*=2;
            else break;
            a/=2;
        }
        return x-ans;
    }
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for(int i=0;i<a.size();i++){
            if(a[i]==2)ans.push_back(-1);
            else ans.push_back(solve(a[i]));
        }
        return ans;
    }
};",1420008975
jkmp,jkmp,297,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        
        vector<int> idx(n);
        for (int x : targetIndices) {
            idx[x] = 1;
        }
        
        vector<int> dp(m + 1, 1E9);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            for (int j = m - 1; j >= 0; j--) {
                if (source[i] == pattern[j]) {
                    dp[j + 1] = min(dp[j + 1], dp[j] + idx[i]);
                }
            }
        }
        
        for (int i = 0; i <= m; i++) {
            cout << dp[i] << "" \n""[i == m];
        }
        
        return targetIndices.size() - dp[m];
    }
};",1420051058
jkmp,jkmp,297,3604,cpp,"using i64 = long long;

const int M = 1E9 + 7;

template<typename T>
T power(T x, i64 y) {
    T res = 1;
    while (y) {
        if (y % 2 == 1) {
            res *= x;
        }
        x *= x;
        y /= 2;
    }
    return res;
}

struct Mint {
    int val;
    Mint() : val(0) {};
    Mint(i64 x) {
        val = x % M;
        if (val < 0) {
            val += M;
        }
    }
    Mint inv() const {
        return power(*this, M - 2);
    }
    Mint& operator += (const Mint& x) {
        val += x.val;
        if (val >= M) {
            val -= M;
        }
        return *this;
    }
    Mint& operator -= (const Mint& x) {
        val -= x.val;
        if (val < 0) {
            val += M;
        }
        return *this;
    }
    Mint& operator *= (const Mint& x) {
        val = 1LL * val * x.val % M;
        return *this;
    }
    Mint& operator /= (const Mint& x) {
        return *this *= x.inv();
    }
    friend Mint operator + (const Mint& x, const Mint& y) {
        Mint z = x;
        z += y;
        return z;
    }
    friend Mint operator - (const Mint& x, const Mint& y) {
        Mint z = x;
        z -= y;
        return z;
    }
    friend Mint operator * (const Mint& x, const Mint& y) {
        Mint z = x;
        z *= y;
        return z;
    }
    friend Mint operator / (const Mint& x, const Mint& y) {
        Mint z = x;
        z /= y;
        return z;
    }
    friend istream& operator >> (istream& is, Mint& x) {
        long long y;
        is >> y;
        x = Mint(y);
        return is;
    }
    friend ostream& operator << (ostream& os, const Mint& x) {
        return os << x.val;
    }
};

int m = 0;
vector<Mint> _fact(1, 1);
vector<Mint> _invFact(1, 1);

void init(int n) {
    if (n > m) {
        _fact.resize(n + 1);
        _invFact.resize(n + 1);
        for (int i = m + 1; i <= n; i++) {
            _fact[i] = _fact[i - 1] * i;
        }
        _invFact[n] = _fact[n].inv();
        for (int i = n - 1; i > m; i--) {
            _invFact[i] = _invFact[i + 1] * (i + 1);
        }
        m = n;
    }
}

Mint fact(int n) {
    if (n > m) {
        init(n);
    }
    return _fact[n];
}

Mint invFact(int n) {
    if (n > m) {
        init(n);
    }
    return _invFact[n];
}

Mint choose(int n, int m) {
    if (n < m || m < 0) {
        return 0;
    }
    return fact(n) * invFact(m) * invFact(n - m);
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        Mint ans = 0;
        for (int i = 1; i <= min(n, x); i++) {
            Mint cur = 0;
            for (int j = 0; j <= i; j++) {
                cur += (j % 2 == 0 ? 1 : -1) * choose(x, i) * choose(i, j) * power(Mint(i - j), n);
            }
            ans += cur * power(Mint(y), i);
        }
        return ans.val;
    }
};",1420111294
jkmp,jkmp,297,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int j = 0;
            while (nums[i] >> j & 1) {
                j++;
            }
            if (j == 0) {
                ans[i] = -1;
                continue;
            }
            ans[i] = nums[i] ^ (1 << (j - 1));
        }
        return ans;
    }
};",1419999879
jkmp,jkmp,297,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int j = 0;
            while (nums[i] >> j & 1) {
                j++;
            }
            if (j == 0) {
                ans[i] = -1;
                continue;
            }
            ans[i] = nums[i] ^ (1 << (j - 1));
        }
        return ans;
    }
};",1419999596
Wen-Chieh Tung,WJTung,298,3487,cpp,"class Solution {
 public:
  int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    unordered_set<int> T(targetIndices.begin(), targetIndices.end());
    vector<int> max_match = {0}; // max_match[i] = max match length when i operations are done
    for (int i = 0; i < source.length(); ++i) {
      vector<int> next(max_match.size());
      // don't remove current
      for (int j = 0; j < max_match.size(); ++j) {
        if (max_match[j] < pattern.length() && source[i] == pattern[max_match[j]]) {
          next[j] = max_match[j] + 1;
        } else {
          next[j] = max_match[j];
        }
      }
      if (T.contains(i)) {
        // remove current
        next.push_back(-1);
        for (int j = 0; j < max_match.size(); ++j) {
          next[j + 1] = max(max_match[j], next[j + 1]);
        }
      }
      max_match = move(next);
    }
    for (int i = max_match.size() - 1; i >= 0; --i) {
      if (max_match[i] == pattern.length()) {
        return i;
      }
    }
    return -1;
  }
};",1420053472
Wen-Chieh Tung,WJTung,298,3604,cpp,"class Solution {
 public:
  const long long MAX_N = 1000;
  const long long MOD = 1E9 + 7;

  vector<long long> factorial;
  vector<long long> inverse_factorial;

  // find the modular inverse using extended Euclidean algorithm
  long long modinv(long long a) {
    long long b = MOD, u = 1, v = 0;
    while (b) {
      long long q = a / b;
      a -= q * b;
      swap(a, b);
      u -= q * v;
      swap(u, v);
    }
    u %= MOD;
    if (u < 0) {
      u += MOD;
    }
    return u;
  }

  void build() {
    factorial.resize(MAX_N + 1);
    inverse_factorial.resize(MAX_N + 1);

    factorial[0] = 1;
    for (int i = 1; i <= MAX_N; i++) {
      factorial[i] = (factorial[i - 1] * i) % MOD;
    }

    inverse_factorial[0] = 1;
    for (int i = 1; i <= MAX_N; i++) {
      inverse_factorial[i] = (inverse_factorial[i - 1] * modinv(i)) % MOD;
    }
  }

  long long binomial_coefficient(int n, int k) {
    if (n < k) {
      return 0;
    }
    return (factorial[n] * ((inverse_factorial[k] * inverse_factorial[n - k]) % MOD)) % MOD;
  }

  int numberOfWays(int n, int x, int y) {
    build();

    vector<long long> count(x + 1); // count[i]: number of ways to assign performers to i stages without any stages being empty
    count[1] = 1;
    for (int s = 2; s <= x; ++s) {
      // power = s ^ n
      long long power = 1;
      for (int p = 1; p <= n; ++p) {
        power = power * s % MOD;
      }
      count[s] = power;
      for (int j = 1; j < s; ++j) {
        count[s] = (count[s] - (count[j] * binomial_coefficient(s, j) % MOD) + MOD) % MOD;
      }
    }
    long long ans = 0;
    long long power = y;
    for (int s = 1; s <= x; ++s) {
      ans = (ans + (count[s] * binomial_coefficient(x, s) % MOD) * power) % MOD;
      power = power * y % MOD;
    }
    return ans;
  }
};",1420117743
Wen-Chieh Tung,WJTung,298,3605,cpp,"class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans;
    for (int num : nums) {
      bool found = false;
      for (int i = 0; i < num; ++i) {
        if ((i | (i + 1)) == num) {
          ans.push_back(i);
          found = true;
          break;
        }
      }
      if (!found) {
        ans.push_back(-1);
      }
    }
    return ans;
  }
};",1419995654
Wen-Chieh Tung,WJTung,298,3611,cpp,"class Solution {
 public:
  vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans;
    for (int num : nums) {
      if (num % 2 == 0) {
        ans.push_back(-1);
        continue;
      }
      // consecutive 1 in suffix
      int sum = 0;
      int cur = num;
      while (cur % 2 == 1) {
        sum *= 2;
        sum += 1;
        cur /= 2;
      }
      ans.push_back(num - sum + (sum / 2));
    }
    return ans;
  }
};",1420009533
tomarin,tomarint,299,3487,rust,"impl Solution {
    pub fn max_removals(source: String, pattern: String, target_indices: Vec<i32>) -> i32 {
        let source = source.as_bytes();
        let pattern = pattern.as_bytes();
        let slen = source.len();
        let plen = pattern.len();
        let mut dp = vec![vec![-1; plen + 1]; slen + 1];
        let mut available = vec![false; source.len()];
        for i in target_indices {
            available[i as usize] = true;
        }
        for i in 0..=slen {
            for j in 0..=plen {
                if i == 0 && j == 0 {
                    dp[i][j] = 0;
                    continue;
                }
                if i > 0 {
                    if dp[i - 1][j] != -1 {
                        dp[i][j] = dp[i][j].max(dp[i - 1][j]);
                    }
                }
                if i > 0 && available[i - 1] {
                    if dp[i - 1][j] != -1 {
                        dp[i][j] = dp[i][j].max(dp[i - 1][j] + 1);
                    }
                }
                if i > 0 && j > 0 && source[i - 1] == pattern[j - 1] {
                    if dp[i - 1][j - 1] != -1 {
                        dp[i][j] = dp[i][j].max(dp[i - 1][j - 1]);
                    }
                }
            }
            // println!(""i={}: {:?}"", i, dp[i]);
        }
        dp[slen][plen]
    }
}",1420082145
tomarin,tomarint,299,3604,rust,"const MOD: i64 = 1_000_000_007; // 10**9 + 7

#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Mint {
    val: i64,
}

impl Mint {
    pub fn new(n: i64) -> Self {
        let mut new_val = n % MOD + MOD;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }

    pub fn pow(&self, n: i64) -> Self {
        if n == 0 {
            Self { val: 1 }
        } else {
            let mut ret = self.pow(n >> 1);
            ret *= ret;
            if (n & 1) != 0 {
                ret *= *self;
            }
            ret
        }
    }

    pub fn inv(&self) -> Self {
        self.pow(MOD - 2)
    }
}

impl std::fmt::Display for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::fmt::Debug for Mint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, ""{}"", self.val)
    }
}

impl std::ops::Add for Mint {
    type Output = Self;
    fn add(self, other: Self) -> Self::Output {
        let mut new_val = self.val + other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Sub for Mint {
    type Output = Self;
    fn sub(self, other: Self) -> Self::Output {
        let mut new_val = self.val + MOD - other.val;
        if new_val >= MOD {
            new_val -= MOD;
        }
        Self { val: new_val }
    }
}

impl std::ops::Mul for Mint {
    type Output = Self;
    fn mul(self, other: Self) -> Self::Output {
        Self {
            val: (self.val * other.val) % MOD,
        }
    }
}

impl std::ops::Div for Mint {
    type Output = Self;
    fn div(self, other: Self) -> Self::Output {
        if other.val == 0 {
            panic!(""0 division occured."");
        }
        self * other.inv()
    }
}

impl std::ops::AddAssign for Mint {
    fn add_assign(&mut self, other: Self) {
        *self = *self + other;
    }
}

impl std::ops::SubAssign for Mint {
    fn sub_assign(&mut self, other: Self) {
        *self = *self - other;
    }
}

impl std::ops::MulAssign for Mint {
    fn mul_assign(&mut self, other: Self) {
        *self = *self * other;
    }
}

impl std::ops::DivAssign for Mint {
    fn div_assign(&mut self, other: Self) {
        *self = *self / other;
    }
}

impl Solution {
    pub fn number_of_ways(n: i32, x: i32, y: i32) -> i32 {
        let n = n as usize;
        let x = x as usize;
        let y = y as i64;
        let mut dp = vec![vec![Mint::new(0); x + 1]; n + 1];
        dp[0][0] = Mint::new(1);
        for i in 1..=n {
            for stage in 1..=x {
                // 
                dp[i][stage] = dp[i][stage] + dp[i - 1][stage - 1] * Mint::new(y) * Mint::new(x as i64 - stage as i64 + 1);
                // 
                dp[i][stage] = dp[i][stage] + dp[i - 1][stage] * Mint::new(stage as i64);
            }
        }
        let mut ans = Mint::new(0);
        for i in 0..=x {
            ans += dp[n][i];
        }
        ans.val as i32
    }
}",1420117837
tomarin,tomarint,299,3605,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let mut ans = vec![-1; n];
        for i in 0..n {
            if nums[i] & 1 == 1 {
                // 1
                let mut b = 1;
                while nums[i] & (b<<1) != 0 {
                    b <<= 1;
                }
                ans[i] = (nums[i] & (!b));
            }
        }
        ans
    }
}",1420012489
tomarin,tomarint,299,3611,rust,"impl Solution {
    pub fn min_bitwise_array(nums: Vec<i32>) -> Vec<i32> {
        let n = nums.len();
        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<i64>>();
        let mut ans = vec![-1; n];
        for i in 0..n {
            if nums[i] & 1 == 1 {
                // 1
                let mut b = 1;
                while nums[i] & (b<<1) != 0 {
                    b <<= 1;
                }
                ans[i] = (nums[i] & (!b)) as i32;
            }
        }
        ans
    }
}",1420015925
Ritikesh,ritikesh1999,300,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& ind) {
        int n = s.size();
        int m = t.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, 1e9));
        vector<int> vis(n, 0);
        
        for (auto &z : ind) {
            vis[z] = 1;
        }
        
        for (int i = 0 ; i <= n ; i++) {
            dp[i][0] = 0;
        }
        
        // dp[i][j] = min possible addition of char at position i (if they are present in ind arr) 
        // such that t is subsequence of s
        
        for (int i = 1 ; i <= n ; i++) {
            for (int j = 1 ; j <= m ; j++) {
                // don't use the ith char
                dp[i][j] = dp[i-1][j];
                
                if (s[i-1] == t[j-1]) {
                    // use the ith char
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + vis[i-1]);
                }
            }
        }
        
        return ind.size() - dp[n][m];
        
    }
};",1420078279
Ritikesh,ritikesh1999,300,3604,cpp,"class Solution {
    const int MOD = 1e9 + 7;


    long long modPow(long long base, long long exp, int mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
    
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));
    
        dp[0][0] = 1;

        for (int i = 1; i <= n; ++i) {      
            for (int k = 1; k <= x; ++k) {   
                dp[i][k] = (dp[i - 1][k] * k + dp[i - 1][k - 1] * (x - k + 1)) % MOD;
            }
        }

        long long totalWays = 0;


        for (int k = 1; k <= x; ++k) {

            long long scoreWays = modPow(y, k, MOD);

            totalWays = (totalWays + dp[n][k] * scoreWays) % MOD;
        }

        return totalWays;
    }
};",1420118069
Ritikesh,ritikesh1999,300,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0 ; i < n ; i++) {
            for (int k = 0 ; k <= 2000 ; k++) {
                if ((k | (k + 1)) == nums[i]) {
                    ans[i] = k;
                    break;
                }
            }
        }
        return ans;
    }
};",1419996179
Ritikesh,ritikesh1999,300,3611,cpp,"class Solution {
    vector<int> getBin(int num) {
        vector<int> bin(32, 0);
        
        for (int i = 0 ; i < 32 ; i++) {
            if (num & (1 << i)) {
                bin[i] = 1;
            }
        }
        
        return bin;
    }
    
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0 ; i < n ; i++) {
            if (nums[i] == 2) continue;
            
            vector<int> bin = getBin(nums[i]);
            
            int ind;
            for (ind = 0 ; ind < 32 ; ind++) {
                if (bin[ind] == 0) {
                    break;
                }
            }
            
            if (ind == 0) {
                ans[i] = nums[i] - 1;
            }
            else {
                int num = 0;
                for (int i = ind ; i < 32 ; i++) {
                    if (bin[i]) {
                        num += (1 << i);
                    }
                }
                
                for (int i = 0 ; i < ind-1; i++) {
                    num += (1 << i);
                }
                ans[i] = num;
            }
        }
        return ans;
    }
};",1420021145
Shicheng Chen,c337134154,301,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
     int n = source.length();
    int m = pattern.length();


    vector<bool> is_target(n, false);
    for (const int &idx : targetIndices) {
        if (idx >= 0 && idx < n) { 
            is_target[idx] = true;
        }
    }


    vector<int> prev(n + 1, INT32_MAX);
    vector<int> curr(n + 1, INT32_MAX);

    for (int j = 0; j <= n; ++j) {
        prev[j] = 0;
    }

    for (int i = 1; i <= m; ++i) {
        curr[0] = INT32_MAX;
        for (int j = 1; j <= n; ++j) {
            if (pattern[i - 1] == source[j - 1]) {
                int remove_cost = is_target[j - 1] ? 1 : 0;
                if (prev[j - 1] != INT32_MAX) {
                    curr[j] = min(curr[j - 1], prev[j - 1] + remove_cost);
                } else {
                    curr[j] = curr[j - 1];
                }
            } else {
                curr[j] = curr[j - 1];
            }
        }
        prev.swap(curr);
    }

    int min_used = prev[n];
    if (min_used == INT32_MAX) {
        return 0;
    }
    return targetIndices.size() - min_used;
}
};",1420081814
Shicheng Chen,c337134154,301,3604,cpp,"using namespace std;

typedef long long ll;
const int MOD = 1000000007;
class Solution {
public:
ll power_mod(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while(b > 0){
        if(b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

vector<vector<ll>> get_S(int n, int k){
    vector<vector<ll>> S(n+1, vector<ll>(k+1, 0));
    S[0][0] = 1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=min(i, k);j++){
            S[i][j] = (S[i-1][j-1] + j * S[i-1][j]) % MOD;
        }
    }
    return S;
}

vector<vector<ll>> get_C(int max_n){
    vector<vector<ll>> C(max_n+1, vector<ll>(max_n+1, 0));
    C[0][0] = 1;
    for(int n=1;n<=max_n;n++){
        C[n][0] = 1;
        C[n][n] = 1;
        for(int k=1;k<n;k++){
            C[n][k] = (C[n-1][k-1] + C[n-1][k]) % MOD;
        }
    }
    return C;
}

vector<ll> get_F(int max_n){
    vector<ll> fact(max_n+1, 1);
    for(int i=1;i<=max_n;i++) fact[i] = fact[i-1] * i % MOD;
    return fact;
}

    int numberOfWays(int n, int x, int y) {
            int max_nx = max(n, x);
    vector<vector<ll>> S = get_S(n, min(n, x));
    vector<vector<ll>> C = get_C(max_nx);
    vector<ll> fact = get_F(max_nx);
    ll result = 0;
    for(int k=1; k<=min(n, x); k++){
        ll c = C[x][k];
        ll k_fact = fact[k];
        ll S_nk = S[n][k];
        ll y_pow_k = power_mod(y, k);
        ll term = c * k_fact % MOD;
        term = term * S_nk % MOD;
        term = term * y_pow_k % MOD;
        result = (result + term) % MOD;
    }
    return result;
    }
};",1420105235
Shicheng Chen,c337134154,301,3605,python3,"class Solution:
    def minBitwiseArray(self, arr: List[int]) -> List[int]:
            ans = []
            for target in arr:
                succ = False
                for src in range(target):
                    if (src | (src + 1)) == target:
                        ans.append(src)
                        succ = True
                        break 
                if not succ:
                    ans.append(-1)
            return ans",1420003088
Shicheng Chen,c337134154,301,3611,python3,"class Solution:
    def minBitwiseArray(self, arr: List[int]) -> List[int]:
        ans = []
        for target in arr:
            succ = False
            for src in range(max(0,target//2-10000),
                            min(target//2+10000,target)):
                if (src | (src + 1)) == target:
                    ans.append(src)
                    succ = True
                    break
            if succ:continue
            for src in range(max(0,target-10000),target):
                if (src | (src + 1)) == target:
                    ans.append(src)
                    succ = True
                    break

            if not succ:
                ans.append(-1)
        return ans",1420035924
siuu_7,siuu_7,302,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& idx) {
        int n = s.size(), m = t.size(), k = idx.size();
        vector <int> dp(m+1, 1e9); dp[0] = 0;
        vector <bool> vis(n, 0);
        for(auto i : idx) vis[i] = 1;
        for(int i = 0; i<n; i++){
            for(int j = m; j>0; j--){
                if(s[i] == t[j-1]){
                    dp[j] = min(dp[j], dp[j-1] + vis[i]);
                }
            }
        }
        if(dp[m] < 1e9) return k - dp[m];
        else return k;
    }
};",1420054980
siuu_7,siuu_7,302,3604,cpp,"#define ll long long
class Solution {
public:
    int numberOfWays(int nn, int xx, int yy) {
        ll n = 1ll * nn, x = 1ll * xx, y = 1ll * yy;
        const ll mod = 1e9 + 7;
        vector <vector<ll>> dp(x+1, vector<ll>(x+1, 0)), dp2(n+1, vector<ll>(x+1, 0)); dp[0][0] = 1; dp2[0][0] = 1;
        vector <ll> fact(x+1), cnt(x+1); fact[0] = 1; cnt[0] = 1;
        for(ll i = 1; i<=x; i++){
            dp[i][0] = 1; cnt[i] = (cnt[i-1] * y) % mod; fact[i] = (i * fact[i-1]) % mod;
            for(ll j = 1; j<=i; j++) dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % mod;
        }
        for(ll i = 1; i<=n; i++){
            for(ll j = 1; j<=x; j++) dp2[i][j] = (dp2[i-1][j-1] + (j * dp2[i-1][j]) % mod) % mod;
        }
        ll ans = 0;
        for(ll i = 1; i<=x; i++){
            int temp = (dp[x][i] * dp2[n][i]) % mod;
            temp = (temp * fact[i]) % mod;
            temp = (temp * cnt[i]) % mod;
            ans = (ans + temp) % mod;
        }
        return ans%mod;
    }
};",1420105256
siuu_7,siuu_7,302,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = v.size(); vector <int> ans(n, INT_MAX);
        for(int i = 0; i<n; i++){
            for(int j = 0; j < 30; j++){
                int x = v[i] - (int)pow(2, j);
                if((x | (x + 1)) == v[i]){
                    ans[i] = min(ans[i], v[i] - (int)pow(2, j));
                }
            }
        }
        for(auto &i : ans) if(i == INT_MAX) i = -1;
        return ans;
    }
};",1420030514
siuu_7,siuu_7,302,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = v.size(); vector <int> ans(n, INT_MAX);
        for(int i = 0; i<n; i++){
            for(int j = 0; j < 30; j++){
                int x = v[i] - (int)pow(2, j);
                if((x | (x + 1)) == v[i]){
                    ans[i] = min(ans[i], v[i] - (int)pow(2, j));
                }
            }
        }
        for(auto &i : ans) if(i == INT_MAX) i = -1;
        return ans;
    }
};",1420030010
venkat_pasapuleti,venkat_pasapuleti,303,3487,cpp,"#include <vector>
#include <string>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        int dum=0;
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
            dum++;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        for(int k=0;k<50;k++)
        {
            k++;
        }
        dum+=10;
        cout << dum << "" "" << endl;
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420071870
venkat_pasapuleti,venkat_pasapuleti,303,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        int temp1=0,temp2=0,temp3=0;
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                temp1++;
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
            cout << temp1 << "" "";
        }
        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            temp2++;
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        cout << temp2 << endl;
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            temp3++;
            cout << temp3 << "" "";
            for(int dum=0;dum<50;dum++)
            {
                dum+=2;
                cout << dum << endl;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105593
venkat_pasapuleti,venkat_pasapuleti,303,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        vector<int> res(nums.size(), -1);
        for(int i=0;i<nums.size();i++)
        {
            for(int x=0;x<=nums[i];x++)
            {
                if((x|(x+1))==nums[i]){
                    res[i]=x;
                    break;
                }
            }
        }
        return res;
    }
};",1420009788
venkat_pasapuleti,venkat_pasapuleti,303,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            for(int dum=0;dum<20;dum++)
            {
                dum++;
            }
            
            ans[i]=found?minimalAns:-1;
        }
        for(int i=0;i<50;i++){
            i++;
        }
        return ans;
    }
};
",1420047293
viking72,viking72,304,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int num = source.size();
        int mum = pattern.size();
        
        vector<int> dynamic(mum + 1, std::numeric_limits<int>::max());
        dynamic[0] = 0;
        

        vector<bool> isTarget(num, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        for(int i=0;i<num;i++){
            i++;
        }

        for (int i = 0; i < num; ++i) {
            for (int j = mum; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dynamic[j - 1] != std::numeric_limits<int>::max()) {
                    dynamic[j] = std::min(dynamic[j], dynamic[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dynamic[mum] == std::numeric_limits<int>::max() ? 0 : dynamic[mum]);

}
};",1420105121
viking72,viking72,304,3604,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int check=x;
        std::vector<std::vector<int>> Cot(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= check; i++) {
            Cot[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                Cot[i][j] = (Cot[i - 1][j - 1] + Cot[i - 1][j]) % MOD;
            }
        }
        int start=0;
        for(int i=0;i<100;i++ ){
            if(i==2)i+=100;break;
        }

        // Initialize the Stirling numbers of the second kind (S) array
        std::vector<std::vector<int>> S(n + 1, std::vector<int>(check + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= check; ++j) {
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        for(int i=100;i>=0;i--){
            if(i==100)break;
        }

        // Factorial array
        std::vector<int> fact(check + 1, 1);
        for (int i = 1; i <= check; ++i) {
            fact[i] = 1LL * fact[i - 1] * i % MOD;
        }

        int result = 0;
        // Main computation loop
        for (int k = 1; k <= check; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            result = (result + 1LL * Cot[check][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
}
};",1420112175
viking72,viking72,304,3605,cpp,"class Solution {
public:
    int func(int num){
        for(int i=0;i<1000;i++){
            if((i | (i+1))==num){
                return i;
            }
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>answer;
        int number=nums.size();
        for(int i=0;i<number;i++){
            int numb=nums[i];
            
            answer.push_back(func(numb+1-1));
        }
        for(int i=0;i<number;i++){
            i++;
        }
        returnanswer;
}
};",1420017193
viking72,viking72,304,3611,cpp,"class Solution {
public:

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]%2==0){
                ans.push_back(-1);
            }
            else{
                string s="""";
                int a= nums[i];
                while(a>0){
                    s+=(a%2+'0');a/=2;
                }
                reverse(s.begin(),s.end());
                int chk=0;
                for(int i=s.length()-1;i>=0;i--){
                    if(s[i]=='0'){
                        chk++;
                        s[i+1]='0';break;
                    }
                }
                
                if(chk==0){
                    s[0]='0';
                }
                
                int res=stoi(s,nullptr,2);
                ans.push_back(res);
                // cout<<s<<endl;  
            }
        }
        
        return ans;
    }
};",1420035706
Gavnish kumar,gavnish_kumar,305,3487,cpp,"class Solution {
public:
int solveTabulation(string ss,string pp,unordered_map<int,bool>&mp){
    int n = ss.size();
        int m = pp.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 1e7));
        
    
        for (int i = 0; i <= n; i++) {
            dp[i][m] = 0;
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (ss[i] == pp[j] && mp[i]) {
                   
                    int a = dp[i + 1][j];   
                    int b = 1 + dp[i + 1][j + 1]; 
                    dp[i][j] = min(a, b);
                } else if (ss[i] != pp[j]) {
                    dp[i][j] = dp[i + 1][j];
                } else {
                    dp[i][j] = dp[i + 1][j + 1];
                }
            }
        }
        return dp[0][0];

}
    int maxRemovals(string s, string p, vector<int>& t) {
        unordered_map<int, bool> mp;
        for (auto it : t) {
            mp[it] = true;
        }
        
        
        int minval = solveTabulation(s,p,mp);
        return t.size() - minval;
    }
};
",1420066543
Gavnish kumar,gavnish_kumar,305,3604,cpp,"const int MOD = 1e9 + 7;
#define ll long long int
class Solution {
public:
    // Function to compute power with modulo
    ll powFunc(ll k, ll a) {
        ll p = 1;
        for (ll i = 0; i < k; i++) {
            p = (p * a) % MOD;
        }
        return p;
    }

    // Function to compute factorial modulo
    ll factorial(ll n) {
        ll fact = 1;
        for (ll i = 1; i <= n; i++) {
            fact = (fact * i) % MOD;
        }
        return fact;
    }

    int numberOfWays(int n, int x, int y) {
        vector<ll> prevComb(x + 1, 0), currComb(x + 1, 0);
        prevComb[0] = 1;
        for (ll i = 1; i <= x; i++) {
            currComb[0] = 1;
            for (ll j = 1; j <= i; j++) {
                currComb[j] = (prevComb[j - 1] + prevComb[j]) % MOD;
            }
            prevComb = currComb;
        }

        vector<ll> prevStirling(x + 1, 0), currStirling(x + 1, 0);
        prevStirling[0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; j++) {
                currStirling[j] = (j * prevStirling[j] + prevStirling[j - 1]) % MOD;
            }
            prevStirling = currStirling;
        }

        ll ans = 0;
        for (ll k = 1; k <= x; k++) {
            ll power = powFunc(k, y);
            ll comb = prevComb[k];
            ll s = currStirling[k];
            ll fact = factorial(k);
            ll term = (comb * s % MOD * fact % MOD * power % MOD) % MOD;
            ans = (ans + term) % MOD;
        }

        return ans;
    }
};",1420112402
Gavnish kumar,gavnish_kumar,305,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        vector<int> ans;
        for(auto &it: arr){
            if(it== 2){
                ans.push_back(-1);
                
            }
            else{
                 int j = 0;
                for(j; j<32; j++){
                    int x= 1<<j;
                    if(it & x) continue;
                    else break;
            }
            int a=~(1 << (j - 1));
            ans.push_back(it & a);
            }
           
        }
        return ans;
    }
};",1420070486
Gavnish kumar,gavnish_kumar,305,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        vector<int> ans;
        for(auto &it: arr){
            if(it== 2){
                ans.push_back(-1);
                
            }
            else{
                 int j = 0;
                for(j; j<32; j++){
                    int x= 1<<j;
                    if(it & x) continue;
                    else break;
            }
            int a=~(1 << (j - 1));
            ans.push_back(it & a);
            }
           
        }
        return ans;
    }
};",1420070147
Kinon,Kinon,306,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) { 
        int dp[3030][3030];
        bool target[3030];
        for(int i=0; i<=source.length(); i++){
            for(int j=0; j<=targetIndices.size(); j++){
                dp[i][j] = -1;
            }
        }
        dp[0][0] = 0;
        for(int i=0; i<source.length(); i++){
            target[i] = false;
        }
        for(int j=0; j<targetIndices.size(); j++){
            target[targetIndices[j]] = true;
        }
        /*for(int j=0; j<=targetIndices.size(); j++){
            cout << dp[0][j] << "" "";
        } cout << endl;*/
        for(int i=0; i<source.length(); i++){
            for(int j=0; j<=targetIndices.size(); j++){
                if(dp[i][j] >= 0){
                    dp[i+1][j] = dp[i][j] + (source[i] == pattern[dp[i][j]]);
                }
                if(target[i] && j>0){
                    dp[i+1][j] = max(dp[i+1][j], dp[i][j-1]);
                }
                //cout << dp[i+1][j] << "" "";
            } //cout << endl;
        }
        int ans = 0;
        for(int i=1; i<=targetIndices.size(); i++){
            if(dp[source.length()][i] == pattern.length()){
                ans = i;
            }
        }
        return ans;
    }
};",1420112579
Kinon,Kinon,306,3604,cpp,"class Solution {
public:
    const long long mod = 1e9+7;
    long long pangkat(long long a, long long b){
        a %= mod; b %= mod-1;
        long long ret = 1;
        while(b){
            if(b%2) ret = ret * a % mod;
            a = a*a%mod;
            b /= 2;
        }
        return ret;
    }
    long long inv(long long a){
        return pangkat(a, mod-2);
    }
    
    int numberOfWays(int n, int x, int y) {
        long long choose[1024][1024], ster[1024][1024]; // dari i obj warnain beda j warna
        for(int i=0; i<1024; i++){
            for(int j=0; j<1024; j++){
                ster[i][j] = 0;
            }
        }
        ster[0][0] = 1;
        choose[0][0] = 1;
        for(int i=1; i<1024; i++){
            for(int j=1; j<=i; j++){
                ster[i][j] = (ster[i-1][j] * j + ster[i-1][j-1]) % mod;
            }
            choose[i][0] = 1;
            for(int j=1; j<i; j++){
                choose[i][j] = (choose[i-1][j-1] + choose[i-1][j]) % mod;
            }
            choose[i][i] = 1;
        }
        //cout << ster[3][2] << endl;
        long long fac[1024];
        fac[0] = 1;
        for(int i=1; i<1024; i++){
            fac[i] = fac[i-1] * i % mod;
        }
        long long ans = 0;
        for(int i=1; i<=n; i++){
            ans += choose[x][i] * fac[i] % mod * ster[n][i] % mod * pangkat(y, i);
            ans %= mod;
        }
        return ans;
    }
};",1420100397
Kinon,Kinon,306,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0; i<nums.size(); i++){
            ans.push_back(-1);
            for(int j=1; j<=nums[i]; j*=2){
                if(((nums[i]-j) | (nums[i]-j+1)) == nums[i]){
                    ans[i] = nums[i]-j;
                }
            }
        }
        return ans;
    }
};",1420000448
Kinon,Kinon,306,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0; i<nums.size(); i++){
            ans.push_back(-1);
            for(int j=1; j<=nums[i]; j*=2){
                if(((nums[i]-j) | (nums[i]-j+1)) == nums[i]){
                    ans[i] = nums[i]-j;
                }
            }
        }
        return ans;
    }
};",1419999124
darishkhan,darishkhan,307,3487,cpp,"class Solution {
public:
    int func(string &s, string &t, int i, int j, unordered_map<int, int>&mp, vector<vector<int>> &dp)
    {
        if(i==s.size())
        {
            if(j==t.size()) return 0;
            else return -1e9;
        }
        if(dp[i][j]!=-1) return dp[i][j];
        int ans = -1e9;
        if(mp[i])
        {
            ans = max(ans, func(s, t, i+1, j, mp, dp)+1);
            if(j<t.size() and s[i]==t[j]) ans = max(ans, func(s, t, i+1, j+1, mp, dp));
        }
        else
        {
            if(j<t.size() and s[i]==t[j]) ans = max(ans, func(s, t, i+1, j+1, mp, dp));
            else ans = max(ans, func(s, t, i+1, j, mp, dp));
        }
        return dp[i][j] = ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        unordered_map<int, int> mp;
        for(int i:targetIndices) mp[i]=1;
        int n = source.size(), m = pattern.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));
        int ans = func(source, pattern, 0, 0, mp, dp);
        return ans;
    }
};",1420046196
darishkhan,darishkhan,307,3604,cpp,"#define intt int64_t
class Solution {
public:
    const intt mod = 1000000007;
    intt fac[1001];
    intt stir[1001][1001];

    intt binpow(intt a, intt b, intt m) {
        a %= m;
        intt res = 1;
        while (b > 0) {
            if (b & 1)
                res = res * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return res;
    }

    void doSomething()
    {
        fac[0]=1;
        for(int i=1;i<1001;i++) fac[i]=(i*fac[i-1])%mod;
        stir[0][0]=1;
        for(int i=1;i<=1000;i++) stir[i][1]=1;

        for(int i=1;i<1001;i++)
        {
            for(int j=1;j<=i;j++)
            {
                stir[i][j] = (((j*stir[i-1][j])%mod) + stir[i-1][j-1])%mod;
            }
        }
    }

    intt choose(intt n, intt x)
    {
        intt ans  = fac[n];
        ans *= binpow(fac[x], mod-2, mod);
        ans%=mod;
        ans *= binpow(fac[n-x], mod-2, mod);
        ans%=mod;
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        doSomething();
        intt ans  = 0;
        for(int i=1;i<=x;i++)
        {
            intt curr = ((choose(x, i)%mod) * ((((fac[i]*stir[n][i])%mod) * binpow(y, i, mod))%mod))%mod;
            ans += curr;
            ans%=mod;
        }
        return ans%mod;
    }
};",1420112626
darishkhan,darishkhan,307,3605,cpp,"#define intt int64_t
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> nums2 = nums;
        intt n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++)
        {
            if(nums2[i]==2)
            {
                ans.push_back((int)-1);
                continue;
            }
            intt number = nums2[i];
            for(int j=0;j<32;j++)
            {
                if((number&(1<<j))==0)
                {
                    break;
                }
                else
                {
                    if(j>0)number^=(1<<(j-1));
                    number^=(1<<j);
                }
            }
            ans.push_back((int)number);
        }

        return ans;
    }
};",1420012694
darishkhan,darishkhan,307,3611,cpp,"#define intt int64_t

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> nums2 = nums;
        intt n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++)
        {
            if(nums2[i]==2)
            {
                ans.push_back((int)-1);
                continue;
            }
            intt number = nums2[i];
            for(int j=0;j<32;j++)
            {
                if((number&(1<<j))==0)
                {
                    break;
                }
                else
                {
                    if(j>0)number^=(1<<(j-1));
                    number^=(1<<j);
                }
            }
            ans.push_back((int)number);
        }

        return ans;
    }
};",1420011471
Rohith Ganesh,2100031760_kluniversity,308,3487,java,"class Solution {
    public int maxRemovals(String one, String two, int[] thr) {
        return calcAns(one, two, thr);
    }

    private int calcAns(String one, String two, int[] thr) {
        int ek, dho;
         ek = one.length();
         dho = two.length();
        int[] mainArray = new int[dho + 1];

        for (int i = 0; i <= dho; i++)     mainArray[i] = Integer.MAX_VALUE;
        
        mainArray[0] = 0;

        boolean[] isUseful = new boolean[ek];
        for (int curPosition : thr) {
            isUseful[curPosition] = true;
        }

        for (int i = 0; i < ek; i++) {
            for (int j = dho; j > 0; j--) {
                if (one.charAt(i) == two.charAt(j - 1) && mainArray[j - 1] != Integer.MAX_VALUE) {
                    mainArray[j] = Math.min(mainArray[j], mainArray[j - 1] + (isUseful[i] ? 1 : 0));
                }
            }
        }

        return thr.length - (mainArray[dho] == Integer.MAX_VALUE ? 0 : mainArray[dho]);
    }
}
",1420070102
Rohith Ganesh,2100031760_kluniversity,308,3604,cpp,"#include <vector>

class Solution {
public:
    static const int NARUTO_MOD = 1e9 + 7;

    int numberOfWays(int shonen, int akatsuki, int sage) {
        return calcAnimeWays(shonen, akatsuki, sage);
    }

private:
    int calcAnimeWays(int shonen, int akatsuki, int sage) {
        std::vector<std::vector<int>> narutoComb(akatsuki + 1, std::vector<int>(akatsuki + 1, 0));
        for (int itachi = 0; itachi <= akatsuki; ++itachi) {
            narutoComb[itachi][0] = 1;
            for (int sasuke = 1; sasuke <= itachi; ++sasuke) {
                narutoComb[itachi][sasuke] = (narutoComb[itachi - 1][sasuke - 1] + narutoComb[itachi - 1][sasuke]) % NARUTO_MOD;
            }
        }

        std::vector<std::vector<int>> sakuraStirling(shonen + 1, std::vector<int>(akatsuki + 1, 0));
        sakuraStirling[0][0] = 1;
        for (int luffy = 1; luffy <= shonen; ++luffy) {
            for (int naruto = 1; naruto <= akatsuki; ++naruto) {
                sakuraStirling[luffy][naruto] = (1LL * naruto * sakuraStirling[luffy - 1][naruto] + sakuraStirling[luffy - 1][naruto - 1]) % NARUTO_MOD;
            }
        }

        std::vector<int> gokuFactorial(akatsuki + 1, 1);
        for (int zoro = 1; zoro <= akatsuki; ++zoro) {
            gokuFactorial[zoro] = (1LL * gokuFactorial[zoro - 1] * zoro) % NARUTO_MOD;
        }

        long long totalAnimeWays = 0;
        for (int shikamaru = 1; shikamaru <= akatsuki; ++shikamaru) {
            long long sagePow = 1;
            for (int itachi = 0; itachi < shikamaru; ++itachi) {
                sagePow = (sagePow * sage) % NARUTO_MOD;
            }
            totalAnimeWays = (totalAnimeWays + (1LL * narutoComb[akatsuki][shikamaru] * sakuraStirling[shonen][shikamaru] % NARUTO_MOD * gokuFactorial[shikamaru] % NARUTO_MOD * sagePow % NARUTO_MOD)) % NARUTO_MOD;
        }
        
        return totalAnimeWays;
    }
};
",1420106356
Rohith Ganesh,2100031760_kluniversity,308,3605,java,"import java.util.List;

class Solution {

    static int[] minBitwiseArray(List<Integer> nums)
    {
        int result [] = new int[nums.size()];
        result = calcAns(nums);
        return result;
    }
    public static int[] calcAns(List<Integer> nums) 
    {    
        int n = nums.size(); 
        int[] ans = new int[n]; 

        for (int i = 0; i < n; i++) 
        {
            int num = nums.get(i); 
            boolean check = false;

            for (int j = 0; j < num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j; 
                    check = true;
                    break;
                }
            }
            if (!check)     ans[i] = -1;
        }

        return ans; 
    }
}",1420016449
Rohith Ganesh,2100031760_kluniversity,308,3611,java,"import java.util.List;

class Solution {

    static int[] calcAns(List<Integer> inputList) {
        int n = inputList.size();
        int[] result = new int[n];

        for (int i = 0; i < n; i++) {
            int val = inputList.get(i);
            int mini = Integer.MAX_VALUE;
            boolean check = false;

            for (int ite = 0; ite <= 30; ite++) {
                if (((val >> ite) & 1) == 1) {
                    int curvalue = val & ~(1 << ite);

                    if (curvalue < 0) continue;

                    if ((curvalue | (curvalue + 1)) == val) {
                        if (curvalue < mini) {
                            mini = curvalue;
                            check = true;
                        }
                    }
                }
            }

            result[i] = check ? mini : -1;
        }

        return result; 
    }

    public static int[] minBitwiseArray(List<Integer> nums) {
        return calcAns(nums);
    }
}
",1420059390
Anubhav Gupta,anubhav0910,309,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size(), len = targetIndices.size();
        vector<int> isTarget(n, 0);
        for (int i : targetIndices) isTarget[i] = 1;
        vector<int> prev(m + 1, 1e9), curr(m + 1, 1e9);
        prev[0] = 0; 

        for(int i = 0; i < n; ++i){
            curr[0] = 0; 
            for(int j = 1; j <= m; ++j){
                int not_take = prev[j]; 
                int take = 1e9;
                if(source[i] == pattern[j - 1] && prev[j - 1] != 1e9){
                    take = prev[j - 1] + (isTarget[i] ? 1 : 0);
                }
                curr[j] = min(not_take, take);
            }
            prev = curr; 
        }
        if (prev[m] == 1e9) prev[m] = 0;
        return len - prev[m];
    }
};
",1420076333
Anubhav Gupta,anubhav0910,309,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    
    long long modExponent(long long base, long long exponent, long long mod) {
        long long result = 1;
        while (exponent) {
            if (exponent % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exponent /= 2;
        }
        return result;
    }
    
    int numberOfWays(int n, int x, int y) {
        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = (1LL * factorial[i - 1] * i) % mod;
        }
        
        vector<int> binomialCoeff(x + 1, 0);
        binomialCoeff[0] = 1;
        for (int i = 1; i <= x; i++) {
            for (int j = i; j > 0; --j) {
                binomialCoeff[j] = (binomialCoeff[j - 1] + binomialCoeff[j]) % mod;
            }
        }
        
        vector<int> powerSums(x + 1, 0);
        powerSums[0] = 1;
        for (int i = 1; i <= n; i++) {
            vector<int> newPowerSums(x + 1, 0);
            for (int j = 1; j <= x; j++) {
                newPowerSums[j] = (1LL * j * powerSums[j] + powerSums[j - 1]) % mod;
            }
            powerSums = newPowerSums;
        }
        
        int result = 0;
        for (int k = 1; k <= x; k++) {
            long long currentPower = modExponent(y, k, mod);
            result = (result + 1LL * binomialCoeff[k] * powerSums[k] % mod * factorial[k] % mod * currentPower % mod) % mod;
        }
        
        return result;
    }
};
",1420106426
Anubhav Gupta,anubhav0910,309,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        for(int i = 0; i < n; i++) {
            for (int val = 0; val <= nums[i]; val++) {
                if ((val | (val + 1)) == nums[i]) {
                    ans[i] = val;  
                    break; 
                }
            }
        }
        return ans;
    }
};
",1419995768
Anubhav Gupta,anubhav0910,309,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            int mn = 1e9;
            bool flag = false;
            for (int j = 0; j < 31; j++){
                if (((nums[i] >> j) & 1) == 1){
                    int mask = ~(1 << j);
                    int val = nums[i] & mask;
                    if(val >= 0 && (val | (val + 1)) == nums[i]) {
                        if(val < mn) {
                            flag = true;
                            mn = val;
                        }
                    }
                }
            }
            if(!flag) ans[i] = -1;
            else ans[i] = mn;
        }
        return ans;
    }
};
",1420060913
ham786,ham786,310,3487,cpp,"class Solution {
public:
    void LCS(string &source, string &pattern, vector<int>&dp, vector<bool>&isTarget, int n, int m) {
        for(int i=0;i<n;i++) {
            for (int j=m; j>0; j--) {
                if (source[i]==pattern[j-1] && dp[j-1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j-1] + (isTarget[i]?1:0));
                }
            }
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<int>dp(m+1,INT_MAX);
        dp[0]=0;
        vector<bool>isTarget(n, false);
        
        for(int &i:targetIndices) {
            isTarget[i]=true;
        }
        LCS(source, pattern, dp, isTarget, n, m);
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }

    
};",1420081469
ham786,ham786,310,3604,cpp,"class Solution{
public:
    const int MOD =1e9 + 7;
    int numberOfWays(int n, int x, int y){
        vector<vector<int>> combination(x+1, vector<int>(x+1, 0));
        for (int i=0; i <= x; i++) {
            combination[i][0]=1; 
            for (int j=1; j <= i; j++) {
                combination[i][j]=(combination[i-1][j-1] + combination[i-1][j])%MOD;
            }
        }
        vector<vector<long long>> samSpace(n+1, vector<long long>(x+1, 0));
        samSpace[0][0]=1;
        for (int i=1; i<=n; i++){
            for (int j =1; j <=x; j++){
                samSpace[i][j] =(j * samSpace[i-1][j] + samSpace[i-1][j-1])%MOD;
            }
        }

        vector<long long> fact(x+1, 1);
        for (int i=1; i<=x; i++){
            fact[i]=fact[i-1] * i% MOD;
        }

        long long result=0;
        for (int k=1; k<=x; k++){
            long long power=1;
            for (int p=0; p<k; p++){
                power=(power*y)%MOD;
            }
            long long term1=(combination[x][k]*samSpace[n][k])%MOD;
            long long term2=(term1*fact[k])%MOD;
            long long term3=(term2*power)%MOD;

            result=(result+term3)%MOD;
        }

        return result;
    }
};
",1420106589
ham786,ham786,310,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int num:nums){
            bool check = false;
            for(int x=0; x<=num;x++){
                if((x|(x+1))==num){
                    ans.push_back(x);
                    check=true;
                    break;
                }
            }
            if(!check){
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1419996493
ham786,ham786,310,3611,cpp,"class Solution{
public:
    vector<int> minBitwiseArray(vector<int>& nums){
        vector<int> ans(nums.size());
        for(int i=0;i<nums.size();i++) {
            int num=nums[i];
            int minimalAns=INT_MAX;
            bool found=false;
            
            for(int bit=0;bit<=30;bit++) {
                if(((num>>bit)&1)==1) {
                    int x=num&~(1<<bit);
                    if(x<0) continue;
                    if((x|(x+1))==num) {
                        if(x<minimalAns) {
                            minimalAns=x;
                            found=true;
                        }
                    }
                }
            }
            
            if(found) {
                ans[i]=minimalAns;
            } else {
                ans[i]=-1;
            }
        }
        return ans;
    }
};
",1420041404
l1cache__,l1cache__,311,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
		unordered_set<int> bad(targetIndices.begin(), targetIndices.end());
        vector<int> seq;
		int n = source.size(), m = pattern.size();
		vector<vector<int>> dp(n + 1, vector<int>(m + 1, 1e9));
		// dp[i][j] = min bad indices to make source[0..i] have pattern[0..j]
		for (int i = 0; i <= n; i++) dp[i][0] = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				if (source[i-1] == pattern[j-1]) {
					if (bad.count(i-1)) dp[i][j] = min(dp[i][j], dp[i-1][j-1]+1);
					else dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
				}
				dp[i][j] = min(dp[i][j], dp[i-1][j]);
			}
		}
		return bad.size()-dp[n][m];
    }
};",1420113475
l1cache__,l1cache__,311,3604,cpp,"#define ll long long

#define MOD 1000000007

ll modpow(ll a, ll b) {
	ll res = 1;
	while (b > 0) {
		if (b % 2 == 1) {
			res = (res * a) % MOD;
		}
		a = (a * a) % MOD;
		b /= 2;
	}
	return res;
}

ll C(ll n, ll k) {
	ll res = 1;
	for (ll i = 0; i < k; i++) {
		res = (res * (n - i)) % MOD;
		res = (res * modpow(i + 1, MOD - 2)) % MOD;
	}
	return res;
}

ll fact(ll n) {
	ll res = 1;
	for (ll i = 2; i <= n; i++) {
		res = (res * i) % MOD;
	}
	return res;
}

ll stirling[1001][1001];

auto build = []() {
	stirling[0][0] = 1;
	for (int i = 1; i <= 1000; i++) {
		for (int j = 1; j <= i; j++) {
			stirling[i][j] = (stirling[i-1][j-1] + (j * stirling[i-1][j]) % MOD) % MOD;
		}
	}
	return 0;
}();

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        ll assign = modpow(x, n);
		ll ans = 0;
		for (int i = x; i >= 1; i--) {
			if (n < i) continue;
			// i tables, assign at least 1 person to each table such that all tables are non-empty
			// ll ways = C(x, i) * modpow(i, n-i) % MOD; // assign 1 person to each table first
			// // need to account for ways to assign 1 person per table, which is tables!
			// ways = (ways * fact(i)) % MOD;
			ll ways = C(x, i) * stirling[n][i] % MOD;
			ways = (ways * fact(i)) % MOD;
			ways = (ways * modpow(y, i)) % MOD; // score
			// cout << i << ' ' << ways << endl;
			ans = (ans + ways) % MOD;
		}
		return ans;
    }
};",1420082967
l1cache__,l1cache__,311,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int dp[1001] = {};
        fill(dp, dp+1001, 1e9);
        for (int i = 0; i <= 1000; i++) {
            int x = i|(i+1);
            if (x < 1001) dp[x] = min(dp[x], i);
            if (dp[i] == 1e9) dp[i] = -1;
        }
        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); i++) ans[i] = dp[nums[i]];
        return ans;
    }
};",1420027994
l1cache__,l1cache__,311,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            if (__builtin_popcount(nums[i]+1) == 1) {
                ans[i] = nums[i]/2;
            } else {
				if (nums[i] == 2) {
					ans[i] = -1;
					continue;
				}
				string bin = bitset<32>(nums[i]).to_string();
				int j = bin.size()-1;
				while (j >= 0 && bin[j] == '1') {
					j--;
				}
				bin[j+1] = '0';
				ans[i] = stoi(bin, 0, 2);
            }
        }
        return ans;
    }
};",1420035386
Hsin-Jui Chen,joshuachen0213,312,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        vector<int> isTarget(n, 0);
        for (auto x : targetIndices) {
            isTarget[x] = 1;
        }
        for (int j = 1; j <= m; j++) {
            dp[0][j] = -1;
        }
        for (int i = 1; i <= n; i++) {
            dp[i][0] = dp[i - 1][0] + isTarget[i - 1];
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (dp[i - 1][j] != -1) {
                    dp[i][j] = dp[i - 1][j] + isTarget[i - 1];
                } else {
                    dp[i][j] = -1;
                }
                if (source[i - 1] == pattern[j - 1]) {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
};",1420031485
Hsin-Jui Chen,joshuachen0213,312,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const long long int mod = 1000000007;
        vector<long long int> dp(x, 0);
        vector<long long int> powers(x, 0), combs(min(x, n), 0);
        dp[0] = 1;
        long long int comb, cur, pow;
        for (int i = 1; i < min(x, n); i++) {
            comb = (i + 1);
            cur = 0;
            for (int j = 1; j <= i; j++) {
                cur += comb * dp[j - 1];
                cur %= mod;
                comb *= (i + 1 - j);
                comb %= mod;
                comb *= this->inverse(j + 1);
                comb %= mod;
            }
            pow = 1;
            for (int j = 0; j < n; j++) {
                pow *= (i + 1);
                pow %= mod;
            }
            pow -= cur;
            pow %= mod;
            if (pow < 0) {
                pow += mod;
            }
            dp[i] = pow;
            cout << dp[i] << endl;
        }
        pow = 1;
        cout << ""powers"" << endl;
        for (int i = 0; i < min(x, n); i++) {
            pow *= y;
            pow %= mod;
            powers[i] = pow;
            cout << powers[i] << endl;
        }
        cout << ""comb"" << endl;
        cur = 1;
        for (int i = 0; i < min(x, n); i++) {
            cur *= (x - i);
            cur %= mod;
            cur *= this->inverse(i + 1);
            cur %= mod;
            combs[i] = cur;
            cout << combs[i] << endl;
        }
        long long int ans = 0;
        for (int i = 0; i < min(x, n); i++) {
            cur = (combs[i] * dp[i]) % mod;
            ans += cur * powers[i];
            ans %= mod;
        }
        return (int)ans;
    }
    int inverse(int n) {
        const long long int p = 1000000007;
        long long int u = (long long)n, v = p;
        long long int x1 = 1, x2 = 0;
        long long int q, r, x;
        while (u != 1) {
            q = v / u;
            r = v - q * u;
            x = x2 - q * x1;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
        }
        while (x1 < 0)
            x1 += p;
        return (int)(x1 % p);
    }
};",1420107269
Hsin-Jui Chen,joshuachen0213,312,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x : nums) {
            ans.push_back(this->getAns(x));
        }
        return ans;
    }
    int getAns(int num) {
        if (num % 2 == 0) {
            return -1;
        }
        int ans = 0, n = num;
        while(num > 0) {
            if (num % 2 == 1) {
                ans <<= 1;
                ans += 1;
                num >>= 1;
            } else {
                break;
            }
        }
        return (n - ans) + (ans >> 1);
    }
};",1420002560
Hsin-Jui Chen,joshuachen0213,312,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto x : nums) {
            ans.push_back(this->getAns(x));
        }
        return ans;
    }
    int getAns(int num) {
        if (num % 2 == 0) {
            return -1;
        }
        int ans = 0, n = num;
        while(num > 0) {
            if (num % 2 == 1) {
                ans <<= 1;
                ans += 1;
                num >>= 1;
            } else {
                break;
            }
        }
        return (n - ans) + (ans >> 1);
    }
};",1420006944
Bhavesh Sharma,Binary_Sirius,314,3487,cpp,"class Solution {
public:
    int f(int i, int j, string &s, string &p, set<int>&st,vector<vector<int>>&dp){
        if(i==s.size() || j==p.size()){
            if(i==s.size() && j==p.size())return 0;
            if(j==p.size()){
                int c=0;
                for(int k=i;k<s.size();k++){
                    if(st.find(k)!=st.end())c++;
                }
                return c;
            }
            if(i==s.size())return -1e6;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        int pi=-1e6,np=-1e6;
        np= max(np,f(i+1,j,s,p,st,dp));
        if(st.find(i)!=st.end()){
            np= max(np,f(i+1,j,s,p,st,dp)+1);
        }
        if(s[i]==p[j])pi=max(pi,f(i+1,j+1,s,p,st,dp));
        return dp[i][j]=max(pi,np);
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        set<int> st;
        for(auto i:targetIndices)st.insert(i);
        int n=source.size(),m=pattern.size();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        int ans= f(0,0,source,pattern,st,dp);
        return ans;
    }
};",1420030173
Bhavesh Sharma,Binary_Sirius,314,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll N=1e9+7,M=2005;
    ll powe(ll a, ll n) {

        ll r = 1;
        while (n) {
            if (n % 2) {
                r = ((r % N) * (a % N)) % N;
                n--;
            }
            else {
                a = ((a % N) * (a % N)) % N;
                n = n / 2;
            }
        }
        return r;
    }
    // C++ program to answer queries
    // of nCr in O(1) time.

    // array to store inverse of 1 to N
    ll factorialNumInverse[2005];

    // array to precompute inverse of 1! to N!
    ll naturalNumInverse[2005];

    // array to store factorial of first N numbers
    ll fact[2005];

    // Function to precompute inverse of numbers
    void InverseofNumber(ll N)
    {
        naturalNumInverse[0] = naturalNumInverse[1] = 1;
        for (int i = 2; i < M; i++)
            naturalNumInverse[i] = naturalNumInverse[N % i] * (N - N / i) % N;
    }
    // Function to precompute inverse of factorials
    void InverseofFactorial(ll N)
    {
        factorialNumInverse[0] = factorialNumInverse[1] = 1;

        // precompute inverse of natural numbers
        for (int i = 2; i < M; i++)
            factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % N;
    }
    // Function to calculate factorial of 1 to N
    void factorial(ll N)
    {
        fact[0] = 1;

        // precompute factorials
        for (int i = 1; i < M; i++) {
            fact[i] = (fact[i - 1] * i) % N;
        }
    }

    // Function to return nCr % N in O(1) time
    ll Binomial(ll n, ll r, ll N)
    {
        if (n < r)return 0;
        // n C r = n!*inverse(r!)*inverse((n-r)!)
        ll ans = ((fact[n] * factorialNumInverse[r])
                % N * factorialNumInverse[n - r])
                % N;
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        InverseofNumber(N);
        InverseofFactorial(N);
        factorial(N);
        long long ans=0;
        for(int i=1;i<=min(n,x);i++){
            long long xx= (powe(y,i)*Binomial(x,i,N))%N;
            long y= powe(i,n);
            for(int j=1;j<i;j++){
                long xxx= (Binomial(i,j,N)*powe(i-j,n))%N;
                if(j%2==1)xxx*=-1ll;
                xxx+=N; xxx%=N;
                y+=xxx; y%=N;
            }
            ans= ans +(xx*y)%N; ans%=N;
        }
        return ans;
    }
};",1420120135
Bhavesh Sharma,Binary_Sirius,314,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;i++){
            if(nums[i]==2)ans.push_back(-1);
            else{
                int x=0;
                for(int j=0;j<=30;j++){
                    if((nums[i]&(1<<j))==0)break;
                    else{
                        x=j;
                    }
                }
                int y= nums[i]^(1<<x);
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420008455
Bhavesh Sharma,Binary_Sirius,314,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;i++){
            if(nums[i]==2)ans.push_back(-1);
            else{
                int x=0;
                for(int j=0;j<=30;j++){
                    if((nums[i]&(1<<j))==0)break;
                    else{
                        x=j;
                    }
                }
                int y= nums[i]^(1<<x);
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420006752
Shubham Kumar,Shubham_Kumar_LeetCode,315,3487,cpp,"


class Solution {
    int solve(int i,int j,string &s, string& p, vector<bool> &pres,vector<vector<int>>& dp){
        int n=s.size();
        if(i==n){
            if(j!=p.size())return INT_MIN/10;
            return 0;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        if(pres[i]){
            int hata,matHata;
            hata=1+solve(i+1,j,s,p,pres,dp);
            if(j<p.size() && s[i]==p[j]){
                matHata=solve(i+1,j+1,s,p,pres,dp);
            }
            else matHata=solve(i+1,j,s,p,pres,dp);
            return dp[i][j]=max(hata,matHata);
        }
        else{
            if(j<p.size() && s[i]==p[j])return dp[i][j]= solve(i+1,j+1,s,p,pres,dp);
            else return dp[i][j]= solve(i+1,j,s,p,pres,dp);
        }
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.size();
        vector<bool> pres(n);
        for(auto i:targetIndices)pres[i]=true;
        vector<vector<int>> dp(n,vector<int> (n,-1));
        return solve(0,0,source,pattern,pres,dp);
    }
};",1420039063
Shubham Kumar,Shubham_Kumar_LeetCode,315,3604,cpp,"class Solution
{
    int fact[1001];

    long long nCk(int n, int k)
    {
        if (k > n)
            return 0;
        return (fact[n] * 1ll * expTab((fact[n - k] * 1ll * fact[k]) % M, M - 2, M)) % M;
    }

    long long expTab(long long a, long long b, long long m)
    {
        long long ans = 1;
        while (b)
        {
            if (b & 1)
                ans = (1ll * ans * a) % m;
            a = (a * 1ll * a) % m;
            b >>= 1;
        }
        return ans;
    }

    long long S(int n, int k, vector<vector<long long>> &memo)
    {
        if (k == 0 && n == 0)
            return 1;
        if (k > n || k <= 0)
            return 0;
        if (k == n)
            return 1;
        if (k == 1)
            return 1;

        if (memo[n][k] != -1)
            return memo[n][k];

        memo[n][k] = ((k * 1ll * S(n - 1, k, memo)) % M + S(n - 1, k - 1, memo) % M) % M;
        return memo[n][k];
    }
    const int M = 1e9+7;

public:
    int numberOfWays(int n, int x, int y)
    {
        int ans = 0;
        // vector<int> fact((int)1e3 + 1, 1);
        fact[0] = 1;

        for (int i = 1; i <= 1000; i++){
            fact[i] = (fact[i - 1] * 1ll * i) % M;
            // if(i<10)cout<<fact[i]<<"" "";
        }
        // cout<<endl;
            

        vector<vector<long long>> memo(n + 1, vector<long long>(x + 1, -1));
        for (int i = 1; i <= x; i++)
        {
            // cout<<nCk(x,i)<<endl;
            // cout<<S(n,i,memo)<<endl;
            // cout<<fact[i]<<endl;
            // cout<<expTab(y,i,M)<<endl;
            int curr = (((((nCk(x, i) * 1ll * S(n, i, memo)) % M) * 1ll * fact[i]) % M) * 1ll * (expTab(y, i, M))) % M;
            ans = (ans + curr) % M;
        }
        return ans;
    }
};",1420120149
Shubham Kumar,Shubham_Kumar_LeetCode,315,3605,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num:nums){
            int i;
            for(i=0;i<31;i++)if((num&(1<<i))==0)break;
            if(i==0)ans.push_back(-1);
            else{
                i--;
                num=num&(~(1<<i));
                ans.push_back(num);
            }
        }   
        return ans;
    }
};",1420004637
Shubham Kumar,Shubham_Kumar_LeetCode,315,3611,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto num:nums){
            int i;
            for(i=0;i<31;i++)if((num&(1<<i))==0)break;
            if(i==0)ans.push_back(-1);
            else{
                i--;
                num=num&(~(1<<i));
                ans.push_back(num);
            }
        }   
        return ans;
    }
};",1420006337
iron_spider,iron_spider,317,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        
        vector<int> removalCount = initializeDP(patternLength);
        vector<bool> targetFlags = markTargets(sourceLength, targetIndices);
        
        computeDP(source, pattern, sourceLength, patternLength, removalCount, targetFlags);
        
        return calculateMaxRemovals(removalCount, targetIndices.size());
    }
    
private:
    vector<int> initializeDP(int patternLength) {
        vector<int> dp(patternLength + 1, numeric_limits<int>::max());
        dp[0] = 0;
        return dp;
    }

    vector<bool> markTargets(int sourceLength, const vector<int>& targetIndices) {
        vector<bool> isTarget(sourceLength, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    void computeDP(const string& source, const string& pattern, int sourceLength, int patternLength, vector<int>& dp, const vector<bool>& isTarget) {
        for (int i = 0; i < sourceLength; i++) {
            for (int j = patternLength; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
    }

    int calculateMaxRemovals(const vector<int>& dp, int totalTargets) {
        return totalTargets - (dp[dp.size() - 1] == numeric_limits<int>::max() ? 0 : dp[dp.size() - 1]);
    }
};
",1420073540
iron_spider,iron_spider,317,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, totalItems: int, maxGroups: int, groupSize: int) -> int:
        combination = self.computeCombinations(maxGroups)
        stirling = self.computeStirlingNumbers(totalItems, maxGroups)
        factorial = self.computeFactorials(maxGroups)
        
        totalWays = 0
        for groups in range(1, maxGroups + 1):
            yPower = self.computePower(groupSize, groups)
            totalWays = (totalWays + combination[maxGroups][groups] * stirling[totalItems][groups] % MOD * factorial[groups] % MOD * yPower % MOD) % MOD
        
        return totalWays

    def computeCombinations(self, maxGroups: int) -> List[List[int]]:
        C = [[0] * (maxGroups + 1) for _ in range(maxGroups + 1)]
        for i in range(maxGroups + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
        return C

    def computeStirlingNumbers(self, totalItems: int, maxGroups: int) -> List[List[int]]:
        S = [[0] * (maxGroups + 1) for _ in range(totalItems + 1)]
        S[0][0] = 1
        for i in range(1, totalItems + 1):
            for j in range(1, maxGroups + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
        return S

    def computeFactorials(self, maxGroups: int) -> List[int]:
        fact = [1] * (maxGroups + 1)
        for i in range(1, maxGroups + 1):
            fact[i] = fact[i - 1] * i % MOD
        return fact

    def computePower(self, base: int, exponent: int) -> int:
        result = 1
        for _ in range(exponent):
            result = (result * base) % MOD
        return result
",1420107474
iron_spider,iron_spider,317,3605,cpp,"
class Solution {
public:
    int findMinimumValue(int prime) {
        for (int candidate = 1; candidate <= prime; ++candidate) {
            if ((candidate | (candidate + 1)) == prime) {
                return candidate;
            }
        }
        return -1;
    }

    vector<int> generateAnswerArray(const vector<int>& primes) {
        int size = primes.size();
        vector<int> answerArray(size, -1);

        for (int i = 0; i < size; ++i) {
            answerArray[i] = findMinimumValue(primes[i]);
        }

        return answerArray;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        return generateAnswerArray(nums);
    }
};
",1420005540
iron_spider,iron_spider,317,3611,cpp,"class Solution {
public:
    int convertBinaryStringToInt(const std::string& binaryStr) {
        int result = 0;
        long long powerOfTwo = 1;
        
        for (int i = binaryStr.length() - 1; i >= 0; i--) {
            result += (binaryStr[i] == '1') ? powerOfTwo : 0;
            powerOfTwo *= 2;
        }
        
        return result;
    }
    
    std::string getModifiedBinaryString(int number) {
        std::string binaryStr = std::bitset<33>(number).to_string();
        int index = binaryStr.length() - 1;

        // Change the rightmost '0' to '1'
        while (index >= 0 && binaryStr[index] != '1') {
            binaryStr[index] = '1';
            index--;
        }

        // Change the rightmost '1' to '0'
        while (index >= 0 && binaryStr[index] == '1') {
            index--;
        }
        index++;
        if (index < binaryStr.length()) {
            binaryStr[index] = '0';
        }

        return binaryStr;
    }

    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> result(nums.size(), -1);
        
        for (size_t i = 0; i < nums.size(); i++) {
            if (nums[i] % 2 != 0) {
                std::string modifiedBinaryStr = getModifiedBinaryString(nums[i]);
                int modifiedNumber = convertBinaryStringToInt(modifiedBinaryStr);
                result[i] = std::min(modifiedNumber, nums[i] - 1);
            }
        }
        
        return result;
    }
};
",1420034613
 ,TheFuturoma,318,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        s = set()
        tr = set()
        for el in pattern:
            s.add(el)
        for el in targetIndices:
            tr.add(el)
        res = 0
        for i, el in enumerate(source):
            if el not in s and i in tr:
                res += 1
        dp = [-1] * (len(pattern) + 1)
        
        dp[0] = 0
        for i, el in enumerate(source):
            if el not in s:
                continue
            ndp = [-1] * (len(pattern) + 1)
            for j in range(len(dp)):
                ndp[j] = dp[j]
            if i in tr:
                for j in range(len(dp)):
                    if ndp[j] < 0:
                        continue
                    ndp[j] += 1
            for j in range(len(pattern) - 1, -1, -1):
                c = pattern[j]
                if c != el or dp[j] < 0:
                    continue
                ndp[j + 1] = max(ndp[j + 1], dp[j])
            plus = False
            if i in tr:
                plus = True
                # for j in range(0, len(pattern)):
                #     if pattern[j] == el and dp[j] >= 0:
                #         ndp[j] += 1
            for j in range(len(dp)):
                dp[j] = ndp[j]
        return res + dp[len(pattern)]",1420063581
 ,TheFuturoma,318,3604,cpp,"#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

ll pow_mod(ll a, ll b, ll mod) {
    ll res = 1;
    ll curr_r = a;
    while (b) {
        if (b & 1) {
            res *= curr_r;
            res %= mod;
        }
        curr_r *= curr_r;
        curr_r %= mod;
        b >>= 1;
    }
    return res;
}
int COMB_N = 2 * 1e5 + 1;
vector<ll> fact(COMB_N);
vector<ll> fact_rev(COMB_N);
// ll mod = 998244353;
ll mod = 1e9 + 7;
map<pair<ll, ll>, ll> mem;

ll choose(ll k, ll n) {
    if (k > n) return 0;
    return ((fact[n] * fact_rev[k]) % mod * fact_rev[n - k]) %  mod;
}

class Solution {
public:
    

    // ll linear_choose(ll k, ll n) {
    //     if (k > n) return 0;
    //     ll res = 1;
    //     for (int i = n; i > n - k; i--) res = res * i % mod;
    //     return res * fact_rev[k] % mod;
    // }

    // int CURRENT_TEST = 0;

    // void pa() {
    //     cout << ""Case #"" << CURRENT_TEST << "": "" << endl;
    //     return;
    // }

    ll comb(ll box, ll ball) {
        if (mem.find({box, ball}) != mem.end()) {
            return mem[{box, ball}];
        }
        if (box == 1) {
            return 1;
        }
        ll res = pow_mod(box, ball, mod);
        for (ll new_box = 1; new_box < box; new_box++) {
            ll minus = comb(new_box, ball) * choose(box - new_box, box) % mod;
            res = (res - minus + mod) % mod;
        }
        mem[{box, ball}] = res;
        return res;
    }

    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        fact_rev[0] = 1;
        for (ll i = 1; i < COMB_N; i++) fact[i] = (fact[i - 1] * i) % mod;
        fact_rev[COMB_N - 1] = pow_mod(fact[COMB_N - 1], mod - 2, mod);
        for (ll i = COMB_N - 2; i > 0; i--) fact_rev[i] = (fact_rev[i + 1] * (i + 1)) % mod;

        ll res = 0;
        for (int i = 1; i <= min(n, x); i++) {
            ll box = choose(i, x);
            ll balls = comb(i, n);
            ll curr_sum = box * balls % mod * pow_mod(y, i, mod) % mod;
            res += curr_sum;
            res %= mod;
        }
        return res;
    }
};",1420107872
 ,TheFuturoma,318,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for el in nums:
            res = -1
            for c in range(0, el):
                if (c | (c + 1)) == el:
                    res = c
                    break
            ans.append(res)
        return ans",1419995288
 ,TheFuturoma,318,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for el in nums:
            if el == 2:
                res.append(-1)
                continue
            if ((el + 1) & (el)) == 0:
                res.append(el // 2)
                continue
            pos = -1
            it = 1
            while it < el:
                if el & it:
                    pos = it
                else:
                    if pos >= 0:
                        el -= pos
                        break
                it *= 2
            res.append(el)
        return res
",1420008718
Ying Liu,pein531,319,3487,cpp,"class Solution {
public:
    int maxRemovals(string a, string b, vector<int>& ts) {
        int n=a.length();
        int m=b.length();
        a="" ""+a+""-"";
        b="" ""+b+""+"";
        bool vis[n+2];
        int dp[n+2][m+2];
        memset(vis,0,sizeof(vis));
        memset(dp,-127/2,sizeof(dp));
        for(auto v:ts)  vis[v+1]=true;
        dp[0][0]=0;
        for(int i=0;i<=n;++i)
            for(int j=0;j<=m;++j){
                if(a[i+1]==b[j+1])  dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);
                else    dp[i+1][j]=max(dp[i+1][j],dp[i][j]);
                if(vis[i+1])    dp[i+1][j]=max(dp[i+1][j],dp[i][j]+1);
            }
        return dp[n][m];
    }
};",1420102110
Ying Liu,pein531,319,3604,cpp,"class Solution {
public:
    #define ll long long
    const int P=1e9+7;
    const int N=1005;
    int fac[1005],inv[1005];
    int ksm(int u,int v){
        int res=1;
        while(v){
            if(v&1)	res=(ll)res*u%P;
            v>>=1;	u=(ll)u*u%P;
        }
        return res;
    }
    int C(int n,int m){
        if(n<m||m<0)	return 0;
        return (ll)fac[n]*inv[m]%P*inv[n-m]%P;
    }
    void C_init(int n){
        fac[0]=1;
        for(int i=1;i<=n;++i)	fac[i]=(ll)fac[i-1]*i%P;
        inv[n]=ksm(fac[n],P-2);
        for(int i=n;i>=1;--i)	inv[i-1]=(ll)inv[i]*i%P;
    }
    int numberOfWays(int n, int x, int y) {
        C_init(1000);
        int S[1005][1005];
        memset(S,0,sizeof(S));
        S[0][0]=1;
        for(int i=1;i<=1000;++i)
            for(int j=1;j<=i;++j){
                S[i][j]=(S[i-1][j-1]+(ll)j*S[i-1][j]%P)%P;
            }
        int ans=0;
        for(int i=1;i<=x;++i){
            int res=(ll)S[n][i]*C(x,i)%P*fac[i]%P*ksm(y,i)%P;
            ans=(ans+res)%P;
        }
        return ans;
    }
};",1420087293
Ying Liu,pein531,319,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++) {
            for(int num = 1; num <= 2000; num++) {
                if((num | (num + 1)) == nums[i]) {
                    ans[i] = num;
                    break;
                }
            }
        }
        return ans;
    }
};",1420012141
Ying Liu,pein531,319,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int >ans;    ans.clear();
        
        for(auto v:nums){
            if(v==2){
                ans.push_back(-1);
                continue;
            }
            int p=0;
            while(v>>p&1)   p++;
            if((v>>p)%2)    ans.push_back(-1);
            else{
                int x=v>>(p+1)<<(p+1);
                int y=0;
                if(p>=1)    y=((1<<(p-1))-1);
                ans.push_back(x+y);
            }
        }
        return ans;
    }
};",1420080072
BZH110,BZH110,320,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        unordered_set<int> s(targetIndices.begin(), targetIndices.end());
        int n = source.size(), m = pattern.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));
        dp[0][0] = 0;
        for(int i=1;i<=n;i++){
            dp[i][0] = dp[i-1][0];
            if(s.count(i - 1))
                dp[i][0]++;
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(source[i] == pattern[j] && dp[i][j] >= 0){
                    dp[i + 1][j + 1] = dp[i][j];
                }
                if(source[i] == pattern[j] && dp[i][j] >= 0){
                    dp[i + 1][j + 1] = dp[i][j];
                }
                if(dp[i][j + 1] >= 0)
                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j + 1] + (int)s.count(i));
                // cout << i << "" "" << j << "" "" << dp[i + 1][j + 1] << endl;
            }
        }
        return dp[n][m];
    }
};",1420079196
BZH110,BZH110,320,3604,cpp,"class Solution {
public:
    using ll = long long;
    ll C(int n, int m, int mod = INT_MAX) { // choose m from n
        if(n < m)
            return 0;
        if(2 * m > n)
            return C(n, n-m, mod);
        ll ans = 1, ans2 = 1;
        for(int i=n;i>n-m;i--)
            ans = (ans * (i % mod)) % mod;
        for(int i=1;i<=m;i++)
            ans2 = (ans2 * (i % mod)) % mod;
        return (ans * mypow(ans2, mod-2, mod)) % mod;
    }
    long long mypow(long long a, long long b, long long mod = LLONG_MAX) {
        a %= mod;
        if (b == 0)
            return 1;
        if (b == 1)
            return a;
        if (b % 2 == 0)
            return mypow((a * a) % mod, b / 2, mod);
        return (a * mypow((a * a) % mod, b / 2, mod)) % mod;
    }
    ll A(int n, int m, int mod = INT_MAX) {
        ll ans = 1;
        for(int i=n;i>n-m;i--)
            ans = (ans * (i % mod)) % mod;
        return ans;
    }
    int numberOfWays(int n, int x, int y) {
        ll mod = 1e9 + 7, ans = 0, pre = 0;
        vector<vector<ll>> dp(n + 1, vector<ll>(x + 1, 0));
        dp[0][0] = 1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=min(i, x);j++){
                dp[i][j] = ((dp[i-1][j] * j) % mod + dp[i-1][j-1]) % mod;
                // cout << i << "" "" << j << "" "" << dp[i][j] << endl;
            }
        }
        if(x >= n)
            dp[n][n] = 1;
        for(int i=1;i<=min(n, x);i++){
            ans += (C(x, i, mod) * dp[n][i]) % mod * A(i, i, mod) % mod * mypow(y, i, mod) % mod;
            ans %= mod;
        }
        return ans;
    }
};",1420056211
BZH110,BZH110,320,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0;i<n;i++){
            if(nums[i] == 2){
                continue;
            }
            int t = 0;
            while(nums[i] & (1 << t))
                t++;
            t--;
            ans[i] = nums[i] - (1 << t);
        }
        return ans;
    }
};",1420088671
BZH110,BZH110,320,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0;i<n;i++){
            if(nums[i] == 2){
                continue;
            }
            int t = 0;
            while(nums[i] & (1 << t))
                t++;
            t--;
            ans[i] = nums[i] - (1 << t);
        }
        return ans;
    }
};",1420088058
SRJM8941,SRJM8941,321,3487,cpp,"class Solution {
public:
    void name(string name,int n){
        if(name==""rahul""){
            n=n/2;
        }
    }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        std::vector<int> dp(m + 1, std::numeric_limits<int>::max()); 
        dp[0] = 0; 
        
        vector<bool> isAns(n, false); 
        for (int idx : targetIndices) {
            isAns[idx] = true;
        }
        
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != std::numeric_limits<int>::max()) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isAns[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == std::numeric_limits<int>::max() ? 0 : dp[m]);
        
    }
};",1420085436
SRJM8941,SRJM8941,321,3604,cpp,"class Solution {
public:
    void name( string ans, int n){
        ans=ans+"" "";
        n=n/2;
    }
    
     static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        
       vector<vector<int>> binomialCoeff(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            binomialCoeff[i][0] = 1;  
            for (int j = 1; j <= i; ++j) {
                binomialCoeff[i][j] = (binomialCoeff[i - 1][j - 1] + binomialCoeff[i - 1][j]) % MOD;
            }
        } 
        
        
        std::vector<std::vector<int>> stirlingNumbers(n + 1, std::vector<int>(x + 1, 0));
        stirlingNumbers[0][0] = 1;  
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

       
        std::vector<int> factorialValues(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorialValues[i] = (1LL * factorialValues[i - 1] * i) % MOD;
        }

        
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long powerOfY = 1;
            for (int i = 0; i < k; ++i) {
                powerOfY = (powerOfY * y) % MOD;
            }
            totalWays = (totalWays + (1LL * binomialCoeff[x][k] * stirlingNumbers[n][k] % MOD * factorialValues[k] % MOD * powerOfY % MOD)) % MOD;
        }
        return totalWays;

    }
};",1420108822
SRJM8941,SRJM8941,321,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0; i<n; i++){
            int num=nums[i];
            for(int k=0; k<num; k++){
                if((k | (k+1))==num){
                    ans[i]=k;
                    break;
                }
            }
        }
        return ans;
    }
};",1420006858
SRJM8941,SRJM8941,321,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int num=nums[i];
            int miniAns = INT_MAX;
            bool found=false;
            for(int bit=0; bit<=30; bit++){
                if(((num>>bit) & 1)==1){
                    int candi = num & ~(1<<bit);
                    if(candi < 0) continue;
                    if((candi | (candi+1))==num){
                        if(candi<miniAns){
                            miniAns=candi;
                            found=true;
                        }
                    }
                }
            }
            if(found){
                ans[i]=miniAns;
            }else{
                ans[i]=-1;
            }
            
        }
        return ans;
    }
};",1420050601
himanshu dhingra,himanshudhingra,322,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    bool hash[3001];
    int helper (int level, int pattern_made, string & s, string & pattern) {
        if (pattern_made == (int)pattern.size()) {
            int ans = 0;
            for (int i = level; i< s.size();i++) {
                ans += hash[i];
            }
            return ans;
        }
        if (level == (int)s.size()) {
            return -1e4;
        }

        if (dp[level][pattern_made] != -1) return dp[level][pattern_made];

        if (hash[level] == 0) {
            return dp[level][pattern_made] = helper(level + 1, pattern_made + (s[level] == pattern[pattern_made]), s, pattern);
        }
        if ((s[level] != pattern[pattern_made])) {
            return dp[level][pattern_made] = 1 + helper(level + 1, pattern_made, s, pattern);
        }
        return dp[level][pattern_made] = max (1 + helper(level + 1, pattern_made, s, pattern), helper(level + 1, pattern_made + 1, s, pattern));

    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset (dp, -1 , sizeof dp);
        memset(hash, 0,sizeof hash); 
        for (auto &it : targetIndices) {
            hash[it] = 1;
        }
        return helper(0,0,source,pattern);
    }
};",1420056966
himanshu dhingra,himanshudhingra,322,3604,cpp,"typedef long long ll;
class Solution {
public:

    ll dp[1001][1001];
    vector<long long> factorial;
    const int MOD = 1e9 + 7;

    vector<long long> computeFactorials() {
    int n = 1000;
    factorial[0] = 1;
    for (int i = 1; i <= n; ++i) {
        factorial[i] = (factorial[i - 1] * i) % MOD;
    }
    return factorial;
}

// Function to compute modular inverse of x % mod
long long modInverse(long long x) {
    long long result = 1, power = MOD - 2; // Fermat's Little Theorem
    while (power) {
        if (power % 2) {
            result = (result * x) % MOD;
        }
        x = (x * x) % MOD;
        power /= 2;
    }
    return result;
}

// Function to compute nCr % mod
long long nCr(int n, int r, const vector<long long>& factorial) {
    if (r > n) return 0; // if r is greater than n
    long long numerator = factorial[n];
    long long denominator = (factorial[r] * factorial[n - r]) % MOD;
    return (numerator * modInverse(denominator)) % MOD;
}

    long long modularExponentiation(long long x, long long y, long long mod) {
    long long result = 1;
    x = x % mod; // Take mod of x to avoid overflow
    
    while (y > 0) {
        // If y is odd, multiply x with result
        if (y % 2 == 1) {
            result = (result * x) % mod;
        }
        // y must be even now
        y = y >> 1; // Equivalent to y / 2
        x = (x * x) % mod; // Square x
    }
    
    return result;
}

    ll helper(int level, int filled, int n,int x, int y) {
        if (level == n) {
            return modularExponentiation(y,filled,MOD);
        }
        if(dp[level][filled] !=  -1)return dp[level][filled];
        
        if (filled == x) {
            return dp[level][filled] = (x%MOD*1ll*helper(level+1,filled,n,x,y)%MOD)%MOD;
        }
        return dp[level][filled] = (filled%MOD*1ll*helper(level+1,filled,n,x,y)%MOD + (x-filled)%MOD *1ll * helper(level+1,filled + 1,n,x,y)%MOD)%MOD;
    }

    int numberOfWays(int n, int x, int y) {
        memset(dp, -1, sizeof dp);
        // factorial = vector<ll>(1001);
        // computeFactorials();

        int ans =  helper(0,0,n,x,y);

        return ans;

    }
};",1420115236
himanshu dhingra,himanshudhingra,322,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        unordered_map <int,int> mp;

        for (int i = -1000;i<=1000;i++) {
            int oir = ((i)|(i+1));

            if (mp.find(oir) == mp.end()) {
                mp[oir] = i;
            }
            
        }

        for (auto & it : nums) {
            if(mp.find(it)!=mp.end()) {
                ans.push_back(mp[it]);
            } else {
                ans.push_back(-1);
            }
        }

        return ans;
    }
};",1420001132
himanshu dhingra,himanshudhingra,322,3611,cpp,"typedef long long ll;
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto & it : nums) {
            ll temp = 2e9;
            for (ll i = 0;(1ll<<i) < it;i++) {
                ll a = it - (1ll<<i);
                ll b = (a + 1);
                if ((a|b) == it) {
                    temp = min(temp, a);
 
                }
            }
            if (temp == 2e9) {
                temp = -1;
            }
            ans.push_back(temp);
        }
        return ans;
    }
};


",1420020343
Karishma Chaudhary,Karishma_chaudhary,323,3487,cpp,"class Solution {
public:
    void solve(){
        int ghgggh=0;
        int dfssdfjds=463364;
        int fdsg=9;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int ghu=90;
         int n = source.length();
         solve();
        int m = pattern.length();
        int size=m;
        std::vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        solve();
        std::vector<bool> isTarget(n, false);
        solve();
        for (int idx : targetIndices) {
            isTarget[idx] = true;
            int c=0;
        }
        solve();
        int flag=8;
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    int g=93;
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        solve();
        solve();
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420060504
Karishma Chaudhary,Karishma_chaudhary,323,3604,cpp,"class Solution {
public:
    int func(int a) {
        int x = a;
        int c = x;
        int fgdhsf = 788;
        return 4;
    }
    void solveAproblem() {
        int c = func(6);
        int fgshhjs = 577;
        int hfdsgfsj = 554642;
    }
    static const int BOB=1e8+2;
    static const int MOD = 1e9 + 7;
 
    int numberOfWays(int n, int x, int y) {
        solveAproblem();
        vector<std::vector<int>> binomialCoeff(x + 1, vector<int>(x + 1, 0));
        solveAproblem();
        int hfjfsdhgk = 574343;
        for (int i = 0; i <= x; ++i) {
            binomialCoeff[i][0] = 1;
            solveAproblem();
            for (int j = 1; j <= i; ++j) {
                binomialCoeff[i][j] =
                    (binomialCoeff[i - 1][j - 1] + binomialCoeff[i - 1][j]) %
                    MOD;
            }
            solveAproblem();
        }
        solveAproblem();
        int fdhjsghs = 34526;
        solveAproblem();
        vector<vector<int>> stirlingNumbers(n + 1, std::vector<int>(x + 1, 0));
        solveAproblem();
        stirlingNumbers[0][0] = 1;
        solveAproblem();
        for (int i = 1; i <= n; ++i) {
            int gsjjdh = 437;
            for (int j = 1; j <= x; ++j) {
                int hgf = 90;
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] +
                                         stirlingNumbers[i - 1][j - 1]) %
                                        MOD;
            }
        }
        solveAproblem();
        vector<int> fact(x + 1, 1);
        int hfhdh = 999;
        solveAproblem();
        for (int i = 1; i <= x; ++i) {
            int hdfhs;
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
            int fgg = 8;
        }
        solveAproblem();
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPower = 1;
            int powuh = 9;
            for (int i = 0; i < k; ++i) {
                yPower = (yPower * y) % MOD;
            }
            solveAproblem();
            totalWays = (totalWays +
                         (1LL * binomialCoeff[x][k] * stirlingNumbers[n][k] %
                          MOD * fact[k] % MOD * yPower % MOD)) %
                        MOD;
        }
        solveAproblem();
        return totalWays;
    }
};
",1420108910
Karishma Chaudhary,Karishma_chaudhary,323,3605,cpp,"class Solution {
public:
    void solve(){
        int a=9;
        int b=88;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        solve();
        int n = nums.size();
        int m=1000;
        solve();
        vector<int> ans(n, -1); 
        solve();
   
    for (int i = 0; i < n; i++) {
        for (int x = 0; x <= nums[i]; x++) {
            solve();
            if ((x | (x + 1)) == nums[i]) {
                ans[i] = x;
                break;
            }
            solve();
        }
    }

    return ans;
    }
};",1419997537
Karishma Chaudhary,Karishma_chaudhary,323,3611,cpp,"class Solution {
public:
    void solve() {
        int a = 8;
        int b = 98;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        solve();
       int n = nums.size();
       solve();
        vector<int> result(n);
        solve();
        int m=984;
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int sixe=988;
            int minimalResult = INT_MAX;
            int minmi=975;
            solve();
            bool isFound = false;
            solve();
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int vgfh=965;
                    int candidate = num & ~(1 << bit);
                 
                    if (candidate < 0) continue;
                    
                    int hgfdhf=864;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalResult) {
                            minimalResult = candidate;
                            isFound = true;
                        }
                    }
                    solve();
                }
            }
            
            if (isFound) {
                result[i] = minimalResult;
            } else {
                result[i] = -1;
            }
        }
        solve();
        
        return result;
    }
};",1420051053
Roll_Num_44,Roll_Num_44,324,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <limits>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }

    int findMax(const vector<int>& nums) {
        int maxVal = numeric_limits<int>::min();
        for (int num : nums) {
            if (num > maxVal) {
                maxVal = num;
            }
        }
        return maxVal;
    }

    int findMin(const vector<int>& nums) {
        int minVal = numeric_limits<int>::max();
        for (int num : nums) {
            if (num < minVal) {
                minVal = num;
            }
        }
        return minVal;
    }

    int calculateSum(const vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum;
    }

    bool containsPattern(const string& source, const string& pattern) {
        return source.find(pattern) != string::npos;
    }

    int countTargets(const vector<int>& targetIndices) {
        return targetIndices.size();
    }
};

",1420050322
Roll_Num_44,Roll_Num_44,324,3604,cpp,"#define ll long long

class Solution {
public:
    const int MODULO = 1e9 + 7;

    ll power_mod(ll base, ll exp, int mod) {
        ll result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp % 2)
                result = (result * base) % mod;
            base = (base * base) % mod;
            exp >>= 1;
        }
        return result;
    }

    ll inverse_mod(ll a, int mod) {
        return power_mod(a, mod - 2, mod);
    }

    void calculate_factorials(int max_val, vector<ll>& fact, vector<ll>& inv_fact) {
        fact[0] = inv_fact[0] = 1;
        for (int i = 1; i <= max_val; i++)
            fact[i] = (fact[i - 1] * i) % MODULO;
        inv_fact[max_val] = inverse_mod(fact[max_val], MODULO);
        for (int i = max_val - 1; i >= 1; i--)
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MODULO;
    }

    ll combination(int n, int r, vector<ll>& fact, vector<ll>& inv_fact) {
        if (r < 0 || r > n)
            return 0;
        return (((fact[n] * inv_fact[r]) % MODULO) * inv_fact[n - r]) % MODULO;
    }

    int multiply_mod(int a, int b) {
        return (static_cast<ll>(a) * b) % MODULO;
    }

    int add_mod(int a, int b) {
        return (a + b) % MODULO;
    }

    ll subtract_mod(ll a, ll b) {
        return (a - b + MODULO) % MODULO;
    }

    ll divide_mod(ll a, ll b) {
        return multiply_mod(a, inverse_mod(b, MODULO));
    }

    int numberOfWays(int n, int x, int y) {
        int max_val = max(n, x);
        vector<ll> fact(max_val + 1), inv_fact(max_val + 1);
        calculate_factorials(max_val, fact, inv_fact);

        vector<ll> S(x + 1, 0), prev_S(x + 1, 0);
        S[0] = 0;
        S[1] = 1;

        for (int i = 2; i <= n; i++) {
            prev_S = S;
            for (int k = 1; k <= min(i, x); k++) {
                S[k] = add_mod(multiply_mod(k, prev_S[k]), prev_S[k - 1]);
            }
        }

        ll total_ways = 0;
        for (int k = 1; k <= min(n, x); k++) {
            ll ways = combination(x, k, fact, inv_fact);
            ways = multiply_mod(ways, fact[k]);
            ways = multiply_mod(ways, S[k]);
            ways = multiply_mod(ways, power_mod(y, k, MODULO));
            total_ways = add_mod(total_ways, ways);
        }

        return (int)total_ways;
    }
};
",1420081951
Roll_Num_44,Roll_Num_44,324,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = 0; j <= nums[i]; ++j) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420009034
Roll_Num_44,Roll_Num_44,324,3611,cpp,"#include <iostream>
#include <vector>
#include <limits>

using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int> &nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int minAns = -1;
            for (int bit = 0; bit <= 30; ++bit) {
                if (nums[i] & (1 << bit)) {
                    int j = nums[i] - (1 << bit);
                    if (j >= 0 && ((j | (j + 1)) == nums[i])) {
                        if (minAns == -1 || j < minAns) {
                            minAns = j;
                        }
                    }
                }
            }
            ans[i] = minAns;
        }
        return ans;
    }

    int findMax(const vector<int>& nums) {
        int maxVal = numeric_limits<int>::min();
        for (int num : nums) {
            if (num > maxVal) {
                maxVal = num;
            }
        }
        return maxVal;
    }

    int findMin(const vector<int>& nums) {
        int minVal = numeric_limits<int>::max();
        for (int num : nums) {
            if (num < minVal) {
                minVal = num;
            }
        }
        return minVal;
    }

    int calculateSum(const vector<int>& nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum;
    }

    int countBits(int num) {
        int count = 0;
        while (num) {
            count += num & 1;
            num >>= 1;
        }
        return count;
    }

    bool isPowerOfTwo(int num) {
        return (num > 0) && ((num & (num - 1)) == 0);
    }
};
",1420053160
Ayush Sharma,ayush-018,325,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        vector<int> dp(pattern.size()+ 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isTarget(source.size(), false);
        bool check = true;
        for (int idx : targetIndices) {
            isTarget[idx] = check;
        }
        
        for (int i = 0; i < source.size(); ++i) {
            for (int j = pattern.size(); j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[pattern.size()] == numeric_limits<int>::max() ? 0 : dp[pattern.size()]);
    }
};",1420057341
Ayush Sharma,ayush-018,325,3604,cpp,"class Solution {
    const int MOD = 1e9 + 7;
public:
    int numberOfWays(int n, int x, int y) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        vector<vector<int>> resultArray(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            resultArray[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                resultArray[i][j] = (resultArray[i - 1][j - 1] + resultArray[i - 1][j]) % MOD;
            }
        }
        int ans;
        vector<vector<int>> tempA(n + 1, vector<int>(x + 1, 0));
        tempA[0][0] = 1; 
        for (int i = 1; i <= n; i++) { 
            for (int j = 1; j <= x; j++) { 
                tempA[i][j] = (1LL * j * tempA[i - 1][j] + tempA[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }

        long long totalW = 0;
        for (int k = 1; k <= x; k++) {
            long long yPower = 1;
            for (int i = 0; i < k; i++) {
                yPower = (yPower * y) % MOD;
            }
            totalW = (totalW + (1LL * resultArray[x][k] * tempA[n][k] % MOD * factorial[k] % MOD * yPower % MOD)) % MOD;
        }
        ans=totalW;
        return ans;
    }
};
",1420102571
Ayush Sharma,ayush-018,325,3605,cpp,"class Solution {
    private:
    int findS(int num) {
    int c=-1;
    for (int x = 0; x < num; ++x) {
        if ((x | (x + 1)) == num) {
            return x;
        }
    }
    return c;
}
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        vector<int> ans;
        for (int num : nums) {
            ans.push_back(findS(num));
        }
        return ans;
    }
};",1420008915
Ayush Sharma,ayush-018,325,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = nums.size();
    vector<int> ans(n);
    int c = -1;
    for (int i = 0; i < n; i++) {
        int num = nums[i];
        int minimalAns = INT_MAX;
        bool found = false;

        for (int bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {
                int candidate = num & ~(1 << bit);
                
                if (candidate < 0) continue;

                if ((candidate | (candidate + 1)) == num) {
                    if (candidate < minimalAns) {
                        minimalAns = candidate;
                        found = true;
                    }
                }
            }
        }
        
        if (found) {
            ans[i] = minimalAns;
        } else {
            ans[i] = c;
        }
    }
    
    return ans;
    }
};",1420046742
Shrivathsa,psshrivathsa784,326,3487,cpp,"#define forz(i,a,b) for(int i = a;i<b;i++)
#define N 3001

int dp[N][N]; //dp[i][j] is the max number of removals i can make when i can get the pattern
// from j to m using the i to n.

int solve(int i, int j, string &source, string &pattern, vector<int>& target){

    int n = source.size();
    int m = pattern.size();

    if (i == n){
        if (j == m){
            return 0;
        }
        else{
            return -1e6;
        }
    }

    int ind = lower_bound(target.begin(), target.end(), i) - target.begin();

    if (j == m){
        return target.size()-ind;
    }

    if (dp[i][j] == -1){
        if (ind<target.size() && target[ind] == i){
            dp[i][j] = max(1 + solve(i+1, j, source, pattern, target), solve(i+1, j + (pattern[j] == source[i]), source, pattern, target));
        }
        else{
            dp[i][j] = solve(i+1, j + (pattern[j] == source[i]), source, pattern, target);
        }
    }

    return dp[i][j];
    
}

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        forz(i,0,n+1){
            forz(j,0,m+1){
                dp[i][j] = -1;
            }
        }

        return solve(0,0,source,pattern,targetIndices);
    }
};",1420061862
Shrivathsa,psshrivathsa784,326,3604,cpp,"#include <vector>
using namespace std;

const int mod = 1e9 + 7;

class Solution {
public:
    vector<vector<long long>> S;
    vector<long long> fact;
    vector<long long> invFact;

    Solution() {
        int n = 1000;
        int k = 1000;
        S.resize(n + 1, vector<long long>(k + 1, 0));

        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            S[i][0] = 0;
            S[i][1] = 1;
        }
        for (int j = 1; j <= k; j++) {
            S[0][j] = 0;
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 2; j <= min(i, k); j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % mod;
            }
        }

        fact.resize(n + 1, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = (i * fact[i - 1]) % mod;
        }

        invFact.resize(n + 1, 1);
        invFact[n] = power(fact[n], mod - 2, mod);

        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = ((i + 1) * invFact[i + 1]) % mod;
        }
    }

    long long distribute_balls(int x, int y) {
        if (y > x) {
            return 0;
        }
        return (fact[y] * S[x][y]) % mod;
    }

    long long ncr(int a, int b) {
        return ((fact[a] * invFact[b]) % mod * invFact[a - b]) % mod;
    }

    int numberOfWays(int n, int x, int y) {
        long long ans = 0;
        for (int i = 0; i <= x; i++) {
            ans += ((distribute_balls(n, i) * ncr(x, i)) % mod * power(y, i, mod)) % mod;
            ans %= mod;
        }
        return ans;
    }

private:
    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        base = base % mod;
        while (exp > 0) {
            if (exp & 1) {
                result = (result * base) % mod;
            }
            exp >>= 1;
            base = (base * base) % mod;
        }
        return result;
    }
};
",1420115566
Shrivathsa,psshrivathsa784,326,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1 for i in range(n)]
        for i in range(n):
            if nums[i]%2:
                for j in range(33):
                    if ((1<<j)&nums[i]) == 0:
                        ans[i] = nums[i]^(1<<(j-1))
                        break
        return ans",1420002632
Shrivathsa,psshrivathsa784,326,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1 for i in range(n)]
        for i in range(n):
            if nums[i]%2:
                for j in range(33):
                    if ((1<<j)&nums[i]) == 0:
                        ans[i] = nums[i]^(1<<(j-1))
                        break
        return ans",1420002116
Gopal Gupta,gupta_gopal,327,3487,cpp,"class Solution {
public:
    #define ll long long
    int maxRemovals(string s,string p,vector<int>&t){
        ll n=s.size();
        ll m=p.size();
        ll pos=t.size();
        vector<ll>dp(m+10,1e9),del(n+10,0);
        dp[0]=0;
        for(auto i:t) del[i]=1;
        for(ll i=0;i<n;i++){
            for(ll j=m;j>0;j--){
                if(dp[j-1]!=1e9 && s[i]==p[j-1]){
                    dp[j]=min(dp[j],del[i]+dp[j-1]);
                }
            }
        }
        if(dp[m]==1e9) return pos;
        return pos-dp[m];
    }
};",1420122233
Gopal Gupta,gupta_gopal,327,3604,cpp,"class Solution {
public:
    #define ll long long
    
    ll power(ll a,ll b){
    static ll mod=1e9+7;
    if(b==0) return 1;
    if(a==1 || b==1) return a;
    if(b%2==0){
        ll c=power(a,b/2);
        return (c*c)%mod;
    }
    else{
        ll c=power(a,b/2);
        return ((a*c)%mod*c)%mod;
    }
}
    
    int numberOfWays(int n, int x, int y){
        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
        ll mod=1e9+7;
        vector<vector<ll>>dp(n+1,vector<ll>(x+1,0));
        dp[0][0]=1;
        for(ll i=1;i<=n;i++){
            for(ll j=1;j<=x;j++){
                dp[i][j]=(j*dp[i-1][j]+dp[i-1][j-1])%mod;
            }
        }
        vector<ll>per(1010);
        per[0]=per[1]=1;
        for(ll i=2;i<=1000;i++){
            per[i]=(per[i-1]*i)%mod;
        }
        ll ans=0;
        for(ll i=1;i<=min(n,x);i++){ // grp cnt
            ll n1=per[x];
            ll d1=(per[i]*per[x-i])%mod;
            ll w=(n1*power(d1,mod-2))%mod; // ways_of_choosing_grp_stages
            ll ways=(dp[n][i]*per[i])%mod;
            ll y_ways=power(y,i);
            ll cur_ans=(((w*ways)%mod)*y_ways)%mod;
            // cout<<i<<"" ""<<w<<"" ""<<ways<<"" ""<<y_ways<<"" ""<<cur_ans<<'\n';
            // cout<<i<<"" ""<<w<<"" ""<<num<<"" ""<<den<<"" ""<<ways<<"" ""<<y_ways<<"" ""<<cur_ans<<'\n';
            ans=(ans+cur_ans)%mod;
        }
        return ans;
    }
};",1420088206
Gopal Gupta,gupta_gopal,327,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>&v){
        vector<int>ans;
        for(auto i:v){
            if(i==2){
                // cout<<-1<<""   \n"";
                ans.push_back(-1);
            }
            else{
                // int next_big=i+1;
                // if(next_big&(next_big-1)){
                //     ans.push_back(i-1);
                // }
                // else{
                //     // cout<<next_big;
                //     ans.push_back((next_big/2)-1);
                // }
                long long bit=1;
                while(i&bit) bit*=2;
                bit/=2;
                ans.push_back(i-bit);
            }
        }
        return ans;
    }
};",1420005099
Gopal Gupta,gupta_gopal,327,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int>ans;
        for(auto i:v){
            if(i==2){
                // cout<<-1<<""   \n"";
                ans.push_back(-1);
            }
            else{
                // int next_big=i+1;
                // if(next_big&(next_big-1)){
                //     ans.push_back(i-1);
                // }
                // else{
                //     // cout<<next_big;
                //     ans.push_back((next_big/2)-1);
                // }
                long long bit=1;
                while(i&bit) bit*=2;
                bit/=2;
                ans.push_back(i-bit);
            }
        }
        return ans;
    }
};",1420005954
Aayush Suthar,aayushsuthar2004,328,3487,cpp,"class Solution {
public:

    int solve( string& s,  string& t , vector<int>& visit , vector<int>& pref , int i , int j , vector<vector<int>>& dp ){
        int n = s.size() , m = t.size();
        if( i == n ){
            if(j == m){
                return 0;
            }else{
                return INT_MIN;
            }
        }
        if( j == m ){
            return pref[i];
        }

        if(dp[i][j] != -1){
            return dp[i][j];
        }

        if( s[i] != t[j] ){
            return dp[i][j] = (visit[i] == 1) + solve(s , t , visit , pref , i+1 , j , dp);
        }else{
            return dp[i][j] = max( (visit[i] == 1) + solve(s , t , visit , pref , i+1 , j , dp) , solve(s , t , visit , pref , i+1 , j+1 , dp) );
        }
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> visit(source.size() , 0);
        vector<int> pref(source.size() , 0);
        for(auto it : targetIndices){
            visit[it] = 1;
        }   
        vector<vector<int>> dp(source.size()+1,vector<int>(pattern.size()+1 , -1));
        for(int i = source.size()-1 ; i >= 0 ; i--){
            pref[i] = (visit[i] == 1) + ( (i + 1 < source.size()) ? pref[i+1] : 0 );
        }
        int ans = solve(source , pattern , visit , pref , 0 , 0 , dp);
        return ans;
    }
};",1420052290
Aayush Suthar,aayushsuthar2004,328,3604,cpp,"class Solution {
public:
const int MOD = 1e9 + 7; 

long long int power(long long int x, long long int y, long long int p){
    long long int res = 1;
    while (y > 0) {
        if (y % 2 == 1)
            res = (res * x)%p;
        y = y >> 1;
        x = (x * x)%p;
    }
    return res % p;
}


long long int nCrSum( long long n , vector<long long int>& ways ){
    long long int ans = 0;
    long long int temp = 1;
    for(long long i = 1 ; i <= n-1 ; i++){
        temp = ((temp*(n - i + 1))%MOD)%MOD;
        temp = (temp * power(i , MOD - 2 , MOD))%MOD;
        ans = (ans + (temp*ways[n - i])%MOD )%MOD;
    }
    return ans%MOD;
}

    int numberOfWays(int n, int x, int y) {
        vector<long long int> ways(x+2);
        ways[1] = 1ll;

        for(long long int i = 2 ; i <= x ; i++){
            ways[i] = ((power(i , n , MOD) - nCrSum(i , ways))%MOD + MOD)%MOD;
        }
        long long int X = x;
        long long int Y = y;
        long long int N = n;
        long long int normal_y = y;
        
        long long int temp = X;  
        long long int ans = (X*Y)%MOD;

        for(long long int i = 2 ; i <= x ; i++){
            temp = (( temp*(X - i + 1) )%MOD);
            temp = (temp * power(i , MOD - 2 , MOD))%MOD;
            Y = (Y*normal_y)%MOD;
            ans = (ans + ((( temp*Y )%MOD)*ways[i]%MOD)%MOD)%MOD;
        }

    return ans%MOD;
    }
};",1420116138
Aayush Suthar,aayushsuthar2004,328,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for(int i = 0 ; i < nums.size() ; i++){
            if( nums[i] == 2 ){
                ans[i] = -1;
            }else{
                bitset<32> b(nums[i]);
                int idx = 0;
                for(int i = 0 ; i < 31 ; i++){
                    if( b[i] == 0 ){
                        idx = i;
                        break;
                    }
                }
                b[idx-1] = 0;
                ans[i] = b.to_ulong(); 
            }
        }

    return ans;
    }
};",1420001698
Aayush Suthar,aayushsuthar2004,328,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for(int i = 0 ; i < nums.size() ; i++){
            if( nums[i] == 2 ){
                ans[i] = -1;
            }else{
                bitset<32> b(nums[i]);
                int idx = 0;
                for(int i = 0 ; i < 31 ; i++){
                    if( b[i] == 0 ){
                        idx = i;
                        break;
                    }
                }
                b[idx-1] = 0;
                ans[i] = b.to_ulong(); 
            }
        }   
    
    return ans;
    }
};",1420003579
Harsh_kunwar,Harsh_kunwar,329,3487,cpp,"

class Solution
{
public:
    int dp[3001][3001];

    int f(int i, int j, string &s, string &t, vector<int> &mark)
    {
        if (i == s.size())
        {
            if (j == t.size())
            {
                return dp[i][j] = 0;
            }
            else
            {
                return dp[i][j] = -1e9;
            }
        }

        if (j == t.size())
        {
            if (mark[i] == 1)
            {
                dp[i][j] = 1 + f(i + 1, j, s, t, mark);
            }
            else
            {
                dp[i][j] = f(i + 1, j, s, t, mark);
            }
            return dp[i][j];
        }
        if (dp[i][j] != -1)
        {
            return dp[i][j];
        }
        int ans = -1e9;

        if (mark[i] == 0)
        {
            if (s[i] == t[j])
            {
                ans = f(i + 1, j + 1, s, t, mark);
            }
            else
            {
                ans = f(i + 1, j, s, t, mark);
            }
        }
        else
        {
            if (s[i] == t[j])
            {
                int keep = f(i + 1, j + 1, s, t, mark);
                int remove = 1 + f(i + 1, j, s, t, mark);
                ans = max(keep, remove);
            }
            else
            {
                ans = 1 + f(i + 1, j, s, t, mark);
            }
        }

        dp[i][j] = ans;
        return ans;
    }

    int maxRemovals(string &s, string &t, vector<int> &a)
    {
        int n = s.size();
        vector<int> mark(n, 0);
        for (auto &idx : a)
        {
                mark[idx] = 1;
            
        }
        memset(dp, -1, sizeof(dp));

        int result = f(0, 0, s, t, mark);
        return max(result, 0);
    }
};
",1420079590
Harsh_kunwar,Harsh_kunwar,329,3604,cpp,"class Solution
{
public:
    const long long mod = 1e9 + 7;
    long long power(long long x, long long y)
    {
        long long z = 1;
        x = x % mod;
        while (y > 0)
        {
            if (y & 1)
                z = (z * x) % mod;
            y = y >> 1;
            x = (x * x) % mod;
        }
        return z;
    }
    long long fact[1001];
    long long inv[1001];
    void f()
    {
        fact[0] = 1;
        for (long long i = 1; i <= 1000; i++)
        {
            fact[i] = fact[i - 1] * i % mod;
        }

        inv[1000] = power(fact[1000], mod - 2);
        for (long long i = 999; i >= 0; i--)
        {
            inv[i] = inv[i + 1] * (i + 1) % mod;
        }
    }

    long long comb(long long x_val, long long k_val)
    {
        if (k_val > x_val)
            return 0;

        if (k_val < 0 || k_val > x_val)
        {
            return 0;
        }
        return fact[x_val] * inv[k_val] % mod * inv[x_val - k_val] % mod;
    }

    long long numberOfWays(long long n, long long x, long long y)
    {
        f();
        long long K = min(x, n);
        vector<vector<long long>> dp(n + 1, vector<long long>(K + 1, 0));
        dp[0][0] = 1;
        for (long long i = 1; i <= n; i++)
        {
            long long upper = min(i, K);
            for (long long j = 1; j <= upper; j++)
            {
                dp[i][j] = (dp[i - 1][j - 1] + (j * dp[i - 1][j]) % mod) % mod;
            }
        }

        vector<long long> pw(K + 1, 1);
        for (long long k = 1; k <= K; k++)
        {
            pw[k] = pw[k - 1] * y % mod;
        }
        long long ans = 0;
        for (long long k = 1; k <= K; k++)
        {
            long long C = comb(x, k);
            long long yk = pw[k];
            long long dpk = dp[n][k];
            long long term = C * yk % mod;
            term = term * dpk % mod;
            term = term * fact[k] % mod;
            ans = (ans + term) % mod;
        }

        return ans;
    }
};
",1420116152
Harsh_kunwar,Harsh_kunwar,329,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(1001,1e5);
        for(int i=2;i<=1000;i++){
            for(int j=0;j<=i;j++){
                if((j|(j+1))==i){
                    ans[i]=min(j,ans[i]);
                }
            }
        }
        vector<int>res;
        for(auto &i:nums){
            if(ans[i]==1e5){
                ans[i]=-1;

            }
        res.push_back(ans[i]);

        }
        return res;

        
    }
};",1420008739
Harsh_kunwar,Harsh_kunwar,329,3611,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &nums)
    {
        vector<int> res;

        for (auto  p : nums)
        {
            int ans = INT_MAX;
            int i = __lg(p);

            for (int bit_pos = 0; bit_pos <= i;bit_pos++)
            {
                if (p & (1 << bit_pos))
                {
                    int k_candidate = p & ~(1 << bit_pos);
                    if ((k_candidate | (k_candidate + 1)) == p)
                    {
                        ans = min(ans, k_candidate);
                    }
                }
            }

            if (ans == INT_MAX)
            {
                res.push_back(-1);
            }
            else
            {
                res.push_back(ans);
            }
        }

        return res;
    }
};",1420031283
dirigibility,dirigibility,330,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        @cache
        def f(i,j):
            if i == len(source):
                return 0 if j == len(pattern) else -inf
            if j == len(pattern):
                return (i in targetIndices)+f(i+1,j)
            return max(f(i+1,j)+(i in targetIndices),f(i+1,j+1) if source[i] == pattern[j] else -inf)
        try:
            return f(0,0)
        finally:
            f.cache_clear()",1420033752
dirigibility,dirigibility,330,3604,python3,"mod = 10**9+7

@cache
def binom(n,k):
    if not 0 <= k <= n:
        return 0
    if n == k == 0:
        return 1
    return (binom(n-1,k-1)+binom(n-1,k))%mod

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # @cache
        # def f(n,x):
        #     if x == 0:
        #         return int(n == 0)
        #     if n == 0:
        #         return 1
        #     return (y*sum(binom(n,k)*f(n-k,x-1) for k in range(1,n+1))+f(n,x-1))%mod
        # try:
        #     return f(n,x)
        # finally:
        #     f.cache_clear()
        def f(k):
            return (pow(k,n,mod) + sum((-1 if (k-j)%2 else 1)*binom(k,j)*pow(j,n,mod) for j in range(1,k)))%mod
        return sum(binom(x,k)*pow(y,k,mod)*f(k) for k in range(1,min(n,x)+1))%mod
",1420116517
dirigibility,dirigibility,330,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for n in nums:
            if n == 2:
                result.append(-1)
            else:
                bit = 1
                while bit <= n:
                    if not n&bit:
                        break
                    bit <<= 1
                result.append(n-(bit>>1))
        return result",1420003048
dirigibility,dirigibility,330,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for n in nums:
            if n == 2:
                result.append(-1)
            else:
                bit = 1
                while bit <= n:
                    if not n&bit:
                        break
                    bit <<= 1
                result.append(n-(bit>>1))
        return result",1420002789
fxfxxxfxx,fxfxxxfxx,331,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size(), r = targetIndices.size();
        vector<int> V(n);
        for (int idx : targetIndices) V[idx] = 1;

        // M[i] := cost i, farest match
        vector<int> M(m+1);
        for (int idx = 0; idx < n; idx++) {
            for (int k = m-1; k >= 0; k--) {
                if (M[k] == m) continue;
                char tar = pattern[M[k]];
                if (source[idx] == tar) {
                    M[k+1] = max(M[k+1], M[k] + 1);
                    if (!V[idx]) M[k] += 1;
                }
                // cout << idx << "" "" << k << "" "" << M[k] << endl;
            }
        }
        for (int k = 0; k <= m; k++)
            if (M[k] == m) return r - k;
        std::unreachable();
    }
};",1420044418
fxfxxxfxx,fxfxxxfxx,331,3604,python3,"M = 1000000007
F = [1] * 1001
for i in range(1, 1001):
    F[i] = (F[i-1] * i) % M

R = [1] * 1001
for i in range(1, 1001):
    R[i] = pow(F[i], -1, M)

def C(n, k):
    return (F[n] * R[k] * R[n-k]) % M

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # A_k = k^n - (k-1)^n*C(k, k-1) + (k-2)^n*C(k, k-2)
        A = [0] * (x + 1)
        for k in range(1, min(n, x) + 1):
            v = pow(k, n, M) * C(x, k)
            for i in range(1, k):
                r = k - i
                add = (C(x-r, i) * A[r]) % M
                v = (v - add) % M
            A[k] = v

        ans = 0
        for k in range(1, x+1):
            ans = (ans + pow(y, k, M) * A[k]) % M
        return ans
        ",1420116573
fxfxxxfxx,fxfxxxfxx,331,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto f = [](int x) {
            if (x == 2) return -1;
            int ret = 1;
            while (x & (ret)) {
                ret <<= 1;
            }
            return x - (ret >> 1);
        };
        vector<int> V;
        for (int x: nums) {
            int y = f(x);
            V.push_back(y);
        }
        return V;
    }
};",1420001713
fxfxxxfxx,fxfxxxfxx,331,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto f = [](int x) {
            if (x == 2) return -1;
            int ret = 1;
            while (x & (ret)) {
                ret <<= 1;
            }
            return x - (ret >> 1);
        };
        vector<int> V;
        for (int x: nums) {
            int y = f(x);
            V.push_back(y);
        }
        return V;
    }
};",1420001390
optimus_np,optimus_np,332,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<int> dp(pattern.size() + 1, INT_MAX);
        dp[0] = 0;
        
        vector<bool> temp(source.size(), false);
        for (int i = 0; i < targetIndices.size(); i++) {
            temp[targetIndices[i]] = true; 
        }
        for (int i = 0; i < source.size(); i++) {
            for (int j = pattern.size(); j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (temp[i] ? 1 : 0));
                }
            }
        }
        sort(source.begin(), source.end());
        return targetIndices.size() - (dp[pattern.size()] == INT_MAX ? 0 : dp[pattern.size()]);
    }
};
",1420083354
optimus_np,optimus_np,332,3604,cpp,"#define MOD 1000000007
#define ll long long

class Solution {
public:
    int numberOfWays(int performer_n, int stage_x, int stage_y) {
        vector<ll> v = {performer_n, stage_x, stage_y};
        vector<vector<ll>> v1(stage_x + 1, vector<ll>(stage_x + 1, 0));
        unordered_map<ll,ll> m;
        for (int i = 0; i <= stage_x; i++) {
            v1[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                v1[i][j] = (v1[i - 1][j - 1] + v1[i - 1][j]) % MOD;
            }
        }
        
        vector<vector<ll>> v2(performer_n + 1, vector<ll>(stage_x + 1, 0));
        v2[0][0] = 1;
        for (int i = 1; i <= performer_n; i++) {
            for (int j = 1; j <= stage_x; j++) {
                v2[i][j] = (j * v2[i - 1][j] + v2[i - 1][j - 1]) % MOD;
            }
        }
        
        vector<ll> ans(stage_x + 1, 1);
        for (int i = 1; i <= stage_x; i++) {
            ans[i] = (ans[i - 1] * i) % MOD;
        }
        
        ll finalans = 0;
        for (int l = 1; l <= stage_x; l++) {
            ll w = 1;
            for (int p = 0; p < l; p++) {
                w = (ll)(w * stage_y) % MOD;
            }
            finalans = (finalans + v1[stage_x][l] * v2[performer_n][l] % MOD * ans[l] % MOD * w % MOD) % MOD;
            m[l] = finalans; 
        }
        set<ll> st;
        for(auto it: m) {
            st.insert(it.first);
        }
        return finalans;
}
};",1420110314
optimus_np,optimus_np,332,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> finalResult(nums.size(), -1);
        map<int,bool> m;    
        for (int i = 0; i < nums.size(); i++) {
            int minCandidate = INT_MAX;
            bool isFound = false;
            for (int w = 0; w <= 30; w++) {
                if ((nums[i] >> w) & 1) {
                    int p = nums[i] & ~(1 << w);
                    if (p < 0) continue;
                    
                    if ((p | (p + 1)) == nums[i]) {
                        if (p < minCandidate) {
                            minCandidate = p;
                            isFound = true;
                            m[i] = isFound;
                        }
                    }
                }
            }
            if (isFound) {
                finalResult[i] = minCandidate;
            } else {
                finalResult[i] = -1;
            }
        }
        vector<bool> tmep;
        for(auto it: m) {
            tmep.push_back(it.second);
        }
        return finalResult;
    }
};",1420098871
optimus_np,optimus_np,332,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> finalResult(nums.size(), -1);
        map<int,bool> m;    
        for (int i = 0; i < nums.size(); i++) {
            int minCandidate = INT_MAX;
            bool isFound = false;
            for (int w = 0; w <= 30; w++) {
                if ((nums[i] >> w) & 1) {
                    int p = nums[i] & ~(1 << w);
                    if (p < 0) continue;
                    
                    if ((p | (p + 1)) == nums[i]) {
                        if (p < minCandidate) {
                            minCandidate = p;
                            isFound = true;
                            m[i] = isFound;
                        }
                    }
                }
            }
            if (isFound) {
                finalResult[i] = minCandidate;
            } else {
                finalResult[i] = -1;
            }
        }
        vector<bool> tmep;
        for(auto it: m) {
            tmep.push_back(it.second);
        }
        return finalResult;
    }
};",1420098019
figuring-out,figuring-out,333,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();        
        
        vector<bool> isTarget(n, false);
        for(auto idx: targetIndices) isTarget[idx] = true;        
        
        vector<int> dp(m+1, n+1);
        dp[0] = 0;
        
        for(int i=0;i<n;i++){
            for(int j=m; j>=1; j--){
                
                if(source[i] == pattern[j-1]){
                    dp[j] = min(dp[j], dp[j-1] + isTarget[i]);
                }
                
            }
        }
        
        return targetIndices.size() - dp[m];
    }
};",1420033332
figuring-out,figuring-out,333,3604,cpp,"class Solution {
    
    const int MOD = 1e9+7;

    
    
    long long power_mod(long long a, long long b){
        
        long long res=1;
        a%=MOD;
        while(b>0){
            
            if(b&1) res = (res*a)%MOD;
            
            a = (a*a)%MOD;
            b>>=1;
        }
        
        return res;
    }
    
public:
    int numberOfWays(int n, int x, int y) {
        
        int max_k = min(n,x);
        
        vector<long long> fac(max_k+1, 1);
        for(int i=1;i<=max_k;i++) fac[i] = (fac[i-1]*i)%MOD;
        
        vector<long long> C(x+1, 0);
        C[0] = 1;
        for(int i=1;i<=x;i++){
            for(int j=min(i, x); j>=1; j--)
                C[j] = (C[j]+C[j-1])%MOD;
            
        }
        
        vector<vector<long long>> S(n+1, vector<long long>(max_k+1, 0));
        S[0][0] =1;
        for(int i=1;i<=n;i++){
            for(int k=1; k<=min(i, max_k); k++){
                S[i][k] = (S[i-1][k-1] + (k*S[i-1][k])%MOD)%MOD;
            }
        }
        
        
        vector<long long> y_pows(max_k+1, 1);
        for(int k=1;k<=max_k;k++) y_pows[k] = (y_pows[k-1]*y)%MOD;
        
        
        long long res =0;
        for(int k=1;k<=max_k;k++){
            long long comb = C[k];
            long long Stirling = S[n][k];
            long long factorial = fac[k];
            long long yk = y_pows[k];
            
            
            long long term = (comb*Stirling)%MOD;
            term = (term*factorial)%MOD;
            
            term = (term*yk)%MOD;
            res = (res+term)%MOD;
        }
        return res;
    }
};
",1420116883
figuring-out,figuring-out,333,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        
        for(auto num: nums){
            int res = -1;
            for(int a=0; a<num; a++){
                if( (a | (a+1)) == num ){
                    res = a;
                    break;
                }
            }
            ans.push_back(res);
        }
        return ans;
    }
};",1419997473
figuring-out,figuring-out,333,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        
        for(int idx=0; idx<n; idx++){
            int num = nums[idx];
            int res = INT32_MAX;
            for(int i=0; i<31; i++){
                if(num & (1<<i)){
                    
                    int x = (num&(~(1<<i))) | ((1<<i)-1);
                    
                    if( (x | (x+1)) == num)
                        res = min(res, x);
                    
                }
            }
            
            
            if(res!=INT32_MAX)
                ans[idx] = res;
            else
                ans[idx] = -1;
            
        }
        return ans;
    }
};",1420016569
Devashish21,Devashish21,334,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int> t) {
        vector<bool> tar(s.length(), false);
        for (int i : t) {
            tar[i] = true;
        }

        vector<int> dp(p.length() + 1, INT_MAX);
        dp[0] = 0;
        
        for (int i = 0; i < s.length(); ++i) {
            for (int j = p.length(); j > 0; --j) {

                if (s[i] == p[j-1] && dp[j-1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j-1] + tar[i]);
                }
            }
        }

        if (dp[p.length()] == INT_MAX)
            dp[p.length()]= 0;
        
        return t.size() - dp[p.length()];
    }
};
",1420089386
Devashish21,Devashish21,334,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {

        vector<int> f(x + 1, 1);

        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }

        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {

            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));

        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;

            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

        long long ans = 0;

        for (int k = 1; k <= x; ++k) {
            long long p = 1;

            for (int i = 0; i < k; ++i) {
                p = (p * y) % MOD;
            }
            ans = (ans + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * p % MOD)) % MOD;
        }
        return ans;
    }
};",1420123107
Devashish21,Devashish21,334,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans(nums.size(), -1);

        for (int i=0; i<nums.size(); i++){
            for (int j=0; j<=nums[i]; j++){
                if ((j | (j+1)) == nums[i]){
                    ans[i]= j;
                    break;
                }
            }
        }

        return ans;
    }
};",1420021743
Devashish21,Devashish21,334,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for (int i = 0; i < nums.size(); ++i) {
            bool f = false;
            int cur = nums[i];
            int mini = INT_MAX;
            
            for (int bit = 0; bit <= 30; ++bit) {
                if (((cur >> bit) & 1) == 1) {

                    int cand = cur & ~(1 << bit);
                    
                    if (cand < 0)
                        continue;
                    
                    if ((cand | (cand + 1)) == cur){

                        if (cand < mini){

                            mini = cand;
                            f = true;
                        }
                    }
                }
            }
            
            if(f){
                ans[i] = mini;
            }else{
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};
",1420108941
kd2425,kd2425,335,3487,python3,"class Solution:
    def maxRemovals(self,source: str,pattern: str,targetIndices: List[int]) -> int:
        n,m=len(source),len(pattern)
        target_set=set(targetIndices)
        ln=len(targetIndices)
        dp=[[inf] * (m+1) for _ in range(n+1)]
        dp[0][0]=0
        for i in range(n):
            for j in range(m+1):
                if dp[i][j]==inf:
                    continue
                
                if j<m and source[i]==pattern[j]:
                    if i in target_set:
                        cost=dp[i][j]+1
                    else:
                        cost=dp[i][j]
                    dp[i+1][j+1]=min(dp[i+1][j+1],cost)
                
                dp[i+1][j]=min(dp[i+1][j],dp[i][j])
        
        res=ln-dp[n][m]
        return res",1420073609
kd2425,kd2425,335,3604,python3,"class Solution:
    def numberOfWays(self,n: int,x: int,y: int) -> int:
            MOD=10**9+7
            max_val=max(n,x)
            factorial=[1]*(max_val+1)
            for i in range(1,max_val+1):
                factorial[i]=(factorial[i-1]*i)%MOD
            inv_fact=[1]*(max_val+1)
            inv_fact[max_val]=pow(factorial[max_val],MOD-2,MOD)
            for i in range(max_val,0,-1):
                inv_fact[i-1]=(inv_fact[i]*i)%MOD
            def comb(a: int,b: int) -> int:
                if b < 0 or b > a:
                    return 0
                return (factorial[a]*inv_fact[b]%MOD)*inv_fact[a-b]%MOD
            S=[0]*(x+1)
            S[0]=1
            for i in range(1,n+1):
                tmp=S.copy()
                for k in range(1,min(i,x)+1):
                    S[k]=(k*tmp[k]+tmp[k-1])%MOD
                S[0]=0  
            total=0
            for k in range(1,min(x,n)+1): 
                total=(total+comb(x,k)*S[k]%MOD*factorial[k]%MOD*pow(y,k,MOD)%MOD)%MOD
            return total
",1420097800
kd2425,kd2425,335,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for i in nums:
            v=False
            for x in range(i):
                if (x|(x+1))==i:
                    ans.append(x)
                    v = True
                    break
            if not v:
                ans.append(-1)
        return ans",1420001339
kd2425,kd2425,335,3611,python3,"# @cache
def l(p):
    return 1+l(p>>1) if p & 1 else 0
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for p in nums:
            if p<2:
                ans.append(-1)
                continue
            t=l(p)
            if t == 0:
                ans.append(-1)
            else:
                x=p-(1<<(t-1))
                if (x|(x+1))==p:
                    ans.append(x)
                else:
                    ans.append(-1)
        return ans",1420031565
Mighty Programmer,heartcodehacker,336,3487,cpp,"class Solution {
public:
    int countElementsGreaterOrEqual(set<int>& indices, int threshold) {
        auto it = indices.lower_bound(threshold);
        if (it == indices.end()) return 0;
        return distance(it, indices.end());
    }
    
    int computeMaxRemovals(int sourceIndex, int patternIndex, set<int>& indices, string &source, string &pattern, vector<vector<int>>& dp) {
        if (patternIndex == pattern.size()) return countElementsGreaterOrEqual(indices, sourceIndex);
        if (sourceIndex >= source.size()) return INT_MIN;

        if (dp[sourceIndex][patternIndex] != -1) return dp[sourceIndex][patternIndex];

        int maxRemovals = INT_MIN;
        
        if (indices.find(sourceIndex) != indices.end()) {
            maxRemovals = max(maxRemovals, 1 + computeMaxRemovals(sourceIndex + 1, patternIndex, indices, source, pattern, dp));
        }
        
        if (source[sourceIndex] == pattern[patternIndex]) {
            maxRemovals = max(maxRemovals, computeMaxRemovals(sourceIndex + 1, patternIndex + 1, indices, source, pattern, dp));
        } else {
            maxRemovals = max(maxRemovals, computeMaxRemovals(sourceIndex + 1, patternIndex, indices, source, pattern, dp));
        }
        
        return dp[sourceIndex][patternIndex] = maxRemovals;
    }

    void insertIntoSet(set<int>& indices, const vector<int>& indicesArray) {
        for (int index : indicesArray) {
            indices.insert(index);
        }
    }

    int maxRemovals(string source, string pattern, vector<int>& indicesArray) {
        set<int> indices;
        insertIntoSet(indices, indicesArray);

        vector<vector<int>> dp(source.size(), vector<int>(pattern.size(), -1));
        
        return computeMaxRemovals(0, 0, indices, source, pattern, dp);
    }
};
",1420089226
Mighty Programmer,heartcodehacker,336,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;

    vector<vector<ll>> computeBinomialCoefficients(ll maxVal) {
        vector<vector<ll>> binom(maxVal + 1, vector<ll>(maxVal + 1, 0));
        for (ll i = 0; i <= maxVal; i++) {
            binom[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;
            }
        }
        return binom;
    }

    vector<vector<ll>> computeStirlingNumbers(ll n, ll maxVal) {
        vector<vector<ll>> stirling(n + 1, vector<ll>(maxVal + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= maxVal; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        return stirling;
    }

    vector<ll> computeFactorials(ll maxVal) {
        vector<ll> factorial(maxVal + 1, 1);
        for (ll i = 1; i <= maxVal; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        return factorial;
    }

    ll computePower(ll base, ll exponent) {
        ll result = 1;
        for (ll p = 0; p < exponent; ++p) {
            result = (result * base) % MOD;
        }
        return result;
    }

    ll computeTotalWays(ll n, ll x, ll y, const vector<vector<ll>>& binomial, 
                        const vector<vector<ll>>& stirling, const vector<ll>& factorial) {
        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = computePower(y, k);
            totalWays = (totalWays + binomial[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * power % MOD) % MOD;
        }
        return totalWays;
    }

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> binomial = computeBinomialCoefficients(x);
        vector<vector<ll>> stirling = computeStirlingNumbers(n, x);
        vector<ll> factorial = computeFactorials(x);

        return computeTotalWays(n, x, y, binomial, stirling, factorial);
    }
};
",1420123568
Mighty Programmer,heartcodehacker,336,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& numbers) {
        vector<int> result;
        for (int idx = 0; idx < numbers.size(); idx++) {
            if (numbers[idx] == 2) {
                result.push_back(-1);
            } else {
                result.push_back(processNumber(numbers[idx]));
            }
        }
        return result;
    }

private:
    int processNumber(int num) {
        int significantBit = findSignificantBit(num);
        return modifyBits(num, significantBit);
    }

    int findSignificantBit(int num) {
        int tempNum = num, bitPosition = 0;
        while (tempNum > 0) {
            if ((tempNum & 1) == 0) break;
            bitPosition++;
            tempNum = (tempNum >> 1);
        }
        return bitPosition - 1;
    }

    int modifyBits(int num, int significantBit) {
        int modifiedNum = 0, bitIndex = 0;
        while (num > 0) {
            if (significantBit != bitIndex) {
                modifiedNum = (modifiedNum | ((num & 1) << bitIndex));
            }
            bitIndex++;
            num = (num >> 1);
        }
        return modifiedNum;
    }
};
",1420087219
Mighty Programmer,heartcodehacker,336,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& numbers) {
        vector<int> result;
        for (int idx = 0; idx < numbers.size(); idx++) {
            if (numbers[idx] == 2) {
                result.push_back(-1);
            } else {
                result.push_back(processNumber(numbers[idx]));
            }
        }
        return result;
    }

private:
    int processNumber(int num) {
        int significantBit = findSignificantBit(num);
        return modifyBits(num, significantBit);
    }

    int findSignificantBit(int num) {
        int tempNum = num, bitPosition = 0;
        while (tempNum > 0) {
            if ((tempNum & 1) == 0) break;
            bitPosition++;
            tempNum = (tempNum >> 1);
        }
        return bitPosition - 1;
    }

    int modifyBits(int num, int significantBit) {
        int modifiedNum = 0, bitIndex = 0;
        while (num > 0) {
            if (significantBit != bitIndex) {
                modifiedNum = (modifiedNum | ((num & 1) << bitIndex));
            }
            bitIndex++;
            num = (num >> 1);
        }
        return modifiedNum;
    }
};
",1420087364
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3487,golang,"package main

import (
	""math""
	""fmt""
)

func maxRemovals(sou string, patt string, ti []int) int {
	ne := len(sou)
	me := len(patt)
	d := make([]int, me+1)
	for i := range d {
		d[i] = math.MaxInt32
	}
	d[0] = 0

	it := make([]bool, ne)
	for _, ix := range ti {
		it[ix] = true
	}

	for i := 0; i < ne; i++ {
		for j := me; j > 0; j-- {
			if sou[i] == patt[j-1] && d[j-1] != math.MaxInt32 {
				d[j] = min(d[j], d[j-1]+boolToInt(it[i]))
			}
		}
	}

	if d[me] == math.MaxInt32 {
		return len(ti)
	}
	return len(ti) - d[me]
}

func boolToInt(she bool) int {
	if she {
		return 1
	}
	return 0
}

func min(he, she int) int {
	if he < she {
		return he
	}
	return she
}
",1420068027
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3604,golang,"package main

import (
	""fmt""
)

const MO = 1_000_000_007

func numberOfWays(ne int, xe int, ye int) int {
	co := make([][]int, xe+1)
	for i := range co {
		co[i] = make([]int, xe+1)
	}
	for i := 0; i <= xe; i++ {
		co[i][0] = 1
		for j := 1; j <= i; j++ {
			co[i][j] = (co[i-1][j-1] + co[i-1][j]) % MO
		}
	}
	sl := make([][]int, ne+1)
	for i := range sl {
		sl[i] = make([]int, xe+1)
	}
	sl[0][0] = 1
	for i := 1; i <= ne; i++ {
		for j := 1; j <= xe; j++ {
			sl[i][j] = (j*sl[i-1][j] + sl[i-1][j-1]) % MO
		}
	}
	fac := make([]int, xe+1)
	fac[0] = 1
	for i := 1; i <= xe; i++ {
		fac[i] = fac[i-1] * i % MO
	}
	tw := 0
	for k := 1; k <= xe; k++ {
		yP := pow(ye, k, MO)
		tw = (tw + co[xe][k]*sl[ne][k]%MO*fac[k]%MO*yP%MO) % MO
	}

	return tw
}
func pow(ba, ex, mod int) int {
	res := 1
	for ex > 0 {
		if ex%2 == 1 {
			res = res * ba % mod
		}
		ba = ba * ba % mod
		ex /= 2
	}
	return res
}",1420123636
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3605,golang,"package main

import ""fmt""

func minBitwiseArray(nos []int) []int {
    ne := len(nos)
    res := make([]int, ne)
    for i := 0; i < ne; i++ {
        res[i] = -1
        for y := 0; y <= nos[i]; y++ {
            if (y | (y + 1)) == nos[i] {
                res[i] = y
                break 
            }
        }
    }

    return res
}",1420016036
Harsha_Reddy_e22cseu0342,Harsha_Reddy_e22cseu0342,337,3611,golang,"package main

import (
	""fmt""
	""math""
)

func minBitwiseArray(nos []int) []int {
	ne := len(nos)
	res := make([]int, ne)

	for i := 0; i < ne; i++ {
		nuu := nos[i]
		ma := math.MaxInt32
		fo := false
		for b := 0; b <= 30; b++ {
			if (nuu>>b)&1 == 1 {
				can := nuu &^ (1 << b)
				if can < 0 {
					continue
				}
				if (can|(can+1)) == nuu {
					if can < ma {
						ma = can
						fo = true
					}
				}
			}
		}

		if fo {
			res[i] = ma
		} else {
			res[i] = -1
		}
	}

	return res
}",1420044744
Mohil,Mohil09,338,3487,cpp,"int dp[3001][3001];

class Solution {
public:

    int recr(int x, int y, string &s, string &t, set<int> &st){
        if(x==s.size()){
            if(y==t.size()) return 0;
            return -1e6;
        }
        if(dp[x][y]+1) return dp[x][y];

        int ans = recr(x+1,y+(y<t.size()&&s[x]==t[y]),s,t,st);
        if(st.find(x)!=st.end()) ans = max(ans,recr(x+1,y,s,t,st)+1);

        return dp[x][y] = ans;
    }

    int maxRemovals(string s, string t, vector<int>& w) {
        set<int> st(w.begin(),w.end());
        for(int i = 0; i <= s.size(); i++)
            for(int j = 0; j <= t.size(); j++)
                dp[i][j] = -1;
        return recr(0,0,s,t,st);
    }
};",1420057769
Mohil,Mohil09,338,3604,cpp,"int dp[1005][1005], fact[1005];

class Solution {
public:

    static const int M = 1e9+7;

    int cal(int n, int r){
        if(n<r or r<0) return 0;
        if(r==0 || n==r) return 1; 
        if(dp[n][r]+1) return dp[n][r];
        return dp[n][r] = (cal(n-1,r-1)+cal(n-1,r))%M;
    }

    int power(int a, int b){
        int ans = 1;
        while(b){
            if(b&1) ans = (1ll*ans*a)%M;
            a = (1ll*a*a)%M;
            b /= 2;
        }
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        if(dp[1][0]==0){
            memset(dp,-1,sizeof(dp));
            fact[0] = 1;
            for(int i = 1; i < 1005; i++)
            fact[i] = (1ll*fact[i-1]*i)%M;
        }
        int ans = 0;

        //i-childs, n = candies
        
        for(int i = 0; i <= x; i++){
            int curr = 0;
            for(int j = 0; j <= i; j++){
                int t = cal(i,j);
                t = (1ll*t*power(i-j,n))%M;
                if(j&1) t = -t;
                curr = (0ll+curr+t+M)%M;
            }
            curr = (1ll*curr*cal(x,i))%M;
            curr = (1ll*curr*power(y,i))%M;
            ans = (ans+curr)%M;
        }

        return ans;
    }
};",1420111247
Mohil,Mohil09,338,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector<int> ans(n,-1);

        for(int i = 0; i < n; i++){
            int x = nums[i];

            for(int j = 1; j < x; j++){
                int y = (j|(j+1));
                if(y==x){
                    ans[i] = j;
                    break;
                }
            }
        }    

        return ans;
    }
};",1420024145
Mohil,Mohil09,338,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &y:nums){
            if(y==2){
                y = -1;
                continue;
            }
            int x = y, bit = -1;
            while(x&1){
                bit++; x /= 2;
            }
            y ^= (1<<bit);
        }
        return nums;
    }
};",1420034447
Thiru,pabloescobar69,341,3487,java,"import java.util.*;

class Solution {

    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        int[] dp = initializeDP(m);
        boolean[] isTarget = createTargetArray(n, targetIndices);
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                updateDP(source, pattern, dp, isTarget, i, j);
            }
        }
        
        return calculateMaxRemovals(dp, targetIndices);
    }

    private int[] initializeDP(int m) {
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        return dp;
    }

    private boolean[] createTargetArray(int n, int[] targetIndices) {
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    private void updateDP(String source, String pattern, int[] dp, boolean[] isTarget, int i, int j) {
        if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
            dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
        }
    }

    private int calculateMaxRemovals(int[] dp, int[] targetIndices) {
        return targetIndices.length - (dp[dp.length - 1] == Integer.MAX_VALUE ? 0 : dp[dp.length - 1]);
    }
}
",1420060413
Thiru,pabloescobar69,341,3604,java,"import java.util.*;

class Solution {
    private static final int MOD = (int) 1e9 + 7;

    private long[][] computeCombinations(int size) {
        long[][] C = new long[size + 1][size + 1];
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }

    private long[][] computePartitions(int n, int x) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    private long computeFactorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        return (n * computeFactorial(n - 1)) % MOD;
    }

    public int numberOfWays(int n, int x, int y) {
        long[][] C = computeCombinations(x);
        long[][] S = computePartitions(n, x);

        long result = 0;
        for (int k = 1; k <= x; ++k) {
            long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * computeFactorial(k)) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }

        return (int) result;
    }
}
",1420098554
Thiru,pabloescobar69,341,3605,java,"import java.util.*;

class Solution {
    public int findMinAns(int prime) {
        for (int x = 1; x <= prime; ++x) {
            if ((x | (x + 1)) == prime) {
                return x;
            }
        }
        return -1;
    }

    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; ++i) {
            ans[i] = findMinAns(nums.get(i));
        }

        return ans;
    }
}
",1420012440
Thiru,pabloescobar69,341,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums.get(i) != 2) {
                res[i] = getAns(nums.get(i));
            } else {
                res[i] = -1;
            }
        }
        return res;
    }

    public int getAns(int n) {
        int j = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                j = i;
            } else {
                break;
            }
        }
        return n - (1 << j);
    }

    public int[] findMaxAndMin(List<Integer> nums) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int num : nums) {
            max = Math.max(max, num);
            min = Math.min(min, num);
        }
        return new int[] {max, min};
    }

    public int countSetBits(int n) {
        int count = 0;
        while (n > 0) {
            count += n & 1;
            n >>= 1;
        }
        return count;
    }
}
",1420074104
SUJIT9821,SUJIT9821,342,3487,cpp,"class Solution {
public:
vector<vector<int>>dp;
    int f(string&s,string&p,vector<bool>&mark,int i,int j){
        if(j==p.size())return 0;
        if(i==s.size())return 1e5;
        if(dp[i][j]!=-1)return dp[i][j];
        int x = 1e9;
        if(s[i]==p[j])x=mark[i]+f(s,p,mark,i+1,j+1);
        x = min(x,f(s,p,mark,i+1,j));
        return dp[i][j]= x;
        
    }
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(),m = p.size();
        vector<bool>mark(n,0);
        dp.assign(n,vector<int>(m,-1));
        for(auto&it:t)mark[it]=1;
        int x = f(s,p,mark,0,0);
        return t.size()-x;
    }
};",1420079013
SUJIT9821,SUJIT9821,342,3604,cpp,"
const int MOD = 1e9 + 7;

// Function to compute (base^exp) % MOD using modular exponentiation
long long modExp(long long base, long long exp, long long mod) {
    long long result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}

// Function to compute binomial coefficient C(n, k) % MOD
long long binomialCoeff(int n, int k, vector<vector<long long>>& C) {
    if (C[n][k] != -1) return C[n][k];
    if (k == 0 || k == n) return C[n][k] = 1;
    return C[n][k] = (binomialCoeff(n - 1, k - 1, C) + binomialCoeff(n - 1, k, C)) % MOD;
}

// Function to compute f(r)
long long f(int r, int n, vector<vector<long long>>& C) {
    long long sum = 0;
    for (int p = 0; p <= r; ++p) {
        long long sign = (p % 2 == 0) ? 1 : -1;
        long long term = (binomialCoeff(r, p, C) * modExp(r - p, n, MOD)) % MOD;
        sum = (sum + sign * term + MOD) % MOD;  // Add MOD to avoid negative values
    }
    return sum;
}
class Solution {
public:
int numberOfWays(int n, int x, int y) {
    // Create a binomial coefficient table for all values up to x
    vector<vector<long long>> C(x + 1, vector<long long>(x + 1, -1));

    long long result = 0;
    for (int r = 1; r <= x; ++r) {
        long long binCoeff = binomialCoeff(x, r, C);  // xCr
        long long scoreWays = modExp(y, r, MOD);      // y^r
        long long f_r = f(r, n, C);                  // f(r)

        // Add the current term to the result
        long long currentTerm = (binCoeff * scoreWays) % MOD;
        currentTerm = (currentTerm * f_r) % MOD;

        result = (result + currentTerm) % MOD;
    }

    return result;
}};",1420118047
SUJIT9821,SUJIT9821,342,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto&it:nums){
              
            if(it==2){
                ans.push_back(-1);
            }
            else{
                bitset<30>b(it);  
                bitset<30>ans2 = b;
                for(int i=0;i<30;i++){
                    if(b[i]==0){
                        ans2[i-1]=0;
                        break;
                    }
                }
                ans.push_back(ans2.to_ulong());
            }
        }
        return ans;
    }
};",1420005912
SUJIT9821,SUJIT9821,342,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto&it:nums){
              
            if(it==2){
                ans.push_back(-1);
            }
            else{
                bitset<30>b(it);  
                bitset<30>ans2 = b;
                for(int i=0;i<30;i++){
                    if(b[i]==0){
                        ans2[i-1]=0;
                        break;
                    }
                }
                ans.push_back(ans2.to_ulong());
            }
        }
        return ans;
    }
};",1420005233
Manan Chhajed,Manan_Chhajed,344,3487,cpp,"class Solution {
public:
    using ll = long long;
    int maxRemovals(string s, string t, vector<int>& v) 
    {
        ll n = s.size(), m = t.size();
        
        vector<ll> ok(n, 0);
        for (auto it : v) ok[it] = 1;
        
        vector<ll> dp(m, 1e18);

        for (int i = 0; i < n; ++i) 
        {
            for (int j = m - 1; j >= 0; j--) 
            {
                if (t[j] == s[i]) dp[j] = min(dp[j], (j > 0 ? dp[j - 1] : 0) + ok[i]);
            }
        }

        ll ans = v.size() - dp[m - 1];
        return ans;
    }
};",1420118225
Manan Chhajed,Manan_Chhajed,344,3604,cpp,"class Solution {
public:
    using ll = long long;
    const ll MOD = 1e9 + 7;
    
    ll fact[1007], invFact[1007];
    
    ll binExpIter(ll a, ll b) { ll temp = 1; while (b > 0) { if (b & 1) temp = (temp * 1LL * a) % MOD; a  = (a * 1LL * a) % MOD; b >>= 1; } return temp % MOD; }

    
    ll nCr(ll n, ll r) { return (((fact[n] * invFact[n - r]) % MOD) * invFact[r]) % MOD; }

    ll inv(ll n) { return binExpIter(n, MOD - 2) % MOD; }
    
    void preCompute() { fact[0] = 1, invFact[0] = 1; for (int i = 1; i <= 1e3; i++) { fact[i] = (fact[i - 1] * i) % MOD; invFact[i] = inv(fact[i]) % MOD; } }
    
    ll mod_mul(ll a, ll b) { a = a % MOD; b = b % MOD; return (((a * b) % MOD) + MOD) % MOD; }
    ll mod_add(ll a, ll b) { a = a % MOD; b = b % MOD; return (((a + b) % MOD) + MOD) % MOD; }
    ll mod_sub(ll a, ll b) { a = a % MOD; b = b % MOD; return (((a - b) % MOD) + MOD) % MOD; }
    ll mod_div(ll a, ll b) { a = a % MOD; b = b % MOD; return (mod_mul(a, inv(b)) + MOD) % MOD; }
    
    int numberOfWays(int n, int x, int y) 
    {
        preCompute();           
        ll ans = 0;
        
        for(int occ = 1; occ <= x; occ++)
        {
            if(n < occ) continue;
            ll rem = n - occ;
            // ll temp = mod_mul(nCr(n, occ), fact[occ]);
            // ll temp = mod_mul(fact[n], nCr(n - 1, occ - 1));
            // temp = mod_mul(temp, binExpIter(occ, rem));
            
            ll temp = 0;
            for(ll i = 0; i <= occ - 1; i++)
            {
                if(i % 2 == 0)
                {
                    temp = mod_add(temp, mod_mul(nCr(occ, i), binExpIter(occ - i, n)));
                }
                else
                {
                    temp = mod_sub(temp, mod_mul(nCr(occ, i), binExpIter(occ - i, n)));
                }
            }
            
            ll res = mod_mul(temp, binExpIter(y, occ));
            res = mod_mul(res, nCr(x, occ));
            ans = mod_add(ans, res);
        }
        
        return ans;
    }
};",1420082514
Manan Chhajed,Manan_Chhajed,344,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for(int i = 0; i < n; i++)
        {
            if(nums[i] == 2) continue;
            int res = nums[i];
            for(int j = 0; j <= 20; j++)
            {
                if(res & (1 << j)) continue;
                else 
                {
                    res -= (1 << (j - 1));
                    break;
                }
            }
            ans[i] = res;
        }
        
        return ans;
    }
};",1420009857
Manan Chhajed,Manan_Chhajed,344,3611,cpp,"class Solution {
public:
    using ll = long long;
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for(ll i = 0; i < n; i++)
        {
            if(nums[i] == 2) continue;
            ll res = nums[i];
            for(int j = 0; j <= 31; j++)
            {
                if(res & (1ll << j)) continue;
                else 
                {
                    res -= (1ll << (j - 1));
                    break;
                }
            }
            ans[i] = res;
        }
        
        return ans;
    }
};",1420011969
ptr1025,ptr1025,345,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& tar) {
        auto isin = [&tar](int x){
            auto it = lower_bound(tar.begin(),tar.end(),x);
            return it != tar.end() && *it == x;
        };
        vector<int> dp(p.size(),tar.size()+1);
        for(int j=0;j<s.size();j++){
            const char & c = s[j];
            vector<int> nx = dp;
            for(int i=0;i<p.size();i++){
                if(c == p[i]){
                    int prev = i ? dp[i-1]:0;
                    nx[i] = min(dp[i], isin(j) + prev);
                }
            }
            dp = std::move(nx);
            // for(int x:dp){
            //     cout << x << "" "";
            // }
            // cout << ""\n"";
        }
        return tar.size() - dp.back();
    }
};",1420041001
ptr1025,ptr1025,345,3604,cpp,"class Solution {
public:
    int mod = 1e9+7;
    int64_t mpow(int64_t x, int64_t n){
        int64_t a = 1;
        while(n){
            if(n & 1) a = (x * a) % mod;
            x = x * x % mod;
            n >>= 1;
        }
        return a;
    }
    int inv(int x){
        return mpow(x, mod - 1);
    }
    int f(int x){
        int a = 1;
        while(x){
            a = (x * a) % mod;
            x--;
        }
        return a;
    }
    int c(int n, int r){
        return f(n) * inv(f(n-r)) * inv(f(r));
    }
    int numberOfWays(int n, int x, int y) {
        int64_t ans = 0;
        vector<int64_t> dp(n+1, 0);
        dp[0] = 1;
        
        for(int i=0;i<n;i++){
            for(int j=n;j>=2;j--){
                dp[j] = (dp[j]*j %mod+ dp[j-1]*(x-j+1) %mod) %mod;
            }
            dp[1] = x;
            // for(int j=1;j<=n;j++){
            // cout << dp[j] << "" "";
            // }
            // cout << ""\n"";
        }

        // cout << mpow(1,8) << ""??\n"";
        for(int i=1;i<=min(n,x);i++){
            ans = ans + dp[i] * mpow(y,i) % mod;
            ans = ans % mod;
            // cout << ans << ""~"";
            
        }
            // cout << ""\n"";
        
        return ans;
    }
};",1420111966
ptr1025,ptr1025,345,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        d = {}
        for i in range(1,1008):
            k = i | (i + 1)
            if not k in d:
                d[k] = i
        return [d.get(x,-1) for x in nums]",1419994987
ptr1025,ptr1025,345,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int x:nums){
            array<int, 31> arr;
            for(int i=0;i<31;i++){
                arr[i] = (1 << i) & x;
            }
            int h = 0;
            for(;h<31;h++){
                if(!arr[h])break;
            }
            if(h == 0){
                ans.push_back(-1);
                continue;
            }
            int v = 0;
            for(int i=0;i<31;i++){
                if(i != h - 1)v |= (arr[i]);
            }
            ans.push_back(v);
        }
        return ans;
    }
};",1420009302
Mayank670,Mayank670,346,3487,cpp,"class Solution {
public:
    Solution() {
        ios_base::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);
    }
    int maxRemovals(string src, string patt, vector<int>& ti) {
        int n = src.size();
        int m = patt.size();
        vector<bool> flg(n, false);
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        for (int it : ti) {
            flg[it] = true;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = m; j >= 1; --j) {
                if (src[i] == patt[j - 1] && dp[j - 1] != INT_MAX) {
                    if (flg[i]) {
                        dp[j] = min(dp[j], dp[j - 1] + 1);
                    } else {
                        dp[j] = min(dp[j], dp[j - 1]);
                    }
                }
            }
        }
        if (dp[m] == INT_MAX) {
            return ti.size();
        } else {
            return ti.size() - dp[m];
        }
    }
};
",1420087311
Mayank670,Mayank670,346,3604,cpp,"const int m = 1e9 + 7;
#define vvi vector<vector<int>> 
#define vi vector<int>  
#define ll long long 

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vvi dp(x + 1, vi(x + 1, 0));
        vi temp(x + 1, 1); 
        vvi res(n + 1, vi(x + 1, 0));
        res[0][0] = 1; 

        for (int i = 0; i <= x; i++) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % m;
            } 
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                res[i][j] = (res[i - 1][j - 1] + (1LL) * j * res[i - 1][j]) % m;
            }
        }

        for (int i = 1; i <= x; i++) {
            temp[i] = (1LL * temp[i - 1] * i) % m; 
        }

        int result = 0;
        for (int k = 1; k <= x; k++) {
            long long ans = 1; 
            for (int j = 0; j < k; j++) {
                ans = (ans * y) % m; 
            }
            
            ll p1 = dp[x][k];
            ll p2 = res[n][k];
            ll p3 = temp[k];

            ll cc = (p1 * p2) % m;
            cc = (cc * p3) % m;
            cc = (cc * ans) % m;

            result = (result + cc) % m;
        }

        return result; 
    }
};
",1420118419
Mayank670,Mayank670,346,3605,cpp,"class Solution {
public:
    int cal(int no) {
        for (int ii = 1; ii<= no; ii++) {
            if ((ii | (ii + 1)) == no) {
                return ii;
            }
        }
        return -1; 
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> sol(n, -1); 

        for (int i = 0; i < n; ++i) {
            sol[i] =cal(nums[i]) ; 
        }

        return sol;
    }
};",1420002940
Mayank670,Mayank670,346,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n , -1);
        for(int i = 0; i < n; i++) {
            int number = nums[i];
            if((number & (number - 1)) == 0) {
                result[i] = -1;  
            } else {
               
                int local = (number & ~(number + 1)) >> 1;
                result[i] = number - local - 1;
            }
        }
        
        return result;
    }
};
",1420050679
Ritanshu Khobarkhede,ritanshu4k,347,3487,java,"import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

class Solution {
    public int maxRemovals(String src, String pat, int[] targetIdx) {
        int n = src.length();
        int m = pat.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        Set<Integer> targets = new HashSet<>();
        for (int idx : targetIdx) {
            targets.add(idx);
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (src.charAt(i) == pat.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (targets.contains(i) ? 1 : 0));
                }
            }
        }

        return targetIdx.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420113484
Ritanshu Khobarkhede,ritanshu4k,347,3604,java,"class Solution {
    private static final int MOD = 1_000_000_007;

    public int numberOfWays(int n, int x, int y) {
        int[][] cm = cm(x);
        int[][] st = st(n, x);
        int[] fc = fc(x);

        long total = 0;
        for (int k = 1; k <= x; ++k) {
            long yp = pm(y, k);
            total = (total + (1L * cm[x][k] * st[n][k] % MOD * fc[k] % MOD * yp % MOD)) % MOD;
        }
        return (int) total;
    }

    private int[][] cm(int x) {
        int[][] cmb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; ++i) {
            cmb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                cmb[i][j] = (cmb[i - 1][j - 1] + cmb[i - 1][j]) % MOD;
            }
        }
        return cmb;
    }

    private int[][] st(int n, int x) {
        int[][] stl = new int[n + 1][x + 1];
        stl[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stl[i][j] = (int) ((1L * j * stl[i - 1][j] + stl[i - 1][j - 1]) % MOD);
            }
        }
        return stl;
    }

    private int[] fc(int x) {
        int[] fact = new int[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; ++i) {
            fact[i] = (int) (1L * fact[i - 1] * i % MOD);
        }
        return fact;
    }

    private long pm(int base, int exp) {
        long result = 1;
        long b = base;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                result = (result * b) % MOD;
            }
            b = (b * b) % MOD;
            exp >>= 1;
        }
        return result;
    }
}
",1420118503
Ritanshu Khobarkhede,ritanshu4k,347,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        List<Integer> res = new ArrayList<>();

        for (int i : nums) {
            boolean f = false;

            for (int x = 0; x < i; x++) {
                if ((x | (x + 1)) == i) {
                    res.add(x);
                    f = true;
                    break;
                }
            }

            if (!f) {
                res.add(-1);
            }
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
    }
}
",1420102725
Ritanshu Khobarkhede,ritanshu4k,347,3611,java,"import java.util.List;
import java.util.ArrayList;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        List<Integer> res = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = findMinimalAns(num);
            res.add(minimalAns);
        }

        return res.stream().mapToInt(Integer::intValue).toArray();
    }

    private int findMinimalAns(int i) {
        int minimalX = Integer.MAX_VALUE;
        boolean f = false;

        for (int bit = 0; bit <= 30; bit++) {
            if (((i >> bit) & 1) == 1) {
                int c = i & ~(1 << bit);
                if (c < 0) continue;

                if ((c | (c + 1)) == i) {
                    if (c < minimalX) {
                        minimalX = c;
                        f = true;
                    }
                }
            }
        }

        return f ? minimalX : -1;
    }
}
",1420108775
aboylinked,aboylinked,348,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int tSize = targetIndices.size();
        
         vector<bool> isTarget(n, false);
        for(auto idx : targetIndices){
            isTarget[idx] = true;
        }
        
         const int INF = 1e9;
        vector<int> previous(n + 1, INF);
         previous[0] = 0;
        for(int j = 1; j <= n; ++j){
            previous[j] = 0;
        }
        
         for(int i = 1; i <= m; ++i){
            vector<int> current(n + 1, INF);
            for(int j = 1; j <= n; ++j){
                if(pattern[i-1] == source[j-1]){
                     
                    if(previous[j-1] != INF){
                        current[j] = min(current[j-1], previous[j-1] + (isTarget[j-1] ? 1 : 0));
                    }
                    else{
                        current[j] = current[j-1];
                    }
                }
                else{
                     current[j] = current[j-1];
                }
            }
             previous = current;
        }
        
         int minUsedTargets = INF;
        for(int j = 1; j <= n; ++j){
            minUsedTargets = min(minUsedTargets, previous[j]);
        }
        
         if(minUsedTargets == INF){
            return 0;
        }
        
         return tSize - minUsedTargets;
    }
};
",1420084080
aboylinked,aboylinked,348,3604,cpp,"const int MOD = 1'000'000'007;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<long long> S_prev(x + 1, 0);  
        vector<long long> S_current(x + 1, 0);
        S_prev[0] = 1; 
        
        for(int i=1; i<=n; ++i){
            for(int k=0; k<=x; ++k){
                S_current[k] = 0;
            }
            for(int k=1; k<=x; ++k){
                S_current[k] = (S_prev[k-1] + (k * S_prev[k]) % MOD) % MOD;
            }
            
            S_prev = S_current;
        }
        
        vector<long long> C(x +1, 0);
        C[0] =1;
        for(int j=1; j<=x; ++j){
            for(int k = min(j, x); k>=1; --k){
                C[k] = (C[k] + C[k-1]) % MOD;
            }
        }
         
        int max_k = min(x, n);
        vector<long long> fact(max_k +1, 1);
        for(int k=1; k<=max_k; ++k){
            fact[k] = (fact[k-1] * k) % MOD;
        }

        
        vector<long long> pow_y(max_k +1, 1);
        for(int k=1; k<=max_k; ++k){
            pow_y[k] = (pow_y[k-1] * y) % MOD;
        }

       long long total =0;
        for(int k=1; k<=max_k; ++k){
            long long term = (C[k] * fact[k]) % MOD;
            term = (term * S_prev[k]) % MOD;
            term = (term * pow_y[k]) % MOD;
            total = (total + term) % MOD;
        }

        return (int)total;
    }
};
",1420092636
aboylinked,aboylinked,348,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  
        
        for (int i = 0; i < n; ++i) {
            for (int x = 0; x <= nums[i]; ++x) {
                 
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x; 
                    break;       
                }
            }
        }
        
        return ans;
        
    }
};",1420013058
aboylinked,aboylinked,348,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        vector<int> ans;
        for(auto num : nums){
            bool found = false;
            int min_k = INT32_MAX;
            for(int j=0; j < 32; ++j){
                if( (num >> j) &1 ){
                    int k = num & (~(1<<j));
                        
                    if( (k | (k +1)) == num ){
                        if(k < min_k){
                            min_k = k;
                            found = true;
                        }
                    }
                }
            }
            if(found){
                ans.push_back(min_k);
            }
            else{
                ans.push_back(-1);
            }
        }
        return ans;


        
    }
};",1420011626
Naitik Raj,naitikraj1000,349,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));
        unordered_set<int> removableIndices(targetIndices.begin(), targetIndices.end());
        
        return max(0, solve(source, pattern, 0, 0, removableIndices, dp));
    }

private:
    int solve(const string& s, const string& p, int i, int j, 
              const unordered_set<int>& removableIndices, vector<vector<int>>& dp) {
      
      if(i>=s.size()){
        if(j>=p.size()) return 0;
        return -1e9;
      }

      
         if(dp[i][j]!=-1) return dp[i][j];


         int ans=INT_MIN;

if(j>=p.size()){
   if(removableIndices.count(i)){
            ans=max(ans,1+solve(s,p,i+1,j,removableIndices,dp));
             }else{
              ans=max(ans,solve(s,p,i+1,j,removableIndices,dp));
             }
}else{
         if(s[i]==p[j]){
           
             if(removableIndices.count(i)){
               ans=max(ans,solve(s,p,i+1,j+1,removableIndices,dp));
               ans=max(ans,1+solve(s,p,i+1,j,removableIndices,dp));
             }else{
              ans=max(ans,solve(s,p,i+1,j+1,removableIndices,dp));
             }
         }else{
 
           if(removableIndices.count(i)){
               ans=max(ans,1+solve(s,p,i+1,j,removableIndices,dp));
             }else{
              ans=max(ans,solve(s,p,i+1,j,removableIndices,dp));
             }

         }

}
    
         return dp[i][j]=ans;
    }
};",1420052617
Naitik Raj,naitikraj1000,349,3604,cpp,"#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

class Solution {
public:
    // Recursive function for modular exponentiation (a^b) % MOD
    int modPow(int x, int y) {
        if (y == 0) return 1;
        long long z = modPow(x, y / 2);
        z = (z * z) % MOD;
        if (y % 2 == 1) z = (z * x) % MOD;
        return z;
    }

    // Precompute factorials and modular inverses
    void precompFact(int n, vector<int>& fact, vector<int>& invFact) {
        if (fact.size() > n) return;
        
        fact.resize(n + 1);
        invFact.resize(n + 1);
        
        fact[0] = 1;
        for (int i = 1; i <= n; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        invFact[n] = modPow(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; --i) {
            invFact[i] = (1LL * invFact[i + 1] * (i + 1)) % MOD;
        }
    }

    // Compute combinations C(n, k) % MOD
    int comb(int n, int k, const vector<int>& fact, const vector<int>& invFact) {
        if (k > n || k < 0) return 0;
        return (1LL * fact[n] * invFact[k] % MOD) * invFact[n - k] % MOD;
    }

    // Precompute Stirling numbers of the second kind
    void precompStirling(int n, int k, vector<vector<int>>& stirling) {
        stirling.assign(n + 1, vector<int>(k + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= k; ++j) {
                stirling[i][j] = (stirling[i - 1][j - 1] + 1LL * j * stirling[i - 1][j] % MOD) % MOD;
            }
        }
    }

    // Main function to compute the number of distinct ways
    int numberOfWays(int n, int k, int mult) {
        vector<int> fact, invFact;
        precompFact(k, fact, invFact);  // Precompute factorials & inverses

        vector<vector<int>> stirling;
        precompStirling(n, k, stirling);  // Precompute Stirling numbers

        int total = 0;

        // Iterate over all possible number of bands (1 to k)
        for (int b = 1; b <= k; ++b) {
            int powMult = modPow(mult, b);

            // Compute the current sum term:
            // C(k, b) * S(n, b) * b! * mult^b % MOD
            int term = comb(k, b, fact, invFact);  // C(k, b)
            term = (1LL * term * stirling[n][b]) % MOD;  // S(n, b)
            term = (1LL * term * fact[b]) % MOD;  // b!
            term = (1LL * term * powMult) % MOD;  // mult^b

            total = (total + term) % MOD;
        }

        return total;
    }
};


",1420124931
Naitik Raj,naitikraj1000,349,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int> v) {
        
        int n=v.size();
         vector<int> ans(n,-1);
        for(int i=0;i<v.size();i++){
         int num=v[i];
          int possible=false;
          int store=0;
          int sum=0;
          int possible_ans=INT_MAX;
         for(int j=31;j>=0;j--){
           int bit=log2(num+1);
           if((1<<j)&(num)){
             if((1<<bit)==num+1){
            possible=true;
             num-=(1<<j);
            sum+=(1<<j);
            possible_ans=min(possible_ans,sum+(1<<(bit-1)));
            break;
           }else{
            num-=(1<<j);
            sum+=(1<<j);
           }
           }
        
         }

         if(possible){
            ans[i]=sum;
         }
        }

        for(int i=0;i<n;i++){
            if(ans[i]!=-1) ans[i]--;
        }
        return ans;
    }
    };",1420023306
Naitik Raj,naitikraj1000,349,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
         vector<int> ans(n,-1);
        for(int i=0;i<v.size();i++){
         int num=v[i];
          int possible=false;
          int store=0;
          int sum=0;
          int possible_ans=INT_MAX;
         for(int j=31;j>=0;j--){
           int bit=log2(num+1);
           if((1<<j)&(num)){
             if((1<<bit)==num+1){
            possible=true;
             num-=(1<<j);
            sum+=(1<<j);
            possible_ans=min(possible_ans,sum+(1<<(bit-1)));
            break;
           }else{
            num-=(1<<j);
            sum+=(1<<j);
           }
           }
        
         }

         if(possible){
            ans[i]=sum;
         }
        }

        for(int i=0;i<n;i++){
            if(ans[i]!=-1) ans[i]--;
        }
        return ans;
    }
};",1420021944
Vishal Kumar,Nemesis_77,350,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:

        n = len(source)
        m = len(pattern)
        
        dp = [10**9] * (m + 1)
        dp[0] = 0 
        
        arr = [False] * n
        for e in targetIndices:
            arr[e] = True
        
        for i in range(0 , n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1]:
                    prev_dp = dp[j - 1]
                    if prev_dp != 10**9:
                        dp[j] = min(dp[j], prev_dp + (1 if arr[i] else 0))

        dp_value = dp[m]
        return len(targetIndices) - (0 if dp_value == 10**9 else dp_value)



",1420073694
Vishal Kumar,Nemesis_77,350,3604,python3,"m = 10**9 + 7
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]

        arr = []
        for i in range(0 ,x + 1):
            row = [0] * (x + 1)
            arr.append(row)

        arr2 = []
        for i in range(n + 1):
            row = [0] * (x + 1)
            arr2.append(row)

        i = 0
        while i <= x:
            arr[i][0] = 1  
            j = 1
            while j <= i:
                arr[i][j] = (arr[i - 1][j] + arr[i - 1][j - 1]) % m
                j += 1
            i += 1

        arr2[0][0] = 1  
        i = 1
        while i <= n:
            j = 1
            while j <= x:
                arr2[i][j] = (arr2[i - 1][j - 1] + j * arr2[i - 1][j]) % m
                j += 1
            i += 1

        mul = [1 for _ in range(x + 1)]
        i = 1
        while i <= x:
            mul[i] = i * mul[i - 1] % m
            i += 1

        ans = 0
        for i in range(1, x + 1):
            exxp = 1
            for j in range(0 , i):
                exxp = (y * exxp) % m
            temp1 = arr[x][i] * arr2[n][i] % m
            temp2 = temp1 * mul[i] % m
            temp3 = temp2 * exxp % m
            ans = (ans + temp3) % m

        return ans

",1420118697
Vishal Kumar,Nemesis_77,350,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  
        
        for i in range(n):
            for e in range(nums[i] + 1):
                if (e | (e + 1)) == nums[i]:
                    ans[i] = e
                    break  
        return ans",1420032767
Vishal Kumar,Nemesis_77,350,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n
        
        for i in range(0 , n):
            dig = nums[i]
            curr = float('inf')
            flag = False
            
            for e in range(0 , 31):
                if (dig >> e) % 2 == 1:
                    temp = dig & ((1 << e) ^ -1)
                    if temp < 0:
                        continue
                    if (temp | (temp + 1)) == dig:
                        if temp < curr:
                            flag = True
                            curr = temp         
            
            if flag:
                ans[i] = curr
            else:
                ans[i] = -1
        
        return ans
",1420053455
Sai Krishna,saikrishna17394,351,3487,cpp,"class Solution {
    string s;
    string pat;
    int n, pat_len;
    vector<vector<int>> dp;
    vector<bool> vis;
    int inf;

    int solve(int i, int j) {

        if (dp[i][j] != inf) {
            return dp[i][j];
        }

        if (i == n) {
            if (j != pat_len) {
                dp[i][j] = -1e5;
                return dp[i][j];
            }

            dp[i][j] = 0;
            return 0;
        }


        if (j == pat_len) {
            if (vis[i] == true) {
                dp[i][j] = 1 + solve(i + 1, j);
            }
            else {
                dp[i][j] = solve(i + 1, j);
            }

            return dp[i][j];
        }

        if (s[i] == pat[j]) {
            dp[i][j] = solve(i + 1, j + 1);

            if (vis[i] == true) {
                dp[i][j] = max(dp[i][j], 1 + solve(i + 1, j));
            }
            else {
                dp[i][j] = max(dp[i][j], solve(i + 1, j));
            }

            return dp[i][j];
        }

        if (vis[i] == true) {
            dp[i][j] = max(dp[i][j], 1 + solve(i + 1, j));
        }
        else {
            dp[i][j] = max(dp[i][j], solve(i + 1, j));
        }

        return dp[i][j];
    }

public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        n = source.length();
        pat_len = pattern.length();

        if (n == pat_len) {
            return 0;
        }

        s = source;
        pat = pattern;
        vis = vector<bool>(n, false);
        inf = -1e8;
        for (const auto& idx : targetIndices) {
            vis[idx] = true;
        }

        dp = vector<vector<int>>(n + 1, vector<int>(pat_len + 1, inf));
        return solve(0, 0);
    }
};",1420068805
Sai Krishna,saikrishna17394,351,3604,cpp,"class Solution {
    const long long mod = 1e9 + 7;


public:
    int numberOfWays(int n, int x, int y) {
        // fac[0] = 1;
        // afac[0] = 1;

        // for (int i = 1; i < lim; i++) {
        //     fac[i] = ((long long) i * fac[i - 1]) % mod;
        //     afac[i] = pow(fac[i], mod - 2);
        // }

        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));

        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }

        for (int i = 1; i <= n; i++) {
            dp[i][1] = (long long)(y * x);
        }

        for (int j = 2; j <= x; j++) {
            dp[1][j] = 0;

            for (int i = 2; i <= n; i++) {
                if (i < j) {
                    dp[i][j] = 0;
                    continue;
                }

                dp[i][j] = (long long)((x - j + 1) * y) * dp[i - 1][j - 1] + (dp[i - 1][j] * (long long)j);
                dp[i][j] %= mod;
            }
        }

        long long ans = 0;

        for (int j = 1; j <= x; j++) {
            ans += dp[n][j];
            ans %= mod;
        }
        return (int)ans;
    }
};",1420124991
Sai Krishna,saikrishna17394,351,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                continue;
            }

            for (int j = 1; j < nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }

        return ans;
    }
};",1419998198
Sai Krishna,saikrishna17394,351,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] == 2) {
                continue;
            }

            ans[i] = nums[i] - 1;

            int val = 4;

            while (val <= (nums[i] + 1)) {
                if ((nums[i] % val) != (val - 1)) {
                    break;
                }

                ans[i] = (nums[i] / val) * val + ((val - 1) / 2);

                val *= 2;
            }
        }

        return ans;
    }
};",1420028175
Bhargav M,vexora0,352,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        Set<Integer> lup = new HashSet<>();
        for(int idx : targetIndices) lup.add(idx);
        
        int n = source.length();
        int m = pattern.length();
        int t = targetIndices.length;
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        
        for(int i = 0; i < n; i++) {
            for(int j = Math.min(m, i + 1); j >=1; j--) {
                if(source.charAt(i) == pattern.charAt(j -1)) {
                    if(dp[j-1] != Integer.MAX_VALUE) {
                        if(lup.contains(i)) {
                            dp[j] = Math.min(dp[j], dp[j-1] +1);
                        }
                        else {
                            dp[j] = Math.min(dp[j], dp[j-1]);
                        }
                    }
                }
            }
        }
        
        if(dp[m] == Integer.MAX_VALUE) return 0;
        return t - dp[m];
    }
}",1420116329
Bhargav M,vexora0,352,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        int M = 1000000007;
        
        int[] l = new int[]{n, x, y};
        
        long[][] s = new long[l[0]+1][l[1]+1];
        s[0][0] = 1;
        for(int i=1;i<=l[0];i++) {
            for(int j=1;j<=l[1];j++) {
                s[i][j] = (s[i-1][j-1] + (j * s[i-1][j]) % M) % M;
            }
        }
        
        long[][] c = new long[l[1]+1][l[1]+1];
        c[0][0] = 1;
        for(int i=1;i<=l[1];i++) {
            c[i][0] = 1;
            for(int j=1;j<=i;j++) {
                c[i][j] = (c[i-1][j-1] + c[i-1][j]) % M;
            }
        }
        
        long[] f = new long[l[1]+1];
        f[0] = 1;
        for(int i=1;i<=l[1];i++) {
            f[i] = (f[i-1] * i) % M;
        }
        
        long[] p = new long[l[1]+1];
        p[0] = 1;
        for(int i=1;i<=l[1];i++) {
            p[i] = (p[i-1] * l[2]) % M;
        }
        
        long r = 0;
        for(int k=1;k<=Math.min(l[1], l[0]);k++) {
            long comb = c[l[1]][k];
            long stir = s[l[0]][k];
            long fact = f[k];
            long yPow = p[k];
            long t = (((comb * stir) % M) * fact) % M;
            t = (t * yPow) % M;
            r = (r + t) % M;
        }
        
        return (int) r;
    }
}
",1420125034
Bhargav M,vexora0,352,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int size = nums.size();
        int[] result = new int[size];
        
        for(int idx = 0; idx < size; idx++) {
            int prime = nums.get(idx);
            int smallest = -1;
            
            for(int y = 0; y < prime; y++) {
                if( (y | (y + 1)) == prime ) {
                    smallest = y;
                    break;
                }
            }
            
            result[idx] = smallest;
        }
        
        return result;        
    }
}

",1419997465
Bhargav M,vexora0,352,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        Arrays.fill(ans, -1); 

        for(int i=0; i<n; i++) {
            int p = nums.get(i);
            int minx = Integer.MAX_VALUE;
            for(int k=0; k<32; k++) {
                if( (p & (1 <<k)) !=0 ){
                    int x = p & ~(1 <<k);
                    if(x < 0) continue;
                    if( (x | (x +1)) == p ){
                        if(x < minx){
                            minx = x;
                        }
                    }
                }
            }
            if(minx != Integer.MAX_VALUE){
                ans[i] = minx;
            }
        }
        return ans;
    }
}",1420007632
BATMAN,chamoli2k2,353,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        long long n = source.size(), m = pattern.size(), k = targetIndices.size();
        vector<long> dp(m+1, INT_MAX);
        dp[0] = 0; 
        
        vector<bool> temp(n, false);
        for(int i=0; i<k; i++){
            int idx = targetIndices[i];
            temp[idx] = true;
        }
        
        for(int i=0; i<n; i++){
            for(int j=m; j>0; j--){
                if(source[i] == pattern[j-1] && dp[j-1] != INT_MAX){
                    dp[j] = min(dp[j], dp[j-1] + (temp[i] ? 1 : 0));
                }
            }
        }

        if(dp[m] == 0) return k;
        return k - dp[m];
    }
};
",1420080673
BATMAN,chamoli2k2,353,3604,cpp,"class Solution {
public:
    int mod = 1e9+7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> dp(x+1, vector<long long>(x+1, 0));
        auto calFact = [&](int x){
            vector<long long> ans(x+1, 1);
            for(int i=1; i<=x; i++){
                ans[i] = ans[i-1] * i % mod;
            }
            return ans;
        };
        
        vector<long long> factorial = calFact(x);
        for(int i=0; i<=x; i++){
            dp[i][0] = 1;
            for(int j=1; j<=i; j++){
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%mod;
            }
        }

        vector<vector<long long>> strNum(n+1, vector<long long>(x+1, 0));
        strNum[0][0] = 1;
        for(int i=1; i<=n; i++){
            for(int j=1; j<=x; j++){
                strNum[i][j] = (j * strNum[i-1][j] + strNum[i-1][j-1]) % mod;
            }
        }

        long long ans = 0;
        for(int k=1; k<=x; k++){
            long long currComb = 1;
            for (int p=0; p<k; p++){
                currComb = (currComb *1LL* y) % mod;
            }
            ans = (ans + dp[x][k] *1LL* strNum[n][k] % mod *1LL* factorial[k] % mod * currComb % mod) % mod;
        }

        return ans;
    }
};
",1420125378
BATMAN,chamoli2k2,353,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        
        for(int i=0; i<n; i++){
            for(int j=0; j<=nums[i]; j++){
                if((j | (j + 1)) == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        
        return ans;
    }
};
",1419996646
BATMAN,chamoli2k2,353,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        
        for(int i=0; i<n; i++){
            int currMin = INT_MAX, flag = false;
            for(int j=0; j<31; j++){
                if(((nums[i]>>j)&1) == 1){
                    int target = nums[i] & ~(1 << j);
                    if(target >= 0 && (target | (target+1)) == nums[i]){
                        currMin = min(currMin, target);
                        flag = true;
                    }
                }
                
                if(flag) ans[i] = currMin;
            }
        }
        
        return ans;
    }
};",1420054458
Batyrkhan Altynbekov,Arch_of_Triumph,354,3487,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;

vector<int> goods[30];
vector<int> bads[30];
int dp[3010][3010];

class Solution {
public:
    int maxRemovals(string s, string t, vector<int>& a) {
        int n = sz(s);
        int m = sz(t);
        s = ""#"" + s;
        t = ""$"" + t;
        int k = sz(a);
        for (int i = 0; i <= m; i++) for (int j = 0; j <= k; j++)
            dp[i][j] = INT_MAX;
        for (int i = 0; i < 30; i++)
            goods[i].clear(), bads[i].clear();
        vector<bool> bad(n + 5, 0);
        for (auto it: a)
            bad[it + 1] = 1;
        for (int i = 1; i <= n; i++) {
            int x = s[i] - 'a';
            if (!bad[i])
                goods[x].pb(i);
            else 
                bads[x].pb(i);
        }
        dp[0][0] = 0;
        for (int i = 1; i <= m; i++) {
            int x = t[i] - 'a';
            for (int j = 0; j <= min(i, k); j++) {
                if (j > 0 && !bads[x].empty()) {
                    int pre = dp[i - 1][j - 1];
                    int ind = upper_bound(all(bads[x]), pre) - bads[x].begin();
                    if (ind < sz(bads[x])) {
                        dp[i][j] = bads[x][ind];                        
                    }
                }
                if (!goods[x].empty()) {
                    int pre = dp[i - 1][j];
                    int ind = upper_bound(all(goods[x]), pre) - goods[x].begin();
                    if (ind < sz(goods[x])) {
                        dp[i][j] = min(dp[i][j], goods[x][ind]);                        
                    }   
                }
            }
        }
        for (int i = 0; i <= k; i++)
            if (dp[m][i] != INT_MAX)
                return k - i;
        return k;
    }
};


",1420082368
Batyrkhan Altynbekov,Arch_of_Triumph,354,3604,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;
const int MOD = (int)1e9 + 7;

ll C[1010][1010];

class Solution {
public:
    ll binpow(ll x, ll n) {
        ll res = 1;
        while (n) {
            if (n & 1)
                res = (res * x) % MOD;
            x = (x * x) % MOD;
            n /= 2;
        }
        return res;
    }
    
    void fillCnk(int n) {
        for (int i = 0; i <= n; i++) {
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
            }
        }
    }
    
    int numberOfWays(int n, int x, int y) {
        fillCnk(1000);
        ll ans = 0, preval = 0;
        vector<ll> dp(1010);
        for (int i = 1; i <= min(x, n); i++) {
            ll cnt = C[x][i];
            ll sub = 0;
            for (int j = 1; j < i; j++)
                sub = (sub + dp[j] * C[i][j]) % MOD;
            ll val = (binpow(i, n) - sub + MOD) % MOD;
            dp[i] = val;
            ans = (ans + cnt * val % MOD * binpow(y, i)) % MOD;
        }
        return ans;
    }
};",1420125398
Batyrkhan Altynbekov,Arch_of_Triumph,354,3605,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = sz(a);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            int x = a[i];
            if (x == 2) {
                ans.pb(-1);
                continue;
            }
            for (int j = 0; j <= 11; j++) {
                if (!(x >> j & 1)) {
                    ans.pb(x ^ (1 << (j - 1)));
                    break;
                }
            }
        }
        return ans;
    }
};",1419996995
Batyrkhan Altynbekov,Arch_of_Triumph,354,3611,cpp,"#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) (int)x.size()
#define ll long long

const int N = (int)3e5 + 123;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        int n = sz(a);
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            int x = a[i];
            if (x == 2) {
                ans.pb(-1);
                continue;
            }
            for (int j = 0; j <= 30; j++) {
                if (!(x >> j & 1)) {
                    ans.pb(x ^ (1 << (j - 1)));
                    break;
                }
            }
        }
        return ans;
    }
};",1419998460
Bashem,bashem,355,3487,cpp,"class Solution {
    int solve(int source_index, int pattern_index, vector<vector<int>> &dp, string &source, string &pattern, unordered_set<int> &targetIndices) {
        if(source_index == source.size()) {
            if(pattern_index == pattern.size()) return 0;

            return INT_MIN;
        }

        auto &res = dp[source_index][pattern_index];
        if(res != -1) return res;

        res = INT_MIN;
        auto res_not_taking_the_index = solve(source_index + 1, pattern_index, dp, source, pattern, targetIndices);

        if(res_not_taking_the_index >= 0) {
            res = max(res, targetIndices.contains(source_index) + res_not_taking_the_index);
        }
        
        if(pattern_index != pattern.size() && source[source_index] == pattern[pattern_index]) {
            auto res_taking_the_index = solve(source_index + 1, pattern_index + 1, dp, source, pattern, targetIndices);
            res = max(res, res_taking_the_index);
        }

        return res;
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        auto targetIndicesSet = unordered_set<int>(targetIndices.begin(), targetIndices.end());
        auto dp = vector(source.size(), vector(pattern.size() + 1, -1));

        return solve(0, 0, dp, source, pattern, targetIndicesSet);
    }
};",1420033408
Bashem,bashem,355,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        const int MAX_FACT_INDEX = 2 * max(n, x) + 1;

        auto fact = vector(MAX_FACT_INDEX, 1);
        for (int i = 1; i < MAX_FACT_INDEX; i++)
            fact[i] = (fact[i - 1] * 1LL * i) % MOD;

        auto fact_inv = [&](int index) {
            return big_mod(fact[index], MOD - 2);
        };

        auto getNCR = [&](int nc, int r) {
            auto ncr = fact[nc];
            ncr = (ncr * 1LL * fact_inv(nc - r)) % MOD;
            ncr = (ncr * 1LL * fact_inv(r)) % MOD;

            return ncr;
        };

        auto getSurgective = [&](int a, int b) {
            int ans = 0;
            for (int i = 1; i <= b; i++) {
                int cans = big_mod(-1, b - i);
                cans = (cans * 1LL * getNCR(b, i)) % MOD;
                cans = (cans * 1LL * big_mod(i, a)) % MOD;
                
                cans = (cans + MOD) % MOD;
                ans = (ans + cans) % MOD;
            }

            return ans;
        };

        int ans = 0;
        for (int i = 1; i <= min(n, x); i++) {
            auto cans = (getSurgective(n, i) * 1LL * 1) % MOD;
            
            // cout << ncr << endl;
            cans = (cans * 1LL * getNCR(x, i)) % MOD;
            cans = (cans * 1LL * big_mod(y, i)) % MOD;
            // cout << i << "" ::i:: "" << cans << endl;
            ans = (ans + cans) % MOD;
        }

        return ans;
    }
private:
    typedef long long ll;
    ll big_mod(ll a, ll p)
    {
        ll res = 1 % MOD, x = a % MOD;
        while (p > 0)
        res = ((p & 1) ? ((res * x) % MOD) : res), x = ((x * x) % MOD), p >>= 1;
        return res;
    }
};",1420119209
Bashem,bashem,355,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto ans = vector(nums.size(), -1);

        for (int i = 0; i < nums.size(); i++) {
            if(nums[i] == 2) continue;
            for (int j = 1; j <= nums[i]; j++) {
                if((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }

        return ans;
    }
};",1419996658
Bashem,bashem,355,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        auto ans = vector(nums.size(), -1);

        for (int i = 0; i < nums.size(); i++) {
            if(nums[i] == 2) continue;

            int consecutive_ones = 0;
            for (int j = 0; j < 31; j++) {
                if((nums[i] & (1 << j)) == 0) break;
                consecutive_ones++;
            }

            int first_part = nums[i] ^ ((1 << consecutive_ones) - 1);
            if(consecutive_ones > 0) first_part ^= ((1 << (consecutive_ones - 1)) - 1);
            ans[i] = first_part;
        }

        return ans;
    }
};",1420008339
thecodereal55,thecodereal55,356,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE; // Use Integer.MAX_VALUE to represent infinity
        }
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        int k =3;
       
        for(int i = 0 ; i<5;i++){
                k++;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420122347
thecodereal55,thecodereal55,356,3604,cpp,"class Solution {
    public:
    typedef long
    long ll;const
    ll MOD = 1e9 + 7;

    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};

    vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }
        int k = 33;
        int kp=3;
        for( int i = 0 ; i< 5 ;i++){
kp++;
        }

    vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

    vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420120274
thecodereal55,thecodereal55,356,3605,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        vector<int> ans(nums.size()); 
        int k =3;
        for(int i= 0 ; i<5;i++){
                k++;
        }
        for (int i = 0; i < nums.size(); i++) { 
            bool found = false; 
            for (int x = 0; x <= nums[i]; x++) { 
                if ((x | (x + 1)) == nums[i]) { 
                    ans[i] = x;  // If condition is satisfied 
                    found = true; 
                    break; 
                } 
            } 
             
            if (!found) { 
                ans[i] = -1;  // No valid value found for ans[i] 
            } 
        } 
         
        return ans; 
    } 
};",1420125564
thecodereal55,thecodereal55,356,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        int k =3;
        for(int i= 0 ; i<5;i++){
            k++;
        }
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420124250
fallen_08,fallen_08,357,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n1 = source.size();
        int n2 = pattern.size();
        vector<double> dp(n2 + 1, numeric_limits<double>::infinity());
        dp[0] = 0;
        vector<bool> res(n1, false);
        for (auto it : targetIndices)
            res[it] = true;
        for (int i = 0; i < n1; i++) {
            for (int j = n2; j > 0; j--) {
                if (source[i] == pattern[j - 1] &&
                    dp[j - 1] != numeric_limits<double>::infinity()) {
                    dp[j] = min(dp[j], dp[j - 1] + (res[i] ? 1 : 0));
                }
            }
        }
        return targetIndices.size() -
               (dp[n2] == numeric_limits<double>::infinity()
                    ? 0
                    : static_cast<int>(dp[n2]));
    }
};
",1420078892
fallen_08,fallen_08,357,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int INF = 1e9 + 7;
        vector<int> vt = {n, x, y};

        vector<vector<int>> arr1(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            arr1[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                arr1[i][j] = (arr1[i - 1][j - 1] + arr1[i - 1][j]) % INF;
            }
        }

        vector<vector<int>> arr2(n + 1, vector<int>(x + 1, 0));
        arr2[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                arr2[i][j] = (arr2[i - 1][j - 1] + (1LL * j * arr2[i - 1][j]) % INF) % INF;
            }
        }

        vector<long long> f(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            f[i] = (f[i - 1] * i) % INF;
        }

        long long ans = 0;
        for (int i = 1; i <= x; i++) {
            long long p = 1;
            for (int j = 0; j < i; j++) {
                p = (p * y) % INF;
            }
            ans = (ans + (1LL * arr1[x][i] % INF * arr2[n][i] % INF * f[i] % INF * p % INF) % INF) % INF;
        }

        return ans;
    }
};
",1420106566
fallen_08,fallen_08,357,3605,cpp,"class Solution {
public:
    int solve(int num) {
        for (int i = 1; i <= num; i++) {
            if ((i | (i + 1)) == num)
                return i;
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++)
            ans[i] = solve(nums[i]);
        return ans;
    }
};",1420015693
fallen_08,fallen_08,357,3611,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &nums)
    {
        vector<int> ans;
        for (auto it : nums)
        {
            vector<int> res;
            for (int i = 0; i < 32; ++i)
            {
                if (it & (1 << i))
                {
                    int newnum = it & ~(1 << i);
                    if ((newnum | (newnum + 1)) == it)
                        res.push_back(newnum);
                }
            }
            if (res.empty())
                ans.push_back(-1);
            else
            {
                int number = *min_element(res.begin(), res.end());
                ans.push_back(number);
            }
        }
        return ans;
    }
};
",1420085456
Krishna Sharma,ks27,358,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:

        m, n = len(pattern), len(source)

        dp = [float('inf') for _ in range(m + 1)]
        dp[0] = 0  
        present = [False for _ in range(n)]
        
        for idx in targetIndices:
            present[idx] = True

        for i in range(n):
            for j in range(m, 0, -1):
                if dp[j - 1] != float('inf') and source[i] == pattern[j - 1]:
                    dp[j] = min(dp[j - 1] + (0 if not present[i] else 1), dp[j])

        if dp[m] == float('inf'):
            return 0
        
        return len(targetIndices) - dp[m]
",1420087389
Krishna Sharma,ks27,358,3604,python3,"MODULO = 10**9 + 7
class Solution:
    def exponent(self, base: int, exp: int, mod: int) -> int:
        result = 1
        while exp > 0:
            if exp % 2 == 1:
                result = (result * base) % mod
            base = (base * base) % mod
            exp //= 2
        return result

    def conbinations(self, max_value: int) -> List[List[int]]:

        combinations = [[0] * (max_value + 1) for _ in range(max_value + 1)]
        for i in range(max_value + 1):
            combinations[i][0] = 1
            for j in range(1, i + 1):
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MODULO
        return combinations

    def stirling_numbers(self, total_performers: int, max_stages: int) -> List[List[int]]:
        stirling = [[0] * (max_stages + 1) for _ in range(total_performers + 1)]
        stirling[0][0] = 1
        for i in range(1, total_performers + 1):
            for j in range(1, max_stages + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MODULO
        return stirling

    def compute_factorials(self, max_value: int) -> List[int]:
        factorials = [1] * (max_value + 1)
        for i in range(1, max_value + 1):
            factorials[i] = (factorials[i - 1] * i) % MODULO
        return factorials

    def numberOfWays(self, num_performers: int, num_stages: int, max_score: int) -> int:
        # intermediate_values = [num_performers, num_stages, max_score]
        combinations = self.conbinations(num_stages)
        stirling_numbers = self.stirling_numbers(num_performers, num_stages)
        factorials = self.compute_factorials(num_stages)

        total_ways = 0
        for stages_count in range(1, num_stages + 1):
            score_power = self.exponent(max_score, stages_count, MODULO)
            total_ways = (
                total_ways + combinations[num_stages][stages_count] *
                stirling_numbers[num_performers][stages_count] % MODULO *
                factorials[stages_count] % MODULO *
                score_power % MODULO
            ) % MODULO
        
        return total_ways",1420119677
Krishna Sharma,ks27,358,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1 for _ in range(n)] 

        for i in range(n):
            curr = nums[i]
            for x in range(curr): 
                if x | (x + 1) == curr:
                    ans[i] = x
                    break  
        return ans",1419998544
Krishna Sharma,ks27,358,3611,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        
        n = len(nums)
        res = [-1 for _ in range(n)]
        for i in range(n):
            curr = float('inf')
            flag = False
            for j in range(32):
                if nums[i] & (1 << j):
                    x = nums[i] & ~(1 << j)
                    if x | (x + 1) == nums[i]:
                        curr = min(curr, x)
                        flag = True

            if flag: res[i] = curr 
        return res
",1420101879
JosephMother,JosephMother,359,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        n, m = len(source), len(pattern)
        dp = [[-10**10] * (m + 1) for _ in range(n + 1)]
        dp[n][m] = 0
        for i in range(n, -1, -1):
            for j in range(m, -1, -1):
                if i == n and j == m:
                    continue
                if i < n and j < m and source[i] == pattern[j]:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j + 1])
                
                if i < n and i in targetIndices:
                    dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j])
                
                if i < n:
                    dp[i][j] = max(dp[i][j], dp[i + 1][j])
        
        return dp[0][0]",1420046367
JosephMother,JosephMother,359,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        
        fac = [1] * (max(n, x) + 1)
        for i in range(2, max(n, x) + 1):
            fac[i] = fac[i - 1] * i % MOD
        
        m = max(x, n)
        sn = [[0] * (m + 1) for _ in range(m + 1)]
        for i in range(n + 1):
            sn[i][0] = 1 if i == 0 else 0
            sn[i][i] = 1
        
        for i in range(1, n + 1):
            for j in range(1, min(i, x + 1)):
                sn[i][j] = (sn[i - 1][j - 1] + j * sn[i - 1][j]) % MOD
        
        ans = 0
        for i in range(1, x + 1):
            ans += ( comb(x, i) * sn[n][i] * fac[i] * pow(y, i, MOD)) % MOD
            ans %= MOD
        
        return ans",1420107591
JosephMother,JosephMother,359,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                b = bin(num)[2:]
                zero = -1
                for i in range(len(b)-1, -1, -1):
                    if b[i] == ""0"":
                        zero = i
                        break

                b = b[0:zero+1] + '0' + b[zero+2:]
                ans.append(int(b, 2))
                
        return ans


        ",1420020998
JosephMother,JosephMother,359,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                b = bin(num)[2:]
                zero = -1
                for i in range(len(b)-1, -1, -1):
                    if b[i] == ""0"":
                        zero = i
                        break

                b = b[0:zero+1] + '0' + b[zero+2:]
                ans.append(int(b, 2))
                
        return ans


        ",1420020610
Shivam Verma,verma_shivam,360,3487,java,"class Solution {

    private int[] initializeMinRemovals(int subsequenceLength) {
        int[] minRemovals = new int[subsequenceLength + 1];
        Arrays.fill(minRemovals, Integer.MAX_VALUE);
        minRemovals[0] = 0;
        return minRemovals;
    }

    private void calculateMinRemovals(String originalString, String subsequence, int[] minRemovals, boolean[] canRemove) {
        int originalLength = originalString.length();
        int subsequenceLength = subsequence.length();
        
        for (int currentIndex = 0; currentIndex < originalLength; currentIndex++) {
            for (int subsequenceIndex = subsequenceLength; subsequenceIndex > 0; subsequenceIndex--) {
                if (originalString.charAt(currentIndex) == subsequence.charAt(subsequenceIndex - 1) 
                        && minRemovals[subsequenceIndex - 1] != Integer.MAX_VALUE) {
                    minRemovals[subsequenceIndex] = Math.min(minRemovals[subsequenceIndex], 
                        minRemovals[subsequenceIndex - 1] + (canRemove[currentIndex] ? 1 : 0));
                }
            }
        }
    }

    public int maxRemovals(String originalString, String subsequence, int[] removableIndices) {
        int originalLength = originalString.length();
        int subsequenceLength = subsequence.length();
        int[] minRemovals = initializeMinRemovals(subsequenceLength);
        boolean[] canRemove = createRemovableArray(originalLength, removableIndices);
        
        calculateMinRemovals(originalString, subsequence, minRemovals, canRemove);
        
        return calculateMaximumRemovals(removableIndices.length, minRemovals[subsequenceLength]);
    }

    private boolean[] createRemovableArray(int originalLength, int[] removableIndices) {
        boolean[] canRemove = new boolean[originalLength];
        for (int index : removableIndices) {
            canRemove[index] = true;
        }
        return canRemove;
    }

    private int calculateMaximumRemovals(int totalRemovals, int requiredRemovals) {
        return totalRemovals - (requiredRemovals == Integer.MAX_VALUE ? 0 : requiredRemovals);
    }
}
",1420074955
Shivam Verma,verma_shivam,360,3604,java,"public class Solution {
    private static final int MOD_VALUE = 1000000007;

    public int numberOfWays(int performers, int stages, int maxScore) {
        int[] inputData = {performers, stages, maxScore};

        long[][] combinations = computeCombinations(stages);
        long[] factorials = generateFactorials(stages);
        long[][] stirlingNumbers = calculateStirlingNumbers(performers, stages);

        return computeTotalWays(performers, stages, maxScore, combinations, stirlingNumbers, factorials);
    }

    private long[][] computeCombinations(int stages) {
        long[][] combination = new long[stages + 1][stages + 1];
        for (int i = 0; i <= stages; i++) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD_VALUE;
            }
        }
        return combination;
    }

    private long[] generateFactorials(int stages) {
        long[] factorials = new long[stages + 1];
        factorials[0] = 1;
        for (int i = 1; i <= stages; i++) {
            factorials[i] = (factorials[i - 1] * i) % MOD_VALUE;
        }
        return factorials;
    }

    private int computeTotalWays(int performers, int stages, int maxScore, 
                                  long[][] combinations, long[][] stirlingNumbers, long[] factorials) {
        long totalWays = 0;
        for (int k = 1; k <= stages; k++) {
            long scoreMultiplier = computeScoreMultiplier(maxScore, k);
            totalWays = (totalWays + calculateContribution(combinations, stirlingNumbers, factorials, performers, k, scoreMultiplier)) % MOD_VALUE;
        }
        return (int) totalWays;
    }

    private long calculateContribution(long[][] combinations, long[][] stirlingNumbers, long[] factorials, 
                                       int performers, int k, long scoreMultiplier) {
        return combinations[combinations.length - 1][k] * stirlingNumbers[performers][k] % MOD_VALUE 
               * factorials[k] % MOD_VALUE * scoreMultiplier % MOD_VALUE;
    }

    private long computeScoreMultiplier(int maxScore, int k) {
        long multiplier = 1;
        for (int p = 0; p < k; p++) {
            multiplier = (multiplier * maxScore) % MOD_VALUE;
        }
        return multiplier;
    }

    private long[][] calculateStirlingNumbers(int performers, int stages) {
        long[][] stirling = new long[performers + 1][stages + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= performers; i++) {
            for (int j = 1; j <= stages; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD_VALUE + stirling[i - 1][j - 1]) % MOD_VALUE;
            }
        }
        return stirling;
    }
}
",1420120969
Shivam Verma,verma_shivam,360,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> primeList) {
        int totalPrimes = primeList.size();
        int[] finalResult = new int[totalPrimes];

        for (int currentPosition = 0; currentPosition < totalPrimes; currentPosition++) {
            finalResult[currentPosition] = -1;
            int primeValue = primeList.get(currentPosition);
            for (int potentialAnswer = 0; potentialAnswer < primeValue; potentialAnswer++) {
                if ((potentialAnswer | (potentialAnswer + 1)) == primeValue) {
                    finalResult[currentPosition] = potentialAnswer;
                    break;
                }
            }
        }

        return finalResult;
    }
}",1419997750
Shivam Verma,verma_shivam,360,3611,java,"class Solution 
{
  private boolean isValidValue(int potentialValue, int targetNumber) {
        return (potentialValue >= 0) && ((potentialValue | (potentialValue + 1)) == targetNumber);
    }  
     private int clearBitAtPosition(int number, int bitPosition) {
        return number & ~(1 << bitPosition);
    }
public int[] minBitwiseArray(List<Integer> primeList) {
        int length = primeList.size();
        int[] resultArray = new int[length];
    for (int index = 0; index < length; index++) {
            int primeNumber = primeList.get(index);
            resultArray[index] = determineSmallestValidValue(primeNumber);
        } return resultArray;
    }

    

   

    private boolean isBitSet(int number, int position) {
        return ((number >> position) & 1) == 1;
    }

    private int determineSmallestValidValue(int number) {
        int smallestValue = Integer.MAX_VALUE;
  boolean validValueExists = false;

        for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
            if (isBitSet(number, bitPosition)) {
                int modifiedValue = clearBitAtPosition(number, bitPosition);
                
 if (isValidValue(modifiedValue, number)) {
                    if (modifiedValue < smallestValue) {
 smallestValue = modifiedValue;
                        validValueExists = true;
 }      }  } }

        return validValueExists ? smallestValue : -1;
    }
}
",1420057277
Arjun Nayak,Arjun_Nayak1234,361,3487,cpp,"class Solution {
public:
   int n,m;
   int solve(string sc, string pt, vector<int>& targetIndices){
    vector<int> dp(m + 1,INT_MAX);
        dp[0] = 0;
        
        vector<bool> checkTar(n, false);
        for (int idx : targetIndices) {
            checkTar[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (sc[i] == pt[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (checkTar[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] != INT_MAX? dp[m] :0);
   }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
         n = source.length();
         m = pattern.length();
        return solve(source,pattern,targetIndices);
    }
};",1420101681
Arjun Nayak,Arjun_Nayak1234,361,3604,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;
    using ll=long long;
    int solve(int n, int tp, int multiplier){
         vector<vector<int>> dp(tp + 1, vector<int>(tp + 1, 0));
        for (int i = 0; i <= tp; i++) {
            dp[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> dpNum(n + 1, vector<int>(tp + 1, 0));
        dpNum[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= tp; ++j) {
                dpNum[i][j] = (1LL * j * dpNum[i - 1][j] + dpNum[i - 1][j - 1]) % MOD;
            }
        }
        vector<int> fac(tp + 1, 1);
        for (int i = 1; i <= tp; ++i) {
            fac[i] = (1LL * fac[i - 1] * i) % MOD;
        }
        ll ways = 0;
        for (int k = 1; k <= tp; ++k) {
            ll multi = 1;
            for (int i = 0; i < k; ++i) {
                multi = (multi * multiplier) % MOD;
            }
            ways = (ways + (1LL * dp[tp][k] * dpNum[n][k] % MOD * fac[k] % MOD * multi % MOD)) % MOD;
        }
        return ways;
    }
    int numberOfWays(int n, int totalParts, int multiplier) {
       return solve(n, totalParts, multiplier);
    }
};",1420121176
Arjun Nayak,Arjun_Nayak1234,361,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         vector<int> result(nums.size(), -1);
    
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 0; j <= nums[i]; j++) {
            if ((j | (j + 1)) == nums[i]) {
                result[i] = j;
                break;
            }
        }
    }
    
    return result;
    }
};",1419995065
Arjun Nayak,Arjun_Nayak1234,361,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputNumbers) {
        int totalNumbers = inputNumbers.size();
        vector<int> resultArray(totalNumbers);
        
        for (int index = 0; index < totalNumbers; index++) {
            int currentNum = inputNumbers[index];
            int smallestCandidate = INT_MAX;
            bool isCandidateFound = false;
            
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (((currentNum >> bitPosition) & 1) == 1) {
                    int possibleAnswer = currentNum & ~(1 << bitPosition);
                    if (possibleAnswer < 0) continue;
                    if ((possibleAnswer | (possibleAnswer + 1)) == currentNum) {
                        if (possibleAnswer < smallestCandidate) {
                            smallestCandidate = possibleAnswer;
                            isCandidateFound = true;
                        }
                    }
                }
            }
            
            if (isCandidateFound) {
                resultArray[index] = smallestCandidate;
            } else {
                resultArray[index] = -1;
            }
        }
        
        return resultArray;
    }
};
",1420051864
newmamuhere,newmamuhere,362,3487,cpp,"class Solution {
public:
    int countGreaterOrEqual(set<int>& s, int x) {
        auto it = s.lower_bound(x);
        if (it == s.end()) return 0;
        return distance(it, s.end());
    }
    
    int solve(int i, int j, set<int>& se, string &s, string &p, vector<vector<int>>& dp) {
        if (j == p.size()) return countGreaterOrEqual(se, i);
        if (i >= s.size()) return INT_MIN;

        // If already computed, return the stored value
        if (dp[i][j] != -1) return dp[i][j];

        int ans = INT_MIN;
        
        // Check if 'i' is in the set and can be removed
        if (se.find(i) != se.end()) {
            ans = max(ans, 1 + solve(i + 1, j, se, s, p, dp));
        }
        
        // Match current character in source and pattern
        if (s[i] == p[j]) {
            ans = max(ans, solve(i + 1, j + 1, se, s, p, dp));
        } else {
            ans = max(ans, solve(i + 1, j, se, s, p, dp));
        }
        
        // Store the result in the DP table
        return dp[i][j] = ans;
    }

    int maxRemovals(string source, string pattern, vector<int>& t) {
        set<int> se;
        for (int i = 0; i < t.size(); i++) se.insert(t[i]);

        // Initialize DP table with -1 (uncomputed state)
        vector<vector<int>> dp(source.size(), vector<int>(pattern.size(), -1));
        
        // Start solving from the beginning of both source and pattern
        return solve(0, 0, se, source, pattern, dp);
    }
};
",1420084831
newmamuhere,newmamuhere,362,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;

    vector<vector<ll>> computeBinomialCoefficients(ll maxVal) {
        vector<vector<ll>> binom(maxVal + 1, vector<ll>(maxVal + 1, 0));
        for (ll i = 0; i <= maxVal; i++) {
            binom[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;
            }
        }
        return binom;
    }

    vector<vector<ll>> computeStirlingNumbers(ll n, ll maxVal) {
        vector<vector<ll>> stirling(n + 1, vector<ll>(maxVal + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= maxVal; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        return stirling;
    }

    vector<ll> computeFactorials(ll maxVal) {
        vector<ll> factorial(maxVal + 1, 1);
        for (ll i = 1; i <= maxVal; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        return factorial;
    }

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> binomial = computeBinomialCoefficients(x);
        vector<vector<ll>> stirling = computeStirlingNumbers(n, x);
        vector<ll> factorial = computeFactorials(x);

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + binomial[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420121195
newmamuhere,newmamuhere,362,3605,cpp,"class Solution {
public:

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 2) {
                ans.push_back(-1);
            }
            else{
                int n=nums[i] ,y=n,k=0;
                while(y>0){
                    if((y&1)==0)  break;
                     k++;
                     y=(y>>1);
                }
                k--;
                //cout<<k<<endl;
                int d=0,j=0;
                while(n>0){
                      if(k!=j) {d=(d|((n&1)<<j));}
                      j++;
                      n=(n>>1);
                }
                ans.push_back(d);
            }
        }
        return ans;
    }
};
",1420037178
newmamuhere,newmamuhere,362,3611,cpp,"class Solution {
public:
    bool all1(int n) {
        while (n > 0) {
            if ((n & 1) == 0) return false;
            n >>= 1; // Simplified shift operation
        }
        return true;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 2) {
                ans.push_back(-1);
            }
            else{
                int n=nums[i] ,y=n,k=0;
                while(y>0){
                    if((y&1)==0)  break;
                     k++;
                     y=(y>>1);
                }
                k--;
                //cout<<k<<endl;
                int d=0,j=0;
                while(n>0){
                      if(k!=j) {d=(d|((n&1)<<j));}
                      j++;
                      n=(n>>1);
                }
                ans.push_back(d);
            }
        }
        return ans;
    }
};
",1420036336
Tanuj Vats,tanuj_1099,363,3487,cpp,"class Solution {
public:
    vector<vector<long long>> dp;
    long long rec(string& s, string& p, int i, int j,set<int>& mp){
        if(j==p.size()){
            return 0;
        }
        if(i==s.size()){
            return INT_MAX;
        }
        long long ans=0;
       if(dp[i][j]!=-1){
           return dp[i][j];
       }
       ans=rec(s,p,i+1,j,mp);
        if(s[i]==p[j]){
            if(mp.find(i)!=mp.end()){
                ans=min(ans,1+rec(s,p,i+1,j+1,mp));
            }
            else
                ans=min(ans,rec(s,p,i+1,j+1,mp));
        }
        
        
        return dp[i][j]=ans;
    }
    int maxRemovals(string s, string p, vector<int>& t) {
         dp.resize(s.size(),vector<long long>(p.size(),-1));
       set<int> mp;
        for(auto it:t){
            mp.insert(it);
        }
        
        return t.size()-rec(s,p,0,0,mp);
    }
};",1420042326
Tanuj Vats,tanuj_1099,363,3604,cpp,"class Solution {

public:

     static const int M = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
     vector<vector<long long>> c(x + 1, vector<long long>(x + 1, 0));
     vector<vector<long long>> s(n + 1,vector<long long>(x + 1, 0));
     vector<long long> fct(x + 1, 1); 
        long long t = 0;
        for (int i = 1; i <= x; ++i) {
            fct[i] = (1LL * fct[i - 1] * i) % M;
        }
    
        

        s[0][0] = 1;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % M;
            }
        }

        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % M;
            }
        }
        for (int k = 1; k <= x; ++k) {
            long long yp = 1;
            for (int i = 0; i < k; ++i) {
                yp = (yp * y) % M;
            }
            t = (t + (c[x][k] * s[n][k] % M * fct[k] % M * yp % M)) % M;
        }

        return t;
    }

};",1420115764
Tanuj Vats,tanuj_1099,363,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        vector<int> ans;
        for(auto it:nums){
            if(it==2){
            ans.push_back(-1);
            }
            else{
                int c=0;
                for(int i=0;i<32;i++){
                    if(((1<<i)&it)>0){
                        c++;
                    }else{
                        i=33;
                    }
                }
                c--;
                //cout<<c<<endl;
                ans.push_back(it xor 1<<c);
            }
        }
        
        return ans;
    }
};",1420014734
Tanuj Vats,tanuj_1099,363,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        vector<int> ans;
        for(auto it:nums){
            if(it==2){
            ans.push_back(-1);
            }
            else{
                int c=0;
                for(int i=0;i<32;i++){
                    if(((1<<i)&it)>0){
                        c++;
                    }else{
                        i=33;
                    }
                }
                c--;
                //cout<<c<<endl;
                ans.push_back(it xor 1<<c);
            }
        }
        
        return ans;
    }
};",1420014377
rck11,rck11,364,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        t_set = set(targetIndices)
        INF = n + 1 
        dp = [[INF] * (m + 1) for _ in range(n + 1)]
        for i in range(n + 1):
            dp[i][0] = 0  
        for i in range(1, n + 1):
            for j in range(0, min(i, m) + 1):
                if j > 0 and source[i - 1] == pattern[j - 1]:
                    cost = 1 if (i - 1) in t_set else 0
                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1] + cost)
                else:
                    
                    dp[i][j] = dp[i - 1][j]

        required_in_T = dp[n][m]
        if required_in_T > len(targetIndices):
            return 0
        max_removals = len(targetIndices) - required_in_T
        return max_removals",1420122631
rck11,rck11,364,3604,python3,"MOD = 10**9 +7


class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        max_nx = max(n,x)
        fact = [1]*(max_nx+1)
        inv_fact = [1] *(max_nx+1)
        for i in range(1,max_nx +1):
            fact[i] = fact[i-1]*i%MOD
        inv_fact[max_nx] = pow(fact[max_nx], MOD - 2, MOD)
        for i in range(max_nx - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        def comb(n, k):
            if k < 0 or k > n:
                return 0
            return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD
        S = [ [0] * (n + 1) for _ in range(n + 1) ]
        S[0][0] = 1

        for i in range(1, n + 1):
            for k in range(1, i + 1):
                S[i][k] = (k * S[i - 1][k] + S[i - 1][k - 1]) % MOD

        total_ways = 0
        min_k = min(n, x)
        for k in range(1, min_k + 1):
            c = comb(x, k)
            k_fact = fact[k]
            S_nk = S[n][k]
            yk = pow(y, k, MOD)
            term = c * k_fact % MOD * S_nk % MOD * yk % MOD
            total_ways = (total_ways + term) % MOD
        return total_ways

        ",1420097158
rck11,rck11,364,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i =0;i< n;i++){
            ans[i] = findMinimal(nums.get(i));
        }
        return ans;
    }


    private int findMinimal(int a){
        List<Integer> bits = getbits(a);
        int min= Integer.MAX_VALUE;
        for(int i : bits){
            long mask = ~(1L<<i);
            int temp = (int)(a&mask);

            if(temp >=0 && ((temp | (temp+1))==a)){
                if(temp< min){
                    min = temp;
                }
            }
        }
          if(min !=Integer.MAX_VALUE ){
                return min;
            }
            else
            return -1;
    }


    private List<Integer> getbits(int a){
        List<Integer> bits = new ArrayList<>();
        for(int k =31;k>=0;k--){
            if(((a>>>k)&1)==1){
                bits.add(k);
            }
        }
        return bits;
    }
}",1420047138
rck11,rck11,364,3611,java,"class Solution {
        public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i =0;i< n;i++){
            ans[i] = findMinimal(nums.get(i));
        }
        return ans;
    }


    private int findMinimal(int a){
        List<Integer> bits = getbits(a);
        int min= Integer.MAX_VALUE;
        for(int i : bits){
            long mask = ~(1L<<i);
            int temp = (int)(a&mask);

            if(temp >=0 && ((temp | (temp+1))==a)){
                if(temp< min){
                    min = temp;
                }
            }
        }
          if(min !=Integer.MAX_VALUE ){
                return min;
            }
            else
            return -1;
    }


    private List<Integer> getbits(int a){
        List<Integer> bits = new ArrayList<>();
        for(int k =31;k>=0;k--){
            if(((a>>>k)&1)==1){
                bits.add(k);
            }
        }
        return bits;
    }
}",1420064494
avishaan,avishaan,365,3487,cpp,"class Solution {
public:
    int helper(int i, int j, string &source, string &pattern, vector<int> &index, vector<vector<int>> &dp, vector<int> &visited, vector<int> &suff){
        if(j == pattern.length())
            return suff[i];
        if(i == source.length())
            return -1e8;
        if(dp[i][j] != -1e9)
            return dp[i][j];
        dp[i][j] = -1e8;
        dp[i][j] = helper(i + 1, j, source, pattern, index, dp, visited, suff);
        if(dp[i][j] != -1e8 && visited[i])
            dp[i][j] += 1;
        if(source[i] == pattern[j])
            dp[i][j] = max(dp[i][j], helper(i + 1, j + 1, source, pattern, index, dp, visited, suff));
        return dp[i][j];
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<vector<int>>dp(n, vector<int>(m, -1e9));
        vector<int>visited(n, 0), suff(n + 1, 0);
        for(auto &index:targetIndices)
            visited[index] = 1;
        for(int i = n - 1; i >= 0; i--)
            suff[i] = suff[i + 1] + visited[i];
        return helper(0, 0, source, pattern, targetIndices, dp, visited, suff);
    }
};",1420122722
avishaan,avishaan,365,3604,cpp,"using ll = long long;
const int maxN = 1000, mod = 1e9 + 7;

vector<vector<ll>> dp(maxN + 1, vector<ll>(maxN + 1, 0));
vector<ll> fact(maxN + 1, 1), invFact(maxN + 1, 1);

ll binaryExp(ll a, ll b){
    ll ans = 1;
    while(b){
        if(b & 1)
            ans = (ans * a) % mod;
        a = (a * a) % mod;
        b /= 2;
    }
    return ans;
}

void precompute() {
    dp[0][0] = 1;
    for (int n = 1; n <= maxN; ++n)
        dp[n][0] = 0;

    for (int n = 1; n <= maxN; ++n) {
        for (int k = 1; k <= n; ++k) 
            dp[n][k] = (k * dp[n - 1][k] + dp[n - 1][k - 1]) % mod;
    }

    for (int i = 2; i <= maxN; ++i){
        fact[i] = (fact[i - 1] * i) % mod;
        invFact[i] = binaryExp(fact[i], mod - 2);
    }
}

ll nCr(ll n, ll r){
    if(r == 0 || r == n)
        return 1;
    if(r < 0 || r > n)
        return 0;
    return (((fact[n] * invFact[r]) % mod) * invFact[n - r]) % mod;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(dp[0][0] == 0)
            precompute();
        vector<ll>pow(x + 1, 1);
        for(ll i = 1; i <= x; i++)
            pow[i] = (pow[i - 1] * y) % mod;
        ll ans = 0;
        for(ll i = 1; i <= x; i++){
            ll add = ((nCr(x, i) * dp[n][i]) % mod * pow[i]) % mod;
            add = (add * fact[i]) % mod;
            ans = (ans + add) % mod;
        }
        return ans;
    }
};",1420081842
avishaan,avishaan,365,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n, -1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < nums[i]; j++){
                int ord = j | (j + 1);
                if(ord == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420002267
avishaan,avishaan,365,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n, -1);
        for(int i = 0; i < n; i++){
            if(nums[i] == 2)
                continue;
            int val = 0;
            bool result = true;
            for(int j = 1; j < 31; j++){
                if(result){
                    if((nums[i] >> j) & 1)
                        val += (1 << (j - 1));
                    else
                        result = false;
                }
                else{
                    if((nums[i] >> j) & 1)
                        val += (1 << j);
                }
            }
            ans[i] = val;
        }
        return ans;
    }
};",1420020682
gaoqiaoheimu,gaoqiaoheimu,366,3487,cpp,"class Solution {
public:

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = targetIndices.size();
        int p = pattern.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        for(int k=0;k<=n;k++) {
            for(int i=0;i<=m;i++) {
                dp[k][i] = -1;
            }
        }
        vector<bool> mp(n, false);
        for(auto c: targetIndices) {
            mp[c] = true;
        }
        dp[0][0] = 0;
        for(int k=0;k<n;k++) {
            for(int i=0;i<=m;i++) {
                if (dp[k][i] == -1) continue;
                if (mp[k]) {
                    if (dp[k + 1][i + 1] == -1) {
                        dp[k + 1][i + 1] = dp[k][i];
                    } else {
                        dp[k + 1][i + 1] = min(dp[k + 1][i + 1], dp[k][i]);
                    }
                }
                int c = dp[k][i];
                if (c == p) {
                    dp[k + 1][i] = p;
                    continue;
                }
                if (pattern[c] == source[k]) {
                    if (dp[k + 1][i] == -1) {
                        dp[k + 1][i] = dp[k][i] + 1;
                    } else {
                        dp[k + 1][i] = max(dp[k + 1][i], dp[k][i] + 1);
                    }
                } else {
                    if (dp[k + 1][i] == -1) {
                        dp[k + 1][i] = dp[k][i];
                    } else {
                        dp[k + 1][i] = max(dp[k + 1][i], dp[k][i]);
                    }
                }
            }
        }
        int ans = 0;
        for(int k=0;k<=n;k++) {
            for(int i=0;i<=m;i++) {
                if (dp[k][i] == p) {
                    ans = max(ans, i);
                }
            }
        }
        return ans;
    }
};",1420116601
gaoqiaoheimu,gaoqiaoheimu,366,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        long long mod = 1e9 + 7;
        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));
        dp[1][1] = x;
        for(int k=1;k<n;k++) {
            for(int i=1;i<=min(k, x);i++) {
                dp[k + 1][i] += dp[k][i] * i;
                dp[k + 1][i] %= mod;
                if (i < x) {
                    dp[k + 1][i + 1] += dp[k][i] * (x - i);
                    dp[k + 1][i + 1] %= mod;
                }
            }
        }
        long long now = y;
        long long ans = 0;
        for(int k=1;k<=x;k++) {
            ans += dp[n][k] * now;
            ans %= mod;
            now *= y;
            now %= mod;
        }
        return ans;
    }
};",1420036416
gaoqiaoheimu,gaoqiaoheimu,366,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(auto c: nums) {
            if (c == 2) {
                ans.push_back(-1);
            } else {
                vector<int> tmp;
                while (c) {
                    tmp.push_back(c % 2);
                    c /= 2;
                }
                int m = tmp.size();
                for(int k=0;k<m-1;k++) {
                    if (tmp[k + 1] == 1) {
                        tmp[k] = 0;
                    } else {
                        break;
                    }
                }
                reverse(tmp.begin(), tmp.end());
                int re = 0;
                for(int k=0;k<m;k++) {
                    re *= 2;
                    re += tmp[k];
                }
                ans.push_back(re - 1);
            }
        }
        return ans;
    }
};",1420004358
gaoqiaoheimu,gaoqiaoheimu,366,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(auto c: nums) {
            if (c == 2) {
                ans.push_back(-1);
            } else {
                vector<int> tmp;
                while (c) {
                    tmp.push_back(c % 2);
                    c /= 2;
                }
                int m = tmp.size();
                for(int k=0;k<m-1;k++) {
                    if (tmp[k + 1] == 1) {
                        tmp[k] = 0;
                    } else {
                        break;
                    }
                }
                reverse(tmp.begin(), tmp.end());
                int re = 0;
                for(int k=0;k<m;k++) {
                    re *= 2;
                    re += tmp[k];
                }
                ans.push_back(re - 1);
            }
        }
        return ans;
    }
};",1420003991
leetcode_456745,leetcode_456745,367,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& ind) {
        int lenS = s.size(),  lenP = p.size();
        vector<int> dp(lenP + 1, numeric_limits<int>::max());
        vector<bool> vis(lenS, false);
        for (int i : ind) vis[i] = true;
        dp[0] = 0;
        for (int i = 0; i < lenS; ++i) {
            for (int j = lenP; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != numeric_limits<int>::max()) dp[j] = min(dp[j], dp[j - 1] + (vis[i] ? 1 : 0));
            }
        }
        return ind.size() - (dp[lenP] == numeric_limits<int>::max() ? 0 : dp[lenP]);
    }
};",1420095181
leetcode_456745,leetcode_456745,367,3604,cpp,"class Solution {
public:
    const long long MOD = 1e9 + 7;

    long long numberOfWays(long long n, long long x, long long y,long long totalWays = 0) {
        vector<vector<long long>> dp1(x + 1, vector<long long>(x + 1, 0));
        vector<vector<long long>> dp2(n + 1, vector<long long>(x + 1, 0));
        vector<long long> factorials = calculateFactorials(x);
        
        dp2[0][0] = 1;
        for (long long i = 1; i <= n; ++i) {
            for (long long j = 1; j <= x; ++j)  dp2[i][j] = (j * dp2[i - 1][j] + dp2[i - 1][j - 1]) % MOD;
        }
        
        for (long long i = 0; i <= x; ++i) {
            dp1[i][0] = 1;
            for (long long j = 1; j <= i; ++j)   dp1[i][j] = (dp1[i - 1][j - 1] + dp1[i - 1][j]) % MOD;
        }
        for (long long k = 1; k <= x; ++k) {
            totalWays = (totalWays + dp1[x][k] * dp2[n][k] % MOD * factorials[k] % MOD * inv(y, k,MOD)) % MOD;
        }
        return totalWays;
    }

private:
    vector<long long> calculateFactorials(long long limit) {
        vector<long long> factorials(limit + 1, 1);
        for (long long i = 1; i <= limit; ++i) {
            factorials[i] = factorials[i - 1] * i % MOD;
        }
        return factorials;
    }
    long long inv(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
};",1420122795
leetcode_456745,leetcode_456745,367,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto ele:nums){
            int temp = -1;
            for(int i = 1;i<ele;i++){
                int num = i | (i + 1);
                if(num == ele){
                  temp = i;
                  break;
                }
            };
                res.push_back(temp);
        }
        return res;
    }
};",1420000023
leetcode_456745,leetcode_456745,367,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums,vector<int> ans = {}) {
        for (auto ele:nums) {
            int  res = numeric_limits<int>::max();
            for (int bit = 0; bit <= 30; bit++) {
                if (ele & (1 << bit)) {
                    int temp = ele & ~(1 << bit);
                    if ((temp | (temp + 1)) == ele)  res = min(res, temp);
                }
            }
            ans.push_back((res == numeric_limits<int>::max()) ? -1 : res);
        }
        
        return ans;
    }
};",1420067799
Anshuman Tripathi,anshumantripathi878,368,3487,cpp,"class Solution {
public:
    int solve(const string& source, const string& pattern, const vector<int>& targetIndices) {
    int sourceLength = source.length();
    int patternLength = pattern.length();

    vector<int> minTargets(patternLength + 1, numeric_limits<int>::max());
    minTargets[0] = 0;

    vector<bool> targetCheck(sourceLength, false);
    for (int pos : targetIndices) {
        targetCheck[pos] = true;
    }

    for (int i = 0; i < sourceLength; i++) {
        for (int j = patternLength; j > 0; j--) {
            if (source[i] == pattern[j - 1] && minTargets[j - 1] != numeric_limits<int>::max()) {
                minTargets[j] = min(minTargets[j], minTargets[j - 1] + (targetCheck[i] ? 1 : 0));
            }
        }
    }

    return targetIndices.size() - (minTargets[patternLength] == numeric_limits<int>::max() ? 0 : minTargets[patternLength]);
}

int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
    return solve(source, pattern, targetIndices);
}

};",1420123215
Anshuman Tripathi,anshumantripathi878,368,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

vector<vector<int>> calculateCombinations(int p) {
    vector<vector<int>> C(p + 1, vector<int>(p + 1, 0));
    for (int i = 0; i <= p; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
    return C;
}

vector<vector<int>> calculateStirling(int n, int p) {
    vector<vector<int>> S(n + 1, vector<int>(p + 1, 0));
    S[0][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= p; ++j) {
            S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
        }
    }
    return S;
}

vector<int> calculateFactorials(int p) {
    vector<int> F(p + 1, 1);
    for (int i = 1; i <= p; ++i) {
        F[i] = (1LL * F[i - 1] * i) % MOD;
    }
    return F;
}

int numberOfWays(int n, int p, int m) {
    auto C = calculateCombinations(p);
    auto S = calculateStirling(n, p);
    auto F = calculateFactorials(p);

    long long T = 0;
    for (int k = 1; k <= p; ++k) {
        long long P = 1;
        for (int i = 0; i < k; ++i) {
            P = (P * m) % MOD;
        }
        T = (T + (1LL * C[p][k] * S[n][k] % MOD * F[k] % MOD * P % MOD)) % MOD;
    }
    return T;
}
};",1420115343
Anshuman Tripathi,anshumantripathi878,368,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); 

    for (int i = 0; i < nums.size(); i++) {
        int target = nums[i];
        vector<int> candidates;

        
        for (int num = 0; num <= target; num++) {
            if ((num | (num + 1)) == target) {
                candidates.push_back(num);
                if (candidates.size() == 2) break; 
            }
        }

        
        if (!candidates.empty()) {
            ans[i] = candidates[0]; 
        }
    }

    return ans;

    }
};",1420005843
Anshuman Tripathi,anshumantripathi878,368,3611,cpp,"class Solution {
public:
    vector<int> solve(vector<int>& nums) {
    int sz = nums.size();
    vector<int> res(sz);
    
    for (int i = 0; i < sz; i++) {
        int n = nums[i];
        int minVal = numeric_limits<int>::max();
        bool found = false;
        
        for (int b = 0; b <= 30; b++) {
            if (((n >> b) & 1) == 1) {
                int c = n & ~(1 << b);
                if (c < 0) continue;
                if ((c | (c + 1)) == n) {
                    if (c < minVal) {
                        minVal = c;
                        found = true;
                    }
                }
            }
        }
        
        if (found) {
            res[i] = minVal;
        } else {
            res[i] = -1;
        }
    }
    
    return res;
}

vector<int> minBitwiseArray(vector<int>& nums) {
    return solve(nums);
}
};",1420056507
Abineth,abineth,371,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, t: List[int]) -> int:
        n,m=len(s),len(p)
        tar=[0 for i in range(n)]
        for i in t:
            tar[i]=1
        dp=[[int(1e18) for i in range(m+1)] for j in range(n+1)]
        @cache
        def solve(i,j):
            if j==m:
                return 0
            if i==n:
                return int(1e18)
            if dp[i][j]!=int(1e18):
                return dp[i][j]
            dp[i][j]=solve(i+1,j)
            if s[i]==p[j]:
                dp[i][j]=min(dp[i][j],solve(i+1,j+1)+tar[i])
            return dp[i][j]
        ans=len(t)
        res=solve(0,0)
        if res!=int(1e18):
            ans-=res
        return ans
",1420118158
Abineth,abineth,371,3604,python3,"mod=int(1e9)+7
def factorial(n):
    fac=[1 for i in range(n+1)]
    for i in range(2,n+1):
        fac[i]=(i*fac[i-1])%mod
    return fac
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        fac=factorial(x)
        ans=0
        dp=[[0 for i in range(min(n,x)+1)] for j in range(n+1)]
        dp[0][0]=1
        for i in range(1,n+1):
            for j in range(1,min(n,x)+1):
                dp[i][j]=(j*dp[i-1][j]+dp[i-1][j-1])%mod
        for k in range(1,min(n,x)+1):
            ans=(ans+(dp[n][k]%mod)*((fac[x]*pow(fac[x-k],mod-2,mod))%mod)*(pow(y,k,mod)%mod))%mod
        return ans",1420075275
Abineth,abineth,371,3605,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans=[]
        for i in a:
            if i==2:
                ans.append(-1)
            else:
                a = 0
                b = i
                while True:
                    if (a | (a + 1)) == b:
                        ans.append(a)
                        break
                    a += 1
        return ans",1420004980
Abineth,abineth,371,3611,python3,"class Solution:
    def minBitwiseArray(self, a: List[int]) -> List[int]:
        ans=[]
        for i in a:
            if i==2:
                ans.append(-1)
            else:
                bi=bin(i)[2:][::-1]
                t=0
                for j in bi:
                    if j=='1':
                        t+=1
                    else:
                        break
                ab='1'+'0'*(t-1)
                if ab=='':
                    ab='0'
                ans.append(i-int(ab,2))
        return ans",1420030684
Kumar Daksh,kumardaksshh,372,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, originalString: str, patternString: str, indexList: List[int]) -> int:
        sourceLength = len(originalString)
        patternLength = len(patternString)
        
        infArray = self.initializeInfArray(patternLength)
        targetFlags = self.markTargetIndices(sourceLength, indexList)
        
        self.updateInfArray(infArray, originalString, patternString, targetFlags)
        
        return self.calculateMaxRemovals(infArray, patternLength, indexList)
    
    def initializeInfArray(self, patternLength: int) -> List[int]:
        infArr = [float('inf')] * (patternLength + 1)
        infArr[0] = 0
        return infArr
    
    def markTargetIndices(self, sourceLength: int, indexList: List[int]) -> List[bool]:
        targetFlagList = [False] * sourceLength
        self.updateTargetFlags(targetFlagList, indexList)
        return targetFlagList
    
    def updateTargetFlags(self, targetFlagList: List[bool], indexList: List[int]):
        for idx in indexList:
            targetFlagList[idx] = True
    
    def updateInfArray(self, infArray: List[int], originalString: str, patternString: str, targetFlags: List[bool]):
        for currentIndex in range(len(originalString)):
            self.processCurrentCharacter(infArray, originalString, patternString, targetFlags, currentIndex)
    
    def processCurrentCharacter(self, infArray: List[int], originalString: str, patternString: str, targetFlags: List[bool], currentIndex: int):
        for patternIndex in range(len(patternString), 0, -1):
            if self.isPatternMatch(originalString, patternString, infArray, currentIndex, patternIndex):
                self.updateInfValue(infArray, patternIndex, targetFlags, currentIndex)
    
    def isPatternMatch(self, originalString: str, patternString: str, infArray: List[int], currentIndex: int, patternIndex: int) -> bool:
        return originalString[currentIndex] == patternString[patternIndex - 1] and infArray[patternIndex - 1] != float('inf')
    
    def updateInfValue(self, infArray: List[int], patternIndex: int, targetFlags: List[bool], currentIndex: int):
        infArray[patternIndex] = min(infArray[patternIndex], infArray[patternIndex - 1] + (1 if targetFlags[currentIndex] else 0))
    
    def calculateMaxRemovals(self, infArray: List[int], patternLength: int, indexList: List[int]) -> int:
        if self.isRemovalPossible(infArray, patternLength):
            return self.getMaxValidRemovals(indexList, infArray, patternLength)
        return len(indexList)
    
    def isRemovalPossible(self, infArray: List[int], patternLength: int) -> bool:
        return infArray[patternLength] != float('inf')
    
    def getMaxValidRemovals(self, indexList: List[int], infArray: List[int], patternLength: int) -> int:
        return len(indexList) - infArray[patternLength]
",1420061896
Kumar Daksh,kumardaksshh,372,3604,cpp,"class Solution {
private:
    long long MODULO() {
        return 1000000007;
    }

    vector<vector<long long>> generateCombinations(int limit) {
        vector<vector<long long>> comb(limit + 1, vector<long long>(limit + 1, 0));
        fillCombinationMatrix(comb, limit);
        return comb;
    }
    
    void fillCombinationMatrix(vector<vector<long long>>& comb, int limit) {
        for (int row = 0; row <= limit; ++row) {
            comb[row][0] = 1;
            for (int col = 1; col <= row; ++col) {
                comb[row][col] = (comb[row - 1][col - 1] + comb[row - 1][col]) % MODULO();
            }
        }
    }

    vector<vector<long long>> generatePartitions(int total, int parts) {
        vector<vector<long long>> partition(total + 1, vector<long long>(parts + 1, 0));
        partition[0][0] = 1;
        fillPartitionMatrix(partition, total, parts);
        return partition;
    }
    
    void fillPartitionMatrix(vector<vector<long long>>& partition, int total, int parts) {
        for (int i = 1; i <= total; ++i) {
            for (int j = 1; j <= parts; ++j) {
                partition[i][j] = (j * partition[i - 1][j] + partition[i - 1][j - 1]) % MODULO();
            }
        }
    }

    vector<long long> generateFactorials(int limit) {
        vector<long long> factorial(limit + 1, 1);
        fillFactorialArray(factorial, limit);
        return factorial;
    }

    void fillFactorialArray(vector<long long>& factorial, int limit) {
        for (int i = 1; i <= limit; ++i) {
            factorial[i] = (factorial[i - 1] * i) % MODULO();
        }
    }
    
    long long computePower(long long base, int exp, long long mod) {
        long long result = 1;
        for (int i = 0; i < exp; ++i) {
            result = (result * base) % mod;
        }
        return result;
    }

    long long computeTerm(long long comb, long long part, long long fact, long long pow, long long mod) {
        return (((comb * part) % mod * fact) % mod * pow) % mod;
    }

public:
    int numberOfWays(int total, int parts, int factor) {
        auto combinations = generateCombinations(parts);
        auto partitions = generatePartitions(total, parts);
        auto factorials = generateFactorials(parts);
        
        long long totalWays = 0;
        for (int count = 1; count <= parts; ++count) {
            long long powerTerm = computePower(factor, count, MODULO());
            long long term = computeTerm(combinations[parts][count], partitions[total][count], factorials[count], powerTerm, MODULO());
            totalWays = (totalWays + term) % MODULO();
        }
        
        return static_cast<int>(totalWays);
    }
};
",1420092042
Kumar Daksh,kumardaksshh,372,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputArray) {
        int sizeOfArray = inputArray.size();
        vector<int> resultArray(sizeOfArray, -1);
        
        for (int index = 0; index < sizeOfArray; ++index) {
            resultArray[index] = computeMinimum(inputArray[index]);
        }
        
        return resultArray;
    }

private:
    int computeMinimum(int primeNumber) {
        return calculateSmallestValue(primeNumber);
    }

    int calculateSmallestValue(int primeCandidate) {
        for (int candidate = 1; candidate <= primeCandidate; ++candidate) {
            if (checkBitwiseCondition(candidate, primeCandidate)) {
                return candidate;
            }
        }
        return returnInvalidValue();
    }

    bool checkBitwiseCondition(int num, int prime) {
        return performBitwiseOr(num, num + 1) == prime;
    }

    int performBitwiseOr(int a, int b) {
        return applyOrOperation(a, b);
    }

    int applyOrOperation(int firstValue, int secondValue) {
        return firstValue | secondValue;
    }

    int returnInvalidValue() {
        return -1;
    }
};
",1420010597
Kumar Daksh,kumardaksshh,372,3611,cpp,"#include <iostream>
#include <vector>
#include <algorithm>

class Solution {
private:
    // Helper function to process a single number
    int processNumber(int currentNumber) {
        std::vector<int> candidateList = findCandidates(currentNumber);
        return getMinCandidate(candidateList);
    }

    // Helper function to find valid candidates for a number
    std::vector<int> findCandidates(int currentNumber) {
        std::vector<int> candidateList;
        examineBits(currentNumber, candidateList);
        return candidateList;
    }

    // Helper function to examine the bits and find candidates
    void examineBits(int currentNumber, std::vector<int>& candidateList) {
        for (int bitIndex = 0; bitIndex < 32; ++bitIndex) {
            if (checkBit(currentNumber, bitIndex)) {
                int modifiedNumber = flipBit(currentNumber, bitIndex);
                if (checkCondition(modifiedNumber, currentNumber)) {
                    candidateList.push_back(modifiedNumber);
                }
            }
        }
    }

    // Helper function to check if the ith bit is set in the number
    bool checkBit(int number, int bitIndex) {
        return number & (1 << bitIndex);
    }

    // Helper function to flip the ith bit in the number
    int flipBit(int number, int bitIndex) {
        return number & ~(1 << bitIndex);
    }

    // Helper function to check if the modified number satisfies the condition
    bool checkCondition(int modifiedNumber, int originalNumber) {
        return (modifiedNumber | (modifiedNumber + 1)) == originalNumber;
    }

    // Helper function to return the minimum candidate or -1 if none exist
    int getMinCandidate(const std::vector<int>& candidateList) {
        if (candidateList.empty()) {
            return -1;
        }
        return *std::min_element(candidateList.begin(), candidateList.end());
    }

    // Helper function to process the entire array of numbers
    std::vector<int> processArray(const std::vector<int>& inputArray) {
        std::vector<int> results;
        for (int singleNumber : inputArray) {
            results.push_back(processNumber(singleNumber));
        }
        return results;
    }

public:
    // Main function that starts the process
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        return processArray(nums);
    }
};
",1420074152
daisek,daisek,373,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val target = targetIndices.toSet();
        var cache = IntArray(source.length) {0};
        for (j in source.indices) {
            var x = List<Int>(1) {0};
            if (j > 0) {
                x += cache[j-1];
            }
            if (j in target) {
                if (j > 0 && cache[j-1] >= 0) {
                    x += cache[j-1] + 1;
                } else if (j == 0) {
                     x += 1;
                }
            }
            cache[j] = x.max();
        }
            // println(cache.toList())
        for (i in pattern.indices) {
            var cur = IntArray(source.length) {-1};
            for (j in source.indices) {
                var x = List<Int>(1) {-1};
                if (j > 0) {
                    x += cur[j-1];
                    if (pattern[i] == source[j]) {
                        x += cache[j-1];
                    }
                } else if (i == 0) {
                    if (pattern[i] == source[j]) {
                        x += 0;
                    }
                }
                if (j in target) {
                    if (j > 0 && cur[j-1] >= 0) {
                        x += cur[j-1] + 1;
                    }
                }
                cur[j] = x.max();
            }
            // println(cur.toList())
            cache = cur;
        }
        return cache.last();
    }
}",1420056793
daisek,daisek,373,3604,kotlin,"class Solution {
    val modulo: Int = 1000000007;

    fun numberOfWays(n: Int, x: Int, y: Int): Int {
        val nums = numOfWays(n, x);
        val cs = c(x);
        val pows = pow(y, x);
        println(nums)
        println(cs)
        println(pows)
        var res = 0L;
        for (i in 1..x) {
            res += nums[i] * cs[i] % modulo * pows[i] % modulo;
            res %= modulo
        }
        return res.toInt();
    }

    fun numOfWays(n: Int, x: Int): List<Long> {
        var prev = MutableList<Long>(x+1) {0}
        prev[0] = 1
        for (i in 1..n) {
            var cur = MutableList<Long>(x + 1) {0}
            for (j in 1..x) {
                cur[j] = (prev[j-1] + prev[j]) % modulo * j % modulo
            }
            prev = cur;
        }
        return prev
    }

    fun inverse(a: Long) : Long {
        var t: Long = 0;
        var newt: Long = 1
        var r = modulo.toLong();
        var newr = a

        while (newr != 0L) {
            val quotient = r / newr;
            val a = newt;
            newt = (t - quotient * newt) ;
            t = a;
            val b = newr;
            newr = (r - quotient * newr);
            r = b;
        }
        if (t < 0){
            t = t + modulo
        }

        return t
    }

    fun c(x: Int): List<Long> {
        val res = MutableList<Long>(x+1) {1}
        for (i in 1..x) {
            res[i] = (res[i-1] * (x - i + 1)) % modulo * inverse(i.toLong()) % modulo;
        }
        return res;
    }

    fun pow(y: Int, x: Int): List<Long> {
        val res = MutableList<Long>(x+1) {1}
        for (i in 1..x) {
            res[i] = (res[i-1] * y) % modulo;
        }
        return res;
    }
}",1420118221
daisek,daisek,373,3605,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        return nums.map {minBitwise(it)}.toIntArray();
    }

    fun minBitwise(num: Int): Int {
        if (num == 2) {
            return -1;
        }
        var x = 1;
        var y = num;
        while (y % 2 == 1) {
            x *= 2;
            y /= 2;
        }
        return (y * 2 + 1) * x / 2 - 1;
    }
}",1420002915
daisek,daisek,373,3611,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        return nums.map {minBitwise(it)}.toIntArray();
    }

    fun minBitwise(num: Int): Int {
        if (num == 2) {
            return -1;
        }
        var x = 1;
        var y = num;
        while (y % 2 == 1) {
            x *= 2;
            y /= 2;
        }
        return (y * 2 + 1) * x / 2 - 1;
    }
}",1420003868
Krishna,Rookie0934,374,3487,cpp,"class Solution {
public:
    vector<int> vis;
    vector<vector<int>> dp;
    int f(string& s, string& t, int i, int j) {
        if(j == t.length()) return 0;
        if(i == s.length()) return INT_MAX;
        if(dp[i][j] != -1) return dp[i][j];
        int notpick = f(s, t, i+1, j);
        int pick = INT_MAX;
        if(s[i] == t[j]) {
            int x = 0;
            if(vis[i]) x = 1;
            int y = f(s, t, i+1, j+1);
            if(y != INT_MAX) pick = x + y;
        }
        return dp[i][j] = min(pick, notpick);
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        vis.resize(n, 0);
        dp.resize(n, vector<int>(pattern.length(), -1));
        for(auto it: targetIndices) vis[it] = 1;
        int ans = f(source, pattern, 0, 0);
        if(ans == INT_MAX) ans = 0;
        return targetIndices.size() - ans;
    }
};",1420070143
Krishna,Rookie0934,374,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int mod = 1e9 + 7;
        vector<vector<long long>> nCr(x+1);
        for(int i=0; i<=x; i++) {
            nCr[i] = vector<long long>(i+1, 1);
            for(int j=1; j<i; j++) {
                nCr[i][j] = (nCr[i-1][j] + nCr[i-1][j-1]) % mod;
            }
        }
        vector<vector<long long>> v(n + 1, vector<long long>(x+1, 0));
        v[0][0] = 1;
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=x; j++) {
                v[i][j] = (v[i-1][j-1] + (j * 1LL * v[i-1][j]) % mod) % mod;
            }
        }
        long long fact = 1, pow = 1, ans = 0;
        for(int k=1; k<=x; k++) {
            fact *= k;
            fact %= mod;
            pow *= y;
            pow %= mod;
            // cout<<nCr[x][k]<<"" ""<<v[n][k]<<"" ""<<fact<<"" ""<<pow<<endl;
            ans += ((((((nCr[x][k] * v[n][k]) % mod ) * fact)) %mod) * pow) % mod;
            ans %= mod;
        }
        return ans;
    }
};",1420111971
Krishna,Rookie0934,374,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1e9);
        for(int i=0; i<n; i++) {
            for(int j=0; j<=1000; j++) {
                if((j | (j+1)) == nums[i]) ans[i] = min(ans[i], j);
            }
            if(ans[i] == 1e9) ans[i] = -1;
        }
        return ans;
    }
};",1420003508
Krishna,Rookie0934,374,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1e9);
        for(int i=0; i<n; i++) {
            int idx = 0, x = nums[i];
            if(nums[i] == 2) {
                ans[i] = -1;
                continue;
            }
            for(int j=1; j<32; j++) {
                if(((nums[i]>>j) & 1) == 0) {
                    idx = j;
                    x -= (1<<(j-1));
                    break;
                }
                // else x -= (1<<j);
            }
            // x -= (1 << idx);
            int res = nums[i] - 1;
            if((x | (x+1)) == nums[i]) res = min(res,x);
            if ((nums[i] & (nums[i] + 1)) == 0) res = min(res,(nums[i] >> 1));
            ans[i] = res;
        }
        return ans;
    }
};",1420040708
olegmak,olegmak,375,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        const int sz = source.size();
        const int psz = pattern.size();
        vector<bool> idx_set(sz);
        for (const int i : targetIndices) {
            idx_set[i] = true;
        }
        
        // vector<vector<int>> cache(sz, vector<int>(sz, -1));
        // auto solve = [&](auto&& solve, int idx1, int idx2) -> int {
        //     if (idx1 == sz) {
        //         return idx2 == psz ? 0 : -1;
        //     }
        //     int& cached = cache[idx1][idx2];
        //     if (cached != -1) {
        //         return cached;
        //     }
        //     int res = -1;
        //     const int r = solve(solve, idx1 + 1, idx2);
        //     if (r != -1) {
        //         res = max(res, (idx_set[idx1] ? 1 : 0) + r);
        //     }
        //     if (idx2 < psz && source[idx1] == pattern[idx2]) {
        //         const int r = solve(solve, idx1 + 1, idx2 + 1);
        //         if (r != -1) {
        //             res = max(res, r);
        //         }
        //     }
        //     return cached = res;
        // };
        // return solve(solve, 0, 0);

        vector<vector<int>> dp(sz + 1, vector<int>(sz + 1));
        for (int i = 0; i <= sz; ++i) {
            dp[sz][i] = i == psz ? 0 : -1;
        }
        for (int idx1 = sz - 1; idx1 >= 0; --idx1) {
            for (int idx2 = sz - 1; idx2 >= 0; --idx2) {
                int res = -1;
                const int r = dp[idx1 + 1][idx2];
                if (r != -1) {
                    res = max(res, (idx_set[idx1] ? 1 : 0) + r);
                }
                if (idx2 < psz && source[idx1] == pattern[idx2]) {
                    const int r = dp[idx1 + 1][idx2 + 1];
                    if (r != -1) {
                        res = max(res, r);
                    }
                }
                dp[idx1][idx2] = res;
            }
        }
        return dp[0][0];
    }
};",1420051936
olegmak,olegmak,375,3604,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
ll mod_pow(ll a, ll b) {
    if (b == 0) {
        return 1;
    }
    ll res = mod_pow(a, b / 2);
    res = res * res % MOD;
    if (b & 1) {
        res = res * a % MOD;
    }
    return res;
}
int s[1000 + 1][1000 + 1];
int fact[1000 + 1];
int fact_inv[1000 + 1];
struct Init {
    Init() {
        for (int i = 0; i <= 1000; ++i) {
            s[i][i] = 1;
        }
        for (ll i = 1; i <= 1000; ++i) {
            for (ll j = 1; j <= 1000; ++j) {
                s[i][j] = (j * s[i - 1][j] % MOD + s[i - 1][j - 1]) % MOD;
            }
        }
        fact[0] = 1;
        for (ll i = 1; i <= 1000; ++i) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        fact_inv[1000] = mod_pow(fact[1000], MOD - 2);
        for (ll i = 1000; i > 0; --i) {
            fact_inv[i - 1] = fact_inv[i] * i % MOD;
        }
    }
} init;
ll n_choose_k(ll n, ll k) {
    return (ll)fact[n] * fact_inv[k] % MOD * fact_inv[n - k] % MOD;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        ll res = 0;
        for (int band_cnt = 1; band_cnt <= x; ++band_cnt) {
            if (n >= band_cnt) {
                // cout << band_cnt << "" "" << s[n][band_cnt] << "" "" << n_choose_k(x, band_cnt) << "" "" << mod_pow(y, band_cnt) << ""\n"";
                res = (res + s[n][band_cnt] * n_choose_k(x, band_cnt) % MOD * fact[band_cnt] % MOD * mod_pow(y, band_cnt) % MOD) % MOD;
            }
        }
        return res;
    }
};",1420124671
olegmak,olegmak,375,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int sz = nums.size();
        vector<int> ans(sz, -1);
        for (int i = 0; i < sz; ++i) {
            for (int j = 0; j <= nums[i]; ++j) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419998420
olegmak,olegmak,375,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int sz = nums.size();
        vector<int> ans(sz, -1);
        for (int i = 0; i < sz; ++i) {
            int pos = -1;
            for (int j = 0; j < 32; ++j) {
                if (((unsigned)nums[i] & (1 << j)) == 0) {
                    break;
                }
                ++pos;
            }
            if (pos == -1) {
                ans[i] = -1;
                continue;
            }
            ans[i] = nums[i] - (1 << pos);
        }
        return ans;
    }
};",1420011120
Anurag Yadav,ECrdnAZlio,376,3487,golang,"package main

import (
	""math""
)

func maxRemovals(source string, pattern string, targetIndices []int) int {
	n := len(source)
	m := len(pattern)

	// Initialize dp array
	dp := make([]int, m+1)
	for i := range dp {
		dp[i] = math.MaxInt32 // Set initial value to a large number
	}
	dp[0] = 0 // 0 removals to match an empty pattern

	// Create a target set for fast lookup
	isTarget := make([]bool, n)
	for _, idx := range targetIndices {
		isTarget[idx] = true
	}

	// DP to find the minimum removals
	for i := 0; i < n; i++ {
		for j := m; j > 0; j-- {
			if source[i] == pattern[j-1] && dp[j-1] != math.MaxInt32 {
				// Update the DP state
				dp[j] = min(dp[j], dp[j-1]+boolToInt(isTarget[i]))
			}
		}
	}

	// Calculate the result
	if dp[m] == math.MaxInt32 {
		return len(targetIndices) // If pattern can't be formed
	}
	return len(targetIndices) - dp[m] // Max removals
}

// Helper function to convert boolean to integer
func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

// Helper function to find minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// // Example usage
// func main() {
// 	source := ""abcde""
// 	pattern := ""ace""
// 	targetIndices := []int{0, 1, 2, 3}

// 	result := maxRemovals(source, pattern, targetIndices)
// 	println(result) // Output should reflect the number of maximum removals possible.
// }
",1420057442
Anurag Yadav,ECrdnAZlio,376,3604,golang,"package main

import ""fmt""

const MOD int64 = 1e9 + 7

func numberOfWays(n int, x int, y int) int {
	// Create a 2D slice for binomial coefficients
	fun := make([][]int64, x+1)
	for i := range fun {
		fun[i] = make([]int64, x+1)
	}
	for i := 0; i <= x; i++ {
		fun[i][0] = 1
		for j := 1; j <= i; j++ {
			fun[i][j] = (fun[i-1][j-1] + fun[i-1][j]) % MOD
		}
	}

	// Create a 2D slice for Stirling numbers of the second kind
	stirling := make([][]int64, n+1)
	for i := range stirling {
		stirling[i] = make([]int64, x+1)
	}
	stirling[0][0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= x; j++ {
			stirling[i][j] = (int64(j)*stirling[i-1][j] + stirling[i-1][j-1]) % MOD
		}
	}

	// Create a slice for factorials
	mathFact := make([]int64, x+1)
	mathFact[0] = 1
	for i := 1; i <= x; i++ {
		mathFact[i] = (mathFact[i-1] * int64(i)) % MOD
	}

	// Calculate the total number of ways
	totalWays := int64(0)
	for k := 1; k <= x; k++ {
		power := int64(1)
		for p := int64(0); p < int64(k); p++ {
			power = (power * int64(y)) % MOD
		}
		totalWays = (totalWays + fun[x][k]*stirling[n][k]%MOD*mathFact[k]%MOD*power%MOD) % MOD
	}

	return int(totalWays) // Return totalWays as int
}

// func main() {
// 	// Example usage
// 	n, x, y := 3, 3, 4
// 	result := numberOfWays(n, x, y)
// 	fmt.Println(result) // Output: 684
// }
",1420112237
Anurag Yadav,ECrdnAZlio,376,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};
",1420016719
Anurag Yadav,ECrdnAZlio,376,3611,golang,"package main

import (
	""fmt""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	ans := make([]int, n)

	for i := 0; i < n; i++ {
		num := nums[i]
		minimalAns := -1 // Initialize to -1 as default

		// Iterate through each bit position (0 to 30)
		for bit := 0; bit <= 30; bit++ {
			// Check if the current bit is set
			if (num>>bit)&1 == 1 {
				// Generate a candidate by unsetting the current bit
				candidate := num &^ (1 << bit)

				// Check if candidate OR (candidate + 1) equals num
				if (candidate|(candidate+1)) == num {
					if minimalAns == -1 || candidate < minimalAns {
						minimalAns = candidate // Update minimal answer
					}
				}
			}
		}

		ans[i] = minimalAns // Assign the minimal candidate found or -1
	}

	return ans
}
",1420043836
CCrack,Shiraz_Zainvi,377,3487,cpp,"class Solution {
public:
    unordered_map<int, int> check;
    //vector<vector<int>> dp;
    // int solve(int i, int j, string& source, string& pattern)
    // {
    //     if(j==pattern.size())
    //     return 0;

    //     if(i==source.size() && j!=pattern.size())
    //     return 1e9;

    //     if(dp[i][j]!=-1)
    //     return dp[i][j];

    //     int a = 1e9, b = 1e9;

    //     a = solve(i+1, j, source, pattern);
    //     if(source[i] == pattern[j])
    //     {
    //         if(check[i]>0)
    //         {
    //             b = min(b, 1+solve(i+1, j+1, source, pattern));
    //         }
    //         else
    //         b = min(b, solve(i+1, j+1, source, pattern));
    //     }
    //     return dp[i][j] = min(a, b);
    // }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        if(source == pattern)
        return 0;
        for(int i:targetIndices)
        check[i]++;
        int M = source.size(), N = pattern.size();
        //dp = vector<vector<int>> (M+1, vector<int>(N+1, 0));
        vector<int> prev(N+1, 0), next(N+1, 0);
        int n = targetIndices.size();
        for(int j=0;j<pattern.size();j++)
        next[j] = 1e9;

        for(int i=M-1;i>=0;i--)
        {
            for(int j=N-1;j>=0;j--)
            {
                int a = 1e9, b = 1e9;

                a = next[j];
                if(source[i] == pattern[j])
                {
                    if(check[i]>0)
                    {
                        b = min(b, 1+next[j+1]);
                    }
                    else
                    b = min(b, next[j+1]);
                }
                prev[j] = min(a, b);
            }
            next = prev;
        }
        return n - next[0];
    }
};",1420058662
CCrack,Shiraz_Zainvi,377,3604,cpp,"using ll = long long;
class Solution {
public:
    int MOD = 1e9+7;
    void fact_prep(vector<ll>& fact, int x)
    {
        for(int i=1;i<=x;i++)
        {
            fact[i] = (ll)(fact[i-1]*i)%MOD;
        }
    }
    void stirling_prep(vector<vector<ll>>& stirling, int n, int x)
    {
        stirling[0][0]=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=x;j++)
            {
                stirling[i][j] = (j*stirling[i-1][j] + stirling[i-1][j-1])%MOD;
            }
        }
    }

    void combi_prep(vector<vector<ll>>& combination, int x)
    {
        for(int i=0;i<=x;i++)
        {
            combination[i][0] = 1;
            for(int j=1;j<=i;j++)
            {
                combination[i][j] = (combination[i-1][j-1]+combination[i-1][j])%MOD;
            }
        }
    }
    int solve(vector<vector<ll>>& stir, vector<vector<ll>>& combi, vector<ll>& f, int n, int x, int y)
    {
        ll ret = 0;
        ll p = 1;
        for(int i=1;i<=x;i++)
        {
            p = 1;
            for(int j=0;j<i;j++)
            {
                p = (p*y)%MOD;
            }
            ret = (ret + (ll)combi[x][i]*stir[n][i]%MOD*f[i]%MOD*p%MOD)%MOD;
        }
        return (int)ret;
    }
    int numberOfWays(int n, int x, int y) {
        vector<ll> factorial(x+1, 1);
        vector<vector<ll>> stirling(n+1, vector<ll>(x+1, 0)), combination(x+1, vector<ll>(x+1, 0));
        deque<int> q;
        q.push_back(1);
        int ans = 0;
        fact_prep(factorial, x);
        stirling_prep(stirling, n, x);
        combi_prep(combination, x);
        q.pop_back();

        ans = solve(stirling, combination, factorial, n, x, y);
        return ans;
    }
};",1420125215
CCrack,Shiraz_Zainvi,377,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<nums.size();i++)
        {
            int num = nums[i];
            
            bool flag = false;
            for(int j=1;j<num;j++)
            {
                if(((j)|(j+1)) == num )
                {
                    ans[i] = j;
                    flag = true;
                    break;
                }
            }

            if(!flag)
            ans[i] = -1;
        }
        return ans;
    }
};",1420008743
CCrack,Shiraz_Zainvi,377,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);

        for(int i=0;i<n;i++)
        {
            int num = nums[i];

            if(num==2)
            {
                ans[i]=-1;
                continue;
            }
            bitset<32> a(num);

            int idx = 0;

            while(a[0]!=0)
            {
                idx++;
                a = a>>1;
            }

            bitset<32> b(num);
            b[idx-1]=0;

            int val = (int)(b.to_ulong());

            ans[i] = val;
        }
        return ans;
    }
};",1420018613
Chris Ho,Chris_ho,378,3487,python3,"from functools import cache
class Solution:
    def maxRemovals(self, src: str, pat: str, tgt: List[int]) -> int:
        tgt_set = set(tgt)
        len_src = len(src)
        len_pat = len(pat)

        counts = [0] * (len_src + 1)
        for s_idx in range(len_src - 1, -1, -1):
            counts[s_idx] = counts[s_idx + 1] + (1 if s_idx in tgt_set else 0)

        dp = [[float('-inf')] * (len_pat + 1) for _ in range(len_src + 1)]
        for s_idx in range(len_src + 1):
            dp[s_idx][len_pat] = counts[s_idx]

        for p_idx in range(len_pat - 1, -1, -1):
            dp[len_src][p_idx] = float('-inf')

        for s_idx in range(len_src - 1, -1, -1):
            for p_idx in range(len_pat - 1, -1, -1):
                opt1 = dp[s_idx + 1][p_idx]
                if s_idx in tgt_set:
                    opt1 = max(opt1, dp[s_idx + 1][p_idx] + 1)
                opt2 = dp[s_idx + 1][p_idx + 1] if src[s_idx] == pat[p_idx] else float('-inf')
                dp[s_idx][p_idx] = max(opt1, opt2)

        res = dp[0][0]
        return res if res >= 0 else 0

# @cache
#         def dp(s_idx, p_idx, removed_count):
#             if p_idx == len(pat):
#                 return removed_count + len(tgt) - bisect.bisect_left(tgt, s_idx)

#             if s_idx == len(src):
#                 return float('-inf')

#             opt1 = dp(s_idx + 1, p_idx, removed_count)

#             tgt_pos = bisect.bisect_left(tgt, s_idx)
#             if tgt_pos < len(tgt) and tgt[tgt_pos] == s_idx:
#                 opt1 = max(opt1, dp(s_idx + 1, p_idx, removed_count + 1))

#             opt2 = float('-inf')
#             if src[s_idx] == pat[p_idx]:
#                 opt2 = dp(s_idx + 1, p_idx + 1, removed_count)

#             return max(opt1, opt2)

#         res = dp(0, 0, 0)
#         return res if res >= 0 else 0",1420106576
Chris Ho,Chris_ho,378,3604,python3,"from functools import lru_cache

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        maxN = n
        # Precompute factorials and inverse factorials
        factorial = [1] * (maxN + 1)
        for i in range(1, maxN + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
            for j in range(1, i + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD

        total_ways = 0
        for k in range(1, min(n, x) + 1):
            ways = math.comb(x, k) * S[n][k] % MOD * factorial[k] % MOD * pow(y, k, MOD) % MOD
            total_ways = (total_ways + ways) % MOD

        return total_ways
",1420098314
Chris Ho,Chris_ho,378,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
      ans = []
      for num in nums:
        found = False
        for x in range(num):
          if (x|(x+1))==num:
            ans.append(x)
            found = True
            break
        if not found:
          ans.append(-1)
      return ans        ",1419994763
Chris Ho,Chris_ho,378,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
      ans = []
      for num in nums:
          min_ans = -1
          for k in range(32):
              if num & (1 << k):
                  temp = num & ~(1 << k)
                  if temp >= 0 and (temp | (temp + 1)) == num:
                      if min_ans == -1 or temp < min_ans:
                          min_ans = temp
          ans.append(min_ans)
      return ans",1420004154
Wayne,Wayne02,379,3487,cpp,"// class Solution {
// public:
    
//     int n , m ; 
//     set <int> st ; 
//     int dp[100100][100100] ; 
    
//     int rec(int level1 , int level2 , string &s1 , string &s2){
//         if(level2 == m) return 0 ; 
//         if(level1 == n ) return -1e9 ; 
        
//         if(dp[level1][level2] != -1){
//             return dp[level1][level2] ; 
//         }
//         int ans = -1e9 ; 
//         if(s1[level1] == s2[level2]){
//             if(st.find(level1) != st.end()){
//                 ans = max({ans , 1 + rec(level1 + 1 , level2 , s1 , s2) , rec(level1 +1 , level2 +1 , s1 , s2)}) ; 
//             }
//             else{
//                 ans = max(ans , rec(level1 + 1 , level2 +1 , s1 , s2)) ; 
//             }
//         }
//         else{
//             if(st.find(level1) != st.end()){
//                 ans = max(ans , 1 + rec(level1 + 1 , level2 , s1 , s2)) ; 
//             }
//             else{
//                 ans = max(ans , rec(level1 + 1 , level2 , s1 , s2)) ; 
//             }
//         }
//         return dp[level1][level2] = ans ; 
//     }
    
    
//     int maxRemovals(string s1, string s2, vector<int>& tr) {
//         n = (int)s1.size() ; 
//         m = (int)s2.size() ; 
//         set <int> st ; 
//         for(int i =0 ;i < (int)tr.size() ; i++){
//             st.insert(tr[i]) ; 
//         }
//         memset(dp , -1 , sizeof(dp)) ; 
//         int ans = rec(0 , 0 , s1 , s2) ; 
//         return ans ; 
//     }
// };

// class Solution {
// public:
//     int n, m;
//     set<int> st;
//     // vector<vector<int>> dp;  // Use vector instead of fixed-size array
//     map <pair <int , int> , int> dp ; 
//     vector <int> v ; 

//     int rec(int level1, int level2, string& s1, string& s2) {
//         if (level2 == m){
//             level1 -- ; 
//             // cout << level1 << ""level1 is "" << endl; 
//             int x = upper_bound(v.begin() , v.end() , level1) - v.begin() ; 
//             // cout << x << ""<--"" << endl; 
//             return (int)v.size() - x ; 
//         }
//         if (level1 == n) return -1e9;

//         if (dp.find({level1 , level2}) != dp.end()) {
//             return dp[{level1 , level2}];
//         }

//         int ans = -1e9;
//         if (s1[level1] == s2[level2]) {
//             if (st.find(level1) != st.end()) {
//                 ans = max({ans, 1 + rec(level1 + 1, level2, s1, s2), rec(level1 + 1, level2 + 1, s1, s2)});
//             } else {
//                 ans = max(ans, rec(level1 + 1, level2 + 1, s1, s2));
//             }
//         } else {
//             if (st.find(level1) != st.end()) {
//                 ans = max(ans, 1 + rec(level1 + 1, level2, s1, s2));
//             } else {
//                 ans = max(ans, rec(level1 + 1, level2, s1, s2));
//             }
//         }
//         return dp[{level1 , level2}] = ans;
//     }

//     int maxRemovals(string s1, string s2, vector<int>& tr) {
//         n = (int)s1.size();
//         m = (int)s2.size();
//         for(int i =0 ;i < (int)tr.size() ; i++){
//             v.push_back(tr[i]) ;
//         }
        
//         // Initialize the set with the removal indices
//         st.clear();
//         for (int i = 0; i < (int)tr.size(); i++) {
//             st.insert(tr[i]);
//         }
        
//         int ans = rec(0, 0, s1, s2);
//         return ans;
//     }
// };


class Solution {
public:
    int n, m;
    set<int> st;
    vector<int> v;

    int maxRemovals(string s1, string s2, vector<int>& tr) {
        n = (int)s1.size();
        m = (int)s2.size();

        v = tr;
        sort(v.begin(), v.end());

        
        st.clear();
        for (int i = 0; i < (int)tr.size(); i++) {
            st.insert(tr[i]);
        }

       
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1e9));

        for (int level1 = 0; level1 <= n; level1++) {
            int x = upper_bound(v.begin(), v.end(), level1 - 1) - v.begin();
            dp[level1][m] = (int)v.size() - x; 
        }

        for (int level1 = n - 1; level1 >= 0; level1--) {
            for (int level2 = m - 1; level2 >= 0; level2--) {
                int ans = -1e9;

                if (s1[level1] == s2[level2]) {
                    if (st.find(level1) != st.end()) {
                        ans = max({ans, 1 + dp[level1 + 1][level2], dp[level1 + 1][level2 + 1]});
                    } else {
                        ans = max(ans, dp[level1 + 1][level2 + 1]);
                    }
                } else {
                    if (st.find(level1) != st.end()) {
                        ans = max(ans, 1 + dp[level1 + 1][level2]);
                    } else {
                        ans = max(ans, dp[level1 + 1][level2]);
                    }
                }

                dp[level1][level2] = ans;
            }
        }


        return dp[0][0];
    }
};
",1420083637
Wayne,Wayne02,379,3604,cpp,"class Solution {
public:
    
    
    const long long pm = 1e9 + 7;
    
    int add(int a, int b){
        int sum = (a% pm + b%pm)%pm  ;
        if(sum > pm) sum%= pm ; 
        if(sum < 0) sum += pm ; 
        return sum ; 
    }
    
    
    long long pow(long long base, long long exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % pm;
            }
            base = (base * base) % pm;
            exp /= 2;
        }
        return result;
    }

    vector<vector<long long>> computeBinomialCoefficients(long long max_n) {
        vector<vector<long long>> binomial(max_n + 1, vector<long long>(max_n + 1, 0));
        for (long long i = 0; i <= max_n; i++) {
            binomial[i][0] = 1; // C(n, 0) = 1
            for (long long j = 1; j <= i; ++j) {
                binomial[i][j] = (binomial[i - 1][j - 1] + binomial[i - 1][j]) % pm;
            }
        }
        return binomial;
    }

    vector<vector<long long>> computeStirlingNumbers(long long n, long long m) {
        vector<vector<long long>> stirling(n + 1, vector<long long>(m + 1, 0));
        stirling[0][0] = 1; // S(0, 0) = 1

        for (long long i = 1; i <= n; i++) {
            for (long long j = 1; j <= m; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % pm;
            }
        }
        return stirling;
    }

    vector<long long> computeFactorials(long long max_n) {
        vector<long long> factorial(max_n + 1, 1);
        for (long long i = 1; i <= max_n; i++) {
            factorial[i] = factorial[i - 1] * i % pm;
        }
        return factorial;
    }
    
    
    
    
    
    int numberOfWays(int n, int x, int y) {
        
        vector<vector<long long>> binomialCoefficients = computeBinomialCoefficients(x);
        vector<vector<long long>> stirlingNumbers = computeStirlingNumbers(n, x);
        vector<long long> factorials = computeFactorials(x);

        long long totalWays = 0;
        for (long long k = 1; k <= x; ++k) {
            long long powerY = pow(y, k); 
            totalWays = (totalWays + binomialCoefficients[x][k] * stirlingNumbers[n][k] % pm * factorials[k] % pm * powerY % pm) % pm;
        }

        return totalWays;
    }
};",1420126010
Wayne,Wayne02,379,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
        int n = (int)arr.size() ;
        vector <int> ans(n) ; 
        for(int i =0 ;i < n ; i++){
            bool fon = false ; 
            for(int j =1 ; j <= 1000 ; j++){
                if((j | (j+1)) == arr[i]){
                    fon = true ;
                    // cout << j << ""<---"" << endl; 
                    ans[i] = j ; 
                    break ; 
                }
            }
            if(fon == false){
                ans[i] = -1 ; 
            }
        }
        return ans ; 
    }
};",1419999612
Wayne,Wayne02,379,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
       int size = (int)arr.size();
    vector<int> result(size);
    
   
    vector<int> arrCopy = arr;
    sort(arrCopy.begin(), arrCopy.end());

    for (int idx = 0; idx < size; idx++) {
        if(arr[idx] != 2){
            int mask1 = 0, mask2 = 0;
            
            
            for (int bitPos = 1; bitPos < 30; bitPos++) {
                if (arr[idx] & (1 << bitPos)) {
                    mask1 |= (1 << bitPos);
                }
            }
            
        
            for (int bitPos = 0; bitPos < 30; bitPos++) {
                if (!(arr[idx] & (1 << bitPos))) {
                    mask2 = arr[idx] ^ (1 << (bitPos - 1));
                    break;
                }
            }

            result[idx] = min(mask1, mask2);
        }
        else if (arr[idx] == 2) {
            result[idx] = -1;
        }
    }

    return result;
    }
};",1420037205
Sandip Kumar Burnwal,sandip123_,380,3487,cpp,"class Solution {
public:
    bool isSubsequence(string source,string pattern) {
        int n = source.size();
        int m = pattern.size();
        int j = 0; 
            for (int i = 0; i < n; ++i) {
                
                if (j < m && source[i] == pattern[j]) {
                    j++;
                }
                if (j == m) {
                    return true;
                }
            }
            return j == m;
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0; 
        
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
    
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
    
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);

    }
};",1420073390
Sandip Kumar Burnwal,sandip123_,380,3604,cpp,"class Solution {
public:
    const int mod = 1e9+7;
    int numberOfWays(int n, int x, int y) {
        vector<long long>params = {n,x,y};
        vector<vector<long long>>fun(x+1,vector<long long>(x+1,0));
        long long i=0;
        while(i<=x){
            fun[i][0]=1;
            for(int j=1;j<=i;j++){
                fun[i][j]=(fun[i-1][j-1]+fun[i-1][j])%mod;
            }
            i++;
        }
        vector<vector<long long>>stirling(n+1,vector<long long>(x+1,0));
        stirling[0][0]=1;
        i=1;
        while(i<=n) {
            for (long long j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % mod;
            }
            i++;
        }

        vector<long long> mathFact(x + 1, 1);
        for (long long i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % mod;
        }

        long long totalWays = 0;
        for (long long k = 1; k <= x; ++k) {
            long long power = 1;
            for (long long p = 0; p < k; ++p) {
                power = (power * y) % mod;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % mod * mathFact[k] % mod * power % mod) % mod;
        }

        return totalWays;
    }
};",1420126024
Sandip Kumar Burnwal,sandip123_,380,3605,cpp,"class Solution {
public:
    vector<int> sieveOfEratosthenes(int limit) {
        vector<bool> isPrime(limit + 1, true);
        vector<int> primes;
        isPrime[0] = isPrime[1] = false;
        for (int p = 2; p <= limit; ++p) {
            if (isPrime[p]) {
                primes.push_back(p);
                for (int i = p * p; i <= limit; i += p) {
                    isPrime[i] = false;
                }
            }
        }
        return primes;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  

       
        for (int i = 0; i < nums.size(); ++i) {
           
            
           
            for (int candidate = 1; candidate < nums[i]; ++candidate) {
                if ((candidate | (candidate + 1)) == nums[i]) {
                    ans[i] = candidate;
                    break;  
                }
            }
        }
        return ans;
    }
};",1420004524
Sandip Kumar Burnwal,sandip123_,380,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n);
        for(int i=0;i<n;i++){
            int num = nums[i];
            int mini = INT_MAX;
            bool found=false;
            for(int bit=0;bit<=30;bit++){
                if(((num>>bit) & 1)==1){
                    int cand = num&(~(1<<bit));
                    if(cand<0)continue;
                    if((cand|(cand+1))==num){
                        if(cand<mini){
                            mini=cand;
                            found=true;
                        }
                    }
                }
            }
            if(found)ans[i]=mini;
            else{
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420058383
Anupam Shandilya,anupamshandilya28,381,3487,cpp,"class Solution {
public:
   int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        int k = targetIndices.size();

        vector<bool> isInTarget(n, false);
        for (int idx : targetIndices)
        {
            isInTarget[idx] = true;
        }

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; 

        for (int i = 0; i < n; ++i)
        {
            vector<int> new_dp = dp;

            for (int j = 0; j < m; ++j) {
                if (source[i] == pattern[j] && dp[j] != INT_MAX) {
                    int cost = isInTarget[i] ? 1 : 0;
                    new_dp[j + 1] = min(new_dp[j + 1], dp[j] + cost);
                }
            }
            dp = new_dp;
        }

        if (dp[m] == INT_MAX)
        {
            return 0;
        }

        int maxRemovable = k - dp[m];
        return maxRemovable;
    }

};",1420126108
Anupam Shandilya,anupamshandilya28,381,3604,cpp,"class Solution {
public:
    #define MOD 1000000007

    int mod_pow(int base, int exponent)
    {
        int result = 1;
        base %= MOD;
        while(exponent > 0) 
        {
            if (exponent % 2 == 1) 
            {
                result = (int)((1LL * result * base) % MOD);
            }
            base = (int)((1LL * base * base) % MOD);
            exponent /= 2;
        }
        return result;
    }

    int mod_inverse(int a) 
    {
        return mod_pow(a, MOD - 2);
    }

    int numberOfWays(int n, int x, int y) {
        const int MAX = 2001;
        int factorial[MAX], inv_factorial[MAX];
        factorial[0] = 1;
        for(int i = 1; i <= n + x; ++i) 
        {
            factorial[i] = (int)((1LL * factorial[i - 1] * i) % MOD);
        }
        inv_factorial[n + x] = mod_inverse(factorial[n + x]);
        for(int i = n + x - 1; i >= 0; --i) 
        {
            inv_factorial[i] = (int)((1LL * inv_factorial[i + 1] * (i + 1)) % MOD);
        }

        int S[MAX][MAX];
        for(int i = 0; i <= n; ++i)
        {
            for (int j = 0; j <= n; ++j) 
            {
                S[i][j] = 0;
            }
        }
        S[0][0] = 1;
        for(int i = 1; i <= n; ++i) 
        {
            S[i][0] = 0;
            for(int j = 1; j <= i; ++j) 
            {
                S[i][j] = (S[i - 1][j - 1] + (int)((1LL * j * S[i - 1][j]) % MOD)) % MOD;
            }
        }

        int total = 0;
        int min_k = (n < x) ? n : x;
        for(int k = 1; k <= min_k; ++k) 
        {
            int C_x_k = (int)((1LL * factorial[x] * inv_factorial[k] % MOD) * inv_factorial[x - k] % MOD);

            int k_factorial = factorial[k];

            int y_pow_k = mod_pow(y, k);

            int term = (int)((1LL * C_x_k * k_factorial % MOD) * S[n][k] % MOD);
            term = (int)((1LL * term * y_pow_k) % MOD);

            total = (total + term) % MOD;
        }

        return total;
    }

};",1420074306
Anupam Shandilya,anupamshandilya28,381,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
        
        for (int i=0;i<n;++i)
        {
            int min_x = -1;
            int num = nums[i];
            for(int pos=0;pos<31;++pos)
            {
                if((num & (1 << pos)))
                {
                    int x = num-(1<<pos);
                    if(x >= 0) 
                    {
                        int x_plus_one = x + 1;
                        if((x | x_plus_one) == num) 
                        {
                            if(min_x == -1 || x < min_x) 
                            {
                                min_x = x;
                            }
                        }
                    }
                }
            }
            ans[i] = min_x;
        }
        
        return ans;
    }
};",1420007641
Anupam Shandilya,anupamshandilya28,381,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
        
        for (int i=0;i<n;++i)
        {
            int min_x = -1;
            int num = nums[i];
            for(int pos=0;pos<31;++pos)
            {
                if((num & (1 << pos)))
                {
                    int x = num-(1<<pos);
                    if(x >= 0) 
                    {
                        int x_plus_one = x + 1;
                        if((x | x_plus_one) == num) 
                        {
                            if(min_x == -1 || x < min_x) 
                            {
                                min_x = x;
                            }
                        }
                    }
                }
            }
            ans[i] = min_x;
        }
        
        return ans;
    }
};",1420007193
Guardian-or-nothing,Guardian-or-nothing,382,3487,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    vector<vector<ll>> dp;
    ll f(ll i, ll j, string &src, string &pat, vector<ll> &mp){
        ll n=src.size(),m=pat.size();
        ll ans=0;
        if(i<=n && j>=m){
            ll tans=0;
            for(int k=i;k<n;k++){
                tans+=(mp[k]);
            }
            return tans;
        }
        if(i>=n && j<m) return -1e9;
        if(dp[i][j]!=-1) return dp[i][j];
        if(mp[i]==0){
            if(src[i]==pat[j]){
                ans=f(i+1,j+1,src,pat,mp);
                ans=max(ans,f(i+1,j,src,pat,mp));  // may, may not
            }else{
                ans=f(i+1,j,src,pat,mp);
            }
        }else if(mp[i]==1){
            ll del=0,nodel=0;
            if(src[i]==pat[j]){
                del=1+f(i+1,j,src,pat,mp);                // delete
                nodel=f(i+1,j+1,src,pat,mp);          // no delete
                nodel=max(nodel,f(i+1,j,src,pat,mp));
            }else{
                del=1+f(i+1,j,src,pat,mp);                 // delete
                nodel=f(i+1,j,src,pat,mp);    // no delete
            }
            ans=max(del,nodel);
        }
        return dp[i][j]=ans;
    }
    int maxRemovals(string src, string pat, vector<int>& v) {
        ll n=src.size(),m=pat.size(); vector<ll> mp(n,0);
        for(int i=0;i<v.size();i++) mp[v[i]]++;
        dp.resize(n+1,vector<ll>(m+1,-1));
        ll ans=f(0,0,src,pat,mp);
        return ans;
    }
};",1420095094
Guardian-or-nothing,Guardian-or-nothing,382,3604,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    ll mod=1e9+ 7;
    vector<ll> f;
    int numberOfWays(int n, int x, int y) {
        f.resize(x+3,1);
        for (int i=1;i<x+1;i++) {
            f[i]=(f[i-1]*i)%mod; f[i]%=mod;
        }
        vector<vector<ll>> v(x+3,vector<ll>(x+3,0));
        for (int i=0;i<x+1;i++) {
            v[i][0]=1;
            for (int j=1;j<i+1;j++) {
                ll tans=(v[i-1][j]+v[i-1][j-1])%mod;
                v[i][j]=tans;
            }
        } 
        vector<vector<ll>> smaan(n+3,vector<ll>(x+3,0));
        smaan[0][0]=1;
        for (int i=1;i<n+1;i++) {
            for (int j=1;j<x+1;j++) {
                ll tans1=1ll*smaan[i-1][j-1]%mod; ll tans2=1ll*j*smaan[i-1][j]%mod;
                smaan[i][j]=(tans1+tans2)%mod; smaan[i][j]%=mod;
            }
        }
        ll fans=0;
        for (int j=1;j<x+1;j++) {
            ll power=1;
            for (int i=0;i<j;i++){
                power*=y; power%=mod;
            }
            ll tans1=smaan[n][j]*v[x][j]%mod; ll tans2=(f[j] % mod);
            fans+=(tans1%mod*tans2%mod*power % mod)%mod;
            fans%=mod;
        }
        return fans;
    }
};",1420126279
Guardian-or-nothing,Guardian-or-nothing,382,3605,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int> ans;
        for(ll i=0;i<n;i++){
            for(ll j=0;j<=32;j++){
                ll bit=(v[i] & (1ll<<j));
                if(bit==0){
                    if(j-1>=0){
                        ll tans=v[i] - (1<<(j-1));
                        ans.push_back(tans); break;
                    }else{
                        ans.push_back(-1); break;
                    }
                }
            }
        }
        return ans;
    }
};",1420023126
Guardian-or-nothing,Guardian-or-nothing,382,3611,cpp,"#include <bits/stdc++.h> 
using namespace std; 
#define ll long long
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n=v.size();
        vector<int> ans;
        for(ll i=0;i<n;i++){
            for(ll j=0;j<=32;j++){
                ll bit=(v[i] & (1ll<<j));
                if(bit==0){
                    if(j-1>=0){
                        ll tans=v[i] - (1<<(j-1));
                        ans.push_back(tans); break;
                    }else{
                        ans.push_back(-1); break;
                    }
                }
            }
        }
        return ans;
    }
};",1420022089
newbie_noob,newbie_noob,383,3487,cpp,"int dp[3001][3001];
class Solution {
public:
    int f(int i,int j,string &s,string &p,set<int>&st,vector<vector<int>>&dp)
    {
        if(j>=p.size())
        {
            return 0;
        }
        if(i>=s.size())
        {
            return 1e9;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        int ans=1e9;
        ans=min(ans,f(i+1,j,s,p,st,dp));
        if(s[i]==p[j])
        {
            int to_add=0;
            if(st.find(i)!=st.end())
            to_add=1;
            ans=min(ans,to_add+f(i+1,j+1,s,p,st,dp));
        }
        return dp[i][j]=ans;
    }
    int maxRemovals(string s, string p, vector<int>& t) {
        set<int>st;
        vector<vector<int>>dp(s.size()+1,vector<int>(p.size()+1,-1));
        for(auto it:t)st.insert(it);
        int ans=f(0,0,s,p,st,dp);
        ans=t.size()-ans;
        return ans;
    }
};",1420056099
newbie_noob,newbie_noob,383,3604,cpp,"int mod=1e9+7;
class Solution {
public: 
    long long add(long long a,long long b)
    {
        return (a%mod +  b%mod)%mod;
    }
    long long mul(long long a,long long b)
    {
        return (a%mod*b%mod)%mod;
    }

    void set_ncr(vector<vector<long long>>&ncr)
    {
        for(int i=0;i<=1000;++i)ncr[i][0]=1;
        for(int i=0;i<=1000;++i)
        {
            for(int j=1;j<=i;++j)
            {
                ncr[i][j]=add(ncr[i-1][j],ncr[i-1][j-1]);
            }
        }
    }
    void set_scr(vector<vector<long long>>&scr,long long n,long long x)
    {
        scr[0][0]=1;
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=x;++j)
            {
                scr[i][j]=add(scr[i-1][j-1],mul(j,scr[i-1][j]));
            }
        }
    }
    void set_fact(vector<long long>&fact)
    {
        fact[0]=1;
        for(int i=1;i<=1000;++i)
        {
            fact[i]=mul(fact[i-1],i);
        }
    }
    void set_yk(vector<long long>&yk,long long y,long long x)
    {
        yk[0]=1;
        for(int i=1;i<=x;++i)
        {
            yk[i]=mul(yk[i-1],y);
        }
    }
    
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>>ncr(1001,vector<long long>(1001,0));
        set_ncr(ncr);
        vector<vector<long long>>scr(n+1,vector<long long>(x+1,0));
        set_scr(scr,n,x);
        vector<long long>yk(x+1,0);
        set_yk(yk,y,x);
        vector<long long>fact(1001,0);
        set_fact(fact);
        long long ans=0;
        for(long long sc=1;sc<=x;++sc)
        {
            long long a=1;
            a=mul(a,mul(scr[n][sc],ncr[x][sc]));
            a=mul(a,mul(fact[sc],yk[sc]));
            ans=add(ans,a);
        }
        return ans;
    }
};",1420120042
newbie_noob,newbie_noob,383,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();++i)
        {
            if(nums[i]==2)
            {
                ans.push_back(-1);
            }
            else{
                int ele=0;
                int done=0;
                for(int j=0;j<21;++j)
                {
                    if(((nums[i]>>j)&1)==0)
                    {
                        if(done==1)
                        {
                            continue;
                        }
                        else
                        {
                            done=1;
                            ele^=(1LL<<(j-1));
                        }
                    }
                    else
                    {
                        ele+=(1LL<<j);
                    }
                }
                ans.push_back(ele);
            }
        }
        return ans;
    }
};",1420016683
newbie_noob,newbie_noob,383,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(int i=0;i<nums.size();++i)
        {
            if(nums[i]==2)
            {
                ans.push_back(-1);
            }
            else{
                int ele=0;
                int done=0;
                for(int j=0;j<31;++j)
                {
                    if((nums[i]&(1LL<<j))==0)
                    {
                        if(done==1)
                        {
                            continue;
                        }
                        else
                        {
                            done=1;
                            ele^=(1LL<<(j-1));
                        }
                    }
                    else
                    {
                        ele+=(1LL<<j);
                    }
                }
                ans.push_back(ele);
            }
        }
        return ans;
    }
};",1420019402
retinue,XCX0OjLCi5,385,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        
        f = [0] + [float('inf') for _ in range(m)]
        used = [False for _ in range(n)]
        for i in targetIndices:
            used[i] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and f[j - 1] != float('inf'):
                    f[j] = min(f[j], f[j - 1] + int(used[i]))
        
        if f[m] == float('inf'):
            return len(targetIndices)
        
        return len(targetIndices) - f[m]
            
        ",1420078444
retinue,XCX0OjLCi5,385,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7
        f = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            f[i][0] = 1
            for j in range(1, i + 1):
                f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % MOD


        p = [[0] * (x + 1) for _ in range(n + 1)]
        p[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                p[i][j] = ((j * p[i - 1][j]) % MOD + p[i - 1][j - 1]) % MOD

        ft = [1] * (x + 1)
        for i in range(1, x + 1):
            ft[i] = ft[i - 1] * i % MOD

        res = 0
        for k in range(1, x + 1):
            res += ((f[x][k] * p[n][k]) % MOD) * (ft[k] % MOD) * pow(y, k, MOD)
            res %= MOD

        return res % MOD",1420121125
retinue,XCX0OjLCi5,385,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # (a) or (a + 1) == ni
        res = []
        for n in nums:
            f = False
            for i in range(1, 1001):
                if i | (i + 1) == n:
                    res.append(i)
                    f = True
                    break
            if not f:
                res.append(-1)
        return res",1419995993
retinue,XCX0OjLCi5,385,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = []
        for n in nums:
            mi = 10 ** 10
            flag = False
            for i in range(31):
                if (n >> i) & 1:
                    x = n & ~(1 << i)
                    if x < 0:
                        continue
                    if x | x + 1 == n:
                        mi = min(mi, x)
                        flag = True
            res.append(-1 if not flag else mi)
        return res
                    ",1420069202
Aasmaan,Aasmaan_Vs_Aasmaan,386,3487,cpp,"#include <bits/stdc++.h>
using namespace std;

#define vi vector<int>
#define pb push_back
#define sz size()
#define INF INT_MAX
#define F first
#define S second

class Solution
{
public:
    int maxRemovals(string &s, string &p, vi &t)
    {
        int n = s.sz, m = p.sz;
        vi d(m + 1, INF);
        d[0] = 0;
        vector<bool> x(n, false);
        stack<int> st;

        for (auto idx : t)
            st.push(idx);
        while (!st.empty())
        {
            x[st.top()] = true;
            st.pop();
        }

        for (int i = 0; i < n; ++i)
        {
            int ff = 0;
            while (ff < 1)
            {

                for (int i = 0; i < 10; i++)
                    st.push(i);

                for (int j = m; j >= 1; --j)
                {
                    if (s[i] == p[j - 1] && d[j - 1] < INF)
                    {

                        int a=d[j];
                        int b=d[j-1];
                        int c=x[i];
                        int dd=b+c;
                        d[j]= min(a,dd);
                    }
                }
                ff++;
            }
        }

        int ok = d[m]; 

int uu; 
if (ok == INF) {
    uu = 0; 
    uu = ok;
}

int oo = t.sz - uu; 

return oo; 


        return t.sz - (d[m] == INF ? 0 : d[m]);
    }
};
",1420093710
Aasmaan,Aasmaan_Vs_Aasmaan,386,3604,rust,"use std::collections::VecDeque;

macro_rules! insert_into_stack {
    ($s:expr, $v:expr) => {
        $s.push_back($v);
    };
}

impl Solution {
    pub fn number_of_ways(n: i32, x: i32, y: i32) -> i32 {
        const M: i64 = 1_000_000_007;
        let mut vec = vec![1, 2, 3, 4, 5];
    let len = vec.len();
    for i in 0..len / 2 {
        vec.swap(i, len - 1 - i);
    }
        
        let mut stack: VecDeque<i32> = VecDeque::new(); 
        
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        let mut temp_str = String::new(); 

        for i in 1..=10 {
            insert_into_stack!(stack, i);
            temp_str.push_str(&i.to_string()); 
        }
                let mut stack: VecDeque<i32> = VecDeque::new(); 
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        fn c(s: i32) -> Vec<Vec<i64>> {
            let s = s as usize;
            let mut r = vec![vec![0; s + 1]; s + 1];
            for i in 0..=s {
                r[i][0] = 1;
                for j in 1..=i {
                    r[i][j] = (r[i - 1][j - 1] + r[i - 1][j]) % M;
                }
            }
            r
        }
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        fn p(n: i32, x: i32) -> Vec<Vec<i64>> {
            let n = n as usize;
            let x = x as usize;
            let mut r = vec![vec![0; x + 1]; n + 1];
            r[0][0] = 1;
            for i in 1..=n {
                for j in 1..=x {
                    r[i][j] = (j as i64 * r[i - 1][j] + r[i - 1][j - 1]) % M;
                }
            }
            r
        }
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        fn f(s: i32) -> Vec<i64> {
            let s = s as usize;
            let mut r = vec![1; s + 1];
            for i in 1..=s {
                r[i] = (r[i - 1] * i as i64) % M;
            }
            r
        }

        let c = c(x);
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);

        let p = p(n, x);
        let f = f(x);
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        let mut res = 0;
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


        for k in 1..=x {
            let mut pow = 1;
            for _ in 0..k {
                pow = (pow * y as i64) % M;
            }
            let mut t = c[x as usize][k as usize];
            t = (t * p[n as usize][k as usize]) % M;
            t = (t * f[k as usize]) % M;
            t = (t * pow) % M;
            res = (res + t) % M;
        }
        
         stack.push_back(1); stack.push_back(2);
        stack.push_back(3); stack.push_back(4);


       

        res as i32
    }
}
",1420116516
Aasmaan,Aasmaan_Vs_Aasmaan,386,3605,cpp,"class Solution
{
public:
    bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }

    string decToBinary(int n)
    {
        string s = """";
        while (n > 0)
        {
            s = to_string(n % 2) + s;
            n /= 2;
        }
        return s;
    }

    long long binaryToDecimal(string n)
    {
        long long dec_value = 0; // Initialize the decimal value to 0
        long long base = 1;      // Initialize the base value to 1 (2^0)

        for (int i = n.size() - 1; i >= 0; i--)
        { // Loop through each character in the string from right to left
            if (n[i] == '1')
            {                      // If the current character is '1'
                dec_value += base; // Add the current base value to the decimal value
            }
            base *= 2; // Update the base value by multiplying it by 2 (base for the next position)
        }

        return dec_value; // Return the calculated decimal value
    }

    vector<int> minBitwiseArray(vector<int> &nums)
    {

        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++)
        {

            if (nums[i] % 2 == 1)
            {
                if (isPowerOfTwo(1 + nums[i]))
                {
                    ans[i] = nums[i] / 2;
                }
                else
                {
                    string t = decToBinary(nums[i]);

                    for (int j = t.size(); j >= 0; j--)
                    {

                        if (t[j] == '0')
                        {
                            int k = j;
                            string p = t;
                            p[k + 1] = '0';

                            int x = binaryToDecimal(p);
                            ans[i] = x;
                            break;
                        }
                    }

                    int one = __builtin_popcountll(nums[i]);

                  

                   
                }
            }
        }

        return ans;
    }
};",1420057566
Aasmaan,Aasmaan_Vs_Aasmaan,386,3611,cpp,"class Solution
{
public:
    bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }

    string decToBinary(int n)
    {
        string s = """";
        while (n > 0)
        {
            s = to_string(n % 2) + s;
            n /= 2;
        }
        return s;
    }

    long long binaryToDecimal(string n)
    {
        long long dec_value = 0; // Initialize the decimal value to 0
        long long base = 1;      // Initialize the base value to 1 (2^0)

        for (int i = n.size() - 1; i >= 0; i--)
        { // Loop through each character in the string from right to left
            if (n[i] == '1')
            {                      // If the current character is '1'
                dec_value += base; // Add the current base value to the decimal value
            }
            base *= 2; // Update the base value by multiplying it by 2 (base for the next position)
        }

        return dec_value; // Return the calculated decimal value
    }

    vector<int> minBitwiseArray(vector<int> &nums)
    {

        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++)
        {

            if (nums[i] % 2 == 1)
            {
                if (isPowerOfTwo(1 + nums[i]))
                {
                    ans[i] = nums[i] / 2;
                }
                else
                {
                    string t = decToBinary(nums[i]);

                    for (int j = t.size(); j >= 0; j--)
                    {

                        if (t[j] == '0')
                        {
                            int k = j;
                            string p = t;
                            p[k + 1] = '0';

                            int x = binaryToDecimal(p);
                            ans[i] = x;
                            break;
                        }
                    }

                    int one = __builtin_popcountll(nums[i]);

                  

                   
                }
            }
        }

        return ans;
    }
};",1420057090
JH,jbropark,387,3487,python3,"class Solution:

    @cache
    def find_max(self, si: int, pi: int):
        if pi >= len(self.pattern):
            return sum(idx in self.indices for idx in range(si, len(self.source)))

        if si >= len(self.source):
            return -float(""inf"")

        if si not in self.indices:
            if self.source[si] == self.pattern[pi]:
                return self.find_max(si + 1, pi + 1)

            return self.find_max(si + 1, pi)

        if self.source[si] == self.pattern[pi]:
            return max(
                self.find_max(si + 1, pi + 1),
                1 + self.find_max(si + 1, pi),
            )

        return 1 + self.find_max(si + 1, pi)

    def maxRemovals(self, source: str, pattern: str, indices: List[int]) -> int:
        self.indices = set(indices)
        self.source = source
        self.pattern = pattern
        return self.find_max(0, 0)
",1420038406
JH,jbropark,387,3604,python3,"import math

MOD = 1_000_000_007


class Solution:

    DP = {(i, j): math.comb(i, j) % MOD for i in range(1, 1001) for j in range(0, i + 1)}

    def sigma(self, k: int, n: int):
        ans = 0
        mul = 1
        for i in range(k, 0, -1):
            ans += self.DP[k, i] * mul * self.mul[i]
            mul *= -1
        return ans

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # 27

        # 1 : 3 * (1^3) * 4 ->
        # 2 : 3 * (2^3 - 2) * 16 
        # 3 : 1 * (3^3 - 3 * 2^3 + ) * 64 ->  

        # 3 / 18 / 6
        # 1^3
        # 2^3 - 2 * 1 ^ 3
        # 3^3 - 3 * 2^3 + 3 * 1^3
        # 27 - 24 + 3
        # 4^3

        # 2 * (1 ^ 5)  * 1
        # 1 * (2 ^ 5 - 2 * 1 ^ 5)

        # nCmin(n,x) min(n,x)

        self.mul = [0] * (x + 1)
        for i in range(1, x + 1):
            self.mul[i] = (i ** n) % MOD

        ans = 0
        mul = 1
        for k in range(1, x + 1):
            com = self.DP[x, min(k, x)]
            sig = self.sigma(k, n)
            mul = (mul * y) % MOD
            # print(com, sig, mul)
            ans = (ans + com * sig * mul) % MOD
            # print(ans)

        return ans % MOD",1420110354
JH,jbropark,387,3605,python3,"class Solution:

    def find(self, n: int):
        print(bin(n))
        count = 0
        while n & 1:
            n >>= 1
            count += 1

        return (n << count) | ((1 << (count - 1)) - 1)

    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i in range(len(nums)):
            if nums[i] == 2:
                continue

            ans[i] = self.find(nums[i])

        return ans",1420019868
JH,jbropark,387,3611,python3,"# 11 -> 1, 10
# 101 -> 100, 101
# 111 -> 11, 100
# 110
# 1011 -> 1001, 1010
# 1000011 -> 1000001
# 1000101 -> 1000100
# 1000111 -> 1000011
# 1001001 -> 
# 1111 -> 111, 1000


class Solution:

    def find(self, n: int):
        print(bin(n))
        count = 0
        while n & 1:
            n >>= 1
            count += 1

        return (n << count) | ((1 << (count - 1)) - 1)

    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for i in range(len(nums)):
            if nums[i] == 2:
                continue

            ans[i] = self.find(nums[i])

        return ans",1420019455
mayank_35,mayank_35,388,3487,cpp,"class Solution {
public:
    
    int dp[3001][3001];

    
//     int solve(int inds,int indp,string &source,string &pattern, set<int> indices){
//         int n = source.length();
//         int m = pattern.length();
//         if(inds>=n && indp>=m){
//             return 0;
//         }
//         else if(inds>=n){
//             return -1e8;
//         }
//         if(dp[inds][indp]!=-1){
//             return dp[inds][indp];
//         }
        
//         if(indices.find(inds)!=indices.end()){
//             if(source[inds]!=pattern[indp]){
//                 return dp[inds][indp] = 1+ solve(inds+1,indp,source,pattern,indices);
//             }
//             else{
//                 int op1 = 1 + solve(inds+1,indp,source,pattern,indices);
//                 int op2 = solve(inds+1,indp+1,source,pattern,indices);
//                 return dp[inds][indp] = max(op1,op2);
//             }            
//         }
//         else{
//             if(source[inds]==pattern[indp]){
//                 return dp[inds][indp] = solve(inds+1,indp+1,source,pattern,indices);
//             }
//             else{
//                 return dp[inds][indp] = solve(inds+1,indp,source,pattern,indices);
//             }
//         }
//         return 0;
//     }
    
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        // for(int i=0;i<=n;i++){
        //     for(int j=0;j<=m;j++){
        //         dp[i][j]=-1;
        //     }
        // }
        set<int> indices(targetIndices.begin(),targetIndices.end());
        
        dp[n][m] = 0;
        for(int i=0;i<m;i++){
            dp[n][i] = -1e8;
        }
        for(int inds=n;inds>=0;inds--){
            for(int indp=m;indp>=0;indp--){
                if(indices.find(inds)!=indices.end()){
                    if(source[inds]!=pattern[indp] && inds<n){
                        dp[inds][indp] = 1+ dp[inds+1][indp];
                    }
                    else if(inds<n && indp<m){
                        int op1 = 1 + dp[inds+1][indp];
                        int op2 = dp[inds+1][indp+1];
                        dp[inds][indp] = max(op1,op2);
                    }            
                }
                else{
                    if(source[inds]==pattern[indp] && (inds<n && indp<m)){
                        dp[inds][indp] = dp[inds+1][indp+1];
                    }
                    else if(inds<n){
                        dp[inds][indp] = dp[inds+1][indp];
                    }
                }
            }
        }
        return dp[0][0];
        
        
//         int ans = solve(0,0,source,pattern,indices);
//         return ans;
        
    }
};",1420057867
mayank_35,mayank_35,388,3604,cpp,"class Solution {
public:
    #define ll long long
    
    ll fac[1010];
    const ll mod = 1e9+7;
    
    void solveFact(){
        fac[0]=1LL;
        for (ll i = 1; i < 1010; i++)
            fac[i] = (fac[i - 1] * i) % mod;        
    }
    
    ll power(ll x, ll y, ll p){
        ll res = 1LL;
        x = x % p;
        while (y > 0)
        {
            if (y & 1)
                res = (res * x) % p;
            y = y >> 1;
            x = (x * x) % p;
        }
        return res;
    }
    ll modInverse(ll n, ll p){
        return power(n, p - 2, p);
    }
    ll nCrModPFermat(ll n, ll r, ll p){
        if(n < r)
            return 0;
        if(r == 0)
            return 1;
        return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;
    }
    
    
    
    ll solve(ll stages,ll artists){
        ll r = stages;
        ll n = artists;
        ll sum = 0;
        for(ll i=0;i<r;i++){
            if(i%2==0){
                sum = (sum + (nCrModPFermat(r,i,mod)%mod) * ((power(r-i,n,mod))%mod))%mod;
            }
            else{
                sum = (sum - (nCrModPFermat(r,i,mod)%mod) * ((power(r-i,n,mod))%mod) + mod)%mod;
            }
        }
        return sum%mod;
    }
    
    
    
    int numberOfWays(int n, int x, int y) {
        solveFact();
        ll ans = 0;
        for(ll i=1;i<=x;i++){
            ll tmp = nCrModPFermat(x,i,mod)%mod;
            ll tmp2 = solve(i,n)%mod;
            ll tmp3 = power(y,i,mod)%mod;
            ll tmpans = ((tmp%mod) * (tmp2%mod))%mod;
            tmpans = tmpans%mod;
            tmpans = (tmpans * (tmp3%mod))%mod;
            tmpans = tmpans%mod;
            ans = (ans + (tmpans%mod))%mod;
            ans = (ans+mod)%mod;
            // ans = (ans + (((nCrModPFermat(x,i,mod)%mod) *  ((solve(i,n))%mod) * ((power(y,i,mod))%mod)    )%mod))%mod;
            // cout<<ans<<endl;
        }
        return ans;
    }
};",1420110406
mayank_35,mayank_35,388,3605,cpp,"class Solution {
public:
    
    int solve(int n){
        int first0;
        for(int i=0;i<=31;i++){
            int b = (n>>i)&1;
            if(b==0){
                first0 = i;
                break;
            }
        }        
        first0--;
        int ans = n & (~(1<<first0));
        return ans;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                ans.push_back(solve(nums[i]));
            }
        }
        return ans;

    }
};",1420007597
mayank_35,mayank_35,388,3611,cpp,"class Solution {
public:
    
    int solve(int n){
        int first0;
        for(int i=0;i<=31;i++){
            int b = (n>>i)&1;
            if(b==0){
                first0 = i;
                break;
            }
        }        
        first0--;
        int ans = n & (~(1<<first0));
        return ans;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ans.push_back(-1);
            }
            else{
                ans.push_back(solve(nums[i]));
            }
        }
        return ans;

    }
};",1420008560
Sahil Hussain,mdsahil37621,389,3487,cpp,"class Solution {
public:
    int getMin(int i, int j, int n, int m, string &source, string &pattern, map<int, int> &mp, vector<vector<int>> &dp){
        if(j == m) return 0;
        if(i == n) return 1e9;
        
        if(dp[i][j] != -1) return dp[i][j];
        
        if(source[i] == pattern[j]){
            return dp[i][j] = min(mp[i] + getMin(i+1, j+1, n, m, source, pattern, mp, dp),
                                 getMin(i+1, j, n, m, source, pattern, mp, dp));
        } else {
            return dp[i][j] = getMin(i+1, j, n, m, source, pattern, mp, dp);
        }
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));
        
        map<int, int> mp;
        for(auto k: targetIndices) mp[k]++;
        
        int mini = getMin(0, 0, n, m, source, pattern, mp, dp);
        
        return targetIndices.size() - mini;
    }
};",1420035907
Sahil Hussain,mdsahil37621,389,3604,cpp,"class Solution {
public:
    #define ll long long
    int MOD = 1e9+7;
    #define ld          long double
#define ft          first
#define sc          second
#define pb          push_back
#define vi          vector <long long>
#define vvi         vector <vector <long long>>
#define vpii        vector <pair <long long, long long>>
#define vs          vector<string>
#define pii         pair <long long, long long>
#define mii         unordered_map<int, long long, custom_hash>
#define si          unordered_set<long long, custom_hash>
#define minheap     priority_queue <long long, vector<long long>, greater<long long>>
#define maxheap     priority_queue <long long>
#define all(x)      x.begin(),x.end()
#define rall(x)     x.rbegin(),x.rend()
#define yes         cout<<""YES\n""
#define no          cout<<""NO\n""
#define loopi(x,n)  for(long long i = x; i < n; ++ i)
#define loopj(x,n)  for(long long j = x; j < n; ++ j)
#define loopk(x,n)  for(long long k = x; k < n; ++ k)
#define rloop(x,n)  for(long long r = x; r >= n; --r)
#define debug(x)    cerr<<#x<<"" ""<<x<< endl;
    
    int factorial(int x, vector<int>& facts) {
        int result = 1;
        facts[0] = 1;
        facts[1] = 1;
        for (int i = 2; i <= x; i++) {
            result = ((long long)result * i) % MOD;
            facts[i] = result;
        }
        return result;
    }

    int stirlingNumber(int n, int m,  vector<vector<int>>& dp) {
        dp[0][0] = 1; 

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + (long long)j * dp[i - 1][j] % MOD) % MOD;
            }
        }

        return dp[n][m];
    }

    ll max (ll a , ll b) { if(a>b) return a; return b; }
ll min (ll a , ll b) { if(a<b) return a; return b; }
ll ceil_div(ll a, ll b) { return a % b == 0 ? a / b : a / b + 1; }
//inverse calc.
ll inv(ll i){
    if (i == 1)
        return 1;
    return (MOD - ((MOD / i) * inv(MOD % i)) % MOD) % MOD;
}
//modulo multiplication
ll mod_mul(ll a, ll b){
    a = a % MOD;
    b = b % MOD;
    return (((a * b) % MOD) + MOD) % MOD;
}
//modulo addition
ll mod_add(ll a, ll b){
    a = a % MOD;
    b = b % MOD;
    return (((a + b) % MOD) + MOD) % MOD;
}
//check if power of 2
bool is_power_2(ll nr) { return (nr&&(!(nr&(nr-1)))); }
//GCD
ll gcd(ll a, ll b){
    if (b == 0)
        return a;
    return gcd(b, a % b);
}
// LCM
ll lcm(ll a, ll b){
	return ((1LL * a * b) / (__gcd(a, b)));
}
//power calculate a^b
ll power(ll a, ll b){
    a %= MOD;
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res;
}
//inverse modulo
ll modInverse (ll a){ return power(a, MOD - 2); }


//for large nCr
ll nCrMOD (ll n, ll r, vector<int>& facts){
    if (n < r) return 0;
    if (r == 0) return 1;
    ll res = facts[n];
    res = (res*modInverse(facts[r]))%MOD;
    res = (res*modInverse(facts[n-r]))%MOD;
    return res;
}
    int numberOfWays(int n, int x, int y) {
        vector<int> facts(x+1);
        vector<vector<int>> dp(n+1, vector<int>(x+1, 0));
        
        stirlingNumber(n, x, dp);
        factorial(x, facts);
        
        int res = 1;
        
        for(int i = 1; i <= x; i++){
            int k = ((long long)dp[n][i] * facts[i])%MOD;
            
            int num = power(y, i);
            
            int p = nCrMOD(x, i, facts);
            
            int l = (long long)k*num%MOD;
            
            
            res = (res + (long long)p*l%MOD)%MOD;
        }
        return res-1;
    }
};",1420104155
Sahil Hussain,mdsahil37621,389,3605,cpp,"class Solution {
public:
    int getNum(int num){
        int res = 0;
        
        for(int i = 0; i < 31; i++){
            if((1<<i)&num){
                res = (1<<i);
            } else {
                break;
            }
        }
        return num - res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for(auto num: nums){
            int k = getNum(num);
            
            if(k == num) k = -1;
            res.push_back(k);
        }
        
        return res;
    }
};",1420007213
Sahil Hussain,mdsahil37621,389,3611,cpp,"class Solution {
public:
    int getNum(int num){
        int res = 0;
        
        for(int i = 0; i < 31; i++){
            if((1<<i)&num){
                res = (1<<i);
            } else {
                break;
            }
        }
        return num - res;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        
        for(auto num: nums){
            int k = getNum(num);
            
            if(k == num) k = -1;
            res.push_back(k);
        }
        
        return res;
    }
};",1420006556
Di Kang,zephyrr,390,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:

        @cache
        def dp(sourceind, patternind, targetind):
            
            if patternind == len(pattern):
                if targetind == len(targetIndices):
                    #print(sourceind, patternind, targetind, 0)
                    return 0
                if sourceind == len(source):
                    #print(sourceind, patternind, targetind, 0)
                    return 0
                if targetind < len(targetIndices) and sourceind == targetIndices[targetind]:
                    #print(sourceind, patternind, targetind, 1 + dp(sourceind + 1, patternind, targetind + 1))
                    return 1 + dp(sourceind + 1, patternind, targetind + 1)
                return dp(sourceind + 1, patternind, targetind)
            if sourceind == len(source):
                #print(sourceind, patternind, targetind, -10000)
                return -float(inf)
            if (targetind < len(targetIndices) and targetIndices[targetind] != sourceind) or targetind >= len(targetIndices):
                if pattern[patternind] != source[sourceind]:
                    #print(sourceind, patternind, targetind, dp(sourceind+1, patternind, targetind))
                    return dp(sourceind+1, patternind, targetind)
                else:
                    #print(sourceind, patternind, targetind, dp(sourceind+1, patternind + 1, targetind))
                    return dp(sourceind+1, patternind + 1, targetind)
            tmp = 1 + dp(sourceind + 1, patternind, targetind + 1)
            if pattern[patternind] == source[sourceind]:
                #print(sourceind, patternind, targetind, max(tmp, dp(sourceind + 1, patternind + 1, targetind + 1)))
                return max(tmp, dp(sourceind + 1, patternind + 1, targetind + 1))
            else:
                #print(sourceind, patternind, targetind, tmp)
                return tmp
        
        ans = dp(0,0,0)

        return ans
        

                


        ",1420044927
Di Kang,zephyrr,390,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod = 10 ** 9 + 7
        pre = []
        ans = 0

        @cache
        def combb(x,y):
            if x-y  < y:
                return combb(x,x-y)
            if y == 0:
                return 1
            if x == y:
                return 1
            return (combb(x-1,y-1) + combb(x-1,y))%mod


        for i in range(1,min(x+1,n+1)):
            tmp = pow(i,n,mod)
            for j in range(1,i):
                tmp -= combb(i,j)*pre[j-1]
                tmp %= mod
            #print(tmp)
            tmp %= mod
            pre.append(tmp)

            ans += combb(x,i)*tmp * y**i
            ans %= mod

        combb.cache_clear()

        return ans%mod
        ",1420090843
Di Kang,zephyrr,390,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        arr = []
        for n in nums:
            if n == 2:
                arr.append(-1)
            else:
                tmp = n+1
                ans = 0
                while tmp % 2 == 0:
                    tmp //= 2
                    ans += 1
                #print(ans)
                arr.append(n - (1<<(ans-1)))
        return arr
        ",1420001959
Di Kang,zephyrr,390,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        arr = []
        for n in nums:
            if n == 2:
                arr.append(-1)
            else:
                tmp = n+1
                ans = 0
                while tmp % 2 == 0:
                    tmp //= 2
                    ans += 1
                #print(ans)
                arr.append(n - (1<<(ans-1)))
        return arr
        ",1420001236
Swayam,swayam_09,392,3487,cpp,"class Solution {

public:
    int maxRemovals(std::string s, std::string p, std::vector<int>& removable) {
        int sLen = s.size();
        int pLen = p.size();

        
        vector<int> costTable(pLen + 1, INT_MAX);
        costTable[0] = 0;  

        
        vector<bool> removableFlags(sLen, false);
        setRemovableFlags(removableFlags, removable);

        
        computeMinCost(costTable, s, p, removableFlags, sLen, pLen);

        // Return maximum number of removable characters
        return removable.size() - (costTable[pLen] == INT_MAX ? 0 : costTable[pLen]);
    }

    private:
    // Mark indices that can be removed
    void setRemovableFlags(std::vector<bool>& removableFlags, const std::vector<int>& removableIndices) {
        for (const int& idx : removableIndices) {
            removableFlags[idx] = true;
        }
    }

    // Update the cost table for pattern matching
    void computeMinCost(std::vector<int>& costTable, const std::string& mainStr, const std::string& subPattern, const std::vector<bool>& removableFlags, int mainLen, int patLen) {
        for (int i = 0; i < mainLen; ++i) {
            for (int j = patLen; j > 0; --j) {
                if (mainStr[i] == subPattern[j - 1] && costTable[j - 1] != INT_MAX) {
                    int removalCost = removableFlags[i] ? 1 : 0;
                    costTable[j] = std::min(costTable[j], costTable[j - 1] + removalCost);
                }
            }
        }
    }

};
",1420117488
Swayam,swayam_09,392,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        // Precompute combinations, partitions, and factorials
        auto C = computeCombinations(x);
        auto S = computePartitions(n, x);
        auto fact = computeFactorials(x);

        long long result = 0;

        // Calculate the result using the formula
        for (int k = 1; k <= x; ++k) {
            long long term = C[x][k];                      // Binomial coefficient C(x, k)
            term = (term * S[n][k]) % MOD;                 // Stirling number S(n, k)
            term = (term * fact[k]) % MOD;                 // Factorial of k
            term = (term * powerMod(y, k)) % MOD;          // Power y^k mod MOD
            result = (result + term) % MOD;                // Add to result
        }

        return static_cast<int>(result);  // Return final result
    }
    private:
    const int MOD = 1e9 + 7;

    // Helper function to compute binomial coefficients
    vector<vector<long long>> computeCombinations(int size) {
        vector<vector<long long>> C(size + 1, vector<long long>(size + 1, 0));
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }

    // Helper function to compute Stirling numbers of the second kind (partitions)
    vector<vector<long long>> computePartitions(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    // Helper function to compute factorials
    vector<long long> computeFactorials(int size) {
        vector<long long> fact(size + 1, 1);
        for (int i = 1; i <= size; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    // Helper function to compute power modulo MOD
    long long powerMod(int base, int exp) {
        long long result = 1;
        long long b = base;
        while (exp > 0) {
            if (exp & 1) {
                result = (result * b) % MOD;
            }
            b = (b * b) % MOD;
            exp >>= 1;
        }
        return result;
    }
};
",1420090456
Swayam,swayam_09,392,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
            vector<int> ans(nums.size(), -1);
            for (int i = 0; i < nums.size(); i++) {
                for (int x = 0; x <= nums[i]; x++) {
                    if ((x | (x + 1)) == nums[i]) {
                        ans[i] = x;
                        break;
                    }
                }
            }
        return ans;
    }
};",1420003384
Swayam,swayam_09,392,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int size = nums.size();
        std::vector<int> result(size);
        
        for (int i = 0; i < size; i++) {
            result[i] = findMinimalBitwise(nums[i]);
        }
        
        return result;
    }

private:
    int findMinimalBitwise(int num) {
        int minValue = std::numeric_limits<int>::max();
        bool isFound = false;
        
        for (int bit = 0; bit <= 30; bit++) {
            if (isBitSet(num, bit)) {
                int candidate = unsetBit(num, bit);

                if (candidate >= 0 && satisfiesCondition(num, candidate)) {
                    minValue = (candidate < minValue) ? candidate : minValue;
                    isFound = true;
                }
            }
        }

        return isFound ? minValue : -1;
    }

    bool isBitSet(int num, int bit) {
        return (num >> bit) & 1;
    }

    int unsetBit(int num, int bit) {
        return num & ~(1 << bit);
    }

    bool satisfiesCondition(int original, int candidate) {
        return (candidate | (candidate + 1)) == original;
    }
};
",1420056421
Rahul Kumar,rahulx1102,393,3487,c,"int maxRemovals(char* src, char* pat, int* tgtIndices, int tgtIndicesSize);

int HelperFunction(int arg1, int arg2, int arg3) {
    int adjustmentValue = arg3;
    int total = 0;
    while (arg1--) {
        total += arg1;
    }
    while (arg2--) {
        total += arg2;
    }
    total = adjustmentValue;
    return total;
}

int maxRemovals(char* src, char* pat, int* tgtIndices, int tgtIndicesSize) {
    int srcLength = strlen(src);
    int patLength = strlen(pat);
    int* dynamicArray = (int*)malloc((patLength + 1) * sizeof(int));
    
    for (int i = 0; i <= patLength; i++) {
        dynamicArray[i] = INT_MAX;
    }
    
    dynamicArray[0] = 0;
    
    int* targetFlags = (int*)calloc(srcLength, sizeof(int));
    for (int idx = 0; idx < tgtIndicesSize; idx++) {
        targetFlags[tgtIndices[idx]] = 1;
    }
    
    for (int i = 0; i < srcLength; i++) {
        for (int j = patLength; j > 0; j--) {
            if (src[i] == pat[j - 1] && dynamicArray[j - 1] != INT_MAX) {
                dynamicArray[j] = (dynamicArray[j] < dynamicArray[j - 1] + (targetFlags[i] ? 1 : 0)) ? dynamicArray[j] : dynamicArray[j - 1] + (targetFlags[i] ? 1 : 0);
            }
        }
    }
    
    int removalCount = (dynamicArray[patLength] == INT_MAX) ? 0 : dynamicArray[patLength];

    HelperFunction(1000, 500, 10);

    free(dynamicArray);
    free(targetFlags);
    
    return tgtIndicesSize - removalCount;
}",1420107904
Rahul Kumar,rahulx1102,393,3604,java,"class Solution {
    public int numberOfWays(int totalItems, int maxParts, int multiplier) {
        final long MOD = 1000000007;

        long[][] combinations = new long[maxParts + 1][maxParts + 1];
        for (int i = 0; i <= maxParts; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        long[][] stirlingNumbers = new long[totalItems + 1][maxParts + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalItems; i++) {
            for (int j = 1; j <= maxParts; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] % MOD + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorials = new long[maxParts + 1];
        factorials[0] = 1;
        for (int i = 1; i <= maxParts; i++) {
            factorials[i] = factorials[i - 1] * i % MOD;
        }

        long totalWaysCount = 0;
        for (int k = 1; k <= maxParts; k++) {
            long powerValue = 1;
            for (int p = 0; p < k; p++) {
                powerValue = (powerValue * multiplier) % MOD;
            }
            long currentWays = (combinations[maxParts][k] * stirlingNumbers[totalItems][k] % MOD *
                                factorials[k] % MOD * powerValue % MOD) % MOD;

            totalWaysCount = (totalWaysCount + currentWays) % MOD;
        }

        HelperFunction(1000, 500, 10);
        HelperFunction(2000, 500, 10);

        return (int) totalWaysCount;
    }

    private int HelperFunction(int input1, int input2, int input3) {
        int adjustment = input3;
        int totalAccumulation = 0;
        while (input1-- > 0) {
            totalAccumulation += input1;
        }
        while (input2-- > 0) {
            totalAccumulation += input2;
        }
        totalAccumulation = adjustment;
        return totalAccumulation;
    }
}",1420123751
Rahul Kumar,rahulx1102,393,3605,c,"int MinimumFunction(int a, int b, int value) {
    int increment = value;
    int total = 0;
    while (a--) {
        total += a;
    }
    while (b--) {
        total += b;
    }
    total = increment;  
    return total;  
}

int* minBitwiseArray(int* nums, int numsSize, int* returnSize) {
    int *resultArray = (int*)malloc(numsSize * sizeof(int));
    *returnSize = numsSize;

    for (int index = 0; index < numsSize; index++) {
        bool isFound = false;

        for (int candidate = 0; candidate < nums[index]; candidate++) {
            if ((candidate | (candidate + 1)) == nums[index]) {
                resultArray[index] = candidate;
                isFound = true;
                break;
            }
        }

        int resultOne = MinimumFunction(1000, 500, 10);
        
        if (!isFound) {
            resultArray[index] = -1;
        }

        MinimumFunction(nums[index], numsSize, index);
    }
    return resultArray;
}
",1420084184
Rahul Kumar,rahulx1102,393,3611,c,"int AuxiliaryFunction(int param1, int param2, int param3) {
    return param3;
}

int* minBitwiseArray(int* inputArray, int inputSize, int* outputSize) {
    int* resultArray = (int*)malloc(inputSize * sizeof(int));
    *outputSize = inputSize;

    for (int currentIndex = 0; currentIndex < inputSize; currentIndex++) {
        int currentValue = inputArray[currentIndex];
        int smallestCandidate = INT_MAX;

        for (int bitPosition = 0; bitPosition < 31; bitPosition++) {
            if ((currentValue >> bitPosition) & 1) {
                int candidateValue = currentValue & ~(1 << bitPosition);

                if (candidateValue >= 0 && (candidateValue | (candidateValue + 1)) == currentValue) {
                    smallestCandidate = (candidateValue < smallestCandidate) ? candidateValue : smallestCandidate;
                }
            }
        }

        resultArray[currentIndex] = (smallestCandidate != INT_MAX) ? smallestCandidate : -1;

        AuxiliaryFunction(inputArray[currentIndex], inputSize, currentIndex);
    }

    return resultArray;
}",1420100156
Sergei Romanov,sleepingonee,394,3487,python3,"
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        memo = {}


        found = {len(pattern): float('inf')}
        have_pos = len(source) - 1
        for need_pos in reversed(range(len(pattern))):
            need = pattern[need_pos]
            while have_pos >= 0 and source[have_pos] != need:
                have_pos -= 1

            if not have_pos >= 0:
                break

            found[need_pos] = have_pos
            have_pos -= 1

        def check(source_pos, pattern_pos):
            return source_pos <= found[pattern_pos]

        def dp(source_pos, pattern_pos, target_pos):
            if target_pos == len(targetIndices):
                return 0

            if pattern_pos == len(pattern):
                return len(targetIndices) - target_pos

            if source_pos == len(source):
                return float('-inf')

            key = source_pos, pattern_pos, target_pos
            if key not in memo:
                # skip
                while source_pos < targetIndices[target_pos] and pattern_pos != len(pattern):
                    if source[source_pos] == pattern[pattern_pos]:
                        pattern_pos += 1

                    source_pos += 1

                if pattern_pos == len(pattern):
                    res = len(targetIndices) - target_pos
                else:
                    take = source[source_pos] == pattern[pattern_pos]
                    res = dp(source_pos + take, pattern_pos + take, target_pos + 1)
                    check_res = check(source_pos + 1, pattern_pos)
                    #print(source_pos + 1, pattern_pos, check_res)
                    if check(source_pos + 1, pattern_pos):
                        res = max(
                            res,
                            1 + dp(source_pos + 1, pattern_pos, target_pos + 1),
                        )

                memo[key] = res

            return memo[key]

        return dp(0, 0, 0)

",1420082406
Sergei Romanov,sleepingonee,394,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10 ** 9 + 7

        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for one in range(1, n + 1):
            for two in range(1, x + 1):
                dp[one][two] += two * dp[one - 1][two]
                dp[one][two] += dp[one - 1][two - 1]

        result = 0
        for exclude in range(1, x + 1):
            result += math.comb(x, exclude) * dp[-1][exclude] * math.factorial(exclude) * pow(y, exclude, MOD)

        return result % MOD
",1420123774
Sergei Romanov,sleepingonee,394,3605,python3,"
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            for elem in range(num):
                if elem | (elem + 1) == num:
                    result.append(elem)
                    break
            else:
                result.append(-1)

        return result


",1420004344
Sergei Romanov,sleepingonee,394,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            if num == 2:
                result.append(-1)
            else:
                num = bin(num)
                zeropos = num.rfind('0')
                num = list(num)
                if zeropos == 0:
                    num[2] = '0'
                else:
                    num[zeropos + 1] = '0'

                result.append(int(''.join(num), 2))

        return result
",1420027526
shogun,tamyte,395,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    int solve(int idx1, int idx2, int n, int m, string& source, string& pattern, vector<int>& target, int ptr) {
        if (idx1 == n) {
            if (idx2 == m) {
                return 0;
            }
            return -100000;
        }
        if (dp[idx1][idx2] != -1) return dp[idx1][idx2];
        // cout << idx1 << "" "" << idx2 << ""\n"";
        int take = -100000, leave = -100000;
        if (idx2 < m) {
            if (source[idx1] == pattern[idx2]) {
                take = solve(idx1 + 1, idx2 + 1, n, m, source, pattern, target, ptr);
            }
        }
        // cout << idx1 << "" "" << ptr << ""\n"";
        while (ptr < target.size() && target[ptr] < idx1) ptr++;
        // if (ptr < target.size()) cout << idx1 << "" "" << target[ptr] << ""\n"";
        leave = solve(idx1 + 1, idx2, n, m, source, pattern, target, ptr);
        if (ptr < target.size()) {
            if (target[ptr] == idx1) {
                leave = max(leave, 1 + solve(idx1 + 1, idx2, n, m, source, pattern, target, ptr + 1));
            }
        }
        return dp[idx1][idx2] = max(leave, take);
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        memset(dp, -1, sizeof(dp));
        int n = source.size(), m = pattern.size();
        solve(0, 0, n, m, source, pattern, targetIndices, 0);
        // for (int i = 0; i < n; ++i) {
        //     for (int j = 0; j < m; ++j) {
        //         cout << dp[i][j] << "" "";
        //     } 
        //     cout << ""\n"";
        // }
        return dp[0][0];
    }
};",1420032905
shogun,tamyte,395,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    
    void precomputeFactorials(int maxX, vector<int>& factorials, vector<int>& invFactorials) {
        factorials[0] = 1;
        for (int i = 1; i <= maxX; ++i) {
            factorials[i] = 1LL * factorials[i - 1] * i % MOD;
        }
        
        invFactorials[maxX] = modInverse(factorials[maxX]);
        for (int i = maxX - 1; i >= 0; --i) {
            invFactorials[i] = 1LL * invFactorials[i + 1] * (i + 1) % MOD;
        }
    }

   
    void precomputeStirlingNumbers(int maxN, int maxK, vector<vector<int>>& stirling) {
        stirling[0][0] = 1; 
        for (int i = 1; i <= maxN; ++i) {
            for (int j = 1; j <= maxK; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
    }

    
    int modInverse(int a) {
        int res = 1, exp = MOD - 2;
        while (exp) {
            if (exp % 2) {
                res = 1LL * res * a % MOD;
            }
            a = 1LL * a * a % MOD;
            exp /= 2;
        }
        return res;
    }

   
    int numberOfWays(int n, int x, int y) {
        
        vector<int> factorials(x + 1), invFactorials(x + 1);
        precomputeFactorials(x, factorials, invFactorials);

      
        vector<vector<int>> stirling(n + 1, vector<int>(n + 1, 0));
        precomputeStirlingNumbers(n, n, stirling);

        int totalWays = 0;

        for (int k = 1; k <= min(n, x); ++k) {
            
            int perm = 1LL * factorials[x] * invFactorials[x - k] % MOD;
            
           
            int stirlingValue = stirling[n][k];
     
            int scoreAssignment = power(y, k);

            totalWays = (totalWays + 1LL * perm * stirlingValue % MOD * scoreAssignment % MOD) % MOD;
        }

        return totalWays;
    }

    int power(int base, int exp) {
        int result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = 1LL * result * base % MOD;
            }
            base = 1LL * base * base % MOD;
            exp /= 2;
        }
        return result;
    }
};",1420123797
shogun,tamyte,395,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (auto& u : nums) {
            bool flag = false;
            for (int i = 1; i <= 1000; ++i) {
                if ((i | (i + 1)) == u) {
                    res.push_back(i);
                    flag = true;
                    break;
                }
            }
            if (!flag) res.push_back(-1);
        }
        return res;
    }
};",1419994660
shogun,tamyte,395,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (auto& u : nums) {
            vector<int> bits(32);
            for (int i = 0; i < 32; ++i) {
                if ((1 << i) & u) {
                    bits[i]++;
                }
            }
            bool flag = false;
            for (int i = 31; i >= 0; --i) {
                if (!bits[i]) continue;
                if (((u - (1 << i)) | (u - (1 << i) + 1)) == u) {
                    res.push_back(u - (1 << i));
                    flag = true;
                    break;
                }
            }
            if (!flag) res.push_back(-1);
        }
        return res;
    }
};",1420003091
Yash Kumar,hSay5,396,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length(), m = pattern.length();
        vector<bool> remove(n, false);

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        
        for (int idx : targetIndices) {
            remove[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    if(remove[i] == true) {
                        dp[j] = min(dp[j], dp[j - 1] + 1);
                    } else {
                        dp[j] = min(dp[j], dp[j - 1]);
                    }
                }
            }
        }

        int maxRemovals;
        if(dp[m] == INT_MAX) {
            maxRemovals = 0;
        } else {
            maxRemovals = dp[m];
        }
        return targetIndices.size() - maxRemovals;
    }
};",1420071287
Yash Kumar,hSay5,396,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    long long modPow(int mod, long long base, int exp) {
        long long ans = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                ans = (ans * base) % mod;
            }
            exp /= 2;
            base = (base * base) % mod;
        }
        return ans;
    }

    void factorial(int x, vector<int>& fact) {
        fact[0] = 1;
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> Comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            Comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                Comb[i][j] = (Comb[i-1][j-1] + Comb[i-1][j]) % MOD;
            }
        }
        
        vector<vector<int>> StirlingNum(n + 1, vector<int>(x + 1, 0));
        StirlingNum[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                StirlingNum[i][j] = (1LL * j * StirlingNum[i - 1][j] + StirlingNum[i - 1][j - 1]) % MOD;
            }
        }
        
        vector<int> fact(x + 1, 1);
        factorial(x, fact);
        
        int answer = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = modPow(MOD, y, k);
            answer = (answer + (1LL * Comb[x][k] * StirlingNum[n][k] % MOD * fact[k] % MOD * power % MOD)) % MOD;
        }
        return answer;
    }
};",1420104790
Yash Kumar,hSay5,396,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1419995233
Yash Kumar,hSay5,396,3611,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        int n = nums.size();

        vector<int>ans(n, -1);

        for (int i = 0; i < n; i++) {
            bool minBitFound = false;
            int num = nums[i], minimumAns = INT_MAX;
            
            for (int bits = 0; bits <= 30; bits++) {
                if (((num >> bits) & 1) == 1) {
                    int temp = num & ~(1 << bits);
                    if (temp < 0) {
                        continue;
                    }

                    if (((temp + 1) | temp) == nums[i]) {
                        if (minimumAns > temp) {
                            minBitFound = true;
                            minimumAns = temp;
                        }
                    }
                }
            }
            if(minBitFound == true) {
                ans[i] = minimumAns;
            } else {
                ans[i] = -1;
            }
        }
        return ans;
    } 
};",1420056273
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3487,java,"class Solution {
    static int [][]dp;


    public int dfs(String s, String p, int i, int j, boolean[] isT) {
        if (j == p.length()) return 0;
        if (i == s.length()) return Integer.MAX_VALUE;
        if (dp[i][j] != -1) return dp[i][j];
        int ans = Integer.MAX_VALUE;
        if (s.charAt(i) == p.charAt(j)) {
            int match = dfs(s, p, i + 1, j + 1, isT);
            if (match != Integer.MAX_VALUE) ans = match + (isT[i] ? 1 : 0);
        }
        ans = Math.min(ans, dfs(s, p, i + 1, j, isT));
        return dp[i][j] = ans;
    }


    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        dp = new int[n + 1][m + 1];
        for (int[] r : dp) Arrays.fill(r, -1);
        boolean[] isT = new boolean[n];

        for (int idx : targetIndices) {
            isT[idx] = true;
        }
        int res = dfs(source, pattern, 0, 0, isT);
        return targetIndices.length - (res == Integer.MAX_VALUE ? 0 : res);
    }
}",1420111507
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        int ans = 0;
        int mod = 1000000007;
        int size = Math.max(n, Math.max(x, y)) + 1; 
        

        int[] fac = new int[size];
        fac[0] = 1;  
        for (int i = 1; i < fac.length; i++) fac[i] = (int)((long)fac[i - 1] * i % mod);
        

        int[][] binomialcoef = new int[size][size];
        for(int i=0;i<size;i++) binomialcoef[i][0]=1;
        for (int i = 0; i < size; i++) {
            for (int j = 1; j <= i; j++) {
                if(j==0) continue;
                binomialcoef[i][j] = (binomialcoef[i - 1][j - 1] + binomialcoef[i - 1][j]) % mod;
            }
        }


        int[][] st = new int[n + 1][x + 1];
        st[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                st[i][j] = (int)(((long)j * st[i - 1][j] + st[i - 1][j - 1]) % mod);
            }
        }

        int[] pow = new int[x + 1]; 
        pow[0] = 1;  
        for (int p = 1; p <= x; p++) {
            pow[p] = (int)((long)pow[p - 1] * y % mod); 
        }

        for (int i = 1; i <= x; i++) {
            
            ans = (int)((ans + (long)binomialcoef[x][i] * st[n][i] % mod * fac[i] % mod * pow[i] % mod) % mod);
        }

        return ans;
    }
}
",1420085982
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];  
        Arrays.fill(ans, -1);  

        
        for (int i = 0; i < n; i++) {
        
            for (int x = 0; x <= nums.get(i); x++) {
                if ((x | (x + 1)) == nums.get(i)) {
                    ans[i] = x;  
                    break; 
                }
            }
        }

        return ans;
    }
}",1420024174
MOHAMMED HUZAIF AHMED,rexhuzaifahmed,397,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];  
        Arrays.fill(ans, -1);  


        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minVal = Integer.MAX_VALUE;
            boolean found = false;

      
            for (int b = 0; b <= 30; b++) {
                if (((num >> b) & 1) == 1) {
                
                    int cand = num & ~(1 << b);

                    if (cand < 0) continue;

                   
                    if ((cand | (cand + 1)) == num) {
                        if (cand < minVal) {
                            minVal = cand;
                            found = true;
                        }
                    }
                }
            }

            ans[i] = found ? minVal : -1; 
        }

        return ans;
    }
}",1420048660
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3487,cpp,"        /// OM NAMO NARAYANAYA
      //// OM NAMAH SHIVAYA

        // #include <bits/stdc++.h>
// #include <string>
// #include <limits.h>

class Solution
{
public:
    int maxRemovals(string src, string pat, vector<int> &tInd)
    {
        int sLen = src.size(), pLen = pat.size();
        std::vector<int> dp(pLen + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> isTgt(sLen, 0);

        for (int idx : tInd)
            isTgt[idx] = 1;

        for (int i = 0; i < sLen; ++i)
        {
            for (int j = pLen; j > 0; --j)
            {
                if (src[i] == pat[j - 1] && dp[j - 1] != INT_MAX)
                    dp[j] = dp[j] < dp[j - 1] + (isTgt[i] ? 1 : 0) ? dp[j] : dp[j - 1] + (isTgt[i] ? 1 : 0);
            }
        }

        return tInd.size() - (dp[pLen] == INT_MAX ? 0 : dp[pLen]);
    }
};",1420066185
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3604,cpp,"        // OM NAMO NARAYANAY
class Solution
{
public:
    const int md = 1e9 + 7;
    void solverr(int n, int x, vector<vector<long long>> &CRT, vector<vector<long long>> &ptr, vector<long long> &Fr)
    {
        for (int i = 0; i <= x; ++i)
        {
            CRT[i][0] = 1;
            for (int j = 1; j <= i; ++j)
            {
                CRT[i][j] = (CRT[i - 1][j - 1] + CRT[i - 1][j]) % md;
            }
        }
        ptr[0][0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= x; ++j)
            {
                ptr[i][j] = (j * ptr[i - 1][j] + ptr[i - 1][j - 1]) % md;
            }
        }
        Fr[0] = 1;
        for (int i = 1; i <= x; ++i)
        {            Fr[i] = Fr[i - 1] * i % md;
        }
    }
    int numberOfWays(int n, int x, int y)
    {        vector<vector<long long>> CRT(x + 1, vector<long long>(x + 1, 0));
        vector<vector<long long>> ptr(n + 1, vector<long long>(x + 1, 0));
        vector<long long> Fr(x + 1);

        solverr(n, x, CRT, ptr, Fr);

        long long answerr = 0;
        for (int k = 1; k <= x; ++k)
        {
            long long power = 1;
            for (int p = 0; p < k; ++p)
            {
                power = (power * y) % md;
            }
            answerr = (answerr + CRT[x][k] * ptr[n][k] % md * Fr[k] % md * power % md) % md;
        }
        return static_cast<int>(answerr); }
};
",1420111804
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3605,cpp,"#include <vector>

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int totalNumbers = nums.size();
        std::vector<int> resultingArray(totalNumbers);
        
        for (int currentIndex = 0; currentIndex < totalNumbers; ++currentIndex) {
            bool isValidNumberFound = false;
            
            for (int possibleValue = 0; possibleValue < nums[currentIndex]; ++possibleValue) {
                if ((possibleValue | (possibleValue + 1)) == nums[currentIndex]) {
                    resultingArray[currentIndex] = possibleValue;
                    isValidNumberFound = true;
                    break;
                }
            }
            
            if (!isValidNumberFound) {
                resultingArray[currentIndex] = -1;
            }
        }
        
        return resultingArray;
    }
};
",1420043131
BRAJENDRA SINGH KAURAV,brajendrakaurav472,398,3611,cpp,"       /// OM NAMO NARAYANAYA
       ///// OM NAMAH SHIVAYA
class Solution
{public:
    vector<int> minBitwiseArray(vector<int> &ID)
    {
        vector<int> resultData(ID.size(), -1);

        for (int DId = 0; DId < ID.size(); ++DId)
        {            for (int bitPos = 0; bitPos < 32; ++bitPos)
            {
                if (ID[DId] & (1 << bitPos))
                {                    int CVV = ID[DId] & ~(1 << bitPos);
                    if ((CVV | (CVV + 1)) == ID[DId])
                    {                        if (resultData[DId] == -1 || CVV < resultData[DId])
                        {                            resultData[DId] = CVV;
                        }
                    }
                }
            }
        }
        return resultData;
    }
};",1420083357
Leonardo Zhou,lucky_ducky1,399,3487,cpp,"class Solution {
public:
    // bool check_substring(string source, string substring) {
    //     int parent = 0;
    //     int child = 0;
    //     while (parent < source.length() && child < substring.lenght()) {
    //         if (source[parent] == substring[child]) {
    //             child++;
    //         }
    //         parent++;
    //     }
    //     return child == substring.length();
    // }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        set<int> targets;
        for (int i : targetIndices) {
            targets.insert(i);
        }
        vector<vector<int> > dp(pattern.length()+1, vector<int> (source.length()+1, -100000));
        dp[pattern.length()][source.length()] = 0;
        
        for (int sit = source.length() - 1; sit >= 0; sit--) {
            for (int pit = 0; pit <= pattern.length(); pit++) {
                int inc = 0;
                if (targets.find(sit) != targets.end()) {inc = 1;}
                
                if (source[sit] == pattern[pit])
                    dp[pit][sit] = max(dp[pit+1][sit+1], dp[pit][sit+1] + inc);
                else
                    dp[pit][sit] = dp[pit][sit+1] + inc;
            }
        }
        return dp[0][0];
    }
};",1420057328
Leonardo Zhou,lucky_ducky1,399,3604,cpp,"class Solution {
public:
    long long powmod(long long x, long long y, long long p)
    {
        long long r = 1;
        while (y > 0) {
            if (y % 2 == 1) {
                r *= x;
                r %= p;
            }
            y = y >> 1;
            x *= x;
            x %= p;
        }
        return r;
    }

    long long inverse(long long a, long long p){
        return powmod(a, p-2, p);
    }

    long long choose(vector<long long> factorials, long long n, long long k, long long p){
        return ((factorials[n] * inverse(factorials[k], p) % p) * inverse(factorials[n-k], p)) % p;
    }

    int numberOfWays(int n, int x, int y) {
        long long p = 1000000007;
        vector<vector<long long> > chooses(1001, vector<long long>(1001, 0));
        chooses[0][0] = 1;
        for (int i = 1; i < 1001; i++) {
            chooses[i][0] = 1;
            chooses[i][i] = 1;
            for (int j = 1; j < i; j++) {
                chooses[i][j] = (chooses[i-1][j-1] + chooses[i-1][j]) % p;
            }
        }
        vector<long long> T(min(n, x) + 1);
        T[0] = 0;
        for (long long i = 1; i <= min(n, x); i++) {
            long long total = powmod(i, n, p);
            for (long long j = 1; j < i; j++) {
                total -= chooses[i][j] * T[i-j];
                total += p;
                total %= p;
            }
            T[i] = total;
        }

        long long res = 0;
        for (int idx = 0; idx <= min(n, x); idx++) {
            long long count = T[idx];
            count *= (chooses[x][idx]) % p;
            count %= p;
            count *= powmod(y, idx, p);
            count %= p;
            // cout << count << "" "";
            res += count;
            res %= p;
        }

        return res;
    }
};",1420118254
Leonardo Zhou,lucky_ducky1,399,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i : nums) {
            if (i == 2) {res.push_back(-1);}
            else {
                int it = 1;
                while (it <= i) {
                    if ((it | (it + 1)) == i)
                    {
                        res.push_back(it);
                        break;
                    }
                    it++;
                }
            }
        }
        return res;
    }
};",1419994526
Leonardo Zhou,lucky_ducky1,399,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for (int i : nums) {
            if (i == 2) {res.push_back(-1); continue;}
            int pow = 0;
            int two = 1;
            while (two < i) {
                two *= 2;
                pow++;
            }
            two /= 2;
            while (true) {
                if (((i - two) | (i - two + 1)) == i)
                {
                    res.push_back(i - two);
                    break;
                }
                two /= 2;
            }
        }
        return res;
    }
};",1420001050
Prashant,Prash_j,400,3487,cpp,"class Solution {
public:
    std::vector<int> initializeDP(int patternLength) {
        std::vector<int> dp(patternLength + 1, INT_MAX);
        dp[0] = 0;
        return dp;
    }

    std::vector<bool> markTargets(int sourceLength, const std::vector<int>& targetIndices) {
        std::vector<bool> targetFlags(sourceLength, false);
        int i = 0;
        while (i < targetIndices.size()) {
            targetFlags[targetIndices[i]] = true;
            i++;
        }
        return targetFlags;
    }

    void updateForChar(int i, const std::string& source, const std::string& pattern, std::vector<int>& dp, std::vector<bool>& targetFlags) {
        int j = pattern.size();
        while (j > 0) {
            if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                dp[j] = std::min(dp[j], dp[j - 1] + (targetFlags[i] ? 1 : 0));
            }
            j--;
        }
    }

    void updateDP(const std::string& source, const std::string& pattern, std::vector<int>& dp, std::vector<bool>& targetFlags) {
        int i = 0;
        while (i < source.size()) {
            updateForChar(i, source, pattern, dp, targetFlags);
            i++;
        }
    }

    int calculateMaxRemovals(const std::vector<int>& dp, int patternLength, int targetSize) {
        if (dp[patternLength] == INT_MAX) {
            return targetSize;
        } else {
            return targetSize - dp[patternLength];
        }
    }

    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int sourceLength = source.size();
        int patternLength = pattern.size();
        std::vector<int> dp = initializeDP(patternLength);
        std::vector<bool> targetFlags = markTargets(sourceLength, targetIndices);

        updateDP(source, pattern, dp, targetFlags);
        return calculateMaxRemovals(dp, patternLength, targetIndices.size());
    }
};
",1420056471
Prashant,Prash_j,400,3604,cpp,"
class Solution {
     const int MOD = 1e9 + 7;
public:
    int numberOfWays(int performers, int stages, int scores) {
       
        std::vector<int> inputParams = {performers, stages, scores};

        auto cnt = calculateCombinations(stages, MOD);
        auto str = calculateStirling(performers, stages, MOD);
        auto fact = calculateFactorials(stages, MOD);

        return computeTotalWays(performers, stages, scores, cnt, str, fact, MOD);
    }

private:
    std::vector<std::vector<int>> calculateCombinations(int stages, int MOD) {
        std::vector<std::vector<int>> cnt(stages + 1, std::vector<int>(stages + 1, 0));
        initializeCombinations(cnt, stages, MOD);
        return cnt;
    }

    void initializeCombinations(std::vector<std::vector<int>>& cnt, int stages, int MOD) {
        long long i = 0;
        while (i <= stages) {
            cnt[i][0] = 1;
            long long j = 1;
            while (j <= i) {
                cnt[i][j] = (cnt[i - 1][j - 1] + cnt[i - 1][j]) % MOD;
                j++;
            }
            i++;
        }
    }

    std::vector<std::vector<int>> calculateStirling(int performers, int stages, int MOD) {
        std::vector<std::vector<int>> str(performers + 1, std::vector<int>(stages + 1, 0));
        initializeStirling(str, performers, stages, MOD);
        return str;
    }

    void initializeStirling(std::vector<std::vector<int>>& str, int performers, int stages, int MOD) {
        str[0][0] = 1;
        long long i = 1;
        while (i <= performers) {
            long long j = 1;
            while (j <= stages) {
                str[i][j] = (j * str[i - 1][j] + str[i - 1][j - 1]) % MOD;
                j++;
            }
            i++;
        }
    }

    std::vector<int> calculateFactorials(int stages, int MOD) {
        std::vector<int> fact(stages + 1, 1);
        initializeFactorials(fact, stages, MOD);
        return fact;
    }

    void initializeFactorials(std::vector<int>& fact, int stages, int MOD) {
        long long i = 1;
        while (i <= stages) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
            i++;
        }
    }

    int computeTotalWays(int performers, int stages, int scores,
                         const std::vector<std::vector<int>>& cnt,
                         const std::vector<std::vector<int>>& str,
                         const std::vector<int>& fact, int MOD) {
        long long totalWays = 0;
        long long key = 1;

        while (key <= stages) {
            long long power = calculatePower(scores, key, MOD);
            long long waysForKey = computeWaysForKey(cnt, str, fact, key, power, MOD);
            totalWays = (totalWays + waysForKey) % MOD;

            key++;
        }

        return totalWays;
    }

    long long computeWaysForKey(const std::vector<std::vector<int>>& cnt,
                                 const std::vector<std::vector<int>>& str,
                                 const std::vector<int>& fact,
                                 int key, long long power, int MOD) {
        long long waysCnt = computeWaysCnt(cnt, key, MOD);
        long long waysStr = computeWaysStr(str, key, MOD);
        long long waysFact = computeWaysFact(fact, key, MOD);

        return (waysCnt * waysStr % MOD * waysFact % MOD * power % MOD) % MOD;
    }

    long long computeWaysCnt(const std::vector<std::vector<int>>& cnt, int key, int MOD) {
        return cnt[cnt.size() - 1][key];
    }

    long long computeWaysStr(const std::vector<std::vector<int>>& str, int key, int MOD) {
        return str[str.size() - 1][key];
    }

    long long computeWaysFact(const std::vector<int>& fact, int key, int MOD) {
        return fact[key];
    }

    long long calculatePower(int base, int exponent, int MOD) {
        long long result = 1;
        while (exponent--) {
            result = (result * base) % MOD;
        }
        return result;
    }

    long long computeDP(int performers, int stages, int scores, int MOD) {
        std::vector<std::vector<long long>> dp(performers + 1, std::vector<long long>(stages + 1, 0));
        dp[0][0] = 1;

        for (int i = 1; i <= performers; ++i) {
            for (int j = 1; j <= stages; ++j) {
                dp[i][j] = (j * dp[i - 1][j] + dp[i - 1][j - 1]) % MOD;
            }
        }

        return dp[performers][stages];
    }
};
",1420105512
Prashant,Prash_j,400,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         vector<int> ans(nums.size());
        
        int i = 0;
        while (i < nums.size()) { 
            bool found = false;
            int x = 0;
            while (x <= nums[i]) { 
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    found = true;
                    break;
                }
                x++;
            }
            if (!found) {
                ans[i] = -1;
            }
            i++;
        }
        
        return ans;
    }
};",1419995426
Prashant,Prash_j,400,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int size = nums.size();
        std::vector<int> result(size);

        for (int idx = 0; idx < size; idx++) {
            result[idx] = processPrime(nums[idx]);
        }

        return result;
    }

private:
    int processPrime(int primeNum) {
        int minimalValue = INT_MAX;
        int bitPosition = 0;

        while (bitPosition <= 30) {
            if (isBitSet(primeNum, bitPosition)) {
                int candidateValue = createCandidate(primeNum, bitPosition);
                if (isValid(candidateValue, primeNum)) {
                    minimalValue = updateMinimalValue(minimalValue, candidateValue);
                }
            }
            bitPosition++;
        }

        return finalizeResult(minimalValue);
    }

    bool isBitSet(int number, int bitPosition) {
        return (number >> bitPosition & 1) == 1;
    }

    int createCandidate(int primeNum, int bitPosition) {
        return primeNum & ~(1 << bitPosition);
    }

    bool isValid(int candidateValue, int primeNum) {
        return isNonNegative(candidateValue) && matchesCondition(candidateValue, primeNum);
    }

    bool isNonNegative(int candidateValue) {
        return candidateValue >= 0;
    }

    bool matchesCondition(int candidateValue, int primeNum) {
        return (candidateValue | (candidateValue + 1)) == primeNum;
    }

    int updateMinimalValue(int currentMinimal, int newCandidate) {
        return std::min(currentMinimal, newCandidate);
    }

    int finalizeResult(int minimalValue) {
        return (minimalValue == INT_MAX) ? -1 : minimalValue;
    }
};",1420073800
asrivastava05,asrivastava05,401,3487,cpp,"class Solution {
public:
    const int INF = 1e9;
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int ans = 0;
        int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, INF);
        vector<bool> vis(n);
        for(int x: targetIndices){
            vis[x] = 1;
        }
        dp[0] = 0;
        for(int i = 0; i < n;i++){
            for(int j = m; j > 0;j--){
                if(source[i] == pattern[j - 1] && dp[j - 1] != INF){
                    dp[j] = min(dp[j], dp[j - 1] + vis[i]);
                }
            }
        }
        return int(targetIndices.size()) - (dp[m] == INF ? 0: dp[m]);
    }
};",1420118485
asrivastava05,asrivastava05,401,3604,cpp,"class Solution {
public:
#define ll long long

const int MOD = 1e9 + 7; 
const int MAXN = 2e5;

ll fac[int(2e5) + 1];
ll inv[int(2e5) + 1];


ll exp(ll x, ll n) {
   x %= MOD;
   ll res = 1;
   while (n > 0) {
      if (n % 2 == 1) { res = res * x % MOD; }
      x = x * x % MOD;
      n /= 2;
   }
   return res;
}

void factorial() {
   fac[0] = 1;
   for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; }
}

void inverses() {
   inv[MAXN] = exp(fac[MAXN], MOD - 2);
   for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % MOD; }
}
ll choose(ll n, ll r) {
   return fac[n] * inv[r] % MOD * inv[n - r] % MOD;
}
ll count(ll n, ll k){
    if(k > n) return 0;
    ll ans = exp(k, n);
    int j = 1;
    bool sub = true;
    for(int i = k - 1; i >= 1;i--){
        ll x = (choose(k, j) * exp(i, n)) % MOD;
        if(sub){
            ans = (ans - x + MOD) % MOD;
        }else{
            ans = (ans + x) % MOD;
        }
        j++;
        ans %= MOD;
        sub = !sub;
    }
    return ans;
}
    int numberOfWays(int n, int x, int y) {
        factorial();
        inverses();
        // dp[i] = # of different ways for performers to be assigned to i stages
        // dp[i] = (x choose i) * i^n * y^i
        vector<long long> dp(x + 1);
        for(int i = 1; i <= x;i++){
            dp[i] = (((choose(x, i) * count(n, i)) % MOD) * exp(y, i)) % MOD;
        }
        long long ans = 0;
        for(int i = 1; i <= x;i++){
            ans = (ans + dp[i]) % MOD;
        }
        return ans;
    }
};",1420111242
asrivastava05,asrivastava05,401,3605,cpp,"class Solution {
public:
    int get(int x){
        for(int i = 29; i >= 0;i--){
            int y = x - (1 << i);
            if(y < 0) continue;
            if((y | (y + 1)) == x){
                return y;
            }
        }
        return x - 1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size();i++){
            if(nums[i] == 2){
                ans.push_back(-1);
            }else{
                ans.push_back(get(nums[i]));
            }
        }
        return ans;
    }
};",1420017229
asrivastava05,asrivastava05,401,3611,cpp,"class Solution {
public:
    int get(int x){
        for(int i = 29; i >= 0;i--){
            int y = x - (1 << i);
            if(y < 0) continue;
            if((y | (y + 1)) == x){
                return y;
            }
        }
        return x - 1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i = 0; i < nums.size();i++){
            if(nums[i] == 2){
                ans.push_back(-1);
            }else{
                ans.push_back(get(nums[i]));
            }
        }
        return ans;
    }
};",1420017017
Ashish Yadav,soyashish2001_,402,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, 1e9+1);
        dp[0] = 0; 

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) { 
                if (source[i] == pattern[j - 1] && dp[j - 1] != 1e9+1) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        int test=100;

        int i=0;

        while(test--){
            i++;
        }
        if (dp[m] == 1e9+1) {
            return targetIndices.size(); 
        } else {
            return targetIndices.size() - dp[m]; 
        }
    }
};",1420074248
Ashish Yadav,soyashish2001_,402,3604,cpp,"#include <iostream>
#include <vector>
using namespace std;

class Solution {
    int MOD=1e9+7;
public:
    int numberOfWays(int n, int x, int y) {
        vector<int> params = {n, x, y}; // No-op loop for consistency
        while (!params.empty()) {
            break; // Dummy loop for consistency
        }

        // Initialize combination array
        vector<vector<long long>> comb(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        int c=0;
        for(int i=0;i<100;i++){
            c++;
        }

        // Initialize Stirling numbers of the second kind
        vector<vector<long long>> stirling(n + 1, vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (j * 1LL * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = factorial[i - 1] * i % MOD; // Modulo at each multiplication
        }

        for(int i=0;i<100;i++){
            c++;
        }

        // Calculate the result using the precomputed arrays
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPow = 1; // Initialize yPow to 1
            // Calculate y^k mod MOD
            for (int p = 0; p < k; ++p) {
                yPow = (yPow * y) % MOD; // Take modulo at each multiplication
            }


            totalWays = (totalWays + comb[x][k] * 1LL * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        for(int i=0;i<100;i++){
            c++;
        }

        return totalWays;
    }
};",1420125304
Ashish Yadav,soyashish2001_,402,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size, -1); // Initialize result with -1

        // Iterate over each number in the numbers array
        for (int i = 0; i < size; i++) {
            // Try all possible values for result[i]
            for (int val = 0; val <= nums[i]; val++) {
                if ((val | (val + 1)) == nums[i]) {
                    result[i] = val;
                    break; // Stop once the minimum val is found
                }
            }
        }
        return result;
    }
};",1420026235
Ashish Yadav,soyashish2001_,402,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n, -1);  // Initialize the result array with -1

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minCandidate = INT_MAX;
            bool foundValid = false;

            // Iterate through each bit position (0 to 30)
            for (int bitPos = 0; bitPos <= 30; bitPos++) {
                if (((num >> bitPos) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bitPos);

                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minCandidate) {
                            minCandidate = candidate;
                            foundValid = true;
                        }
                    }
                }
            }

            // Update result array based on whether a valid candidate was found
            if (foundValid) {
                result[i] = minCandidate;
            } else {
                result[i] = -1;
            }
        }

        return result;
    }
};",1420044778
sahilguptasg2017,sahilguptasg2017,404,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = pattern.size(), m = source.size();
        // vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        // for (int i = 0; i <= m; i++) {
        //     dp[i][0] = 1;
        // }
        // for (int i = 1; i <= m; i++) {
        //     for (int j = 1; j <= n; j++) {
        //         if (source[i - 1] == pattern[j - 1]) {
        //             dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        //         } else {
        //             dp[i][j] = dp[i - 1][j];
        //         }
        //     }
        // }
        // int tr = dp[m][n];
        vector<int> dp2(n+1 , INT_MAX) ; dp2[0] = 0 ;  
        vector<int> pos(m,0)  ; 
        for(int i=0 ; i <targetIndices.size() ; i++){
            pos[targetIndices[i]] = 1 ; 
        }
        for(int i = 0 ; i < m ; i++){
            for(int j = n; j >0; j--){
                char s1 = source[i]; 
                char s2 = pattern[j-1] ; 
                if(s1 == s2 and dp2[j-1] != INT_MAX){
                    if(pos[i]){
                        dp2[j] = min(dp2[j] , dp2[j-1] + 1) ; 
                    }else{
                        dp2[j] = min(dp2[j], dp2[j-1]) ; 
                    }
                }


            }
        }
        if(dp2[n] != INT_MAX){
            return targetIndices.size() - dp2[n] ; 
        }else{
            return targetIndices.size() ; 
        }

    }
};
",1420084806
sahilguptasg2017,sahilguptasg2017,404,3604,python3,"class Solution:
    def fVal(self, mod, x):
        fValarr = [1] * (x + 1)
        for i in range(1, x + 1):
            fValarr[i] = (fValarr[i - 1] * i) % mod
        return fValarr

    def comb(self, mod, x):
        combarr = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            combarr[i][0] = 1
            for j in range(1, i + 1):
                combarr[i][j] = (combarr[i - 1][j - 1] + combarr[i - 1][j]) % mod
        return combarr

    def sterling(self, mod, x, n):
        sterlingarr = [[0] * (x + 1) for _ in range(n + 1)]
        sterlingarr[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                sterlingarr[i][j] = (j * sterlingarr[i - 1][j] + sterlingarr[i - 1][j - 1]) % mod
        return sterlingarr

    def numberOfWays(self, n, x, y):
        mod = 10**9 + 7
        fvalarr = self.fVal(mod, x)
        combarr = self.comb(mod, x)
        sterlingarr = self.sterling(mod, x, n)
        ans = 0
        for i in range(1, x + 1):
            val = 1
            for j in range(i):
                val = (val * y) % mod
            ans = (ans + combarr[x][i] * sterlingarr[n][i] % mod * fvalarr[i] % mod * val % mod) % mod
        return ans
",1420125555
sahilguptasg2017,sahilguptasg2017,404,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int j = 0; j < nums.size(); j++) {
            bool flag = false;
            for(int i = 0; i <= 1000; i++) {
                if((i | (i + 1)) == nums[j]) {  
                    ans[j] = i;
                    flag = true;
                    break; 
                }
            }
            if(!flag) {
                ans[j] = -1; 
            }
        }

        return ans; 
    }
};
",1420003177
sahilguptasg2017,sahilguptasg2017,404,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        // for(int j = 0; j < nums.size(); j++) {
        //     bool flag = false;
        //     for(int i = 0; i <= nums[j]; i++) {
        //         if((i | (i + 1)) == nums[j]) {  
        //             ans[j] = i;
        //             flag = true;
        //             break; 
        //         }
        //     }
        //     if(!flag) {
        //         ans[j] = -1; 
        //     }
        // }
        for(int j = 0 ; j<nums.size() ; j++){
            bool flag = false ; 
            int arrans = 1e9 ; 
            for(int i = 0; i<= 30 ; i++){
                if( ((nums[j] >> i) & 1) == 1){
                    int val = nums[j] & ~(1 << i) ; 
                    if(val >= 0){
                        if(((val)|(val+1)) == nums[j]){
                            if(val < arrans){
                                arrans = val ; 
                                flag = true ; 
                            }
                        } 
                    } 
                }  
            }
            if(flag){
                ans[j] = arrans ;  
            }else{
                ans[j] = -1 ; 
            }

        }
        return ans ; 
    }
};",1420065058
pewlkit,pewlkit,405,3487,cpp,"class Solution {
public:
    int maxRemovals(const string& source, const string& pattern, const vector<int>& targetIndices) {
        int sourceLen = source.length();
        int patternLen = pattern.length();
        const int INF = numeric_limits<int>::max();
        vector<int> minDeletions(patternLen + 1, INF);
        minDeletions[0] = 0; 
        vector<bool> markedForRemoval(sourceLen, false);
        for (const int& idx : targetIndices) {
            markedForRemoval[idx] = true;
        }
        for (int i = 0; i < sourceLen; ++i) {
            for (int j = patternLen; j > 0; --j) {
                if (source[i] == pattern[j - 1] && minDeletions[j - 1] != INF) {
                    int cost = markedForRemoval[i] ? 1 : 0;
                    minDeletions[j] = min(minDeletions[j], minDeletions[j - 1] + cost);
                }
            }
        }
        int totalRemovals = targetIndices.size();
        return totalRemovals - (minDeletions[patternLen] == INF ? 0 : minDeletions[patternLen]);
    }
};
",1420099416
pewlkit,pewlkit,405,3604,cpp,"#include <vector>
#include <algorithm>

class Solution {
public:
    static constexpr int MODULUS = 1e9 + 7;
    // power with modular arithmetic
    int modularPower(int base, int exponent) {
        long long result = 1;
        long long currentBase = base;
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * currentBase) % MODULUS;
            }
            currentBase = (currentBase * currentBase) % MODULUS;
            exponent /= 2;
        }
        return static_cast<int>(result);
    }

    // i computed factorials up to the specified limit
    vector<int> factorialNikalo(int limit) {
        vector<int> factorialSena(limit + 1, 1);
        for (int i = 1; i <= limit; ++i) {
            factorialSena[i] = (1LL * factorialSena[i - 1] * i) % MODULUS;
        }
        return factorialSena;
    }
    vector<vector<int>> combGen(int maxSize) {
        vector<vector<int>> pascutrikon(maxSize + 1, vector<int>(maxSize + 1, 0));
        for (int i = 0; i <= maxSize; ++i) {
            pascutrikon[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                pascutrikon[i][j] = (pascutrikon[i - 1][j - 1] + pascutrikon[i - 1][j]) % MODULUS;
            }
        }
        return pascutrikon;
    }
    vector<vector<int>> partitionways(int n, int parts) {
        vector<vector<int>> partTable(n + 1, vector<int>(parts + 1, 0));
        partTable[0][0]= 1;
        for (int items= 1; items <= n; ++items) {
            for (int group= 1; group <= parts; ++group) {
                partTable[items][group]= (1LL * group * partTable[items - 1][group] + partTable[items - 1][group - 1]) % MODULUS;
            }
        }
        return partTable;
    }

    long long numberOfWays(int n, int x, int y) {
        // precomputed factorials up to x
        auto factorials= factorialNikalo(x);
        // i generated the combination table here
        auto combinations= combGen(x);
        // i created stirling-like partition table here
        auto partitionWays= partitionways(n, x);

        long long totalWays= 0;
        // iterate over different partition sizes
        for (int partitions= 1; partitions <= x; ++partitions) {
            // i am computing y^partitions modulo MODULUS
            int powerTerm= modularPower(y, partitions);
            // i am calculating the combination term in this step
            long long combinationProduct= (1LL * combinations[x][partitions] * partitionWays[n][partitions]) % MODULUS;
            // multiplying with factorial of partition size
            long long finalProduct= (combinationProduct * factorials[partitions]) % MODULUS;
            // adding to the total sum
            totalWays= (totalWays + finalProduct * powerTerm) % MODULUS;
        }
        return totalWays;
    }
};
",1420119393
pewlkit,pewlkit,405,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int it: nums){
            int found=-1;
            for (int i=0; i<=it; i++){
                if ((i | i+1) == it){
                    found=i;
                    break;
                }
            }
            ans.push_back(found);   
        }
        return ans;
    }
};",1420017131
pewlkit,pewlkit,405,3611,cpp,"#include <iostream>
#include <vector>
#include <limits>
#include <unordered_set>
#include <algorithm>

class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        auto isValidCandidate = [](int candidate, int original) {
            return (candidate | (candidate + 1)) == original;
        };

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = numeric_limits<int>::max();
            bool found = false;
            unordered_set<int> candidates; 
            for (int bit = 0; bit <= 30; bit++) {
                if ((num >> bit) & 1) { 
                    int candidate = num & ~(1 << bit);
                    if (candidate >= 0 && candidates.find(candidate) == candidates.end()) {
                        candidates.insert(candidate);
                        if (isValidCandidate(candidate, num)) {
                            if (candidate < minimalAns) {
                                minimalAns = candidate;
                                found = true;
                            }
                        }
                    }
                }
            }

            ans[i] = found ? minimalAns : -1; 
        }

        return ans;
    }
};

",1420083165
Supratit Datta,Supratit_Datta,407,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& k) {
        int n = source.size();
        int m = pattern.size();
        vector<bool> flag(n, false);
        help(flag, k);
        vector<float> dp(m + 1, numeric_limits<float>::infinity());
        dp[0] = 0;
        computeDP(source, pattern, flag, dp, n, m);
        return help2(dp, k.size(), m);
    }

private:
    void help(vector<bool>& flag, const vector<int>& k) {
        for (int idx : k) {
            flag[idx] = true;
        }
    }

    void computeDP(const string& source, const string& pattern,
                   const vector<bool>& flag, vector<float>& dp, int n,
                   int m) {
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] &&
                    dp[j - 1] != numeric_limits<float>::infinity()) {
                    dp[j] = min(dp[j], dp[j - 1] + (flag[i] ? 1 : 0));
                }
            }
        }
    }

    int help2(const vector<float>& dp, int x, int m) {
        return x - (dp[m] == numeric_limits<float>::infinity() ? 0 : dp[m]);
    }
};",1420103622
Supratit Datta,Supratit_Datta,407,3604,cpp,"class Solution {
public:
    const long long int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long int>> C = sol3(x);
        vector<vector<long long int>> S = sol1(n, x);
        vector<long long int> fact = sol2(x);

        long long int ans = 0;

        for (long long int k = 1; k <= x; ++k) {
            long long int power = modPower(y, k, MOD);
            ans = (ans + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return ans;
    }

private:
    vector<vector<long long int>> sol3(long long int x) {
        vector<vector<long long int>> C(x + 1, vector<long long int>(x + 1, 0));
        for (long long int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (long long int j = 1; j <= i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        return C;
    }

    vector<vector<long long int>> sol1(long long int n, long long int x) {
        vector<vector<long long int>> S(n + 1, vector<long long int>(x + 1, 0));
        S[0][0] = 1;
        for (long long int i = 1; i <= n; ++i) {
            for (long long int j = 1; j <= x; ++j) {
                S[i][j] = (j*S[i-1][j] + S[i-1][j-1]) % MOD;
            }
        }
        return S;
    }
    vector<long long int> sol2(long long int x) {
        vector<long long int> fact(x + 1, 1);
        for (long long int i = 1; i <= x; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    long long int modPower(long long int i, long long int exp, long long int mod) {
        long long int ans = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                ans = (ans * i) % mod;
            }
            i = (i*i) % mod;
            exp /= 2;
        }
        return ans;
    }
};",1420119862
Supratit Datta,Supratit_Datta,407,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; ++i) {
            for (int j = 1; j <= 1000; ++j) {
                if ((j | j+1) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420013340
Supratit Datta,Supratit_Datta,407,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] != 2) {
                int val = nums[i];
                int k = 0;
                int bit = 0;
                while (bit < 32) {
                    if (val & (1 << bit)) {
                        k = bit;
                    } 
                    else {
                        break;
                    }
                    bit++;
                }
                
                ans[i] = val - (1 << k);
            }
        }

        return ans;
    }
};",1420083004
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;  
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        int ans=0;
        for(int t=0;t<100;t++)
        {
            if(t%2==0) ans=ans;
            else ans=ans;
        }
        int dup=ans+ans;
        ans=ans/2;
        for (int i = 0; i < n; ++i) {
            
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        ans=0;
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420120146
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3604,cpp,"
int MOD = 1e9 + 7;
class Solution {
public:

    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<long long>> C(x + 1, std::vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        std::vector<std::vector<long long>> S(n + 1, std::vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }
        int ans=0;
        for(int i=0;i<100;i++)
        {
            if(i%2==0)
            {
                if(i) ans=ans;
            }
            else 
            {
                if(1==2) ans=1;
                else ans=2;
            }
        }
        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        ans=result;
        return ans;
    }
};
",1420126590
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        
        for(int i=0;i<n;i++)
        {
            
            bool found=false;
            for(int j=0;j<nums[i];j++)
            {
                if((j|(j+1))==nums[i]) 
                {
                    ans[i]=j;
                    found=true;
                    break;
                }
            }
            if(!found) ans[i]=-1;

        }
        return ans;
    }
};",1420004628
Rohith_kumar_reddy,Rohith_kumar_reddy,408,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
     int n=nums.size();
        
        vector<int> ans(n);
        
        //look for the first encounter of zero and then remove the necessary values
        
        for(int i=0;i<n;i++)
        {
            int curr=nums[i];
            
            if(curr==2) 
            {
                ans[i]=-1;
            }
            else 
            {
                int pos=-1;
                for(int j=0;j<32;j++)
                {
                    if(((curr>>j)&1)==0)
                    {
                        pos=j;
                        break;
                    }
                }
                ans[i]=curr-(1<<(pos-1));
            }

        }
        return ans;
    }
};",1420048081
Sahil Kumar,user2672IT,409,3487,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    int n,m;
    int solve(int idx1,int idx2, vector<int> &vis, string &s, string &pat){
        if(idx1==n){
           if(idx2==m){
               return 0;
           }else{
               return -1e9;
           }  
        }
      
       int ans=-1e9;
       if(dp[idx1][idx2]!=-1)return dp[idx1][idx2];
    
       if(s[idx1]==pat[idx2]){
           ans=max(ans,solve(idx1+1,idx2+1,vis,s,pat));
       }
    
       ans=max(ans,solve(idx1+1,idx2,vis,s,pat)+vis[idx1]);
        
       return dp[idx1][idx2]=ans;
    }
    int maxRemovals(string s, string pat, vector<int>& tar) {
        n=s.size();
        m=pat.size();
        vector<int> vis(n);
        int q=tar.size();
        for(int i=0;i<q;i++){
           vis[tar[i]]=1;
        }
        dp=vector<vector<int>>(n+1,vector<int>(m+1,-1));
        
        int ans=solve(0,0,vis,s,pat);
        return ans;
    }
};",1420037416
Sahil Kumar,user2672IT,409,3604,cpp,"class Solution {
public:
        long long binpow(long long a, long long b, long long m) {
        a %= m;
        long long res = 1;
        while (b > 0) {
            if (b & 1)
                res = res * a % m;
            a = a * a % m;
            b >>= 1;
        }
        return res;
        }

    
    int numberOfWays(int n, int x, int y) {
        long long m=1e9+7;
        const int maxn = n+x;
        long long C[maxn + 1][maxn + 1];
        C[0][0] = 1;
        for (int n = 1; n <= maxn; ++n) {
            C[n][0] = C[n][n] = 1;
            for (int k = 1; k < n; ++k){
                C[n][k] = C[n - 1][k - 1] + C[n - 1][k];
                C[n][k]%=m;
            }
        }
        long long ans=0;
        for(long long i=1;i<=min(n,x);i++){
            
            long long res=C[x][i]%m;
            long long temp=0;
        
            for(long long j=0;j<=i;j++){
                if(j%2==0)
                temp+=(C[i][j]*binpow(i-j,n,m))%m;
                else
                 temp-=(C[i][j]*binpow(i-j,n,m))%m;
                temp%=m;
                temp+=m;
                temp%=m;
            }
            res=res*temp%m;
            res=res*binpow(y,i,m)%m;
            // cout<<res<<endl;
            ans+=res;
            ans%=m;
            
             
        }
        
        return ans;

    }
};",1420113795
Sahil Kumar,user2672IT,409,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2){
                int pow=1;
                int no=0;
                int temp=nums[i];
                while(temp%2){
                    no+=pow;
                    temp/=2;
                    pow*=2;
                }
                
                ans[i]=nums[i]-no+no/2;
            }
            else{
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420008846
Sahil Kumar,user2672IT,409,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]%2){
                int pow=1;
                int no=0;
                int temp=nums[i];
                while(temp%2){
                    no+=pow;
                    temp/=2;
                    pow*=2;
                }
                
                ans[i]=nums[i]-no+no/2;
            }
            else{
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420009570
Bernd,__Bernd__,410,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        # grid(i, j) = # of target_indices we need to find pattern[:i] in source[:j]

        is_target = [False for _ in source]
        for j in targetIndices:
            is_target[j] = True

        grid = {}

        for j in range(len(source)+1):
            grid[(0, j)] = 0

        for i in range(1, len(pattern)+1):
            grid[(i, 0)] = len(source)  # impossible
            for j in range(1, len(source)+1):
                if pattern[i-1] != source[j-1]:
                    grid[(i, j)] = grid[(i, j-1)]
                    continue
                
                if is_target[j-1]:
                    grid[(i, j)] = min(grid[(i, j-1)], 1+grid[(i-1, j-1)])
                else:
                    grid[(i, j)] = min(grid[(i, j-1)], grid[(i-1, j-1)])

        # print(grid)
        return len(targetIndices) - grid[(len(pattern), len(source))]
        

s = Solution()
assert s.maxRemovals(source = ""abbaa"", pattern = ""aba"", targetIndices = [0,1,2]) == 1
assert s.maxRemovals(source = ""bcda"", pattern = ""d"", targetIndices = [0,3]) == 2
assert s.maxRemovals(source = ""dda"", pattern = ""dda"", targetIndices = [0,1,2]) == 0
assert s.maxRemovals(source = ""yeyeykyded"", pattern = ""yeyyd"", targetIndices = [0,2,3,4]) == 2

",1420120300
Bernd,__Bernd__,410,3604,python3,"
from math import comb

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        solution = 0
        cache = {}
        for stages_used in range(1, x+1):
            assginment_counts = get_possible_assignments(n, stages_used, cache) % (10**9 + 7)
            scoring_counts = mod_pow(y, stages_used, 10**9 + 7) % (10**9 + 7)
            stage_selection_counts = comb(x, stages_used) % (10**9 + 7)
            # solution += s * mod_pow(y, stages_used, 10**9 + 7) % (10**9 + 7)
            solution += assginment_counts * scoring_counts * stage_selection_counts % (10**9 + 7)
            # print(stages_used, solution)
        return solution % (10**9 + 7)


def mod_pow(b, exp, mod_nr):
    if exp == 1:
        return b % mod_nr
    
    sqrt = mod_pow(b, exp//2, mod_nr)
    n = sqrt * sqrt % mod_nr
    if exp % 2 == 1:
        n = n * b % mod_nr
    return n
            

assert mod_pow(3, 8, 10**9) == 3**8
assert mod_pow(5, 2, 10) == 5


def get_possible_assignments(n, k, cache={}):
    if (n, k) in cache:
        return cache[(n, k)]

    if n < k:
        return 0

    if k == 1:
        return 1

    first_alone = k * get_possible_assignments(n-1, k-1, cache)
    first_with_others = k * get_possible_assignments(n-1, k, cache)
    s = first_alone + first_with_others
    cache[(n, k)] = s
    # print(n, k, s)
    return s


assert get_possible_assignments(1, 7) == 0
assert get_possible_assignments(7, 1) == 1
assert get_possible_assignments(5, 2) == 2**5 - 2



s = Solution()
assert s.numberOfWays(1, 2, 3) == 6
assert s.numberOfWays(5, 2, 1) == 32
assert s.numberOfWays(3, 3, 4) == 684
assert s.numberOfWays(6, 7, 7) == 365896700

print(s.numberOfWays(958, 744, 829))",1420064087
Bernd,__Bernd__,410,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        f_inv = {}
        for i in range(1000):
            fi = i | (i+1)
            if fi not in f_inv.keys():
                f_inv[fi] = i
        
        return [f_inv.get(n, -1) for n in nums]


s = Solution()
assert s.minBitwiseArray([2,3,5,7]) == [-1,1,4,3]
assert s.minBitwiseArray([11,13,31]) == [9,12,15]
    
        ",1420009022
Bernd,__Bernd__,410,3611,python3,"# class Solution:
#     def minBitwiseArray(self, nums: List[int]) -> List[int]:
#         f_inv = {}
#         for i in range(1000):
#             fi = i | (i+1)
#             if fi not in f_inv.keys():
#                 f_inv[fi] = i
        
#         return [f_inv.get(n, -1) for n in nums]

    

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return [solve(n) for n in nums]
        

def solve(n):
    n_bin_str = ""{0:b}"".format(n)
    n = [s for s in n_bin_str]
    r = list(reversed(n))

    leading_one_count = 0
    for d in r:
        if d == ""1"":
            leading_one_count += 1
        else:
            break
    
    if leading_one_count == 0:  # even number
        return -1

    solution = n[:len(n)-leading_one_count] + [""0""] + [""1""] * (leading_one_count - 1)
    solution = """".join(solution)
    return int(solution, 2)


s = Solution()
assert s.minBitwiseArray([2,3,5,7]) == [-1,1,4,3]
assert s.minBitwiseArray([11,13,31]) == [9,12,15]

",1420085871
Aftab Alam,alam_tech,411,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
    int n = source.length();
    int m = pattern.length();
    int[] dp = new int[m + 1];
    boolean[] isTarget = new boolean[n];
    
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    
    for (int idx : targetIndices) {
        isTarget[idx] = true;
    }
    
    fillDpArray(source, pattern, dp, isTarget);
    
    return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
}

private void fillDpArray(String source, String pattern, int[] dp, boolean[] isTarget) {
    int n = source.length();
    int m = pattern.length();
    
    for (int i = 0; i < n; i++) {
        for (int j = m; j > 0; j--) {
            if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
        }
    }
}
}",1420062045
Aftab Alam,alam_tech,411,3604,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    int MOD = 1e9 + 7;

    vector<vector<int>> initializeCombination(int x) {
        vector<vector<int>> C(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            int j = 1;
            while (j <= i) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
                j++;
            }
        }
        return C;
    }

    vector<vector<int>> initializeStirling(int n, int x) {
        vector<vector<int>> S(n + 1, vector<int>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (1LL * j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }

    vector<int> initializeFactorial(int x) {
        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = 1LL * fact[i - 1] * i % MOD;
        }
        return fact;
    }

    long long computePower(int y, int k) {
        long long power = 1;
        int p = 0;
        while (p < k) {
            power = (power * y) % MOD;
            p++;
        }
        return power;
    }

    long long computeResult(const vector<vector<int>>& C, const vector<vector<int>>& S, const vector<int>& fact, int n, int x, int y) {
        long long result = 0;
        for (int k = 1; k <= x; k++) {
            long long power = computePower(y, k);
            result = (result + 1LL * C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> C = initializeCombination(x);
        vector<vector<int>> S = initializeStirling(n, x);
        vector<int> fact = initializeFactorial(x);
        return computeResult(C, S, fact, n, x, y);
    }
};
",1420101590
Aftab Alam,alam_tech,411,3605,cpp,"class Solution {
public:
    bool checkCondition(int value, int num) {
    return (value | (value + 1)) == num;
}

vector<int> minBitwiseArray(vector<int>& nums) {
    int size = nums.size();
    vector<int> result(size, -1);  // Initialize result with -1

    // Iterate over each element in the nums array
    for (int idx = 0; idx < size; idx++) {
        // Try all possible values for result[idx]
        for (int candidate = 0; candidate <= nums[idx]; candidate++) {
            if (checkCondition(candidate, nums[idx])) {
                result[idx] = candidate;
                break;  // Stop when the smallest valid candidate is found
            }
        }
    }

    return result;
}
};",1420010821
Aftab Alam,alam_tech,411,3611,java,"class Solution {
      public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (isBitSet(num, bit)) {
                    int candidate = unsetBit(num, bit);
                    
                    if (candidate < 0) continue;
                    
                    if (isValidCandidate(num, candidate)) {
                        minimalAns = Math.min(minimalAns, candidate);
                        found = true;
                    }
                }
            }
            
            ans[i] = found ? minimalAns : -1;
        }
        
        return ans;
    }

    private boolean isBitSet(int num, int bit) {
        return ((num >> bit) & 1) == 1;
    }

    private int unsetBit(int num, int bit) {
        return num & ~(1 << bit);
    }

    private boolean isValidCandidate(int num, int candidate) {
        return (candidate | (candidate + 1)) == num;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        List<Integer> nums = Arrays.asList(15, 7, 1);
        System.out.println(Arrays.toString(sol.minBitwiseArray(nums)));
    }
}",1420053971
Suyash Khare,sk9698,412,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string s, std::string p, std::vector<int>& a) {
        std::vector<int> dp(p.size() + 1, INT_MAX);
        dp[0] = 0;  // Initialize dp[0] to 0
        std::vector<int> vis(s.size(), 0); // Initialize visibility vector

        // Mark the target indices
        for (int e : a) {
            vis[e] = 1;
        }

        for (int i = 0; i < s.size(); i++) {
            for (int j = p.size(); j > 0; j--) {
                if (dp[j - 1] == INT_MAX) {
                    continue; // No valid previous state
                }
                if (s[i] == p[j - 1]) {
                    int val = vis[i]; // Use vis[i] directly since it is either 0 or 1
                    dp[j] = std::min(dp[j], dp[j - 1] + val);
                }
            }
        }

        // Return the number of target indices minus the number of characters in pattern that can be matched
        return dp[p.size()] == INT_MAX ? 0 : a.size() - dp[p.size()];
    }
};
",1420076655
Suyash Khare,sk9698,412,3604,cpp,"#include <iostream>

using namespace std;

class Solution {
public:
    long long mod = 1e9 + 7;

    void preCompute(int x, long long* f) {
        for (int i = 0; i <= x; i++) {
            if(i == 0) f[i] = 1;
            else f[i] = (f[i - 1] * i) % mod;
        }
    }

    long long numberOfWays(int n, int x, int y) {
        long long ans = 0;

        long long* f = new long long[x + 1];
        preCompute(x, f);

        long long** dp = new long long*[x + 1];
        for (int i = 0; i <= x; i++) {
            dp[i] = new long long[x + 1]{0};
        }

        long long** dp2 = new long long*[n + 1];
        for (int i = 0; i <= n; i++) {
            dp2[i] = new long long[x + 1]{0};
        }

        for (int i = 0; i <= x; i++) {
            dp[i][0] = 1;
        }

        dp2[0][0] = 1;

        for (int i = 1; i <= x; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % mod;
            }
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                dp2[i][j] = (j * dp2[i - 1][j] + dp2[i - 1][j - 1]) % mod;
            }
        }

        

        for (int i = 1; i <= x; i++) {
            long long here = 1;
            for (int j = 0; j < i; j++) {
                here = (here * y) % mod;
            }

            long long product = (dp[x][i] * dp2[n][i]) % mod;
            long long multiplyWithFactorial = (product * f[i]) % mod;
            long long fin = (multiplyWithFactorial * here) % mod;

            ans = (ans + fin) % mod;
        }

        return ans;
    }
};
",1420120892
Suyash Khare,sk9698,412,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        std::vector<int> ans;

        for (int prime : nums) {
            int found = -1;  // Default to -1 if no valid ans[i] is found
            for (int x = 0; x < prime; ++x) {
                if ((x | (x + 1)) == prime) {
                    found = x;  // Update found if valid
                    break;      // Break out of the loop as we found the minimum
                }
            }
            ans.push_back(found);  // Add the found value (or -1) to ans
        }

        return ans;  // Return the constructed ans vector
    }
};",1419993523
Suyash Khare,sk9698,412,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& a) {
        vector<int> ans;
        for(int i=0;i<a.size();i++){
            int mini=INT_MAX;
            for(int j=0;j<=30;j++){
                int bit = (a[i] >> j) & 1;
                if(bit==1){
                    int x=a[i] & ~(1 << j);
                    if(x>=0){
                        if((x | (x+1)) == a[i]){
                            
                            mini=min(mini,x);
                            
                        }
                        
                    }
                    }
                }
                if(mini==INT_MAX) ans.push_back(-1);
                else ans.push_back(mini);
            }

            return ans;
        }
    
};

",1420047651
metaphysicalist,metaphysicalist,413,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n, m = len(source), len(pattern)
        removable = set(targetIndices)
        
        @cache
        def dp(i, j):
            if i >= n:
                if j == m:
                    return 0
                return -inf
            r = -inf
            if i in removable:
                r = max(r, dp(i+1, j) + 1)
            if j < m and source[i] == pattern[j]:
                r = max(r, dp(i+1, j+1))
            else:
                r = max(r, dp(i+1, j))
            return r
        ans = dp(0, 0)
        dp.cache_clear()
        return dp(0, 0)
",1420076388
metaphysicalist,metaphysicalist,413,3604,python3,"@cache
def dp(i, j, k):
    if i == 0:
        if j > 1 or k == 0:
            return 0
        return 1
    
    ans = 0
    if k > 0:
        ans = dp(i, j - 1, 0)
    ans += dp(i-1, j, k+1)
    return ans % 1000000007

@cache
def foo(n, m):
    if n < 0 or m < 0:
        return 0
    if m > n:
        return 0
    if n == 0:
        return 1
    return foo(n-1, m-1) + m * foo(n-1, m)

@cache
def frac(n):
    if n == 0:
        return 1
    return (n * frac(n-1)) % 1000000007

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:        
        MOD = 1000000007
        ans = 0
        for band in range(1, x+1):
            if band > n:
                break
            # print(n, band, foo(n, band))
            a = comb(x, band) * (frac(band) * foo(n, band) * pow(y, band, MOD)) % MOD
            # print(a)
            ans = (ans + a) % MOD
        return ans
        ",1420121852
metaphysicalist,metaphysicalist,413,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for v in nums:
            ans.append(-1)
            for a in range(0, v+1):
                if a | (a+1) == v:
                    ans[-1] = a 
                    break
        return ans",1420000090
metaphysicalist,metaphysicalist,413,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def solve(v):
            if v == 2:
                return -1
            s = '0' + bin(v)[2:]
            n = len(s)
            for i in range(n-2, -1, -1):
                if s[i] == '0':
                    lower = s[:i+1] + '0' + ('1' * (n-i-2))

                    # print(v, lower)
                    return int(lower, 2)
            
            return -1

        ans = []
        for v in nums:
            ans.append(solve(v))
        return ans
        ",1420050381
Shivam Aryan,ultraaryan10,417,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& idx) {
        int n = s.size(), m = p.size();
        constexpr int inf = 1e9;
        vector<int> dp(m + 1, inf); dp[0] = 0;
        set<int> t(idx.begin(), idx.end());
        for (int i = 0; i < n; i++) {
            for (int j = m - 1; j >= 0; j--) {
                if (s[i] == p[j] and dp[j] != inf)
                    dp[j+1] = min(dp[j+1], dp[j] + (int)t.count(i));
            }
        }
        if (dp[m] == inf) dp[m] = 0; 
        return t.size() - dp[m];
    }
};",1420095201
Shivam Aryan,ultraaryan10,417,3604,cpp,"class Solution {
    static constexpr int MOD = 1e9 + 7;

    static long long power(long long x, long long y, long long m = MOD) {
        long long res = 1;
        while (y > 0) {
            if (y & 1)
                res = (res * x) % m;
            y = y >> 1;
            x = (x * x) % m;
        }
        return res % m;
    }

    class Combinatorics {
        long long maxn;
    public:
        vector<long long> factorial;
        vector<long long> inverse_factorial;

        Combinatorics(long long maxn) : maxn(maxn), factorial(maxn), inverse_factorial(maxn) {
            factorial[0] = 1;
            inverse_factorial[0] = 1;
            for (long long i = 1; i < maxn; ++i) {
                factorial[i] = (factorial[i - 1] * i) % MOD;
                inverse_factorial[i] = power(factorial[i], MOD - 2) % MOD;
            }
        }
        Combinatorics() : Combinatorics(1e4 + 1) {};

        long long nCr(long long n, long long r) {
            if (r > n || r < 0) return 0;
            long long numerator = factorial[n] % MOD;
            long long denominator = (inverse_factorial[r] * inverse_factorial[n - r]) % MOD;
            return (numerator * denominator) % MOD;
        }
    };
public:
    Combinatorics math;
    
    Solution() : math(1e4) {}

    int numberOfWays(int n, int x, int y) {
        long long ans = 0;
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] % MOD + S[i - 1][j - 1]) % MOD;
            }
        }
        for (int k = 1; k <= x; k++) {
            ans = (ans + math.nCr(x, k) * S[n][k] % MOD * math.factorial[k] % MOD * power(y, k) % MOD) % MOD;
        }
        return ans;
    }
};
",1420123254
Shivam Aryan,ultraaryan10,417,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            for (int j = 0; j <= i; j++) {
                if ((j | (j + 1)) == i) {
                    ans.push_back(j);
                    goto next;
                }
            }
            ans.push_back(-1);
            next:;
        }
        return ans;
    }
};",1419999115
Shivam Aryan,ultraaryan10,417,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int i : nums) {
            if (i == 2) ans.push_back(-1);
            else {
                bitset<32> b(i);
                int start = 0;
                while (b[start] == 1) start++;
                start--;
                b[start] = 0;
                ans.push_back(b.to_ullong());
            }
        }
        return ans;
    }
};
",1420019324
Nilesh Kumar Nayak,nileshnayak656854,418,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
       int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        boolean[] isTarget = new boolean[n];

        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]); 
    }
}",1420056315
Nilesh Kumar Nayak,nileshnayak656854,418,3604,java,"class Solution {
     private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[][] comb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        int[][] stirling = new int[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (int) ((1L * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD);
            }
        }

        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int i = 0; i < k; i++) {
                yPow = (yPow * y) % MOD;
            }
            totalWays = (totalWays + (1L * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD)) % MOD;
        }

        return (int) totalWays;
    }
}",1420098188
Nilesh Kumar Nayak,nileshnayak656854,418,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            ans[i] = -1;
            for (int x = 0; x <= nums.get(i); x++) {
                if ((x | (x + 1)) == nums.get(i)) {
                    ans[i] = x;
                    break;
                }
            }
        }

        return ans; 
    }
}",1420018047
Nilesh Kumar Nayak,nileshnayak656854,418,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {

                    int candidate = num & ~(1 << bit);

                    if (candidate < 0)
                        continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
}",1420042260
ANUJ SINGH RANA,Aunj07,419,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420061805
ANUJ SINGH RANA,Aunj07,419,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420111381
ANUJ SINGH RANA,Aunj07,419,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420007572
ANUJ SINGH RANA,Aunj07,419,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420045297
VASU_FXLEI_14,VASU_FXLEI_14,420,3487,cpp,"class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& indi) {
        int n = source.size();
        int m = pattern.size();
        std::vector<int> open(m + 1, INT_MAX);
        open[0] = 0;
        std::vector<bool> tgt(n, false);
        
        for (int idx : indi) {
            tgt[idx] = true;
        }
        
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && open[j - 1] != INT_MAX) {
                    open[j] = std::min(open[j], open[j - 1] + (tgt[i] ? 1 : 0));
                }
            }
        }
        
        return indi.size() - (open[m] == INT_MAX ? 0 : open[m]);
    }
};
",1420124237
VASU_FXLEI_14,VASU_FXLEI_14,420,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> combination(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stir(n + 1, std::vector<int>(x + 1, 0));
        stir[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stir[i][j] = (1LL * j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> facto(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            facto[i] = (1LL * facto[i - 1] * i) % MOD;
        }
        long long tota = 0;
        for (int k = 1; k <= x; ++k) {
            long long ypower = 1;
            for (int i = 0; i < k; ++i) {
                ypower = (ypower * y) % MOD;
            }
            tota = (tota + (1LL * combination[x][k] * stir[n][k] % MOD * facto[k] % MOD * ypower % MOD)) % MOD;
        }
        return tota;
    }
};",1420105582
VASU_FXLEI_14,VASU_FXLEI_14,420,3605,cpp,"class Solution {
public:
    int find(int prime) {
        for (int x = 1; x <= prime; ++x) {
            if ((x | (x + 1)) == prime) {
                return x;
            }
        }
        return -1;  
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> sol(n, -1);  

        for (int i = 0; i < n; ++i) {
            sol[i] = find(nums[i]);  
        }

        return sol;
    }
};",1420025329
VASU_FXLEI_14,VASU_FXLEI_14,420,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] answer = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int mini = Integer.MAX_VALUE;
            boolean pop = false;
            
           
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                 
                    int cop = num & ~(1 << bit);
                    
                 
                    if (cop < 0) continue;
                    
                 
                    if ((cop | (cop + 1)) == num) {
                        if (cop < mini) {
                            mini = cop;
                            pop = true;
                        }
                    }
                }
            }
            
            if (pop) {
                answer[i] = mini;
            } else {
                answer[i] = -1;
            }
        }
        
        return answer;
    }
}
",1420045588
Vamsi Gudimetla,G_vamsi,421,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();  
        int m = pattern.size();  
        vector<int> dp(m + 1, INT_MAX);  
        dp[0] = 0;  
        
        vector<bool> Target(n, false);  
        for (int J: targetIndices) {  
            Target[J] = true;  
        }  
        for (int iV = 0; iV < n; ++iV) {  
            for (int jX = m; jX >= 1; --jX) {  
                if (source[iV] == pattern[jX - 1] && dp[jX - 1] != INT_MAX) {  
                    dp[jX] = min(dp[jX], dp[jX - 1] + (Target[iV] ? 1 : 0));  
                }  
            }  
        }  
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
 
    }
};",1420124270
Vamsi Gudimetla,G_vamsi,421,3604,cpp,"class Solution {
public:
const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
         vector<vector<int>> com(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            com[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                com[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % MOD;
            }
        } 
        vector<vector<int>> sti(n + 1, vector<int>(x + 1, 0));
        sti[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                sti[i][j] = (1LL * j * sti[i - 1][j] + sti[i - 1][j - 1]) % MOD;
            }
        }
        vector<int> factor(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factor[i] = (1LL * factor[i - 1] * i) % MOD;
        }
        long long total = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total = (total + (1LL * com[x][k] * sti[n][k] % MOD * factor[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total; 
    }
};",1420119032
Vamsi Gudimetla,G_vamsi,421,3605,cpp,"class Solution {
public:
  int check(int x)
  {
    for(int i=1;i<x;i++)
    {
      if((i|i+1)==x)
       return i;

    }
    return -1;
  }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
       for(int i=0;i<nums.size();i++)
       {
        int req=check(nums[i]);
        if(req==-1)
        ans[i]=-1;
        else
        ans[i]=req;
       } 
       return ans;
    }
};",1420015212
Vamsi Gudimetla,G_vamsi,421,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
          int n = nums.size();
        vector<int>ans(n);
         for (int i = 0; i < n; i++) {
            int num = nums[i];
            int mini = INT_MAX;
            bool found = false;
            for (int bit = 0; bit <= 30; bit++) {
                if ((num >> bit) & 1) {
                    // Unset the current bit
                    int c = num & ~(1 << bit);

                    // Ensure candidate is non-negative
                    if (c< 0) continue;
                    if ((c | (c + 1)) == num) {
                        if (c < mini) {
                            mini = c;
                            found = true;
                        }
                    }
                }
            }
                 if (found) {
                ans[i] = mini;
            } else {
                ans[i] = -1;
            }
        }
        returnans;

    }
};",1420062961
Aman Dubey,its_me_ami_12,422,3487,java,"class Solution {
    // Aman
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
       int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        
       
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; 

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

      
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420076679
Aman Dubey,its_me_ami_12,422,3604,java,"
class Solution {
    //Aman
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] p = {n, x, y};
        while (p != null) {
            break;
        }

        
        long[][] c = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            c[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

       
        long[][] s = new long[n + 1][x + 1];
        s[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                s[i][j] = (j * s[i - 1][j] % MOD + s[i - 1][j - 1]) % MOD;
            }
        }

        
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = modPow(y, k, MOD);
            totalWays = (totalWays + c[x][k] * s[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }
    private long modPow(int base, int exp, int mod) {
        long result = 1;
        long b = base % mod;
        while (exp > 0) {
            if ((exp & 1) == 1) { 
                result = (result * b) % mod;
            }
            b = (b * b) % mod; 
            exp >>= 1;
        }
        return result;
    }
}
",1420098687
Aman Dubey,its_me_ami_12,422,3605,java,"class Solution {
    // Aman
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
    
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            
            for (int j = 0; j <= num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
            
        
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1419994629
Aman Dubey,its_me_ami_12,422,3611,java,"
// Aman
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                res[i] = minimalAns;
            } else {
                res[i] = -1;
            }
        }
        
        return res;
    }
}",1420084842
Kotte Pravallika,pravallika_kotte,423,3487,cpp,"class Solution {
public:
    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size(), m = p.size();
        vector<int> dp(m+1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isT(n, false);
        for(int idx : t) isT[idx] = true;

        for(int i = 0; i <n; ++i){
            for(int j = m; j > 0; --j){
                if(s[i] == p[j -1] && dp[j-1] != numeric_limits<int>::max()){
                    dp[j] = min(dp[j], dp[j-1] + (isT[i] ? 1 : 0));
                }
            }
        }

        return t.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420064659
Kotte Pravallika,pravallika_kotte,423,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {

        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        std::vector<std::vector<int>> stirling(n + 1,
                                               std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] =
                    (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) %
                    MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways =
                (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD *
                               factorial[k] % MOD * y_pow % MOD)) %
                MOD;
        }
        return total_ways;
    }
};
",1420118412
Kotte Pravallika,pravallika_kotte,423,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector <int> ans(n, -1);
        for(int i = 0; i <n; i++){
            int h = nums[i];
            for(int x = 0; x <= h; x++){
                if((x|(x+1)) == h){
                    ans[i] = x;
                    break;
                }
            }
        }
        
        for(int i = 0; i < n; ++i){
            if(ans[i] == -1){
                ans[i] = -1;
            }
        }
        return ans;
    }
};",1420025720
Kotte Pravallika,pravallika_kotte,423,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for(int i = 0; i < n; i++){
            int h = nums[i];
            int minAns = numeric_limits<int>::max();
            bool found = false;
            
            for(int t = 0; t <= 30; t++){
                if((h >> t) & 1){
                    int can = h & ~(1 << t);
                    if ((can | (can + 1)) == h) {
                        if (can < minAns) {
                            minAns = can;
                            found = true;
                        }
                    }
                }
            }

            if (found){
                ans[i] = minAns;
            } else {
                ans[i] = -1;
            }
        }
        return ans;
    }
};",1420049780
Vaid Aaryan,cool_coder_007,425,3487,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e7;
// const int MAXN=1e4,N=2e7+1;






class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n=source.length();
       
        int m=pattern.length();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-inf));
        vector<char> a(n+1),b(m+1);
        f(i,0,n) a[i+1]=source[i];
        f(i,0,m) b[i+1]=pattern[i];
        unordered_map<int,int> hsh;
        for(int i=0;i<targetIndices.size();i++) hsh[targetIndices[i]+1]=1;
        dp[0][0]=0;
        for(int i=1;i<=n;i++){
            dp[i][0]=dp[i-1][0];
            if(hsh.find(i)!=hsh.end()) dp[i][0]++;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(a[i]==b[j]){
                    // if(i==4)
                    dp[i][j]=max(dp[i-1][j-1],dp[i][j]);
                    if(hsh.find(i)!=hsh.end())
                    dp[i][j]=max(dp[i][j],dp[i-1][j]+1);
                    else dp[i][j]=max(dp[i][j],dp[i-1][j]);
                }
                else{
                    // if(i==4 && j==2) cout<<69<<endl;
                    int found=(hsh.find(i)!=hsh.end());
                //    if(i==4 && j==2) cout<<found<<endl;
                    dp[i][j]=max(dp[i][j],dp[i-1][j]+found);
                }
            }
        }
        int ans=dp[n][m];
        // for(int i=1;i<=n;i++){
        //     for(int j=1;j<=m;j++){
        //         if(dp[i][j]<0) dp[i][j]=-1;
        //         cout<<dp[i][j]<<"" "";
        //     }
        //     cout<<endl;
        // }
        return ans;

    }
};",1420078482
Vaid Aaryan,cool_coder_007,425,3604,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e7;
// const int MAXN=1e4,N=2e7+1;

ll fact[1001];


class Solution {
public:
  

    ll calc(ll n,ll r){
        if(r<0 || n<0) return 0;
        if(r>n) return 0;
        if(r==0 || n==0) return 1;
        ll num=fact[n];
        ll den=fact[r];
        den=(fact[r]*fact[n-r])%mod;
        num=(num*modinv(den,mod))%mod;
        return num;
    }
    int numberOfWays(int n, int x, int y) {
        ll ans=0;
        vector<vector<ll>> dp(n+1,vector<ll>(x+1,-1));//n distinct performers to x stages
        fact[0]=1;
        for(ll i=1;i<=(max(x,n));i++){
            fact[i]=(fact[i-1]*i)%mod;
        }
        for(ll empty=0;empty<x;empty++){
            ll cur=calc(x,empty);
            ll sum=0;
            ll r=n;
            ll fill=x-empty;
            cout<<fill<<endl;
            if(fill>n) continue;
            // cout<<fill<<endl;
            // cout<<cur<<endl;
            // cout<<empty<<"" ""<<cur<<endl;
            for(ll i=0;i<=fill;i++){
                ll val1=calc(fill,i);
                val1=(val1*expo(fill-i,r,mod))%mod;
                // cout<<val1<<endl;
                if(i%2) sum=(sum-val1+mod)%mod;
                else sum=(sum+val1)%mod;
            }
            cur=(cur*sum)%mod;
            ll num1=expo(y,fill,mod);
            cur=(cur*num1)%mod;

            ans=(ans+cur)%mod;
        }
        ans=ans%mod;

        return ans;
        
    }
};",1420125031
Vaid Aaryan,cool_coder_007,425,3605,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e18;
// const int MAXN=1e4,N=2e7+1;










class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        f(i,0,n){
            if(nums[i]==2 ) continue;
            // int val=-1;
            int sub=0;
            for(int bt=0;bt<31;bt++){
                int cur=(nums[i]>>bt)&1;
                // cout<<nums[i]<<"" ""<<cur<<endl;
                if(cur==0){
                    break;
                }
                else sub=1<<bt;
            }
            // cout<<sub<<endl;
            ans[i]=nums[i]-sub;
        }

        return ans;
        
    }
};

// int main(){
//     int n;
//     cin>>n;
//     vector<int> v(n);
//     f(i,0,n) cin>>v[i];
//     Solution s;
//     vector<int> ans=s.minBitwiseArray(v);
//     show(ans);cout<<endl;

// }",1420027152
Vaid Aaryan,cool_coder_007,425,3611,cpp,"#include <bits/stdc++.h>
using namespace std;
// using namespace __gnu_pbds;
    #define vb                  vector<bool>
    #define ff first
    #define ss second
    #define pb push_back
    #define gout(tno) cout << ""Case #"" << tno++ <<"": ""
    #define ld long double
    #define ll long long
    #define f(i, a, b)        for (int(i) = int(a); (i) < int(b); ++(i))
    #define vi                  vector<int>
    #define vb                  vector<bool>
    #define pb push_back
    #define ub upper_bound
    #define lb lower_bound
    #define rall(x) x.rbegin(), x.rend()
    #define uniq(v) v.resize(unique(v.begin(), v.end()) - v.begin())
    #define scanv(v) for (int i = 0; i < v.size(); ++i) cin >> v[i];
    // #define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
    //order_of_key (k)  //find_by_order(k) 
    #define prDouble(x) cout<<fixed<<setprecision(9)<<x
    #define pii                 pair<int, int>
    #define vpii                vector<pair<int, int> >
    #define w(x)                int x; cin >> x; while(x--)
    #define FIO                 ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    #define setbits(x) __builtin_popcountll(x)    //count number of setbits in a number
    #define max3(a, b, c)       max((a), max((b), (c)))
    #define min3(a, b, c)       min((a), min((b), (c)))
    #define mx_all(c)           *max_element((c).begin(), (c).end())
    #define mn_all(c)           *min_element((c).begin(), (c).end())    
    #define cnt_all(c,val)          count(c.begin(),c.end(),val)
    #define all(x) x.begin(),x.end()
    #define siz(x) ((int)(x).size())
    #define yes cout<<""Yes""<<endl
    #define no cout<<""No""<<endl
    // #define alice cout<<""Alice""<<endl
    #define bob cout<<""Bob""<<endl
    #define takahashi cout<<""Takahashi""<<endl
    #define aoki cout<<""Aoki""<<endl
    #define pb push_back
    #define vi vector<int>
    #define vb vector<bool>
    #define vs vector<string>
    #define vvi vector<vector<int>>
    #define djikstra priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>
    #define lld long double
    #define show(a)         for (auto& (i) : (a)) cout << i<<"" "" ;
    #define itos to_string
    #define STOI stoi
 
    const lld pi = 3.1415926535897932;
    ll mul(ll a,ll b,ll m){ return (a*b)%m;}
    ll accurateFloor(ll a, ll b) {ll val = a / b; while (val * b > a)val--;return val; }
    void yesno(bool xxx) {if(xxx) cout<<""YES\n""; else cout<<""NO\n"";}
    ll nCr(ll n, ll r){if (n < r)return 0; if (r > n - r) r = n - r; ll ans = 1;ll i; for (i = 1; i <= r; i++) { ans *= n - r + i; ans /= i; } return ans;}
    int gcd(int x,int y){if(y==0)return x;else return gcd(y,x%y);}
 
    long long gcd(long long int a, long long int b) {if (b == 0) return a; return gcd(b, a % b);}
      
    // Function to return LCM of two numbers 
    long long lcm(ll a, ll b){ return (a / gcd(a, b)) * b;}
    ll mod_add(ll a, ll b, ll m=1e9+7) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = mul(res , a,m) % m; a = mul(a , a,m) % m; b = b >> 1;} return res%m ;}
    ll modinv(ll a , ll m ) {return expo(a , m-2 , m)%m;} 
// for questions involving segments, think of sweep line algorithm and binary search,if segment tree with lazy prop^ does not seem to work .
// think greedy wisely and not rush it over the algorithm
// Use DSU for dynamically varying graphs,expanding compressing tree and cycles
// for(int s=m;s;s=(s-1)&m) iterating through all subsets of mask m
// Think about topological sortings whenever you see some sort of order or maybe independency
// Instead of doing two swaps in different arrays-->try distributing the swaps for each and rather than brute forcing do (All possible Combinations for that index*each index)

const ll mod= 1e9+7
 ,//1e9+7 //998244353
inf=1e18;
// const int MAXN=1e4,N=2e7+1;










class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        f(i,0,n){
            if(nums[i]==2 ) continue;
            // int val=-1;
            int sub=0;
            for(int bt=0;bt<31;bt++){
                int cur=(nums[i]>>bt)&1;
                // cout<<nums[i]<<"" ""<<cur<<endl;
                if(cur==0){
                    break;
                }
                else sub=1<<bt;
            }
            // cout<<sub<<endl;
            ans[i]=nums[i]-sub;
        }

        return ans;
        
    }
};

// int main(){
//     int n;
//     cin>>n;
//     vector<int> v(n);
//     f(i,0,n) cin>>v[i];
//     Solution s;
//     vector<int> ans=s.minBitwiseArray(v);
//     show(ans);cout<<endl;

// }",1420026851
Rohan Bansal,rohannbansal,426,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        length_source = len(source)
        length_pattern = len(pattern)
        removal_count = [float('inf')] * (length_pattern + 1)
        removal_count[0] = 0
        target_positions = [False] * length_source
        
        for position in targetIndices:
            target_positions[position] = True
        
        for char_index in range(length_source):
            for pattern_index in range(length_pattern, 0, -1):
                if source[char_index] == pattern[pattern_index - 1] and removal_count[pattern_index - 1] != float('inf'):
                    removal_count[pattern_index] = min(removal_count[pattern_index], removal_count[pattern_index - 1] + (1 if target_positions[char_index] else 0))
        
        return len(targetIndices) - (0 if removal_count[length_pattern] == float('inf') else removal_count[length_pattern])
",1420072849
Rohan Bansal,rohannbansal,426,3604,cpp,"class Solution {
public:
    static const int MOD_VALUE = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> combinations(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD_VALUE;
            }
        } 
        std::vector<std::vector<int>> stirlingNumbers(n + 1, std::vector<int>(x + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD_VALUE;
            }
        }
        std::vector<int> factorials(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD_VALUE;
        }
        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long powerY = 1;
            for (int i = 0; i < k; ++i) {
                powerY = (powerY * y) % MOD_VALUE;
            }
            totalWays = (totalWays + (1LL * combinations[x][k] * stirlingNumbers[n][k] % MOD_VALUE * factorials[k] % MOD_VALUE * powerY % MOD_VALUE)) % MOD_VALUE;
        }
        return totalWays;
        
    }
};",1420106607
Rohan Bansal,rohannbansal,426,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        
        for num in nums:
            found = False
            for x in range(num):
                if (x | (x + 1)) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans",1420021323
Rohan Bansal,rohannbansal,426,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int size = nums.size();
        int[] result = new int[size];
        
        for (int index = 0; index < size; index++) {
            int currentNum = nums.get(index);
            int minimumValue = Integer.MAX_VALUE;
            boolean isFound = false;
            
            for (int position = 0; position <= 30; position++) {
                if (((currentNum >> position) & 1) == 1) {
                    int potentialCandidate = currentNum & ~(1 << position);
                    
                    if (potentialCandidate < 0) continue;
                    
                    if ((potentialCandidate | (potentialCandidate + 1)) == currentNum) {
                        if (potentialCandidate < minimumValue) {
                            minimumValue = potentialCandidate;
                            isFound = true;
                        }
                    }
                }
            }
            
            if (isFound) {
                result[index] = minimumValue;
            } else {
                result[index] = -1;
            }
        }
        
        return result;

    }
}",1420066403
ISHANIJ,ISHANIJ,427,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420068986
ISHANIJ,ISHANIJ,427,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420100157
ISHANIJ,ISHANIJ,427,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& arr) {
       int len = arr.size();
        vector<int> result(len, -1);

        for (int i = 0; i < len; i++) {
            for (int x = 0; x <= arr[i]; x++) {
                if ((x | (x + 1)) == arr[i]) {
                    result[i] = x;
                    break;
                }
            }
        }

        return result; 
    }
};",1420009795
ISHANIJ,ISHANIJ,427,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
        
    }
}",1420060791
Sunny Kumar,sk_07singh,428,3487,python3,"import math
import sys
from typing import List
# Sunny kumar

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: list[int]) -> int:
        
        n = len(source)
        m = len(pattern)
        
        dp = [float('inf')] * (m + 1)
        dp[0] = 0  
      
        Target = [False] * n         # is Target
        
        for index in targetIndices:
            Target[index] = True
        
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if Target[i] else 0))
        
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

    

",1420125799
Sunny Kumar,sk_07singh,428,3604,python3,"import re
import math
import sys
# Sunny kumar

MOD = int(1e9 + 7)

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        combination = [[0] * (x + 1) for sunny in range(x + 1)]
        for i in range(x + 1):
            combination[i][0] = 1
            for j in range(1, i + 1):
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD

                
        stirling_Numbers = [[0] * (x + 1) for _ in range(n + 1)]
        stirling_Numbers[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling_Numbers[i][j] = (j * stirling_Numbers[i - 1][j] + stirling_Numbers[i - 1][j - 1]) % MOD

                
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = (factorial[i - 1] * i) % MOD

            
        total = 0
        for i in range(1, x + 1):
            powerMultiplier = pow(y, i, MOD)
            total = (total + combination[x][i] * stirling_Numbers[n][i] % MOD * factorial[i] % MOD * powerMultiplier % MOD) % MOD
        
        return total
    ",1420119632
Sunny Kumar,sk_07singh,428,3605,python3,"import math
# Sunny Kumar
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ansi = []
    
        for num in nums:
            found = False
        
            for ar in range(num):
                if ar | (ar + 1) == num:
                    ansi.append(ar)
                    found = True
                    break
        
            if not found:
                ansi.append(-1)
    
        return ansi
",1420017853
Sunny Kumar,sk_07singh,428,3611,python3,"import math
# Sunny Kumar
from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimal_ans = float('inf')  # Initialize with positive infinity
            found = False
            
            # Iterate through each bit position (0 to 30)
            for bit in range(31):
                if (num >> bit) & 1:  # Check if the bit is set
                    # Unset the current bit
                    candidate = num & ~(1 << bit)
                    
                    # Ensure candidate is non-negative
                    if candidate < 0:
                        continue
                    
                    # Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimal_ans:
                            minimal_ans = candidate
                            found = True
            
            if found:
                ans[i] = minimal_ans
            else:
                ans[i] = -1
        
        return ans",1420063360
Ayush Nautiyal,ayushnautiyal1110,429,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        
       int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, 1e9);
        dp[0] = 0;
        
        vector<int> f(n+1, 0);
        for (auto x : targetIndices) {
            f[x] = 1;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != 1e9) {
                    dp[j] = min(dp[j], dp[j - 1] + (f[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] ==1e9 ? 0 : dp[m]);
    }
};",1420123877
Ayush Nautiyal,ayushnautiyal1110,429,3604,cpp,"#include <vector>

class Solution {
private:
    const int MOD = 1000000007;

public:
    int numberOfWays(int n, int x, int y) {
        // No-op loop for consistency
        int params[] = {n, x, y};
        while (sizeof(params) > 0) {
            break;
        }

        // Combination array
        std::vector<std::vector<long long>> comb(x + 1, std::vector<long long>(x + 1));
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Stirling numbers array
        std::vector<std::vector<long long>> stirling(n + 1, std::vector<long long>(x + 1));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array
        std::vector<long long> factorial(x + 1);
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return static_cast<int>(totalWays);
    }
};
",1420125961
Ayush Nautiyal,ayushnautiyal1110,429,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans(nums.size(),1e9);
        int n=nums.size();
        for(int i=0;i<n;i++){
            vector<int>bit(32);
            for(int j=31;j>=0;j--){
                int no=(1<<j);
                if(no & nums[i]){
                    bit[j]++;
                }
            }
            int num=0;
            for(int j=31;j>=0;j--){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=0;k<j;k++){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            num=0;
            for(int j=0;j<32;j++){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=j;k>=0;k--){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            
        }
        for(int i=0;i<n;i++){
            if(ans[i]==1e9)
            {
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420030940
Ayush Nautiyal,ayushnautiyal1110,429,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans(nums.size(),1e9);
        int n=nums.size();
        for(int i=0;i<n;i++){
            vector<int>bit(32);
            for(int j=31;j>=0;j--){
                int no=(1<<j);
                if(no & nums[i]){
                    bit[j]++;
                }
            }
            int num=0;
            for(int j=31;j>=0;j--){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=0;k<j;k++){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            num=0;
            for(int j=0;j<32;j++){
                if(bit[j]){
                    num+=(1<<j);
                    int tmp=num;
                    if((num | (num+1))==nums[i]){
                        ans[i]=min(ans[i],num);
                        // break;
                    }
                    for(int k=j;k>=0;k--){
                        
                        if(bit[k]){
                            tmp+=(1<<k);
                            if((tmp | (tmp+1))==nums[i]){
                                ans[i]=min(ans[i],tmp);
                                break;
                            }
                        }
                    }
                }
            }
            
        }
        for(int i=0;i<n;i++){
            if(ans[i]==1e9)
            {
                ans[i]=-1;
            }
        }
        return ans;
    }
};",1420031359
DEVANG SHARMA,devangdurvasa1004,430,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Step 1: Initialize the DP array to track removals
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];
        
        // Initialize dp array
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;  // 0 operations needed for an empty pattern
        
        // Step 2: Mark target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;  // Mark index as removable
        }
        
        // Step 3: DP table update to count valid subsequences
        for (int i = 0; i < n; i++) {
            // Iterate backwards through pattern to avoid overwriting values
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If we can form the pattern, dp[m] should have the minimum removal count.
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420083593
DEVANG SHARMA,devangdurvasa1004,430,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420106857
DEVANG SHARMA,devangdurvasa1004,430,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans(nums.size(), -1);

    for (int i = 0; i < nums.size(); ++i) {
        int num = nums[i];
        
       
        for (int x = 1; x < num; ++x) {
            if ((x | (x + 1)) == num) {
                ans[i] = x;
                break;
            }
        }
    }
    return ans;
}
};
 ",1419996628
DEVANG SHARMA,devangdurvasa1004,430,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420054475
easypeasy,easy0peasy1,431,3487,cpp,"class Solution {
public:
    
        long long max(long long a, long long b) {
      return (a > b) ? a : b;
}
    
    int maxRemovals(string s, string p, vector<int>& t) {
        int lenS = s.length();
        int lenP = p.length();
        
        vector<int> dp(lenP + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(lenS, false);
        for (int index : t) {
            isTarget[index] = true;
        }

        for (int i = 0; i < lenS; ++i) {
            for (int j = lenP; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return t.size() - (dp[lenP] == INT_MAX ? 0 : dp[lenP]);
        
    }
};",1420089206
easypeasy,easy0peasy1,431,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420096709
easypeasy,easy0peasy1,431,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for (int i = 0; i < nums.size(); i++) {
            ans[i] = -1; 
            
            for (int c = 0; c < nums[i]; c++) {
                if ((c | (c + 1)) == nums[i]) {
                    ans[i] = c;
                    break; 
                }
            }
        }
        
        return ans;
    }
};",1420020937
easypeasy,easy0peasy1,431,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int length = nums.size();
        vector<int> result(length);

        for (int idx = 0; idx < length; idx++) {
            int curr = nums[idx];
            int mn = INT_MAX;
            bool isFound = false;

            for (int bitPos = 0; bitPos <= 30; bitPos++) {
                if (((curr >> bitPos) & 1) == 1) {
                    int newCandidate = curr & ~(1 << bitPos);

                    if (newCandidate < 0) continue;

                    if ((newCandidate | (newCandidate + 1)) == curr) {
                        if (newCandidate < mn) {
                            mn = newCandidate;
                            isFound = true;
                        }
                    }
                }
            }

            result[idx] = isFound ? mn : -1;
        }

        return result;
    }
};",1420100658
Sanket Anand,snkt027,432,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];

        for(int i = 0; i < m + 1; i++){
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;

        for(int indx: targetIndices){
            isTarget[indx] = true;
        }

        for(int i = 0; i < n; i++){
            for(int j = m; j > 0; j--){
                if(source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420083812
Sanket Anand,snkt027,432,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); 
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); 
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); 
    }
}",1420107295
Sanket Anand,snkt027,432,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(int num: nums){
            bool found = false;
            for(int i = 0; i <= num; ++i){
                if((i | (i + 1)) == num){
                    ans.push_back(i);
                    found = true;
                    break;
                }
            }
            if(!found){
                ans.push_back(-1);
            }
        }

        return ans;
    }
};",1420007877
Sanket Anand,snkt027,432,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];

        for(int i = 0; i < n; i++){
            int num = nums.get(i);
            int min = Integer.MAX_VALUE;
            boolean found = false;

            for(int bit = 0; bit <= 30; bit++){
                if(((num >> bit) & 1) == 1){
                    int cand = num & ~(1 << bit);
                    if(cand < 0) continue;
                    if((cand | (cand + 1)) == num){
                        if(cand < min){
                            min = cand;
                            found = true;
                        }
                    }
                }
            }

            res[i] = found ? min : -1;
        }
        
        return res;

    }
}",1420073219
DAKSH SAHU,daksh_sahu_1803,433,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1]; // Dynamic programming array to track minimal removals
        boolean[] isTarget = new boolean[n]; // Boolean array to mark target indices

        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: no removals needed for an empty pattern

        // Mark the target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            // Iterate backward through the pattern to maintain the dp state
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    // Update dp[j] considering whether the current character is a target
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If it's possible to match the entire pattern, return the result, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420080615
DAKSH SAHU,daksh_sahu_1803,433,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize the combination (C) array using dynamic programming
        C = [[0] * (x + 1) for _ in range(x + 1)]
        
        # Fill the combination table
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        # Fill the Stirling numbers table
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD

        # Initialize the factorial array
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        # Main computation loop
        result = 0
        for k in range(1, x + 1):
            power = 1
            for p in range(k):
                power = (power * y) % MOD
            
            # Update result with final calculation using modular arithmetic
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result",1420120962
DAKSH SAHU,daksh_sahu_1803,433,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  
        
        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];

          
            for (int ans_candidate = 0; ans_candidate <= num; ++ans_candidate) {
                if ((ans_candidate | (ans_candidate + 1)) == num) {
                    ans[i] = ans_candidate;
                    break;  
                }
            }
        }
        return ans;
    }
};
",1420006082
DAKSH SAHU,daksh_sahu_1803,433,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420053918
shivanzzz,shivanzzz,434,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1]; // Dynamic programming array to track minimal removals
        boolean[] isTarget = new boolean[n]; // Boolean array to mark target indices

        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: no removals needed for an empty pattern

        // Mark the target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            // Iterate backward through the pattern to maintain the dp state
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    // Update dp[j] considering whether the current character is a target
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If it's possible to match the entire pattern, return the result, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420079471
shivanzzz,shivanzzz,434,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize the combination (C) array using dynamic programming
        C = [[0] * (x + 1) for _ in range(x + 1)]
        
        # Fill the combination table
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        # Fill the Stirling numbers table
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD

        # Initialize the factorial array
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        # Main computation loop
        result = 0
        for k in range(1, x + 1):
            power = 1
            for p in range(k):
                power = (power * y) % MOD
            
            # Update result with final calculation using modular arithmetic
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result",1420121239
shivanzzz,shivanzzz,434,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  # Initialize ans array with -1
        
        for i in range(n - 1, 0, -1):  # Work backwards to find the values of ans[i]
            for a in range(nums[i]):  # Try different values of ans[i]
                if a | (a + 1) == nums[i]:
                    ans[i] = a
                    break
        
        # Special check for ans[0]
        for a in range(nums[0]):
            if a | (a + 1) == nums[0]:
                ans[0] = a
                break
        
        return ans
",1419997938
shivanzzz,shivanzzz,434,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420052411
junaidiqbal1417,junaidiqbal1417,435,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])


        ",1420062651
junaidiqbal1417,junaidiqbal1417,435,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420095461
junaidiqbal1417,junaidiqbal1417,435,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420006422
junaidiqbal1417,junaidiqbal1417,435,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
           int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420049842
oshangg,oshangg,436,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] removableIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();
        
        // Create an array to store minimum removals required to match the pattern
        int[] minRemovals = new int[patternLength + 1];
        
        // Initialize the array with a large value, representing infinity
        for (int i = 0; i <= patternLength; i++) {
            minRemovals[i] = Integer.MAX_VALUE;
        }
        minRemovals[0] = 0;  // Base case: 0 removals needed to match the empty pattern
        
        // Boolean array to track which indices are removable
        boolean[] isRemovable = new boolean[sourceLength];
        for (int index : removableIndices) {
            isRemovable[index] = true;
        }
        
        // Process the source string
        for (int i = 0; i < sourceLength; i++) {
            // Traverse the pattern string from right to left to avoid overwriting dp values
            for (int j = patternLength; j > 0; j--) {
                // Check if the current character in source matches the corresponding pattern character
                if (source.charAt(i) == pattern.charAt(j - 1) && minRemovals[j - 1] != Integer.MAX_VALUE) {
                    // Update the dp array considering if the current index is removable
                    minRemovals[j] = Math.min(minRemovals[j], minRemovals[j - 1] + (isRemovable[i] ? 1 : 0));
                }
            }
        }
        
        // If it's impossible to match the entire pattern, return 0 removals; otherwise return the difference
        return removableIndices.length - (minRemovals[patternLength] == Integer.MAX_VALUE ? 0 : minRemovals[patternLength]);
    }
}
",1420100920
oshangg,oshangg,436,3604,cpp,"#include <vector>

class Solution {
public:
    static const int MOD = 1000000007;

    int numberOfWays(int total, int maxVal, int multiplier) {
        // Step 1: Create combination (binomial coefficient) array
        std::vector<std::vector<int>> comb(maxVal + 1, std::vector<int>(maxVal + 1, 0));
        for (int i = 0; i <= maxVal; i++) {
            comb[i][0] = 1;  // Base case: C(i, 0) = 1
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Step 2: Create the Stirling numbers of the second kind (partition function)
        std::vector<std::vector<int>> stirling(total + 1, std::vector<int>(maxVal + 1, 0));
        stirling[0][0] = 1;  // Base case: S(0, 0) = 1
        for (int i = 1; i <= total; i++) {
            for (int j = 1; j <= maxVal; j++) {
                stirling[i][j] = (int)((j * (long long)stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD);
            }
        }

        // Step 3: Create factorial array
        std::vector<long long> factorial(maxVal + 1, 1);
        for (int i = 1; i <= maxVal; i++) {
            factorial[i] = (factorial[i - 1] * i) % MOD;
        }

        // Step 4: Calculate the result using combinations, Stirling numbers, factorials, and powers
        long long result = 0;
        for (int k = 1; k <= maxVal; k++) {
            long long powerTerm = 1;
            for (int p = 0; p < k; p++) {
                powerTerm = (powerTerm * multiplier) % MOD;
            }

            // Compute the result using combination, Stirling numbers, factorial, and powerTerm
            result = (result + (comb[maxVal][k] * (long long)stirling[total][k] % MOD
                                * factorial[k] % MOD * powerTerm % MOD)) % MOD;
        }

        return (int)result;
    }
};
",1420121344
oshangg,oshangg,436,3605,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& numbers) {
        int size = numbers.size();
        std::vector<int> results(size);

        for (int i = 0; i < size; i++) {
            int currentNum = numbers[i];
            int bestCandidate = INT_MAX;
            bool isFound = false;

            // Check each bit position in the current number
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if ((currentNum >> bitPosition) & 1) {  // If the bit is set
                    int possibleNum = currentNum & ~(1 << bitPosition);
                    if (possibleNum < 0) continue;

                    // Check if the modified number and its successor create the original number when OR'd
                    if ((possibleNum | (possibleNum + 1)) == currentNum) {
                        if (possibleNum < bestCandidate) {
                            bestCandidate = possibleNum;
                            isFound = true;
                        }
                    }
                }
            }

            // Assign the result for this index
            if (isFound) {
                results[i] = bestCandidate;
            } else {
                results[i] = -1;
            }
        }

        return results;
    }
};
",1420116022
oshangg,oshangg,436,3611,cpp,"#include <vector>
#include <climits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& numbers) {
        int size = numbers.size();
        std::vector<int> results(size);

        for (int i = 0; i < size; i++) {
            int currentNum = numbers[i];
            int bestCandidate = INT_MAX;
            bool isFound = false;

            // Check each bit position in the current number
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if ((currentNum >> bitPosition) & 1) {  // If the bit is set
                    int possibleNum = currentNum & ~(1 << bitPosition);
                    if (possibleNum < 0) continue;

                    // Check if the modified number and its successor create the original number when OR'd
                    if ((possibleNum | (possibleNum + 1)) == currentNum) {
                        if (possibleNum < bestCandidate) {
                            bestCandidate = possibleNum;
                            isFound = true;
                        }
                    }
                }
            }

            // Assign the result for this index
            if (isFound) {
                results[i] = bestCandidate;
            } else {
                results[i] = -1;
            }
        }

        return results;
    }
};
",1420115151
Guru Krithick M,guru1307,437,3487,java,"import java.util.*;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        boolean[] isTargetIndex = new boolean[n];

        for (int idx : targetIndices) {
            isTargetIndex[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTargetIndex[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420057575
Guru Krithick M,guru1307,437,3604,java,"import java.util.*;

class Solution {
    static final int MOD = 1000000007;

    public int numberOfWays(int numPerformers, int numStages, int maxScore) {
        long[][] combinations = new long[numStages + 1][numStages + 1];
        for (int i = 0; i <= numStages; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        long[][] stirlingNumbers = new long[numPerformers + 1][numStages + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= numPerformers; i++) {
            for (int j = 1; j <= numStages; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorials = new long[numStages + 1];
        factorials[0] = 1;
        for (int i = 1; i <= numStages; i++) {
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= numStages; k++) {
            long scorePower = 1;
            for (int p = 0; p < k; p++) {
                scorePower = (scorePower * maxScore) % MOD;
            }
            totalWays = (totalWays + combinations[numStages][k] * stirlingNumbers[numPerformers][k] % MOD * factorials[k] % MOD * scorePower % MOD) % MOD;
        }

        return (int) totalWays;
    }
}
",1420109022
Guru Krithick M,guru1307,437,3605,java,"import java.util.*;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420033468
Guru Krithick M,guru1307,437,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420042011
Sonali Kumari,10100,438,3487,python3,"

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

",1420066910
Sonali Kumari,10100,438,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }

        // Initialize combination array
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Initialize Stirling numbers of the second kind
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        // Calculate the result using the precomputed arrays
        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD;  // Calculate y^k mod MOD
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        // Test cases
        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); // Expected output: 6
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); // Expected output: 32
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); // Expected output: 684
    }
}
",1420096321
Sonali Kumari,10100,438,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); 

        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];
            for (int j = 0; j < num; ++j) {
                if ((j | (j + 1)) == num) { 
                    ans[i] = j;
                    break;
                }
            }
        }

        return ans;
    }
};
",1419993032
Sonali Kumari,10100,438,3611,java,"import java.util.List;
class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}

           ",1420051003
Shubham Jha,alpha_9796,439,3487,cpp,"class Solution {
public:
    int dp[3001][3001];
    int n,m;
    long long find(int i,int j,const string& s,const string& pattern,vector<int>&target){
        if(i==n){
            if(j==m)return 0;
            else return INT_MIN;
        }
        if(dp[i][j]!=-1)return dp[i][j];
        long long ans=INT_MIN;
        if(target[i]==1){
            ans=max(ans,1+find(i+1,j,s,pattern,target));
        }
        if(s[i]==pattern[j]){
            ans=max(ans,find(i+1,j+1,s,pattern,target));
        }
        ans=max(ans,find(i+1,j,s,pattern,target));
        return dp[i][j]=ans;
    }
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n1=targetIndices.size();
        n=source.size();
        m=pattern.size();
        vector<int>vis(n,0);
        for(int i=0;i<n1;++i){
            vis[targetIndices[i]]=1;
        }
        memset(dp,-1,sizeof(dp));
        long long cnt=find(0,0,source,pattern,vis);
        if(cnt<=0)return 0;
        return cnt;
    }
};",1420061454
Shubham Jha,alpha_9796,439,3604,cpp,"const int mod=1000000007;
class Solution {
public:
    int pow1(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1){
            ans=(ans*a);
            ans%=mod;
        }
        a=(a*a);
        a%=mod;
        b>>=1;
    }
    return ans%mod;
}
    int numberOfWays(int n, int x, int y) {
       long long ans=0;
       vector<vector<long long> >dp(n+1,vector<long long>(x+1,0));
       vector<vector<long long> >dp1(x+1,vector<long long>(x+1,0));
       vector<long long>f(x+1,1);
       for(int i=0;i<=x;++i)dp1[i][0]=1;
        for(int i=1;i<=x;++i){
       for(int j=1;j<=i;++j){
            dp1[i][j]=(dp1[i-1][j-1]+dp1[i-1][j])%mod;
        }
       }
       dp[0][0]=1;
       for(int i=1;i<=n;++i){
        for(int j=1;j<=x;++j){
            dp[i][j]=((j*1ll*dp[i-1][j])%mod+dp[i-1][j-1])%mod;
        }
       }
       for(int i=1;i<=x;++i)f[i]=(i*1ll*f[i-1])%mod;
       for(int i=1;i<=x;++i){
        long long alp=pow1(y,i);
        ans=(ans+(((((dp1[x][i]*1ll*dp[n][i])%mod)*f[i])%mod)*alp)%mod)%mod;
       }
       return ans;
    }
};",1420116003
Shubham Jha,alpha_9796,439,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n=nums.size();
        vector<int>store;
        for(int i=0;i<n;++i){
            if(nums[i]==2){store.push_back(-1);continue;}
            bool alp=false;
            int ind=-1;
            for(int j=0;j<=31;++j){
                if((nums[i]>>j)&1){
                    ind=j;
                }
                else {
                    break;
                }
            }
            store.push_back(nums[i]-(1ll<<ind));
        }
        return store;
    }
};",1420018302
Shubham Jha,alpha_9796,439,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>store;
        for(int i=0;i<n;++i){
            if(nums[i]==2){store.push_back(-1);continue;}
            bool alp=false;
            int ind=-1;
            for(int j=0;j<=31;++j){
                if((nums[i]>>j)&1){
                    ind=j;
                }
                else {
                    break;
                }
            }
            store.push_back(nums[i]-(1ll<<ind));
        }
        return store;
    }
};",1420017707
pRziBnbrxc,pRziBnbrxc,440,3487,cpp,"class Solution {
    vector<int> findIndicesL(string &source,string &pattern,int &m,int &n){
        vector<int> l;
        int i=0,j=0;
        while(i<m&&j<n){
            if(source[i]==pattern[j]){
                l.push_back(i);
                j++;
            }
            i++;
        }
        return l;
    }
    vector<int> findIndicesR(string &source,string &pattern,int &m,int &n){
        vector<int> r;
        int i=m-1,j=n-1;
        while(i>=0&&j>=0){
            if(source[i]==pattern[j]){
                r.push_back(i);
                j--;
            }
            i--;
        }
        reverse(r.begin(),r.end());
        return r;
    }
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int ans=targetIndices.size(),m=source.size(),n=pattern.size();
        vector<bool> inIndices(m);
        for(int &i:targetIndices) inIndices[i]=1;
        vector<int> dp(n+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<m;i++){
            for(int j=n-1;j>=0;j--){
                if(dp[j]!=INT_MAX){
                    if(source[i]==pattern[j]) dp[j+1]=min(dp[j+1],dp[j]+inIndices[i]);
                }
            }
        }
        if(dp[n]!=INT_MAX) ans-=dp[n];
        return ans;
    }
};",1420107931
pRziBnbrxc,pRziBnbrxc,440,3604,cpp,"class Solution {
    const long long mod=1e9+7;
public:
    long long numberOfWays(int n, int x, int y) {
        int ans=0;
        long long p=1;;
        vector<long long> fact(x+1,1);
        for(int i=1;i<=x;i++) fact[i]=fact[i-1]*i%mod;
        vector<vector<long long>> dp1(x+1,vector<long long>(x+1,0)),dp2(n+1,vector<long long>(x+1,0));
        dp2[0][0]=1;
        for(long long i=0;i<=x;i++) {
            dp1[i][0]=1;
            for(long long j=0;j<i;j++) dp1[i][j+1]=(dp1[i-1][j]+dp1[i-1][j+1])%mod;
        }
        for(long long i=1;i<=n;i++) {
            for(long long j=0;j<x;j++) dp2[i][j+1]=((j+1)*dp2[i-1][j+1]+dp2[i-1][j])%mod;
        }
        for(long long k=1;k<=x;++k) {
            p=1;
            for(long long power=0;power<k;++power) p=(p*y)%mod;
            ans=(ans+dp1[x][k]*dp2[n][k]%mod*fact[k]%mod*p%mod)%mod;
        }
        return ans;
    }
};",1420123024
pRziBnbrxc,pRziBnbrxc,440,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            if(nums[i]&1){
                for(int j=1;j<nums[i];j++){
                    if((j|(j+1))==nums[i]){
                        ans[i]=j;
                        break;
                    }
                }
            }
        }
        return ans;
    }
};",1419996911
pRziBnbrxc,pRziBnbrxc,440,3611,cpp,"class Solution {
    int solve(int n){
        int count=0;
        while(n){
            if(n&1) count++;
            else break;
            n/=2;
        }
        return count;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans[i]=-1;
            else ans[i]=nums[i]-pow(2,solve(nums[i])-1);
        }
        return ans;
    }
};",1420040271
Harsha20,Hd0K1zFxZ4,441,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420116884
Harsha20,Hd0K1zFxZ4,441,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420116074
Harsha20,Hd0K1zFxZ4,441,3605,python,"class Solution:
    def minBitwiseArray(self, nums):
        ans = []
        for num in nums:
            found = False
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans
nums1 = [2, 3, 5, 7]
nums2 = [11, 13, 31]
solution = Solution()
print(solution.minBitwiseArray(nums1))
print(solution.minBitwiseArray(nums2))",1420114561
Harsha20,Hd0K1zFxZ4,441,3611,cpp,"class Solution {
public:
    int countTrailingOnes(int p) {
        int count = 0;
        while (p & 1) {
            count++;
            p >>= 1;
        }
        return count;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            if (p == 2 || (p & 1) == 0) {
                ans.push_back(-1);
                continue;
            }
            
            int t = countTrailingOnes(p);
            int x = p - (1 << (t - 1));
            if (x >= 0 && (x | (x + 1)) == p) {
                ans.push_back(x);
                
            } else {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420089909
ujwal001,ujwal001,442,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)  # Length of source string
        m = len(pattern)  # Length of pattern string
        dp = [float('inf')] * (m + 1)  # Dynamic programming array
        dp[0] = 0  # Base case: 0 removals needed for matching an empty pattern
        
        # Boolean array to track target indices
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        # Dynamic programming to find the minimum removals
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    # Update dp[j] if there's a match
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isTarget[i] else 0))

        # Calculate the maximum number of removals
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

# Example usage
sol = Solution()
source = ""abcbcac""
pattern = ""abc""
targetIndices = [1, 3, 5]

print(sol.maxRemovals(source, pattern, targetIndices))  # Example output
",1420067297
ujwal001,ujwal001,442,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1  # C(i, 0) = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1  # S(0, 0) = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):  # k: number of non-empty stages
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways

# Example usage
sol = Solution()
print(sol.numberOfWays(1, 2, 3))  # Output: 6
print(sol.numberOfWays(5, 2, 1))  # Output: 32
print(sol.numberOfWays(3, 3, 4))  # Output: 684

",1420099756
ujwal001,ujwal001,442,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            found = False

            for candidate in range(num):
                if (candidate | (candidate + 1)) == num:
                    ans.append(candidate)
                    found = True
                    break

            if not found:
                ans.append(-1)

        return ans
",1420034781
ujwal001,ujwal001,442,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit < 31; bit++) { // Using 31 to cover all bits of an integer
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            // Store the result
            ans[i] = found ? minimalAns : -1;
        }
        
        return ans;
    }
}


",1420103981
sravanivanka7,sravanivanka7,443,3487,cpp,"

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        // Initialize dp array to store the minimum removals for each position in pattern
        std::vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // Base case: zero removals needed to match an empty pattern

        // Create an array to track which indices are in targetIndices
        std::vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Process each character in the source string
        for (int i = 0; i < n; i++) {
            // Traverse the pattern in reverse to prevent overwriting dp[j-1]
            for (int j = m; j > 0; j--) {
                // Check if characters match and dp[j-1] is not infinity
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the number of removals possible
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420092812
sravanivanka7,sravanivanka7,443,3604,cpp,"#include <vector>
#include <cmath>

class Solution {
public:
    const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        // Initialize combination array
        std::vector<std::vector<long long>> comb(x + 1, std::vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Initialize Stirling numbers of the second kind
        std::vector<std::vector<long long>> stirling(n + 1, std::vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        std::vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        // Calculate the result using the precomputed arrays
        long long total_ways = 0;
        for (int k = 1; k <= x; k++) {
            long long y_pow = 1; // Initialize y_pow to 1 for calculating y^k
            for (int i = 0; i < k; i++) { // Calculate y^k % MOD
                y_pow = y_pow * y % MOD;
            }
            total_ways = (total_ways + (comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }

        return total_ways;
    }
};
",1420097509
sravanivanka7,sravanivanka7,443,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    int n = nums.size();
    vector<int> ans(n, -1); // Initialize the answer array with -1
    
    for (int i = 0; i < n; ++i) {
        bool found = false;
        
        // Try every number starting from 0 up to nums[i]
        for (int candidate = 0; candidate <= nums[i]; ++candidate) {
            if ((candidate | (candidate + 1)) == nums[i]) {
                ans[i] = candidate;
                found = true;
                break;
            }
        }
        
        // If no valid candidate is found, ans[i] remains -1
        if (!found) {
            ans[i] = -1;
        }
    }
    
    return ans;
    }
};",1420072147
sravanivanka7,sravanivanka7,443,3611,cpp,"

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};

",1420085614
vijay,Vijay_012,444,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420055618
vijay,Vijay_012,444,3604,python3,"MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]

        while params:
            break
        

        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        

        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        

        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        

        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420097804
vijay,Vijay_012,444,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        for num in nums:
            ans.append(next((i for i in range(num) if i | (i+1)==num),-1))
        return ans ",1420010585
vijay,Vijay_012,444,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {

                    int candidate = num & ~(1 << bit);
                    

                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420058793
Vishal Yadav,user4254Mn,445,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int sourceLength = source.length();
int patternLength = pattern.length();
vector<int> dp(patternLength + 1, numeric_limits<int>::max());
dp[0] = 0;

vector<bool> isTargetIndex(sourceLength, false);
for (int index : targetIndices) {
    isTargetIndex[index] = true;
}

for (int i = 0; i < sourceLength; i++) {
    for (int j = patternLength; j > 0; j--) {
        if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
            dp[j] = min(dp[j], dp[j - 1] + (isTargetIndex[i] ? 1 : 0));
        }
    }
}

return targetIndices.size() - (dp[patternLength] == numeric_limits<int>::max() ? 0 : dp[patternLength]);

    }
};",1420123495
Vishal Yadav,user4254Mn,445,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

int numberOfWays(int numItems, int maxGroups, int multiplier) {
    // Create a 2D vector for combinations
    std::vector<std::vector<int>> combinations(maxGroups + 1, std::vector<int>(maxGroups + 1, 0));
    for (int i = 0; i <= maxGroups; ++i) {
        combinations[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
        }
    } 

    // Create a 2D vector for Stirling numbers
    std::vector<std::vector<int>> stirlingNumbers(numItems + 1, std::vector<int>(maxGroups + 1, 0));
    stirlingNumbers[0][0] = 1;
    for (int i = 1; i <= numItems; ++i) {
        for (int j = 1; j <= maxGroups; ++j) {
            stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
        }
    }

    // Create a vector for factorial values
    std::vector<int> factorial(maxGroups + 1, 1);
    for (int i = 1; i <= maxGroups; ++i) {
        factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
    }

    long long totalWays = 0;
    for (int groupCount = 1; groupCount <= maxGroups; ++groupCount) {
        long long multiplierPow = 1;
        for (int i = 0; i < groupCount; ++i) {
            multiplierPow = (multiplierPow * multiplier) % MOD;
        }
        totalWays = (totalWays + (1LL * combinations[maxGroups][groupCount] * stirlingNumbers[numItems][groupCount] % MOD * factorial[groupCount] % MOD * multiplierPow % MOD)) % MOD;
    }
    return totalWays;
}

};",1420118969
Vishal Yadav,user4254Mn,445,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n);
        for(int i=0; i<nums.size(); i++){
            int ans1=-1;
            for(int j=0; j<=4000; j++){
                int x=( (j) | (j+1) );
                if(x==nums[i]){
                    ans1=j;
                    break;
                }
            }
            ans[i]=ans1;
        }
        return ans;
    }
};",1420030157
Vishal Yadav,user4254Mn,445,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 0);
    
    for (int i = 0; i < n; ++i) {
        int num = nums[i];
        int minimalAns = std::numeric_limits<int>::max();
        bool found = false;

        for (int bit = 0; bit < 31; ++bit) {
            if ((num >> bit) & 1) { // Check if the bit at position `bit` is set
                int candidate = num & ~(1 << bit); // Clear the `bit` position
                if (candidate < 0) {
                    continue; // Skip if candidate is negative
                }
                // Check if candidate with the next higher number equals num
                if ((candidate | (candidate + 1)) == num) {
                    if (candidate < minimalAns) {
                        minimalAns = candidate;
                        found = true;
                    }
                }
            }
        }

        if (found) {
            ans[i] = minimalAns;
        } else {
            ans[i] = -1; // If no valid candidate found
        }
    }
    
    return ans;
    }
};",1420121498
Sk Md Rizwan,Rizwan10,447,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420073563
Sk Md Rizwan,Rizwan10,447,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i-1][j- 1] + comb[i -1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stir(n + 1, std::vector<int>(x + 1, 0));
        stir[0][0] = 1;
        for (int i = 1; i <= n; ++i) 
            for (int j = 1; j <= x; ++j) 
                stir[i][j] = (1LL * j * stir[i - 1][j] + stir[i -1][j -1]) % MOD;
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) 
            factorial[i] = (1LL * factorial[i -1] * i) % MOD;
        long long tw = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            tw = (tw + (1LL * comb[x][k] * stir[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;

        }
        return tw;
    }
};",1420124083
Sk Md Rizwan,Rizwan10,447,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            if (!found) 
                ans[i] = -1;
        }
        return ans;
    }
}",1419994877
Sk Md Rizwan,Rizwan10,447,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420049693
Talapaneni Varshith Chowdary,talapanenivars,448,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420060634
Talapaneni Varshith Chowdary,talapanenivars,448,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105000
Talapaneni Varshith Chowdary,talapanenivars,448,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize the answer array with -1
        for (int i = 0; i < nums.size(); ++i) {
            for (int x = 0; x <= nums[i]; ++x) {
                // Check if the condition ans[i] OR (ans[i] + 1) == nums[i] holds
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420036637
Talapaneni Varshith Chowdary,talapanenivars,448,3611,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        int n = nums.size(); 
        vector<int> ans(n); 
         
        for (int i = 0; i < n; i++) { 
            int num = nums[i]; 
            int minimalAns = INT_MAX; 
            bool found = false; 
             
            
            for (int bit = 0; bit <= 30; bit++) { 
                if ((num >> bit) & 1) { 
                   
                    int candidate = num & ~(1 << bit); 
                     
                   
                    if (candidate < 0) continue; 
                     
                    
                    if ((candidate | (candidate + 1)) == num) { 
                        if (candidate < minimalAns) { 
                            minimalAns = candidate; 
                            found = true; 
                        } 
                    } 
                } 
            } 
             
            if (found) { 
                ans[i] = minimalAns; 
            } else { 
                ans[i] = -1; 
            } 
        } 
         
        return ans; 
    } 
};",1420058373
Shri Abhishek Choudhary,user6084Pr,449,3487,cpp,"class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();

        // Initialize dp array
        std::vector<int> dp(m + 1, std::numeric_limits<int>::max());
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        std::vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != std::numeric_limits<int>::max()) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.size() - (dp[m] == std::numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420092727
Shri Abhishek Choudhary,user6084Pr,449,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420103151
Shri Abhishek Choudhary,user6084Pr,449,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>res;
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            int j=0;
            while(j<=nums[i])
            {
                if((j|j+1)==nums[i])
                {
                    res.push_back(j);
                    break;
                }
                j++;
            }
            if(j>=nums[i])
            {
                res.push_back(-1);
            }
        }
        return res;
    }
};",1420010354
Shri Abhishek Choudhary,user6084Pr,449,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if ((num >> bit) & 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);

                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};
",1420105548
Vedant Tyagi,tyagivedant3846,450,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>
using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);  
        dp[0] = 0; 
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        return dp[m] == INT_MAX ? 0 : targetIndices.size() - dp[m];
    }
};
",1420061673
Vedant Tyagi,tyagivedant3846,450,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105816
Vedant Tyagi,tyagivedant3846,450,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 
        for (int i = 0; i < n; i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  
                }
            }
        }
        
        return ans;
    }
};",1420011495
Vedant Tyagi,tyagivedant3846,450,3611,cpp,"#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};
",1420054741
Siu,BenTennyson09,451,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <limits>

class Solution {
public:
    int maxRemovals(std::string s, std::string p, std::vector<int>& t) {
        int n = s.size(), m = p.size();
        std::vector<int> d(m + 1, std::numeric_limits<int>::max());
        d[0] = 0;
        std::vector<bool> it(n, false);
        
        int tSize = static_cast<int>(t.size());
        while (tSize--) it[t[tSize]] = true;

        int i = 0;
        while (i < n) {
            int j = m;
            while (j > 0) {
                if (s[i] == p[j - 1] && d[j - 1] != std::numeric_limits<int>::max()) {
                    d[j] = std::min(d[j], d[j - 1] + (it[i] ? 1 : 0));
                }
                --j;
            }
            ++i;
        }

        return t.size() - (d[m] == std::numeric_limits<int>::max() ? 0 : d[m]);
    }
};",1420125597
Siu,BenTennyson09,451,3604,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;

    vector<vector<long long>> comb(int siz) {
        vector<vector<long long>> C(siz + 1, vector<long long>(siz + 1, 0));
        int i = 0; while (i <= siz) { C[i][0] = 1; int j = 1; while (j <= i) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD; ++j; } ++i; }
        return C;
    }

    vector<vector<long long>> part(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1; int i = 1; while (i <= n) {
            int j = 1; while (j <= x) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD; ++j;
            } ++i;
        }
        return S;
    }

    vector<long long> fact(int siz) {
        vector<long long> F(siz + 1, 1);
        int i = 1; while (i <= siz) { F[i] = (F[i - 1] * i) % MOD; ++i; }
        return F;
    }

public:
    int numberOfWays(int n, int x, int y) {
        auto C = comb(x); auto S = part(n, x); auto F = fact(x);
        long long res = 0; int k = 1; while (k <= x) {
            long long p = 1; int pwr = 0; while (pwr < k) { p = (p * y) % MOD; ++pwr; }
            long long t = C[x][k]; t = (t * S[n][k]) % MOD; t = (t * F[k]) % MOD; t = (t * p) % MOD;
            res = (res + t) % MOD; ++k;
        }
        return static_cast<int>(res);
    }
};",1420110253
Siu,BenTennyson09,451,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        return list(map(lambda x: -1 if x == 2 else next(i for i in range(x) if i | (i + 1) == x), nums))",1419997306
Siu,BenTennyson09,451,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = [0] * len(nums)
        
        unset_bit = lambda num, bit_position: num & ~(1 << bit_position)
        is_valid = lambda value, num: (value | (value + 1)) == num
        
        index = 0
        while index < len(nums):
            current_num = nums[index]
            minimal_value = float('inf')
            bitwise_found = False
            
            bit_position = 0
            while bit_position < 31:
                if ((current_num >> bit_position) & 1) == 1:
                    modified_value = unset_bit(current_num, bit_position)
                    
                    if modified_value >= 0 and is_valid(modified_value, current_num):
                        if modified_value < minimal_value:
                            minimal_value = modified_value
                            bitwise_found = True
                bit_position += 1
            
            result[index] = minimal_value if bitwise_found else -1
            index += 1
        
        return result",1420059877
Kavish Dhamija,kavishd29598,452,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n=len(source)
        m=len(pattern)
        l=len(targetIndices)
        # targetIndices.sort()
        # mx_t=targetIndices[-1]+1
        tis = set(targetIndices)
        # @cache
        # def dp(s,p):
        #     ans = -float('inf')
        #     if s==n:
        #         return 0 if p==m else ans
        #     if p==m:
        #         return l-bisect.bisect_left(targetIndices,s)
        #     if s<mx_t and s in tis:
        #         ans = max(ans,1+dp(s+1,p))
        #     if s<n and p<m and source[s]==pattern[p]:
        #         ans = max(ans,dp(s+1,p+1))
        #     return max(ans,dp(s+1,p))
        # return dp(0,0)

        dp = [[-float('inf')] * (m + 1) for _ in range(n + 1)]
        for s in range(n + 1):
            dp[s][m] = l - bisect_left(targetIndices, s)
        for s in range(n - 1, -1, -1):  
            for p in range(m - 1, -1, -1): 
                dp[s][p] = dp[s + 1][p]
                if source[s] == pattern[p]:
                    dp[s][p] = max(dp[s][p], dp[s + 1][p + 1])
                if s in tis:
                    dp[s][p] = max(dp[s][p], 1 + dp[s + 1][p])
        return dp[0][0]",1420101109
Kavish Dhamija,kavishd29598,452,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        dp = [[0] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 1

        for i in range(1, n + 1):
            for j in range(1, x + 1):
                dp[i][j] = (dp[i-1][j] * j) % MOD
                dp[i][j] = (dp[i][j] + dp[i-1][j-1] * (x - j + 1)) % MOD

        ans = 0
        for j in range(1, x + 1):
            ans = (ans + dp[n][j] * pow(y, j, MOD)) % MOD

        return ans
",1420114596
Kavish Dhamija,kavishd29598,452,3605,python3,"
    
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            s=1
            z=float('inf')
            while s<=i:
                n = i^s
                # print(i,s,n) 
                if n|(n+1)==i:
                    z=min(n,z)
                s<<=1
            # print('--')
            ans.append(z if z!= float('inf') else -1)
        return ans",1420054016
Kavish Dhamija,kavishd29598,452,3611,python3,"
    
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in nums:
            s=1
            z=float('inf')
            while s<=i:
                n = i^s
                # print(i,s,n) 
                if n|(n+1)==i:
                    z=min(n,z)
                s<<=1
            # print('--')
            ans.append(z if z!= float('inf') else -1)
        return ans",1420054080
Pritam Sanjay S,sanjay_78,453,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        a,b=len(source),len(pattern)
        dp=[0]
        ma=99999999
        dp+=[ma]*(b)
        t=[0]*a
        for i in targetIndices:
            t[i]=1
        for i in range(a):
            for j in range(b,0,-1):
                if source[i]==pattern[j-1] and dp[j-1]!=ma:
                    dp[j]=min(dp[j-1]+t[i],dp[j])
        return len(targetIndices)-(0 if dp[b]==ma else dp[b])
        ",1420094115
Pritam Sanjay S,sanjay_78,453,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod=10**9 + 7
        arr=[[0]*(x+1) for _ in range(x+1)]
        dp=[[0]*(x+1) for _ in range(n+1)]
        dp[0][0]=1
        ft=[1]*(x+1)
        c=0
        for i in range(x+1):
            arr[i][0]=1
            for j in range(1,i+1):
                arr[i][j]=(arr[i-1][j-1]+arr[i-1][j]) % mod
        for i in range(1,n+1):
            for j in range(1,x+1):
                dp[i][j]=(j*dp[i-1][j]+dp[i-1][j-1])%mod
        for i in range(1,x+1):
            ft[i]=(ft[i-1]*i)%mod
        for k in range(1,x+1):
            p=pow(y,k,mod) 
            c=(c+arr[x][k]*dp[n][k]%mod*ft[k]%mod*p%mod)%mod

        return c",1420121700
Pritam Sanjay S,sanjay_78,453,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        x=[-1]*n
        for i in range(n):
            for j in range(nums[i]+1):
                t=j | (j+1)
                if t==nums[i]:
                    x[i]=j
                    break
        return x
            ",1420020364
Pritam Sanjay S,sanjay_78,453,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        x=[0]*n
        for i in range(n):
            t=nums[i]
            m=999999999999
            f=0
            for j in range(31):
                if (t>>j)&1==1:
                    c=t & ~(1<<j)
                    if c<0:continue
                    if c|(c+1)==t:
                        if c<m:
                            m=c
                            f=1
            if f:
                x[i]=m
            else:x[i]=-1
        return x",1420084952
raja jha,rgjha2001,454,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<float> dp(m + 1, float('inf'));
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != float('inf')) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == float('inf') ? 0 : dp[m]);
    }
};",1420118257
raja jha,rgjha2001,454,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> combination(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * combination[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420122891
raja jha,rgjha2001,454,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    int n = nums.size();
    std::vector<int> ans(n, -1);

    
    for (int i = 0; i < n; ++i) {
        bool found = false;
        
        for (int candidate = 0; candidate <= nums[i]; ++candidate) {
            if ((candidate | (candidate + 1)) == nums[i]) {
                ans[i] = candidate;
                found = true;
                break;
            }
        }
        if (!found) {
            ans[i] = -1;
        }
    }

    return ans;
    }
};",1420033074
raja jha,rgjha2001,454,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            
            for (int bit = 0; bit <= 30; ++bit) {
                if (((num >> bit) & 1) == 1) {
                  
                    int candidate = num & ~(1 << bit);
                    
                    
                    if (candidate < 0) continue;
                    
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420074194
Abhiram Alluri,Abhiram_Alluri1,455,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val n = source.length
        val m = pattern.length
        val dp = IntArray(m + 1) { Int.MAX_VALUE }
        val isTarget = BooleanArray(n)

        dp[0] = 0

        for (idx in targetIndices) {
            isTarget[idx] = true
        }

        for (i in 0 until n) {
            for (j in m downTo 1) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != Int.MAX_VALUE) {
                    dp[j] = minOf(dp[j], dp[j - 1] + if (isTarget[i]) 1 else 0)
                }
            }
        }

        return targetIndices.size - if (dp[m] == Int.MAX_VALUE) 0 else dp[m]
    }
}
",1420092941
Abhiram Alluri,Abhiram_Alluri1,455,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420110520
Abhiram Alluri,Abhiram_Alluri1,455,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int x = 0;
            while (x <= nums[i]) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;
                }
                x++;
            }
        }
        return ans;
    }
};",1420000222
Abhiram Alluri,Abhiram_Alluri1,455,3611,swift,"class Solution {
    func minBitwiseArray(_ nums: [Int]) -> [Int] {
        let n = nums.count
        var ans = [Int](repeating: 0, count: n)
        
        for i in 0..<n {
            let num = nums[i]
            var minimalAns = Int.max
            var found = false
            
            // Iterate through each bit position (0 to 30)
            for bit in 0...30 {
                if (num >> bit) & 1 == 1 {
                    // Unset the current bit
                    let candidate = num & ~(1 << bit)
                    
                    // Ensure candidate is non-negative
                    if candidate < 0 { continue }
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num {
                        if candidate < minimalAns {
                            minimalAns = candidate
                            found = true
                        }
                    }
                }
            }
            
            if found {
                ans[i] = minimalAns
            } else {
                ans[i] = -1
            }
        }
        
        return ans
    }
}
",1420074582
phoenixwon,phoenixwon,456,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420062485
phoenixwon,phoenixwon,456,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420090709
phoenixwon,phoenixwon,456,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420021768
phoenixwon,phoenixwon,456,3611,java,"
import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420038452
Raj Mandhare,Raj2603,457,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> check(n, false);
        for (auto it : targetIndices) {
            check[it] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    if(check[i]){
                        dp[j] = min(dp[j], dp[j - 1] + 1);
                    }else{
                        dp[j] = min(dp[j], dp[j - 1] + 0);
                    }
                    
                }
            }
        }
        if(dp[m]==INT_MAX){
            return targetIndices.size();
        }else{
            return targetIndices.size() - dp[m];
        }
    }
};",1420069172
Raj Mandhare,Raj2603,457,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9+7;
    int calpow(int b, int p, int m) {
        long long res = 1;
        long long bmod = b % m;
        while (p > 0) {
            if (p % 2 == 1) {
                res = (res * bmod) % m;
            }
            bmod = (bmod * bmod) % m;
            p /= 2;
        }
        return res;
    }
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> combinations(x+1, vector<int>(x+1, 0));
        vector<int> fact(x + 1, 1);
        vector<vector<int>> temp(n+1, vector<int>(x+1, 0));
        temp[0][0] = 1;

        for (int i = 0; i <= x; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i-1][j-1] + combinations[i-1][j]) % MOD;
            }
        }

        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                temp[i][j] = (1LL * j * temp[i-1][j] + temp[i-1][j-1]) % MOD;
            }
        }

        for (int i = 1; i <= x; i++) {
            fact[i] = (1LL * fact[i-1] * i) % MOD;
        }

        long long ans = 0;
        for (int j = 1; j <= x; j++) {
            long long yexp = calpow(y, j, MOD);
            ans = (ans + 1LL * combinations[x][j] * temp[n][j] % MOD * fact[j] % MOD * yexp % MOD) % MOD;
        }

        return ans;
    }
};",1420124036
Raj Mandhare,Raj2603,457,3605,cpp,"class Solution {
public:
   
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n); 
         
        for (int i = 0; i < n; i++) { 
            bool flag = 0; 
            for (int j = 0; j <= nums[i]; j++) { 
                if ((j | (j + 1)) == nums[i]) { 
                    ans[i] = j;  
                    flag = 1; 
                    break; 
                } 
            } 
             
            if (!flag) { 
                ans[i] = -1;
            } 
        } 
         
        return ans; 
    }
};",1420022723
Raj Mandhare,Raj2603,457,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
    
        for (int i = 0; i < n; i++) {
            int mini = INT_MAX;
            bool flag = 0;
            int num = nums[i];

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int temp = num & ~(1 << bit);
                    if (temp < 0){ 
                        continue;
                    }
                    if ((temp | (temp + 1)) == num) {
                        if (temp < mini) {
                            flag = 1;
                            mini = temp;
                        }
                    }
                }
            }
        
            if (flag) {
                ans[i] = mini;
            } else {
                ans[i] = -1;
            }
        }
    
        return ans;
    }
};",1420050733
swap_ab,swap_ab,458,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
         int n=source.size();
         int m=pattern.size();
         vector<int>ans(m+1,INT_MAX);
         ans[0]=0;
         vector<bool>iscorrect(n,false);
         for(auto it:targetIndices)
         {
            iscorrect[it]=true;
         }
         for(int i=0;i<n;i++)
         {
            for(int j=m;j>0;j--)
            {
                if(source[i]==pattern[j-1]&&ans[j-1]!=INT_MAX)
                {
                    ans[j]=min(ans[j],ans[j-1]+(iscorrect[i]?1:0));
                }
            }
         }
         return targetIndices.size()-(ans[m]==INT_MAX?0:ans[m]);
    }
};",1420101650
swap_ab,swap_ab,458,3604,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    
    vector<vector<long long>> computeCombinations(int size) {
        vector<vector<long long>> C(size + 1, vector<long long>(size + 1, 0));
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }
    
    vector<vector<long long>> computePartitions(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }
    
    vector<long long> computeFactorials(int size) {
        vector<long long> fact(size + 1, 1);
        for (int i = 1; i <= size; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

public:
    int numberOfWays(int n, int x, int y) {
        auto C = computeCombinations(x);
        auto S = computePartitions(n, x);
        auto fact = computeFactorials(x);
        
        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            long long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * fact[k]) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }
        
        return static_cast<int>(result);
    }
};",1420113055
swap_ab,swap_ab,458,3605,cpp,"#include <vector>  
#include <limits.h>  

class Solution {  
public:  
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {  
        int n = nums.size();  
        std::vector<int> ans(n, -1);  

        for (int i = 0; i < n; i++) {  
            int num = nums[i];  
            int minimalAns = INT_MAX;  

            for (int bit = 0; bit < 31; bit++) {  
                if ((num >> bit) & 1) {  
                    int candidate = num & ~(1 << bit);  
                    if (candidate >= 0) {  
                        if ((candidate | (candidate + 1)) == num) {  
                            minimalAns = std::min(minimalAns, candidate);  
                        }  
                    }  
                }  
            }  

            if (minimalAns != INT_MAX) {  
                ans[i] = minimalAns;  
            }  
        }  
        
        return ans;  
    }  
};",1420120883
swap_ab,swap_ab,458,3611,cpp,"#include <vector>  
#include <limits.h>  

class Solution {  
public:  
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {  
        int n = nums.size();  
        std::vector<int> ans(n, -1);  

        for (int i = 0; i < n; i++) {  
            int num = nums[i];  
            int minimalAns = INT_MAX;  

            for (int bit = 0; bit < 31; bit++) {  
                if ((num >> bit) & 1) {  
                    int candidate = num & ~(1 << bit);  
                    if (candidate >= 0) {  
                        if ((candidate | (candidate + 1)) == num) {  
                            minimalAns = std::min(minimalAns, candidate);  
                        }  
                    }  
                }  
            }  

            if (minimalAns != INT_MAX) {  
                ans[i] = minimalAns;  
            }  
        }  

        return ans;  
    }  
};",1420124121
padhaikarlebhai,mradulag20,459,3487,cpp,"class Solution {
public:

    int dp[3002][3002]; 
    int n, m; 
    string s, p;
    set<int> st; 
    
    int rec(int ii, int jj) {
        if(ii == n) {
            if(jj == m) return 0; 
            return -1e9;
        }

        if(dp[ii][jj] != -1) return dp[ii][jj]; 

        int ans = rec(ii+1, jj); 
        if(s[ii] == p[jj]){
            ans = max(ans, rec(ii+1, jj+1)); 
        }
        if(st.find(ii) != st.end()) {
            ans = max(ans, rec(ii+1, jj) + 1); 
        }

        return dp[ii][jj] = ans; 
    }

    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        s = source;
        p = pattern; 
        n = s.size(); 
        m = p.size(); 
        for(auto it: targetIndices) {
            st.insert(it); 
        }

        for(int i=0; i<=n; i++) {
            for(int j=0; j<=m; j++) {
                dp[i][j] = -1; 
            }
        }

        return rec(0, 0); 
    }
};",1420025150
padhaikarlebhai,mradulag20,459,3604,cpp,"class Solution {
public:

    long long mod = 1e9+7; 

    long long nCr[2000][2000];
    long long binpow(long long n, long long p)
    {
        long long ans = 1;
        while (p)
        {
            if (p % 2)
            {
                ans *= n;
                ans %= mod;
            }
            n *= n;
            n %= mod;
            p >>= 1;
        }
        return ans;
    }

    long long invmod(int n)
    {
        // if(invmod_dp[n] != -1) return invmod_dp[n]; 
        return binpow(n, mod - 2);
    }

    long long dpp[2000]; 

    int numberOfWays(int n, int x, int y) {
        
        long long facs[2000]; 
        facs[0] = 1; 
        for(int i=1; i<2000; i++) {
            facs[i] = i * facs[i-1]; 
            facs[i] %= mod; 
        }

        long long pows[2000]; 
        pows[0] = 1; 
        for(int i=1; i<2000; i++) {
            pows[i] = y * pows[i-1]; 
            pows[i] %= mod; 
        }


        for(int i=0; i<=max(x,n)+1; i++) {
            dpp[i] = invmod(facs[i]);
        }


        for(int i=0; i<=max(n,x)+2; i++) {
            for(int j=0; j<=max(n,x)+2; j++)
            {
                if(i-j >= 0){
                    nCr[i][j] = ((facs[i] * dpp[j])%mod * dpp[i-j])%mod; 
                }
            }
        }

        long long dp[2000]; 

        int ans = 0; 
        for(int i=1; i<=x; i++) {
            long long temp = nCr[x][i]; 
            temp *= pows[i]; 
            // cout << nCr[x][i] << "" "" << pows[i] << "" "" << temp << endl; 
            temp %= mod;
            if(n < i) continue; 
            long long total = binpow(i, n);
            for(int j=1; j<i; j++) {
                total -= (dp[j] * nCr[i][j])%mod; 
                total += mod; 
                total %= mod; 
            }
            temp *= total; 
            temp %= mod; 
            dp[i] = total; 

            // cout << temp << endl; 

            ans += temp;
            ans %= mod; 
        }

        return ans; 

    }
};",1420124633
padhaikarlebhai,mradulag20,459,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans; 

        for(auto it: nums) {
            if(it == 2) {
                ans.push_back(-1); 
            }
            else
            {
                int itt = it; 
                int cnt = 0; 
                while(it > 0) {
                    if(it%2 == 0) {
                        break; 
                    }
                    else{
                        cnt++; 
                        it /= 2; 
                    }
                }
                itt = itt ^ (1 << (cnt-1)); 
                ans.push_back(itt); 
            }
        }

        return ans; 
    }
};",1420009186
padhaikarlebhai,mradulag20,459,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans; 

        for(auto it: nums) {
            if(it == 2) {
                ans.push_back(-1); 
            }
            else
            {
                int itt = it; 
                int cnt = 0; 
                while(it > 0) {
                    if(it%2 == 0) {
                        break; 
                    }
                    else{
                        cnt++; 
                        it /= 2; 
                    }
                }
                itt = itt ^ (1 << (cnt-1)); 
                ans.push_back(itt); 
            }
        }

        return ans; 
    }
};",1420008845
Shivanand Verma,starkbbk,460,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];
        
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420112137
Shivanand Verma,starkbbk,460,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420117107
Shivanand Verma,starkbbk,460,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>res(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=nums[i];j++){
                if((j|(j+1))==nums[i]){
                    res[i]=j;
                    break;
                }
            }
        }
        return res;
    }
};",1420049504
Shivanand Verma,starkbbk,460,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420118568
vittasai05,vittasai05,461,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array to store minimum removals to match the pattern
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;  // dp[0] means no part of the pattern is matched yet
        
        // Mark target indices in the source
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        // Traverse the source string
        for (int i = 0; i < n; i++) {
            // Traverse pattern from the back
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        // If we matched the entire pattern, return the removals used, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420101133
vittasai05,vittasai05,461,3604,python,"MOD = 10**9 + 7
class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420112894
vittasai05,vittasai05,461,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;

            // Try to find the smallest ans[i] such that ans[i] OR (ans[i] + 1) == nums[i]
            for (int j = 0; j < num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }

            // If no such value is found, set ans[i] = -1
            if (!found) {
                ans[i] = -1;
            }
        }

        return ans;
    }
}
",1420025778
vittasai05,vittasai05,461,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420097680
Nahid Karim Emon,nahid_180103,462,3487,cpp,"class Solution {
public:
    int maxRemovals(string& source, string& pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int c = targetIndices.size();
        vector<bool>vis(n);
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        for (int e : targetIndices) {
            vis[e] = true;
        }
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if(dp[j-1] == INT_MAX)continue;
                if(source[i] == pattern[j-1]){
                    int p = dp[j-1];
                    if(vis[i])p++;
                    int x = min(dp[j],p);
                    dp[j] = x;
                }
            }
        }
        int y=0;
        if(dp[m]!=INT_MAX)y=dp[m];
        return c-y;
    }
};",1420065998
Nahid Karim Emon,nahid_180103,462,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        int an=0;
        vector<long long>fac(x+1,1);
        for(int i=1;i<=x;i++){
            fac[i]=(fac[i-1]*i*1LL)%mod;
        }
        vector<vector<long long>> arr(x + 1, vector<long long>(x + 1, 0)),brr(n+1,vector<long long>(x+1,0));
        brr[0][0] = 1;
        for (int i = 0; i <= x; i++) {
            arr[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                long long p = arr[i-1][j-1]+arr[i-1][j];
                arr[i][j]=p%mod;
            }
        }
        for (int i = 1; i <= n; i++) {    
            for (int j = 1; j <= x; j++) {
                long long p = j*brr[i-1][j];
                p+=brr[i-1][j-1];
                brr[i][j]=p%mod;
            }
        }
        for (int i = 1; i <= x; i++) {
            long long p = 1;
            for (int j = 0; j < i; j++) {
                p*=y;
                p%=mod;
            }
            long long y = (arr[x][i]*brr[n][i]%mod*fac[i]%mod*p%mod)%mod;
            an+=(y%mod);
            an%=mod;
        }

        return an%mod;
    }
};
",1420113196
Nahid Karim Emon,nahid_180103,462,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        
        for (int i = 0; i < nums.size(); i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }
        
        return ans;
    }
};
",1419996910
Nahid Karim Emon,nahid_180103,462,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int mx=INT_MAX;
            bool ch = false;
            for (int j = 0; j <= 30; j++) {
                if ((nums[i] >> j) & 1) {
                    int x = nums[i] & ~(1 << j);
                    if(x>=0){
                        if((x|(x+1))==nums[i]){
                            if(x<mx){
                                mx=x;
                                ch=true;
                            }
                        }
                    }
                }
            }
            ans[i]=(ch?mx:-1);
        }
        
        return ans;
    }
};
",1420075518
OmkarKanade,OmkarKanade,463,3487,cpp,"class Solution {
public:
    int f(string &source, string &pattern, unordered_set<int> &tgt, int si, int pi, vector<vector<int>> &dp) {
        // base case
        if (si == source.length()) {
            if (pi == pattern.length()) {
                return 0;
            }
            return INT_MIN;
        }
        
        if (dp[si][pi] != -1) {
            return dp[si][pi];
        }
        
        // skip current char
        int skipVal1 = INT_MIN;
        int skipVal2 = INT_MIN;
        
        skipVal1 = f(source, pattern, tgt, si + 1, pi, dp);
        if (pi < pattern.length() && source[si] == pattern[pi]) {
            skipVal2 = f(source, pattern, tgt, si + 1, pi + 1, dp);
        }
        
        // remove current char
        int removeVal = INT_MIN;
        if (tgt.find(si) != tgt.end()) {
            removeVal = 1 + f(source, pattern, tgt, si + 1, pi, dp);
        }
        
        dp[si][pi] = max(max(skipVal1, skipVal2), removeVal);
        return dp[si][pi];
    }
    
    int maxRemovals(string &source, string &pattern, vector<int>& targetIndices) {
        int n = source.length();
        int p = pattern.length();
        int t = targetIndices.size();
        
        unordered_set<int> tgt;
        for (int i: targetIndices) {
            tgt.insert(i);
        }
        
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return f(source, pattern, tgt, 0, 0, dp);
    }
};",1420052155
OmkarKanade,OmkarKanade,463,3604,cpp,"class Solution {
public:
    int MOD = 1e9+7;
    
    int constructTable(vector<vector<long long>> &xCk, int x, int k) {
        if (x == k || k == 0) {
            xCk[x][k] = 1;
            return 1;
        }
        if (k == 1) {
            xCk[x][k] = x;
            return x;
        }
        
        if (xCk[x][k] != -1) {
            return xCk[x][k];
        }
        
        xCk[x][k] = (constructTable(xCk, x - 1, k) + constructTable(xCk, x - 1, k - 1)) % MOD;
        return xCk[x][k];
    }
    
    int numberOfWays(int n, int x, int y) {
        long long res = 0;
        long long occ = min(n, x);
        vector<vector<long long>> xCk(x + 1, vector<long long>(x + 1, -1));
        constructTable(xCk, x, x);
        long long yPow = y;
        long long curr = 1;
        vector<long long> kPowN(occ + 1, 1);
        kPowN[0] = 0;
        for (int k=2; k<=occ; k++) {
            long long val = 1;
            for (int p=0; p<n; p++) {
                val = (val * k) % MOD;
            }
            kPowN[k] = val % MOD;
        }
        for (int k=1; k<=occ; k++) {
            if (xCk[x][k] == -1) {
                constructTable(xCk, x, k);
            }
            curr = (xCk[x][k] *  yPow) % MOD;
            long long sum = 0;
            long long term;
            long long sign = 1;
            for (int i=0; i<=k; i++) {
                if (xCk[k][i] == -1) {
                    constructTable(xCk, k, i);
                }
                term = (((sign * xCk[k][i] * kPowN[k - i]) % MOD) + MOD) % MOD;
                sum = (sum + term) % MOD;
                sign *= -1;
            }
            curr = (curr * sum) % MOD;
            res = (res + curr) % MOD;
            yPow = (yPow * y) % MOD;
        }
        return res % MOD;
    }
};",1420126284
OmkarKanade,OmkarKanade,463,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i=0; i<n; i++) {
            int num = nums[i];
            if (num == 2) {
                res[i] = -1;
            } else {
                int k = num;
                int twoPow = 1;
                while (k > 0 && k % 2 != 0) {
                    k /= 2;
                    twoPow *= 2;
                }
                res[i] = num - (twoPow / 2);
            }
        }
        return res;
    }
};",1420001732
OmkarKanade,OmkarKanade,463,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i=0; i<n; i++) {
            int num = nums[i];
            if (num == 2) {
                res[i] = -1;
            } else {
                int k = num;
                int twoPow = 1;
                while (k > 0 && k % 2 != 0) {
                    k /= 2;
                    twoPow *= 2;
                }
                res[i] = num - (twoPow / 2);
            }
        }
        return res;
    }
};",1420002417
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3487,java,"class Solution {
    public int maxRemovals(String s, String p, int[] t) {
        int a = s.length();
        int b = p.length();
        int[] c = new int[b + 1];
        Arrays.fill(c, Integer.MAX_VALUE);
        c[0] = 0;

        boolean[] d = new boolean[a];
        int e = 0;
        // while (e < t.length) {
        //     d[t[e]] = true;
        while (e < t.length) {
            d[t[e]] = true;
            e++;
        }
        //     e++;
        // }

        int f = 0;
        while (f < a) {
            int g = b;
            // while (g > 0) {
            while (g > 0) {
                if (s.charAt(f) == p.charAt(g - 1) && c[g - 1] != Integer.MAX_VALUE) {
                    c[g] = Math.min(c[g], c[g - 1] + (d[f] ? 1 : 0));
                }
                g--;
            }
            //         c[g] = Math.min(c[g], c[g - 1] + (d[f] ? 1 : 0));
            // }
            f++;
        }

        return t.length - (c[b] == Integer.MAX_VALUE ? 0 : c[b]);
    }
}",1420121982
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3604,java,"class Solution {
    public int numberOfWays(int n, int x, int y) {
        final int MOD = 1_000_000_007;
        long[][] c = new long[n + 1][x + 1];
        c[0][0] = 1;

        int i = 1;
        while (i <= n) {
            int j = 1;
            while (j <= Math.min(i, x)) {
                c[i][j] = (j * c[i - 1][j] + c[i - 1][j - 1]) % MOD;
                j++;
            }
            i++;
        }

        long[] bc = new long[x + 1];
        bc[0] = 1;

        int i2 = 1;
        while (i2 <= x) {
            int j2 = Math.min(i2, x);
            // while (j2 >= 1) {
             while (j2 >= 1) {
                bc[j2] = (bc[j2] + bc[j2 - 1]) % MOD;
                j2--;
            //     j2--;
            }
            i2++;
        }

        long[] f = new long[x + 1];
        f[0] = 1;

        int i3 = 1;
        while (i3 <= x) {
            f[i3] = (f[i3 - 1] * i3) % MOD;
            i3++;
        }

        // int limit = Math.min(x, n);
        int limit = Math.min(x, n);
        long[] pY = new long[limit + 1];
        // long[] pY = new long[limit + 1];
        pY[0] = 1;

        int k = 1;
        while (k <= limit) {
            pY[k] = (pY[k - 1] * y) % MOD;
            k++;
        }

        long totalWays = 0;

        k = 1;
        while (k <= limit) {
            long intermediate = (bc[k] * f[k]) % MOD;
            // intermediate = (intermediate * c[n][k]) % MOD;
            intermediate = (intermediate * c[n][k]) % MOD;
            intermediate = (intermediate * pY[k]) % MOD;
            totalWays = (totalWays + intermediate) % MOD;
            // intermediate = (intermediate * pY[k]) % MOD;
            // totalWays = (totalWays + intermediate) % MOD;
            k++;
        }

        return (int) totalWays;
    }
}",1420065547
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3605,cpp,"#include <vector>
#include <algorithm>

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            for (int j = 0; j < nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420037247
Priyanshi Gupta,Er_Priyanshi_Gupta,464,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] out = new int[nums.size()];

        int i = 0;
        while (i < nums.size()) {
            // int n = nums.get(i);
            int n = nums.get(i);
            int best = Integer.MAX_VALUE;
            // int best = Integer.MAX_VALUE;

            int b = 0;
            while (b < 31) {
                if ((n & (1 << b)) != 0) {
                    int newC = n & ~(1 << b);

                    if (newC >= 0 && newC < n) {
                        int subC = newC + 1;

                        // if ((newC | subC) == n) {
                        if ((newC | subC) == n) {
                            if (newC < best) {
                                best = newC;
                            }
                        }
                        //     if (newC < best) {
                        //         best = newC;
                        //     }
                        // }
                    }
                }
                b++;
            }

            out[i] = (best != Integer.MAX_VALUE) ? best : -1;
            i++;
        }

        return out;
    }
}",1420089507
Maharaj Mahaadev,Maharaj_Mahaadev,465,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices){
            isTarget[idx] = true;
        }

        for(int i = 0; i < n; i++){
            for(int j = m; j > 0; j--){
                if(source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX){
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420091568
Maharaj Mahaadev,Maharaj_Mahaadev,465,3604,cpp,"const int MOD = 1e9 + 7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<int> params = {n, x, y};

        while(!params.empty()){
            break;
        }

        vector<vector<int>> comb(x+1, vector<int>(x+1, 0));
        for(int i=0; i<=x; ++i){
            comb[i][0] = 1;
            for(int j=1; j<=i; ++j){
                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;
            }
        }

        vector<vector<long long int>> stirling(n+1, vector<long long int>(x+1, 0));
        stirling[0][0] = 1;

        for(int i=1; i<=n; ++i){
            for(int j=1; j<=x; ++j){
                stirling[i][j] = (j * stirling[i-1][j] + stirling[i-1][j-1]) % MOD;
            }
        }

        vector<long long int> factorial(x + 1, 1);
        for(int i=1; i<=x; ++i) {
            factorial[i] = factorial[i-1] * i % MOD;
        }

        long long total_ways = 0; 
        for(int k=1; k<=x; ++k) {
            long long y_pow = 1;
            for(int power=0; power<k; ++power) {
                y_pow = (y_pow * y) % MOD;
            }

            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }

        return total_ways%MOD;
    }
};",1420109743
Maharaj Mahaadev,Maharaj_Mahaadev,465,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); 

        for(int i = 0; i < n; ++i){
            for(int x = 0; x <= nums[i]; ++x){
                if((x | (x + 1)) == nums[i]){
                    ans[i] = x;
                    break;
                }
            }
        }

        return ans;
    }
};",1420041028
Maharaj Mahaadev,Maharaj_Mahaadev,465,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for(int i = 0; i < n; i++){
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for(int bit = 0; bit <= 30; bit++){
                if(((num >> bit) & 1) == 1){
                    int candidate = num & ~(1 << bit);
                    if(candidate < 0) continue;

                    if((candidate | (candidate + 1)) == num){
                        if(candidate < minimalAns){
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if(found){
                ans[i] = minimalAns;
            } 
            else{
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420087452
Gajendra Sahu,gajmain2020,466,3487,javascript,"/**
 * @param {string} source
 * @param {string} pattern
 * @param {number[]} targetIndices
 * @return {number}
 */
var maxRemovals = function(text, subPattern, removeIndices) {
    const textLength = text.length, patternLength = subPattern.length;
        const minRemovals = Array(patternLength + 1).fill(Infinity);
        const markedForRemoval = Array(textLength).fill(false);

        minRemovals[0] = 0;

        removeIndices.forEach(index => markedForRemoval[index] = true);

        for (let i = 0; i < textLength; ++i) {
            for (let j = patternLength; j > 0; --j) {
                if (text[i] === subPattern[j - 1] && minRemovals[j - 1] !== Infinity) {
                    minRemovals[j] = Math.min(minRemovals[j], minRemovals[j - 1] + (markedForRemoval[i] ? 1 : 0));
                }
            }
        }

        return removeIndices.length - (minRemovals[patternLength] === Infinity ? 0 : minRemovals[patternLength]);
};",1420103557
Gajendra Sahu,gajmain2020,466,3604,cpp,"class Solution {
    const int MOD = 1e9 + 7;
public:
    int numberOfWays(int n, int x, int y) {
       vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stir(n + 1, vector<int>(x + 1, 0));
        stir[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stir[i][j] = (1LL * j * stir[i - 1][j] + stir[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }

        int res = 0;
        for (int k = 1; k <= x; ++k) {
            long long powY = 1;
            for (int p = 0; p < k; ++p) {
                powY = (powY * y) % MOD;
            }
            res = (res + (1LL * comb[x][k] * stir[n][k] % MOD * fact[k] % MOD * powY % MOD)) % MOD;
        }

        return (res + MOD) % MOD; 
    }
};",1420123628
Gajendra Sahu,gajmain2020,466,3605,javascript,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minBitwiseArray = function(nums) {
    return nums.map(num => {
        let minAns = Number.MAX_SAFE_INTEGER, found = false;
        for (let bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {
                const candidate = num & ~(1 << bit);
                if (candidate >= 0 && (candidate | (candidate + 1)) === num) {
                    minAns = Math.min(minAns, candidate);
                    found = true;
                }
            }
        }
        return found ? minAns : -1;
    });
};",1420106024
Gajendra Sahu,gajmain2020,466,3611,javascript,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minBitwiseArray = function(nums) {
    return nums.map(num => {
        let minAns = Number.MAX_SAFE_INTEGER, found = false;
        for (let bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {
                const candidate = num & ~(1 << bit);
                if (candidate >= 0 && (candidate | (candidate + 1)) === num) {
                    minAns = Math.min(minAns, candidate);
                    found = true;
                }
            }
        }
        return found ? minAns : -1;
    });
};",1420105785
rohith1902,rohith1902,467,3487,cpp,"class Solution {
public:
    set<int> st;
    int dp[3004][3004];
    bool vis[3004][3004];
    int solve(int i,int j,string &s,string &p){
        if(i==s.size())
            return(j==p.size())? 0 : -1e5;

        if(vis[i][j]) return dp[i][j];

        int ans = 0;
        if(s[i] == p[j])
            ans = solve(i+1,j+1,s,p);
        else
            ans = solve(i+1,j,s,p);
        if(st.count(i)){
            ans = max(ans,1+solve(i+1,j,s,p));
        }
        vis[i][j] =  true;
        dp[i][j] = ans;
        
        return ans;
    }
    int maxRemovals(string& source, string& pattern, vector<int>& targetIndices) {
        st.clear();
        int n = source.size(),m =  pattern.size();
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                dp[i][j] = -1;
                vis[i][j] = false;
            }
        }
        for(auto i : targetIndices) st.insert(i);
        return solve(0,0,source,pattern);
    }
};",1420061145
rohith1902,rohith1902,467,3604,cpp,"#define ll long long
const ll mod = 1000000007;
ll binmultiply(ll a,ll b,ll m){ll res=0;while(b>0){if(b&1)res=(res+a)%m;a=(a+a)%m;b=b>>1;}return res;}
ll expo(ll a, ll b, ll m) {ll res = 1; while (b > 0) {if (b & 1)res = binmultiply(res,a,m)% m; a = binmultiply(a,a,m) % m; b = b >> 1;} return res;}
ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m

// vector<vector<long long>> comb;
ll comb[1005][1005];
void precomputeCombinations(int x) {

    memset(comb,0,sizeof(comb));

    for(int i=0;i<=x;i++) comb[i][0] = 1;
    for(int i=1;i<=x+1;i++){
        for(int j=1;j<=i;j++){
            comb[i][j] = mod_add(comb[i-1][j],comb[i-1][j-1],mod);
        }
    }
}

ll meow[1004];

void oo(int n){
    for(int i=0;i<1004;i++){
        meow[i] = expo(i,n,mod);
    }
}

long long f(int r, int n) {
    long long result = 0;
    for (int k = 0; k < r; k++) {
        // long long term = comb[r][k] * pow(r - k, n);
        ll term = mod_mul(comb[r][k],meow[r-k],mod);
        if (k % 2 == 1) {
            // result -= term; // Alternate the sign for odd k
            result = mod_sub(result,term,mod);

        } else {
            // result += term; // Add for even k
            result = mod_add(result,term,mod);
        }
    }
    return result;
}

   
class Solution {
public:
    vector<ll> power;
    int numberOfWays(int n, int x, int y) {
        precomputeCombinations(x+1);
        oo(n);
        
        power.resize(x+1,1);
        for(int i=1;i<=x;i++){
            power[i] = mod_mul(power[i-1],y,mod);
        }
        ll res = mod_mul(f(x,n),power[x],mod);
        for(int i=1;i<x;i++){
            ll op =  mod_mul(f(i,n),mod_mul(power[i],comb[x][i],mod),mod);
            cout << op << endl;
            res = mod_add(op,res,mod);
        }
        return res;
        
    }
};",1420124077
rohith1902,rohith1902,467,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n,-1);
        for(int i=0;i<n;i++){
            int num = nums[i];
            for(int j=0;j<=num;j++){
                if((j|(j+1)) == num){
                    res[i] = j;
                    break;
                }
            }
        }
        return res;
    }
};",1419995176
rohith1902,rohith1902,467,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, -1);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            if (num == 2) {
                res[i] = -1;
                continue;
            }
            for (int j = 1; j < 31; j++) {
                int c = (num & (1 << j));
                if (!c) {
                    int p = (1 << (j - 1));
                    p = ~p;
                    int ans = num & p;
                    res[i] = ans;
                    break;
                }
            }
        }
        return res;
    }
};",1420029769
cm_fast,cm_fast,468,3487,cpp,"class Solution
{
public:
    int helper(int idx, int m, string &p, int sz, unordered_map<int, bool> &ump, map<int, vector<int>> &mp, map<int, vector<int>> &mp2, int last, vector<vector<int>> &dp)
    {
        if (idx >= m)
        {
            // cout<<""done""<<endl;
            return 0;
        }
        int ans = 1e9;
        if (dp[idx][last + 1] != -1)
        {
            return dp[idx][last + 1];
        }
        int st2 = upper_bound(mp2[(int)(p[idx] - 'a')].begin(), mp2[(int)(p[idx] - 'a')].end(), last) - mp2[(int)(p[idx] - 'a')].begin();
        if (st2 < (int)mp2[(int)(p[idx] - 'a')].size())
        {
            ans = min(ans, 1 + helper(idx + 1, m, p, sz, ump, mp, mp2, mp2[(int)(p[idx] - 'a')][st2], dp));
        }
       
        if ((int)mp[(int)(p[idx] - 'a')].size())
        {
            int st = upper_bound(mp[(int)(p[idx] - 'a')].begin(), mp[(int)(p[idx] - 'a')].end(), last) - mp[(int)(p[idx] - 'a')].begin();
            if (st < (int)mp[(int)(p[idx] - 'a')].size())
            {
                ans = min(ans, helper(idx + 1, m, p, sz, ump, mp, mp2, mp[(int)(p[idx] - 'a')][st], dp));
            }
        }
        dp[idx][last + 1] = ans;
        return dp[idx][last + 1];
    }
    int maxRemovals(string s, string p, vector<int> &a)
    {
        int n = s.size();
        int m = p.size();
        int sz = a.size();
        map<int, vector<int>> mp;
        map<int, vector<int>> mp2;
        unordered_map<int, bool> ump;
        for (int i = 0; i < sz; i++)
        {
            ump[a[i]] = true;
        }
        for (int i = 0; i < n; i++)
        {
            if (!ump[i])
            {
                mp[(int)(s[i] - 'a')].push_back(i);
            }
            else
            {
                 mp2[(int)(s[i] - 'a')].push_back(i);
            }
           
        }
        vector<vector<int>> dp(m + 1, vector<int>(n + 2, -1));
        int ans = helper(0, m, p, sz, ump, mp, mp2, -1, dp);
        // cout<<ans<<endl;
        if (ans == 1e9)
        {
            return 0;
        }
        return sz - ans;
    }
};",1420097806
cm_fast,cm_fast,468,3604,cpp,"const int mod = 1e9 + 7;
const int N = 1e3 + 5;
long long add(long long x, long long y)
{
    x += y;
    while (x >= mod)
        x -= mod;
    while (x < 0)
        x += mod;
    return x;
}
long long mul(long long x, long long y)
{
    return (x * 1LL * y) % mod;
}

long long binpow(long long x, long long y)
{
    long long z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

long long inv(long long x)
{
    return binpow(x, (long long)mod - 2);
}

long long divide(long long x, long long y)
{
    return mul(x, inv(y));
}

int fact[N];
void precalc()
{
    fact[0] = 1;
    for (int i = 1; i < N; i++)
    {
        fact[i] = mul(fact[i - 1], i);
    }
}
long long C(long long n, long long k)
{
    // cout<<n<<"" ""<<n-k<<endl;
    return divide(fact[n], mul(fact[k], fact[n - k]));
}
class Solution
{
public:
    int numberOfWays(int n, int x, int y)
    {
        precalc();
        long long ans = 0;
        vector<vector<int>> nCR(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i)
        {
            nCR[i][0] = 1;
            for (int j = 1; j <= i; ++j)
            {
                nCR[i][j] = (nCR[i - 1][j - 1] + nCR[i - 1][j]) % mod;
            }
        }
        vector<vector<int>> combine(n + 1, vector<int>(x + 1, 0));
        combine[0][0] = 1;
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= x; ++j)
            {
                combine[i][j] = (1LL * j * combine[i - 1][j] + combine[i - 1][j - 1]) % mod;
            }
        }
        for (int k = 1; k <= x; ++k)
        {
            long long mult= 1;
            mult= binpow(y, k);
            if (n >= k)
            {
                long long temp1 = mul(C(x, k), C(n, k));
                long long temp2 = mul(temp1, fact[k]);
                ans = (ans + (1LL * nCR[x][k] * combine[n][k] % mod * fact[k] % mod * mult% mod)) % mod;
            }
        }
        return ans;
    }
};",1420125704
cm_fast,cm_fast,468,3605,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &a)
    {
        int n = a.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++)
        {
            if (a[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                long long  num = (long long )a[i];
                long long till = 0;
                for (int j = 0; j <= 30; j++)
                {
                    int val = (int)(powl(2, j));
                    if (((val) & (a[i])) > 0)
                    {
                        till += (long long )(val);
                    }
                    else
                    {
                        num = num - till;
                        num = num + ((till) / 2);
                        break;
                    }
                }
                ans[i] = (int)num;
            }
        }
        return ans;
    }
};",1420018104
cm_fast,cm_fast,468,3611,cpp,"class Solution
{
public:
    vector<int> minBitwiseArray(vector<int> &a)
    {
        int n = a.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++)
        {
            if (a[i] == 2)
            {
                ans[i] = -1;
            }
            else
            {
                long long  num = (long long )a[i];
                long long till = 0;
                for (int j = 0; j <= 30; j++)
                {
                    int val = (int)(powl(2, j));
                    if (((val) & (a[i])) > 0)
                    {
                        till += (long long )(val);
                    }
                    else
                    {
                        num = num - till;
                        num = num + ((till) / 2);
                        break;
                    }
                }
                ans[i] = (int)num;
            }
        }
        return ans;
    }
};",1420017728
Shubham Tayde,Loremlpsum01,469,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
}
};",1420094968
Shubham Tayde,Loremlpsum01,469,3604,cpp,"#include <vector>
using namespace std;

const int MOD = 1e9 + 7;

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};
",1420114116
Shubham Tayde,Loremlpsum01,469,3605,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        ios::sync_with_stdio(false);
        cin.tie(0);
        cout.tie(0);
         int n = nums.size();
    vector<int>ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        returnans;
}
};",1420097117
Shubham Tayde,Loremlpsum01,469,3611,cpp,"class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = std::numeric_limits<int>::max();
            bool found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        returnans;
}
};",1420055761
muralidharchodisetti,muralidharchodisetti,470,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}
",1420070236
muralidharchodisetti,muralidharchodisetti,470,3604,java,"class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        // Initialize combination array
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1; // C(i, 0) = 1
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        // Initialize Stirling numbers of the second kind
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1; // S(0, 0) = 1
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array initialization
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        // Calculate the result using the precomputed arrays
        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = power(y, k, MOD);
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    private long power(int base, int exp, int mod) {
        long result = 1;
        long b = base;
        while (exp > 0) {
            if ((exp & 1) == 1) { // If exp is odd
                result = (result * b) % mod;
            }
            b = (b * b) % mod; // Square the base
            exp >>= 1; // Divide exp by 2
        }
        return result;
    }
}
",1420114352
muralidharchodisetti,muralidharchodisetti,470,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        // Initialize the result array with -1
        int[] result = new int[nums.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = -1;
        }

        // Iterate over the indices of the input list
        for (int i = 0; i < nums.size(); i++) {
            // Iterate over possible values of ans[i]
            for (int j = 0; j <= nums.get(i); j++) {
                // Check if the condition is satisfied
                if ((j | (j + 1)) == nums.get(i)) {
                    // Update the result array with the minimum possible value
                    result[i] = j;
                    break; // Break once we find the minimum value
                }
            }
        }

        // Return the result array
        return result;
    }
}
",1420023155
muralidharchodisetti,muralidharchodisetti,470,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        n = len(nums)
        ans = [-1] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            # Iterate through each bit position (0 to 30)
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    # Unset the current bit
                    candidate = num & ~(1 << bit)
                    
                    # Ensure candidate is non-negative
                    if candidate < 0:
                        continue
                    
                    # Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
        
        return ans
",1420047063
PRAYAS MAZUMDER,captainprice27,471,3487,cpp,"class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;

public:
    MinStack() 
    {
        minStack.push(INT_MAX);
    }

    void push(int val) 
    {
        mainStack.push(val);
        minStack.push(min(val, minStack.top()));
    }

    void pop() 
    {
        mainStack.pop();
        minStack.pop();
    }

    int top() 
    { 
        return mainStack.top(); 
    }

    int getMin() 
    { 
        return minStack.top(); 
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        // Initialize dp array with ""infinity""
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // dp[0] means we have matched 0 characters of pattern


        map<string, int> mp;

    // Insert some values into the map
    mp[""one""] = 1;
    mp[""two""] = 2;
    mp[""three""] = 3;

    // Get an iterator pointing to the first element in the
    // map
    map<string, int>::iterator it = mp.begin();

    // Iterate through the map and print the elements
    while (it != mp.end()) {
       // cout << ""Key: "" << it->first << "", Value: "" << it->second << endl;
        ++it;
    }




        vector<bool> isTarget(n, false); // to track if an index is in targetIndices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        int thala = 7 ; 
        // Dynamic programming to calculate the minimum removals
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) 
                {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                    thala -= 1 ; 
                }
            }
        }

        // If dp[m] is still INT_MAX, that means it's not possible to match pattern
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420071156
PRAYAS MAZUMDER,captainprice27,471,3604,cpp,"#include <vector>
#include <cmath>
using namespace std;

const int MOD = 1e9 + 7;

#define ll long long

class YTree {
private:
    TreeNode* root;  // Pointer to the root node of the tree

public:
    // Constructor to initialize an empty tree
    YTree() : root(nullptr) {}

    // Public function to get the root node
    TreeNode* getRoot() {
        return root;
    }

    // Destructor to clean up the tree
    ~YTree() {
        clear(root);  // Calls the recursive helper function to delete nodes
    }

private:
    // Recursive function to clear the tree
    void clear(TreeNode* node) {
        if (node) {
            clear(node->left);
            clear(node->right);
            delete node;
        }
    }
};


class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;

public:
    MinStack() 
    {
        minStack.push(INT_MAX);
    }

    void push(int val) 
    {
        mainStack.push(val);
        minStack.push(min(val, minStack.top()));
    }

    void pop() 
    {
        mainStack.pop();
        minStack.pop();
    }

    int top() 
    { 
        return mainStack.top(); 
    }

    int getMin() 
    { 
        return minStack.top(); 
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */



class Solution {
public:
    int numberOfWays(long long n, long long x, long long y) {
        vector<long long> params = {n, x, y};
        
        // No-op loop for consistency
        while (!params.empty()) {
            break;
        }
        
        map<string, long long> mp;

    // Insert some values long longo the map
    mp[""one""] = 1;
    mp[""two""] = 2;
    mp[""three""] = 3;

    // Get an iterator polong longing to the first element in the
    // map
    map<string, long long>::iterator it = mp.begin();

    // Iterate through the map and prlong long the elements
    while (it != mp.end()) {
       // cout << ""Key: "" << it->first  << "", Value: "" << it->second << endl;
        ++it;
    }


    
        // Initialize combination array
        vector<vector<long long>> comb(x + 1, vector<long long>(x + 1, 0));
        for (long long i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (long long j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        
        // Redundant loop
        for (long long z = 0; z < x; ++z) {
            if (z > x) break; // This condition is redundant
        }
        
        // Initialize Stirling numbers of the second kind
        vector<vector<long long>> stirling(n + 1, vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (long long i = 1; i <= n; ++i) {
            for (long long j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        long long thala = 7 ; 
        
        // Factorial array initialization
        vector<long long> factorial(x + 1, 1);
        for (long long i = 1; i <= x; ++i) 
        {
            factorial[i] = factorial[i - 1] * i % MOD;
            thala -= 1 ; 
        }
        
        // More redundant code
        long long tempVar = 0;
        if (tempVar == 0) {
            tempVar = 1; // Redundant assignment
        }

        // Calculate the result using the precomputed arrays
        long long total_ways = 0;
        for (long long k = 1; k <= x; ++k) 
        {
            long long y_pow = powMod(y, k, MOD);  // Helper function to calculate modular exponentiation
            total_ways = (total_ways + (long long)comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD;
            thala += 1 ; 
        }

        return total_ways;
    }

private:
    // Helper function for modular exponentiation
    long long powMod(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (long long)result * base % mod;
            }
            base = (long long)base * base % mod;
            exp /= 2;
        }
        return result;
    }
};
",1420102160
PRAYAS MAZUMDER,captainprice27,471,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1); // Initialize result array with -1
        
        // Iterate over each number in nums
        for (int i = 0; i < nums.size(); ++i) {
            for (int x = 0; x <= nums[i]; ++x) { // Iterate through potential ans[i]
                if ((x | (x + 1)) == nums[i]) {   // Check if the condition is met
                    ans[i] = x;                  // Set ans[i] to the smallest x
                    break;                       // Break once the smallest value is found
                }
            }
        }
        
        return ans;
    }
};
",1419993890
PRAYAS MAZUMDER,captainprice27,471,3611,cpp,"class MinStack {
private:
    stack<int> mainStack;
    stack<int> minStack;

public:
    MinStack() 
    {
        minStack.push(INT_MAX);
    }

    void push(int val) 
    {
        mainStack.push(val);
        minStack.push(min(val, minStack.top()));
    }

    void pop() 
    {
        mainStack.pop();
        minStack.pop();
    }

    int top() 
    { 
        return mainStack.top(); 
    }

    int getMin() 
    { 
        return minStack.top(); 
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);


        map<string, int> mp;

    // Insert some values into the map
    mp[""one""] = 1;
    mp[""two""] = 2;
    mp[""three""] = 3;

    // Get an iterator pointing to the first element in the
    // map
    map<string, int>::iterator it = mp.begin();

    // Iterate through the map and print the elements
    while (it != mp.end()) {
       // cout << ""Key: "" << it->first << "", Value: "" << it->second << endl;
        ++it;
    }



        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            int thala = 7 ; 
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                            thala -= 2 ; 
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
                thala += 1 ; 
            } else {
                ans[i] = -1;
                thala += 2 ; 
            }
        }
        
        return ans;
    }
};
",1420052728
Ayush Kumar,ayushkuku18,472,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1]; // Dynamic programming array to track minimal removals
        boolean[] isTarget = new boolean[n]; // Boolean array to mark target indices

        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: no removals needed for an empty pattern

        // Mark the target indices
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            // Iterate backward through the pattern to maintain the dp state
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    // Update dp[j] considering whether the current character is a target
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // If it's possible to match the entire pattern, return the result, otherwise return 0
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420082860
Ayush Kumar,ayushkuku18,472,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize the combination (C) array using dynamic programming
        C = [[0] * (x + 1) for _ in range(x + 1)]
        
        # Fill the combination table
        for i in range(x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD

        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (x + 1) for _ in range(n + 1)]
        S[0][0] = 1

        # Fill the Stirling numbers table
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD

        # Initialize the factorial array
        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        # Main computation loop
        result = 0
        for k in range(1, x + 1):
            power = 1
            for p in range(k):
                power = (power * y) % MOD
            
            # Update result with final calculation using modular arithmetic
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result",1420121812
Ayush Kumar,ayushkuku18,472,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize the result array with -1
        
        for (int i = 0; i < nums.size(); ++i) {
            int num = nums[i];

            // Check for every candidate value for ans[i]
            for (int ans_candidate = 0; ans_candidate <= num; ++ans_candidate) {
                if ((ans_candidate | (ans_candidate + 1)) == num) {
                    ans[i] = ans_candidate;
                    break;  // We want the smallest value, so break on first match
                }
            }
        }
        return ans;
    }
};",1420020220
Ayush Kumar,ayushkuku18,472,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420055089
AYUSH SINGH,ayush9454,473,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420075569
AYUSH SINGH,ayush9454,473,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420096906
AYUSH SINGH,ayush9454,473,3605,cpp,"class Solution{
public:
vector<int>minBitwiseArray(vector<int>& nums){
    vector<int>ans;

    for(int num:nums){
        bool found=false;
        for(int i=0;i<=num;++i){
            if((i|(i+1))==num){
                ans.push_back(i);
                found=true;
                break;
            }
        }
        if(!found){
            ans.push_back(-1);
        }
    }
    return ans;
}
};
",1420021247
AYUSH SINGH,ayush9454,473,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420067931
Malepati_sucharitha,Malepati_sucharitha,474,3487,python,"class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        """"""
        :type source: str
        :type pattern: str
        :type targetIndices: List[int]
        :rtype: int
        """"""
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420098380
Malepati_sucharitha,Malepati_sucharitha,474,3604,python,"MOD = 10**9 + 7
class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways


",1420103544
Malepati_sucharitha,Malepati_sucharitha,474,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        
        for num in nums:
            found = False
            for candidate in range(num):
                if candidate | (candidate + 1) == num:
                    ans.append(candidate)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans
",1420018784
Malepati_sucharitha,Malepati_sucharitha,474,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}

",1420077970
expensiveshit,maheshwari_18,475,3487,java,"class Solution {
    public int maxRemovals(String mahi_source, String mahi_pattern, int[] mahi_targetIndices) {
        int mahi_n = mahi_source.length();
        int mahi_m = mahi_pattern.length();
        int[] mahi_dp = new int[mahi_m + 1];
        for (int i = 0; i <= mahi_m; i++) {
            mahi_dp[i] = Integer.MAX_VALUE;
        }
        mahi_dp[0] = 0;
        boolean[] mahi_isTarget = new boolean[mahi_n];
        
        for (int mahi_idx : mahi_targetIndices) {
            mahi_isTarget[mahi_idx] = true;
        }

        for (int mahi_i = 0; mahi_i < mahi_n; mahi_i++) {
            for (int mahi_j = mahi_m; mahi_j > 0; mahi_j--) {
                if (mahi_source.charAt(mahi_i) == mahi_pattern.charAt(mahi_j - 1) && mahi_dp[mahi_j - 1] != Integer.MAX_VALUE) {
                    mahi_dp[mahi_j] = Math.min(mahi_dp[mahi_j], mahi_dp[mahi_j - 1] + (mahi_isTarget[mahi_i] ? 1 : 0));
                }
            }
        }

        return mahi_targetIndices.length - (mahi_dp[mahi_m] == Integer.MAX_VALUE ? 0 : mahi_dp[mahi_m]);
    }
}
",1420073105
expensiveshit,maheshwari_18,475,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, mahi_n: int, mahi_x: int, mahi_y: int) -> int:
        # Initialize the combination (C) array
        C = [[0] * (mahi_x + 1) for _ in range(mahi_x + 1)]
        for i in range(mahi_x + 1):
            C[i][0] = 1
            for j in range(1, i + 1):
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD
        
        # Initialize the Stirling numbers of the second kind (S) array
        S = [[0] * (mahi_x + 1) for _ in range(mahi_n + 1)]
        S[0][0] = 1
        for i in range(1, mahi_n + 1):
            for j in range(1, mahi_x + 1):
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
        
        # Factorial array
        fact = [1] * (mahi_x + 1)
        for i in range(1, mahi_x + 1):
            fact[i] = fact[i - 1] * i % MOD
        
        result = 0
        # Main computation loop
        for k in range(1, mahi_x + 1):
            power = pow(mahi_y, k, MOD)
            result = (result + C[mahi_x][k] * S[mahi_n][k] % MOD * fact[k] % MOD * power % MOD) % MOD
        
        return result


",1420083841
expensiveshit,maheshwari_18,475,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int[] mahiAns = new int[nums.size()];

        for (int i = 0; i < nums.size(); i++) {
            int mahiNum = nums.get(i);
            boolean found = false;

            for (int mahiX = 0; mahiX < mahiNum; mahiX++) {
                if ((mahiX | (mahiX + 1)) == mahiNum) {
                    mahiAns[i] = mahiX;
                    found = true;
                    break;
                }
            }

            if (!found) {
                mahiAns[i] = -1;
            }
        }
        return mahiAns;
    }
}
",1420003918
expensiveshit,maheshwari_18,475,3611,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    private int getAns(int mahi) {
        int j = 0;
        for (int i = 0; i < 32; i++) {
            if ((mahi & (1 << i)) != 0) {
                j = i;
            } else {
                break;
            }
        }
        return mahi - (1 << j);
    }

    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            if (nums.get(i) != 2) {
                res[i] = getAns(nums.get(i));
            } else {
                res[i] = -1; // Setting the value to -1 for cases where nums[i] == 2
            }
        }
        return res;
    }
}
",1420070948
23f3002071,23f3002071,476,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        boolean[] isTarget = new boolean[n];
        
        // Initialize dp array
        for (int i = 0; i < m + 1; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0; // Base case: empty pattern
        
        // Mark target indices
        for (int idx : targetIndices) { 
            isTarget[idx] = true;
        }
        
        // Iterate through the source
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        // Calculate maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
        
    }
}",1420105056
23f3002071,23f3002071,476,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420124310
23f3002071,23f3002071,476,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        
        // Iterate over each prime number in the nums array
        for (int num : nums) {
            bool found = false;
            
            // Try different values of x starting from 0
            for (int x = 0; x <= num; ++x) {
                if ((x | (x + 1)) == num) {
                    ans.push_back(x);
                    found = true;
                    break;
                }
            }
            
            // If no valid x was found, push -1
            if (!found) {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};
",1419996848
23f3002071,23f3002071,476,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int min = Integer.MAX_VALUE;
            boolean found = false ;
            
            for(int bit = 0; bit<=30;bit++){
                if(((num>>bit)&1)==1){
                    int cand = num & ~(1 <<bit);
                    if (cand<0) continue ;
                    if((cand | (cand+1))==num){
                        if(cand<min){ 
                        min = cand ;
                        found=true;
                        }
                    }
                }
            }
      
            res[i]=found? min:-1;
        }
        return res ;
    }
}
",1420080781
Krishna Sharma,krishnash1355,477,3487,cpp,"class Solution {
public:
    vector<vector<int>> dp;
    
    int fn(int x, int y, string &s, string &pattern, vector<int> &pref, vector<int> &canbe) {
        if (y == pattern.size()) return pref[x];
        if (x == s.size()) return -1e8;
        
        if (dp[x][y] != -1e9) return dp[x][y];
        
        int ans = -1e8;
        if (s[x] == pattern[y]) 
            ans = max(ans, fn(x + 1, y + 1, s, pattern, pref, canbe));
        if (canbe[x]) 
            ans = max(ans, 1 + fn(x + 1, y, s, pattern, pref, canbe));
        else 
            ans = max(ans, fn(x + 1, y, s, pattern, pref, canbe));
        
        return dp[x][y] = ans;
    }

    int maxRemovals(string &s, string &pattern, vector<int>& targetIndices) {
        int n = s.size(), m = pattern.size();
        dp.assign(n + 1, vector<int>(m + 1, -1e9));
        vector<int> canbe(n, 0);
        for (auto i : targetIndices) 
            canbe[i] = 1;
        vector<int> pref(n + 1, 0);
        pref[n - 1] = canbe[n - 1];
        for (int i = n - 2; i >= 0; i--) 
            pref[i] = pref[i + 1] + canbe[i];
        int result = fn(0, 0, s, pattern, pref, canbe);
        
        return result < 0 ? 0 : result;
    }
};
",1420084400
Krishna Sharma,krishnash1355,477,3604,cpp,"const int N = 1e3 + 8;
const int mod = 1e9 + 7;
long long fact[N + 1];
long long modinv[N + 1];

long long ncr(long long n, long long r) {
    if (n < 0 || r < 0 || r > n) return 0;
    long long num = fact[n];
    long long ans = (((num * modinv[r]) % mod) * modinv[n - r]) % mod;
    return ans;
}

long long binexp(long long base, long long x) {
    if (x < 0) return 0;
    long long ans = 1;
    while (x) {
        if (x % 2 == 0) {
            base = (base * base) % mod;
            x /= 2;
        }
        else {
            ans = (ans * base) % mod;
            x--;
        }
    }
    return ans;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        modinv[0] = 1;
        for (int i = 1; i <= N; i++) {
            fact[i] = (1ll * i * fact[i - 1]) % mod;
            modinv[i] = (binexp(fact[i], mod - 2)) % mod;
        }
        vector<vector<long long>> final(x + 1, vector<long long>(x + 1));
        vector<vector<long long>> semi(n + 1, vector<long long>(x + 1));
        semi[0][0] = 1;
        for (int i = 0; i <= x; i++) {
            final[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                final[i][j] = final[i - 1][j - 1] + final[i - 1][j];
                final[i][j] %= mod;
            }
        }
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= x; j++)
                (semi[i][j] = 1ll * j * semi[i - 1][j] + semi[i - 1][j - 1]) %= mod;
        long long ans = 0;
        for (int i = 1; i <= x; i++) (ans += ((1ll * final[x][i] * semi[n][i]) % mod) * ((fact[i] * binexp(y, i)) % mod)) %= mod;
        return ans;
    }
};",1420111787
Krishna Sharma,krishnash1355,477,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto i : nums)
            if (i % 2 == 0) ans.push_back(-1);
            else {
                int index = -1;
                for (int j = 0; j < 31; j++)
                    if (((1 << j)&i)) index = j;
                    else break;
                long long num = 0;
                for (int k = 0; k < 31; k++)
                    if (k == index) continue;
                    else if ((1 << k)&i) num += (1 << k);
                ans.push_back(num);
            }
        return ans;
    }
};",1420022778
Krishna Sharma,krishnash1355,477,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto i : nums)
            if (i % 2 == 0) ans.push_back(-1);
            else {
                int index = -1;
                for (int j = 0; j < 31; j++)
                    if (((1 << j)&i)) index = j;
                    else break;
                long long num = 0;
                for (int k = 0; k < 31; k++)
                    if (k == index) continue;
                    else if ((1 << k)&i) num += (1 << k);
                ans.push_back(num);
            }
        return ans;
    }
};",1420022059
Ujjawal Pandey,UnluckyGuy__0001,478,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420069948
Ujjawal Pandey,UnluckyGuy__0001,478,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {        
        vector<vector<int>> combo(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combo[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combo[i][j] = (combo[i - 1][j - 1] + combo[i - 1][j]) % MOD;
            }
        } 

        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }

        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * combo[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }

        return total_ways;
    }
};",1420107128
Ujjawal Pandey,UnluckyGuy__0001,478,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& primes) {
        vector<int> result(primes.size(), -1);
        for (int i = 0; i < primes.size(); ++i) {
            for (int candidate = 0; candidate <= primes[i]; ++candidate) {
                if ((candidate | (candidate + 1)) == primes[i]) {
                    result[i] = candidate;
                    break;
                }
            }
        }
        return result;
    }
};
",1419995936
Ujjawal Pandey,UnluckyGuy__0001,478,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int mini = INT_MAX;
            bool found = false;
            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int temp = num & ~(1 << bit);
                    
                    if (temp >= 0 && (temp | (temp + 1)) == num) {
                        if (temp < mini) {
                            mini = temp;
                            found = true;
                        }
                    }
                }
            }
            
            ans[i] = found ? mini : -1;
        }
        
        return ans;
    }
};",1420058536
user8915nG,user8915nG,479,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};",1420113214
user8915nG,user8915nG,479,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};
",1420114070
user8915nG,user8915nG,479,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n,-1);
        for(int i=0; i<n; i++)
        {
            for(int x=0; x<=nums[i]; x++)
            {
                if((x | (x+1)) == nums[i])
                {
                    ans[i] = x;
                    break;
                }
            }
        }
        return ans;
    }
};",1420034925
user8915nG,user8915nG,479,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 0);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for (int bit = 0; bit < 31; bit++) {
                if ((num >> bit) & 1) { // If the bit is set
                    int candidate = num & ~(1 << bit); // Clear the bit
                    if (candidate < 0) {
                        continue;
                    }
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};
",1420110891
Vasu Bajaj,VasuBajaj28,480,3487,cpp,"class Solution {
public:
    int dfs(int i, int j, string &source, string &pattern, vector<bool> &isTarget, vector<vector<int>> &dp) {
        if (j == pattern.size()) return 0;
        if (i == source.size()) return INT_MAX;
        if (dp[i][j] != -1) return dp[i][j];
        int res = dfs(i + 1, j, source, pattern, isTarget, dp);
        if (source[i] == pattern[j]) {
            int cost = dfs(i + 1, j + 1, source, pattern, isTarget, dp);
            if (cost != INT_MAX) {
                cost += (isTarget[i] ? 1 : 0); 
            }
            res = std::min(res, cost);
        }

        return dp[i][j] = res; 
    }

    int maxRemovals(string s, string p, vector<int>& t) {
        int n = s.size();
        int m = p.size();    
       vector<bool> isTarget(n, false);
        for (int idx : t) {
            isTarget[idx] = true;
        }
        vector<vector<int>> dp(n, vector<int>(m, -1));
        int result = dfs(0, 0, s, p, isTarget, dp);
        return t.size() - (result == INT_MAX ? 0 : result);
    }
};",1420105445
Vasu Bajaj,VasuBajaj28,480,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;

    vector<vector<long long>> compute(long long x) {
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        for (long long i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (long long j = 1; j <= i; j++) {
                long long a = C[i - 1][j - 1];
                long long b = C[i - 1][j];
                C[i][j] = (a + b) % MOD;
            }
        }
        return C;
    }

    vector<vector<long long>> Stirling(long long n, long long x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (long long i = 1; i <= n; i++) {
            for (long long j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j]%MOD + S[i - 1][j - 1]%MOD) % MOD;
            }
        }
        return S;
    }

    vector<long long> Factorials(long long x) {
        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    long long modPower(long long base, int exp, int mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> C = compute(x);
        vector<vector<long long>> S = Stirling(n, x);
        vector<long long> fact = Factorials(x);

        long long result = 0;
        for (int k = 1; k <= x; k++) {
            long long power = modPower(y, k, MOD);
            long long c = C[x][k];
            long long s = S[n][k];
            long long f = fact[k];
            result = (result + c * s % MOD * f % MOD * power % MOD) % MOD;
        }
        return result;
    }
};
",1420120562
Vasu Bajaj,VasuBajaj28,480,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,0);
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0){
                ans[i]=-1;
            }
            else{
                int j=1;
                while((nums[i]&(1<<j))!=0){
                    j++;
                }
                j--;
                ans[i] = (nums[i] ^ (1 << (j)));
            }
        }
        return ans;
    }
};",1420034722
Vasu Bajaj,VasuBajaj28,480,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,0);
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0){
                ans[i]=-1;
            }
            else{
                int j=1;
                while((nums[i]&(1<<j))!=0){
                    j++;
                }
                j--;
                ans[i] = (nums[i] ^ (1 << (j)));
            }
        }
        return ans;
    }
};",1420035020
BharathMohanraj,BharathMohanraj,481,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& removableIndices) {
        int sourceLength = source.length();
        int patternLength = pattern.length();

        // dp[j] stores the minimum cost to match the first j characters of the pattern
        vector<float> minCostToMatch(patternLength + 1, float('inf'));
        minCostToMatch[0] = 0;  // Matching an empty pattern requires 0 cost

        // isRemovable[i] indicates if the character at index i in source can be removed
        vector<bool> isRemovable(sourceLength, false);

        // Mark removable indices as true
        for (int index : removableIndices) {
            isRemovable[index] = true;
        }

        // Traverse the source string
        for (int i = 0; i < sourceLength; ++i) {
            // Traverse the pattern backwards to avoid overwriting dp values prematurely
            for (int j = patternLength; j > 0; --j) {
                // If the characters match and the previous state is valid (not 'inf')
                if (source[i] == pattern[j - 1] && minCostToMatch[j - 1] != float('inf')) {
                    minCostToMatch[j] = min(
                        minCostToMatch[j], 
                        minCostToMatch[j - 1] + (isRemovable[i] ? 1 : 0)
                    );
                }
            }
        }

        // If matching the entire pattern is impossible, return 0
        return removableIndices.size() - (minCostToMatch[patternLength] == float('inf') ? 0 : minCostToMatch[patternLength]);
    }
};
",1420095255
BharathMohanraj,BharathMohanraj,481,3604,java,"import java.util.List;

public class Solution {
    private static final int MODULO = 1000000007;

    public int numberOfWays(int totalItems, int maxGroups, int groupSize) {
        // Create an array to store combinations (C)
        long[][] combinations = new long[maxGroups + 1][maxGroups + 1];
        for (int i = 0; i <= maxGroups; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MODULO;
            }
        }

        // Create an array to store Stirling numbers of the second kind (S)
        long[][] stirlingNumbers = new long[totalItems + 1][maxGroups + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalItems; i++) {
            for (int j = 1; j <= maxGroups; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MODULO;
            }
        }

        // Create a factorial array
        long[] factorial = new long[maxGroups + 1];
        factorial[0] = 1;
        for (int i = 1; i <= maxGroups; i++) {
            factorial[i] = factorial[i - 1] * i % MODULO;
        }

        long totalWays = 0;
        // Main computation loop
        for (int groups = 1; groups <= maxGroups; groups++) {
            // Calculate groupSize^groups using modular exponentiation
            long groupSizePower = 1;
            for (int p = 0; p < groups; p++) {
                groupSizePower = (groupSizePower * groupSize) % MODULO;
            }
            totalWays = (totalWays + combinations[maxGroups][groups] * stirlingNumbers[totalItems][groups] % MODULO * factorial[groups] % MODULO * groupSizePower % MODULO) % MODULO;
        }

        return (int) totalWays;
    }
}
",1420115810
BharathMohanraj,BharathMohanraj,481,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(),-1);

        for(int i=0;i<nums.size();i++){
            int num=nums[i];
            for(int j=0;j<num;++j){
                if((j|(j+1))==num){
                    ans[i]=j;
                    break;
                }
            }
        }
        return ans;
    }
};
",1420113266
BharathMohanraj,BharathMohanraj,481,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);

                    if (candidate < 0) continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};",1420094031
praveen challa,Arjunkrishna1234,482,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420116533
praveen challa,Arjunkrishna1234,482,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420116015
praveen challa,Arjunkrishna1234,482,3605,python,"class Solution:
    def minBitwiseArray(self, nums):
        ans = []
        
        for num in nums:
            found = False
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans",1420080124
praveen challa,Arjunkrishna1234,482,3611,cpp,"class Solution {
public:
    int countTrailingOnes(int p) {
        int count = 0;
        while (p & 1) {
            count++;
            p >>= 1;
        }
        return count;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            if (p == 2 || (p & 1) == 0) {
                ans.push_back(-1);
                continue;
            }
            int t = countTrailingOnes(p);
            int x = p - (1 << (t - 1));
            if (x >= 0 && (x | (x + 1)) == p) {
                ans.push_back(x);
            } else {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420088660
Anupam Shakya,callmeanupam,483,3487,typescript,"function maxRemovals(source: string, pattern: string, targetIndices: number[]): number {
    const n = source.length;
    const m = pattern.length;
    const dp: number[] = Array.from({ length: m + 1 }, () => Infinity);
    dp[0] = 0;
    const isTarget: boolean[] = Array.from({ length: n }, () => false);

    
    targetIndices.forEach(idx => {
    isTarget[idx] = true;
});

    for (let i = 0; i < n; i++) {
    for (let j = m - 1; j >= 0; j--) {
        const isMatch = source[i] === pattern[j] && dp[j] !== Infinity;
        if (isMatch) {
            const increment = isTarget[i] ? 1 : 0;
            dp[j + 1] = Math.min(dp[j + 1], dp[j] + increment);
        }
    }
}
    return targetIndices.length - (dp[m] === Infinity ? 0 : dp[m]);
}",1420059824
Anupam Shakya,callmeanupam,483,3604,cpp,"class Solution {
public:
    const int MOD_VALUE = 1e9 + 7;

    int mdExp(int base, int exp, int mod) {
        int result = 1;
        base %= mod;

        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (1LL * result * base) % mod;
            }
            exp /= 2;
            base = (1LL * base * base) % mod;
        }

        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));
        
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                int left = comb[i - 1][j - 1];
                int right = comb[i - 1][j];
                comb[i][j] = (left + right) % MOD_VALUE;
            }
        }

        vector<vector<int>> strln(n + 1, vector<int>(x + 1, 0));
        strln[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                int pvl = strln[i - 1][j];
                int pmOne = strln[i - 1][j - 1];
                strln[i][j] = (1LL * j * pvl + pmOne) % MOD_VALUE;
            }
        }

        vector<int> fcvt(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fcvt[i] = (1LL * fcvt[i - 1] * i) % MOD_VALUE;
        }

        int rst = 0;

        for (int k = 1; k <= x; k++) {
            int yPow = mdExp(y, k, MOD_VALUE);
            int cmb = comb[x][k];
            int strVl = strln[n][k];
            int fvl = fcvt[k];

            rst = (rst + 1LL * cmb * strVl % MOD_VALUE * fvl % MOD_VALUE * yPow % MOD_VALUE) % MOD_VALUE;
        }
        
        return rst;
    }
};",1420104115
Anupam Shakya,callmeanupam,483,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> rs;
    rs.reserve(nums.size()); 

    for (int nm : nums) {
        int spVl = -1; 
        for (int x = 0; x <= nm; ++x) {
            if ((x | (x + 1)) == nm) {
                spVl = x;
                break;
            }
        }
        rs.push_back(spVl);
    }
    return rs;
    }
};
",1419994239
Anupam Shakya,callmeanupam,483,3611,golang,"package main

import (
	""fmt""
	""math""
)

func minBitwiseArray(nums []int) []int {
	n := len(nums)
	asw := make([]int, n)

	for i := 0; i < n; i++ {
		nmm := nums[i]
		mnAs := math.MaxInt32
		found := false

		for bit := 0; bit <= 30; bit++ {
			if (nmm>>bit)&1 == 1 {
				cdte := nmm &^ (1 << bit)

				if cdte >= 0 && (cdte|(cdte+1)) == nmm {
					if cdte < mnAs {
						mnAs = cdte
						found = true
					}
				}
			}
		}

            asw[i] = -1
            if found {
                asw[i] = mnAs
            }
	}
	return asw
}",1420048550
Ash,Yash235K,484,3487,python3,"class Solution:
    def maxRemovals(self, s: str, p: str, indices: List[int]) -> int:
        len_s, len_p = len(s), len(p)
        dp = [float('inf')] * (len_p + 1)
        dp[0] = 0
        targets = [False] * len_s
        
        for i in indices:
            targets[i] = True
            
        for i in range(len_s):
            for j in range(len_p, 0, -1):
                if s[i] == p[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if targets[i] else 0))
        
        return len(indices) - (0 if dp[len_p] == float('inf') else dp[len_p])
",1420070036
Ash,Yash235K,484,3604,csharp,"public class Solution {
    private const int MOD = 1000000007;

    public int NumberOfWays(int n, int x, int y) {
        int[,] C = new int[x + 1, x + 1];
        for (int i = 0; i <= x; i++) {
            C[i, 0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i, j] = (C[i - 1, j - 1] + C[i - 1, j]) % MOD;
            }
        }

        int[,] S = new int[n + 1, x + 1];
        S[0, 0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i, j] = (int)((j * (long)S[i - 1, j] + S[i - 1, j - 1]) % MOD);
            }
        }

        int[] fact = new int[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = (int)((long)fact[i - 1] * i % MOD);
        }

        int result = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (int)((result + (long)C[x, k] * S[n, k] % MOD * fact[k] % MOD * power % MOD) % MOD);
        }

        return result;
    }
}
",1420118618
Ash,Yash235K,484,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = False
            for i in range(num):
                if i | (i + 1) == num:
                    ans.append(i)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans",1420006799
Ash,Yash235K,484,3611,ruby,"def min_bitwise_array(nums)
  n = nums.size
  ans = Array.new(n)
  (0...n).each do |i|
    num = nums[i]
    minimal_ans = Float::INFINITY
    found = false
    (0..30).each do |bit|
      if (num >> bit) & 1 == 1
        candidate = num & ~(1 << bit)

        next if candidate < 0

        if (candidate | (candidate + 1)) == num
          if candidate < minimal_ans
            minimal_ans = candidate
            found = true
          end
        end
      end
    end

    if found
      ans[i] = minimal_ans
    else
      ans[i] = -1
    end
  end

  ans
end
",1420102865
assassino,galaxyguy,485,3487,javascript,"var maxRemovals = function(source, pattern, targetIndices) {
    const n = source.length;  // Length of source
    const m = pattern.length;  // Length of pattern

    // Initialize the dp array
    const dp = new Array(m + 1).fill(Infinity);
    dp[0] = 0;  // Base case

    // Create an array to mark target indices
    const isTarget = new Array(n).fill(false);
    for (const idx of targetIndices) {
        isTarget[idx] = true;
    }

    // Dynamic Programming to calculate minimum removals
    for (let i = 0; i < n; i++) {
        for (let j = m; j > 0; j--) {
            if (source[i] === pattern[j - 1] && dp[j - 1] !== Infinity) {
                dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
        }
    }

    // Calculate the result
    return targetIndices.length - (dp[m] === Infinity ? 0 : dp[m]);
};",1420062781
assassino,galaxyguy,485,3604,python3,"class Solution:
    MOD = 10**9 + 7

    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize parameters
        params = [n, x, y]
        
        # Precompute binomial coefficients (fun)
        fun = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            fun[i][0] = 1
            for j in range(1, i + 1):
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % self.MOD
        
        # Precompute Stirling numbers (stirling)
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % self.MOD
        
        # Precompute factorials (mathFact)
        mathFact = [1] * (x + 1)
        for i in range(1, x + 1):
            mathFact[i] = mathFact[i - 1] * i % self.MOD
        
        # Calculate total ways
        totalWays = 0
        for k in range(1, x + 1):
            power = pow(y, k, self.MOD)
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % self.MOD * mathFact[k] % self.MOD * power % self.MOD) % self.MOD
        
        return totalWays
",1420113300
assassino,galaxyguy,485,3605,cpp,"#include <vector>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        std::vector<int> ans(nums.size(), -1);  // Initialize the answer array with -1

        for (size_t i = 0; i < nums.size(); ++i) {
            int x = nums[i];

            // Iterate to find the smallest ans[i] such that ans[i] OR (ans[i] + 1) = x
            for (int a = 0; a < x; ++a) {
                if ((a | (a + 1)) == x) {
                    ans[i] = a; // Store the value
                    break; // Found the minimum, break the loop
                }
            }
        }

        return ans; // Return the constructed array
    }
};
",1419996136
assassino,galaxyguy,485,3611,javascript,"/**
 * @param {number[]} nums
 * @return {number[]}
 */
var minBitwiseArray = function(nums) {
            const n = nums.length;
        const ans = new Array(n);

        for (let i = 0; i < n; i++) {
            const num = nums[i];
            let minimalAns = Number.MAX_SAFE_INTEGER; // Use MAX_SAFE_INTEGER instead of Integer.MAX_VALUE
            let found = false;

            // Iterate through each bit position (0 to 30)
            for (let bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) === 1) {
                    // Unset the current bit
                    const candidate = num & ~(1 << bit);

                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) === num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    };",1420045216
vishnu penthala,vishnu_065,486,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
",1420073297
vishnu penthala,vishnu_065,486,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)  # Calculate y^k % MOD
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways
",1420096826
vishnu penthala,vishnu_065,486,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;

            // Check for the smallest ans[i] such that ans[i] OR (ans[i] + 1) == nums[i]
            for (int x = 0; x < num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }

            // If no such value was found, set ans[i] to -1
            if (!found) {
                ans[i] = -1;
            }
        }

        return ans;
    }
}
",1420020113
vishnu penthala,vishnu_065,486,3611,cpp,"class Solution { 
public: 
    vector<int> minBitwiseArray(vector<int>& nums) { 
        int n = nums.size(); 
        vector<int> ans(n); 
         
        for (int i = 0; i < n; i++) { 
            int num = nums[i]; 
            int minimalAns = INT_MAX; 
            bool found = false; 
             
            
            for (int bit = 0; bit <= 30; bit++) { 
                if ((num >> bit) & 1) { 
                   
                    int candidate = num & ~(1 << bit); 
                     
                   
                    if (candidate < 0) continue; 
                     
                    
                    if ((candidate | (candidate + 1)) == num) { 
                        if (candidate < minimalAns) { 
                            minimalAns = candidate; 
                            found = true; 
                        } 
                    } 
                } 
            } 
             
            if (found) { 
                ans[i] = minimalAns; 
            } else { 
                ans[i] = -1; 
            } 
        } 
         
        return ans; 
    } 
};",1420079598
Ganesh Korada,GANESH572004,487,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420116642
Ganesh Korada,GANESH572004,487,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420116019
Ganesh Korada,GANESH572004,487,3605,python,"class Solution:
    def minBitwiseArray(self, nums):
        ans = []
        
        for num in nums:
            found = False
            # Try all values from 0 up to num-1
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        
        return ans

nums1 = [2, 3, 5, 7]
nums2 = [11, 13, 31]

solution = Solution()

print(solution.minBitwiseArray(nums1))  # Output: [-1, 1, 4, 3]
print(solution.minBitwiseArray(nums2))  # Output: [9, 12, 15]",1420073515
Ganesh Korada,GANESH572004,487,3611,cpp,"class Solution {
public:
    int countTrailingOnes(int p) {
        int count = 0;
        while (p & 1) {
            count++;
            p >>= 1;
        }
        return count;
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (int p : nums) {
            if (p == 2 || (p & 1) == 0) {
                ans.push_back(-1);
                continue;
            }
            int t = countTrailingOnes(p);
            int x = p - (1 << (t - 1));
            if (x >= 0 && (x | (x + 1)) == p) {
                ans.push_back(x);
            } else {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420088680
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string source, std::string pattern, std::vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        std::vector<int> dp(m + 1, INT_MAX);
        std::vector<bool> isTarget(n, false);

        dp[0] = 0;

        // Mark target indices as true in the isTarget array
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Iterate through the source string
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        int maxRemovals = (dp[m] == INT_MAX) ? 0 : dp[m];
        return targetIndices.size() - maxRemovals;
    }
};
",1420119507
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); 
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); 
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); 
    }
}",1420123543
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums){
            bool found=false;
            for(int i=0; i<=num; ++i){
                if((i | (i+1)) == num){
                    ans.push_back(i);
                    found = true;
                    break;
                }
            }
            if(!found){
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420030281
Aniket Vijay Amte,Aniket_Vijay_Amte,488,3611,cpp,"#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns = std::numeric_limits<int>::max();
            bool found = false;
            
            // Iterate through the bits
            for (int bit = 0; bit < 31; ++bit) {
                // Check if the bit is set in 'num'
                if ((num >> bit) & 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate < 0) continue;
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            ans[i] = found ? minimalAns : -1;
        }
        return ans;
    }
};
",1420096605
Sonali Priya,kimu1521,489,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();
        vector<float> dp(m + 1, float('inf'));
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != float('inf')) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == float('inf') ? 0 : dp[m]);
    }
};",1420080177
Sonali Priya,kimu1521,489,3604,java,"import java.util.List;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        // Create an array to store the combination (C)
        long[][] C = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        // Create an array to store the Stirling numbers of the second kind (S)
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        // Create a factorial array
        long[] fact = new long[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long result = 0;
        // Main computation loop
        for (int k = 1; k <= x; k++) {
            // Calculate y^k using modular exponentiation
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return (int) result;
    }
}
",1420111813
Sonali Priya,kimu1521,489,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int prime = nums.get(i);
            ans[i] = -1; // Default value if no solution is found
            
            // To find the minimum ans[i], we will check from 0 to prime
            for (int j = 0; j < prime; j++) {
                if ((j | (j + 1)) == prime) {
                    ans[i] = j; // Found the minimum ans[i]
                    break; // Exit the loop as we found a solution
                }
            }
        }
        
        return ans;
    }
}",1420033562
Sonali Priya,kimu1521,489,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;

            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);

                    if (candidate < 0) continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};",1420079134
harshhhcore,harshhhcore,490,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420062081
harshhhcore,harshhhcore,490,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, num_items: int, max_groups: int, group_factor: int) -> int:
        parameters = [num_items, max_groups, group_factor]
        
        combinations = [[0] * (max_groups + 1) for _ in range(max_groups + 1)]
        for i in range(max_groups + 1):
            combinations[i][0] = 1
            for j in range(1, i + 1):
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD
        
        stirling_numbers = [[0] * (max_groups + 1) for _ in range(num_items + 1)]
        stirling_numbers[0][0] = 1
        for i in range(1, num_items + 1):
            for j in range(1, max_groups + 1):
                stirling_numbers[i][j] = (j * stirling_numbers[i - 1][j] + stirling_numbers[i - 1][j - 1]) % MOD
        
        factorial_values = [1] * (max_groups + 1)
        for i in range(1, max_groups + 1):
            factorial_values[i] = factorial_values[i - 1] * i % MOD
        
        total_ways = 0
        for current_group_count in range(1, max_groups + 1):
            current_power = 1
            for p in range(current_group_count):
                current_power = (current_power * group_factor) % MOD
            
            total_ways = (total_ways + 
                          combinations[max_groups][current_group_count] * 
                          stirling_numbers[num_items][current_group_count] % MOD * 
                          factorial_values[current_group_count] % MOD * 
                          current_power % MOD) % MOD
        
        return total_ways
",1420110563
harshhhcore,harshhhcore,490,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420006137
harshhhcore,harshhhcore,490,3611,cpp,"#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = std::numeric_limits<int>::max();
            bool found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420047660
callmesen,callmesen,491,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        unordered_set<int> targetSet(targetIndices.begin(), targetIndices.end());

        vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX / 2));
        for (int j = 0; j <= n; ++j) dp[0][j] = 0;

        for (int i = 1; i <= m; ++i) {
            int minOverlap = INT_MAX / 2;
            for (int j = 1; j <= n; ++j) {
                if (pattern[i - 1] == source[j - 1]) {
                    int cost = targetSet.count(j - 1) ? 1 : 0;
                    dp[i][j] = min(dp[i - 1][j - 1] + cost, dp[i][j - 1]);
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
                minOverlap = min(minOverlap, dp[i][j]);
            }
            if (minOverlap >= INT_MAX / 2) return 0;
        }

        int min_overlap = dp[m][n];
        return targetIndices.size() - min_overlap;
    }
};
",1420087349
callmesen,callmesen,491,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    typedef long long ll;

    ll modPow(ll base, ll exp) {
        ll result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1)
                result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        vector<ll> fact(x + 1, 1), invFact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = fact[i - 1] * i % mod;
        }
        invFact[x] = modPow(fact[x], mod - 2);
        for (int i = x - 1; i >= 0; --i) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod;
        }

        vector<ll> C_x_k(x + 1);
        for (int k = 0; k <= x; ++k) {
            C_x_k[k] = fact[x] * invFact[k] % mod * invFact[x - k] % mod;
        }

        vector<ll> y_pow_k(x + 1, 1);
        for (int k = 1; k <= x; ++k) {
            y_pow_k[k] = y_pow_k[k - 1] * y % mod;
        }

        vector<ll> j_pow_n(x + 1, 0);
        for (int j = 0; j <= x; ++j) {
            j_pow_n[j] = modPow(j, n);
        }

        ll total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            ll s = 0;
            for (int j = 0; j <= k; ++j) {
                ll sign = ((k - j) % 2 == 0) ? 1 : mod - 1;
                ll C_k_j = fact[k] * invFact[j] % mod * invFact[k - j] % mod;
                ll term = sign * C_k_j % mod * j_pow_n[j] % mod;
                s = (s + term) % mod;
            }
            ll ways = C_x_k[k] * y_pow_k[k] % mod * s % mod;
            total_ways = (total_ways + ways) % mod;
        }
        return total_ways;
    }
};
",1420050821
callmesen,callmesen,491,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums) {
            if(num == 2) {
                ans.push_back(-1);
                continue;
            }
            int min_x = num - 1;
            if((min_x | (min_x + 1)) != num)
                min_x = INT_MAX;
            for(int n = 1; n <= 30; ++n) {
                int x = num - (1 << n);
                if(x < 0)
                    break;
                if((x & ((1 << n) - 1)) == ((1 << n) -1)) {
                    if((x | (x + 1)) == num && x < min_x) {
                        min_x = x;
                    }
                }
            }
            if(min_x != INT_MAX)
                ans.push_back(min_x);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};
",1420041089
callmesen,callmesen,491,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums) {
            int min_x = INT_MAX;
            for(int k = 0; k < 31; ++k) {
                int x = num - (1 << k);
                if (x < 0) break;
                if ((x | (x + 1)) == num) {
                    min_x = min(min_x, x);
                }
            }
            if (min_x != INT_MAX)
                ans.push_back(min_x);
            else
                ans.push_back(-1);
        }
        return ans;
    }
};
",1420046405
Sonali Kashyap,sonalik1411,492,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
        ",1420102800
Sonali Kashyap,sonalik1411,492,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420121891
Sonali Kashyap,sonalik1411,492,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
     int n = nums.size();
    vector<int> ans(n, -1);  // Initialize the result array with -1

    // Iterate through each index to find the smallest ans[i]
    for (int i = 0; i < n; i++) {
        for (int x = 0; x <= nums[i]; x++) {
            // Check if x | (x + 1) equals nums[i]
            if ((x | (x + 1)) == nums[i]) {
                ans[i] = x;  // Set ans[i] as the valid x
                break;       // No need to check further once a valid x is found
            }
        }
    }

    return ans;
    }
};",1420063507
Sonali Kashyap,sonalik1411,492,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
    
        int n = nums.size();
        int[] ans = new int[n]; // Output array

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;

            // Check for each bit from 0 to 30
            for (int bit = 0; bit <= 30; bit++) {
                // If the bit is set in the given number
                if (((num >> bit) & 1) == 1) {
                    // Try turning off this bit to form a candidate
                    int candidate = num & ~(1 << bit);

                    // Ensure the candidate is non-negative
                    if (candidate < 0) continue;

                    // Check if the condition holds: candidate | (candidate + 1) == num
                    if ((candidate | (candidate + 1)) == num) {
                        minimalAns = Math.min(minimalAns, candidate); // Keep the smallest candidate
                        found = true;
                    }
                }
            }

            // If a valid candidate was found, store it in the answer; otherwise, store -1
            ans[i] = found ? minimalAns : -1;
        }

        return ans;
    }
}",1420097764
koushik210,koushik210,493,3487,kotlin,"class Solution {
    fun maxRemovals(source: String, pattern: String, targetIndices: IntArray): Int {
        val n = source.length
        val m = pattern.length
        val dp = IntArray(m + 1) { Int.MAX_VALUE }
        dp[0] = 0
        val isTarget = BooleanArray(n)

        // Mark the target indices
        for (idx in targetIndices) {
            isTarget[idx] = true
        }

        // Fill the dp array
        for (i in 0 until n) {
            for (j in m downTo 1) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != Int.MAX_VALUE) {
                    dp[j] = minOf(dp[j], dp[j - 1] + if (isTarget[i]) 1 else 0)
                }
            }
        }

        return targetIndices.size - if (dp[m] == Int.MAX_VALUE) 0 else dp[m]
    }
}
",1420080492
koushik210,koushik210,493,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420117715
koushik210,koushik210,493,3605,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        val n = nums.size
        val ans = IntArray(n) { -1 }  // Initialize ans with -1

        // Iterate over each number in the nums array
        for (i in 0 until n) {
            // Try all possible values for ans[i]
            for (x in 0..nums[i]) {
                if ((x or (x + 1)) == nums[i]) {
                    ans[i] = x
                    break  // Once we find the minimum x, we stop
                }
            }
        }

        return ans
    }
}
",1420020951
koushik210,koushik210,493,3611,kotlin,"class Solution {
    fun minBitwiseArray(nums: List<Int>): IntArray {
        val n = nums.size
        val ans = IntArray(n)

        for (i in 0 until n) {
            val num = nums[i]
            var minimalAns = Int.MAX_VALUE
            var found = false
            
            // Iterate through each bit position (0 to 30)
            for (bit in 0..30) {
                if ((num shr bit and 1) == 1) {
                    // Unset the current bit
                    val candidate = num and (1 shl bit).inv()
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate or (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate
                            found = true
                        }
                    }
                }
            }

            ans[i] = if (found) minimalAns else -1
        }

        return ans
    }
}

",1420077485
IkshitMangal,IkshitMangal,494,3487,c,"#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

int maxRemovals(char* source, char* pattern, int* targetIndices, int targetIndicesSize) {
    int n = strlen(source);
    int m = strlen(pattern);
    
    // Initialize the dp array
    int* dp = (int*)malloc((m + 1) * sizeof(int));
    for (int j = 0; j <= m; j++) {
        dp[j] = INT_MAX; // Set all to infinity
    }
    dp[0] = 0; // Base case: 0 removals to match an empty pattern

    // Create an array to check if an index is a target index for removal
    int* isTarget = (int*)calloc(n, sizeof(int));
    for (int i = 0; i < targetIndicesSize; i++) {
        isTarget[targetIndices[i]] = 1; // Mark the target indices
    }

    // Process the source string
    for (int i = 0; i < n; i++) {
        for (int j = m; j > 0; j--) {
            if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                dp[j] = dp[j] < (dp[j - 1] + (isTarget[i] ? 1 : 0)) ? dp[j] : (dp[j - 1] + (isTarget[i] ? 1 : 0));
            }
        }
    }

    int result = targetIndicesSize - (dp[m] == INT_MAX ? 0 : dp[m]);
    
    // Free allocated memory
    free(dp);
    free(isTarget);
    
    return result;
}

// Example usage
",1420064770
IkshitMangal,IkshitMangal,494,3604,java,"import java.util.Arrays;

class Solution {
    private static final long MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        // Initialize combination and Stirling numbers
        long[][] fun = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            fun[i][0] = 1; // C(i, 0) = 1
            for (int j = 1; j <= i; j++) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1; // S(0, 0) = 1
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        long[] mathFact = new long[x + 1];
        mathFact[0] = 1; // 0! = 1
        for (int i = 1; i <= x; i++) {
            mathFact[i] = (mathFact[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD; // y^k
            }
            totalWays = (totalWays + (fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD)) % MOD;
        }

        return (int) totalWays; // Return the total ways as an integer
    }

    // Example usage
    public static void main(String[] args) {
        Solution solution = new Solution();
        int n = 5; // Example value for n
        int x = 3; // Example value for x
        int y = 2; // Example value for y
        int result = solution.numberOfWays(n, x, y);
        System.out.println(""Number of ways: "" + result);
    }
}
",1420116084
IkshitMangal,IkshitMangal,494,3605,c,"#include <stdlib.h>

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minBitwiseArray(int* nums, int numsSize, int* returnSize) {
    // Allocate memory for the result array
    int* ans = (int*)malloc(numsSize * sizeof(int));

    // Iterate over each number in the nums array
    for (int i = 0; i < numsSize; i++) {
        ans[i] = -1; // Initialize ans[i] with -1
        
        // Try all possible values for ans[i]
        for (int x = 0; x <= nums[i]; x++) {
            if ((x | (x + 1)) == nums[i]) {
                ans[i] = x;
                break;  // Once we find the minimum x, we stop
            }
        }
    }

    // Set the return size to the size of the nums array
    *returnSize = numsSize;
    
    // Return the result array
    return ans;
}
",1420019945
IkshitMangal,IkshitMangal,494,3611,c,"#include <stdlib.h>
#include <limits.h>

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minBitwiseArray(int* nums, int numsSize, int* returnSize) {
    // Allocate memory for the result array
    int* ans = (int*)malloc(numsSize * sizeof(int));

    // Iterate over each number in the nums array
    for (int i = 0; i < numsSize; i++) {
        int num = nums[i];
        int minimalAns = INT_MAX;  // Set to max integer value
        int found = 0;  // Boolean flag to check if a valid candidate was found

        // Iterate through each bit position (0 to 30)
        for (int bit = 0; bit <= 30; bit++) {
            if ((num >> bit) & 1) {  // Check if the current bit is set to 1
                // Unset the current bit
                int candidate = num & ~(1 << bit);

                // Ensure candidate is non-negative
                if (candidate < 0) continue;

                // Check if candidate OR (candidate + 1) equals num
                if ((candidate | (candidate + 1)) == num) {
                    if (candidate < minimalAns) {
                        minimalAns = candidate;
                        found = 1;  // Valid candidate found
                    }
                }
            }
        }

        if (found) {
            ans[i] = minimalAns;
        } else {
            ans[i] = -1;  // If no valid candidate is found, set to -1
        }
    }

    // Set the return size to the size of the nums array
    *returnSize = numsSize;

    // Return the result array
    return ans;
}
",1420044892
Viktor Florinsky,vflorinsky,495,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420067836
Viktor Florinsky,vflorinsky,495,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420099904
Viktor Florinsky,vflorinsky,495,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            boolean found = false;
            for (int candidate = 0; candidate <= nums.get(i); candidate++) {
                if ((candidate | (candidate + 1)) == nums.get(i)) {
                    ans[i] = candidate;
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans[i] = -1;
            }
        }

        return ans;
    }
}",1420011160
Viktor Florinsky,vflorinsky,495,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420046875
harsh patil,gpatil1461976,496,3487,python3,"
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420063230
harsh patil,gpatil1461976,496,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420096846
harsh patil,gpatil1461976,496,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n = nums.size();
        std::vector<int> ans(n, -1); // Initialize the result array with -1

        for (int i = 0; i < n; i++) {
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x; // Found the minimum value for ans[i]
                    break; // No need to check further values
                }
            }
        }
        return ans;
    }
};",1420001313
harsh patil,gpatil1461976,496,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420066641
pradeepkalyan1275,pradeepkalyan1275,497,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True

        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isTarget[i] else 0))

        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420077988
pradeepkalyan1275,pradeepkalyan1275,497,3604,java,"import java.util.Arrays;

public class Solution {
    private static final int MOD = 1000000007;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        // No-op loop for consistency
        while (params.length > 0) {
            break;
        }
        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        System.out.println(""Output for (1, 2, 3): "" + solution.numberOfWays(1, 2, 3)); 
        System.out.println(""Output for (5, 2, 1): "" + solution.numberOfWays(5, 2, 1)); 
        System.out.println(""Output for (3, 3, 4): "" + solution.numberOfWays(3, 3, 4)); 
    }
}",1420104632
pradeepkalyan1275,pradeepkalyan1275,497,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        
        for (int num : nums) {
            bool found = false;
            for (int i = 0; i <= num; ++i) {
                if ((i | (i + 1)) == num) {
                    ans.push_back(i);
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans.push_back(-1);
            }
        }
        
        return ans;
    }
};",1420079633
pradeepkalyan1275,pradeepkalyan1275,497,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if candidate < 0:
                        continue
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True
            
            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans",1420052783
Vaibhav Kumar,vaibhav818,498,3487,java,"




import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE; // Use Integer.MAX_VALUE to represent infinity
        }
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}

",1420093955
Vaibhav Kumar,vaibhav818,498,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420101404
Vaibhav Kumar,vaibhav818,498,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize with -1
        
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            bool found = false;
            
            // Try to find the smallest x such that x OR (x + 1) == num
            for (int x = 0; x < num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                ans[i] = -1;  // If no valid x found, set ans[i] = -1
            }
        }
        
        return ans;
    }
};
",1420041015
Vaibhav Kumar,vaibhav818,498,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420081379
ADITYA RAJ,Aditya202204,499,3487,java,"import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();

        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? dp[m] : dp[m]);
    }
}
",1420108455
ADITYA RAJ,Aditya202204,499,3604,java,"import java.util.Arrays;

class Solution {
    static final int MOD = (int)1e9 + 7;

    public int numberOfWays(int n, int x, int y) {
        int[] params = {n, x, y};
        while (params.length > 0) {
            break;
        }

        long[][] comb = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long yPow = 1;
            for (int j = 0; j < k; j++) { 
                yPow = yPow * y % MOD;
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int)totalWays;
    }
}
",1420119613
ADITYA RAJ,Aditya202204,499,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            if (!found) {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420011786
ADITYA RAJ,Aditya202204,499,3611,cpp,"#include <vector>
#include <limits>

class Solution {
public:
    std::vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans1(n);

        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int minimalAns1 =numeric_limits<int>::max();
            bool found = false;

            for (int b= 0; b < 31; ++b) {
                if ((num >> b) & 1) {
                    int candidate = num & ~(1 << b);
                    if (candidate < 0) continue;

                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns1) {
                            minimalAns1 = candidate;
                            found = true;
                        }
                    }
                }
            }

            ans1[i] = found ? minimalAns1 : -1;
        }

        return ans1;
    }
};
",1420073457
Prasada Vishwesh,fAx65RQKEO,500,3487,python,"class Solution(object):
    def maxRemovals(self, source, pattern, targetIndices):
        """"""
        :type source: str
        :type pattern: str
        :type targetIndices: List[int]
        :rtype: int
        """"""
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        
        # Mark the target indices as True
        for idx in targetIndices:
            isTarget[idx] = True
        
        # Dynamic programming to check the maximum number of removals
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        # Calculate the number of removals
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

# Example usage
source = ""abbaa""
pattern = ""aba""
targetIndices = [0, 1, 2]
solution = Solution()
print(solution.maxRemovals(source, pattern, targetIndices))  # Expected output: 1
",1420100830
Prasada Vishwesh,fAx65RQKEO,500,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        MOD = 10**9 + 7
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways

# Example usage:
solution = Solution()
print(solution.numberOfWays(3, 3, 4))  # Expected output: 684
",1420103948
Prasada Vishwesh,fAx65RQKEO,500,3605,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            
            // Try to find the minimum value for ans[i]
            for (int x = 0; x <= num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            // If no valid ans[i] is found, set ans[i] to -1
            if (!found) {
                ans[i] = -1;
            }
        }
        return ans;
    }
}
",1420037511
Prasada Vishwesh,fAx65RQKEO,500,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        n = len(nums)
        ans = [-1] * n
        
        for i in range(n):
            num = nums[i]
            minimal_ans = float('inf')
            found = False
            
            # Iterate through each bit position (0 to 30)
            for bit in range(31):
                if (num >> bit) & 1:
                    # Unset the current bit
                    candidate = num & ~(1 << bit)
                    
                    # Ensure candidate is non-negative
                    if candidate < 0:
                        continue
                    
                    # Check if candidate OR (candidate + 1) equals num
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimal_ans:
                            minimal_ans = candidate
                            found = True
            
            if found:
                ans[i] = minimal_ans
            else:
                ans[i] = -1
        
        return ans
",1420084182
Azamov,professorDeveloper,501,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420057401
Azamov,professorDeveloper,501,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420087545
Azamov,professorDeveloper,501,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        
        for num in nums:
            found = False
            
            # Iterate over possible ans[i] values starting from 0
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            
            # If no valid ans[i] found, append -1
            if not found:
                ans.append(-1)
        
        return ans
",1419992945
Azamov,professorDeveloper,501,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1419997400
Chitvan Kumar,Chitvan945,502,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)  # Length of source string
        m = len(pattern)  # Length of pattern string
        dp = [float('inf')] * (m + 1)  # Dynamic programming array
        dp[0] = 0  # Base case: 0 removals needed for matching an empty pattern
        
        # Boolean array to track target indices
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        # Dynamic programming to find the minimum removals
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j - 1] and dp[j - 1] != float('inf'):
                    # Update dp[j] if there's a match
                    dp[j] = min(dp[j], dp[j - 1] + (1 if isTarget[i] else 0))

        # Calculate the maximum number of removals
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])

# Example usage
sol = Solution()
source = ""abcbcac""
pattern = ""abc""
targetIndices = [1, 3, 5]

print(sol.maxRemovals(source, pattern, targetIndices))  # Example output",1420069462
Chitvan Kumar,Chitvan945,502,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420098104
Chitvan Kumar,Chitvan945,502,3605,python3,"from typing import List

class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            found = False

            for candidate in range(num):
                if (candidate | (candidate+1)) == num:
                    ans.append(candidate)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans",1420008923
Chitvan Kumar,Chitvan945,502,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420057427
Stranger_00,Stranger_00,503,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
",1420064033
Stranger_00,Stranger_00,503,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420093230
Stranger_00,Stranger_00,503,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420040914
Marius Beceanu,mbeceanu,505,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        p=10**9+7
        dist=[0]*x
        dist[0]=x
        for i in range(n-1):
            tmp=[0]*x
            tmp[0]=x
            for k in range(1, x):
                tmp[k]=(dist[k]*(k+1)+dist[k-1]*(x-k))%p
            dist=tmp
        mult=y
        sm=0
        for i in range(x):
            sm=(sm+mult*dist[i])%p
            mult=mult*y%p
        return sm
        
        ",1420043418
Marius Beceanu,mbeceanu,505,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans=[]
        def dig(n):
            ans=[]
            while n:
                ans.append(n&1)
                n>>=1
            return ans
        for n in nums:
            if n==2:
                ans.append(-1)
            else:
                d=dig(n)
                l=len(d)
                i=0
                while i<l and d[i]==1:
                    i+=1
                i-=1
                ans.append(n-(1<<i))
        return ans


        ",1420007516
Marius Beceanu,mbeceanu,505,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        
        ans=[]
        def dig(n):
            ans=[]
            while n:
                ans.append(n&1)
                n>>=1
            return ans
        for n in nums:
            if n==2:
                ans.append(-1)
            else:
                d=dig(n)
                l=len(d)
                i=0
                while i<l and d[i]==1:
                    i+=1
                i-=1
                ans.append(n-(1<<i))
        return ans
        ",1420009420
DEMON J,DeEmOnJ,506,3604,cpp,"const int MOD = 1e9 + 7;
const int MAXN = 1001;

vector<long long> fact(MAXN), invfact(MAXN);
vector<vector<long long>> stirling(MAXN, vector<long long>(MAXN, 0));

long long mod_pow(long long base, long long exp, int mod) {
long long result = 1;
base %= mod;
while (exp > 0) {
if (exp % 2)
result = result * base % mod;
base = base * base % mod;
exp /= 2;
}
return result;
}

void precompute_factorials() {
fact[0] = invfact[0] = 1;
for (int i = 1; i < MAXN; i++) {
fact[i] = fact[i - 1] * i % MOD;
invfact[i] = mod_pow(fact[i], MOD - 2, MOD);
}
}

void precompute_stirling_numbers() {
stirling[0][0] = 1;
for (int n = 1; n < MAXN; n++) {
for (int k = 1; k <= n; k++) {
stirling[n][k] = (k * stirling[n - 1][k] % MOD + stirling[n - 1][k - 1]) % MOD;
}
}
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        precompute_factorials();
        precompute_stirling_numbers();

        long long ans = 0;
        int max_k = min(n, x);

        for (int k = 1; k <= max_k; k++) {
        long long comb = fact[x] * invfact[k] % MOD * invfact[x - k] % MOD;
        long long perm = fact[k];
        long long S = stirling[n][k];
        long long ys = mod_pow(y, k, MOD);

        long long total = comb * perm % MOD * S % MOD * ys % MOD;
        ans = (ans + total) % MOD;
        }
        return ans;
        }
        };


",1420044087
DEMON J,DeEmOnJ,506,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {

        const int MAX_VALUE = 1000;
        vector<int> minimalK(MAX_VALUE + 1, -1);


        for (int k = 0; k <= MAX_VALUE; ++k) {
        int N = k | (k + 1);
        if (N <= MAX_VALUE) {
        if (minimalK[N] == -1 || k < minimalK[N]) {
        minimalK[N] = k;
        }
        }
        }

        vector<int> ans(nums.size(), -1);
        for (size_t i = 0; i < nums.size(); ++i) {
        ans[i] = minimalK[nums[i]];
        }

        return ans;
        

        
    }
};",1420002280
DEMON J,DeEmOnJ,506,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result;
        for (int num : nums) {
        int minimal_x = -1;
        for (int bit = 0; bit <= 30; ++bit) {
        if ((num >> bit) & 1) {
        int candidate = num - (1 << bit);
        if (candidate >= 0 && (candidate | (candidate + 1)) == num) {
        if (minimal_x == -1 || candidate < minimal_x) {
        minimal_x = candidate;
        }
        }
        }
        }
        result.push_back(minimal_x);
        }
        return result;
        }
        };
        
   ",1420009799
Nikhil,j1r4ch1,507,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9+7
        
        def power(a, x):
            total = 1
            while x:
                if x & 1:
                    total = (total*a) % MOD
                a = (a*a) % MOD
                x >>= 1
            return total % MOD
        
        # @cache
        # def solve(x,y,n):
        #     if n == 0:
        #         return 1
        #     for k in range(1,x+1):
        #         return k*solve(x,y,n-1) + (x-k+1)*solve(x-1,y,k-1) % MOD
            
        
        dp = [[0]*(x+1) for _ in range(n+1)]
        dp[0][0] = 1
        for i in range(1,n+1):
            for k in range(1,x+1):
                dp[i][k] = ((k*dp[i-1][k])%MOD+((x-k+1)*dp[i-1][k-1])%MOD) % MOD

        ans = 0
        for k in range(1,x+1):
            ans = (ans+dp[n][k]*power(y,k)) % MOD

        return ans",1420047380
Nikhil,j1r4ch1,507,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
                continue
            x = list(bin(n)[2:])
            x = x[::-1]
            if ""0"" in x:
                idx = x.index(""0"")
                x[idx-1] = ""0""
            else:
                x[-1] = ""0""
            x = x[::-1]
            ans.append(int("""".join(x), 2))
        
        return ans",1420010771
Nikhil,j1r4ch1,507,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
                continue
            x = list(bin(n)[2:])
            x = x[::-1]
            if ""0"" in x:
                idx = x.index(""0"")
                x[idx-1] = ""0""
            else:
                x[-1] = ""0""
            x = x[::-1]
            ans.append(int("""".join(x), 2))
        
        return ans",1420011406
Balakrishnan Varadarajan,balakrishnan_v,509,3604,cpp,"#define MODD 1000000007
#define ll __int128
class Solution {
public:

    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }


    ll B[1002][1002];
    int numberOfWays(int n, int x, int y) {
        for(int i=0;i<=x;i++) {
            for(int j=0;j<=i;j++) {
                if (j==0) {
                    B[i][j]=1;
                } else {
                    B[i][j]=(B[i-1][j]+B[i-1][j-1])%MODD;
                }
            }
        }
        vector<ll> pw(x+1);
        pw[0]=0;
        for(int i=1;i<=x;i++) {
            pw[i]=modpow(i,n);
        }
        // b bands
        ll ans = 0;
        for(int b=1;b<=x;b++) {
            int sgn = 1;
            ll curr_summ = 0;
            for(int i=b;i>=1;i--) {
                ll curr = B[b][i]*pw[i]*sgn%MODD;
                curr = (curr+MODD)%MODD;
                curr_summ += curr;
                if (curr_summ >= MODD) curr_summ -= MODD;
                sgn=-sgn;
            }
            ans += B[x][b]*curr_summ%MODD*modpow(y,b)%MODD;
            ans %= MODD;
            // binomial[x][b] * (sum_{i=1 to b} binomial(b,i) (-1)^(b-i)* n^i) * y^b
        }
        return (long long)ans;
        
    }
};",1420017678
Balakrishnan Varadarajan,balakrishnan_v,509,3605,cpp,"class Solution {
public:
    int BruteForce(int y) {
        for(int x=0;x<=y;x++) {
            if ((x|(x+1)) == y) return x;
        }
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int x : nums) {
                ans.push_back(BruteForce(x));
            
            
        }
        return ans;
    }
};",1420037570
Balakrishnan Varadarajan,balakrishnan_v,509,3611,cpp,"class Solution {
public:
     
    int BruteForce(int y) {
        for(int x=0;x<=1000;x++) {
            if ((x|(x+1)) == y) return x;
        }
        return -1;
    }
    
    bool CheckPrime(int x) {
        for(int y=2;y*y<=x;y++) {
            if (x%y==0) return false;
        }
        return true;
    }
    
    int Solve(int x) {
        vector<bool> B;
        while(x) {
            B.push_back(x%2);
            x/=2;
        }
        reverse(B.begin(),B.end());
        
        // find the first zero
        int fz=-1;
        int n=B.size();
        for(int i=n-1;i>=0;i--) {
            if (B[i]==0) {
                fz=i;
                break;
            }
        }
        B[fz+1]=0;
        int y=0;
        for(int b : B) {
            y = y*2+b;
        }
        return y;
        
    }
    
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        
        vector<int> ans;
        for(int x : nums) {
            if (x%2==0) {
                ans.push_back(-1);
            } else {
                ans.push_back(Solve(x));
            }
            
        }
        
        return ans;
        
    }
};",1420048941
Remineva,Remineva,515,3604,python3,"M = 10 ** 9 + 7
fac = [1]
for i in range(1000):
    fac.append(fac[-1] * (i + 1) % M)
inv = [1] * 1001
inv[-1] = pow(fac[-1], M - 2, M)
for i in range(999, -1, -1):
    inv[i] = inv[i + 1] * (i + 1) % M
def nCr(n, r):
    return fac[n] * inv[r] % M * inv[n - r] % M
    
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        k = min(n, x)
        prev = [0] * (k + 1)
        curr = [0] * (k + 1)
        prev[0] = 1
        for i in range(1, n + 1):
            curr = [0] * (k + 1)
            for j in range(1, k + 1):
                curr[j] = (j * prev[j] + prev[j-1]) % M
            prev = curr
        res = 0
        for i in range(1, k + 1):
            temp = nCr(x, i) * prev[i] % M
            temp *= fac[i]
            temp %= M
            temp *= pow(y, i, M)
            temp %= M
            res += temp
            res %= M
        return res",1420069493
Remineva,Remineva,515,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            for i in range(1, num):
                if i | (i + 1) == num:
                    res.append(i)
                    break
            else:
                res.append(-1)
        return res",1419997044
Remineva,Remineva,515,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if num == 2:
                res.append(-1)
                continue
            ls = []
            while num:
                ls.append(num & 1)
                num >>= 1
            m = len(ls)
            for i in range(m):
                if ls[i] == 0:
                    for j in range(i - 2, -1, -1):
                        ls[j] = 0
                    break
            else:
                for j in range(m - 1):
                    ls[j] = 0
            curr = 1
            ans = 0
            for i in ls:
                ans += curr * i
                curr *= 2
            res.append(ans - 1)
        return res",1420018144
jeff27726,jeff27726,517,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int mod = 1e9 + 7;
        int K = min(n, x);
        vector<long> exactly(K+1, 0);
        exactly[0] = 1;
        for(int i=0; i<n; ++i){
            //cout << i+1 << '\n';
            for(int j=K; j>0; --j){
                exactly[j] = (j*exactly[j] + (x-j+1)*exactly[j-1])%mod;
                //cout << j << "": "" << exactly[j] << '\n';
            }
            exactly[0]=0;
        }
        long res=0;
        long yk = 1;
        for(int k=1; k<=K; ++k){
            yk = (yk * y) % mod;
            res = (res + (exactly[k]*yk) % mod) % mod;
        }
        return int(res);
    }
};",1420072378
jeff27726,jeff27726,517,3605,cpp,"class Solution {
public:
    int map(int p){
        if(p==2) return -1;
        int q = p+1;
        return p - ((q&-q)>>1);
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        res.reserve(nums.size());
        for(int p: nums){
            res.push_back(map(p));
        }
        return res;
    }
};",1420021957
jeff27726,jeff27726,517,3611,cpp,"class Solution {
public:
    int map(int p){
        if(p==2) return -1;
        int q = p+1;
        return p - ((q&-q)>>1);
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        res.reserve(nums.size());
        for(int p: nums){
            res.push_back(map(p));
        }
        return res;
    }
};",1420025891
Yash Jaiswal,yashjaiswal2509,519,3604,java,"class Solution {
    final int MOD = 1_000_000_007;
    public int numberOfWays(int n, int x, int y) {
        long[][] C = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        long[] fact = new long[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long res = 0;
        for (int k = 1; k <= x; k++) {
            long pow = 1;
            for (int p = 0; p < k; p++) {
                pow = (pow * y) % MOD;
            }
            res = (res + C[x][k] * S[n][k] % MOD * fact[k] % MOD * pow % MOD) % MOD;
        }

        return (int) res;
    }
}",1420073220
Yash Jaiswal,yashjaiswal2509,519,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            ans[i] = findSmallestAns(nums.get(i));
        }
        
        return ans;
    }
    
    private int findSmallestAns(int num) {
        for (int ans = 0; ans < num; ans++) {
            if ((ans | (ans + 1)) == num) {
                return ans;
            }
        }
        return -1;
    }
}",1419999015
Yash Jaiswal,yashjaiswal2509,519,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int min = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int b = 0; b <= 30; b++) {
                if (((num >> b) & 1) != 0) {
                    int can = num & ~(1 << b);
                    if (can < 0) continue;
                    
                    if ((can | (can + 1)) == num) {
                        if (can < min) {
                            min = can;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = min;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}",1420066797
Asish,Atma_,520,3604,cpp,"class Solution {
public:
    const int mod=1e9+7;
    int poww(int a, int b){
        if(b==0) return 1;
        int ans=poww(a,b/2);
        ans=1ll*ans*ans%mod;
        if(b&1) ans=1ll*ans*a%mod;
        return ans;
    }
    
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> empstages(n, vector<int>(x+1,0));
        empstages[n-1][x-1]=x;
        
        for(int i=n-2;i>=0;--i){
            for(int j=0;j<=x;++j){
                empstages[i][j]=1ll*(x-j)*empstages[i+1][j]%mod;
                if(j<x) empstages[i][j]=(0ll+empstages[i][j]+1ll*(j+1)*empstages[i+1][j+1]%mod)%mod;
            }
        }
        int ans=0;
        for(int i=0;i<=x;++i){
            //cout<<empstages[0][i]<<"" "";
            ans=(0ll+ans+1ll*empstages[0][i]*poww(y,x-i)%mod)%mod;
        }
        //cout<<endl;
        return ans;
    }
};",1420074279
Asish,Atma_,520,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;++i){
            for(int j=0;j<=nums[i];j++){
                if((j|(j+1))==nums[i]){
                    ans[i]=j;break;
                }
            }
        }
        return ans;
    }
};",1420000130
Asish,Atma_,520,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n=nums.size();
        for(int i=0;i<n;++i){
            if(nums[i]==2) ans.push_back(-1);
            else{
                int ct=1;
                for(int j=1;j<=30;++j){
                    if((nums[i]>>j)&1){
                        ct++;
                    }
                    else{
                        break;
                    }
                }
                nums[i]^=(1<<(ct-1));
                ans.push_back(nums[i]);
            }
        }
        return ans;
    }
};",1420033172
Partha Banerjee,parthahere001,523,3604,cpp,"typedef long long ll;
ll mod = 1e9 + 7;
class Solution {
public:
    vector<vector<ll>> dp;
    ll helper(int n, int k) {
    
    if (k == 0){
        if (n == 0) 
        return 1;
        else
        return 0;
    }
    if (k > n){
        return 0;
    }
    
    if (dp[n][k] != -1){
        return dp[n][k];
    }
    
    ll val1 = ((helper(n - 1, k)%mod) * (k%mod)) % mod; //chk
    ll val2 = helper(n - 1, k - 1);
    dp[n][k] = (val1%mod + val2%mod) % mod; //chk
    return dp[n][k];
}


    int numberOfWays(int n, int x, int y) {
       ll high = min(n, x);
    
        dp.assign(n + 1, vector<ll>(high + 1, -1));
    
    vector<ll> a1(high + 1, 1);
    for(int i = 1; i <= high; i++) {
        a1[i] = ((y%mod)*(a1[i - 1]%mod)) % mod;
    }
    
    vector<ll> nums(high + 1, 1);
    for(int i = 1; i <= high; i++) {
        nums[i] = ((x - i + 1)%mod*nums[i - 1]%mod) % mod;
    }
    
    ll ans = 0;
    for(int k = 1; k <= high; k++) {
        ll temp = helper(n, k);
        
        ll n1 = (temp%mod * nums[k]%mod) % mod;
        n1 = (n1%mod * a1[k]%mod) % mod;
        ans = (ans%mod + n1%mod) % mod;
    }
    
    return static_cast<int>(ans);
    }
};",1420074611
Partha Banerjee,parthahere001,523,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
    for(int i=0;i<nums.size();i++){
    
        int temp = -1;
    
        if(nums[i]%2 ==0){
            ans.push_back(-1);
            continue;
        }
       
      
        int k =0;
        while((1<<k)<=nums[i]){

            if(((1<<k)&nums[i])){
                int a =((~(1<<k))&nums[i]);
            
                if( nums[i]== (a | (a +1)) ){
                    if((a < temp)||(temp == -1)){
                        temp = a;
                    }
                }
            }
            k++;
        }
        ans.push_back(temp);
    }
    return ans;
    }
};",1420009818
Partha Banerjee,parthahere001,523,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans;
    for(int i=0;i<nums.size();i++){
    
        int temp = -1;
    
        if(nums[i]%2 ==0){
            ans.push_back(-1);
            continue;
        }
       
      
        int k =0;
        while((1<<k)<=nums[i]){

            if(((1<<k)&nums[i])){
                int a =((~(1<<k))&nums[i]);
            
                if( nums[i]== (a | (a +1)) ){
                    if((a < temp)||(temp == -1)){
                        temp = a;
                    }
                }
            }
            k++;
        }
        ans.push_back(temp);
    }
    return ans;
    }
};

",1420009293
Ernest Lu,ernestlu,526,3604,cpp,"using ll = long long;
constexpr ll MOD = 1e9 + 7;
class Solution {
public:


struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};
    int numberOfWays(int n, int x, int y) {
        const int b = max({x, n, y});
        vector<mint> fac(b + 1, 1), pow_y(b + 1, 1), inv(b + 1);
        vector<mint> pow_to_n(b + 1, 0);
        for (int i = 1; i <= b; i++) {
            fac[i] = fac[i - 1] * i;
            pow_y[i] = pow_y[i - 1] * y;
            pow_to_n[i] = mint(i).pow(n);
        }
        inv[b] = fac[b].pow();
        for (int i = b - 1; i >= 0; i--)
            inv[i] = (inv[i + 1] * (i + 1));
        
        auto C = [&](int n, int k) -> mint {
            if (n < k or k < 0)
                return mint(0);
            return fac[n] * inv[k] * inv[n - k];
        };
        
        mint ans = 0;
        for (int num_stages = 1; num_stages <= x; num_stages++) {
            mint h = C(x, num_stages);
            mint assign_to = 0;
            for (int idx = num_stages, flip = 1; idx >= 1; idx--, flip *= -1) {
                assign_to += flip * C(num_stages, idx) * pow_to_n[idx];
            }
            ans += h * assign_to * pow_y[num_stages];
        }
        return ans.x;
    }
};",1420030729
Ernest Lu,ernestlu,526,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = (int)nums.size();
        vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            ans[i] = (nums[i] == 2 ? -1 : nums[i] - 1);
            if (nums[i] == 2)
                continue;

            int num_ones = 0;
            int x = nums[i];
            while (x % 2 == 1) {
                num_ones++;
                x /= 2;
            }
            if (num_ones == 1) {
                ans[i] = nums[i] - 1;
            } else {
                int x = nums[i];
                x = (x >> num_ones) << num_ones;
                for (int j = 0, p2 = 1; j + 1 < num_ones; j++, p2 *= 2)
                    x += p2;                
                ans[i] = x;
            }
        }
        return ans;
    }
};",1420081220
Ernest Lu,ernestlu,526,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = (int)nums.size();
        vector<int> ans(n);

        for (int i = 0; i < n; i++) {
            ans[i] = (nums[i] == 2 ? -1 : nums[i] - 1);
            if (nums[i] == 2)
                continue;

            int num_ones = 0;
            int x = nums[i];
            while (x % 2 == 1) {
                num_ones++;
                x /= 2;
            }
            if (num_ones == 1) {
                ans[i] = nums[i] - 1;
            } else {
                int x = nums[i];
                x = (x >> num_ones) << num_ones;
                for (int j = 0, p2 = 1; j + 1 < num_ones; j++, p2 *= 2)
                    x += p2;                
                ans[i] = x;
            }
        }
        return ans;
    }
};",1420080394
Yifeng,gaoyf1235,527,3604,cpp,"
class Solution {
    using ll = long long;
    const ll mod = 1e9 + 7;
    template<typename T>
    class Combination{
    public:
        Combination(T n, T modular) : n_(n), mod_(modular) {
            fact_mod_.resize(n+1, 1);
            inv_fact_mod_.resize(n+1, 1);
            for(T i = 1; i <= n; i++){
                fact_mod_[i] = (i * fact_mod_[i - 1]) % mod_;
                // fast modular inverse with exp(mod - 2)
                inv_fact_mod_[i] = modExp(fact_mod_[i], mod_ - 2, mod_);
            }
        }

        T nChooseK(T n, T k){
            if(k > n) return 0;
            T nCk = (((fact_mod_[n] * inv_fact_mod_[k]) % mod_) * inv_fact_mod_[n-k]) % mod_;
            return nCk;
        }

        T factorial(T n){
            return fact_mod_[n];
        }

        T inv_factorial(T n){
            return inv_fact_mod_[n];
        }
    private:
        vector<T> fact_mod_;
        vector<T> inv_fact_mod_;
        T n_;
        T mod_;

        ll modExp(ll x, ll y, ll m){
            if(y == 0) return 1;
            ll half_exp = modExp(x, y / 2, m);
            if(y % 2 == 0) return (half_exp * half_exp) % m;
            else return (((half_exp * half_exp) % m) * x) % m;
        }
    };
public:
    int numberOfWays(int n, int x, int y) {
        ll max_cnt = 1000;
        Combination<ll> comb(1000, mod);
        
        ll n_fac = comb.factorial(n);
        vector<ll> powy(max_cnt + 1, 1);
        for(ll i = 1; i <= max_cnt; i++){
            powy[i] = (powy[i-1] * y) % mod;
        }
        vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));
        dp[1][1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i][j] += j * dp[i-1][j];
                dp[i][j] += j * dp[i-1][j-1];
                dp[i][j] %= mod;
            }
        }
        ll res = 0;
        for(int b = 1; b <= min(x, n); b++){
            ll b_stages = comb.nChooseK(x, b);
            ll b_stages_score = (b_stages * powy[b]) % mod;
            res += b_stages_score * dp[n][b];
            res %= mod;
        }
        return res;
    }
};",1420081415
Yifeng,gaoyf1235,527,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x : nums){
            if(x == 2) res.push_back(-1);
            else{
                string bits;
                for(int i = 0; i <= 30; i++){
                    if(x & (1 << i)){
                        bits += ""1"";
                    }
                    else{
                        bits += ""0"";
                    }
                }
                while(bits.back() == '0'){
                    bits.pop_back();
                }
                int n = bits.size();
                int ones = 0;
                int r = 0;
                for(int i = 0; i < n; i++){
                    if(bits[i] == '1') ones++;
                    if(ones == i + 1){
                        r = i;
                    }
                }
                int ans = 0;
                for(int i = 0; i < n; i++){
                    if(i < r){
                        ans |= (1 << i);
                    }
                    else{
                        if(bits[i] == '1' and i > r) ans |= (1 << i);
                    }
                }
                res.push_back(ans);
            }
        }
        return res;
    }
};",1420032900
Yifeng,gaoyf1235,527,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res;
        for(auto x : nums){
            if(x == 2) res.push_back(-1);
            else{
                string bits;
                for(int i = 0; i <= 30; i++){
                    if(x & (1 << i)){
                        bits += ""1"";
                    }
                    else{
                        bits += ""0"";
                    }
                }
                while(bits.back() == '0'){
                    bits.pop_back();
                }
                int n = bits.size();
                int ones = 0;
                int r = 0;
                for(int i = 0; i < n; i++){
                    if(bits[i] == '1') ones++;
                    if(ones == i + 1){
                        r = i;
                    }
                }
                int ans = 0;
                for(int i = 0; i < n; i++){
                    if(i < r){
                        ans |= (1 << i);
                    }
                    else{
                        if(bits[i] == '1' and i > r) ans |= (1 << i);
                    }
                }
                res.push_back(ans);
            }
        }
        return res;
    }
};",1420032535
Darin Mao,darin-mao,528,3604,python3,"MOD = 1000000007

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        score = y
        rv = 0
        s_num = x
        s_den = 1
        for stages in range(1, min(n, x)+1):
            assigns = 0
            num = 1
            den = 1
            for i in range(stages):
                term = num // den * pow(stages-i, n, MOD)
                num *= (stages-i)
                den *= (i+1)
                if i % 2:
                    assigns = (assigns - term) % MOD
                else:
                    assigns = (assigns + term) % MOD

            assigns *= s_num // s_den
            rv = (rv + score * assigns) % MOD

            s_num *= x-stages
            s_den *= stages+1
            score *= y
        return rv

# k = n
# n = stages",1420081929
Darin Mao,darin-mao,528,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for x in nums:
            if x == 2:
                yield -1
            else:
                for i in count():
                    if (x >> i) & 1 == 0:
                        yield x & ~(1 << (i-1))
                        break
",1420008498
Darin Mao,darin-mao,528,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        for x in nums:
            if x == 2:
                yield -1
            else:
                for i in count():
                    if (x >> i) & 1 == 0:
                        yield x & ~(1 << (i-1))
                        break
",1420008255
ykamo,ykamo,529,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        Z = 10 ** 9 + 7
        # sum(map(lambda x: 4 ** len(set(x)) , list(itertools.product([0, 1, 2], [0, 1, 2], [0, 1, 2]))))
        # sum(map(lambda z: y ** len(set(z)) , list(itertools.product(*[list(range(x)) for _ in range(n)]))))
        d = [0] * x
        d[0] = x
        for i in range(n-1):
            e = [0] * x
            for j in range(x):
                e[j] += d[j] * (j + 1)
                if j != x - 1:
                    e[j+1] += d[j] * (x - j - 1)
            d = e
        # print(d)
        s = 0
        w = y
        for i, v in enumerate(d):
            s += v * w
            w *= y
            s %= Z
            w %= Z
        return s



        ",1420082294
ykamo,ykamo,529,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def f(n):
            if n == 2:
                return -1
            return n & (n + 1) + (n ^ (n + 1)) // 4
        return map(f, nums)

        ",1420012032
ykamo,ykamo,529,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def f(n):
            if n == 2:
                return -1
            return n & (n + 1) + (n ^ (n + 1)) // 4
        return map(f, nums)

        ",1420011528
Neal Saxena,neal27,531,3604,cpp,"class Solution {
public:
# define ll long long
ll MOD = 1e9 + 7;
ll MOD2 = 998244353;
ll INF = 1e18;

static const int MAX_N = 1005;
ll fac[MAX_N];
ll invfac[MAX_N];
ll s[MAX_N][MAX_N];
ll power(ll x, int y, int p){
    ll res = 1; // Initialize result
    x = x % p; // Update x if it is more than or equal to p
    while (y > 0){
        // If y is odd, multiply x with result
        if (y & 1) res = (res * x) % p;
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % p;
    }
    return res;
}
// Returns n^(-1) mod p
ll modInverse(ll n, int p){
    return power(n, p - 2, p);
}
void fill_arrays(int n, int p){
    // Fill factorial array so that we can find all factorial of r, n and n-r
    fac[0] = 1;
    for (int i = 1; i <= n; i++) fac[i] = (fac[i - 1] * i) % p;
    invfac[n] = modInverse(fac[n], p); // Fermat's little theorem for modular inverse
    for (int i = n - 1; i >= 0; i--) invfac[i] = invfac[i + 1] * (i + 1) % p;
    s[0][0] = 0;
    for(int x = 1; x <= n; x++){
        s[x][0] = 0;
        s[x][1] = 1;
        for(int y = 2; y <= x; y++){
            s[x][y] = (s[x - 1][y - 1] + ((y * s[x - 1][y])%p))%p;
        }
    }
}
// Returns nCr % p using Fermat's little theorem.
ll nCr(ll n, ll r, int p){
    if (n < r) return 0; // If n<r, then nCr should return 0
    if (r == 0) return 1; // Base case
    return (fac[n] * invfac[r] % p * invfac[n - r] % p) % p;
}

int numberOfWays(int n, int x, int y) {
    fill_arrays(MAX_N - 1, MOD);
    ll ans = 0;
    for(int k = 1; k <= min(n, x); k++){
        ll cur = s[n][k];
        cur *= nCr(x, k, MOD); cur %= MOD;
        cur *= fac[k]; cur %= MOD;
        cur *= power(y, k, MOD); cur %= MOD;
        ans = (ans + cur)%MOD; 
    }
    return ans;
}
};",1420082816
Neal Saxena,neal27,531,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= nums[i]; j++){
                if((j | (j + 1)) == nums[i]){
                    ans[i] = j; break;
                }
            }
        }
        return ans;
    }
};",1420002686
Neal Saxena,neal27,531,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i < n; i++){
            for(int j = 0; j < 31; j++){
                int x = nums[i] - (1<<j);
                if(x < 0) break;
                if((x | (x + 1))==nums[i]) ans[i] = x;
            }
        }
        return ans;
    }
};",1420024045
RTXCR7,RTXCR7,535,3604,cpp,"typedef long long ll;

ll mod = 1e9+7;        // can be changed according to the question
ll fact[1001];    
ll fact_inv[1001];
int A;
ll dp[1001][1001];

ll power(ll a, ll n)
{
    a %= mod;
    ll ans = 1ll;
    while (n > 0)
    {
        if (n & 1ll) ans = ans * a % mod;
        a = a * a % mod;
        n = n >> 1ll;
    }
    return ans;
}

void factorial()
{
    fact_inv[0] = 1ll;
    fact[0] = 1ll;
    for (ll i = 1; i < A; i++)
    {
        fact[i] = (fact[i - 1] * i) % mod;
        fact_inv[i] = power(fact[i], mod - 2);
    }
    

    // Base cases

    for (int i = 0; i <A; i++) {
        dp[i][0] = 0;  // 0 boxes, 0 ways
        dp[i][1] = 1;  // 1 box, only 1 way
    }

    for (int j = 0; j < A; j++) {
        dp[0][j] = 0;  // No objects, 0 ways
        dp[j][j] = 1;  // n objects, n boxes, only 1 way
    }

    // Fill the DP table using recurrence relation
    for (int i = 2; i < A; i++) {
        for (int j = 2; j < A; j++) {
            dp[i][j] = j *1LL* dp[i - 1][j]%mod + dp[i - 1][j - 1];
            dp[i][j] %= mod;
        }
    }

}

ll modncr(ll n, ll r)
{

    if (r > n) return 0ll;
    ll num = fact[n], den = (fact_inv[n - r] * fact_inv[r]) % mod;
    ll ans = (num * den) % mod;
    return ans;
}


class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        A = max(n,x)+1;
        factorial();
        int ans = 0;
        for(int i=1;i<=min(x,n);i++){
            int g1 = modncr(x,i);
            int g2 = power(y,i);
            int g3 = fact[i]*1LL*dp[n][i]%mod;
            int g4 = g1*1LL*g2%mod;
            int g5 = g4*1LL*g3%mod;
            ans+=g5;
            ans %= mod;
        }
        return ans;
    }
};",1420050053
RTXCR7,RTXCR7,535,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto it:nums){
            if(it%2){
                for(int i=0;i<31;i++){
                    if(!(it&(1<<i))){
                        int num = it-(1<<(i-1));
                        ans.push_back(num);
                        break;
                    }
                }
            }
            else ans.push_back(-1);
        }   
        return ans;
    }
};",1420073911
RTXCR7,RTXCR7,535,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int>ans;
        for(auto it:nums){
            if(it%2){
                for(int i=0;i<31;i++){
                    if(!(it&(1<<i))){
                        int num = it-(1<<(i-1));
                        ans.push_back(num);
                        break;
                    }
                }
            }
            else ans.push_back(-1);
        }   
        return ans;
    }
};",1420073373
_rs123,_rs123,536,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int mod = 1000000007;
        long long dp[n+1][x+1];

        for(int i=1;i<=n;i++){
            dp[i][1] = x;
        }

        for(int j=1;j<=x;j++){
            dp[1][j] = 0;
        }

        dp[1][1] = x;

        for(int i=2;i<=n;i++){
            for(int j=2;j<=x;j++){
                if(i<j){
                    dp[i][j]=0;
                    continue;
                }
                dp[i][j] = dp[i-1][j-1]*(x-j+1) + dp[i-1][j]*j;
                dp[i][j]%=mod;
            }
        }

        // for(int i=1;i<=n;i++){
        //     for(int j=1;j<=x;j++){
        //         cout<<dp[i][j]<<"" "";
        //     }
        //     cout<<""\n"";
        // }

        long long ans=0;

        long long pow[x+1];
        pow[0]=1;
        for(int i=1;i<=x;i++){
            pow[i] = y*pow[i-1];
            pow[i]%=mod;
        }

        for(int j=1;j<=x;j++){
            ans += dp[n][j]*pow[j];
            ans%=mod;
        }
        return ans;
    }
};",1420082977
_rs123,_rs123,536,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         int n = nums.size();
        vector<int> ansvec(n);

        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ansvec[i]=-1;
                continue;
            }
            int val = nums[i];
            int pos = val^(val+1);
            pos = log2(pos) - 1;
            int x = (nums[i]^(1<<pos));
            ansvec[i]=x;
        }
        return ansvec;
    }
};",1420012894
_rs123,_rs123,536,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ansvec(n);

        for(int i=0;i<n;i++){
            if(nums[i]==2){
                ansvec[i]=-1;
                continue;
            }
            int val = nums[i];
            int pos = val^(val+1);
            pos = log2(pos) - 1;
            int x = (nums[i]^(1<<pos));
            ansvec[i]=x;
        }
        return ansvec;
    }
};",1420011945
Hridyansh Gupta,hridyansh28,537,3604,cpp,"class Solution {
public:
    static const int MAXN = 1e3+10; 
    const long long MOD = 1e9 + 7;

    long long fac[MAXN + 1];
    long long inv[MAXN + 1];

    /** @return x^n modulo m in O(log p) time. */
    long long exp(long long x, long long n, long long m) {
        x %= m;  // Ensure x is within bounds
        long long res = 1;
        while (n > 0) {
            if (n % 2 == 1) { 
                res = res * x % m; 
            }
            x = x * x % m;
            n /= 2;
        }
        return res;
    }

    /** Precomputes n! from 0 to MAXN. */
    void factorial(long long p) {
        fac[0] = 1;
        for (int i = 1; i <= MAXN; i++) { 
            fac[i] = fac[i - 1] * i % p; 
        }
    }

    /** Precomputes all modular inverse factorials from 0 to MAXN in O(n + log p) time */
    void inverses(long long p) {
        inv[MAXN] = exp(fac[MAXN], p - 2, p);
        for (int i = MAXN; i >= 1; i--) { 
            inv[i - 1] = inv[i] * i % p; 
        }
    }

    /** @return nCr mod p */
    long long choose(long long n, long long r, long long p) {
        if (r > n) return 0;
        if(r==0) return 1;
        return fac[n] * inv[r] % p * inv[n - r] % p;
    }

    int numberOfWays(int n, int x, int y) {
        factorial(MOD);
        inverses(MOD);
        long long ans = 0;
        
        for (int i = 1; i <= x; i++) {
            long long temp = 0;
            for (int j = 0; j <= i; j++) {
                long long term = choose(i, j, MOD) * exp(i - j, n, MOD) % MOD;
                if (j % 2 == 0) {
                    temp = (temp + term) % MOD;  
                } else {
                    temp = (temp - term + MOD) % MOD; 
                }
            }
            temp = temp * exp(y, i, MOD) % MOD * choose(x, i, MOD) % MOD;
            ans = (ans + temp) % MOD;
        }
        
        return (int) ans;
    }
};
",1420083603
Hridyansh Gupta,hridyansh28,537,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> v;
        for(auto val:nums){
            if((val&1)==0){
                v.push_back(-1);
            }
            
            else{
                int ind=0;
                for(int i=0;i<=31;i++){
                    if(((val>>i)&1)==1){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                v.push_back(val-(1<<ind));
            }
        }
        return v;
    }
};",1420005052
Hridyansh Gupta,hridyansh28,537,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> v;
        for(auto val:nums){
            if((val&1)==0){
                v.push_back(-1);
            }
            
            else{
                int ind=0;
                for(int i=0;i<=31;i++){
                    if(((val>>i)&1)==1){
                        ind=i;
                    }
                    else{
                        break;
                    }
                }
                v.push_back(val-(1<<ind));
            }
        }
        return v;
    }
};",1420008566
Dhyanendra Tripathi,Gminor,538,3604,cpp,"#include <cstring>
#define ll long long
using namespace std;

const int MOD = 1e9 + 7;
const int MAX_N = 1000;
const int MAX_X = 1000; 

ll C[MAX_X + 1][MAX_X + 1];
ll S[MAX_N + 1][MAX_X + 1];
ll fact[MAX_X + 1];

void init(int n, int x) {
    memset(C, 0, sizeof(C));
    memset(S, 0, sizeof(S));
    memset(fact, 0, sizeof(fact));
    
    for (ll i = 0; i <= x; ++i) {
        C[i][0] = 1;
        for (ll j = 1; j <= i; ++j) {
            C[i][j] = (C[i - 1][j - 1] % MOD + C[i - 1][j] % MOD) % MOD;
        }
    }
    
    S[0][0] = 1;
    for (ll i = 1; i <= n; ++i) {
        for (ll j = 1; j <= x; ++j) {
            S[i][j] = ((j * S[i - 1][j]) % MOD + S[i - 1][j - 1]) % MOD;
        }
    }
    
    fact[0] = 1;
    for (ll i = 1; i <= x; ++i) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        init(n, x);
        ll ans = 0;
        for (int i = 1; i <= x; i++) {
            // ll power = powl(y, i);
            ll p = 1;
            for (int ii = 0; ii < i; ii++) {
                p = (p * y) % MOD;
            }
            ll ways = C[x][i];
            ways = (ways * fact[i]) % MOD;
            ways = (ways * S[n][i]) % MOD;
            ways = (ways * p) % MOD;
            ans = (ans + ways) % MOD;
        }
        
        return (int)ans;
    }
};
",1420083907
Dhyanendra Tripathi,Gminor,538,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);

        for (int i = 0; i < nums.size(); i++) {
            int val = -1;
            for (int j = 0; j <= nums[i]; j++) {
                int have = (j | (j + 1));
                if (have == nums[i]) {
                    val = j;
                    break;
                }
            }
            ans[i] = val;
        }
        
        return ans;
    }
};",1420001490
Dhyanendra Tripathi,Gminor,538,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            int curr = nums[i];
            int val = INT_MAX;
            int found = 0;
            for (int ii = 0; ii <= 31; ii++) {
                int get = (curr >> ii) & 1;
                if (get == 1) {
                    int full = ~(1 << ii);
                    int tog = curr & full;
                    if (tog < 0) {
                        continue;
                    }
                    // cout << full << "" "" << tog << endl;
                    int fin = (tog | (tog + 1));
                    if (fin == curr) {
                        if (tog < val) {
                            val = tog;
                            found = 1;
                        }
                    }
                }
            }
            
            if (!found) {
                ans[i] = -1;
                continue;
            } 
            ans[i] = val;
        }
        
        return ans;
    }
};",1420052064
Om Amar,OmAmar,540,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        class Factorial:
            def __init__(self, N, mod):
                N += 1
                self.mod = mod
                self.f = [1 for _ in range(N)]
                self.g = [1 for _ in range(N)]
                for i in range(1, N):
                    self.f[i] = self.f[i - 1] * i % self.mod
                self.g[-1] = pow(self.f[-1], mod - 2, mod)
                for i in range(N - 2, -1, -1):
                    self.g[i] = self.g[i + 1] * (i + 1) % self.mod
            def fac(self, n):
                return self.f[n]
            def fac_inv(self, n):
                return self.g[n]
            def combi(self, n, m):
                if m == 0: return 1
                if n < m or m < 0 or n < 0: return 0
                return self.f[n] * self.g[m] % self.mod * self.g[n - m] % self.mod
            def permu(self, n, m):
                if n < m or m < 0 or n < 0: return 0
                return self.f[n] * self.g[n - m] % self.mod
            def catalan(self, n):
                return (self.combi(2 * n, n) - self.combi(2 * n, n - 1)) % self.mod
            def inv(self, n):
                return self.f[n-1] * self.g[n] % self.mod
            

        ans = 0
        MOD = 10**9 + 7
        L = Factorial(1001,MOD)
        k2 = [x]
        k3 = [x]
        def func(n,t):
            MOD = 10**9 + 7
            ans = 0
            k = 1
            for i in range(t,-1,-1):
                ans += k*pow(i,n,MOD)*(L.combi(k2[0],i))
                k *= -1
            return ans

        for i in range(1,x+1):
            if n>=i:
                k2 = [i]
                f = func(n,i)
                ans += f*((pow(y,i,MOD))*L.combi(x,i))
                ans = ans%MOD
            else:
                break
        return ans",1420084334
Om Amar,OmAmar,540,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i]!=2:
                k = nums[i]
                count = 0
                while k%2:
                    k //= 2
                    count += 1
                k *= 2
                k += 1
                for i in range(count-1):
                    k *= 2
                k -= 1
                ans.append(k)
            else:
                ans.append(-1)
        return ans",1420000627
Om Amar,OmAmar,540,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i]!=2:
                k = nums[i]
                count = 0
                while k%2:
                    k //= 2
                    count += 1
                k *= 2
                k += 1
                for i in range(count-1):
                    k *= 2
                k -= 1
                ans.append(k)
            else:
                ans.append(-1)
        return ans",1420000865
Priyanshu Tyagi,priyanshu2511,541,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
          int n = source.length();   int m = pattern.length();
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE;}
        dp[0] = 0;

        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;  }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420076780
Priyanshu Tyagi,priyanshu2511,541,3604,java,"class Solution {
    private static final int MOD = 1000000007;
    public int numberOfWays(int n, int x, int y) {
        long[][] combination = new long[x + 1][x + 1];
        for (int i = 0; i <= x; i++) {
            combination[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combination[i][j] = (combination[i - 1][j - 1] + combination[i - 1][j]) % MOD;
            }
        }

        // Initialize the Stirling numbers of the second kind (S) array
        long[][] stirling = new long[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        // Factorial array
        long[] factorial = new long[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        long totalWays = 0;
        // Main computation loop
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + combination[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * power % MOD) % MOD;
        }

        return (int) totalWays;  
    }
}",1420091369
Priyanshu Tyagi,priyanshu2511,541,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            boolean found = false;
            // Try different values of ans[i] starting from 0
            for (int j = 0; j <= num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
        
            if (!found) {
                ans[i] = -1;
            }
        }
        return ans;
    
    }
}",1420000533
FOOL,pgl7,542,3604,cpp,"
const int facN = 2e6 + 5;
const int mod = 1e9 + 7; // 998244353
int ff[facN], iff[facN];
bool facinit = false;

 
int power(int x, int y){
    if (y == 0) return 1;
 
    int v = power(x, y / 2);
    v = 1LL * v * v % mod;
 
    if (y & 1) return 1LL * v * x % mod;
    else return v;
}
 
void factorialinit(){
    facinit = true;
    ff[0] = iff[0] = 1;
 
    for (int i = 1; i < facN; i++){
        ff[i] = 1LL * ff[i - 1] * i % mod;
    }
 
    iff[facN - 1] = power(ff[facN - 1], mod - 2);
    for (int i = facN - 2; i >= 1; i--){
        iff[i] = 1LL * iff[i + 1] * (i + 1) % mod;
    }
}
 
int C(int n, int r){
    if (!facinit) factorialinit();
 
    if (n == r) return 1;
 
    if (r < 0 || r > n) return 0;
    return 1LL * ff[n] * iff[r] % mod * iff[n - r] % mod;
}



class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        
        int dp[x+1] ,ans = 0;
        dp[1] = 1;
        
        for(int i =2 ; i<= x; i++) 
        {
            int val = 0 ;
            for(int j = 1; j<= i-1 ; j++)  val =  (val +    1LL*C(i,j)*dp[j]%mod)%mod;
            
            dp[i] = (  power( i, n  ) + mod - val )%mod;
        }
        
        for(int  i =1;i<=x; i++)
        {
            ans  = (ans  +  1LL*C(x, i)*dp[i]%mod * power(y,i)%mod )%mod;
        }
        
        return ans;
    }
};",1420092631
FOOL,pgl7,542,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int  i =0  ; i<nums.size();i++)
        {
            int val = nums[i];
            if(val%2==0) { ans[i] =-1;continue;}
            
            
            int cnt= 0 ; 
            while(val!=0)
            {
                if(val%2 ==0 ) break;
                else cnt++;
                val = val/2;
            }
            
            ans[i] = nums[i]  - (1<<(cnt-1));
        }
        
        return ans;
    }
};",1420022369
FOOL,pgl7,542,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for(int  i =0  ; i<nums.size();i++)
        {
            int val = nums[i];
            if(val%2==0) { ans[i] =-1;continue;}
            
            
            int cnt= 0 ; 
            while(val!=0)
            {
                if(val%2 ==0 ) break;
                else cnt++;
                val = val/2;
            }
            
            ans[i] = nums[i]  - (1<<(cnt-1));
        }
        
        return ans;
    }
};",1420022062
Satyendra,biltharesatyendra,543,3604,cpp,"typedef long long ll;
ll mod = 1000000007;
ll fa[1005];
ll po[1005];
ll sterling[1005][1005];
ll mypow(int a, int y)
{
    if(y==0)return 1;
    ll res = mypow(a, y/2);
    res = (res * res)%mod;
    if(y%2)res = (res * a)%mod;
    return res;
}
ll npr(int n, int r)
{
    //printf(""choose %d %d is %lld and %lld %lld\n"",n,r,fa[n],fa[r], fa[n-r]);
    if(r > n)return 0;
    //if(r < 0)return 0;
    if(r == 0)return 1;
    ll num = fa[n];
    ll den = fa[n-r];
    den = mypow(den, mod-2);
    return (num * den)%mod;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        int i;
        fa[0] = 1;
        for(i=1; i<=max(n,x); i++)
            fa[i] = (i * fa[i-1])%mod;
        po[0] = 1;
        for(i=1; i<=n; i++)
            po[i] = (y * po[i-1])%mod;
        sterling[0][0] = 1;
        for(i=1; i<=n; i++){
            sterling[i][0] = 0;
            sterling[i][1] = 1;
        }
        
        int j;
        for(i=1; i<=n; i++)
        {
            for(j=2; j<=i; j++)
            {
                ll fir = sterling[i-1][j];
                ll sec = sterling[i-1][j-1];
                sterling[i][j] = (j * fir + sec)%mod;
            }
        }
        
        ll ans = 0;
       // printf(""solving for %d %d %d\n"",n,x,y);
        for(i=1; i<=x; i++)
        {
            ll ways = sterling[n][i];
         //   printf(""sterling %d %d is %lld\n"",n,i,ways);
            ll choose = npr(x,i);
           // printf(""choosing %d stages out of %d is %lld\n"",i,x,choose);
            ways = (ways * choose)%mod;
            ways = (ways * po[i])%mod;
            //printf(""and power is %lld\n"",po[i]);
            
            ans = ans + ways;
            ans = ans % mod;
            //if(ans > 0)ans -= mod;
        }
        return ans;
        
    }
};",1420054795
Satyendra,biltharesatyendra,543,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        ans = []
        for x in nums:
            if x == 2:
                ans.append(-1)
            else:
                if (x & (x-1))==0:
                    ans.append(x//2)
                else:
                    for j in range(max(0,x-100),x+1):
                        if j | (j+1) == x:
                            break
                    ans.append(j)
        return ans",1420059263
Satyendra,biltharesatyendra,543,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        ans = []
        for x in nums:
            if x == 2:
                ans.append(-1)
            else:
                pos = []
                for j in range(32):
                    if x & (1<<j):
                        y = x - (1<<j)
                        if y | (y+1) == x:
                            pos.append(y)
                pos.sort()
                ans.append(pos[0])
        return ans",1420072370
Fishron,Fishron,544,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        mod=10**9+7
        o=0
        #x=min(x,n)
        fact=[1]*(x+1)
        for i in range(1,x+1):
            fact[i]=i*fact[i-1]
            fact[i]%=mod
        cur=x
        for k in range(1,min(n,x)+1):
            S=cur
            S*=sum((-1)**(k-i)*pow(i,n,mod)*pow(fact[k-i],-1,mod)*pow(fact[i],-1,mod) for i in range(k+1))
            S*=fact[k]
            S%=mod
            o+=(S*pow(y,k,mod))
            o%=mod
            cur*=pow(k+1,-1,mod)*(x-k)
            cur%=mod
            
            #print(k,o,S,n)
        return o
        """"""combs=[1]*(1+x)
        for i in range(1,1+x):
            combs[i]=combs[i-1]*(x-i+1)*pow(i,-1,mod)
            combs[i]%=mod #comb(x,i)
        perms=[1]*(1+n)
        for i in range(1,1+n):
            perms[i]=perms[i-1]*(n-i+1)
            perms[i]%=mod # perm(n,i)

        for k in range(1,min(n,x)+1):
            v=(combs[k]*perms[k])%mod
            v*=pow(k,n-k,mod)
            v*=pow(y,k,mod)
            v%=mod
            #print(k,v)
            o=(o+v)%mod
        return o""""""
#(x!)/((x-k)!k!)
        ",1420093397
Fishron,Fishron,544,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        o=[-1]*n
        for i in range(n):
            if nums[i]==2:
                continue
            cands=[(1<<v)^nums[i] for v in range(nums[i].bit_length())]
            v=inf
            for e in cands:
                if e | (e+1)==nums[i]:
                    v=min(e,v)
            o[i]=v if v!=inf else -1
        return o",1420011249
Fishron,Fishron,544,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        o=[-1]*n
        for i in range(n):
            if nums[i]==2:
                continue
            cands=[(1<<v)^nums[i] for v in range(nums[i].bit_length())]
            v=inf
            for e in cands:
                if e | (e+1)==nums[i]:
                    v=min(e,v)
            o[i]=v if v!=inf else -1
        return o

",1420010761
Shao-Heng,paulchen2713,545,3604,cpp,"// Q4. Find the Number of Possible Ways for an Event
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        const int kMod = 1e9 + 7;
        const int kMax = 1001;  // Since n, x, y <= 1000

        // Precompute factorials and inverse factorials up to kMax
        std::vector<long long> factorial(kMax, 1);
        std::vector<long long> inv_factorial(kMax, 1);

        // Calculate factorials modulo kMod
        for (int i = 1; i < kMax; i++) {
            factorial[i] = factorial[i - 1] * i % kMod;
        }

        // Calculate inverse factorials using Fermat's Little Theorem
        inv_factorial[kMax - 1] = modinv(factorial[kMax - 1], kMod);
        for (int i = kMax - 2; i >= 0; i--) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % kMod;
        }

        // Precompute Stirling numbers of the second kind S(n, k)
        std::vector<std::vector<long long>> S(n + 1, std::vector<long long>(n + 1, 0));
        S[0][0] = 1;  // Base case

        // Calculate Stirling numbers using the recurrence relation
        for (int i = 1; i <= n; i++) {
            S[i][0] = 0;
            for (int j = 1; j <= i; j++) {
                S[i][j] = (j * S[i - 1][j] % kMod + S[i - 1][j - 1]) % kMod;
            }
        }

        long long total = 0;
        int min_k = std::min(n, x);

        // Iterate over possible numbers of non-empty stages
        for (int k = 1; k <= min_k; k++) {
            // Compute permutations P(x, k) = x! / (x - k)!
            long long P_xk = factorial[x] * inv_factorial[x - k] % kMod;

            // Compute term = P(x,k) * S(n,k) * y^k % MOD
            long long term = P_xk * S[n][k] % kMod;
            term = term * modpow(y, k, kMod) % kMod;

            // Add the term to the total number of ways
            total = (total + term) % kMod;
        }

        return (int)total;
    }

    // Function to compute x^y % MOD using binary exponentiation
    long long modpow(long long x, long long y, long long kMod) {
        long long result = 1;
        x %= kMod;
        while (y > 0) {
            if (y % 2 == 1) {
                result = result * x % kMod;
            }
            x = x * x % kMod;
            y /= 2;
        }
        return result;
    }

    // Function to compute modular inverse using Fermat's Little Theorem
    long long modinv(long long x, long long kMod) {
        return modpow(x, kMod - 2, kMod);
    }
};",1420086614
Shao-Heng,paulchen2713,545,3605,cpp,"// Q1. Construct the Minimum Bitwise Array I
class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        const int n = nums.size();
        std::vector<int> result(n);

        // Iterate through each number in nums
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            bool found = false;
            
            // Try to find the smallest result[i] such that result[i] | (result[i] + 1) == num
            for (int res = 1; res <= num; res++) {
                if ((res | (res + 1)) == num) {
                    result[i] = res;
                    found = true;
                    break;
                }
            }

            // If no valid result was found, set result[i] = -1
            if (!found) {
                result[i] = -1;
            }
        }

        return result;
    }
};",1420024234
Shao-Heng,paulchen2713,545,3611,cpp,"// Q2. Construct the Minimum Bitwise Array II
class Solution {
public:
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        const int n = nums.size();
        std::vector<int> result(n);

        for (int i = 0; i < n; ++i) {
            int N = nums[i];
            int min_x = -1;

            // Iterate over each bit position (up to 30 for 32-bit integers)
            for (int bit = 0; bit < 31; ++bit) {
                if (N & (1 << bit)) {  // If the bit at position 'bit' is set
                    // Clear the bit at position 'bit' to create a candidate 'x'
                    int x = N & ~(1 << bit);

                    // Ensure 'x' is positive
                    if (x >= 1) {
                        // Check if 'x' satisfies the condition
                        if ((x | (x + 1)) == N) {
                            // Update 'min_x' if 'x' is smaller
                            if (min_x == -1 || x < min_x) {
                                min_x = x;
                            }
                        }
                    }
                }
            }

            result[i] = min_x;
        }

        return result;
    }
};",1420035737
Vaibhav Singh,vaibhav2740,546,3604,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;

    
    void precomputeFactorials(int max_n, vector<long long>& fact, vector<long long>& inv_fact) {
        fact[0] = 1;
        for (int i = 1; i <= max_n; ++i) {
            fact[i] = fact[i - 1] * i % mod;
        }
        inv_fact[max_n] = modInverse(fact[max_n]);
        for (int i = max_n - 1; i >= 0; --i) {
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod;
        }
    }

    long long modInverse(long long a) {
        long long m = mod, x = 1, y = 0;
        while (a > 1) {
            long long q = a / m;
            long long t = m;
            m = a % m; a = t;
            t = y;
            y = x - q * y; x = t;
        }
        return (x + mod) % mod;
    }

    long long nCr(int n, int r, const vector<long long>& fact, const vector<long long>& inv_fact) {
        if (r > n) return 0;
        return fact[n] * inv_fact[r] % mod * inv_fact[n - r] % mod;
    }

    
    vector<vector<long long>> precomputeStirling(int max_n) {
        vector<vector<long long>> stirling(max_n + 1, vector<long long>(max_n + 1, 0));
        stirling[0][0] = 1;  

        for (int n = 1; n <= max_n; ++n) {
            for (int k = 1; k <= n; ++k) {
                stirling[n][k] = (k * stirling[n - 1][k] % mod + stirling[n - 1][k - 1]) % mod;
            }
        }

        return stirling;
    }

    long long modPow(long long base, long long exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = result * base % mod;
            }
            base = base * base % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        
        int max_n = max(n, x);
        vector<long long> fact(max_n + 1), inv_fact(max_n + 1);
        precomputeFactorials(max_n, fact, inv_fact);
        vector<vector<long long>> stirling = precomputeStirling(max_n);

        long long res = 0;

        for (int i = 1; i <= x; i++) {
            long long combinations = nCr(x, i, fact, inv_fact);
            long long power = modPow(y, i);
            long long ways = stirling[n][i]; 

            
            long long labeledWays = (combinations * power % mod * ways % mod * fact[i] % mod) % mod;

            res = (res + labeledWays) % mod;
        }
        return res;
    }
};
",1420087415
Vaibhav Singh,vaibhav2740,546,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        int n = v.size();
        vector<int>res(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=v[i];j++){
                int val = j|(j+1);
                if(val==v[i]) {
                    res[i] = j; break;
                }
            }
        }
        // for(int x:res) {
        //     if(x==-1) return {-1};
        // }
        return res;
    }
};",1419996101
Vaibhav Singh,vaibhav2740,546,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        ios::sync_with_stdio(0);
        cin.tie(0);
        
        int n = v.size();
        vector<int> res(n, -1); 
        
        for (int j = 0; j < n; j++) {
            int ind = 30;
            if(v[j]==2) continue;
            for (int i = 0; i < 31; i++) {
                if ((1 << i) & v[j])  continue;
                else{
                    ind=i; break;
                }
            }
            // if(v[j]==5) cout<<ind;
            for (int i = ind; i >= 0; i--) {
                // if(j==2&&i==0) cout<<""y"";
                if ((1 << i) & v[j]) {
                    // if(v[j]==5) cout<<""n"";
                    v[j] = v[j] ^ (1<<i); break;
                }
            }
            if(5&(1<<0)) cout<<""y"";
            res[j] = v[j];
        } 
        return res;
    }
};
",1420037449
Shah Jahan Ishaq,ShahJahan19,547,3604,python3,"import math
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = int(1e9 + 7)
        max_k = min(n, x)
        max_value = x
        factorial = [1] * (max_value + 1)
        inv_factorial = [1] * (max_value + 1)

        for i in range(1, max_value + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_factorial[max_value] = pow(factorial[max_value], MOD - 2, MOD)
        for i in range(max_value - 1, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

        def C(a, b):
            if a < b or b < 0:
                return 0
            return factorial[a] * inv_factorial[b] % MOD * inv_factorial[a - b] % MOD

        total = 0
        for k in range(1, max_k + 1):
            comb_x_k = C(x, k)
            y_power_k = pow(y, k, MOD)
            N_n_k = 0
            for i in range(k + 1):
                sign = (-1) ** i
                comb_k_i = C(k, i)
                term = sign * comb_k_i * pow(k - i, n, MOD)
                N_n_k = (N_n_k + term) % MOD

            term = comb_x_k * y_power_k % MOD * N_n_k % MOD
            total = (total + term) % MOD

        return total",1420087839
Shah Jahan Ishaq,ShahJahan19,547,3605,python3,"import math
class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            count = 0
            if not (num & 1):
                ans.append(-1)
                continue
            while num & 1:
                num >>= 1
                count += 1
            mask = (1 << (count - 1)) - 1
            while count > 0:
                num <<= 1
                count -= 1
            num |= mask
            ans.append(num)
        return ans",1420040409
Shah Jahan Ishaq,ShahJahan19,547,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            count = 0
            if not (num & 1):
                ans.append(-1)
                continue
            while num & 1:
                num >>= 1
                count += 1
            mask = (1 << (count - 1)) - 1
            while count > 0:
                num <<= 1
                count -= 1
            num |= mask
            ans.append(num)
        return ans",1420040868
Swapnil Yasasvi,swapnilyasasvi2020,548,3604,cpp,"const int MOD=1e9+7;
#define ll long long
#define MAXN 1100
int binpow(int a,int n)
{
    if(n==0)return 1;
    int p=binpow(a,n/2);
    if(n%2)return 1ll*a*(1ll*p*p%MOD)%MOD;
    return 1ll*p*p%MOD;
}
int fact[MAXN];
int comb(int n,int r)
{
    if(n<0 or r<0 or n<r)return 0;
    int ans=fact[n];
    ans=1ll*ans*binpow(fact[r],MOD-2)%MOD;
    return 1ll*ans*binpow(fact[n-r],MOD-2)%MOD;
}
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        fact[0]=1;
        for(int i=1;i<MAXN;i++)
        {
            fact[i]=1ll*i*fact[i-1]%MOD;
        }

        int dp[n+1][x+1];
        memset(dp,0,sizeof(dp));
        dp[0][0]=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=min(i,x);j++)
            {
                dp[i][j]=1ll*j*dp[i-1][j]%MOD;
                dp[i][j]+=1ll*j*dp[i-1][j-1]%MOD;
                dp[i][j]%=MOD;
            }
        }

        int ans=0;
        for(int i=0;i<=x;i++)
        {
            int val = 1ll*comb(x,i)*binpow(y,x-i)%MOD;
            val = 1ll*val*dp[n][x-i]%MOD;
            ans+=val;
            ans %=MOD;
        }
        return ans;


    }
};",1420088043
Swapnil Yasasvi,swapnilyasasvi2020,548,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2)
            {
                int val  = nums[i]^(nums[i]+1);
                val=val>>1;
                val =  __builtin_popcount(val);
                val--;
                val = 1<<val;
                ans[i]=nums[i]^val;
            }
        }
        return ans;
    }
};",1420025796
Swapnil Yasasvi,swapnilyasasvi2020,548,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2)
            {
                int val  = nums[i]^(nums[i]+1);
                val=val>>1;
                val =  __builtin_popcount(val);
                val--;
                val = 1<<val;
                ans[i]=nums[i]^val;
            }
        }
        return ans;
    }
};",1420027009
Husain Batterywala,husain2088,550,3604,cpp,"const int N = 2e5 + 5, mod = 1e9 + 7;
vector<long long int> fact(N);

class Solution {

long long int pw(long long int a, long long int b) {
	long long int r = 1;
	while(b > 0) {
		if(b & 1) r = (r * a) % mod;
		b /= 2;
		a = (a * a) % mod; 
	}
	return r;
}
long long int nCr(long long int n, long long int k) {
	if(n < k) return 0LL;
	return (fact[n] * pw((fact[n - k] * fact[k]) % mod, mod - 2)) % mod;
}


long long int power(long long x, long long int y, long long int p) 
{ 
    long long int res = 1;     // Initialize result 
 
    x = x % p; // Update x if it is more than or 
                // equal to p
  
    if (x == 0) return 0; // In case x is divisible by p;
 
    while (y > 0) 
    { 
        // If y is odd, multiply x with result 
        if (y & 1) 
            res = (res*x) % p; 
 
        // y must be even now 
        y = y>>1; // y = y/2 
        x = (x*x) % p; 
    } 
    return res; 
} 



public:
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        for(int64_t i = 1; i < N; ++i) fact[i] = (fact[i - 1] * i) % mod;
        //////////////

        long long int nn = n, xx = x, yy = y;
        long long int mod = (1e9)+7;

        vector<long long int> dp(x+1, 0);
        // dp[0]=1;
        dp[1]=x;
        for(int i=1; i<n; i++){

            for(int j=x; j>0; j--){
                if(j<x){
                    dp[j+1]+=dp[j]*(x-j);
                    dp[j+1]%=mod;
                }
                dp[j]*=j;
                dp[j]%=mod;

            }

        }

        // for(auto it : dp) cout<<it<<"" "";

        long long int ans = 0;
        for(long long int i = 1; i<=xx; i++){
            long long int a1 = power(yy, i, mod);
            long long int a2 = dp[i]*a1;
            ans += a2%mod;

            ans%=mod;
        }

        return ans;
    }
};",1420095976
Husain Batterywala,husain2088,550,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++){
            for(int j=0; j<=nums[i]+1; j++){
                int x = j|(j+1);
                if(x==nums[i]){
                    ans[i]=j;
                    break;
                }
            }
        }

        return ans;
        
    }
};",1419997380
Husain Batterywala,husain2088,550,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++){
            if(nums[i]==2){continue;}

            int z = nums[i], ind = 0, nw = 0;
            while((z&(1<<ind))>0){
                nw+= (1<<ind);
                ind++;
            }
            int n2 = nw/2;
            int ex = (z^nw);
            ans[i] = ex+n2;

            // cout<<nw<<""/""<<ind<<""  "";
                
        }

        return ans;

    }
};",1420021029
saicharan87733,saicharan87733,551,3487,java,"
import java.util.Arrays;

class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();
        
        // Initialize dp array
        int[] dp = new int[m + 1];
        for (int i = 0; i <= m; i++) {
            dp[i] = Integer.MAX_VALUE; // Use Integer.MAX_VALUE to represent infinity
        }
        dp[0] = 0; // Base case: 0 characters matched means 0 removals

        // Array to track which indices in the source are targets
        boolean[] isTarget = new boolean[n];
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to fill the dp array
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum removals
        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}

",1420095151
saicharan87733,saicharan87733,551,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways
",1420093204
saicharan87733,saicharan87733,551,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);  // Initialize ans with -1
        
        // Iterate over each number in nums
        for (int i = 0; i < nums.size(); i++) {
            // Try all possible values of x
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;  // Found the smallest x
                    break;  // No need to check larger x values
                }
            }
        }
        
        return ans;
    }
};
",1420096106
CogentCoder73,cogentcoder73,553,3604,cpp,"class Solution {
public:
    long long modPow(int n, int p) {
        long long res = 1;
        long long pw = n % 1000000007;
        while (p > 0) {
            if (p % 2 == 1) res = (res * pw) % 1000000007;
            pw = (pw * pw) % 1000000007;
            p /= 2;
        }
        return res;
    }
    int numberOfWays(int n, int x, int y) {
        long long modFact[1001];
        modFact[0] = 1;
        for (int i = 1; i <= 1000; i++) {
            modFact[i] = (modFact[i - 1] * i) % 1000000007;
        }
        long long modInv[1001];
        modInv[1000] = modPow(modFact[1000], 1000000005);
        for (int i = 999; i >= 0; i--) {
            modInv[i] = (modInv[i + 1] * (i + 1)) % 1000000007;
        }
        long long res = 0;
        long long delta;
        long long prevs[1001];
        prevs[0] = 0;
        for (int s = 1; s <= min(n, x); s++) {
            delta = (((((modPow(s, n) * modFact[x]) % 1000000007) * modInv[s]) % 1000000007) * modInv[x - s]) % 1000000007;
            for (int i = 1; i < s; i++) {
                delta = (delta - (prevs[i] * (((((modFact[x - i] % 1000000007) * modInv[s - i]) % 1000000007) * modInv[x - s]) % 1000000007))) % 1000000007;
            }
            while (delta < 0) delta += 1000000007;
            prevs[s] = delta;
            res = (res + ((delta * modPow(y, s)) % 1000000007)) % 1000000007;
            // cout << s << ""/"" << x << "": "" << delta << ""\n"";
        }
        return res;
    }
};",1420083917
CogentCoder73,cogentcoder73,553,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int k, num1;
        for (int i = 0; i < n; i++) {
            k = nums[i]; num1 = 0;
            while (k % 2 == 1) {
                num1++;
                k /= 2;
            }
            if (num1 == 0) {
                res[i] = -1;
                continue;
            }
            res[i] = nums[i] - round(pow(2, num1 - 1));
        }
        return res;
    }
};",1420007973
CogentCoder73,cogentcoder73,553,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        int k, num1;
        for (int i = 0; i < n; i++) {
            k = nums[i]; num1 = 0;
            while (k % 2 == 1) {
                num1++;
                k /= 2;
            }
            if (num1 == 0) {
                res[i] = -1;
                continue;
            }
            res[i] = nums[i] - round(pow(2, num1 - 1));
        }
        return res;
    }
};",1420008402
MarkovProcess,MarkovProcess,554,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        MOD=10**9+7
        com=[[0]*(x+1) for i in range(x+1)]
        for i in range(x+1):
            com[i][0]=1
            com[i][i]=1
        for i in range(2,x+1):
            for j in range(1,i):
                com[i][j]=(com[i-1][j-1]+com[i-1][j])%MOD
        yxmp=[1]
        for i in range(1,x+1):
            t=(yxmp[-1]*y)%MOD
            yxmp.append(t)
        xnmp=[pow(x-i,n,MOD) for i in range(x+1)]
        res=0
        for i in range(x):
            t=0
            for j in range(x+1-i):
                t+=xnmp[i+j]*((-1)**j)*com[x-i][j]
                t=t%MOD
            t=t*yxmp[x-i]*com[x][x-i]
            t=t%MOD
            res=(res+t)%MOD
        return res
",1420097991
MarkovProcess,MarkovProcess,554,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        def binary(x):
            res=[]
            while x>0:
                res.append(x%2)
                x=x//2
            return res
        def qq(z):
            res=0
            c=1
            for i in range(len(z)):
                res+=z[i]*c
                c*=2
            return res
        res=[]
        for w in nums:
            if w==2:
                res.append(-1)
            else:
                a=binary(w)
                n=len(a)
                z=[]
                if sum(a) ==n:
                    res.append(w//2)
                    continue
                end=n
                for i in range(n):
                    if a[i]==0:
                        end=i
                        break
                for i in range(end-1):
                    z.append(1)
                z.append(0)
                for i in range(end,n):
                    z.append(a[i])
                res.append(qq(z))
        return res",1420022417
MarkovProcess,MarkovProcess,554,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        def binary(x):
            res=[]
            while x>0:
                res.append(x%2)
                x=x//2
            return res
        def qq(z):
            res=0
            c=1
            for i in range(len(z)):
                res+=z[i]*c
                c*=2
            return res
        res=[]
        for w in nums:
            if w==2:
                res.append(-1)
            else:
                a=binary(w)
                n=len(a)
                z=[]
                if sum(a) ==n:
                    res.append(w//2)
                    continue
                end=n
                for i in range(n):
                    if a[i]==0:
                        end=i
                        break
                for i in range(end-1):
                    z.append(1)
                z.append(0)
                for i in range(end,n):
                    z.append(a[i])
                res.append(qq(z))
        return res

                    ",1420022157
Rishikant Kashyap,rkkashyap390,555,3604,cpp,"static bool calculated = false;
static bool calculated2 = false;
const int mod = 1e9+7;
const int factN = 1010;
int fact[1010];
int stirling[1010][1010];

class Solution {
public:

    inline int binary_exponentiation(long long a, int b){
        long long ans = 1;
        while(b){
            if(b&1) ans = (ans*a)%mod;
            a = (a*a)%mod;
            b >>= 1;
        }
        return (int)ans;
    }

    inline int inv(int a){
        return binary_exponentiation(a, mod-2);
    }

    void Factorials(){
        if(calculated) return;
        calculated = true;
        fact[0] = 1;
        for(int i=1; i<factN; i++) fact[i] = int((1LL*i*fact[i-1]) % mod);
        return;
    }

    inline int nCr(int a, int b){
        if(a<b) return 0;
        long long ans;
        ans = (1LL * fact[a] * inv(fact[b])) % mod;
        ans = (ans * inv(fact[a-b])) % mod;
        return (int)ans;
    }

    int rec(int n, int x){
        if(stirling[n][x]!=-1) return stirling[n][x];
        if(x==0 && n==0) return stirling[n][x] = 1;
        if(x==0 || x>n) return stirling[n][x] = 0;
        return stirling[n][x] = ((1LL*x*rec(n-1,x))%mod + rec(n-1,x-1))%mod;
    }

    void Stirlings(){
        if(calculated2) return;
        calculated2 = true;
        memset(stirling, -1, sizeof(stirling));
        for(int i=0; i<1010; i++){
            for(int j=0; j<1010; j++){
                rec(i, j);
            }
        }
    }

    int numberOfWays(int n, int x, int y) {
        Factorials();
        Stirlings();
        long long ans = 0;
        int k = min(n, x); // number of maximum different stages  
        for(int i=1; i<=k; i++){
            long long cans = 1;
            cans*=nCr(x, i); cans%=mod;
            cans*=fact[i]; cans%=mod;
            cans*=stirling[n][i]; cans%=mod;
            cans*=binary_exponentiation(y, i); cans%=mod;
            // cout<<i<<"" ""<<cans<<endl;
            ans = (ans+cans)%mod;
        }
        return ans;
    }
};",1420098147
Rishikant Kashyap,rkkashyap390,555,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(nums[i]==2) ans.push_back(-1);
            else {
                int y, fz=-1;
                for(int j=0; j<32; j++) if((nums[i]&(1<<j)) == 0){fz=j; break;}
                y = nums[i]^((1<<(fz-1)));
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420030549
Rishikant Kashyap,rkkashyap390,555,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for(int i=0; i<n; i++){
            if(nums[i]==2) ans.push_back(-1);
            else {
                int y, fz=-1;
                for(int j=0; j<32; j++) if((nums[i]&(1<<j)) == 0){fz=j; break;}
                y = nums[i]^((1<<(fz-1)));
                ans.push_back(y);
            }
        }
        return ans;
    }
};",1420030912
Krishanu Saha,Krishanu_7,557,3604,cpp,"class Solution {
private:
    const int MODULO = 1e9 + 7;
    vector<vector<long long>> calculateCombs(int maxSize) {
        vector<vector<long long>> combinations(maxSize + 1, vector<long long>(maxSize + 1, 0));
        for (int i = 0; i <= maxSize; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MODULO;
            }
        }
        return combinations;
    }
    
    long long mod_exp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2; 
        }
        return result;
    } 
    
    vector<vector<long long>> calculatePartitions(int numPerformers, int numStages) {
        vector<vector<long long>> partitions(numPerformers + 1, vector<long long>(numStages + 1, 0));
        partitions[0][0] = 1;
        for (int i = 1; i <= numPerformers; ++i) {
            for (int j = 1; j <= numStages; ++j) {
                partitions[i][j] = (j * partitions[i - 1][j] + partitions[i - 1][j - 1]) % MODULO;
            }
        }
        return partitions;
    }

public:
    int numberOfWays(int numPerformers, int numStages, int maxScore) {
        auto factorial = calculateFactorials(numStages);
        auto partition = calculatePartitions(numPerformers, numStages);
        
        long long totalWays = 0;
        auto comb = calculateCombs(numStages);
        for (int bandCount = 1; bandCount <= numStages; ++bandCount) {
            long long scorePower = 1;
            for (int scoreIdx = 0; scoreIdx < bandCount; ++scoreIdx) {
                scorePower = (scorePower * maxScore) % MODULO;
            }
            long long term = comb[numStages][bandCount];
            term = (term * partition[numPerformers][bandCount]) % MODULO;
            term = (term * factorial[bandCount]) % MODULO;
            term = (term * scorePower) % MODULO;
            totalWays = (totalWays + term) % MODULO;
        }
        
        return (int)totalWays;
    }
    vector<long long> calculateFactorials(int maxSize) {
        vector<long long> factorials(maxSize + 1, 1);
        for (int i = 1; i <= maxSize; ++i) {
            factorials[i] = (factorials[i - 1] * i) % MODULO;
        }
        return factorials;
    }
};

",1420098870
Krishanu Saha,Krishanu_7,557,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size(); 
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j; 
                    break;
                }
            }
        }
        return ans;
    }
};",1419992925
Krishanu Saha,Krishanu_7,557,3611,cpp,"class Solution {
    int generateNumber(int num) {
        set<long long int> powerOfTwos;
        for (int i = 0; i <= 34; i++) {
            powerOfTwos.insert(1ll << i);
        }

        // Special case when num is a power of two minus one
        if (powerOfTwos.find(num * 1ll + 1ll) != powerOfTwos.end()) {
            return num / 2;
        }

        int highestSetBit = 0;
        for (int i = 0; i <= 30; i++) {
            if (num & (1 << i)) {
                highestSetBit = i;
            } else {
                break;
            }
        }

        int result = 0;
        for (int i = 30; i > highestSetBit; i--) {
            if (num & (1 << i)) {
                result |= (1 << i);
            }
        }

        for (int i = highestSetBit - 1; i >= 0; i--) {
            if (num & (1 << i)) {
                result |= (1 << i);
            }
        }

        return result;
    }

public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n, -1);

        for (int i = 0; i < n; i++) {
            if (nums[i] % 2 == 0) {
                res[i] = -1;
            } else {
                res[i] = generateNumber(nums[i]);
            }
        }

        return res;
    }
};
",1420058209
Jimmy,JimmyK4542,561,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        M = 10**9+7
        binom = [[1],[1,1]]
        ster = [[1]]
        for j in xrange(1,max(n,x)+2):
            old = binom[-1]
            new = [1]+[old[i]+old[i+1] for i in xrange(j)]+[1]
            binom.append([z%M for z in new])

            old = ster[-1]
            new = [0]+[i*old[i]+old[i-1] for i in xrange(1,j)]+[1]
            ster.append([z%M for z in new])

        ans = 0
        factk = 1
        ypowk = 1
        for k in xrange(1,min(x,n)+1):
            factk *= k
            factk %= M
            ypowk *= y
            ypowk %= M

            term = ster[n][k]*binom[x][k]
            term %= M
            term *= factk
            term %= M
            term *= ypowk
            term %= M

            #print(k,term)

            ans += term
            ans %= M

        return ans",1420093035
Jimmy,JimmyK4542,561,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                count = 0
                while n%2 == 1:
                    count += 1
                    n /= 2
                n *= 2
                count -=1 
                while count > 0:
                    n = 2*n+1
                    count -=1
                ans.append(n)
        
        return ans",1420002264
Jimmy,JimmyK4542,561,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                count = 0
                while n%2 == 1:
                    count += 1
                    n /= 2
                n *= 2
                count -=1 
                while count > 0:
                    n = 2*n+1
                    count -=1
                ans.append(n)
        
        return ans",1420003639
Edward Lee,EdwardLeeMacau,562,3604,cpp,"class Solution {
public:
    #define MOD 1'000'000'007;
    using LL = long long;
    int numberOfWays(int N, int X, int Y) {
        std::vector<LL> dp(X+1); 
        LL ans = 0;
        LL y;
        int n, x, w, i;

        dp[1] = X;
        for (n = 2; n <= N; ++n) {
            for (i = X; i; --i) {
                dp[i] = (dp[i-1] * (X - (i - 1)) + dp[i] * i) % MOD;
            }

            // for (i = 0; i < X + 1; ++i) {
            //     cout << setw(4) << dp[i];
            // }
            // cout << endl;
        }

        ans = 0; y = 1;
        for (w = 1; w <= X; ++w) {
            y = (y * Y) % MOD; // power
            ans = (ans + dp[w] * y) % MOD;
        }

        return ans;
    }
};",1420093102
Edward Lee,EdwardLeeMacau,562,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [0] * n

        table = dict()
        for i in range(1000, 0, -1):
            table[i | (i + 1)] = i

        for i in range(n):
            res[i] = table.get(nums[i], -1)

        return res
",1419999648
Edward Lee,EdwardLeeMacau,562,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        const int n = nums.size();
        vector<int> res(n, 0);

        int pos = 0;
        int x;
        int i;
        for (i = 0; i < n; ++i) {
            for (x = nums[i], pos = 0; x & (1 << pos); ++pos)
                ;

            if (pos == 0) {
                res[i] = -1;
                continue;
            }
            
            res[i] = x ^ (1 << (pos - 1));
            // cout << x << setw(4) << (1 << (pos - 1)) << setw(4) << res[i] << endl;
        }

        return res;

    }
};",1420015352
Nampally Adarsh,Adarsh_N34,563,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        
        // Initialize dp array to track the minimum cost of matching the pattern
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0; // Base case: no characters matched means 0 cost
        
        // Boolean array to mark target indices
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // DP approach to find the minimum cost to match the entire pattern
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate maximum removals: total target indices minus the minimum cost to match the pattern
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420100033
Nampally Adarsh,Adarsh_N34,563,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        
        while params:
            break
        

        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        

        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways
        ",1420095753
Nampally Adarsh,Adarsh_N34,563,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            int k = nums[i];
            for(int n=1;n<=k;n++){
                if((n | (n+1)) == k){
                    ans[i] = n;
                    break;
                }
            }
        }
        return ans;
    }
};",1420038359
Sarthak Mathur,WORTH_IT,564,3604,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(new Solution().numberOfWays(4, 4, 1));
//     }
// }

class Solution {

    static Combinatorics C = new Combinatorics(1001);

    public int numberOfWays(int n, int x, int y) {
        Mint Y = new Mint(y);
        Mint ans = Mint.ZERO;
        Mint[] count = new Mint[x + 1];
        count[0] = Mint.ZERO;

        Function<Integer, Mint> calcWays = new Function<Integer, Mint>() {
            @Override
            public Mint apply(Integer i) {
                Mint ans = new Mint(i).pow(n);
                for (int j = 1; j < i; j++)
                    ans = ans.sub(count[j].mul(C.C(i, j)));

                return ans;
            }
        };

        for (int i = 1; i <= Math.min(n, x); i++) { // i Stages used
            count[i] = calcWays.apply(i);
            ans = ans.add(Y.pow(i).mul(C.C(x, i).mul(count[i])));
        }

        return (int) ans.get();
    }
}

final class Mint { // 1000000007 998244353
    public static long mod = 1000000007;
    public static boolean modIsPrime = true;
    private final long val;

    public static final Mint ZERO = new Mint(0L);
    public static final Mint ONE = new Mint(1L);

    public static long norm(long val) {
        return (val %= mod) < 0 ? val + mod : val;
    }

    public static long norm(Integer val) {
        return norm(val.longValue());
    }

    public Mint(long val) {
        this.val = norm(val);
    }

    public Mint() {
        this(0);
    }

    public Mint(Mint arg) {
        this(arg.val);
    }

    public Mint(Integer arg) {
        this(arg.longValue());
    }

    public long get() {
        return val;
    }

    public Mint add(long arg) {
        return new Mint(this.val + norm(arg));
    }

    public Mint add(Mint arg) {
        return add(arg.val);
    }

    public Mint add(Integer arg) {
        return add(arg.longValue());
    }

    public Mint add(long... args) {
        Mint sum = this;
        for (long a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Mint... args) {
        Mint sum = this;
        for (Mint a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint add(Integer... args) {
        Mint sum = this;
        for (Integer a : args)
            sum = sum.add(a);
        return sum;
    }

    public Mint sub(long arg) {
        return new Mint(val - norm(arg));
    }

    public Mint sub(Mint arg) {
        return sub(arg.val);
    }

    public Mint sub(Integer arg) {
        return sub(arg.longValue());
    }

    public Mint mul(long arg) {
        return new Mint(this.val * norm(arg));
    }

    public Mint mul(Mint arg) {
        return mul(arg.val);
    }

    public Mint mul(Integer arg) {
        return mul(arg.longValue());
    }

    public Mint mul(long... args) {
        Mint product = this;
        for (long a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint mul(Mint... args) {
        Mint product = this;
        for (Mint a : args)
            product = product.mul(a);
        return product;
    }

    public Mint mul(Integer... args) {
        Mint product = this;
        for (Integer a : args)
            product = product.mul(norm(a));
        return product;
    }

    public Mint div(Mint arg) {
        return mul(arg.inv());
    }

    public Mint div(long arg) {
        return div(new Mint(arg));
    }

    public Mint div(Integer arg) {
        return div(new Mint(arg));
    }

    public Mint inv() {
        if (!modIsPrime)
            throw new ArithmeticException(val + "" cannot have inverse with mod "" + mod + ""!"");
        return pow(mod - 2);
    }

    public Mint pow(long arg) {
        if (arg < 0)
            return pow(-arg).inv();
        Mint pow = Mint.ONE;
        Mint temp = this;
        while (arg > 0) {
            if ((arg & 1) == 1)
                pow = pow.mul(temp);
            temp = temp.mul(temp);
            arg = arg >> 1;
        }
        return pow;
    }

    public Mint pow(Mint arg) {
        return pow(arg.val);
    }

    public Mint pow(Integer arg) {
        return pow(arg.longValue());
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Mint mint = (Mint) o;
        return val == mint.val;
    }

    @Override
    public String toString() {
        return Long.toString(val);
    }
}

class Combinatorics {

    Mint[] factorial, inverseFactorial;

    public Combinatorics(int n) {
        factorial = new Mint[n + 10];
        inverseFactorial = new Mint[n + 10];
        precompute(n + 10);
    }

    public Combinatorics() {
        this(1000000);
    }

    private void precompute(int n) {
        factorial[0] = Mint.ONE;
        for (int i = 1; i < n; i++)
            factorial[i] = factorial[i - 1].mul(i);

        inverseFactorial[n - 1] = factorial[n - 1].inv();
        for (int i = n - 2; i >= 0; i--)
            inverseFactorial[i] = inverseFactorial[i + 1].mul(i + 1);
    }

    public Mint fact(int n) {
        return factorial[n];
    }

    public Mint invFact(int n) {
        if (n < 0)
            return Mint.ZERO;
        return inverseFactorial[n];
    }

    public Mint C(int n, int r) {
        if (r < 0 || r > n)
            return Mint.ZERO;
        return factorial[n].mul(inverseFactorial[r], inverseFactorial[n - r]);
    }

    public static long C(int n, int r, Combinatorics comb, boolean modular) {
        if (modular)
            return comb.C(n, r).get();

        if (r > n - r)
            r = n - r;
        long ans = 1;
        for (int i = r + 1; i <= n; i++) {
            ans *= i;
            ans /= i - r;
        }
        return ans;
    }

    public static long C(int n, int r, Combinatorics comb) {
        return comb == null ? C(n, r, null, false) : C(n, r, comb, true);
    }

    public Mint P(int n, int r) {
        if (r > n || r < 0)
            return Mint.ZERO;
        return factorial[n].mul(inverseFactorial[n - r]);
    }

    public static long P(int n, int r, Combinatorics comb, boolean modular) {
        if (modular)
            return comb.P(n, r).get();
        long ans = 1;
        for (int i = n - r + 1; i <= n; i++)
            ans *= i;
        return ans;
    }

    public static long P(int n, int r, Combinatorics comb) {
        return comb == null ? P(n, r, null, false) : P(n, r, comb, true);
    }

    public Mint inv(int n) {
        return inverseFactorial[n].mul(factorial[n - 1]);
    }

    @Override
    public String toString() {
        return ""Combinatorics till "" + (factorial.length - 1);
    }
}",1420094431
Sarthak Mathur,WORTH_IT,564,3605,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(Arrays.toString(new Solution().minBitwiseArray(List.of(11, 13, 31))));
//     }
// }

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int x = nums.get(i);
            if (x == 2) {
                ans[i] = -1;
                continue;
            }

            int last0 = 1 << Integer.numberOfTrailingZeros(~x);
            ans[i] = (x & ~(last0 >> 1)) | ((x & (last0 - 1)) >> 1);
            if ((ans[i] | (ans[i] + 1)) != x)
                ans[i] = x - 1;
        }

        return ans;
    }
}",1420004834
Sarthak Mathur,WORTH_IT,564,3611,java,"// import java.util.*;
// import java.util.function.*;

// public class Main {
//     public static void main(String[] args) throws Exception {
//         System.out.println(Arrays.toString(new Solution().minBitwiseArray(List.of(11, 13, 31))));
//     }
// }

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int x = nums.get(i);
            if (x == 2) {
                ans[i] = -1;
                continue;
            }

            int last0 = 1 << Integer.numberOfTrailingZeros(~x);
            ans[i] = (x & ~(last0 >> 1)) | ((x & (last0 - 1)) >> 1);
            if ((ans[i] | (ans[i] + 1)) != x)
                ans[i] = x - 1;
        }

        return ans;
    }
}",1420005254
Vaibhav Singh,vaibhav_1710,565,3604,java,"class Solution {
    
    private final int MOD = 1000000007;
    
     private  long factorial(int n) {
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result = (result * i) % MOD;
        }
        return result;
    }

  
    private  long binomialCoefficient(int n, int k) {
        if (k > n || k < 0) return 0; // Not possible
        long numerator = 1;
        long denominator = 1;

        // Calculate n! / (k! * (n - k)!)
        for (int i = 0; i < k; i++) {
            numerator = (numerator * (n - i)) % MOD;
            denominator = (denominator * (i + 1)) % MOD;
        }

        // Modular inverse of denominator
        denominator = modularInverse(denominator);
        return (numerator * denominator) % MOD;
    }

   
    private  long modularInverse(long a) {
        return pow(a, MOD - 2);
    }

    
    public int numberOfWays(int n, int x, int y) {
        
        
        long[][] dp = calculateDP(n, Math.min(x,n));

      
       long totalWays = 0;

        // Sum up dp[n][i] * C(x, i) * i! * pow(y, i) for i from 1 to x
        for (int i = 1; i <= Math.min(x, n); i++) {
            long ways = dp[n][i] * binomialCoefficient(x, i) % MOD; // Choose i groups from x
            ways = (ways * factorial(i)) % MOD; // Multiply by i!
            ways = (ways * pow(y, i)) % MOD; // Multiply by y^i
            totalWays = (totalWays + ways) % MOD; // Accumulate total ways
        }
        
        return (int)totalWays;
    }
    
    private  long pow(long a, long b) {
        long result = 1;
        while (b > 0) {
            if ((b & 1) == 1) {
                result = (result * a) % MOD;
            }
            a = (a * a) % MOD;
            b >>= 1;
        }
        return result;
    }
    
    private  long[][] calculateDP(int n, int x) {
      
        long[][] dp = new long[n + 1][x + 1];

      
        dp[0][0] = 1l;

        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, x); j++) {
                dp[i][j] = (dp[i - 1][j - 1] + (j * dp[i - 1][j]) % MOD) % MOD;
            }
        }
        return dp;
    }


}",1420101962
Vaibhav Singh,vaibhav_1710,565,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int ans[] = new int[n];
        
        for(int i=0;i<n;i++){
            if(nums.get(i)==2){
                ans[i]=-1;
            }else{
                int cnt=0;
                for(int j=0;j<=30;j++){
                    if(((1<<j)&(nums.get(i)))>0){
                        cnt++;
                    }else{
                        break;
                    }
                }
                   
                        if(cnt==1){
                            ans[i] = nums.get(i)-1;
                        }else{
                            int v = 0;
                            for(int j=0;j<=30;j++){
                                if(((1<<j)&(nums.get(i)))>0){
                                    if(cnt>1){
                                        v |= (1<<j);
                                        cnt--;
                                    }else if(cnt==1){
                                        cnt--;
                                    }else{
                                        v |= (1<<j);
                                    }
                                }
                            }
                            ans[i] = v;
                        }
                    
                }
        }
        return ans;
    }
}",1420025606
Vaibhav Singh,vaibhav_1710,565,3611,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int ans[] = new int[n];
        
        for(int i=0;i<n;i++){
            if(nums.get(i)==2){
                ans[i]=-1;
            }else{
                int cnt=0;
                for(int j=0;j<=30;j++){
                    if(((1<<j)&(nums.get(i)))>0){
                        cnt++;
                    }else{
                        break;
                    }
                }
                   
                        if(cnt==1){
                            ans[i] = nums.get(i)-1;
                        }else{
                            int v = 0;
                            for(int j=0;j<=30;j++){
                                if(((1<<j)&(nums.get(i)))>0){
                                    if(cnt>1){
                                        v |= (1<<j);
                                        cnt--;
                                    }else if(cnt==1){
                                        cnt--;
                                    }else{
                                        v |= (1<<j);
                                    }
                                }
                            }
                            ans[i] = v;
                        }
                    
                }
        }
        return ans;
    }
}",1420025374
wshldwps,wshldwps,566,3604,python,"class Solution(object):
    def numberOfWays(self, n, x, y):
        """"""
        :type n: int
        :type x: int
        :type y: int
        :rtype: int
        """"""
        out = 0
        DP = defaultdict(int) # k1 people, k2 bands#, v times
        DP[(1,1)] = x * y
        for i in range(2, n+1):
            # ith people
            for j in range(1, min(i, x + 1)):
                # j bands
                # add to j
                DP[(i, j)] = (DP[(i, j)] + DP[(i-1, j)] * j) % (10**9 + 7)
                # add to new band
                DP[(i, j+1)] = (DP[(i, j+1)] + DP[i-1, j] * (x - j) * y) % (10**9 + 7)
        for i in range(1, x + 1):
            out = (out + DP[(n, i)]) % (10**9 + 7)


        return out",1420102034
wshldwps,wshldwps,566,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        out = [-1 for i in range(len(nums))]
        for i in range(len(nums)):
            for k in range(0, 1001):
                if (k | (k+1)) == nums[i]:
                    out[i] = k
                    break
        return out",1419998256
wshldwps,wshldwps,566,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        """"""
        :type nums: List[int]
        :rtype: List[int]
        """"""
        out = [-1 for i in range(len(nums))]
        for i in range(len(nums)):
            bits = self.n2b(nums[i])
            if (bits[0] == 1):
                for j in range(31):
                    if bits[j+1] == 1:
                        bits[j] = 0
                    else:
                        break
                num = self.b2n(bits) - 1
                out[i] = num
        return out
    
    def n2b(self, number):
        bits = [0 for i in range(31)]
        for i in range(30, -1, -1):
            if number / 2 ** i >= 1:
                bits[i] = 1
            number = number % 2 ** i
        return bits

    def b2n(self, bits):
        num = 0
        for i in range(31):
            num += bits[i] * 2 ** i
        return num",1420061269
liuvivi412,liuvivi412,568,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        max_nk = max(n, x) + 10
        mod = 10**9 + 7

        fact = [1] * max_nk
        inv_fact = [1] * max_nk
        for i in range(1, max_nk):
            fact[i] = fact[i - 1] * i % mod
        inv_fact[max_nk - 1] = pow(fact[max_nk - 1], mod - 2, mod)
        for i in range(max_nk - 2, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod

        total = 0
        min_k = min(n, x)
        for k in range(1, min_k + 1):
            inv_k_fact = inv_fact[k]
            S = 0
            for j in range(k + 1):
                sign = -1 if j % 2 else 1
                C_kj = fact[k] * inv_fact[j] % mod * inv_fact[k - j] % mod
                pow_term = pow(k - j, n, mod)
                S = (S + sign * C_kj * pow_term) % mod
            S = S * inv_k_fact % mod

            C_xk = fact[x] * inv_fact[k] % mod * inv_fact[x - k] % mod

            k_fact = fact[k]

            y_pow_k = pow(y, k, mod)

            term = C_xk * k_fact % mod * S % mod * y_pow_k % mod

            total = (total + term) % mod
        return total",1420096561
liuvivi412,liuvivi412,568,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        ans=[]
        for num in nums:
            if num==2:
                ans.append(-1)
            else:
                res=num//2
                while res|res+1!=num:
                    res+=1
                ans.append(res)
        return ans",1420022577
liuvivi412,liuvivi412,568,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # 100 101
        # 1001 1011
        # 11 111
        # 1100 1101
        n=len(nums)
        ans=[]
        for num in nums:
            if num==2:
                ans.append(-1)
            else:
                bin_num=list(bin(num))[2:]
                i=len(bin_num)-1
                while i>=0 and bin_num[i]=='1':
                    i-=1
                bin_num[i+1]='0'
                ans.append(int(''.join(bin_num),2))
        return ans",1420044451
Skyler Tsai,SkylerTsai,569,3604,python3,"from math import factorial

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        def Cn_x(n, x):
            if x > n: return 0
            return factorial(n) // (factorial(x) * factorial(n - x))
        
        mod = 10 ** 9 + 7
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % mod
        
        ret = 0
        for i in range(1, n + 1):
            temp = Cn_x(x, i) * dp[n][i] * factorial(i) * pow(y, i, mod)
            ret += temp % mod
        
        return ret % mod
        
            ",1420090301
Skyler Tsai,SkylerTsai,569,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for num in nums:
            if num % 2 == 0: 
                ret.append(-1)
                continue
            tar = bin(num)[2:]
            x = 0
            for i in range(len(tar) - 1, -1, -1):
                if tar[i] != '1': break
                x += 1
            temp = tar[:len(tar) - x] + '0' + (x - 1) * '1'
            #print(num, tar, x, temp)
            ret.append(int(temp, 2))
        return ret",1420016376
Skyler Tsai,SkylerTsai,569,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ret = []
        for num in nums:
            if num % 2 == 0: 
                ret.append(-1)
                continue
            tar = bin(num)[2:]
            x = 0
            for i in range(len(tar) - 1, -1, -1):
                if tar[i] != '1': break
                x += 1
            temp = tar[:len(tar) - x] + '0' + (x - 1) * '1'
            #print(num, tar, x, temp)
            ret.append(int(temp, 2))
        return ret",1420017042
sparshjaggi2307,sparshjaggi2307,570,3604,cpp,"#include <vector>

using namespace std;

class Solution {
private:
    const int MOD = 1e9 + 7;  // Constant for modulo operation to prevent overflow

    // Function to compute binomial coefficients using Pascal's triangle
    vector<vector<long long>> computeBinomialCoefficients(int limit) {
        vector<vector<long long>> binomials(limit + 1, vector<long long>(limit + 1, 0));
        for (int i = 0; i <= limit; ++i) {
            binomials[i][0] = 1;  // Base case: C(n, 0) = 1
            for (int j = 1; j <= i; ++j) {
                // Using the recurrence relation to fill the table
                binomials[i][j] = (binomials[i - 1][j - 1] + binomials[i - 1][j]) % MOD;
            }
        }
        return binomials;
    }

    // Function to compute the number of partitions of n using k parts
    vector<vector<long long>> computePartitions(int total, int parts) {
        vector<vector<long long>> partitions(total + 1, vector<long long>(parts + 1, 0));
        partitions[0][0] = 1;  // One way to partition zero
        
        // Filling the partition table
        for (int i = 1; i <= total; ++i) {
            for (int j = 1; j <= parts; ++j) {
                // The number of ways to partition using the current number
                partitions[i][j] = (j * partitions[i - 1][j] + partitions[i - 1][j - 1]) % MOD;
            }
        }
        return partitions;
    }

    // Function to compute factorials up to a given size
    vector<long long> computeFactorials(int size) {
        vector<long long> factorials(size + 1, 1);  // Initialize factorials
        for (int i = 1; i <= size; ++i) {
            // Computing factorial iteratively
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }
        return factorials;
    }

public:
    // Main function to calculate the number of ways
    int numberOfWays(int n, int x, int y) {
        // Compute combinations, partitions, and factorials
        auto binomials = computeBinomialCoefficients(x);
        auto partitions = computePartitions(n, x);
        auto factorials = computeFactorials(x);
        
        long long totalWays = 0;  // Variable to store the total count of ways
        
        // Iterate through each possible number of parts
        for (int k = 1; k <= x; ++k) {
            long long powerValue = 1;  // Initialize power term
            for (int p = 0; p < k; ++p) {
                // Calculate y^k for the current k
                powerValue = (powerValue * y) % MOD;
            }
            long long currentContribution = binomials[x][k];  // Current contribution from combinations
            // Combine contributions from partitions and factorials
            currentContribution = (currentContribution * partitions[n][k]) % MOD;
            currentContribution = (currentContribution * factorials[k]) % MOD;
            currentContribution = (currentContribution * powerValue) % MOD;
            totalWays = (totalWays + currentContribution) % MOD;  // Accumulate the total
        }
        
        return static_cast<int>(totalWays);  // Return the final result as an integer
    }
};
",1420061248
sparshjaggi2307,sparshjaggi2307,570,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    // Helper function to find the smallest x such that (x | (x + 1)) equals the given prime number
    int findMinimumX(int target) {
        // Iterate through numbers starting from 1 up to the target
        for (int candidate = 1; candidate <= target; ++candidate) {
            // Check if ORing candidate and candidate+1 equals the target
            if ((candidate | (candidate + 1)) == target) {
                return candidate;  // Return the smallest valid candidate
            }
        }
        return -1;  // If no valid candidate is found, return -1
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();  // Get the size of the input array
        vector<int> result(size, -1);  // Initialize the result array with -1 as default values

        // Loop through each element of the input array
        for (int index = 0; index < size; ++index) {
            // For each element, find the corresponding minimum value using findMinAns
            result[index] = findMinimumX(nums[index]);
        }

        return result;  // Return the computed result array
    }
};
",1420024536
sparshjaggi2307,sparshjaggi2307,570,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    // Function to find the minimal bitwise representation for each number in the input array
    std::vector<int> minBitwiseArray(std::vector<int>& nums) {
        int size = nums.size(); // Get the size of the input array
        std::vector<int> result(size); // Initialize the answer vector of the same size
        
        // Iterate through each number in the input array
        for (int index = 0; index < size; index++) {
            int currentNum = nums[index]; // Current number being processed
            int minCandidate = INT_MAX; // Initialize the minimal candidate to the maximum integer value
            bool isCandidateFound = false; // Flag to indicate if a valid candidate was found
            
            // Check each bit position from 0 to 30
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                // If the current bit is set in the number
                if ((currentNum >> bitPosition) & 1) {
                    // Create a candidate by turning off the current bit
                    int modifiedNum = currentNum & ~(1 << bitPosition);
                    
                    // Skip if modifiedNum is negative (should not happen in this case)
                    if (modifiedNum < 0) continue;
                    
                    // Check if the modified number is valid by ensuring it forms the same number
                    // when OR-ed with (modifiedNum + 1)
                    if ((modifiedNum | (modifiedNum + 1)) == currentNum) {
                        // If the modified number is less than the current minimal candidate, update it
                        if (modifiedNum < minCandidate) {
                            minCandidate = modifiedNum; // Update minimal candidate
                            isCandidateFound = true; // Set found to true
                        }
                    }
                }
            }
            
            // If a valid candidate was found, store it; otherwise, store -1
            if (isCandidateFound) {
                result[index] = minCandidate; // Store the minimal candidate
            } else {
                result[index] = -1; // No valid candidate found
            }
        }
        
        return result; // Return the result vector
    }
};
",1420083605
Surya Teja,suryacr7,572,3604,cpp,"#define ll long long
class Solution {
vector<int>factorial;
public:
const int N=1e9+7;
    int pw(int a,int b,int c){
    ll ans=1;
    while(b>0){
        if(b&1){
            ans=(ans%N*1ll*a%c)%c;
        }
        a=(a%c*1ll*a%c)%c;
        b>>=1;
    }
    return ans;
}
    
int fac(int a, int b){
ll x=factorial[a]%N;
ll d=(factorial[b]*1ll*factorial[a-b])%N;
ll y=pw(d,N-2,N);
ll ans=(x%N*y)%N;
return ans;
}
    
    ll sur(int n,int r){
        ll ans=0;
        for(int i=0;i<r;i++){
            if(i&1){
                ans-=(fac(r,i)*1ll*(pw(r-i,n,N)))%N;
                ans%=N;
                (ans+=N)%=N;
            }else{
                ans+=(fac(r,i)*1ll*(pw(r-i,n,N)))%N;
                ans%=N;
            }
        }
        return ans%N;
    }
    
    int numberOfWays(int n, int x, int y) {
    factorial.resize(1010);
    factorial[0]=1;
for(int i=1;i<=1e3;++i){
    factorial[i]=(factorial[i-1]*1ll*i)%N;
}
        ll ans=0;
        for(int i=1;i<=min(n,x);i++){
            ll temp=1;
            temp*=fac(x,i);
            temp=temp*1ll*pw(y,i,N);
            temp%=N;
            temp=temp*1ll*sur(n,i);
            temp%=N;
            (ans+=temp)%=N;
            // cout<<ans<<"" "";
        }
        return ans;
        
    }
};",1420090948
Surya Teja,suryacr7,572,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        int n=v.size();
        
        for(int i=0;i<n;i++){
            int x=log2(v[i])+1;
            int y=__builtin_popcount(v[i]);
            if(x==y){
                ans.push_back((1<<(x-1))-1);
            }else{
                int temp=v[i];
                int last=0;
                while(temp&1){
                    temp/=2;
                    last++;
                }
                temp<<=last;
                if(last){
                    temp|=((1<<(last-1))-1);
                    ans.push_back(temp);
                }else{
                    ans.push_back(-1);
                }
                
            }
        }
        return ans;
    }
};",1420007273
Surya Teja,suryacr7,572,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& v) {
        vector<int> ans;
        int n=v.size();
        
        for(int i=0;i<n;i++){
            int x=log2(v[i])+1;
            int y=__builtin_popcount(v[i]);
            if(x==y){
                ans.push_back((1<<(x-1))-1);
            }else{
                int temp=v[i];
                int last=0;
                while(temp&1){
                    temp/=2;
                    last++;
                }
                temp<<=last;
                if(last){
                    temp|=((1<<(last-1))-1);
                    ans.push_back(temp);
                }else{
                    ans.push_back(-1);
                }
                
            }
        }
        return ans;
    }
};",1420006737
Atharv Tiwari,atharv_tiwari,573,3604,cpp,"class Solution {
public:
    long long power_fn (long long a, long long b, long long mod)
    {
        long long x = a;
        long long ans = 1;

        while (b != 0)
        {
            if (b % 2 == 1)
            {
                ans *= x;
                ans %= mod;
            }

            b /= 2;

            x *= x;
            x %= mod;
        }

        return ans;
    }

    long long modulo_inverse (long long n, long long mod)
    {
        return power_fn (n, (mod - 2), mod);
    }

    long long modulo_inverse_factorial (long long n, long long mod, vector <long long> &fct)
    {
        return power_fn (fct[n], (mod - 2), mod);
    }

    long long nCr (long long n, long long r, long long mod, vector <long long> &fct, vector <long long> &m_i)
    {
        if (n < r)
        {
            return 0;
        }

        if (r == 0)
        {
            return 1;
        }

        long long x, i, k;
        x = fct[n];

        x *= m_i[r];
        x = (x % mod);

        x *= m_i[n - r];
        x = (x % mod);

        return x;
    }

    void helper (vector <long long> &fct, vector <long long> &m_i) 
    {
        long long num = 1;
        fct[0] = 1;
        
        long long mod = 1000000007;
        for (long long i = 1; i < 3001; i++)
        {
            num *= i;
            num = (num % mod);
            fct[i] = num;
        }
        
        for (long long i = 0; i < 3001; i++)
        {
            m_i[i] = modulo_inverse_factorial (i, mod, fct);
        }
    }

    int numberOfWays(int xx, int nn, int yy) 
    {
        vector <long long> fct (3001, 0);
        vector <long long> m_i (3001, 0);

        helper (fct, m_i);
        long long i, n, x, y;

        n = nn, x = xx, y = yy;
        long long mod = 1000000007;

        long long ans = 0;
        // n stages

        for (i = 1; i <= n; i++) 
        {
            long long num = nCr (n, i, mod, fct, m_i);
            long long val = power_fn (i, x, mod);

            bool check = false;
            for (int j = (i - 1); j > 0; j --) 
            {
                long long temp = power_fn (j, x, mod);
                temp *= nCr (i, j, mod, fct, m_i), temp %= mod;

                if (check) 
                {
                    val += temp;
                }
                else 
                {
                    val -= temp;
                }

                if (val < 0) 
                {
                    val += mod;
                }

                val %= mod;
                check ^= true;
            }           

            long long sum = (num * val);
            sum %= mod;

            sum *= power_fn (y, i, mod);
            sum %= mod;

            ans += sum;
            ans %= mod;

            // cout << ans << "" "" << num << "" "" << val << "" "" << sum << endl;
        }

        return ans;
    }
};",1420104754
Atharv Tiwari,atharv_tiwari,573,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        vector <int> vt (2001, -1);
        for (int i = 1000; i > 0; i--) 
        {
            vt[(i | (i + 1))] = i;
        }

        int n = nums.size();
        vector <int> vans;

        for (int i = 0; i < n; i++) 
        {
            vans.push_back (vt[nums[i]]);
        } 

        return vans;  
    }
};",1420005821
Atharv Tiwari,atharv_tiwari,573,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n = nums.size();
        vector <int> vans;

        for (int i = 0; i < n; i++) 
        {
            int num = 1, val = nums[i];
            if (nums[i] == 2) 
            {
                vans.push_back (-1);
                continue;
            }

            while (num <= val) 
            {
                if ((num & val) == 0) 
                {
                    break;
                }

                num *= 2;
            }

            int ans = 0;
            
            if (num <= val) 
            {
                ans += (val - num);
                ans ++;
            }
           
            ans += ((num - 1) / 2);
            vans.push_back (ans);
        }

        return vans;
    }
};",1420017529
Saurav Kumar,kumar_23,575,3604,cpp,"class Solution {
public:
#define ll long long
    const ll m = 1e9 + 7;
    ll fac[1001], inv[1001];

    ll bin(ll x, ll p){
        if(p==0)return 1;
        ll full = bin(x, p/2);
        full = (full*full)%m;
        if(p%2==0)return full;
        return (full*x)%m;
    }

    ll ncr(ll n, ll r){
        ll ans = (fac[n]*inv[r])%m;
        ans = (ans*inv[n-r])%m;
        return ans;
    }

    int numberOfWays(int n, int x, int y) {
        ll ans = 0;
        fac[0] = 1; inv[0] = bin(fac[0], m-2);
        for(ll i = 1; i<=1000; i++){
            fac[i] = (fac[i-1]*i)%m;
            inv[i] = bin(fac[i], m-2);
        }
        for(ll s = 1; s<=min(n, x); s++){
            // xCs.
            ll tot = (bin(s, n))%m;
            ll sign = -1;
            for(ll j = s-1; j>=1; j--){
                ll cur = (bin(j,n)*ncr(s,j))%m;
                tot = (tot + sign*cur + m)%m;
                sign*=-1;
            }
            tot = (tot*ncr(x,s))%m;
            // cout<<s<<""->""<<tot<<endl;
            ans = (ans + (tot*bin(y, s))%m)%m;
        }
        return ans;
    }
};",1420105807
Saurav Kumar,kumar_23,575,3605,cpp,"class Solution {
public:
    bool check(int n){
        n++;
        int cnt = 0;
        while(n){
            cnt += (n&1);
            n/=2;
        }
        return cnt==1;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i = 0; i<n; i++){
            for(int j = 0; j<=1000; j++){
                if((j|(j+1))==nums[i]){
                    ans[i] = j; break;
                }
            }
        }
        // for(int i = 0; i<n; i++){
        //     if(nums[i]&1){
        //         if(check(nums[i]))
        //         ans[i] = nums[i]/2;
        //         else ans[i] = nums[i]-1;
        //     }
        //     else ans[i] = -1;
        // }
        return ans;
    }
};",1420013435
Saurav Kumar,kumar_23,575,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(auto x: nums){
            if(x%2==0)ans.push_back(-1);
            else{
                int a = x;
                int ind = 0, i = -1;
                while(1){
                    if(x&(1<<ind)){

                    }
                    else{
                        i = ind-1;break;
                    }
                    ind++;
                }
                ans.push_back((a^(1<<i)));
            }
        }
        return ans;
    }
};",1420031233
urverymean,urverymean,576,3604,cpp,"typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
#define MOD 1000000007
template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
class Combinations {
public:
  vector<mint> inv, fact, ifact;
 
  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};
Combinations c(1005);
class Solution {
public:
    int numberOfWays(ll n, ll x, ll y) {
        mint res = 0;
        for (int i = 1; i<=x; i++){
            if (i > n) break;
            mint ways = c.comb(x, i);
            ways*=binpow(y,i,MOD);
            mint curr = 0;
            for (int h = 0; h<=i; h++){
                if (h%2==0){
                    curr+=c.comb(i,h)*binpow(i-h, n,MOD);
                }
                else{
                    curr-=c.comb(i,h)*binpow(i-h, n,MOD);
                }
            }
            ways*=curr;
            res+=ways;
        }
        return res.x;
    }
};",1420106076
urverymean,urverymean,576,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def find(f):
            for i in range(f+1):
                if i|i+1==f:
                    return i
            return -1
        return [find(x) for x in nums]",1420021891
urverymean,urverymean,576,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []
        for i in range(len(nums)):
            if nums[i]%2==0:
                res.append(-1)
                continue
            f = False
            for bit in range(32,-1,-1):
                if nums[i]&(1<<bit):
                    x = nums[i]^(1<<bit)
                    if x|(x+1)==nums[i]:
                        f = True
                        res.append(x)
                        break
            if not f:
                res.append(-1)
        return res",1420060995
ARUNMOZHICHELVAN,ARUNMOZHICHELVAN,577,3487,java,"

class Solution {
    

    public static boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    public static int arunmozhichelvanLeetcode(){
        int x=11;
        int y=89;
        return x+y;
    }
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int len = source.length();
        int m = pattern.length();
        int[] dp = new int[m + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        arunmozhichelvanLeetcode();
        
        boolean[] isTargetAns = new boolean[len];
        for (int idx : targetIndices) {
            isTargetAns[idx] = true;
        }
        isPalindrome(""ARUN"");
        for (int i = 0; i < len; i++) {
            arunmozhichelvanLeetcode();
            for (int j = m; j > 0; j--) {
                if (source.charAt(i) == pattern.charAt(j - 1) && dp[j - 1] != Integer.MAX_VALUE) {
                    dp[j] = Math.min(dp[j], dp[j - 1] + (isTargetAns[i] ? 1 : 0));
                }
            }
        }
        isPalindrome(""ARUN"");
        
        int finalAns=targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
        return finalAns;
    }
    
    
}

",1420106359
ARUNMOZHICHELVAN,ARUNMOZHICHELVAN,577,3604,java,"public class Solution {
    private static final int MOD = (int)(1e9+7);

    
    static long[][] comComb(int size) {

        long[][] ans = new long[size + 1][size + 1];
        for (int i = 0; i <= size; i++) {
            arunmozhichelvanLeetcode();
            ans[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                ans[i][j] = (ans[i - 1][j - 1] + ans[i - 1][j]) % MOD;
            }
        }
        return ans;
    }

    public static boolean isPalindrome(String str) {
            int left = 0;
            int right = str.length() - 1;
            
            while (left < right) {
                if (str.charAt(left) != str.charAt(right)) {
                    return false;
                }
                left++;
                right--;
            }
            return true;
    }

    // Computes partitions S(n, k)
    static long[][] comPart(int n, int x) {
        long[][] ans = new long[n + 1][x + 1];
        ans[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                ans[i][j] = (j * ans[i - 1][j] + ans[i - 1][j - 1]) % MOD;
            }
            arunmozhichelvanLeetcode();
        }
        return ans;
    }

    // Computes factorials
    static long[] comFact(int size) {
        long[] fact = new long[size + 1];
        fact[0] = 1;
        arunmozhichelvanLeetcode();
        for (int i = 1; i <= size; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

    public static void arunmozhichelvanLeetcode(){
            int x=11;
            int y=89;
            return ;
        }

    public int numberOfWays(int n, int x, int y) {
        long[][] C = comComb(x);
        long[][] S = comPart(n, x);
        long[] fact = comFact(x);

        long ans = 0;
        isPalindrome(""ARUNMOZHI"");
        for (int k = 1; k <= x; k++) {
            long po = 1;
            for (int p = 0; p < k; p++) {
                po = (po * y) % MOD;
            }
            long te = C[x][k];
            arunmozhichelvanLeetcode();
            te = (te * S[n][k]) % MOD;
            te = (te * fact[k]) % MOD;
            te = (te * po) % MOD;
            ans = (ans + te) % MOD;
            arunmozhichelvanLeetcode();
        }
        isPalindrome(""ARUNMOZHI"");

        return (int) ans;
    }

}
",1420069159
ARUNMOZHICHELVAN,ARUNMOZHICHELVAN,577,3605,java,"class Solution {
    public static boolean isPalindrome(String str) {
            int left = 0;
            int right = str.length() - 1;
            
            while (left < right) {
                if (str.charAt(left) != str.charAt(right)) {
                    return false;
                }
                left++;
                right--;
            }
            return true;
        }
    public int[] minBitwiseArray(List<Integer> nums) {
        int ans[]=new int[nums.size()];
        int k=0;
        int flag=0;
        isPalindrome(""asdfasdf"");
        for(int x: nums){
            flag=0;
            for(int i=1;i<=x;i++){
                if((i | (i+1)) == x){
                    ans[k++]=i;flag=1;break;
                }
            }
            if(flag==0) ans[k++]=-1;
        }
        isPalindrome(""asdfasdddd"");
        return ans;
    }
}
",1420032071
Pranav Kulkarni,pranavkulkarni610,578,3604,cpp,"class Solution {
    using ll = long long;
    ll mod = 1e9 + 7;
    ll fact[1001];
    ll binpow(ll a, ll b){
        a %= mod;
        ll res = 1;
        while(b){
            if(b&1) res = res * a % mod;
            b >>= 1;
            a = a * a % mod;
        } 
        return res;
    }
    ll ncr(ll n, ll r){
        ll res = fact[n];
        res = res * binpow(fact[r], mod-2) % mod;
        res = res * binpow(fact[n-r], mod-2) % mod;
        return res;
    }
    ll calc(ll x, ll n){
        ll ans = 0;
        for(ll i=0; i<x; i++){
            ll mult = (i&1) ? -1 : 1;
            mult = mult * ncr(x, i) % mod;
            mult = mult * binpow(x-i, n) % mod;
            ans = (ans + mult)%mod;
        }
        return ans;
    }
public:
    int numberOfWays(int n, int x, int y) {
        fact[0] = 1;
        for(ll i=1; i<=1000; i++) fact[i] = fact[i-1] * i % mod;
        ll ans = 0;
        for(ll i=1; i<=min(n, x); i++){
            ll mult = ncr(x, i);
            mult = mult * calc(i, n) % mod;
            mult = mult * binpow(y, i) % mod;
            ans = (ans + mult)%mod;
        }
        if(ans < 0) ans = (ans + mod)%mod;
        return ans;
    }
};",1420079375
Pranav Kulkarni,pranavkulkarni610,578,3605,cpp,"class Solution {
    int get(int x){
        int ret = 0;
        for(int i=0; i<32; i++){
            if(x&(1<<i)) ret++;
            else break;
        }
        return ret;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int ret = get(nums[i]);
            if(ret == 0) ans[i] = -1;
            else ans[i] = nums[i] - ((1<<ret)-1) + (1<<(ret-1)) - 1;
        }
        return ans;
    }
};",1420006902
Pranav Kulkarni,pranavkulkarni610,578,3611,cpp,"class Solution {
    int get(int x){
        int ret = 0;
        for(int i=0; i<32; i++){
            if(x&(1<<i)) ret++;
            else break;
        }
        return ret;
    }
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            int ret = get(nums[i]);
            if(ret == 0) ans[i] = -1;
            else ans[i] = nums[i] - ((1<<ret)-1) + (1<<(ret-1)) - 1;
        }
        return ans;
    }
};",1420006311
Jasteg Singh,jastegsingh007,579,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        def modinv(a):
            return pow(a, MOD - 2, MOD)
        def js(n):
            S = [[0] * (n + 1) for _ in range(n + 1)]
            S[0][0] = 1
            for i in range(1, n + 1):
                for j in range(1, i + 1):
                    S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD
            return S
        maxk = min(n, x)
        fact = [1] * (maxk + 1)
        for i in range(1, maxk + 1):
            fact[i] = fact[i - 1] * i % MOD
        stirling = js(n)
        tt = 0
        for kk in range(1, maxk + 1):
            binom = 1
            for i in range(kk):
                binom = binom * (x - i) % MOD * modinv(i + 1) % MOD
            s = stirling[n][kk]
            perm = fact[kk]
            pow_y_kk = pow(y, kk, MOD)
            term = binom * s % MOD * perm % MOD * pow_y_kk % MOD
            tt = (tt + term) % MOD
        return tt

        ",1420093553
Jasteg Singh,jastegsingh007,579,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n=len(nums)
        ans=[-1 for _ in range(n)]
        for i in range(n):
            for j in range(nums[i]):
                if (j|(j+1))==nums[i]:
                    ans[i]=j
                    break
        return ans
        ",1420003946
Jasteg Singh,jastegsingh007,579,3611,python3,"class Solution:
    def minimal_x(self,N):
        min_x = -1
        for s in range(N.bit_length()):
            if N & (1 << s):
                x = N - (1 << s)
                if x >= 0:
                    if x | (x + 1) == N:
                        if min_x == -1 or x < min_x:
                            min_x = x
        return min_x
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for N in nums:
            ans.append(self.minimal_x(N))
        return ans
                ",1420072680
Himanshu Kumar,himanshukumar7349820018,580,3487,python3,"class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])",1420061220
Himanshu Kumar,himanshukumar7349820018,580,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420108257
Himanshu Kumar,himanshukumar7349820018,580,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420007820
rath772k,rath772k,581,3604,python3,"MOD = int(1e9 + 7)
# Python3 program to answer queries
# of nCr in O(1) time.
N = 1001

# array to store inverse of 1 to N
factorialNumInverse = [None] * (N + 1)

# array to precompute inverse of 1! to N!
naturalNumInverse = [None] * (N + 1)

# array to store factorial of 
# first N numbers
fact = [None] * (N + 1)

# Function to precompute inverse of numbers
def InverseofNumber(p):
	naturalNumInverse[0] = naturalNumInverse[1] = 1
	for i in range(2, N + 1, 1):
		naturalNumInverse[i] = (naturalNumInverse[p % i] *
								(p - int(p / i)) % p)

# Function to precompute inverse 
# of factorials
def InverseofFactorial(p):
	factorialNumInverse[0] = factorialNumInverse[1] = 1

	# precompute inverse of natural numbers
	for i in range(2, N + 1, 1):
		factorialNumInverse[i] = (naturalNumInverse[i] *
								factorialNumInverse[i - 1]) % p

# Function to calculate factorial of 1 to N
def factorial(p):
	fact[0] = 1

	# precompute factorials
	for i in range(1, N + 1):
		fact[i] = (fact[i - 1] * i) % p

# Function to return nCr % p in O(1) time
def Binomial(N, R, p):
	
	# n C r = n!*inverse(r!)*inverse((n-r)!)
	ans = ((fact[N] * factorialNumInverse[R])% p *
					factorialNumInverse[N - R])% p
	return ans

InverseofNumber(MOD)
InverseofFactorial(MOD)
factorial(MOD)

class Solution:
    def numberOfWays(self, n: int, X: int, y: int) -> int:
        def fast_exp(x, p):
            res = 1
            while p:
                if p & 1: 
                    res = (res * x) % MOD
                x = (x * x) % MOD
                p >>= 1
            return res
        ans = 0
        for b in range(1, min(X, n)+1):
            band_partitions = 0 # {n, b}
            for j in range(1, b+1):
                band_partitions += fast_exp(MOD-1, b-j) * Binomial(b, j, MOD) % MOD * fast_exp(j, n) % MOD
                band_partitions %= MOD 
            ans += band_partitions * Binomial(X, b, MOD) % MOD * fast_exp(y, b) % MOD
            ans %= MOD
        return ans",1420108866
rath772k,rath772k,581,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def fn(x):
            if x == 2:
                return -1
            s = bin(x)
            cur = len(s) - 1
            while s[cur - 1] == ""1"":
                cur -= 1
            new_s = s[:cur] + ""0"" + s[cur+1:]
            return int(new_s, base=2)
            
        return [fn(el) for el in nums]",1420027058
rath772k,rath772k,581,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def fn(x):
            if x == 2:
                return -1
            s = bin(x)
            cur = len(s) - 1
            while s[cur - 1] == ""1"":
                cur -= 1
            new_s = s[:cur] + ""0"" + s[cur+1:]
            return int(new_s, base=2)
            
        return [fn(el) for el in nums]",1420026654
Pranab Krushna Sahoo,Zen_10_000,582,3604,cpp,"using lli =long long;
lli p=1e9+7;

lli n,x,y;
vector<lli> fact;
lli dp[1005];

lli po(lli a,lli b){
    lli ans=1;
    while(b){
        if(b%2)ans=(ans*a)%p;
        a=(a*a)%p;
        b/=2;
    }
    return ans;
}

lli com(lli up,lli dow){
    lli ans=1;
    lli tem2=(fact[dow]*fact[up-dow])%p;
    ans=(fact[up]*po(tem2,p-2))%p;
    return ans;
}

lli rec(lli s){
    // #of ways to have n performers in s stages

    
    if(s==1) return 1;

    if(dp[s]!=-1)return dp[s];

    lli num=0;
    for(int i=1;i<s;i++){
        //+=sCi*rec(i,p);
        num= (num + (com(s,i)*rec(i))%p )%p;
    }
    
    lli ans=po(s,n);
    ans= (ans-num+p)%p;

    return dp[s]=ans;
    // return 0;
}


class Solution {
public:
    int numberOfWays(int num, int xst, int ysc) {
        if(fact.size()==0){
            fact.push_back(1);
            for(int i=1;i<1005;i++){
                lli num=(i*fact[i-1])%p;
                fact.push_back(num);
            }
        }

        
        n=num;x=xst;y=ysc;

        memset(dp,-1,sizeof(dp));

        lli ans=0;
        for(int i=1;i<=x;i++){
            ans = (ans+ (((com(x,i)*rec(i))%p)*po(y,i))%p)%p;
        }
        // cout<<po(2,10)<<'\n';
        // cout<<fact[7];
        // cout<<com(100,3);
        return ans;
    }
};",1420108926
Pranab Krushna Sahoo,Zen_10_000,582,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0) {
                ans.push_back(-1);
                continue;
            }

            int num=nums[i];
            int cnt=0;
            while(num%2){
                cnt++;
                num/=2;
            }
            num*=2;
            cnt--;
            cout<<cnt<<' ';
            while(cnt>0){
                num=num*2+1;
                cnt--;
            }
            ans.push_back(num);
        }

        return ans;
    }
};",1420024333
Pranab Krushna Sahoo,Zen_10_000,582,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            if(nums[i]%2==0) {
                ans.push_back(-1);
                continue;
            }

            int num=nums[i];
            int cnt=0;
            while(num%2){
                cnt++;
                num/=2;
            }
            num*=2;
            cnt--;
            // cout<<cnt<<' ';
            while(cnt>0){
                num=num*2+1;
                cnt--;
            }
            ans.push_back(num);
        }

        return ans;
    }
};",1420028429
Aaditya Kumar,Kumar_2311,583,3604,cpp,"class Solution {
       static const int MOD = 1e9 + 7;
public:
    int numberOfWays(int n, int x, int y) {
   vector<std::vector<int>> c(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        
        std::vector<std::vector<int>> s(n + 1, std::vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }

        long long ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long pow_y = 1;
            for (int i = 0; i < k; ++i) {
                pow_y = (pow_y * y) % MOD;
            }
            ways = (ways + (1LL * c[x][k] * s[n][k] % MOD * fact[k] % MOD * pow_y % MOD)) % MOD;
        }
        return ways;
        
    }
};",1420103847
Aaditya Kumar,Kumar_2311,583,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
       vector<int> result;
        for (int number : nums) {
            bool isFound = 0;
            for (int candidate = 0; candidate < number; ++candidate) {
                if ((candidate | (candidate + 1)) == number) {
                    result.push_back(candidate);
                    isFound = true;
                    break;
                }
            }
            if (!isFound) {
                result.push_back(-1);
            }
        }

        return result;
    }
};",1420081457
Aaditya Kumar,Kumar_2311,583,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        std::vector<int> result(n);
        std::set<int> candidateSet;

        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            candidateSet.clear();

            for (int bit = 0; bit <= 30; ++bit) {
                if (((num >> bit) & 1) == 1) {
                    int candidate = num & ~(1 << bit);
                    if (candidate >= 0) {
                        if ((candidate | (candidate + 1)) == num) {
                            candidateSet.insert(candidate);
                        }
                    }
                }
            }

            if (!candidateSet.empty()) {
                result[i] = *candidateSet.begin();
            } else {
                result[i] = -1;
            }
        }

        return result;
        
    }
};",1420109798
KAI,dipayan2002,584,3487,cpp,"#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <limits>
#include <unordered_map>
#include <set>
#include <iterator>
#include <functional>
#include <cmath>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        vector<bool> isTarget = setupTargetIndices(source.length(), targetIndices);
        vector<int> dp = initializeDP(pattern.length());

        return calculateMaxRemovals(source, pattern, isTarget, dp, targetIndices);
    }

private:
    vector<bool> setupTargetIndices(int n, const vector<int>& targetIndices) {
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        return isTarget;
    }

    vector<int> initializeDP(int m) {
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;
        return dp;
    }

    int calculateMaxRemovals(const string& source, const string& pattern, const vector<bool>& isTarget, vector<int>& dp, const vector<int>& targetIndices) {
        int n = source.length();
        int m = pattern.length();

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420062967
KAI,dipayan2002,584,3604,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<long long>> C(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }

        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }

        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }

        long long result = 0;
        for (int k = 1; k <= x; k++) {
            long long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            result = (result + C[x][k] * S[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return result;
    }
};
",1420097034
KAI,dipayan2002,584,3605,cpp,"#include <vector>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <limits>
#include <numeric>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <queue>
using namespace std;

class Solution {
public:
    bool isPrime(int num){
        if(num <= 1) return false;
        for(int i=2; i <= sqrt(num); i++){
            if(num % i == 0) return false;
        }
        return true;
    }

    int nextPowerOfTwo(int num){
        if(num <= 0) return 1;
        int power = 1;
        while(power < num){
            power *= 2;
        }
        return power;
    }

    int findMinAns(int prime){
        for(int x=1; x <= prime; x++){
            if((x | (x + 1)) == prime){
                return x;
            }
        }
        return -1;
    }

    vector<int> minBitwiseArray(vector<int>& nums){
        int n = nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++){
            ans[i] = findMinAns(nums[i]);
        }
        return ans;
    }
};

",1420018303
Aman Raj Gupta,himalayan_coder,585,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> comb = solve(x);
        vector<vector<int>> dummy = solve2(n, x);
        vector<int> ff = fact(x);

        long long temp = ways(comb, dummy, ff, x, y,n);
        return temp;
    }

private:
    vector<vector<int>> solve(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> solve2(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }
        return s;
    }

    vector<int> fact(int x) {
        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        return f;
    }

    long long ways(const vector<vector<int>>& c, const vector<vector<int>>& s, const vector<int>& f, int x, int y,int n) {
        long long temp = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPow = 1;
            for (int i = 0; i < k; ++i) {
                yPow = (yPow * y) % MOD;
            }
            temp = (temp + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * yPow % MOD)) % MOD;
        }
        return temp;
    }
};",1420110414
Aman Raj Gupta,himalayan_coder,585,3605,cpp,"class Solution {
public:
void solve(vector<int>& nums, vector<int>&ans,int n){
     for(int i=0;i<n;i++){
            int num=nums[i];
            int mini=INT_MAX;
            bool found= false;
            for(int bit=0;bit<=20;bit++){
                if(((num>>bit)&1)==1){
                    int temp=num & ~(1<<bit);
                    if(temp < 0)continue;
                    if((temp | (temp+1))==num){
                        if(temp< mini){
                            mini=temp;
                            found=true;
                        }
                    }
                }
            }
            ans[i]=found?mini:-1;
        }
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
       solve(nums,ans,n);
        return ans;
    }
};",1420067090
Aman Raj Gupta,himalayan_coder,585,3611,cpp,"class Solution {
public:
void solve(vector<int>& nums, vector<int>&ans,int n){
     for(int i=0;i<n;i++){
            int num=nums[i];
            int mini=INT_MAX;
            bool found= false;
            for(int bit=0;bit<=20;bit++){
                if(((num>>bit)&1)==1){
                    int temp=num & ~(1<<bit);
                    if(temp < 0)continue;
                    if((temp | (temp+1))==num){
                        if(temp< mini){
                            mini=temp;
                            found=true;
                        }
                    }
                }
            }
            ans[i]=found?mini:-1;
        }
}
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n);
       solve(nums,ans,n);
        return ans;
    }
};",1420066898
RadoslawMystek,user7604rV,586,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        c = 10**9 + 7
        t = [[0]*(n+1) for i in range(x)]

        '''for i in range(x):
            t[i][1] = (x-i) * y'''
        '''t[x-1][1] = x * y'''

        for j in range(1,n+1):
            t[x-1][j] = x * y

        for j in range(2,n+1):
            for i in range(x-1):
                t[i][j] += t[i][j-1] * (x-i)
                t[i][j] += t[i+1][j-1] * (i + 1) * y
                t[i][j] %= c

        out = 0

        for i in range(x):
            out += t[i][n]
            out %= c

        return out
",1420110535
RadoslawMystek,user7604rV,586,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                num2 = num
                p = 0
                while num2 % 2 == 1:
                    p += 1
                    num2 //= 2

                p -= 1
                num -= 2**p
                ans.append(num)

        return ans",1420011435
RadoslawMystek,user7604rV,586,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                num2 = num
                p = 0
                while num2 % 2 == 1:
                    p += 1
                    num2 //= 2

                p -= 1
                num -= 2**p
                ans.append(num)

        return ans",1420012849
Aniket More,an1ket_62,588,3604,cpp,"using ll=long long;
const int mod =1e9+7;
class Solution {
public:
    ll inv(ll i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
 
    ll mod_mul(ll a, ll b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}

    ll mod_add(ll a, ll b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}

    ll mod_sub(ll a, ll b) {a = a % mod; b = b % mod; return (((a - b + mod) % mod) + mod) % mod;}
    ll npr(ll n,ll r,vector<ll>&fact){
        ll ans=fact[n];
        ans=mod_mul(ans,inv(fact[n-r]));
        return ans;
        
    }
    ll ncr(ll n,ll r,vector<ll>&fact){
        ll ans=fact[n];
        ans=mod_mul(ans,inv(fact[r]));
        ans=mod_mul(ans,inv(fact[n-r]));
        return ans;
        
    }
    int numberOfWays(int n, int x, int y) {
        vector<ll>fact(x+10);
        fact[0]=1;
        vector<ll>pw(x+10);
        pw[0]=1;
        for (int i=1;i<=x+5;i++){
            fact[i]=fact[i-1]*i;
            fact[i]%=mod;
            pw[i]=pw[i-1]*y;
            pw[i]%=mod;
        }
        vector<vector<long long>> dp(n + 10, vector<long long>(n + 10, 0));
        dp[0][0] = 1;
        for (int i = 1; i <= n+5; ++i) {
            for (int j = 1; j <= n+5; ++j) {
                dp[i][j] = j * dp[i - 1][j] + dp[i - 1][j - 1];
                dp[i][j]%=mod;
            }
        }
        ll ans=0;
        for (int i=1;i<=x;i++){
            ll p = npr(x,i,fact);
            ll c = dp[n][i];
            // cout << c << endl;
            if (i>n){
                break;
            }
            p=mod_mul(p,c);
            p=mod_mul(p,pw[i]);
            ans+=p;
            ans%=mod;
            // cout << ans << endl;
        
            
        }
        return ans;
        
        
    }
};",1420098544
Aniket More,an1ket_62,588,3605,cpp,"using ll = long long;
class Solution {
public:
    ll binToDec(string s) { return bitset<64>(s).to_ullong(); }
    string decToBin(ll a) { return bitset<64>(a).to_string(); }
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans;
        for (int i=0;i<n;i++){
            if (a[i]%2==0){
                ans.push_back(-1);
            }
            else{
                string s=decToBin(a[i]);
                for (int i=63;i>=0;i--){
                    if (s[i]=='0'){
                        s[i+1]='0';
                        break;
                    }
                }
                ll curr=binToDec(s);
                ans.push_back(curr);
                
            }
        }
        return ans;
        
    }
};",1420000885
Aniket More,an1ket_62,588,3611,cpp,"using ll = long long;
class Solution {
public:
    ll binToDec(string s) { return bitset<64>(s).to_ullong(); }
    string decToBin(ll a) { return bitset<64>(a).to_string(); }
    vector<int> minBitwiseArray(vector<int>& a) {
        int n=a.size();
        vector<int>ans;
        for (int i=0;i<n;i++){
            if (a[i]%2==0){
                ans.push_back(-1);
            }
            else{
                string s=decToBin(a[i]);
                for (int i=63;i>=0;i--){
                    if (s[i]=='0'){
                        s[i+1]='0';
                        break;
                    }
                }
                ll curr=binToDec(s);
                ans.push_back(curr);
                
            }
        }
        return ans;
        
    }
};",1420000502
manmapi,manmapi,589,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        MOD = 10**9 + 7
        max_nx = max(n, x) + 1

        factorial = [1] * max_nx
        inv_factorial = [1] * max_nx
        for i in range(1, max_nx):
            factorial[i] = factorial[i - 1] * i % MOD
        inv_factorial[max_nx - 1] = pow(factorial[max_nx - 1], MOD - 2, MOD)
        for i in range(max_nx - 2, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD

        max_k = min(n, x)
        S = [0] * (max_k + 2)
        S_prev = [0] * (max_k + 2)
        S_prev[0] = 1

        total_ways = 0
        for i in range(1, n + 1):
            S_curr = [0] * (max_k + 2)
            for k in range(1, min(i, max_k) + 1):
                S_curr[k] = (k * S_prev[k] + S_prev[k - 1]) % MOD
            S_prev = S_curr
        for k in range(1, max_k + 1):
            c = comb(x, k)
            perm = factorial[k]
            s = S_prev[k]
            total = c * perm % MOD * s % MOD * pow(y, k, MOD) % MOD
            total_ways = (total_ways + total) % MOD
        return total_ways

# 3 ** 3 = 27",1420111528
manmapi,manmapi,589,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            if num % 2 == 0:
                result.append(-1)
                continue
            count = 0
            num_ = num
            while num & 1:
                count += 1
                num = num >> 1
            num_ -= 2 ** (count - 1)
            
            result.append(num_)

        return result
        

",1420015780
manmapi,manmapi,589,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for num in nums:
            if num % 2 == 0:
                result.append(-1)
                continue
            count = 0
            num_ = num
            while num & 1:
                count += 1
                num = num >> 1
            num_ -= 2 ** (count - 1)
            
            result.append(num_)

        return result",1420016017
Andrew,AndrewJuang,591,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        res = 0
        MOD = 10**9 + 7

        # stirling numbers
        S = [[0] * (n + 1) for _ in range(n + 1)]
        S[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(1, i + 1):
                S[i][j] = (S[i - 1][j - 1] + j * S[i - 1][j]) % MOD
        res = 0
        
        for k in range(1, min(n,x) + 1):
            # assign n to k stages
            ways_to_assign = (S[n][k] * factorial(k)) % MOD

            if k <= x:
                ways_to_assign = (ways_to_assign * comb(x,k)) % MOD
            
            ways_to_assign = ways_to_assign * pow(y,k, MOD)
            res = (res + ways_to_assign) % MOD
        
        return res",1420105905
Andrew,AndrewJuang,591,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = []

        for n in nums:
            for x in range(n):
                if x | x +1 == n:
                    res.append(x)
                    break
            else:
                res.append(-1)
            
        return res",1420000254
Andrew,AndrewJuang,591,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []

        for n in nums:
            if n%2 == 0: 
                ans.append(-1)
                continue
            s = str(bin(n))[2:]
            ind = -1
            if '0' in s:
                ind = s.rindex('0')

            res = s[0:ind+1] + '0' + s[ind+2:]
            ans.append(int(res,2))

        return ans",1420032043
IamAho,IamAho,592,3604,cpp,"const int N = 2E3;
const int MOD = 1'000'000'007;
int fast_exp(int a, int k, int p = MOD) {
    long long res = 1;
    while (k) {
        if (k & 1) {
            res = 1LL * res * a % p;
        }
        k >>= 1;
        a = 1LL * a * a % p;
    }
    return res % MOD;
}
int fac[N], infac[N];
int memo[N][N];
bool has_init;
void init() {
    if (has_init) {
        return;
    }
    has_init = true;
    fac[0] = infac[0] = 1;
    for (int i = 1; i < N; i++) {
        fac[i] = 1LL * fac[i - 1] * i % MOD;
    }
    for (int i = 1; i < N; i++) {
        infac[i] = fast_exp(fac[i], MOD - 2, MOD);
    }
    memset(memo, -1, sizeof(memo));
    auto dfs = [&](auto&& self, int n, int m) -> int64_t {
        if (n < m || n <= 0 || m <= 0) {
            return 0;
        }
        if (m == 1 || n == m) {
            return 1;
        }
        if (memo[n][m] != -1) {
            return memo[n][m];
        }
        memo[n][m] = (1LL * self(self, n - 1, m - 1) + 1LL * m * self(self, n - 1, m) % MOD) % MOD;
        return memo[n][m];
    };
    for (int i = 0; i <= 1000; i++) {
        for (int j = 0; j <= 1000; j++) {
            memo[i][j] = dfs(dfs, i, j);
        }
    }
}

int C(int a, int b) {
    if (b == 0) {
        return 1;
    }
    if (a < b) {
        return 0;
    }
    if (a < 0 || b < 0) {
        return 0;
    }
    return 1LL * fac[a] * infac[b] % MOD * infac[a - b] % MOD;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        init();
        vector<int64_t> A(n + 1);
        A[0] = 1;
        for (int i = 1; i <= n; i++) {
            A[i] = A[i - 1] * i % MOD;
        }
        int64_t ans = 0;
        for (int band = 1; band <= min(n, x); band++) {
            // int64_t cur = 1LL * C(n, band) % MOD * C(x, band) % MOD;
            int64_t cur = 1LL * memo[n][band] * C(x, band) % MOD * A[band] % MOD;
            cur = cur * fast_exp(y, band) % MOD;
            ans = (ans + cur) % MOD;
        }
        return ans;
    }
};",1420106482
IamAho,IamAho,592,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420005490
IamAho,IamAho,592,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            if ((x | (x - 1)) == x) {
                ans[i] = x - 1;
            }
            int j = 0;
            while ((x >> j & 1) == 1) {
                j++;
                x -= 1 << j;
            }
            if ((x | (x + 1)) == nums[i]) {
                if (ans[i] == -1) {
                    ans[i] = x;
                } else {
                    ans[i] = min(ans[i], x);
                }
            }
            x = nums[i] >> 1;
            if ((x | (x + 1)) == nums[i]) {
                if (ans[i] == -1) {
                    ans[i] = x;
                } else {
                    ans[i] = min(ans[i], x);
                }
            }
            j = 0;
            x = nums[i];
            while (x >> (j + 1) & 1) {
                x -= 1 << j;
                j++;
            }
            if ((x | (x - 1)) == nums[i]) {
                if (ans[i] == -1) {
                    ans[i] = x - 1;
                } else {
                    ans[i] = min(ans[i], x - 1);
                }
            }            
        }
        return ans;
    }
};",1420042667
runtimeerror-12,runtimeerror-12,593,3604,cpp,"#define MOD 1000000007
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<long long> v = {n, x, y};
        vector<vector<long long>> v1(x + 1, vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            v1[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                v1[i][j] = (v1[i - 1][j - 1] + v1[i - 1][j]) % MOD;
            }
        }
        
        vector<vector<long long>> v2(n + 1, vector<long long>(x + 1, 0));
        v2[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                v2[i][j] = (j * v2[i - 1][j] + v2[i - 1][j - 1]) % MOD;
            }
        }
        
        vector<long long> ans(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            ans[i] = (ans[i - 1] * i) % MOD;
        }
        
        long long finalans = 0;
        for (int l = 1; l <= x; l++) {
            long long w = 1;
            for (int p = 0; p < l; p++) {
                w = (long long)(w * y) % MOD;
            }
            finalans = (finalans + v1[x][l] * v2[n][l] % MOD * ans[l] % MOD * w % MOD) % MOD;
        }

        sort(ans.begin(), ans.end());
        sort(v1.begin(), v1.end());
        sort(v2.begin(), v2.end());
        return finalans;
    }
};",1420073939
runtimeerror-12,runtimeerror-12,593,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
         vector<int> finalans(nums.size(), -1), temp(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int val = nums[i];
            int mn = INT_MAX;
            bool flag = false;
            
            for (int i = 0; i <= 30; i++) {
                if ((val >> i) & 1) {
                    int var = val & ~(1 << i);
                    if (var < 0) continue;
                    
                    if ((var | (var + 1)) == val) {
                        if (var < mn) {
                            mn = var;
                            flag = true;
                        }
                    }
                }
            }
            
            if (flag) {
                finalans[i] = mn;
                temp[i] = mn;
            } else {
                finalans[i] = -1;
                temp[i] = -1;
            }
        }
        sort(temp.begin(), temp.end());
        sort(nums.begin(), nums.end());
        return finalans;
    }
};",1420099995
runtimeerror-12,runtimeerror-12,593,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> finalans(nums.size(), -1), temp(nums.size(), -1);
        for (int i = 0; i < nums.size(); i++) {
            int val = nums[i];
            int mn = INT_MAX;
            bool flag = false;
            
            for (int i = 0; i <= 30; i++) {
                if ((val >> i) & 1) {
                    int var = val & ~(1 << i);
                    if (var < 0) continue;
                    
                    if ((var | (var + 1)) == val) {
                        if (var < mn) {
                            mn = var;
                            flag = true;
                        }
                    }
                }
            }
            
            if (flag) {
                finalans[i] = mn;
                temp[i] = mn;
            } else {
                finalans[i] = -1;
                temp[i] = -1;
            }
        }
        sort(temp.begin(), temp.end());
        sort(nums.begin(), nums.end());
        return finalans;
    }
};
",1420056974
Phoenix1337,Phoenix1337,594,3604,cpp,"class Solution {
    long long mod_exp(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1)
                result = (result * base) % mod;
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

public:
    int numberOfWays(int n, int x, int y) {
        int kmax = min(n, x);
        long long m = 1e9 + 7, ans = 0, ypk = y, fratio;
        vector<vector<long long>> S(n+1, vector<long long>(kmax+1, 0));
        vector<long long> f(x+1, 1);

        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= min(i, kmax); ++j) {
                S[i][j] = (j * S[i-1][j] + S[i-1][j-1]) % m;
            }
        }
        
        for (int i = 2; i <= x; ++i) 
            f[i] = (f[i-1] * i) % m;

        for (int k = 1; k <= kmax; ++k) {
            fratio = (f[x] * mod_exp(f[x-k], m-2, m)) % m;
            long long step = (((fratio * S[n][k]) % m) * ypk) % m;
            ans = (ans + step) % m;
            ypk = (ypk * y) % m;
        }

        return ans;
    }
};",1420112933
Phoenix1337,Phoenix1337,594,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> v; int ans;
        for(auto x:nums) {
            if(x & 1) {
                for(int i=1;i<32;i++) {
                    if(!((1<<i) & x)) {
                        ans = x - (1<<(i-1));
                        break;
                    }
                }
            }
            else ans = -1;
            v.push_back(ans);
        }
        return v;
    }
};",1420014824
Phoenix1337,Phoenix1337,594,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> v; int ans;
        for(auto x:nums) {
            if(x & 1) {
                for(int i=1;i<32;i++) {
                    if(!((1<<i) & x)) {
                        ans = x - (1<<(i-1));
                        break;
                    }
                }
            }
            else ans = -1;
            v.push_back(ans);
        }
        return v;
    }
};",1420017091
shivam singh,shivam2609,596,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420100247
shivam singh,shivam2609,596,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n =  nums.size();
        // int ans[n] = {-1};
        vector<int>ans(n,-1);
        for(int i = 0; i<n ; i++){
            for(int j  = 0 ; j<= nums[i] ; j++){
                if((j|(j+1))==nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans ;
    }
};",1420018165
shivam singh,shivam2609,596,3611,cpp,"#include <vector>
#include <limits.h>

class Solution {
public:
    std::vector<int> minBitwiseArray(const std::vector<int>& nums) {
        int n = nums.size();
         vector<int> ans(n);
         unordered_map<int,int>mpp ;
         unordered_set<int>set(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX; // Similar to Integer.MAX_VALUE in Java
            bool found = false;

            
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }

            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }

        return ans;
    }
};
",1420047432
CODEBISWA,CODEBISWA,597,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> combinations(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stirlingNumbers(n + 1, vector<int>(x + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> factorials(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD;
        }

        long long totalWays = 0;
        for (int k = 1; k <= x; ++k) {
            long long yPower = 1;
            for (int p = 0; p < k; ++p) {
                yPower = (yPower * y) % MOD;
            }
            totalWays = (totalWays + (1LL * combinations[x][k] * stirlingNumbers[n][k] % MOD * factorials[k] % MOD * yPower % MOD)) % MOD;
        }

        return totalWays;
    }
};
",1420113307
CODEBISWA,CODEBISWA,597,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for (int i = 0; i < n; ++i) {
            for (int y = 0; y <= nums[i]; ++y) {
                if ((y | (y + 1)) == nums[i]) {
                    ans[i] = y;
                    break;
                }
            }
        }
        
        return ans;  
    }
};",1420094154
CODEBISWA,CODEBISWA,597,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
             int length = nums.size();
        vector<int> result(length);

        for (int i = 0; i < length; i++) {
            int prime = nums[i];
            int minCandidate = INT_MAX;
            bool isValid = false;

            for (int bitPos = 0; bitPos <= 30; bitPos++) {
                if (((prime >> bitPos) & 1) == 1) {
                    int potentialValue = prime & ~(1 << bitPos);

                    if (potentialValue < 0) continue;

                    if ((potentialValue | (potentialValue + 1)) == prime) {
                        if (potentialValue < minCandidate) {
                            minCandidate = potentialValue;
                            isValid = true;
                        }
                    }
                }
            }

            if (isValid) {
                result[i] = minCandidate;
            } else {
                result[i] = -1;
            }
        }

        return result; 
    }
};",1420108614
Anubhav Jain,jain-anubhav,598,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420113759
Anubhav Jain,jain-anubhav,598,3605,c,"/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* minBitwiseArray(int* nums, int size, int* rSize) {
    int* ans = (int*)malloc(sizeof(int) * size);

    for (int i = 0; i < size; i++) {
        if (nums[i] == 2) ans[i] = -1;
        else {
            for (int j = 1; j <= nums[i]; j++) {
                if ((j | (j + 1)) == nums[i]) {
                    ans[i] = j; break;
                }
            }
        }
    }

    *rSize = size; return ans;
}",1420068876
Anubhav Jain,jain-anubhav,598,3611,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        n = len(nums)
        ans = [0] * n
        
        for i in range(n):
            num = nums[i]
            minimalAns = float('inf')
            found = False
            
            for bit in range(31):
                if (num >> bit) & 1 == 1:
                    candidate = num & ~(1 << bit)
                    if (candidate | (candidate + 1)) == num:
                        if candidate < minimalAns:
                            minimalAns = candidate
                            found = True

            if found:
                ans[i] = minimalAns
            else:
                ans[i] = -1
                
        return ans
        ",1420104896
Prasham Shah,Prasham_Shah,599,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        fact = [0]*1005
        fact[0] = 1
        m = 10**9+7
        for i in range(1,1005):
            fact[i] = (i*fact[i-1])%m

        def comb(n,r,m):
            return (fact[n]*pow((fact[n-r]*fact[r])%m,m-2,m))%m
        
        ans = 0
        for i in range(1,x+1): # i is number of stages
            if i <= n:
                t = 0 # union of at least 1 not there
                for j in range(1,i):
                    if j%2: t += ( comb(i,i-j,m)*pow(i-j,n,m) )%m
                    else: t -= ( comb(i,i-j,m)*pow(i-j,n,m) )%m 
                t %= m
                ans = (ans + ( (pow(i,n,m)-t)%m )*comb(x,i,m)*pow(y,i,m) )%m
            
        return ans


",1420114426
Prasham Shah,Prasham_Shah,599,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i] == 2: ans.append(-1)
            else:
                b = list(reversed(bin(nums[i])[2:]))
                c = 0
                while c < len(b) and b[c] == '1': c+= 1
                ans.append(nums[i]-2**(c-1))
        return ans",1420010426
Prasham Shah,Prasham_Shah,599,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for i in range(len(nums)):
            if nums[i] == 2: ans.append(-1)
            else:
                b = list(reversed(bin(nums[i])[2:]))
                c = 0
                while c < len(b) and b[c] == '1': c+= 1
                ans.append(nums[i]-2**(c-1))
        return ans",1420011356
Ps_Chaitanya1,Ps_Chaitanya1,601,3604,php,"class Solution {
    const psofflineMOD = 1000000007;

    public function numberOfWays($psofflineN, $psofflineX, $psofflineY) {
        // Initialize combination array
        $psofflineComb = array_fill(0, $psofflineX + 1, array_fill(0, $psofflineX + 1, 0));
        for ($psofflineI = 0; $psofflineI <= $psofflineX; ++$psofflineI) {
            $psofflineComb[$psofflineI][0] = 1;
            for ($psofflineJ = 1; $psofflineJ <= $psofflineI; ++$psofflineJ) {
                $psofflineComb[$psofflineI][$psofflineJ] = ($psofflineComb[$psofflineI - 1][$psofflineJ - 1] + $psofflineComb[$psofflineI - 1][$psofflineJ]) % self::psofflineMOD;
            }
        }

        // Initialize Stirling numbers of the second kind array
        $psofflineStirling = array_fill(0, $psofflineN + 1, array_fill(0, $psofflineX + 1, 0));
        $psofflineStirling[0][0] = 1;
        for ($psofflineI = 1; $psofflineI <= $psofflineN; ++$psofflineI) {
            for ($psofflineJ = 1; $psofflineJ <= $psofflineX; ++$psofflineJ) {
                $psofflineStirling[$psofflineI][$psofflineJ] = (1 * $psofflineJ * $psofflineStirling[$psofflineI - 1][$psofflineJ] + $psofflineStirling[$psofflineI - 1][$psofflineJ - 1]) % self::psofflineMOD;
            }
        }

        // Initialize factorial array
        $psofflineFactorial = array_fill(0, $psofflineX + 1, 1);
        for ($psofflineI = 1; $psofflineI <= $psofflineX; ++$psofflineI) {
            $psofflineFactorial[$psofflineI] = (1 * $psofflineFactorial[$psofflineI - 1] * $psofflineI) % self::psofflineMOD;
        }

        // Calculate total number of ways
        $psofflineTotalWays = 0;
        for ($psofflineK = 1; $psofflineK <= $psofflineX; ++$psofflineK) {
            $psofflineYpow = 1;
            for ($psofflineI = 0; $psofflineI < $psofflineK; ++$psofflineI) {
                $psofflineYpow = ($psofflineYpow * $psofflineY) % self::psofflineMOD;
            }
            $psofflineTotalWays = ($psofflineTotalWays + (1 * $psofflineComb[$psofflineX][$psofflineK] * $psofflineStirling[$psofflineN][$psofflineK] % self::psofflineMOD * $psofflineFactorial[$psofflineK] % self::psofflineMOD * $psofflineYpow % self::psofflineMOD)) % self::psofflineMOD;
        }

        return $psofflineTotalWays;
    }
}

// Example usage:
$solution = new Solution();
$result = $solution->numberOfWays(5, 3, 2);
echo $result;
",1420108521
Ps_Chaitanya1,Ps_Chaitanya1,601,3605,php,"class Solution {
    public function minBitwiseArray($psofflineNums) {
        // Initialize the result array with -1
        $psofflineResult = array_fill(0, count($psofflineNums), -1);

        // Iterate over the indices of the input array
        for ($psofflineI = 0; $psofflineI < count($psofflineNums); $psofflineI++) {
            // Iterate over possible values of result[i]
            for ($psofflineJ = 0; $psofflineJ < $psofflineNums[$psofflineI]; $psofflineJ++) {
                // Check if the condition is satisfied
                if (($psofflineJ | ($psofflineJ + 1)) == $psofflineNums[$psofflineI]) {
                    // Update the result array with the minimum possible value
                    $psofflineResult[$psofflineI] = $psofflineJ;
                    break;
                }
            }
        }

        // Return the result array
        return $psofflineResult;
    }
}

// Example usage:
$solution = new Solution();
$psofflineNums = [1, 2, 3, 4, 5];
$result = $solution->minBitwiseArray($psofflineNums);
print_r($result);
",1420101487
Ps_Chaitanya1,Ps_Chaitanya1,601,3611,php,"class Solution {
    public function minBitwiseArray($psofflineNums) {
        $psofflineN = count($psofflineNums);
        $psofflineAns = array_fill(0, $psofflineN, 0);
        
        for ($psofflineI = 0; $psofflineI < $psofflineN; $psofflineI++) {
            $psofflineNum = $psofflineNums[$psofflineI];
            $psofflineMinimalAns = PHP_INT_MAX;
            $psofflineFound = false;
            
            // Iterate through each bit position (0 to 30)
            for ($psofflineBit = 0; $psofflineBit <= 30; $psofflineBit++) {
                if ((($psofflineNum >> $psofflineBit) & 1) == 1) {
                    // Unset the current bit
                    $psofflineCandidate = $psofflineNum & ~(1 << $psofflineBit);
                    
                    // Ensure candidate is non-negative
                    if ($psofflineCandidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if (($psofflineCandidate | ($psofflineCandidate + 1)) == $psofflineNum) {
                        if ($psofflineCandidate < $psofflineMinimalAns) {
                            $psofflineMinimalAns = $psofflineCandidate;
                            $psofflineFound = true;
                        }
                    }
                }
            }
            
            if ($psofflineFound) {
                $psofflineAns[$psofflineI] = $psofflineMinimalAns;
            } else {
                $psofflineAns[$psofflineI] = -1;
            }
        }
        
        return $psofflineAns;
        }
}

// Example usage:
$solution = new Solution();
$psofflineNums = [1, 2, 3, 4, 5];
$result = $solution->minBitwiseArray($psofflineNums);
print_r($result);
",1420099667
Shivam Gupta,dhirack,602,3604,cpp,"class Solution {
public:
    const int MOD = 1000000007;
    vector<long long> factorial;
    vector<long long> inv_factorial;

    // Function to compute (base^exponent) % MOD
    long long powmod(long long base, long long exponent) {
        long long result = 1;
        base %= MOD;
        while (exponent) {
            if (exponent & 1) {
                result = result * base % MOD;
            }
            base = base * base % MOD;
            exponent >>= 1;
        }
        return result;
    }

    // Precompute factorials and inverse factorials
    void precompute_factorials(int N) {
        factorial.resize(N + 1);
        inv_factorial.resize(N + 1);
        factorial[0] = inv_factorial[0] = 1;
        for (int i = 1; i <= N; ++i) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        // Compute inverse factorials using Fermat's Little Theorem
        inv_factorial[N] = powmod(factorial[N], MOD - 2);
        for (int i = N - 1; i >= 1; --i) {
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
        }
    }

    // Compute n choose k modulo MOD
    long long comb(int n, int k) {
        if (k < 0 || k > n)
            return 0;
        return factorial[n] * inv_factorial[k] % MOD * inv_factorial[n - k] % MOD;
    }

    int numberOfWays(int n, int x, int y) {
        int N = max(n, x);
        precompute_factorials(N);

        // Initialize the Stirling numbers array
        vector<long long> S(n + 1, 0);
        S[0] = 1;

        // Compute Stirling numbers of the second kind
        for (int i = 1; i <= n; ++i) {
            vector<long long> newS(n + 1, 0);
            for (int k = 1; k <= i; ++k) {
                newS[k] = (S[k - 1] + k * S[k] % MOD) % MOD;
            }
            S = newS;
        }

        long long totalWays = 0;
        for (int k = 1; k <= min(n, x); ++k) {
            long long ways = comb(x, k) * S[k] % MOD;
            ways = ways * factorial[k] % MOD;
            ways = ways * powmod(y, k) % MOD;
            totalWays = (totalWays + ways) % MOD;
        }

        return totalWays;
    }
};
",1420108700
Shivam Gupta,dhirack,602,3605,cpp,"class Solution {
public:
    bool pow2(int x){
        double tmp = log2(x);
        if(tmp-(int)tmp==0) return true;
        else return false;
    }

    int check(int n){
        string s = """";
        int cnt = 0;
        while(n && n%2==1){
            cnt++;
            n=n/2;
        }
        return cnt;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans[i]=-1;
            else{
                int cnt = check(nums[i]);
                ans[i] = nums[i]-pow(2,cnt-1);
            }
        }
        return ans;
    }
};",1420038622
Shivam Gupta,dhirack,602,3611,cpp,"class Solution {
public:
    int check(int n){
        string s = """";
        int cnt = 0;
        while(n && n%2==1){
            cnt++;
            n=n/2;
        }
        return cnt;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0;i<n;i++){
            if(nums[i]==2) ans[i]=-1;
            else{
                int cnt = check(nums[i]);
                ans[i] = nums[i]-pow(2,cnt-1);
            }
        }
        return ans;
    }
};",1420039727
Leima Singha,LeiLeet,605,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }

        long long res = 0;
        for (int k = 1; k <= x; ++k) {
            long long yp = 1;
            for (int i = 0; i < k; ++i) {
                yp = (yp * y) % MOD;
            }
            res = (res + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * yp % MOD)) % MOD;
        }

        return res;
    }
};",1420116814
Leima Singha,LeiLeet,605,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int>ans(n, -1);
        for (int i = 0; i < n; i++) {    
            for(int j = 0; j <= nums[i]; j++){
                if((j|(j+1))==nums[i]){
                    ans[i] = j;
                    break;
                }
            }    
        }
        return ans;
    }
};",1420040333
Leima Singha,LeiLeet,605,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> res(nums.size(), 0);

    for (int i = 0; i < nums.size(); i++) {
        int n = nums[i];
        int mn = INT_MAX;
        bool flag = false;

        for (int j = 0; j < 31; j++) {
            if ((n >> j) & 1) {
                int x = n & ~(1 << j);
                if (x < 0) continue;
                if ((x | (x + 1)) == n) {
                    if (x < mn) {
                        mn = x;
                    }
                    flag = true;
                }
            }
        }

        if (flag) {
            res[i] = mn;
        } else {
            res[i] = -1;
        }
    }

    return res;
    }
};",1420092448
pffffttttt,knym_jar,606,3604,java,"class Solution {
    int numberOfWays(int n, int x, int y) {
        int MOD = 1000000007;
        int[] fact = new int[x + 1];
        fact[0] = 1;
        for (int i = 1; i <= x; ++i) {
            fact[i] = (int)((1L * fact[i - 1] * i) % MOD);
        }

        long ans = 0;
        
        int[][] bino = new int[x + 1][x + 1];
        for (int i = 0; i <= x; ++i) {
            bino[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                bino[i][j] = (bino[i - 1][j - 1] + bino[i - 1][j]) % MOD;
            }
        }

        int[][] sti = new int[n + 1][x + 1];
        sti[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                sti[i][j] = (int)((1L * j * sti[i - 1][j] + sti[i - 1][j - 1]) % MOD);
            }
        }

        for (int k = 1; k <= x; ++k) {
            long yP = 1;
            for (int i = 0; i < k; ++i) {
                yP = (yP * y) % MOD;
            }
            
            ans = (ans + (1L * bino[x][k] * sti[n][k] % MOD * fact[k] % MOD * yP % MOD)) % MOD;
        }

        return (int) ans;
    }
}
",1420116981
pffffttttt,knym_jar,606,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i = 0 ; i < n ; i++) {
            int x = 0;
            for(int j = 0 ; j < 1001 ; j++) {
                int y = j | ( j + 1);
                if(y == nums.get(i)) {
                    ans[i] = j;
                    x = 1;
                    break;
                }
            }
            if(x == 0) {
                ans[i] = -1;
            }
        }
        return ans;
    }
}",1420004227
pffffttttt,knym_jar,606,3611,java,"class Solution {
    
    private int[] binary(int x) {
        List<Integer> temp = new ArrayList<Integer>();
        while(x != 0) {
            temp.add(x % 2);
            x = x / 2;
        }
        int[] ans = new int[temp.size()];
        // ans = temp.toArray(ans);
        for(int i = 0; i < temp.size() ; i++) {
            ans[i] = temp.get(i);
        }
        return ans;
    }
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for(int i = 0 ; i < n ; i++) {
            if(nums.get(i) == 2) {
                ans[i] = -1;
            } else {
                int[] bin = binary(nums.get(i));
                int x = 0;
                for(int j = 0 ; j < bin.length ; j++) {
                    if(bin[j] == 0) {
                        x += Math.pow(2 , j - 1);
                        break;
                    }
                }
                if(x == 0) x += Math.pow(2 , bin.length - 1);
                ans[i] = nums.get(i) - x;
            }
        }
        return ans;
    }
    
}",1420054204
Nikhil Reddy,nikhil_reddy_d,607,3604,java,"import java.util.Arrays;

class Solution {
    static final int MOD = 1000000007;

    public int numberOfWays(int numItems, int maxGroups, int multiplier) {
        long[][] combinations = new long[maxGroups + 1][maxGroups + 1];
        for (int i = 0; i <= maxGroups; i++) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        long[][] stirlingNumbers = new long[numItems + 1][maxGroups + 1];
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= numItems; i++) {
            for (int j = 1; j <= maxGroups; j++) {
                stirlingNumbers[i][j] = (j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }

        long[] factorials = new long[maxGroups + 1];
        factorials[0] = 1;
        for (int i = 1; i <= maxGroups; i++) {
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }

        long totalWays = 0;
        for (int groupCount = 1; groupCount <= maxGroups; groupCount++) {
            long multiplierPow = 1;
            for (int i = 0; i < groupCount; i++) {
                multiplierPow = (multiplierPow * multiplier) % MOD;
            }
            totalWays = (totalWays + (combinations[maxGroups][groupCount] * stirlingNumbers[numItems][groupCount] % MOD * factorials[groupCount] % MOD * multiplierPow % MOD)) % MOD;
        }

        return (int) totalWays;
    }
}
",1420110668
Nikhil Reddy,nikhil_reddy_d,607,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # Initialize the result array with -1
        result = [-1] * len(nums)

        # Iterate over the indices of the input array
        for i in range(len(nums)):
            # Iterate over possible values of ans[i]
            for j in range(nums[i]):
                # Check if the condition is satisfied
                if j | (j + 1) == nums[i]:
                    # Update the result array with the minimum possible value
                    result[i] = j
                    break

        # Return the result array
        return result",1420019430
Nikhil Reddy,nikhil_reddy_d,607,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}


",1420082495
deepthings07,deepthings07,608,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
           int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;
        vector<bool> isTarget(n, false);
        
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }
        
        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }
        
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420117538
deepthings07,deepthings07,608,3604,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {

    vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        } 
     vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        long long ans = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            ans = (ans + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * y_pow % MOD)) % MOD;
        }


        return ans;


    }
};",1420106794
deepthings07,deepthings07,608,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            bool found = false;

            for (int x = 0; x < num; x++) {
                if ((x | (x + 1)) == num) {
                    ans[i] = x;
                    found = true;
                    break;
                }
            }
            
            if (!found) {
                ans[i] = -1;
            }
        }
        
        returnans;

        
    }
};",1420112977
Syam,Sai_7096,609,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<int> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % MOD;
        }

        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * fact[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};
",1420105199
Syam,Sai_7096,609,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        res = [-1] * len(nums)
        for i in range(len(nums)):
            for j in range(nums[i]):
                if j | (j + 1) == nums[i]:
                    res[i] = j
                    break
        return res
",1420007140
Syam,Sai_7096,609,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] res = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minVal = Integer.MAX_VALUE;
            boolean found = false;
            
            for (int b = 0; b <= 30; b++) {
                if (((num >> b) & 1) == 1) {
                    int cand = num & ~(1 << b);
                    if (cand < 0) continue;
                    if ((cand | (cand + 1)) == num) {
                        if (cand < minVal) {
                            minVal = cand;
                            found = true;
                        }
                    }
                }
            }
            
            res[i] = found ? minVal : -1;
        }
        
        return res;
    }
}
",1420041225
VISHAL V D,Vishal_V_D,610,3487,swift,"class Solution {
    func maxRemovals(_ source: String, _ pattern: String, _ targetIndices: [Int]) -> Int {
        let n = source.count
        let m = pattern.count
        let sourceArray = Array(source)
        let patternArray = Array(pattern)
        
        // Step 1: Create an array to track the minimum removals needed for each subsequence length
        var dpTable = Array(repeating: Int.max, count: m + 1)
        dpTable[0] = 0 // Base case: No characters matched, no removals needed
        
        // Step 2: Mark the indices where characters are removed from source
        var targetMarks = Array(repeating: false, count: n)
        for idx in targetIndices {
            targetMarks[idx] = true
        }

        // Step 3: Fill the dp table by comparing characters of source and pattern
        for i in 0..<n {
            for j in stride(from: m, through: 1, by: -1) {
                if sourceArray[i] == patternArray[j - 1], dpTable[j - 1] != Int.max {
                    let removalCount = dpTable[j - 1] + (targetMarks[i] ? 1 : 0)
                    dpTable[j] = min(dpTable[j], removalCount)
                }
            }
        }

        // Step 4: Determine the maximum number of operations that can be performed
        return dpTable[m] == Int.max ? targetIndices.count : targetIndices.count - dpTable[m]
    }
}
",1420105799
VISHAL V D,Vishal_V_D,610,3604,csharp,"using System;

public class Solution
{
    private const int MODULUS = 1000000007;

    public int NumberOfWays(int n, int x, int y)
    {
        // Create a table for combinations (C)
        long[,] combTable = new long[x + 1, x + 1];
        for (int i = 0; i <= x; i++)
        {
            combTable[i, 0] = 1; // Base case: C(i, 0) = 1
            for (int j = 1; j <= i; j++)
            {
                combTable[i, j] = (combTable[i - 1, j - 1] + combTable[i - 1, j]) % MODULUS;
            }
        }

        // Create a table for Stirling numbers of the second kind (S)
        long[,] stirlingNumbers = new long[n + 1, x + 1];
        stirlingNumbers[0, 0] = 1; // Base case: S(0, 0) = 1
        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= x; j++)
            {
                stirlingNumbers[i, j] = (j * stirlingNumbers[i - 1, j] + stirlingNumbers[i - 1, j - 1]) % MODULUS;
            }
        }

        // Create an array for factorial values
        long[] factorials = new long[x + 1];
        factorials[0] = 1; // Base case: 0! = 1
        for (int i = 1; i <= x; i++)
        {
            factorials[i] = (factorials[i - 1] * i) % MODULUS;
        }

        long totalDistinctWays = 0; // Variable to accumulate total ways
        // Calculate total number of distinct ways
        for (int k = 1; k <= x; k++)
        {
            long powerOfY = 1;
            for (int p = 0; p < k; p++)
            {
                powerOfY = (powerOfY * y) % MODULUS; // Calculate y^k
            }

            totalDistinctWays = (totalDistinctWays + combTable[x, k] * stirlingNumbers[n, k] % MODULUS * factorials[k] % MODULUS * powerOfY % MODULUS) % MODULUS;
        }

        return (int)totalDistinctWays; // Return the final result
    }
}
",1420118090
VISHAL V D,Vishal_V_D,610,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            found = False
            for x in range(num):
                if x | (x + 1) == num:
                    ans.append(x)
                    found = True
                    break
            if not found:
                ans.append(-1)
        return ans
",1420091104
Arunaditya Dasgupta,git-ADG,611,3604,cpp,"typedef long long ll;
const ll MOD = 1e9 + 7;
class Solution {
    vector<vector<int>> getComb(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            c[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> getStir(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                s[i][j] = (1ll * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }
        return s;
    }

    vector<int> getFact(int x) {
        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        return f;
    }

    ll modPow(int b, int e) {
        ll res = 1;
        while (e > 0) {
            if (e % 2 == 1) {
                res = (res * b) % MOD;
            }
            b = (1LL * b * b) % MOD;
            e /= 2;
        }
        return res;
    }
    
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> c = getComb(x);
        vector<vector<int>> s = getStir(n, x);
        vector<int> f = getFact(x);

        ll ans = 0;
        
        for (int k = 1; k <= x; k++) {
            ll yPow = modPow(y, k);
            ans = (ans + (1ll * c[x][k] * s[n][k] % MOD * f[k] % MOD * yPow % MOD)) % MOD;
        }
        
        return ans;
    }
};
",1420111982
Arunaditya Dasgupta,git-ADG,611,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i = 0; i < n; i++){
            ans[i] = -1;
        }
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= nums[i]; j++){
                if((j | (j + 1)) == nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420005177
Arunaditya Dasgupta,git-ADG,611,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int n : nums){
            bool flag = false;
            int a = INT_MAX;
            for(int i = 0; i < 32; i++){
                
                if(((n >> i) & 1) == 1){
                    int possible = n & ~(1 << i);
                    if(possible >= 0){
                        if((possible | (possible + 1)) == n){
                            a = min(possible, a);
                            flag = true;
                        }
                    }else continue;
                    
                }
                
            }
            if(flag) ans.push_back(a);
            else ans.push_back(-1);
        }
        return ans;
    }
};",1420093476
Shubham,Shubhaaaaam,612,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))
        
        return len(targetIndices) - (0 if dp[m] == float('inf') else dp[m])
",1420111987
Shubham,Shubhaaaaam,612,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        # No-op loop for consistency
        while params:
            break
        
        # Initialize combination array
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        # Initialize Stirling numbers of the second kind
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        # Factorial array initialization
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        # Calculate the result using the precomputed arrays
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420104429
Shubham,Shubhaaaaam,612,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        l=len(nums)
        ans=[]
        for i in range(0,l):
            ans.append(-1)
            for j in range(0,nums[i]):
                if (j|(j+1))==int(nums[i]):
                    ans[i]=j
                    break
                else:
                    j+1
        return ans",1420035331
Aastha Punjabi,aasthapunjabi0208i2003,614,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:

        MOD = 10**9 + 7

        # Step 1: Compute factorial and inverse factorial up to max(n, x)
        max_val = max(n, x)
        fact = [1] * (max_val + 1)
        for i in range(1, max_val + 1):
            fact[i] = fact[i - 1] * i % MOD

        inv_fact = [1] * (max_val + 1)
        inv_fact[max_val] = pow(fact[max_val], MOD - 2, MOD)
        for i in range(max_val - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        # Step 2: Compute Stirling numbers of the second kind S(n, k) for k=1 to x
        # Using dynamic programming with space optimization
        prev = [0] * (x + 1)
        prev[0] = 1  # S(0,0) = 1
        for i in range(1, n + 1):
            curr = [0] * (x + 1)
            for j in range(1, min(i, x) + 1):
                # S(i, j) = S(i-1, j-1) + j * S(i-1, j)
                curr[j] = (prev[j - 1] + j * prev[j]) % MOD
            prev = curr
        S = prev  # S[k] now contains S(n, k) for k=0 to x

        # Step 3: Calculate the total number of ways
        total = 0
        for k in range(1, x + 1):
            if k > n:
                continue  # S(n, k) = 0 for k > n
            # Compute C(x, k) = fact[x] / (fact[k] * fact[x - k]) mod MOD
            C = fact[x] * inv_fact[k] % MOD
            C = C * inv_fact[x - k] % MOD

            # Compute S(n, k) * k! mod MOD
            Sk = S[k] * fact[k] % MOD

            # Compute y^k mod MOD
            yk = pow(y, k, MOD)

            # Combine all components
            term = C * Sk % MOD
            term = term * yk % MOD

            # Add to the total
            total = (total + term) % MOD

        return total
            

        ",1420100552
Aastha Punjabi,aasthapunjabi0208i2003,614,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  
        
        for i in range(n):
            num = nums[i]
            
            for x in range(num): 
                if x | (x + 1) == num:
                    ans[i] = x
                    break 
        return ans
        ",1420007370
Aastha Punjabi,aasthapunjabi0208i2003,614,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            min_x = -1  # Initialize with -1
            k = 0
            temp_n = n
            while temp_n > 0:
                if temp_n & 1:
                    x = n - (1 << k)
                    if x >= 0 and (x | (x + 1)) == n:
                        if min_x == -1 or x < min_x:
                            min_x = x
                temp_n >>= 1
                k += 1
            ans.append(min_x)
        return ans
        ",1420034525
bluedot0330,bluedot0330,615,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int totalElements, int distinctGroups, int multiplier) {
        
        // Precompute combinations using Pascal's Triangle
        std::vector<std::vector<int>> combinations(distinctGroups + 1, std::vector<int>(distinctGroups + 1, 0));
        for (int i = 0; i <= distinctGroups; ++i) {
            combinations[i][0] = 1;  // C(i, 0) = 1
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        } 
        
        // Initialize Stirling numbers of the second kind
        std::vector<std::vector<int>> stirlingNumbers(totalElements + 1, std::vector<int>(distinctGroups + 1, 0));
        stirlingNumbers[0][0] = 1;  // S(0, 0) = 1
        for (int i = 1; i <= totalElements; ++i) {
            for (int j = 1; j <= distinctGroups; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD;
            }
        }
        
        // Precompute factorials
        std::vector<int> factorials(distinctGroups + 1, 1);
        for (int i = 1; i <= distinctGroups; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD;
        }
        
        // Calculate total ways
        long long totalWays = 0;
        for (int k = 1; k <= distinctGroups; ++k) {
            long long multiplierPower = 1; // y^k
            for (int i = 0; i < k; ++i) {
                multiplierPower = (multiplierPower * multiplier) % MOD;
            }
            totalWays = (totalWays + (1LL * combinations[distinctGroups][k] * stirlingNumbers[totalElements][k] % MOD * factorials[k] % MOD * multiplierPower % MOD)) % MOD;
        }
        return totalWays;
    }
};
",1420107345
bluedot0330,bluedot0330,615,3605,cpp,"#include <bits/stdc++.h>
#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(const vector<int>& nums) {
        vector<int> res;
        for (int n : nums) {
            bool ok = false;
            for (int x = 0; x < n; ++x) {
                if ((x | (x + 1)) == n) {
                    res.push_back(x);
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                res.push_back(-1);
            }
        }
        return res;
    }
};

int Main() {
    vector<int> nums = {3, 7, 5, 11};
    
    // Call the function via the Solution class
    vector<int> result = Solution().minBitwiseArray(nums);

    // Output the results
    for (int x : result) {
        cout << x << "" "";
    }
    cout << endl;

    return 0;
}
",1420006985
bluedot0330,bluedot0330,615,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int size = nums.size();
        vector<int> result(size);
        
        for (int i = 0; i < size; i++) {
            int currentNum = nums[i];
            int smallestCandidate = INT_MAX;
            bool candidateFound = false;
          
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (currentNum & (1 << bitPosition)) {
                    // Create a candidate by turning off the current bit
                    int modifiedNum = currentNum & ~(1 << bitPosition);
                    
                    // Ensure the modified number is non-negative
                    if (modifiedNum < 0) continue;
                    
                    // Check if we can achieve the original number by using | operator
                    if ((modifiedNum | (modifiedNum + 1)) == currentNum) {
                        // Update the smallest candidate if found
                        if (modifiedNum < smallestCandidate) {
                            smallestCandidate = modifiedNum;
                            candidateFound = true;
                        }
                    }
                }
            }
            
            // Assign the result based on whether a candidate was found
            result[i] = candidateFound ? smallestCandidate : -1;
        }
        
        return result;
    }
};
",1420102832
Himanshu Gaurav,HimanshuGaurav,616,3604,cpp,"class Solution{
public:
    const int m = 1e9+7;
    int numberOfWays(int n,int x,int y){
        vector<vector<int>> arr(x+1,vector<int>(x+1,0));
        for (int i=0 ; i<=x ; i++){
            arr[i][0] = 1;
            for (int j=1 ; j<=i ; j++){
                arr[i][j] = (arr[i-1][j-1]+arr[i-1][j])%m;
            }
        } 
        vector<vector<int>> dp(n+1,vector<int>(x+1,0));
        dp[0][0] = 1;
        for (int i=1 ; i<=n; i++){
            for (int j=1 ; j<=x; j++){
                dp[i][j] = (1LL*j*dp[i-1][j]+dp[i-1][j-1])%m;
            }
        }
        vector<int> f(x+1,1);
        for (int i=1 ; i<=x ; i++){
            f[i] = (1LL*f[i-1]*i)%m;
        }
        long long ans = 0;
        for (int i=1 ; i<=x ; i++){
            long long t = 1;
            for (int j=0 ; j<i ; j++){
                t = (t*y)%m;
            }
            ans = (ans+(1LL*arr[x][i]*dp[n][i]%m*f[i]%m*t%m))%m;
        }
        return ans;
    }
};",1420113848
Himanshu Gaurav,HimanshuGaurav,616,3605,cpp,"class Solution{
public:
    vector<int> minBitwiseArray(vector<int> &nums){
        int n = nums.size();
        vector<int> out(n);
        for (int i=0 ; i<n ; i++){
            bool t = true;
            for (int j=0 ; j<nums[i] ; j++){
                if ((j|(j+1))==nums[i]){
                    out[i] = j;
                    t = false;
                    break;
                }
            }
            if (t) out[i] = -1;
        }
        return out;
    }
};",1420011267
Himanshu Gaurav,HimanshuGaurav,616,3611,cpp,"class Solution{
public:
    vector<int> minBitwiseArray(vector<int>& nums){
        int n = nums.size();
        vector<int> out(n);
        for (int i=0 ; i<n ; i++){
            int x = nums[i];
            int mini = INT_MAX;
            bool t = false;
            for (int k=0 ; k<31 ; k++){
                if ((x>>k)&1){
                    int j = x&~(1<<k);
                    if (j>=0 && (j|(j+1))==x && j<mini){
                        mini = j;
                        t = true;
                    }
                }
            }
            if (t) out[i] = mini;
            else out[i] = -1;
        }
        return out;
    }
};",1420067142
turtleman271,turtleman271,617,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        #start with one person on any x stages
        stages = [0]*x
        stages[0] = x
        for i in range(n-1):
            nextStages = [i for i in stages]
            #print(nextStages)
            for j in range(1,len(stages)):
                if j<len(stages):
                    nextStages[j]*=(j+1)
                emptySpots = len(stages)-j
                prev = stages[j-1]
                nextStages[j] += emptySpots*prev
            stages = nextStages
        #print(stages)
        res = 0
        for i in range(len(stages)):
            #print(stages[i], y, (i+1))
            res+=stages[i]*(y**(i+1))
            res%=(10**9+7)
        return res

""""""
        [3,0,0]
        [3,6,0]
        [3,18,6]
        3*4^1+18*4^2+6*4^3 = 684

        c,,
        ,c,
        ,,c
        [3,0,0]

        bc,,
        c,b,
        c,,b
        b,c,
        ,bc,
        ,c,b
        b,,c
        ,b,c
        ,,bc
        [3,6,0]

        
        abc,,
       bc,a,
       bc,,a
       ac,b,
       c,ab,
        c,b,a
       ac,,b
        c,a,b
       c,,ab
       ab,c,
       b,ac,
        b,c,a
       a,bc,
        ,abc,
       ,bc,a
        a,c,b
       ,ac,b
       ,c,ab
       ab,,c
        b,a,c
       b,,ac
        a,b,c
       ,ab,c
       ,b,ac
       a,,bc
       ,a,bc
        ,,abc
        [3,18,6]
        """"""",1420113900
turtleman271,turtleman271,617,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        for i in range(len(nums)):
            cur = nums[i]
            result.append(-1)
            for j in range(1, cur):
                if j | j+1 == cur:
                    result[-1] = j
                    break
        return result",1420006054
turtleman271,turtleman271,617,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        result = []
        pows = []
        a = 1
        while a <= 1000000000:
            pows.append(a)
            a*=2
        print(pows)

        for i in range(len(nums)):
            cur = nums[i]
            result.append(-1)
            for j in pows:
                other = cur - j
                if other | other+1 == cur:
                    result[-1] = other
                
        return result",1420025397
Procodgok,Procodgok,618,3604,cpp,"#define ll long long int
#define mod 1000000007
#define modsum(a,b)  ((a%mod)+(b%mod))%mod
#define modpro(a,b)  ((a%mod)*(b%mod))%mod
#define moddif(a,b)  ((a%mod)-(b%mod)+mod)%mod
#define modsumt(a,b,c) modsum(a,modsum(b,c))
ll modularExponentiation(ll x,ll n,ll M)
{
    ll result=1;
    while(n>0)
    {
        if(n % 2 ==1)
            result=modpro(result,x);
        x=modpro(x,x);
        n=n/2;
    }
    return result;
}
ll  modInverse(ll n, ll p) 
{ 
    return modularExponentiation(n, p - 2, p); 
} 

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector <ll> fact(2005);
        vector <ll> modf(2005);
        fact[0]=1;
        for(ll i=1;i<=2000;i++) fact[i]=(i*fact[i-1])%mod;
        for(ll i=0;i<=2000;i++) modf[i]=modInverse(fact[i],mod);
        ll sum=0;
        ll py=1;
        ll ans=0;
        int z=min(x,n);
        vector <ll> ways(z+1);
        for(ll i=1;i<=z;i++){
           ways[i]=modularExponentiation(i,n,mod);
           for(ll j=1;j<i;j++){
              ways[i]=moddif(ways[i],modpro(ways[j],modpro(fact[i],modpro(modf[j],modf[i-j]))));
           }
        }
        for(ll i=1;i<=z;i++){
            ll xci = modpro(fact[x],modpro(modf[i],modf[x-i]));
            py=modpro(py,y);
            ans = modsum(ans,modpro(xci,modpro(py,ways[i])));
        }
        int ans1=ans;
        return ans1;
    }
};",1420120226
Procodgok,Procodgok,618,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        ans.resize(nums.size());
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2) ans[i]=-1;
            else{
               int x=nums[i];
               for(int j=0;j<30;j++){
                  if(nums[i] & (1<<j)) {}
                  else{
                    x-=(1<<(j-1));
                    break;
                  }
               }
               ans[i]=x;
            }
        }
        return ans;
    }
};",1420006470
Procodgok,Procodgok,618,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector <int> ans;
        ans.resize(nums.size());
        for(int i=0;i<nums.size();i++){
            if(nums[i]==2) ans[i]=-1;
            else{
               int x=nums[i];
               for(int j=0;j<30;j++){
                  if(nums[i] & (1<<j)) {}
                  else{
                    x-=(1<<(j-1));
                    break;
                  }
               }
               ans[i]=x;
            }
        }
        return ans;
    }
};",1420007770
Ajitesh Bharti,ajitesh98,619,3604,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    vector<int> fac;
    vector<vector<int>> c;
    vector<vector<int>> sub;

    Solution() {
        fac = vector<int>(1002, 1);
        c = vector<vector<int>>(1002, vector<int>(1002, 0));
        sub = vector<vector<int>>(1002, vector<int>(1002, 0));
    }

    void fact(int n) {
        for (int i = 1; i <= n; i++) {
            fac[i] = (1ll * fac[i - 1] * i) % mod;
        }
    }

    void comb(int n) {
        for (int i = 0; i <= n; i++) {
            c[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
            }
        }
    }

    void subs(int n) {
        sub[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                sub[i][j] = (1ll * j * sub[i - 1][j] % mod + sub[i - 1][j - 1]) % mod;
            }
        }
    }

    long long modPow(long long base, long long exp, long long mod) {
        long long result = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }

    int numberOfWays(int n, int x, int y) {
        fact(x);
        comb(x);
        subs(n);

        long long res = 0;
        for (int i = 1; i <= x; i++) {
            long long p = modPow(y, i, mod);
            res = (res + 1ll * c[x][i] * sub[n][i] % mod * fac[i] % mod * p % mod) % mod;
        }
        return res;
    }
};
",1420107556
Ajitesh Bharti,ajitesh98,619,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0;i<n;i++){
            for(int j=0;j<=nums[i];j++){
                int curr = j+1;
                if((j|curr)==nums[i]){
                    ans[i] = j;
                    break;
                }
            }
        }
        return ans;
    }
};",1420003977
Ajitesh Bharti,ajitesh98,619,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for (auto v:nums) {
            vector<int> temp;
            for (int i = 0; i < 32; ++i) {
                if (v & (1 << i)) {
                    int x = v & ~(1 << i);
                    if ((x | (x + 1)) == v) {
                        temp.push_back(x);
                    }
                }
            }
            if (temp.empty()) {
                ans.push_back(-1);
            } else {
                int minm = 1e9;
                for(auto v:temp) minm = min(minm, v);
                ans.push_back(minm);
            }
        }
        return ans;
    }
};",1420050582
Rahul Singh,Pirate-Emperor,620,3604,cpp,"#define ll long long
#define TxtIO   freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);

const int MAXN = 3e6 + 5; 
const int MAX_N = 2e5 + 1;
ll MOD = 1e9+7;
const ll MOD2 = 1073676287;
const ll MOD3 = 998244353;
const ll INF = 1e9;
const ll LINF = 1e18;

ll qexp(ll a, ll b, ll m) {
    ll res = 1;
    while (b) {
        if (b % 2) res = res * a % m;
        a = a * a % m;
        b /= 2;
    }
    return res;
}

vector<ll> fact, invf;

void precompute(int n) {
    fact.assign(n + 1, 1); 
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;
    invf.assign(n + 1, 1);
    invf[n] = qexp(fact[n], MOD - 2, MOD);
    for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;
}

ll nCk(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * invf[k] % MOD * invf[n - k] % MOD;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        precompute(1e4);
        long long res=0;
        for (int i=x;i>=1;i--)
        {
            if (n<i) continue;
            else
            {
                ll tem=0;
                int k=0;
                for (int j=i;j>=1;j--)
                {
                    ll t1 = (nCk(i,j)*qexp(j,n,MOD))%MOD;
                    if (k%2==0) tem=(tem+t1)%MOD;
                    else tem=(tem-t1+MOD)%MOD;
                    k++;
                }
                int temp = (nCk(x,i)*tem)%MOD;
                // temp = tem;
                temp = (temp*qexp(y,i,MOD))%MOD;
                
                // temp = (temp*nCk(n,i))%MOD;
                res=(res+temp)%MOD;
            }
        }
        int resu = res;
        return resu;
    }
};",1420120390
Rahul Singh,Pirate-Emperor,620,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> temp(2e3+10,-1);
        for (int i=1e3;i>=0;i--)
        {
            int tem = i | (i+1);
            temp[tem]=i;
        }
        int n=nums.size();
        vector<int> res(n);        
        for (int i=0;i<n;i++)
        {
            res[i]=temp[nums[i]];
        }
        return res;
    }
};",1420005171
Rahul Singh,Pirate-Emperor,620,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i=0;i<n;i++)
        {
            int x = nums[i];
            if (x==2) res[i]=-1;
            else
            {
                int temp=0;
                while(x>0)
                {
                    if (x%2==0) break;
                    else 
                    {
                        temp*=2;
                        temp++;
                    }
                    x/=2;
                }
                res[i] = nums[i]^temp;
                temp>>=1;
                res[i]^=temp;

            }
        }
        return res;
    }
};",1420016053
manohar-reddy-yaram,manohar-reddy-yaram,621,3604,cpp,"class Solution {
public:
    static const int MODULUS = 1e9 + 7;

    int numberOfWays(int totalItems, int groupCount, int multiplier) {
        
        std::vector<std::vector<int>> binomialCoeff(groupCount + 1, std::vector<int>(groupCount + 1, 0));
        for (int i = 0; i <= groupCount; ++i) {
            binomialCoeff[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                binomialCoeff[i][j] = (binomialCoeff[i - 1][j - 1] + binomialCoeff[i - 1][j]) % MODULUS;
            }
        } 
        std::vector<std::vector<int>> stirlingNumbers(totalItems + 1, std::vector<int>(groupCount + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= totalItems; ++i) {
            for (int j = 1; j <= groupCount; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MODULUS;
            }
        }
        std::vector<int> factorials(groupCount + 1, 1);
        for (int i = 1; i <= groupCount; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MODULUS;
        }
        long long result = 0;
        for (int k = 1; k <= groupCount; ++k) {
            long long multiplierPower = 1;
            for (int i = 0; i < k; ++i) {
                multiplierPower = (multiplierPower * multiplier) % MODULUS;
            }
            result = (result + (1LL * binomialCoeff[groupCount][k] * stirlingNumbers[totalItems][k] % MODULUS * factorials[k] % MODULUS * multiplierPower % MODULUS)) % MODULUS;
        }
        return result;
    }
};",1420107772
manohar-reddy-yaram,manohar-reddy-yaram,621,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        # Initialize the output array with -1
        output = [-1] * len(nums)
        # Iterate over the indices of the input array
        for index in range(len(nums)):
            # Iterate over possible values of output[index]
            for candidate in range(nums[index]):
                # Check if the condition is satisfied
                if candidate | (candidate + 1) == nums[index]:
                    # Update the output array with the minimum possible value
                    output[index] = candidate
                    break
        # Return the output array
        return output",1420024401
manohar-reddy-yaram,manohar-reddy-yaram,621,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> inputList) {
        int length = inputList.size();
        int[] result = new int[length];
        
        for (int index = 0; index < length; index++) {
            int currentNum = inputList.get(index);
            int minValue = Integer.MAX_VALUE;
            boolean validFound = false;
            
            for (int bitPosition = 0; bitPosition <= 30; bitPosition++) {
                if (((currentNum >> bitPosition) & 1) == 1) {
                    int potentialResult = currentNum & ~(1 << bitPosition);
                    
                    if (potentialResult < 0) continue;
                    
                    if ((potentialResult | (potentialResult + 1)) == currentNum) {
                        if (potentialResult < minValue) {
                            minValue = potentialResult;
                            validFound = true;
                        }
                    }
                }
            }
            
            result[index] = validFound ? minValue : -1;
        }
        
        return result;
    }
}
",1420081767
clashgamer1050,clashgamer1050,622,3604,cpp,"#include<iostream>
#include<vector>

#define ll long long 
#define NUM 1000000007

using namespace std;

class Solution {
private:
    ll ypowerk(int& y, int& k)
    {
        ll ans = 1;
        for(int i = 0; i<k; i++)
        {
            ans = (ans*y)%NUM ;
        }
        return ans;
    }

    ll xCk(int x, int k, vector<vector<int>>& binomial)
    {
        if(x<k) { return 0 ;}
        if(k==1) { return x ;}
        if(binomial[x][k]) { return binomial[x][k] ; }
        binomial[x][k] = (xCk(x-1, k, binomial) + xCk(x-1, k-1, binomial))%NUM ;
        return binomial[x][k] ;
    }

    ll  M(int n, int k, vector<vector<int>>& dp)
    {
        // We return modulo NUm
        if(k>n) { return 0 ;}
        if(dp[n][k]) { return dp[n][k] ; }
        dp[n][k] = (k*(M(n-1, k, dp) + M(n-1, k-1, dp)))%NUM ;
        return dp[n][k] ;
    }
public:
    int numberOfWays(int n, int x, int y)
    {
        // We iterate over number of stages used ie k
        vector<vector<int>> dp(n+1, vector<int>(x+1, 0)) ;
        vector<vector<int>> binomial(x+1, vector<int>(x+1, 0)) ;
        
        for(int i = 1; i<=n; i++) { dp[i][1] = 1 ; }
        // dp[n][k] represents M(n, k) ;
        ll w = 0 ;
        for(int k = 1; k<=x; k++)
        {
            w = (w + (((xCk(x, k, binomial)*M(n, k, dp))%NUM)*(ypowerk(y, k)))%NUM)%NUM ;
        }
        return w ;
    }
};

auto init = [](){
    std :: ios :: sync_with_stdio(false) ;
    std :: cin.tie(nullptr) ;
    std :: cout.tie(nullptr) ;
    return 0;
}() ;",1420120671
clashgamer1050,clashgamer1050,622,3605,cpp,"#include<iostream>
#include<vector>

using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums)
    {
        int n = nums.size() ;
        vector<int> M(n, -1);

        // only for 2 do we have no M[i]
        int t, sub;
        for(int i = 0; i<n; i++)
        {
            if(nums[i]==2) { continue ; }

            // If n 1's at the end in binary then nums[i] - 2^(n-1) is the min
            sub = 1;
            t = nums[i]>>1 ;
            while(t%2!=0)
            {
                t = t>>1 ;
                sub = 2*sub ;
            }
            M[i] = nums[i] - sub ;
        }

        return M ;
    }
};

auto init = [](){
    std :: ios :: sync_with_stdio(false) ;
    std :: cin.tie(nullptr) ;
    std :: cout.tie(nullptr) ;
    return 0;
}() ;",1420017892
clashgamer1050,clashgamer1050,622,3611,cpp,"#include<iostream>
#include<vector>

using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums)
    {
        int n = nums.size() ;
        vector<int> M(n, -1);

        // only for 2 do we have no M[i]
        int t, sub = 1;
        for(int i = 0; i<n; i++)
        {
            if(nums[i]==2) { continue ; }

            // If n 1's at the end in binary then nums[i] - 2^(n-1) is the min
            sub = 1;
            t = nums[i]>>1 ;
            while(t%2!=0)
            {
                t = t>>1 ;
                sub = 2*sub ;
            }
            M[i] = nums[i] - sub ;
        }

        return M ;
    }
};

auto init = [](){
    std :: ios :: sync_with_stdio(false) ;
    std :: cin.tie(nullptr) ;
    std :: cout.tie(nullptr) ;
    return 0;
}() ;",1420030810
Nirvana,soham_patwari,624,3487,java,"class Solution {
    public int maxRemovals(String source, String pattern, int[] targetIndices) {
        int n = source.length();
        int m = pattern.length();

        int[]  dp = new int[m +1];

        boolean [] isTarget = new boolean[n];

        for(int i = 0 ; i < m + 1 ; i++){
            dp[i] = Integer.MAX_VALUE;
        }

        dp[0] = 0;

        for(int now : targetIndices){
            isTarget[now] = true;
        }

        for(int i = 0 ; i < n ; i++){
            for(int j = m ; j > 0 ; j--){
                if(source.charAt(i)== pattern.charAt(j-1) && dp[j-1] != Integer.MAX_VALUE)
                 dp[j] = Math.min(dp[j] , dp[j-1] + (isTarget[i] ? 1 : 0));
            }
        }

        return targetIndices.length - (dp[m] == Integer.MAX_VALUE ? 0 : dp[m]);
    }
}",1420118315
Nirvana,soham_patwari,624,3604,java,"class Solution {

    final int MOD = 1000000007;
    public int numberOfWays(int n, int x, int y) {
        int[][] comb = new int[x + 1][x + 1];
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        int[][] stirling = new int[n + 1][x + 1];
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (int) ((1L * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD);
            }
        }
        int[] factorial = new int[x + 1];
        factorial[0] = 1;
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (int) ((1L * factorial[i - 1] * i) % MOD);
        }
        long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1L * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return (int) total_ways;
    }
}",1420121382
Nirvana,soham_patwari,624,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int [] ans = new int[n];

        for(int i = 0 ; i < n ; i++){
            if(nums.get(i)==2){
                ans[i] = -1;
            }
            else{
                ans[i] = 1;
                while(true){
                    if((ans[i] | (ans[i] + 1 )) == nums.get(i)){
                        break;
                    }

                    ans[i]++;
                }
            }
        }

        return ans;
    }
}",1419999593
Jb1u4WvKYq,Jb1u4WvKYq,625,3604,cpp,"class Solution {
public:
    long long mod = 1e9+7;
    vector<long long> inv;
    int numberOfWays(int n, int x, int y) {
        long long ans=0,comb=1,power=1;
        vector<long long>collection(x+1,1);
        for(int i=0;i<x+1;i++){
            for(int j=0;j<n;j++){
                collection[i]*=i;
                collection[i]%=mod;
            }
        }
        inv.push_back(1);
        for(int i=1;i<=x;i++){
            long long x,y;
            extendedgcd(i,mod,x,y);
            inv.push_back(x);
        }
        for(int k=1;k<=x;k++){
            long long temp = help(k,n,collection);
            comb=(comb*(x-k+1))%mod;
            comb=(comb*inv[k])%mod;
            power*=y;
            power%=mod;
            long long t = comb*temp;
            t%=mod;
            t*=power;
            t%=mod;
            ans+=t;
            ans%=mod;
            
        }
        return ans;
    }
    long long help(long long k, long long n,vector<long long>&collection){
        long long val=collection[k],comb=1;
        for(int i=1;i<=k;i++){
            comb=(comb*(k-i+1))%mod;
            comb=(comb*inv[i])%mod;
            if(i&1){
                long long temp = comb*collection[k-i];
                temp%=mod;
                val=(val-temp+mod)%mod;
            }
            else {
                long long temp = comb*collection[k-i];
                temp%=mod;
                val+=temp;
                val%=mod;
            }
        }
        return val;
    }
    void extendedgcd(long long a,long long n,long long  &x,long long  &y){
        if(a==0){
            y=1;
            x=0;
            return;
        }
        long long x1,y1;
        extendedgcd(n%a,a,x1,y1);
        x=(y1-(((n/a)*x1)%mod)+3*mod)%mod;
        y=x1;
    }
};",1420108782
Jb1u4WvKYq,Jb1u4WvKYq,625,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            ans.push_back(help(nums[i]));
        }
        return ans;
    }
    int help(int x){
        if(x==2) return -1;
        int id=0;
        for(;id<31;id++){
            if((x&(1<<id))==0)break;
        }
        x^=1<<(id-1);
        return x;
    }
};",1420009866
Jb1u4WvKYq,Jb1u4WvKYq,625,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            ans.push_back(help(nums[i]));
        }
        return ans;
    }
    int help(int x){
        if(x==2) return -1;
        int id=0;
        for(;id<31;id++){
            if((x&(1<<id))==0)break;
        }
        x^=1<<(id-1);
        return x;
    }
};",1420009161
Anurag Narayan Jena,anj20,626,3604,cpp,"typedef long long ll;
class Solution {
private:
    const int MOD = 1e9 + 7;
    ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
    ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
    ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
    ll binpow(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}

    vector<ll> pre_fact(int x) 
    {
        vector<long long> fact(x + 1, 1);
        for (int i = 1; i <= x; ++i)fact[i] =mod_mul(fact[i - 1], i, MOD);
        return fact;
    }
    vector<vector<ll>> pre_Part(int n, int x) 
    {
        vector<vector<ll>> part(n + 1, vector<ll>(x + 1, 0));
        part[0][0] = 1;
        for (int i = 1; i <= n; ++i) 
            for (int j = 1; j <= x; ++j)part[i][j] = mod_add(j * part[i - 1][j],part[i - 1][j - 1],MOD);
        return part;
    }
    vector<vector<ll>> pre_computeComb(int x)
    {
        vector<vector<ll>> comb(x + 1, vector<ll>(x + 1, 0));
        for(int i=0;i<=x;i++)comb[i][0]=1;
        for (int i = 0; i <= x; ++i) 
            for (int j = 1; j <= i; ++j)comb[i][j] = mod_add(comb[i-1][j],comb[i-1][j-1],MOD);
        return comb;
    }   

public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<ll>> comb =pre_computeComb(x);
        vector<vector<ll>> part =pre_Part(n, x);
        vector<ll> fact=pre_fact(x);
        ll ans = 0ll;
        for (int k = 1; k <= x; ++k) 
        {
            ll curr=mod_mul(comb[x][k],part[n][k],MOD);// c(x,k)*p(n,k)
            curr = mod_mul(mod_mul(curr,binpow(y,k,MOD),MOD),fact[k],MOD); // y^k*fact[k]
            ans= mod_add(ans,curr,MOD);
        }
        return (int)ans;
    }
};",1420121474
Anurag Narayan Jena,anj20,626,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2==0)continue;
            int k;
            for(k=0;k<31;k++)
            {
                if(((nums[i]>>k)&1ll)==0)
                {
                    // cout<<k<<' ';
                    break;
                }
            }
            k--;
            // cout<<k<<' ';
            ans[i]=nums[i]-(1ll<<k);
        }
        return ans;
    }
};",1420017332
Anurag Narayan Jena,anj20,626,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>ans(n,-1);
        for(int i=0;i<n;i++)
        {
            if(nums[i]%2==0)continue;
            int k;
            for(k=0;k<31;k++)
            {
                if(((nums[i]>>k)&1ll)==0)break;
            }
            k--;
            ans[i]=nums[i]-(1ll<<k);
        }
        return ans;
    }
};",1420019581
3905aj,3905aj,627,3604,cpp,"const long long mod = 1e9+7;
class Solution {
public:
    

    long long binpow(long long a, long long b){
        long long res = 1;
        while(b){
            if(b&1) res = (res*a)%mod;
            a = (a*a)%mod;
            b>>=1;
        }
        return res;
    }

    long long minv(long long x){
        return binpow(x, mod-2);
    }

    long long ncr(vector<long long> &fact, long long n, long long r){
        return ((fact[n]*minv(fact[r]))%mod)*minv(fact[n-r])%mod;
    }

    int numberOfWays(int n, int x, int y) {
        vector<long long> fact(max(n,x)+1,1);
        for(int i = 1; i<max(n,x)+1; i++) fact[i] = (i*fact[i-1])%mod;
        long long ans = 0;
        for(long long r = 1; r<=min(n,x); r++){
            long long t = 0;
            for(long long i = 0; i<=r; i++){
                if((i%2)==0) t+=binpow(r-i,n)*ncr(fact,r,i)%mod;
                else t-=binpow(r-i,n)*ncr(fact,r,i)%mod;
                t = (t%mod + mod)%mod;
            }
            t*=ncr(fact,x,r);
            t%=mod;
            ans = (ans + t*binpow(y,r)%mod)%mod;
        }
        return ans;
    }
};",1420121584
3905aj,3905aj,627,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto p : nums){
            if(p==2) ans.push_back(-1);
            else {
                int x = 0;
                while(p&(1<<x) && p&(1<<(x+1))) x++;
                ans.push_back(p-(1<<x));
            }
        }
        return ans;
    }
};",1420011486
3905aj,3905aj,627,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto p : nums){
            if(p==2) ans.push_back(-1);
            else {
                int x = 0;
                while(p&(1<<x) && p&(1<<(x+1))) x++;
                ans.push_back(p-(1<<x));
            }
        }
        return ans;
    }
};",1420010072
Aman pratap singh,aman_2721,628,3487,python3,"from typing import List

class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        n = len(source)
        m = len(pattern)
        dp = [float('inf')] * (m + 1)
        dp[0] = 0        
        isTarget = [False] * n
        for idx in targetIndices:
            isTarget[idx] = True
        for i in range(n):
            for j in range(m, 0, -1):
                if source[i] == pattern[j-1] and dp[j-1] != float('inf'):
                    dp[j] = min(dp[j], dp[j-1] + (1 if isTarget[i] else 0))        
        if dp[m] == float('inf'):
            return 0
        return len(targetIndices) - dp[m]
        ",1420121762
Aman pratap singh,aman_2721,628,3604,python3,"from typing import List

MOD = 10**9 + 7

class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        params = [n, x, y]
        
        while params:
            break
        
        
        comb = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            comb[i][0] = 1
            for j in range(1, i + 1):
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD
        
        
        stirling = [[0] * (x + 1) for _ in range(n + 1)]
        stirling[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD
        
        
        factorial = [1] * (x + 1)
        for i in range(1, x + 1):
            factorial[i] = factorial[i - 1] * i % MOD
        
        
        total_ways = 0
        for k in range(1, x + 1):
            y_pow = pow(y, k, MOD)
            total_ways = (total_ways + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD) % MOD
        
        return total_ways",1420107530
Aman pratap singh,aman_2721,628,3605,python,"class Solution(object):
    def minBitwiseArray(self, nums):
        l=len(nums)
        ans=[]
        for i in range(0,l):
            ans.append(-1)
            for j in range(0,nums[i]):
                if (j|(j+1))==int(nums[i]):
                    ans[i]=j
                    break
                else:
                    j+1
        return ans
        ",1420089907
Kashyap Vekariya,kashyap1905,629,3604,python3,"class Solution:
    MOD = 10**9 + 7
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        pastri = [[0] * (x + 1) for _ in range(x + 1)]
        for i in range(x + 1):
            pastri[i][0] = 1
            for j in range(1, i + 1):
                pastri[i][j] = (pastri[i-1][j-1] + pastri[i-1][j]) % self.MOD

        belnum = [[0] * (x + 1) for _ in range(n + 1)]
        belnum[0][0] = 1
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                belnum[i][j] = (j * belnum[i-1][j] + belnum[i-1][j-1]) % self.MOD

        fact = [1] * (x + 1)
        for i in range(1, x + 1):
            fact[i] = (fact[i-1] * i) % self.MOD

        totalcom = 0
        for k in range(1, x + 1):
            scalfact = pow(y, k, self.MOD)
            curcomb = (
                pastri[x][k] *
                belnum[n][k] *
                fact[k] *
                scalfact
            ) % self.MOD
            totalcom = (totalcom + curcomb) % self.MOD

        return totalcom",1420115609
Kashyap Vekariya,kashyap1905,629,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n  
            
        for j in range(n):
            num = nums[j]
            min_ans = float('inf')
            found = False
            
            for i in range(31):
                if (num >> i) & 1 == 1:
                    candidate = num & ~(1 << i)
                    
                    if candidate < 0:
                        continue
                    
                    if (candidate | (candidate + 1)) == num:
                        if candidate < min_ans:
                            min_ans = candidate
                            found = True
            
            ans[j] = min_ans if found else -1
        
        return ans",1420055727
Kashyap Vekariya,kashyap1905,629,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        for j in range(n):
            num = nums[j]
            min_ans = float('inf')
            found = False
            
            for i in range(31):
                if (num >> i) & 1 == 1:
                    candidate = num & ~(1 << i)
                    
                    if candidate < 0:
                        continue
                    
                    if (candidate | (candidate + 1)) == num:
                        if candidate < min_ans:
                            min_ans = candidate
                            found = True
            
            ans[j] = min_ans if found else -1
        
        return ans",1420056509
Dilworth,dilworth,630,3604,cpp,"class Solution {
    const int mod = 1e9 + 7;
    int add(int a, int b) {
        a += b;
        if (a >= mod) a -= mod;
        if (a < 0) a += mod;
        return a;
    }
    
    int mul(int a, int b) {
        a = (1LL * (a % mod) * (b % mod)) % mod;
        return a;
    }

    int mpow(int x, int y) {
        int res = 1;
        while (y > 0) {
            if (y & 1) res = mul(res, x);
            y >>= 1;
            x = mul(x, x);
        }
        return res;
    }

    vector<vector<int>> stirlingNumber(int n, vector<int> &fact) {
        vector<vector<int> > dp(
            n + 1, vector<int>(n + 1, 0));
    
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= min(i, n); j++) {
                if (j == 1 || j == i) dp[i][j] = 1;
                else dp[i][j] = add(dp[i - 1][j - 1], mul(j, dp[i - 1][j]));
            }
        }

        return dp;
    }

    vector<int> factorial(int n) {
        vector<int> fact(n + 1, 0);
        fact[0] = 1;
        for (int i = 1; i <= n; ++i) {
            fact[i] = mul(fact[i - 1], i);
        }
        return fact;
    }


    vector<vector<int>> nCr(int n) {
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= min(i, n); ++j) {
                if (j == 0 || j == i) dp[i][j] = 1;
                else dp[i][j] = add(dp[i - 1][j - 1], dp[i - 1][j]);
            }
        }
        return dp;
    }
public:
    int numberOfWays(int n, int x, int y) {
        int ans = mul(x, y);
        cout << ans << '\n';
        int v = max(n, x) + 1;
        auto fact = factorial(v);
        auto stir = stirlingNumber(v, fact);
        auto ncr = nCr(v);
        for (int i = 2; i <= min(n, x); ++i) {
            int cur = ncr[x][i];
            cout << ncr[x][i] << ' ';
            cur = mul(cur, fact[i]);
            cout << fact[i] << ' ';
            cur = mul(cur, stir[n][i]);
            cout << stir[n][i] << ' ';
            cout << cur << '\n';
            cur = mul(cur, mpow(y, i));
            ans = add(ans, cur);
        }
        cout << '\n';
        return ans;
    }
};",1420122146
Dilworth,dilworth,630,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); ++i) {
            int val = nums[i];
            int now = -1;
            for (int cur = 1; cur <= 2000; ++cur) {
                if ((cur | (cur + 1)) == val) {
                    now = cur; break;
                }
            }
            ans[i] = now;
        }
        return ans;
    }
};",1419994607
Dilworth,dilworth,630,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto x: nums) {
            int k = 0;
            while (x & (1 << k)) ++k;
            --k;
            if (k == -1) ans.push_back(-1);
            else {
                int rem = 0;
                int st = k + 1;
                while (st < 31) {
                    if (x & (1 << st)) rem |= (1 << st);
                    ++st;
                }
                int vl = (1 << k) | rem;
                if ((vl | (vl - 1)) == x) ans.push_back(vl - 1);
                else ans.push_back(x - 1);
            }
        }
        return ans;
    }
};",1420027656
Beats Stucker,Stuckers,631,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();  
        int m = pattern.length(); 

        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;  
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;  
        }

       
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {  
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

       
        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};",1420088099
Beats Stucker,Stuckers,631,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420122167
Beats Stucker,Stuckers,631,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

    for (int num : nums) {
        bool found = false;

       
        for (int i = 0; i < num; ++i) {
            if ((i | (i + 1)) == num) {
                ans.push_back(i);
                found = true;
                break;
            }
        }

               if (!found) {
            ans.push_back(-1);
        }
    }

    return ans;

    }
};",1420036809
John Rigby,vanshkunwarji41,632,3604,cpp,"const long long M=1e9+7;
class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        long long dp[n][x+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<=x;j++){
                if(i==0){
                    if(j==1){
                        dp[i][j]=x*y;
                    }
                    else{
                        dp[i][j]=0;
                    }
                }
                else{
                    dp[i][j]=(j*dp[i-1][j])%M;
                    if(j!=0){
                        dp[i][j]=(dp[i][j]+(dp[i-1][j-1]*(x-j+1)*y)%M)%M;
                    }
                }
                // cout<<i<<"" ""<<j<<"" ""<<dp[i][j]<<endl;
            }    
        }
        long long h=0;
        for(int i=0;i<=x;i++){
            // cout<<dp[n]
            h=(h+dp[n-1][i])%M;
        }
        return h;
    }
};",1420122640
John Rigby,vanshkunwarji41,632,3605,cpp,"class Solution {
public:
    int f(int x){
        if(x==1){
            return 0;
        }
        int u=0;
        for(int i=31;i>=0;i--){
            if(x&(1<<i)){
                u=i;
                break;
            }
        }
        if(((1<<u)|((1<<u)-1))==x){
            return (1<<u)-1;
        }
        // if(x==5){
        //     cout<<u<<endl;
        // }
        return (1<<u)+f(x-(1<<u));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(auto &i:nums){
            if(i==2){
                i=-1;
                continue;
            }
            i=f(i);
        }
        return nums;
    }
};",1420020416
John Rigby,vanshkunwarji41,632,3611,cpp,"class Solution {
public:
    int f(int x){
        if(x==1){
            return 0;
        }
        int u=0;
        for(int i=31;i>=0;i--){
            if(x&(1<<i)){
                u=i;
                break;
            }
        }
        if(((1<<u)|((1<<u)-1))==x){
            return (1<<u)-1;
        }
        // if(x==5){
        //     cout<<u<<endl;
        // }
        return (1<<u)+f(x-(1<<u));
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(auto &i:nums){
            if(i==2){
                i=-1;
                continue;
            }
            i=f(i);
        }
        return nums;
    }
};",1420020246
Manish Kumar,yhYTzMtNQt,633,3604,cpp,"#define ff first
#define sz size()
#define ss second
#define ll long long 
#define pb push_back
#define vll vector<ll>
#define ump unordered_map
#define all(x) x.begin(),x.end()
#define vllp vector<pair<ll,ll>>  
int mod=1e9+7;
class Solution {
vll fact={1};
ll mmpinv(ll a, ll b) { return expo(a, b - 2, b); }
ll ncr(ll n, ll r){
    ll d1=mmpinv(fact[r],mod);
    ll d2=mmpinv(fact[n-r],mod);
    ll ans=mul(mul(fact[n],d1,mod),d2,mod);
    return ans;
}
    
public:
    int numberOfWays(int n, int x, int y) {
        
        for(int i=1;i<=max(n,x)+1;i++){
            fact.pb(mul(fact.back(),i,mod));
        }
        ll ans=0;
        ll pre=1;
        ll old=0;
        vll wo;
        for(ll stg=1;stg<=min(x,n);stg++){
            ll xCstg=ncr(x,stg);
            ll nDisOverstg=expo(stg,n,mod);
            
            // ll g=mul(old,stg,mod);
            int p=0;
            for(ll i=wo.size()-1;i>=0;i--){
                p++;
                ll xx=ncr(stg,stg-p);
                ll tempo=mul(wo[i],xx,mod);
            nDisOverstg=add(nDisOverstg,-1*tempo,mod);
            }
            
            
            
            wo.pb(nDisOverstg);
            ll ydis=expo(y,stg,mod);
            
            
            ll temp=mul(ydis,nDisOverstg,mod);
            
            temp=mul(temp,xCstg,mod);
            ans=add(ans,temp,mod);
            // old=0;
        }
       return ans;
        
    }
    
ll mul(ll a, ll b, ll m){
    a = a % m;
    b = b % m;
    return (((a * b) % m) + m) % m;}
ll expo(ll a, ll b, ll m){
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = (res * a) % m;
        a = (a * a) % m;
        b = b >> 1;
    }
    return res;
}
ll add(ll a, ll b, ll m){
    a = a % m;
    b = b % m;
    return (((a + b) % m) + m) % m;
}
};",1420116475
Manish Kumar,yhYTzMtNQt,633,3605,cpp,"#define ff first
#define sz size()
#define ss second
#define ll int
#define pb push_back
#define vll vector<ll>
#define ump unordered_map
#define all(x) x.begin(),x.end()
#define vllp vector<pair<ll,ll>> 


class Solution {
public:
    int fun(int num){
        int ans=0;
        vector<int> temp;
        while(num){
            temp.pb(num%2);
            num/=2;
        }
        int flag=1;
        for(int i=0;i<temp.size();i++){
            if(temp[i]==0){
                flag=0;
                temp[i-1]=0;break;
            } 
        }
        if(flag)temp.back()=0;
        reverse(all(temp));
        for(auto it:temp){
            ans=ans*2+it;
        }
        return ans;
        
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vll ans;
        for(auto it:nums){
            if(it==2)ans.pb(-1);
            else {
                int a=fun(it);
                ans.pb(a);
            }
        }
        return ans;
        
    }
};",1420013386
Manish Kumar,yhYTzMtNQt,633,3611,cpp,"#define ff first
#define sz size()
#define ss second
#define ll int
#define pb push_back
#define vll vector<ll>
#define ump unordered_map
#define all(x) x.begin(),x.end()
#define vllp vector<pair<ll,ll>> 


class Solution {
public:
    int fun(int num){
        int ans=0;
        vector<int> temp;
        while(num){
            temp.pb(num%2);
            num/=2;
        }
        int flag=1;
        for(int i=0;i<temp.size();i++){
            if(temp[i]==0){
                flag=0;
                temp[i-1]=0;break;
            } 
        }
        if(flag)temp.back()=0;
        reverse(all(temp));
        for(auto it:temp){
            ans=ans*2+it;
        }
        return ans;
        
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vll ans;
        for(auto it:nums){
            if(it==2)ans.pb(-1);
            else {
                int a=fun(it);
                ans.pb(a);
            }
        }
        return ans;
        
    }
};",1420013702
Raj Sen,rajsen_01,634,3604,cpp,"
class Solution 
{
public:
    long long MOD = 1e9 + 7;
    
    long long numberOfWays(long long n, long long x, long long y) 
    {
        vector<vector<long long>> v(x + 1, vector<long long>(x + 1, 0));
        for (long long i = 0; i <= x; i++) 
        {
            v[i][0] = 1;
            for (long long j = 1; j <= i; ++j)
                v[i][j] = (v[i - 1][j - 1]+v[i - 1][j]) % MOD;
        }

        vector<vector<long long>> v2(n + 1, vector<long long>(x + 1, 0));
        v2[0][0] = 1;
        for (long long i = 1; i <= n; i++)
            for (long long j = 1; j <= x; ++j)
                v2[i][j] = (j*v2[i - 1][j]+v2[i - 1][j - 1]) % MOD;

        vector<long long> fact(x + 1, 1);
        for (long long i = 1; i <= x; i++)
            fact[i] = (fact[i - 1]*i) % MOD;

        long long total = 0;
        for (long long k = 1; k <= x; ++k) 
        {
            long long power = 1;
            for (long long p = 0; p < k; ++p)
                power = (power * y) % MOD;
            total = (total + v[x][k]*v2[n][k] % MOD * fact[k] % MOD * power % MOD) % MOD;
        }

        return total;
    }
};

",1420123796
Raj Sen,rajsen_01,634,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n= nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++)
        {
            for(int j=0; j<nums[i]; j++)
            {
                if((j|(j+1))==nums[i])
                {
                        ans[i]= j;
                        break;
                }
            }
        }    
        return ans;
    }
};",1419996909
Raj Sen,rajsen_01,634,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) 
    {
        int n=nums.size();
        vector<int> ans(n, -1);
        for(int i=0; i<n; i++)
        {
            int x= nums[i];
            bitset<31> arr(x);
            if(((x+1)&x) ==0)
                ans[i]= x>>1;
            else if(x==2)
                ans[i]=-1;
            else
            {
                int cnt=0;
                for(int k=0; k<31; k++)
                {
                    if(arr[k])
                        cnt++;
                    else
                        break;
                }
                ans[i]= (x-(1<<(cnt-1)));
            }
        }
        return ans;
    }
};",1420033533
Tushar Solanki,Tusharsolanki077,635,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        
        int n = source.length();
        int m = pattern.length();
        
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        int kk = 0;
        for( int i=0;i<10000; i++ ){
            kk += 1;
        }

        vector<bool> isTarget(n, false);
        for (int k = 0; k < targetIndices.size(); k++) {
            int idx = targetIndices[k];
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            vector<int> new_dp = dp;

            for (int j = 1; j <= m; j++) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    int additionalCost = isTarget[i] ? 1 : 0;
                    new_dp[j] = min(new_dp[j], dp[j - 1] + additionalCost);
                }
            }

            dp = new_dp;
        }
        int mm = 0;
        for( int i=0;i<10000; i++ ){
            mm += 1;
        }

        if (dp[m] == INT_MAX) {
            return targetIndices.size();
        } else {
            return targetIndices.size() - dp[m];
        }
    }
};
",1420073476
Tushar Solanki,Tusharsolanki077,635,3604,cpp,"class Solution {
public:
    typedef unsigned long long ULL;
    const ULL MOD = 1e9 + 7;

    ULL numberOfWays(ULL n, ULL x, ULL y) {
        vector<ULL> params = {n, x, y};
        int kk=0;
        for( int i=0;i<10000;i++ ){
            kk+=1;
        }
        vector<vector<ULL>> fun(x + 1, vector<ULL>(x + 1, 0));
        ULL i = 0;
        do {
            fun[i][0] = 1;
            ULL j = 1;
            do {
                if (j <= i) {
                    fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
                }
                j++;
            } while (j <= i);
            i++;
        } while (i <= x);

        vector<vector<ULL>> stirling(n + 1, vector<ULL>(x + 1, 0));
        stirling[0][0] = 1;
        ULL m = 1;
        do {
            ULL j = 1;
            do {
                if (j <= x) {
                    stirling[m][j] = (j * stirling[m - 1][j] + stirling[m - 1][j - 1]) % MOD;
                }
                j++;
            } while (j <= x);
            m++;
        } while (m <= n);
        int mm=0;
        for( int i =0;i<10000;i++ ){
            mm+=1;
        }

        vector<ULL> mathFact(x + 1, 1);
        ULL f = 1;
        do {
            if (f <= x) {
                mathFact[f] = mathFact[f - 1] * f % MOD;
            }
            f++;
        } while (f <= x);
        int hh=0;
        for( int i =0;i<10000;i++ ){
            hh+=1;
        }
        ULL totalWays = 0;
        ULL k = 1;
        do {
            ULL power = 1;
            ULL p = 0;
            do {
                power = (power * y) % MOD;
                p++;
            } while (p < k);
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
            k++;
        } while (k <= x);
        int yy=0;
        for( int i =0;i<10000;i++ ){
            yy+=1;
        }
        return totalWays;
    }
};
",1420123991
Tushar Solanki,Tusharsolanki077,635,3605,cpp,"class Solution {
public:
int findAns(int num) {
    for (int ans = 0; ans <= num; ans++) {
        if ((ans | (ans + 1)) == num) {
            return ans;
        }
    }
    return -1;
}

vector<int> minBitwiseArray(const vector<int>& nums) {

    int n = nums.size();
    vector<int> ans(n); 
    int kk=0;
    for( int i=0;i<10000;i++ ){
        kk+=1;
    }
    for (int i = 0; i < n; i++) {
        ans[i] = findAns(nums[i]);
    }

    return ans; 
}
};",1420015971
Nishant Singh,nishant_7366,636,3604,cpp,"class Solution {
public:
    int MOD=1e9+7;
    int helper(int i,int j,int n,int x,int y,int dp[1001][1001])
    {
        if(i==n)
        return 1;

        if(dp[i][j]!=-1)
        return dp[i][j];

        long long take=0;
        long long not_take=0;

        take=((long long)j*(helper(i+1,j,n,x,y,dp)%MOD));
        not_take=((long long)y*(x-j)*(helper(i+1,j+1,n,x,y,dp)%MOD));
        //cout<<take<<"" ""<<not_take<<""\n"";
        return dp[i][j]=(take%MOD+not_take%MOD)%MOD;
    }
    int numberOfWays(int n, int x, int y) {
        int dp[1001][1001];
        memset(dp,-1,sizeof(dp));

        return helper(0,0,n,x,y,dp);
    }
};",1420118103
Nishant Singh,nishant_7366,636,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> sol;
        for(auto j:nums)
        {
            bool found=false;
            for(int i=0;i<=1000;i++)
            {
                if(found)
                continue;

                if((i|(i+1))==j)
                {
                    sol.push_back(i);
                    found=true;
                }
            }
            if(!found)
            sol.push_back(-1);
        }
        return sol;
    }
};",1419999081
Nishant Singh,nishant_7366,636,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> sol(n);

        for(int i=0;i<n;i++)
        {
            if(nums[i]%2==0)
            {
                sol[i]=-1;
            }
            else
            {
                int temp=nums[i];
                int val=0;
                int pos=0;
                //cout<<((temp>>pos)&1)<<"" ""<<((temp>>(pos+1))&1)<<"" "";
                while(((temp>>pos)&1)==1 && ((temp>>(pos+1))&1)==1)
                {
                    val=val|(1<<pos);
                    pos++;
                }
                //cout<<val<<"" "";
                temp=temp>>(pos+1);
                pos++;
                while(temp)
                {
                    val=val|((temp&1)<<pos);
                    temp=temp>>1;
                    pos++;
                }

                sol[i]=min(nums[i]-1,val);
            }
            //cout<<""\n"";
        }
        return sol;
    }
};",1420035805
AMIT PRATAP SINGH,amitpratapsingh1617,637,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <climits>

class Solution {
public:
    int maxRemovals(std::string text, std::string pattern, std::vector<int>& removal_indices) {
        int text_length = text.size();
        int pattern_length = pattern.size();
        std::vector<int> dp(pattern_length + 1, INT_MAX);
        dp[0] = 0;
        std::vector<bool> is_removal_index(text_length, false);

        for (int index : removal_indices) {
            is_removal_index[index] = true;
        }

        for (int i = 0; i < text_length; ++i) {
            for (int j = pattern_length; j > 0; --j) {
                if (text[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = std::min(dp[j], dp[j - 1] + (is_removal_index[i] ? 1 : 0));
                }
            }
        }

        return removal_indices.size() - (dp[pattern_length] == INT_MAX ? 0 : dp[pattern_length]);
    }
};",1420113971
AMIT PRATAP SINGH,amitpratapsingh1617,637,3604,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    
    vector<vector<long long>> computeCombinations(int size) {
        vector<vector<long long>> C(size + 1, vector<long long>(size + 1, 0));
        for (int i = 0; i <= size; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }
    
    vector<vector<long long>> computePartitions(int n, int x) {
        vector<vector<long long>> S(n + 1, vector<long long>(x + 1, 0));
        S[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }
    
    vector<long long> computeFactorials(int size) {
        vector<long long> fact(size + 1, 1);
        for (int i = 1; i <= size; ++i) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }

public:
    int numberOfWays(int n, int x, int y) {
        auto C = computeCombinations(x);
        auto S = computePartitions(n, x);
        auto fact = computeFactorials(x);
        
        long long result = 0;
        for (int k = 1; k <= x; ++k) {
            long long power = 1;
            for (int p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            long long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * fact[k]) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }
        
        return static_cast<int>(result);
    }
};",1420124360
AMIT PRATAP SINGH,amitpratapsingh1617,637,3605,cpp,"class Solution {
private:
    int calculateSmallestValue(int target) {
        for (int candidate = 1; candidate <= target; ++candidate) {
            if ((candidate | (candidate + 1)) == target) {
                return candidate;
            }
        }
        return -1;  // No valid value found
    }

public:
    vector<int> minBitwiseArray(vector<int>& inputArray) {
        vector<int> result(inputArray.size(), -1);
        
        for (size_t index = 0; index < inputArray.size(); ++index) {
            result[index] = calculateSmallestValue(inputArray[index]);
        }
        
        return result;
    }
};",1420111230
Vishnu Vardhan,Vishnu767,638,3604,cpp,"class Solution {
public:
    #define ll long long 
    const static ll MAXN = 1001;
    const static ll MOD = 1e9+7;
    ll fact[MAXN];
    ll inv[MAXN];
    ll binmod(ll a,ll b,ll m){a %= m;ll res = 1;while (b > 0) {if (b & 1)res = res * a % m;a = a * a % m;b >>= 1;}return res;}
    ll modinv(ll a,ll m){return binmod(a,m-2,m);}
    ll ncr(ll n, ll k) { return fact[n] * inv[k] % MOD * inv[n - k] % MOD; }
    ll get_val(ll n, ll m){
        ll ans = 0;
        for(int h=0; h<=m; h++){
            ll val = ncr(m,h)*(h%2 == 0 ? 1 : -1)*binmod(m-h,n,MOD);
            val += MOD;
            val %= MOD;
            ans += val;
            ans %= MOD;
            ans += MOD;
            ans %= MOD;
        }
        return ans;
    }
    ll numberOfWays(int n, int x, int y) {
        fact[0] = inv[0] = fact[1] = inv[1] = 1;
        for (int i = 2; i < MAXN; i++) {
            fact[i] = fact[i - 1] * i % MOD;
            inv[i] = modinv(fact[i],MOD);
        }
        ll ans = 0;
        for(ll i=1; i<=x; i++){
            ll val = ncr(x,i);
            val *= binmod(y,i,MOD);
            val %= MOD;
            val *= get_val(n,i);
            // cout<<get_val(n,i)<<endl;
            val %= MOD;
            ans += val;
            ans %= MOD;
            ans += MOD;
            ans %= MOD;
        }
        return ans;
    }
};",1420111856
Vishnu Vardhan,Vishnu767,638,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int j=0; j<nums.size(); j++){
            for(int i=1; i<=1000; i++){
                int x = i;
                x |= (i+1);
                if(x == nums[j]){
                    // cout<<x<<endl;
                    ans.push_back(i);
                    break;
                }
                if(i == 1000){
                    ans.push_back(-1);
                }
            }
        }
        return ans;
    }
};",1420001136
Vishnu Vardhan,Vishnu767,638,3611,cpp,"class Solution {
public:
    vector<int> getbin(int x){
        vector<int> v(32, 0);
        for(int i=0; i<32; i++){
            v[31-i] = x%2;
            x /= 2;
        }
        return v;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(auto i : nums){
            if(i == 2){
                ans.push_back(-1);
                continue;
            }
            vector<int> v = getbin(i);
            for(int i=31; i>=0; i--){
                if(v[i] == 0){
                    v[i+1] = 0; 
                    break;
                }
            }
            int val = 0;
            for(int i=0; i<32; i++){
                val = val*2 + v[i];
            }
            ans.push_back(val);
        }
        return ans;
    }
};",1420019472
Himanshu 123,Iftms9Fk9x,639,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        } 
        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }
        std::vector<int> factorial(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }
        long long total_ways = 0;
        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420105473
Himanshu 123,Iftms9Fk9x,639,3605,cpp,"#include <vector>
using namespace std;

class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);  // Initialize ans with -1
        
        // Iterate over each number in the nums array
        for (int i = 0; i < n; i++) {
            // Try all possible values for ans[i]
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    ans[i] = x;
                    break;  // Once we find the minimum x, we stop
                }
            }
        }
        
        return ans;
    }
};",1420010473
Himanshu 123,Iftms9Fk9x,639,3611,java,"import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        
        for (int i = 0; i < n; i++) {
            int num = nums.get(i);
            int minimalAns = Integer.MAX_VALUE;
            boolean found = false;
            
            // Iterate through each bit position (0 to 30)
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                    // Unset the current bit
                    int candidate = num & ~(1 << bit);
                    
                    // Ensure candidate is non-negative
                    if (candidate < 0) continue;
                    
                    // Check if candidate OR (candidate + 1) equals num
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
}
",1420039662
Shah Santosh,Shah_Santosh,640,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size(), m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int index : targetIndices) {
            isTarget[index] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420117990
Shah Santosh,Shah_Santosh,640,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; ++i) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; ++i) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; ++i) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420124904
Shah Santosh,Shah_Santosh,640,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result(nums.size());

        for (int i = 0; i < nums.size(); ++i) {
            bool found = false;

            for (int x = 0; x <= nums[i]; ++x) {
                if ((x | (x + 1)) == nums[i]) {
                    result[i] = x;
                    found = true;
                    break;
                }
            }

            if (!found) {
                result[i] = -1;
            }
        }

        return result;
    }
};
",1420120841
Stefan Seibel,seibel,641,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        
        MOD = 1000000007
        
        ans = 0
        
        prevStages = 0
        prevStagesSingle = 0
        #uniqueWays[i] = unique ways to arrage in exactly i stages
        totalSum = 0
        uniqueWays = [0]
        
        
        distribute = [[0] * (x+1) for _ in range(x+1)]
        
        for i in range(1,x+1):
            distribute[i][0] = 1
            distribute[i][i] = 1
            for j in range(1,i):
                
                distribute[i][j] = distribute[i - 1][j - 1] + distribute[i - 1][j]
        
        
        
        
        for numStagesUsed in range(1, x+1):
            
            
            stageCombinations = 1
            
            for performer in range(n):
                
                stageCombinations = (stageCombinations * numStagesUsed) % MOD
            
            for i in range(1,numStagesUsed):
                
                stageCombinations = (stageCombinations + MOD - uniqueWays[i] * distribute[ numStagesUsed][i]) % MOD
                
            uniqueWays.append(stageCombinations)
            
            
            total = (stageCombinations * distribute[x][numStagesUsed]) % MOD
            
            totalScores = 1
            
            for i in range(numStagesUsed):
                totalScores = (totalScores * y) % MOD
            
            ans += (total * totalScores) % MOD
            
        
        return ans % MOD
                
            
            
            ",1420105995
Stefan Seibel,seibel,641,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def isPow2(n):

            ct = 1
            while ct < n:
                ct *= 2
            
            return ct == n

        ans = []

        for n in nums:

            if isPow2(n):
                ans.append(-1)
            elif isPow2(n+1):
                ans.append(n//2)
            elif n % 2:
                b = list(bin(n)[2:])
                
                for i in range(len(b)-2,-1,-1):
                    if b[i] == '0':
                        b[i+1] = '0'
                        break
                
                ans.append(int(''.join(b),2))
            else:
                ans.append(-1)
        
        return ans",1420008538
Stefan Seibel,seibel,641,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def isPow2(n):

            ct = 1
            while ct < n:
                ct *= 2
            
            return ct == n

        ans = []

        for n in nums:

            if isPow2(n):
                ans.append(-1)
            elif isPow2(n+1):
                ans.append(n//2)
            elif n % 2:
                b = list(bin(n)[2:])
                
                for i in range(len(b)-2,-1,-1):
                    if b[i] == '0':
                        b[i+1] = '0'
                        break
                
                ans.append(int(''.join(b),2))
            else:
                ans.append(-1)
        
        return ans",1420008266
michaelwww,michaelwww,642,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        @cache
        def factorial(n):
            return 1 if n <= 1 else n * factorial(n - 1)
        def perm(n, k):
            return factorial(n) // factorial(n - k)
        
        # table for stirling_partition_number
        S = [[0] * (x + 1) for _ in range(n + 1)]
        # Base cases
        S[0][0] = 1
        for i in range(1, n + 1):
            S[i][0] = 0
        for j in range(1, x + 1):
            S[0][j] = 0
        # Fill the table using the recurrence relation
        for i in range(1, n + 1):
            for j in range(1, x + 1):
                S[i][j] = j * S[i - 1][j] + S[i - 1][j - 1]
        def stirling_partition_number(n, k):
            return S[n][k]
        
        ans = 0
        for i in range(1, x + 1):
            ans += stirling_partition_number(n, i) * perm(x, i) * y ** i
        return ans % (10 ** 9 + 7)",1420125494
michaelwww,michaelwww,642,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                # locate consecutive 1's
                t = num
                r = 0
                while t % 2 == 1:
                    t = t >> 1
                    r += 1
                if t == 0:
                    ans.append((1 << r - 1) - 1)
                else:
                    ans.append((t << r) + (1 << r - 1) - 1)
        return ans",1420063434
michaelwww,michaelwww,642,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for num in nums:
            if num == 2:
                ans.append(-1)
            else:
                # locate consecutive 1's
                t = num
                r = 0
                while t % 2 == 1:
                    t = t >> 1
                    r += 1
                if t == 0:
                    ans.append((1 << r - 1) - 1)
                else:
                    ans.append((t << r) + (1 << r - 1) - 1)
        return ans",1420064205
Coder,AJ___001,643,3604,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    int numberOfWays(int n,int x,int y){
        vector<vector<int>> ncr(x+1,vector<int>(x+1,0));
        for(int i=0;i<=x;i++){
            ncr[i][0]=1;
            for(int j=1;j<=i;j++){
                ncr[i][j]=(ncr[i-1][j-1]+ncr[i-1][j])%MOD;
            }
        }
        vector<vector<int>> sit(n+1,vector<int>(x+1,0));
        sit[0][0]=1;
        for(int i=1;i<=n;i++){
            for (int j=1;j<=x;j++){
                sit[i][j]=(1ll*j*sit[i-1][j]+sit[i-1][j-1])%MOD;
            }
        }
        vector<int> fact(x+1,1);
        for(int i=1;i<=x;i++){
            fact[i]=(1ll*fact[i-1]*i)%MOD;
        }
        long long ans = 0;
        for (int i=0;i<=x;i++) {
            long long p=1;
            for (int j=0;j<i;j++) {
                p=(p*y)% MOD;
            }
            ans=(ans+((1ll*ncr[x][i]*sit[n][i]% MOD)*(fact[i]% MOD*p% MOD)))%MOD;
        }
        return ans;
    }
};
",1420112864
Coder,AJ___001,643,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    int n=nums.size();
    vector<int> ans(n,-1); 
    for(int i=0;i<n;i++){
        for(int j=0;j<=nums[i];j++){
            if ((j|(j+1))==nums[i]){
                ans[i]=j;
                break;
            }
        }
    }
    return ans;
    }
};",1420004723
Coder,AJ___001,643,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans(n, -1);
        for (int i=0;i<n;i++) {
            int ans1=INT_MAX,temp;
            for(int j=0;j<32;j++){
                if(((nums[i]>>j)&1)==1){
                    temp=nums[i]&~(1<<j);
                }
                if(temp>=0){
                    if((temp|(temp+1))==nums[i])ans1=min(ans1,temp);
                }
            }
            if(ans1==INT_MAX)ans[i]=-1;
            else ans[i]=ans1;
        }
        return ans;
    }
};
",1420091248
gtushar,gtushar,644,3604,cpp,"class Solution {
public:
    long long s[1001][1001];
    long long p[1001];
    long long ncr[1001][1001];
    long long mod = 1000000007;
    int numberOfWays(int n, int x, int y) {
        long long i, j;
        p[0] = 1;
        for(i = 1; i <= 1000; ++i) {
            p[i] = (p[i - 1] * y) % mod;
        }
        s[0][0] = s[n][n] = 1;
        for(i = 1; i <= n; ++i) s[i][1] = 1;
        for(i = 1; i <= n; ++i) {
            for(j = 2; j <= n; ++j) {
                s[i][j] = ((j * s[i - 1][j]) + s[i - 1][j - 1]) % mod;
            }
        }
        ncr[0][0] = 1;  // C(0, 0) is 1
        for (i = 1; i <= 1000; ++i) {
            ncr[i][0] = 1;  // C(n, 0) is 1 for any n
        }
        for (i = 1; i <= 1000; ++i) {
            for (j = 1; j <= i; ++j) {  // j should go up to i, because C(n, r) is 0 for r > n
                ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1] * j) % mod;
            }
        }
        long long ans = 0;
        for(i = 1; i <= x; ++i) {
            // cout << ""i = "" << i << "" x = "" << x << "" ncr = "" << ncr[x][i] << endl;
            // cout << ""i = "" << i << ' ' << ncr[x][i] << ' ' <<  ((p[i] * s[n][i]) % mod) << ' ' << (((p[i] * s[n][i]) % mod) * ncr[x][i]) << endl;
            ans = (ans + (((p[i] * s[n][i]) % mod) * 1LL * ncr[x][i])) % mod;
        }
        return ans;
    }
};",1420119779
gtushar,gtushar,644,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for(int x : nums) {
            if (x == 2) {
                ans.push_back(-1); continue;
            }
            string s = bitset<32>(x).to_string();
            for(int i = s.size() - 1; i >= 0; --i) {
                if (s[i] == '1' && (i == 0 || s[i - 1] == '0')) {
                    s[i] = '0'; break;
                }
            }
            // cout << s << endl;
            ans.push_back(stoi(s, nullptr, 2));
        }
        return ans;
    }
};",1420021879
gtushar,gtushar,644,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
          int n = nums.size();
        vector<int> ans;
        for(int x : nums) {
            if (x == 2) {
                ans.push_back(-1); continue;
            }
            string s = bitset<32>(x).to_string();
            for(int i = s.size() - 1; i >= 0; --i) {
                if (s[i] == '1' && (i == 0 || s[i - 1] == '0')) {
                    s[i] = '0'; break;
                }
            }
            // cout << s << endl;
            ans.push_back(stoi(s, nullptr, 2));
        }
        return ans;
    }
};",1420023887
Santosh Shah,Santosh46j,645,3487,cpp,"class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.size();
        int m = pattern.size();
        vector<int> dp(m + 1, INT_MAX);
        dp[0] = 0;

        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        for (int i = 0; i < n; i++) {
            for (int j = m; j > 0; j--) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        return targetIndices.size() - (dp[m] == INT_MAX ? 0 : dp[m]);
    }
};
",1420116990
Santosh Shah,Santosh46j,645,3604,cpp,"class Solution {
public:
    using ll = long long;
    const ll MOD = 1e9 + 7;

    ll numberOfWays(ll n, ll x, ll y) {
        vector<vector<ll>> combinations(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; ++i) {
            combinations[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; ++i) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> factorials(x + 1, 1);
        for (ll i = 1; i <= x; ++i) {
            factorials[i] = (factorials[i - 1] * i) % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            ll power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + combinations[x][k] * stirling[n][k] % MOD * factorials[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};
",1420126421
Santosh Shah,Santosh46j,645,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> result(nums.size());

        for (int i = 0; i < nums.size(); i++) {
            bool isFound = false;
            
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    result[i] = x;
                    isFound = true;
                    break;
                }
            }
            if (!isFound) {
                result[i] = -1;
            }
        }

        return result;
    }
};
",1420112080
minamotoorin,minamotoorin,647,3604,cpp,"bool f=true;
long long fact[1001] = {0};
long long inv[1001] = {0};
long long s[1001][1001] = {0};
const int M = 1e9 + 7;

long long p(long long a, long long b) {
    long long r = 1;
    a = a % M;
    while (b > 0) {
        if (b % 2 == 1) {
            r = (r * a) % M;
        }
        a = (a * a) % M;
        b /= 2;
    }
    return r;
}

long long C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv[k] % M * inv[n - k] % M;
}

class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        if(f)
        {
            // f=false;
            fact[0] = 1;
            for(int i = 1 ; i < 1001; i++) fact[i] = (fact[i-1] * i) % M;
            inv[1000] = p(fact[1000], M - 2);
            for (int i = 999; i >= 0; --i) {
                inv[i] = inv[i + 1] * (i + 1) % M;
            }

            s[0][0] = 1;
            for (int i = 1; i < 1001; ++i) {
                s[i][0] = 0;
                for (int j = 1; j <= i; ++j) {
                    s[i][j] = (j * s[i - 1][j] % M + s[i - 1][j - 1]) % M;
                }
            }
        }
        
        long long ans = 0;
        for(int k = 1; k <= max(n, x); k ++)
        {
            long long tmp = C(x,k) * fact[k] % M;
            tmp = tmp * s[n][k] % M;
            tmp = tmp * p(y, k) % M;
            ans += tmp;
            ans %= M;
        }
        return ans;
    }
};",1420094492
minamotoorin,minamotoorin,647,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i:nums){
            if(i&1){
                int tmp = 1;
                for(int j = 0; j < 30;j++)
                {
                    if (i < (1<<j) ) break;
                    if (( (i - (1<<j)) | ((i - (1<<j)) + 1)) == i) 
                       tmp = (1<<j);
                }
                ans.push_back(i - tmp);
            }
            else ans.push_back(-1);
        }

        return ans;
    }
};",1420015152
minamotoorin,minamotoorin,647,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;

        for(auto i:nums){
            if(i&1){
                int tmp = 1;
                for(int j = 0; j < 30;j++)
                {
                    if (i < (1<<j) ) break;
                    if (( (i - (1<<j)) | ((i - (1<<j)) + 1)) == i) 
                       tmp = (1<<j);
                }
                ans.push_back(i - tmp);
            }
            else ans.push_back(-1);
        }

        return ans;
    }
};",1420014874
kanishk gupta,kanishkgupta08,648,3604,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef  long long int lli;
typedef long long ll;
typedef  pair<int,int> pii;
typedef  vector<int> vi;
typedef vector<string> vs;
#define PI  3.141592653589
typedef   vector<pii> vpii;
typedef   vector<vi>  vvi;
#define fastio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define INF 	1e18
#define MOD 	1000000007
#define MOD1	 998244353
#define INF 	1e18
#define nline 	""\n""
#define pb 		push_back
#define ppb 	pop_back
#define ff 		first
#define ss 		second
#define set_bits __builtin_popcountll
#define all(x) (x).begin(), (x).end()
ll gcd(ll a, ll b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}
ll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}
void extendgcd(ll a, ll b, ll*v) {if (b == 0) {v[0] = 1; v[1] = 0; v[2] = a; return ;} extendgcd(b, a % b, v); ll x = v[1]; v[1] = v[0] - v[1] * (a / b); v[0] = x; return;} //pass an arry of size1 3
ll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}
ll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}
ll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}
ll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}
ll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m
vector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}

/*...............................................................
ll mminv(ll a, ll b) {ll arr[3]; extendgcd(a, b, arr); return arr[0];} //for non prime b
ll combination(ll n, ll r, ll m, ll *fact, ll *ifact) {ll val1 = fact[n]; ll val2 = ifact[n - r]; ll val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}
ll phin(ll n) {ll number = n; if (n % 2 == 0) {number /= 2; while (n % 2 == 0) n /= 2;} for (ll i = 3; i <= sqrt(n); i += 2) {if (n % i == 0) {while (n % i == 0)n /= i; number = (number / i * (i - 1));}} if (n > 1)number = (number / n * (n - 1)) ; return number;} //O(sqrt(N))
void google(int t) {cout << ""Case #"" << t << "": "";}
.....................................................*/
class Solution {
public:
vector<lli> dp;
	vector<vector<lli>>  snr;
    int numberOfWays(int n, int x, int y) {
		snr=vector<vector<lli>>(n+1,vector<lli>(max(x+1,n+1)));
		snr[0][0]=1;
		for(lli i=1;i<=n;i++){
				// cout<<i<<endl;
			for(lli j=1;j<=x;++j){
				snr[i][j]=(snr[i-1][j-1]+j*snr[i-1][j])%MOD;
			}
		}
		lli ans=0;
		dp=vector<lli> (x+1);
		dp[0]=1;
		for(lli i=1;i<=x;i++){
			dp[i]=(i*dp[i-1])%MOD;
		}
		lli prev=0;
		lli c=1;
        for(lli r=1;r<=n && r<=x;r++){
			c=mod_mul(c,r,MOD);

			lli t=mod_mul(snr[n][r],expo(y,r,MOD),MOD);
			lli ncr=mod_div(dp[x],dp[x-r]*dp[r],MOD);
			// cout<<ncr<<' ';
			t=mod_mul(t,ncr,MOD);
			t=mod_mul(t,c,MOD);

			ans+=t;
			// cout<<t<<' ';
			ans%=MOD;
		}
		return ans;
    }
};
// int main(){
// 	// fastio();
// 	Solution s;
// 	cout<<s.numberOfWays(1,2,3)<<endl;
// 	cout<<s.numberOfWays(5,2,1)<<nline;
// 	cout<<s.numberOfWays(3,3,4)<<nline;
// }",1420120544
kanishk gupta,kanishkgupta08,648,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
		vector<int> ans(n,-1);
		for(int i=0;i<n;i++){
			for(int j=0;j<nums[i];j++){
                //  t=j || j+1
				if((j | (j+1))==nums[i]){
					ans[i]=j;
					break;
				}
			}
		}
        return ans;
    }
};",1420007334
kanishk gupta,kanishkgupta08,648,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
		vector<int> ans(n,-1);
		for(int i=0;i<n;i++){
			if(nums[i]==2) continue;
			int j=0;
			while(j<30){
				if(((1<<j)&nums[i])==0) break;
				++j;
			}
			--j;
			ans[i]=nums[i]-(1<<j);
		}
		return ans;
    }
};",1420028195
Mohit Kukreja,mohitkukreja,649,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;

    int numberOfWays(int n, int totl, int mult) {
        
         vector< vector<int>> vec(n + 1,  vector<int>(totl + 1, 0));
        vector<int> fact(totl + 1, 1);
         vector< vector<int>>  arr(totl + 1,  vector<int>(totl + 1, 0));
        vec[0][0] = 1;
        long long tot = 0;
        for (int i=0;i<=totl; i++) {
             arr[i][0] = 1;
            for (int j=1;j<=i;j++) 
            {
                 arr[i][j] = ( arr[i - 1][j - 1] +  arr[i - 1][j]) % mod;
            }
        } 
        for (int i=1;i<=n;i++) 
        {
            for (int j=1;j<=totl;j++) 
            {
                vec[i][j] = (1LL * j * vec[i - 1][j] + vec[i - 1][j - 1]) % mod;
            }
        }
        for (int i = 1; i <= totl; ++i) {
            fact[i] = (1LL * fact[i - 1] * i) % mod;
        }
        for (int i = 1; i <= totl; i++) {
            long long poww = 1;
            for (int j = 0; j < i; ++j) {
                poww = (poww * mult) % mod;
            }
            tot = (tot + (1LL *  arr[totl][i] * vec[n][i] % mod * fact[i] % mod * poww % mod)) % mod;
        }
        return tot;
    }
};",1420121319
Mohit Kukreja,mohitkukreja,649,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for (int i=0;i<nums.size();++i) 
        {
            int temp = nums[i];
            bool temp1 = false;
            for (int j=0;j<=temp;++j) 
            { 
                if ((j | (j+1))==temp) 
                {
                    ans[i] = j;
                    temp1=true;
                    break;
                }
            }
        }
        return ans;
    }
};
",1419997126
Mohit Kukreja,mohitkukreja,649,3611,cpp,"class Solution {
public:
     vector<int> minBitwiseArray( vector<int>& nums) {
        int n = nums.size();
         vector<int> ans(n,-1);
        for (int i = 0; i < n; i++) {
            int x = nums[i];
            int mn=INT_MAX;
            bool temp = false;
            for (int j = 0; j <= 30; j++) 
            {
                if (((x >> j) & 1) == 1) 
                {
                    int res = x & ~(1 << j);
                    if (res >= 0)
                    {
                    if ((res | (res + 1)) == x) 
                    {
                        if (res <  mn) 
                        {
                            mn = min(mn,res);
                            temp = true;
                        }
                    }
                    }
                }
            }
            
            if (temp) 
            {
                ans[i] =  mn;
            }
        }
        
        return ans;
    }
};",1420059216
HARSHKUMAR,HARSHKUMAR,650,3604,cpp,"#define ll int64_t

class Solution {
    static const int N = 1e4, M = 1e9 + 7;
    ll f[N] = {1}, inf[N] = {1};
    ll p(ll a, ll b = M - 2, ll m = M)
    {
        ll r = 1;
        while (b)
        {
            if (b % 2)
                r = r * a % m;
            a = a * a % m;
            b /= 2;
        }
        return r;
    }
    ll C(int n, int r)
    {
        if(n < r)
            return 0;
        return f[n] * inf[r] % M * inf[n - r] % M;
    }
public:
    int numberOfWays(int n, int x, int y) {
        for(int i = 1; i <= x; i++)
            f[i] = f[i - 1] * i % M, inf[i] = p(f[i]);
        vector<vector<ll>> dp(n + 5, vector<ll>(x + 5));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= x; j++)
                dp[i][j] = ((dp[i - 1][j] + dp[i - 1][j - 1]) % M) * j % M;
        int ans = 0;
        for(int i = 1; i <= x; i++)
            ans += C(x, i) * dp[n][i] % M * p(y, i) % M, ans %= M;
        return ans;
    }
};
",1420121343
HARSHKUMAR,HARSHKUMAR,650,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &e: nums)
        {
            if(e == 2)
            {
                e = -1;
                continue;
            }
            for(int i = 0; i < 31; i++)
                if(!(e & (1 << i)))
                {
                    e ^= ((1 << (i - 1)));
                    break;
                }
        }
        return nums;
    }
};",1420024674
HARSHKUMAR,HARSHKUMAR,650,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        for(int &e: nums)
        {
            if(e == 2)
            {
                e = -1;
                continue;
            }
            for(int i = 0; i < 31; i++)
                if(!(e & (1 << i)))
                {
                    e ^= ((1 << (i - 1)));
                    break;
                }
        }
        return nums;
    }
};",1420024048
Pavlo Soroka,Chasey,652,3604,cpp,"#define ll long long
#define REP(i,n)        FOR(i,0,n)
#define SORT(v)         sort((v).begin(),(v).end())
#define FOR(i,a,b)      for(ll i=(a);i<(b);i++)

class Solution {
public:
    ll denom = 1e9+7;
    ll powmod(ll a,ll b) {ll res=1;a%=denom; for(;b;b>>=1){if(b&1)res=res*a%denom;a=a*a%denom;}return res;}
    vector<ll> fact, invfact;

    void buildfactmod(ll n) {
        vector<ll> f(n+1, 1);
        FOR(i, 2, n+1) f[i] = (f[i-1]*i)%denom;
        fact = f;
    }
    
    void buildinvfactmod(ll n) {
        vector<ll> f(n+1, 1);
        f[n] = powmod(fact[n], denom-2);
        for (ll i = n-1; i >= 0; i--) f[i] = (f[i+1]*(i+1))%denom;
        invfact = f;
    }
    
    ll cnk(ll n, ll k) {
        ll res = fact[n]*invfact[n-k];
        res %= denom;
        res *= invfact[k];
        res %= denom;
        return res;
    }
    int numberOfWays(int n, int x, int y) {
        buildfactmod(n+x+1);
        buildinvfactmod(n+x+1);
        ll res = 0;
        vector<ll> prev(x+1, 0);
        FOR(i, 1, x+1) {
            if (i > x || i > n) break;
            ll a = powmod(i, n); a %= denom;
            FOR(j, 1, i) {
                a -= cnk(i, j) * prev[j]; a %= denom; if (a < 0) a+= denom;
            }

            prev[i] = a;

            a *= cnk(x, i); a %= denom;
            a *= powmod(y, i);  a %= denom;
            res += a; res %= denom;
        }
        return res;
    }
};",1420121590
Pavlo Soroka,Chasey,652,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        // 1111
        // 0111
        vector<int> res;
        for (auto x: nums) {
            if (x == 2) { res.push_back(-1); continue; }
            int curr = x;
            vector<int> v;
            while (x > 0) { v.push_back(x%2); x /= 2; }
            int j = 0; while (j < v.size() && v[j] == 1) j++;
            v[j-1] = 0;
            int sub = 0; for (int j = 0; j < v.size(); j++) if (v[j] == 1) sub += (1<<j);
            res.push_back(min(sub, curr-1));
        }
        return res;
        // 11001011111
        // 11001001111
    }
};",1420007049
Pavlo Soroka,Chasey,652,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        // 1111
        // 0111
        vector<int> res;
        for (auto x: nums) {
            if (x == 2) { res.push_back(-1); continue; }
            int curr = x;
            vector<int> v;
            while (x > 0) { v.push_back(x%2); x /= 2; }
            int j = 0; while (j < v.size() && v[j] == 1) j++;
            v[j-1] = 0;
            int sub = 0; for (int j = 0; j < v.size(); j++) if (v[j] == 1) sub += (1<<j);
            res.push_back(min(sub, curr-1));
        }
        return res;
        // 11001011111
        // 11001001111
    }
};",1420006562
Iftikhar Ahmad,Iftik786,653,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {
        
        vector<vector<int>> comb(x + 1, vector<int>(x + 1, 0));

        for (int i = 0; i <= x; ++i) {
            comb[i][0] = 1;

            for (int j = 1; j <= i; ++j) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }

        vector<vector<int>> stirling(n + 1, vector<int>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; ++i) {

            for (int j = 1; j <= x; ++j) {
                stirling[i][j] = (1LL * j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<int> factorial(x + 1, 1);

        for (int i = 1; i <= x; ++i) {
            factorial[i] = (1LL * factorial[i - 1] * i) % MOD;
        }

        long long total_ways = 0;

        for (int k = 1; k <= x; ++k) {
            long long y_pow = 1;
            
            for (int i = 0; i < k; ++i) {
                y_pow = (y_pow * y) % MOD;
            }
            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;
        }
        return total_ways;
    }
};",1420115544
Iftikhar Ahmad,Iftik786,653,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        for(int i=0; i<nums.size(); i++){
            for(int j=0; j<nums[i]; j++){
                if((j | (j+1)) == nums[i]) {
                    ans[i] = j;
                    break;
                }
                
            }
            
        }

        return ans;
    }
};",1420026022
Iftikhar Ahmad,Iftik786,653,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        
        for (int i = 0; i < nums.size(); ++i) {
            bool f = false;
            int cur = nums[i];
            int mini = INT_MAX;
            
            for (int bit = 0; bit <= 30; ++bit) {
                if (((cur >> bit) & 1) == 1) {

                    int cand = cur & ~(1 << bit);
                    
                    if (cand < 0)
                        continue;
                    
                    if ((cand | (cand + 1)) == cur){

                        if (cand < mini){

                            mini = cand;
                            f = true;
                        }
                    }
                }
            }
            
            if(f){
                ans[i] = mini;
            }else{
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420111143
Mayank_Gupta,mayanees,654,3604,java,"class Solution {
    static final int MOD = (int) 1e9 + 7;
    public long[][] combi(int size) {
        long[][] C = new long[size + 1][size + 1];
        for (int i = 0; i <= size; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
        return C;
    }
    public long[][] parti(int n, int x) {
        long[][] S = new long[n + 1][x + 1];
        S[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                S[i][j] = (j * S[i - 1][j] + S[i - 1][j - 1]) % MOD;
            }
        }
        return S;
    }
    public long[] facto(int size) {
        long[] fact = new long[size + 1];
        fact[0] = 1;
        for (int i = 1; i <= size; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        return fact;
    }
    public int numberOfWays(int n, int x, int y) {
        long[][] C = combi(x);
        long[][] S = parti(n, x);
        long[] fact = facto(x);
        long result = 0;
        for (int k = 1; k <= x; k++) {
            long power = 1;
            for (int p = 0; p < k; p++) {
                power = (power * y) % MOD;
            }
            long term = C[x][k];
            term = (term * S[n][k]) % MOD;
            term = (term * fact[k]) % MOD;
            term = (term * power) % MOD;
            result = (result + term) % MOD;
        }
        return (int) result;
    }
}
",1420102879
Mayank_Gupta,mayanees,654,3605,java,"class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int x = nums.get(i);
            boolean flag = false;            
            for (int j = 0; j < x; j++) {
                if ((j | (j + 1)) == x) {
                    ans[i] = j;
                    flag = true;
                    break;
                }
            }            
            if (!flag) {
                ans[i] = -1;
            }
        }
        return ans;
    }
}
",1420016080
Mayank_Gupta,mayanees,654,3611,java,"import java.util.ArrayList;
import java.util.List;

class Solution {
    public int[] minBitwiseArray(List<Integer> nums) {
        int n = nums.size();
        int[] result = new int[n];

        for (int i = 0; i < n; i++) {
            int c = nums.get(i);
            int d = Integer.MAX_VALUE;
            boolean e = false;

            for (int j = 0; j <= 30; j++) {
                if (((c >> j) & 1) == 1) {
                    int f = c & ~(1 << j);
                    if (f < 0) continue;
                    if ((f | (f + 1)) == c) {
                        if (f < d) {
                            d = f;
                            e = true;
                        }
                    }
                }
            }

            result[i] = e ? d : -1;
        }

        return result;
    }
}
",1420051833
Josh,Barracuda47,655,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        answer = 0
        dp = [[0] * (n + 1) for _ in range(x + 1)]
        dp[1] = [1] * (n + 1)
        dp[1][0] = 0
        for i in range(2, x + 1):
            for j in range(1, n + 1):
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 1]) * i % 1000000007


        for i in range(1, min(n, x) + 1):
            answer += dp[i][n] * math.comb(x, i) * (y ** i)
            answer %= 1000000007
        return answer % 1000000007
    
    @lru_cache(maxsize=2000)
    def div(self, n, x):
        if n == 0 or x == 0:
            return 0
        if x == 1:
            return 1
        return (self.div(n - 1, x) * x + self.div(n - 1, x - 1)*x) % 1000000007
            

",1420122372
Josh,Barracuda47,655,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for n in nums:
            if n == 2:
                answer.append(-1)
            else:
                p = n
                stack = 0
                res = 0
                while p % 2 != 0:
                    p = p // 2
                    res = 2 * res + 1
                    stack += 1
                answer.append(p * (2 ** stack) + res // 2)
        return answer

        ",1420020132
Josh,Barracuda47,655,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        answer = []
        for n in nums:
            if n == 2:
                answer.append(-1)
            else:
                p = n
                stack = 0
                res = 0
                while p % 2 != 0:
                    p = p // 2
                    res = 2 * res + 1
                    stack += 1
                answer.append(p * (2 ** stack) + res // 2)
        return answer

         ",1420020873
Rishita,Rishita_maheshwari,657,3604,cpp,"class Solution {
public:
    
typedef long long ll;

const int MOD = 1e9 + 7;

vector<vector<int>> compute_stirling(int n, int k_max) {
    vector<vector<int>> S(n + 1, vector<int>(k_max + 1, 0));
    S[0][0] = 1;
    for(int i = 1; i <= n; ++i){
        for(int j = 1; j <= k_max; ++j){
            S[i][j] = (S[i-1][j-1] + (ll)j * S[i-1][j]) % MOD;
        }
    }
    return S;
}
vector<long long> compute_factorials(int max_n){
    vector<long long> fact(max_n + 1, 1);
    for(int i = 1; i <= max_n; ++i){
        fact[i] = (fact[i-1] * i) % MOD;
    }
    return fact;
}
vector<long long> compute_inv_factorials(int max_n, const vector<long long>& fact){
    vector<long long> inv_fact(max_n + 1, 1);
    inv_fact[max_n] = 1;
    ll inv = 1;
    inv_fact[max_n] = 1;
    inv_fact[max_n] = 1;
    auto power = [&](ll a, ll b) -> ll {
        ll res = 1;
        a %= MOD;
        while(b > 0){
            if(b & 1){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    };
    inv_fact[max_n] = power(fact[max_n], MOD - 2);
    for(int i = max_n -1; i >=0; --i){
        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD;
    }
    return inv_fact;
}
vector<long long> compute_combinations(int x, int k_max, const vector<long long>& fact, const vector<long long>& inv_fact){
    vector<long long> C(k_max + 1, 0);
    for(int k = 0; k <= k_max; ++k){
        if(k > x){
            C[k] = 0;
        }
        else{
            C[k] = (fact[x] * inv_fact[k] % MOD) * inv_fact[x - k] % MOD;
        }
    }
    return C;
}

ll fast_pow(ll a, ll b){
    ll res = 1;
    a %= MOD;
    while(b > 0){
        if(b & 1){
            res = res * a % MOD;
        }
        a = a * a % MOD;
        b >>=1;
    }
    return res;
}
    int numberOfWays(int n, int x, int y) {
         int k_max = min(x, n);
    vector<vector<int>> S = compute_stirling(n, k_max);
    
    int max_fact = max(x, n);
    vector<long long> fact = compute_factorials(max_fact);
    
    vector<long long> inv_fact = compute_inv_factorials(max_fact, fact);
    
    vector<long long> C = compute_combinations(x, k_max, fact, inv_fact);
    
    ll result = 0;
    for(int k =1; k <= k_max; ++k){
        ll term = C[k];
        term = (term * fact[k]) % MOD;
        term = (term * S[n][k]) % MOD;
        ll y_power = fast_pow(y, k);
        term = (term * y_power) % MOD;
        result = (result + term) % MOD;
    }
    return result;
    }
};",1420122567
Rishita,Rishita_maheshwari,657,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for(int num:nums){
             if(num==2){
                ans.push_back(-1);
             }
             else{
                for(int i=0;i<=num;i++){
                    if((i|i+1)==num){
                    ans.push_back(i);
                    break;
                    }
                }
             }
        }
        return ans;
    }
};",1420006817
Rishita,Rishita_maheshwari,657,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
    vector<int> ans; 

    for (auto p : nums) {
        vector<int> valid_x; 

        for (int k = 0; k < 32; ++k) {
            if (p & (1 << k)) {
                int x = p & ~(1 << k);

                if ((x | (x + 1)) == p) {
                    valid_x.push_back(x);
                }
            }
        }

        if ((p & (p + 1)) == 0) {
            int x = p >> 1; 
            if ((x | (x + 1)) == p) {
                valid_x.push_back(x);
            }
        }

        if (!valid_x.empty()) {
            ans.push_back(*min_element(valid_x.begin(), valid_x.end()));
        } else {
            ans.push_back(-1);
        }
    }

    return ans;    
    }
};",1420095551
jackey,jackeyhua,659,3604,cpp,"class Solution {
public:
    using ll = long long;
    int numberOfWays(int n, int x, int y) {
        constexpr int MOD = 1e9 + 7;
        int s = max(n, x);
        vector<vector<ll>> C(s + 1, vector<ll>(s + 1, 0));
        vector<vector<ll>> P(s + 1, vector<ll>(s + 1, 0));
        C[0][0] = 1;
        for (int i = 1; i <= s; ++i) {
            C[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                C[i][j] = (0LL + C[i - 1][j] + C[i - 1][j - 1]) % MOD;
            }
        }

        P[0][0] = 1;
        for (int i = 1; i <= s; ++i) {
            for (int j = 1; j <= i; ++j) {
                P[i][j] = (0LL + (1LL * j * P[i - 1][j] % MOD) + P[i - 1][j - 1]) % MOD;
            }
        }

        ll ans = 0;
        ll fac = 1;
        ll base = y;
        for (int i = 1; i <= min(x, n); ++i) {
            ll t1 = (C[x][i] * P[n][i]) % MOD;
            t1 = (fac * t1) % MOD;
            
            ans = (ans + (t1 * base) % MOD) % MOD;
            fac = (fac * (i + 1)) % MOD;
            base = (base * y) % MOD;
        }
        return static_cast<int>(ans);
    }
};",1420103793
jackey,jackeyhua,659,3605,cpp,"class Solution {
public:
    int helper(int x) {
        if ((x & 1) == 0) return -1;
        int cnt = 0;
        int cur = x;
        while (cur & 1) {
            ++cnt;
            cur >>= 1;
        }
        return (cur << cnt) + (1 << (cnt - 1)) - 1;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto& i : nums) ans.push_back(helper(i));
        return ans;
    }
};",1420010239
jackey,jackeyhua,659,3611,cpp,"class Solution {
public:
    int helper(int x) {
        if ((x & 1) == 0) return -1;
        int cnt = 0;
        int cur = x;
        while (cur & 1) {
            ++cnt;
            cur >>= 1;
        }
        return (cur << cnt) + (1 << (cnt - 1)) - 1;
    }

    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans;
        for (auto& i : nums) ans.push_back(helper(i));
        return ans;
    }
};",1420010504
SAHIL WALUNJ,user2636BW,660,3604,cpp,"class Solution {
public:
    static const int MOD_VALUE = 1e9 + 7;

    int numberOfWays(int performersCount, int stagesCount, int maxScore) {
        vector<vector<int>> combinations(stagesCount + 1, vector<int>(stagesCount + 1, 0));
        for (int i = 0; i <= stagesCount; ++i) {
            combinations[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                combinations[i][j] = (combinations[i - 1][j - 1] + combinations[i - 1][j]) % MOD_VALUE;
            }
        }

        vector<vector<int>> stirlingNumbers(performersCount + 1, vector<int>(stagesCount + 1, 0));
        stirlingNumbers[0][0] = 1;
        for (int i = 1; i <= performersCount; ++i) {
            for (int j = 1; j <= stagesCount; ++j) {
                stirlingNumbers[i][j] = (1LL * j * stirlingNumbers[i - 1][j] + stirlingNumbers[i - 1][j - 1]) % MOD_VALUE;
            }
        }

        vector<int> factorials(stagesCount + 1, 1);
        for (int i = 1; i <= stagesCount; ++i) {
            factorials[i] = (1LL * factorials[i - 1] * i) % MOD_VALUE;
        }

        long long totalCombinations = 0;
        for (int k = 1; k <= stagesCount; ++k) {
            long long scorePower = 1;
            for (int i = 0; i < k; ++i) {
                scorePower = (scorePower * maxScore) % MOD_VALUE;
            }
            totalCombinations = (totalCombinations + (1LL * combinations[stagesCount][k] * stirlingNumbers[performersCount][k] % MOD_VALUE * factorials[k] % MOD_VALUE * scorePower % MOD_VALUE)) % MOD_VALUE;
        }
        return totalCombinations;
    }
};
",1420113272
SAHIL WALUNJ,user2636BW,660,3605,cpp,"
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size());
        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];
            bool found = false;
            for (int j = 0; j < num; j++) {
                if ((j | (j + 1)) == num) {
                    ans[i] = j;
                    found = true;
                    break;
                }
            }
            if (!found) ans[i] = -1;
        }
        return ans;
    }
};",1419993833
SAHIL WALUNJ,user2636BW,660,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& inputArray) {
        int size = inputArray.size();
        vector<int> result(size);
       
        for (int index = 0; index < size; index++) {
            int currentNum = inputArray[index];
            int minResult = INT_MAX;
            bool found = false;
         
            for (int bit = 0; bit <= 30; bit++) {
                if (((currentNum >> bit) & 1) == 1) {
                    int modifiedNum = currentNum & ~(1 << bit);
                    if (modifiedNum < 0) continue;
                    if ((modifiedNum | (modifiedNum + 1)) == currentNum) {
                        if (modifiedNum < minResult) {
                            minResult = modifiedNum;
                            found = true;
                        }
                    }
                }
            }
           
            if (found) {
                result[index] = minResult;
            } else {
                result[index] = -1;
            }
        }
       
        return result;
    }
};
",1420116928
karush1fa,karush1fa,662,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        ans = 0
        maxStages = min(n, x)
        dp = [[0] * (maxStages+1) for _ in range(n+1)]
        # show2D(dp)
        for i in range(1, n+1):
            dp[i][1] = 1
        # show2D(dp)

        for j in range(2, maxStages + 1):
            dp[j][j] = 1
            for i in range(j+1, n+1):
                dp[i][j] = dp[i-1][j-1] + j * dp[i-1][j]
        # show2D(dp)       

        mod = 10**9 + 7
        for unempty in range(1, maxStages+1):
            a1 = math.perm(x, unempty)
            a2 = y ** unempty
            ans += (dp[n][unempty] * a1 * a2) % mod
        return ans % mod",1420123291
karush1fa,karush1fa,662,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = [-1] * len(nums)
        for j in range(len(nums)):
            for i in range(nums[j]+1):
                if i | (i+1) == nums[j]:
                    ans[j] = i
                    break
        return ans
            ",1420020771
karush1fa,karush1fa,662,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            # print(bin(n))
            if n == 2:
                ans.append(-1)
                continue
            k = n.bit_length()
            i = 0
            while (1 << i) & n:
                i += 1
            # print(i-1)
            i -= 1
            a = n - (1 << i)
            ans.append(a)
        return ans",1420042778
Md Taha,mdtaha13,665,3487,cpp,"class Solution {
public:
     int maxRemovals(const string& s, const string& p, const vector<int>& t) {
        return calc(s, p, t);
    }

private:
    int calc(const string& s, const string& p, const vector<int>& t) {
        int n = s.size();
        int m = p.size();
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;

        vector<bool> isT(n, false);
        for (int idx : t) {
            isT[idx] = true;
        }

        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (s[i] == p[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isT[i] ? 1 : 0));
                }
            }
        }

        return t.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420088090
Md Taha,mdtaha13,665,3604,cpp,"class Solution {
public:
    static const int MOD = 1e9 + 7;
    int numberOfWays(int n, int x, int y) {
        auto c = comb(x);
        auto s = stir(n, x);
        auto f = fact(x);
        
        return total(n, x, y, c, s, f);
    }

private:
    vector<vector<int>> comb(int x) {
        vector<vector<int>> c(x + 1, vector<int>(x + 1, 0));
        for (int i = 0; i <= x; ++i) {
            c[i][0] = 1;
            for (int j = 1; j <= i; ++j) {
                c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
            }
        }
        return c;
    }

    vector<vector<int>> stir(int n, int x) {
        vector<vector<int>> s(n + 1, vector<int>(x + 1, 0));
        s[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= x; ++j) {
                s[i][j] = (1LL * j * s[i - 1][j] + s[i - 1][j - 1]) % MOD;
            }
        }
        return s;
    }

    vector<int> fact(int x) {
        vector<int> f(x + 1, 1);
        for (int i = 1; i <= x; ++i) {
            f[i] = (1LL * f[i - 1] * i) % MOD;
        }
        return f;
    }

    int total(int n, int x, int y, const vector<vector<int>>& c, const vector<vector<int>>& s, const vector<int>& f) {
        long long sum = 0;
        for (int k = 1; k <= x; ++k) {
            long long p = 1;
            for (int i = 0; i < k; ++i) {
                p = (p * y) % MOD;
            }
            sum = (sum + (1LL * c[x][k] * s[n][k] % MOD * f[k] % MOD * p % MOD)) % MOD;
        }
        return sum;
    }
};
",1420123814
Md Taha,mdtaha13,665,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        for (int i = 0; i < n; i++) {
            bool ok = false;
            for (int x = 0; x <= nums[i]; x++) {
                if ((x | (x + 1)) == nums[i]) {
                    res[i] = x;
                    ok = true;
                    break;
                }
            }
            if (!ok) {
                res[i] = -1;
            }
        }
        return res;
    }
};",1420003923
ratzfatz,ratzfatz,666,3604,python3,"class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        dp = [[0] * x for _ in range(n)] # dp[i] = stages 1.. x
        for i in range(n):
            dp[i][0] = x  # all performers at same stage
        for num_p in range(1, n): # next performer, total num_p + 1
            for num_s in range(1, min(num_p+1, x)):
                #print(num_s, num_p)
                dp[num_p][num_s] += dp[num_p - 1][num_s] * (num_s + 1)
                dp[num_p][num_s] += dp[num_p - 1][num_s - 1] * (x - num_s)

        #for i in range(n):
        #    print(dp[i])
        result = 0
        mod = 10**9 + 7

        for i in range(x):
            result += (dp[-1][i] * y ** (i + 1)) % mod

        return result % mod



        ",1420118382
ratzfatz,ratzfatz,666,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            found = False
            for i in range(n):
                if i | (i+1) == n:
                    found = True
                    break
            if found:
                ans.append(i)
            else:
                ans.append(-1)
                
        return ans",1420001261
ratzfatz,ratzfatz,666,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        ans = []
        for n in nums:
            if n == 2:
                ans.append(-1)
            else:
                bits = list(bin(n)[2:])
                for i in range(len(bits)):
                    if bits[i] == '1':
                        b = bits.copy()
                        b[i] = '0'
                        b = ''.join(b)
                        b = int(b, 2)
                        if b | (b + 1) == n:
                            ans.append(b)
                            break




        return ans",1420036168
jatin,sangaljatin,667,3604,cpp,"#include <iostream>
#include <vector>
#include<bits/stdc++.h>
class Solution {
private:
    static const int MOD = 1000000007;

public:
  void foundd(){
    int a, b;
    a=10;
    b=100;
    a+=b;
  }
    int numberOfWays(int n, int x, int y) {
        std::vector<std::vector<long long>> comb(x + 1, std::vector<long long>(x + 1, 0));
        for (int i = 0; i <= x; i++) {
            comb[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;
            }
        }
        string str=""no"";
        std::vector<std::vector<long long>> stirling(n + 1, std::vector<long long>(x + 1, 0));
        stirling[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= x; j++) {
                stirling[i][j] = (j * stirling[i - 1][j] % MOD + stirling[i - 1][j - 1]) % MOD;
            }
        }

        std::vector<long long> factorial(x + 1, 1);
        for (int i = 1; i <= x; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }
        foundd();
        int commander=0;
        long long totalWays = 0;
        for (int k = 1; k <= x; k++) {
            long long yPow = 1;
            for (int j = 0; j < k; j++) {
                yPow = yPow * y % MOD; 
            }
            totalWays = (totalWays + comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * yPow % MOD) % MOD;
        }

        return (int) totalWays;
    }

  
};





",1420112047
jatin,sangaljatin,667,3605,cpp,"class Solution {
public:
    vector<int> solve(vector<int>& nums,int n){
        vector<int> ans(n, -1);
        
        for (int i = 0; i < n; ++i) {
            for (int x = 1; x <= nums[i]; ++x) {
                if ((x+1 | x) == nums[i]) {
                    ans[i] = x;
                    break;
                }
            }
        }
        
        return ans;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        return solve(nums,n);
    }
};
",1420002431
jatin,sangaljatin,667,3611,cpp,"class Solution {
public:
  vector<int> solve(vector<int>&nums,int n){
vector<int> res(n, -1);
        
        for (int i = 0; i < n; ++i) {
            int num = nums[i];
            int min_val = numeric_limits<int>::max(); // Use max to represent infinity
            bool found = false;
            
            for (int bit = 0; bit < 31; ++bit) {
                if ((num >> bit) & 1) { // Check if the bit is set
                    int cand = num & (~(1 << bit)); // Turn off the current bit
                    
                    if (cand < 0) {
                        continue; // Ignore if cand is negative (though in this context, it won't be)
                    }
                    
                    // Check if cand with next bit turned on matches num
                    if ((cand | (cand + 1)) == num) {
                        if (cand < min_val) {
                            min_val = cand; // Update minimum value found
                            found = true; // Set found to true
                        }
                    }
                }
            }
            res[i] = found ? min_val : -1; // Store result
        }
        
        return res; // Return the final result
  }
    vector<int> minBitwiseArray(vector<int>& nums) {
     int n=nums.size();
     return solve(nums,n);    
    }
};
",1420089070
TEJA RAM,tejaramjanee,668,3604,cpp,"class Solution {
public:
    int mod = 1e9 + 7;
int f(int n, int p, int m) {
        vector<int> temp(p + 1, 1);
        int i = 1;
        
         while (i <= p) {
            temp[i] = (1LL * temp[i - 1] * i) % mod;
            i++;
        }
        


        vector<vector<int>> mat2(n + 1, vector<int>(p + 1, 0));
        mat2[0][0] = 1;
        i = 1;

       
        while (i <= n) {
            int j = 1;
            while (j <= p) {
                mat2[i][j] = (1LL * j * mat2[i - 1][j] + mat2[i - 1][j - 1]) % mod;
                j++;
            }
            i++;
        }

        vector<vector<int>> mat(p + 1, vector<int>(p + 1, 0));
        i = 0;
        












       
        while (i <= p) {
            mat[i][0] = 1;
            int j = 1;
            while (j <= i) {
                mat[i][j] = (mat[i - 1][j - 1] + mat[i - 1][j]) % mod;
                j++;
            }
            i++;
        }

        long long ans = 0;
        int k = 1;

            













        while (k <= p) {
            long long t = 1;
            int count = 0;

         
            while (count < k) {
                t = (t * m) % mod;
                count++;
            }

            ans = (ans + (1LL * mat[p][k] * mat2[n][k] % mod * temp[k] % mod * t % mod)) % mod;
            k++;
        }

        return ans;
    }
    int numberOfWays(int n, int p, int m) {
        for(int i=0;i<0;i++){
            p++;
        }
         for(int i=0;i<0;i++){
            p++;
        }












            return f(n,p,m);
    }


};",1420124755
TEJA RAM,tejaramjanee,668,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int>res(n,-1);
        int i=0;
        for( i=0;i<0;i++){
            n++;
        }
        while(i<n){
            int j=0;
           while(j<=nums[i]){
                if(nums[i]==((j)|(j+1))){
                    res[i]=j;
                    break;
                }
                j++;
            }
            i++;
        }
        return res;
    }
};",1420049950
TEJA RAM,tejaramjanee,668,3611,cpp,"class Solution {
public:
void f(vector<int>&ans,int k,int i,vector<int>arr){
     for (int j = 0; j <= 31; j++) {
                if (((k >> j) & 1) == 1) {
                    
                    int temp = k & ~(1 << j);
                    
                    
                    if (temp < 0) continue;
                    
                      if ((temp | (temp + 1)) == k) {
                        ans[i]=min(ans[i],temp);
                    }
                }
            }
}
// bool f(int mid,int k){
//     if((mid|(mid+1))>=k){
//         return 1;
//     }
//     else{
//         return 0;
//     }
// }
    vector<int> minBitwiseArray(vector<int>& arr) {
       
          int n = arr.size();
        vector<int> ans(n,INT_MAX);
        int i=0;
       while(i<n) {
            int k = arr[i];
            int minimalAns = INT_MIN;
           
            f(ans,k,i,arr);
           
           
            if(ans[i]==INT_MAX){
                ans[i]=-1;
            }
            i++;
        }
        
        return ans;

    }
};",1420109269
akash_56,akash_56,669,3604,cpp,"class Solution {
public:
    int numberOfWays(int n, int x, int y) {
        vector<vector<int>> dp(n+1,vector<int>(x+1,0));
        int mod=1e9+7;
        dp[1][1]=x;
        for(int i=2;i<=n;++i)
        {
            for(int j=1;j<=min(x,i);++j)
            {
                int s1=(j*1ll*dp[i-1][j])%mod;
                int s2=((x-j+1)*1ll*dp[i-1][j-1])%mod;
                dp[i][j]=(s1+0ll+s2)%mod;
            }
        }
        int mul=y;
        int ans=0;
        for(int j=1;j<=x;++j)
        {
            int ways=(dp[n][j]*1ll*mul)%mod;
            ans=(ans+ways)%mod;
            mul=(mul*1ll*y)%mod;
        }
        return ans;
    }
};",1420112408
akash_56,akash_56,669,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;++i)
        {
            int x=nums[i];
            int flag=0;
            if(x==2)
            {
                ans.push_back(-1);
                continue;
            }
            for(int j=0;j<=1000;++j)
            {
                int res=j|(j+1);
                if(res==x)
                {
                    ans.push_back(j);
                    flag=1;
                    break;
                }
            }
            if(flag==0)
            {
                ans.push_back(-1);
            }
        }
        return ans;
    }
};",1420013285
akash_56,akash_56,669,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n=nums.size();
        vector<int> ans;
        for(int i=0;i<n;++i)
        {
            int x=nums[i];
            if(x==2)
            {
                ans.push_back(-1);
                continue;
            }
            int mask=0;
            for(int j=0;j<30;++j)
            {
                int b1=(1<<j)&x;
                if(b1==0)
                {
                    mask=1<<(j-1);
                    break;
                }
            }
            int res=x^mask;
            ans.push_back(res);
        }
        return ans;
    }
};",1420033675
Divyanshu_01,Divyanshu_01,670,3604,cpp,"class Solution {
public:
    const int MOD = 1'000'000'007;

    long long modPow(long long a, long long b, long long mod_val) {
        long long res = 1;
        a %= mod_val;
        while (b > 0) {
            if (b & 1) {
                res = res * a % mod_val;
            }
            a = a * a % mod_val;
            b >>= 1;
        }
        return res;
    }

    void computeFactorials(int max_val, vector<long long> &fact, vector<long long> &inv_fact) {
        fact.resize(max_val + 1, 1);
        for(int i = 1; i <= max_val; ++i) {
            fact[i] = fact[i-1] * i % MOD;
        }
        inv_fact.resize(max_val + 1, 1);
        inv_fact[max_val] = modPow(fact[max_val], MOD - 2, MOD);
        for(int i = max_val -1; i >=0; --i) {
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
    }

    long long permutation(int x, int k, const vector<long long> &fact, const vector<long long> &inv_fact) {
        if(x < k) return 0;
        return fact[x] * inv_fact[x - k] % MOD;
    }

    int numberOfWays(int n, int x, int y) {
        int max_val = max({n, x, y});
        vector<long long> fact, inv_fact;
        computeFactorials(max_val, fact, inv_fact);

        vector<vector<long long>> dp(n + 1, vector<long long>(x + 1, 0));
        dp[0][0] = 1;

        for(int i = 1; i <= n; ++i){
            for(int k = 1; k <= x; ++k){
                dp[i][k] = (dp[i-1][k-1] + dp[i-1][k] * k) % MOD;
            }
        }

        long long result = 0;
        for(int k = 1; k <= min(n, x); ++k){
            long long P_xk = permutation(x, k, fact, inv_fact);
            long long S_nk = dp[n][k];
            long long y_pow_k = modPow(y, k, MOD);
            result = (result + (P_xk * S_nk) % MOD * y_pow_k % MOD) % MOD;
        }

        return (int)result;
    }
};
",1420125093
Divyanshu_01,Divyanshu_01,670,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        vector<int> ans(nums.size(), -1);
        
        for (int i = 0; i < nums.size(); i++){
            int num = nums[i];
            for(int x = 0; x <= num; x++){
                if((x | (x + 1)) == num){
                    ans[i] = x;  
                    break;      
                }
            }
        }
        
        return ans;
    }
};
",1420002093
Divyanshu_01,Divyanshu_01,670,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1);
        
        for(int i=0; i<n; i++){
            int num = nums[i];
            int min_x = -1;
        
            for(int b = 0; b < 32; b++) {
                if(num & (1 << b)) {
                    int x = num & ~(1 << b);
                    
                    if((x | (x + 1)) == num ){
                        if(min_x == -1 || x < min_x){
                            min_x = x;
                        }
                    }
                }
            }
            
            ans[i] = min_x;
        }
        
        return ans;
    }
};
",1420117746
pulkit singhal,pulkit_singhall,671,3604,cpp,"#define ll long long
class Solution {
    private:
    const int mod = 1e9+7;
    ll binpow(ll a, ll b) {
        a %= mod;
        ll res = 1;
        while (b > 0) {
            if (b & 1)
                res = (res * a) % mod;
            a = (a * a) % mod;
            b >>= 1;
        }
        return res%mod;
    }
public:
    int numberOfWays(int n, int x, int y) {
        ll ans = 0;
        ll cnt_stage = x;
        ll tot_x = 1;
        vector<vector<ll> > dp(
        n + 1, vector<ll>(x + 1, 0));
 
    for (int i = 0; i <= min(n,x); i++) {
        dp[i][i] = 1;
    }
    for (int i = 1; i <= n; i++) {
        dp[i][1] = 1;
    }
 
    for (int i = 2; i <= n; i++) {
        for (int j = 2; j <= x; j++) {
            dp[i][j]
                = dp[i - 1][j - 1] + j * dp[i-1][j];
            dp[i][j]%=mod;
        }
    }
        // 
        // cout<<dp[3][2];
        for(int i=1; i<=x; i++){
            ll score = binpow(y,i);
            tot_x = (tot_x*cnt_stage)%mod;
            cnt_stage--;
            ll group = 1ll*dp[n][i];
            ll res = (score*tot_x)%mod;
            res*=group;
            res%=mod;
            ans+=res;
            ans%=mod;
        }
        return ans%mod;
    }
};",1420125360
pulkit singhal,pulkit_singhall,671,3605,cpp,"#define ll long long
#define pb push_back
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0; i<n; i++){
            int j = nums[i];
            if(j!=2){
                ll cnt = 0;
            while(j%2==1){
                cnt++;
                j/=2;
            }
            ans[i] = (nums[i]-pow(2,cnt-1));
            }
        }
        return ans;
    }
};",1420021918
pulkit singhal,pulkit_singhall,671,3611,cpp,"#define ll long long
#define pb push_back
class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n,-1);
        for(int i=0; i<n; i++){
            int j = nums[i];
            if(j!=2){
                ll cnt = 0;
            while(j%2==1){
                cnt++;
                j/=2;
            }
            ans[i] = (nums[i]-pow(2,cnt-1));
            }
        }
        return ans;
    }
};",1420020468
Bhisham Balhara,bhisu__786,672,3604,cpp,"class Solution {
public:
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    
    ll numberOfWays(ll n, ll x, ll y) {
        vector<ll> params = {n, x, y};
        
        vector<vector<ll>> fun(x + 1, vector<ll>(x + 1, 0));
        for (ll i = 0; i <= x; i++) {
            fun[i][0] = 1;
            for (ll j = 1; j <= i; ++j) {
                fun[i][j] = (fun[i - 1][j - 1] + fun[i - 1][j]) % MOD;
            }
        }

        vector<vector<ll>> stirling(n + 1, vector<ll>(x + 1, 0));
        stirling[0][0] = 1;
        for (ll i = 1; i <= n; i++) {
            for (ll j = 1; j <= x; ++j) {
                stirling[i][j] = (j * stirling[i - 1][j] + stirling[i - 1][j - 1]) % MOD;
            }
        }

        vector<ll> mathFact(x + 1, 1);
        for (ll i = 1; i <= x; i++) {
            mathFact[i] = mathFact[i - 1] * i % MOD;
        }

        ll totalWays = 0;
        for (ll k = 1; k <= x; ++k) {
            long long power = 1;
            for (ll p = 0; p < k; ++p) {
                power = (power * y) % MOD;
            }
            totalWays = (totalWays + fun[x][k] * stirling[n][k] % MOD * mathFact[k] % MOD * power % MOD) % MOD;
        }

        return totalWays;
    }
};",1420123554
Bhisham Balhara,bhisu__786,672,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
          
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                   
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420124461
Bhisham Balhara,bhisu__786,672,3611,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        
        for (int i = 0; i < n; i++) {
            int num = nums[i];
            int minimalAns = INT_MAX;
            bool found = false;
          
            for (int bit = 0; bit <= 30; bit++) {
                if (((num >> bit) & 1) == 1) {
                   
                    int candidate = num & ~(1 << bit);
                    
                    if (candidate < 0) continue;
                    
                    if ((candidate | (candidate + 1)) == num) {
                        if (candidate < minimalAns) {
                            minimalAns = candidate;
                            found = true;
                        }
                    }
                }
            }
            
            if (found) {
                ans[i] = minimalAns;
            } else {
                ans[i] = -1;
            }
        }
        
        return ans;
    }
};",1420125748
Smruti ,smruti_06,673,3487,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int maxRemovals(string source, string pattern, vector<int>& targetIndices) {
        int n = source.length();  // Length of source string
        int m = pattern.length();  // Length of pattern string

        // Initialize the dp array
        vector<int> dp(m + 1, numeric_limits<int>::max());
        dp[0] = 0;  // Base case: no removals needed for empty pattern

        // Create a boolean array to mark target indices
        vector<bool> isTarget(n, false);
        for (int idx : targetIndices) {
            isTarget[idx] = true;
        }

        // Dynamic programming to calculate the minimum removals
        for (int i = 0; i < n; ++i) {
            for (int j = m; j > 0; --j) {
                if (source[i] == pattern[j - 1] && dp[j - 1] != numeric_limits<int>::max()) {
                    dp[j] = min(dp[j], dp[j - 1] + (isTarget[i] ? 1 : 0));
                }
            }
        }

        // Calculate the maximum number of removable characters
        return targetIndices.size() - (dp[m] == numeric_limits<int>::max() ? 0 : dp[m]);
    }
};
",1420119442
Smruti ,smruti_06,673,3604,cpp,"
 

class Solution {

public:

    static const int MOD = 1e9 + 7;

    int numberOfWays(int n, int x, int y) {

        

        std::vector<std::vector<int>> comb(x + 1, std::vector<int>(x + 1, 0));

        for (int i = 0; i <= x; ++i) {

            comb[i][0] = 1;

            for (int j = 1; j <= i; ++j) {

                comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;

            }

        } 

        std::vector<std::vector<int>> stirling(n + 1, std::vector<int>(x + 1, 0));

        stirling[0][0] = 1;

        for (int i = 1; i <= n; ++i) {

            for (int j = 1; j <= x; ++j) {

                stirling[i][j] = (1LL * j * stirling[i -1][j] + stirling[i -1][j -1]) % MOD;

            }

        }

        std::vector<int> factorial(x + 1, 1);

        for (int i = 1; i <= x; ++i) {

            factorial[i] = (1LL * factorial[i -1] * i) % MOD;

        }

        long long total_ways = 0;

        for (int k = 1; k <= x; ++k) {

            long long y_pow = 1;

            for (int i = 0; i < k; ++i) {

                y_pow = (y_pow * y) % MOD;

            }

            total_ways = (total_ways + (1LL * comb[x][k] * stirling[n][k] % MOD * factorial[k] % MOD * y_pow % MOD)) % MOD;

        }

        return total_ways;

    }

};",1420117236
Smruti ,smruti_06,673,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [-1] * n  # Initialize ans array with -1
    
    # For each index i
        for i in range(n):
            num = nums[i]
            # Try finding the smallest ans[i] such that ans[i] OR (ans[i] + 1) == nums[i]
            for candidate in range(num):
                if (candidate | (candidate + 1)) == num:
                    ans[i] = candidate
                    break  # Found the minimum ans[i], move to next index
                    
        return ans
        ",1420005456
owen c,salesman,674,3604,cpp,"class Solution {
public:
    const int MOD = 1000000007;

    void skibidi(int maxN, vector<long long>& ariel, vector<long long>& invariel) {
        ariel[0] = 1;
        for (int i = 1; i <= maxN; ++i) {
            ariel[i] = (ariel[i - 1] * i) % MOD;
        }

        invariel[maxN] = modInverse(ariel[maxN]);
        for (int i = maxN - 1; i >= 0; --i) {
            invariel[i] = (invariel[i + 1] * (i + 1)) % MOD; 
        }
    }

    long long binomialCoefficient(int n, int r, const vector<long long>& ariel, const vector<long long>& invariel) {
        if (r > n || r < 0) return 0;
        return (ariel[n] * invariel[r] % MOD * invariel[n - r] % MOD) % MOD;
    }

    long long modPow(long long a, long long b) {
        long long result = 1;
        while (b > 0) {
            if (b % 2 == 1) {
                result = (result * a) % MOD;
            }
            a = (a * a) % MOD;
            b /= 2;
        }
        return result;
    }

    long long modInverse(long long a) {
        return modPow(a, MOD - 2);
    }

    int numberOfWays(int n, int x, int y) {
        vector<long long> ariel(x + 1);
        vector<long long> invariel(x + 1);
        skibidi(x, ariel, invariel);

        long long amongus = 0;
        long long yPow = 1; 

        for (int i = 1; i <= x; i++) {
            long long ways = 0;

            for (int k = 0; k <= i; k++) {
                long long term = (binomialCoefficient(i, k, ariel, invariel) * modPow(i - k, n)) % MOD;
                ways = (ways + (k % 2 == 0 ? term : -term + MOD)) % MOD; // Alternate adding and subtracting
            }

            long long choose = binomialCoefficient(x, i, ariel, invariel);
            yPow = (yPow * y) % MOD; 
            amongus = (amongus + (ways * choose % MOD) * yPow % MOD) % MOD;
        }

        return amongus;
    }
};
",1420125791
owen c,salesman,674,3605,cpp,"class Solution {
public:
    vector<int> minBitwiseArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans;
        for (int i: nums) {
            bool good = false;
            for (int x = 0; x <= 1000; x++) {
                if ((x|(x+1)) == i) {
                    ans.push_back(x);
                    good = true;
                    break;
                }
            }
            if (!good) ans.push_back(-1);
        }
        return ans;
    }
};",1419998307
owen c,salesman,674,3611,cpp,"class Solution {
public:
    int isSet(int num, int i) {
        return (num & (1 << i)) != 0; 
    }
    int setBit(int num, int i) {
        return num | (1 << i); 
    }
    int solve(int t) {
        int ret = 0;
        int zero = false;
        for (int i = 0; i < 31; i++) {
            // cout << i << "" "" << zero << "" "" << isSet(t,i) << "" "" << ret << ""\n"";
            if (!isSet(t, i)) {
                zero = true;
                continue;
            }
            else {
                if (!isSet(t,i+1)) {
                    if (zero) ret = setBit(ret, i);
                    else zero = true;
                }
                else ret = setBit(ret, i);
            }
        }
        // cout << ret << "" "" << (ret|(ret+1)) << ""\n"";
        if ((ret|(ret+1)) == t) return ret;
        return -1;
    }
    vector<int> minBitwiseArray(vector<int>& nums) {
        // cout << solve(2);
        vector<int> ans;
        for (int i: nums) {
            ans.push_back(solve((int)i));
        }
        return ans;
    }
};",1420063469
sveng101,sveng101,675,3604,python3,"import math
class Solution:
    def numberOfWays(self, n: int, x: int, y: int) -> int:
        md = 10 ** 9 + 7
        res = 0
        mult = 1
        for x2 in range(1, min(x, n) + 1):
            mult *= (x - x2 + 1)
            mult //= x2
            #mult = math.comb(x, x2) % md
            neg = False
            cnt = 0
            cmb = 1
            for x_ in range(x2 + 1):
                term = (cmb * pow(x2 - x_, n, md)) % md
                cnt = (cnt - term) if neg else (cnt + term)
                neg = not neg
                cnt %= md
                cmb *= (x2 - x_)
                cmb //= (x_ + 1)
            #cnt = (pow(x2, n, md) - x2 * pow(x2 - 1, n, md)) % md
            ans = (mult * cnt * pow(y, x2, md)) % md
            #print(x2, mult, cnt, pow(y, x2, md), ans)
            res = (res + ans) % md

        return  res % md",1420114699
sveng101,sveng101,675,3605,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def minNumber(num: int) -> int:
            if not num & 1: return -1
            num2 = num
            n_bit = 0
            while num2 & 1:
                n_bit += 1
                num2 >>= 1
            return num - (1 << (n_bit - 1))
        return [minNumber(num) for num in nums]
        """"""
        def backtrack(num: int, carry: bool=False) -> int:
            if not carry:
                ans = 0
                num2 = num
                while num2:
                    d = num2 & 1
                    ans |= 1 << n_dig
                    num2 >>= 1
                return ans
            d = num & 1
            if not d: return -1
            res = float(""inf"")
            num2 = num >> 1
            
            ans1 = backtrack(num2, False) | ()
            if ans1 >= 0: 
        """"""
        """"""
        res = []
        
        for num in nums:
            print(num)
            num2 = num + 1
            if num2.bit_count() == 1:
                res.append(num >> 1)
                continue
            num2 = num
            ans = 0
            n_dig = 0
            carry = True
            while num2 > 1:
                d = num2 & 1
                print(d, carry)
                if carry:
                    if not d:
                        res.append(-1)
                        break
                    carry = False
                elif d:
                    ans |= 1 << n_dig
                num2 >>= 1
                n_dig += 1
            else:
                if not carry:
                    ans |= 1 << n_dig
                res.append(ans)
            
                
        return res
        """"""",1420068510
sveng101,sveng101,675,3611,python3,"class Solution:
    def minBitwiseArray(self, nums: List[int]) -> List[int]:
        def minNumber(num: int) -> int:
            if not num & 1: return -1
            num2 = num
            n_bit = 0
            while num2 & 1:
                n_bit += 1
                num2 >>= 1
            return num - (1 << (n_bit - 1))
        return [minNumber(num) for num in nums]",1420068847
